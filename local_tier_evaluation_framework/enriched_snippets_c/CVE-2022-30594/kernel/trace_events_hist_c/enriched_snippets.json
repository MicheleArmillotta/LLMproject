[
  {
    "function_name": "register_trigger_hist_enable_disable_cmds",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
    "lines": "6474-6486",
    "snippet": "__init int register_trigger_hist_enable_disable_cmds(void)\n{\n\tint ret;\n\n\tret = register_event_command(&trigger_hist_enable_cmd);\n\tif (WARN_ON(ret < 0))\n\t\treturn ret;\n\tret = register_event_command(&trigger_hist_disable_cmd);\n\tif (WARN_ON(ret < 0))\n\t\tunregister_trigger_hist_enable_disable_cmds();\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include \"tracing_map.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct event_command trigger_hist_enable_cmd = {\n\t.name\t\t\t= ENABLE_HIST_STR,\n\t.trigger_type\t\t= ETT_HIST_ENABLE,\n\t.parse\t\t\t= event_enable_trigger_parse,\n\t.reg\t\t\t= event_enable_register_trigger,\n\t.unreg\t\t\t= event_enable_unregister_trigger,\n\t.unreg_all\t\t= hist_enable_unreg_all,\n\t.get_trigger_ops\t= hist_enable_get_trigger_ops,\n\t.set_filter\t\t= set_trigger_filter,\n};",
      "static struct event_command trigger_hist_disable_cmd = {\n\t.name\t\t\t= DISABLE_HIST_STR,\n\t.trigger_type\t\t= ETT_HIST_ENABLE,\n\t.parse\t\t\t= event_enable_trigger_parse,\n\t.reg\t\t\t= event_enable_register_trigger,\n\t.unreg\t\t\t= event_enable_unregister_trigger,\n\t.unreg_all\t\t= hist_enable_unreg_all,\n\t.get_trigger_ops\t= hist_enable_get_trigger_ops,\n\t.set_filter\t\t= set_trigger_filter,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "unregister_trigger_hist_enable_disable_cmds",
          "args": [],
          "line": 6483
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_trigger_hist_enable_disable_cmds",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "6468-6472",
          "snippet": "static __init void unregister_trigger_hist_enable_disable_cmds(void)\n{\n\tunregister_event_command(&trigger_hist_enable_cmd);\n\tunregister_event_command(&trigger_hist_disable_cmd);\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct event_command trigger_hist_enable_cmd = {\n\t.name\t\t\t= ENABLE_HIST_STR,\n\t.trigger_type\t\t= ETT_HIST_ENABLE,\n\t.parse\t\t\t= event_enable_trigger_parse,\n\t.reg\t\t\t= event_enable_register_trigger,\n\t.unreg\t\t\t= event_enable_unregister_trigger,\n\t.unreg_all\t\t= hist_enable_unreg_all,\n\t.get_trigger_ops\t= hist_enable_get_trigger_ops,\n\t.set_filter\t\t= set_trigger_filter,\n};",
            "static struct event_command trigger_hist_disable_cmd = {\n\t.name\t\t\t= DISABLE_HIST_STR,\n\t.trigger_type\t\t= ETT_HIST_ENABLE,\n\t.parse\t\t\t= event_enable_trigger_parse,\n\t.reg\t\t\t= event_enable_register_trigger,\n\t.unreg\t\t\t= event_enable_unregister_trigger,\n\t.unreg_all\t\t= hist_enable_unreg_all,\n\t.get_trigger_ops\t= hist_enable_get_trigger_ops,\n\t.set_filter\t\t= set_trigger_filter,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct event_command trigger_hist_enable_cmd = {\n\t.name\t\t\t= ENABLE_HIST_STR,\n\t.trigger_type\t\t= ETT_HIST_ENABLE,\n\t.parse\t\t\t= event_enable_trigger_parse,\n\t.reg\t\t\t= event_enable_register_trigger,\n\t.unreg\t\t\t= event_enable_unregister_trigger,\n\t.unreg_all\t\t= hist_enable_unreg_all,\n\t.get_trigger_ops\t= hist_enable_get_trigger_ops,\n\t.set_filter\t\t= set_trigger_filter,\n};\nstatic struct event_command trigger_hist_disable_cmd = {\n\t.name\t\t\t= DISABLE_HIST_STR,\n\t.trigger_type\t\t= ETT_HIST_ENABLE,\n\t.parse\t\t\t= event_enable_trigger_parse,\n\t.reg\t\t\t= event_enable_register_trigger,\n\t.unreg\t\t\t= event_enable_unregister_trigger,\n\t.unreg_all\t\t= hist_enable_unreg_all,\n\t.get_trigger_ops\t= hist_enable_get_trigger_ops,\n\t.set_filter\t\t= set_trigger_filter,\n};\n\nstatic __init void unregister_trigger_hist_enable_disable_cmds(void)\n{\n\tunregister_event_command(&trigger_hist_enable_cmd);\n\tunregister_event_command(&trigger_hist_disable_cmd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "ret < 0"
          ],
          "line": 6482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "register_event_command",
          "args": [
            "&trigger_hist_disable_cmd"
          ],
          "line": 6481
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_event_command",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_trigger.c",
          "lines": "365-382",
          "snippet": "__init int unregister_event_command(struct event_command *cmd)\n{\n\tstruct event_command *p, *n;\n\tint ret = -ENODEV;\n\n\tmutex_lock(&trigger_cmd_mutex);\n\tlist_for_each_entry_safe(p, n, &trigger_commands, list) {\n\t\tif (strcmp(cmd->name, p->name) == 0) {\n\t\t\tret = 0;\n\t\t\tlist_del_init(&p->list);\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n out_unlock:\n\tmutex_unlock(&trigger_cmd_mutex);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/security.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(trigger_commands);",
            "static DEFINE_MUTEX(trigger_cmd_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/security.h>\n\nstatic LIST_HEAD(trigger_commands);\nstatic DEFINE_MUTEX(trigger_cmd_mutex);\n\n__init int unregister_event_command(struct event_command *cmd)\n{\n\tstruct event_command *p, *n;\n\tint ret = -ENODEV;\n\n\tmutex_lock(&trigger_cmd_mutex);\n\tlist_for_each_entry_safe(p, n, &trigger_commands, list) {\n\t\tif (strcmp(cmd->name, p->name) == 0) {\n\t\t\tret = 0;\n\t\t\tlist_del_init(&p->list);\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n out_unlock:\n\tmutex_unlock(&trigger_cmd_mutex);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "ret < 0"
          ],
          "line": 6479
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct event_command trigger_hist_enable_cmd = {\n\t.name\t\t\t= ENABLE_HIST_STR,\n\t.trigger_type\t\t= ETT_HIST_ENABLE,\n\t.parse\t\t\t= event_enable_trigger_parse,\n\t.reg\t\t\t= event_enable_register_trigger,\n\t.unreg\t\t\t= event_enable_unregister_trigger,\n\t.unreg_all\t\t= hist_enable_unreg_all,\n\t.get_trigger_ops\t= hist_enable_get_trigger_ops,\n\t.set_filter\t\t= set_trigger_filter,\n};\nstatic struct event_command trigger_hist_disable_cmd = {\n\t.name\t\t\t= DISABLE_HIST_STR,\n\t.trigger_type\t\t= ETT_HIST_ENABLE,\n\t.parse\t\t\t= event_enable_trigger_parse,\n\t.reg\t\t\t= event_enable_register_trigger,\n\t.unreg\t\t\t= event_enable_unregister_trigger,\n\t.unreg_all\t\t= hist_enable_unreg_all,\n\t.get_trigger_ops\t= hist_enable_get_trigger_ops,\n\t.set_filter\t\t= set_trigger_filter,\n};\n\n__init int register_trigger_hist_enable_disable_cmds(void)\n{\n\tint ret;\n\n\tret = register_event_command(&trigger_hist_enable_cmd);\n\tif (WARN_ON(ret < 0))\n\t\treturn ret;\n\tret = register_event_command(&trigger_hist_disable_cmd);\n\tif (WARN_ON(ret < 0))\n\t\tunregister_trigger_hist_enable_disable_cmds();\n\n\treturn ret;\n}"
  },
  {
    "function_name": "unregister_trigger_hist_enable_disable_cmds",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
    "lines": "6468-6472",
    "snippet": "static __init void unregister_trigger_hist_enable_disable_cmds(void)\n{\n\tunregister_event_command(&trigger_hist_enable_cmd);\n\tunregister_event_command(&trigger_hist_disable_cmd);\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include \"tracing_map.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct event_command trigger_hist_enable_cmd = {\n\t.name\t\t\t= ENABLE_HIST_STR,\n\t.trigger_type\t\t= ETT_HIST_ENABLE,\n\t.parse\t\t\t= event_enable_trigger_parse,\n\t.reg\t\t\t= event_enable_register_trigger,\n\t.unreg\t\t\t= event_enable_unregister_trigger,\n\t.unreg_all\t\t= hist_enable_unreg_all,\n\t.get_trigger_ops\t= hist_enable_get_trigger_ops,\n\t.set_filter\t\t= set_trigger_filter,\n};",
      "static struct event_command trigger_hist_disable_cmd = {\n\t.name\t\t\t= DISABLE_HIST_STR,\n\t.trigger_type\t\t= ETT_HIST_ENABLE,\n\t.parse\t\t\t= event_enable_trigger_parse,\n\t.reg\t\t\t= event_enable_register_trigger,\n\t.unreg\t\t\t= event_enable_unregister_trigger,\n\t.unreg_all\t\t= hist_enable_unreg_all,\n\t.get_trigger_ops\t= hist_enable_get_trigger_ops,\n\t.set_filter\t\t= set_trigger_filter,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "unregister_event_command",
          "args": [
            "&trigger_hist_disable_cmd"
          ],
          "line": 6471
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_event_command",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_trigger.c",
          "lines": "365-382",
          "snippet": "__init int unregister_event_command(struct event_command *cmd)\n{\n\tstruct event_command *p, *n;\n\tint ret = -ENODEV;\n\n\tmutex_lock(&trigger_cmd_mutex);\n\tlist_for_each_entry_safe(p, n, &trigger_commands, list) {\n\t\tif (strcmp(cmd->name, p->name) == 0) {\n\t\t\tret = 0;\n\t\t\tlist_del_init(&p->list);\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n out_unlock:\n\tmutex_unlock(&trigger_cmd_mutex);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/security.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(trigger_commands);",
            "static DEFINE_MUTEX(trigger_cmd_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/security.h>\n\nstatic LIST_HEAD(trigger_commands);\nstatic DEFINE_MUTEX(trigger_cmd_mutex);\n\n__init int unregister_event_command(struct event_command *cmd)\n{\n\tstruct event_command *p, *n;\n\tint ret = -ENODEV;\n\n\tmutex_lock(&trigger_cmd_mutex);\n\tlist_for_each_entry_safe(p, n, &trigger_commands, list) {\n\t\tif (strcmp(cmd->name, p->name) == 0) {\n\t\t\tret = 0;\n\t\t\tlist_del_init(&p->list);\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n out_unlock:\n\tmutex_unlock(&trigger_cmd_mutex);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct event_command trigger_hist_enable_cmd = {\n\t.name\t\t\t= ENABLE_HIST_STR,\n\t.trigger_type\t\t= ETT_HIST_ENABLE,\n\t.parse\t\t\t= event_enable_trigger_parse,\n\t.reg\t\t\t= event_enable_register_trigger,\n\t.unreg\t\t\t= event_enable_unregister_trigger,\n\t.unreg_all\t\t= hist_enable_unreg_all,\n\t.get_trigger_ops\t= hist_enable_get_trigger_ops,\n\t.set_filter\t\t= set_trigger_filter,\n};\nstatic struct event_command trigger_hist_disable_cmd = {\n\t.name\t\t\t= DISABLE_HIST_STR,\n\t.trigger_type\t\t= ETT_HIST_ENABLE,\n\t.parse\t\t\t= event_enable_trigger_parse,\n\t.reg\t\t\t= event_enable_register_trigger,\n\t.unreg\t\t\t= event_enable_unregister_trigger,\n\t.unreg_all\t\t= hist_enable_unreg_all,\n\t.get_trigger_ops\t= hist_enable_get_trigger_ops,\n\t.set_filter\t\t= set_trigger_filter,\n};\n\nstatic __init void unregister_trigger_hist_enable_disable_cmds(void)\n{\n\tunregister_event_command(&trigger_hist_enable_cmd);\n\tunregister_event_command(&trigger_hist_disable_cmd);\n}"
  },
  {
    "function_name": "hist_enable_unreg_all",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
    "lines": "6431-6444",
    "snippet": "static void hist_enable_unreg_all(struct trace_event_file *file)\n{\n\tstruct event_trigger_data *test, *n;\n\n\tlist_for_each_entry_safe(test, n, &file->triggers, list) {\n\t\tif (test->cmd_ops->trigger_type == ETT_HIST_ENABLE) {\n\t\t\tlist_del_rcu(&test->list);\n\t\t\tupdate_cond_flag(file);\n\t\t\ttrace_event_trigger_enable_disable(file, 0);\n\t\t\tif (test->ops->free)\n\t\t\t\ttest->ops->free(test->ops, test);\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include \"tracing_map.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "test->ops->free",
          "args": [
            "test->ops",
            "test"
          ],
          "line": 6441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_event_trigger_enable_disable",
          "args": [
            "file",
            "0"
          ],
          "line": 6439
        },
        "resolved": true,
        "details": {
          "function_name": "trace_event_trigger_enable_disable",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_trigger.c",
          "lines": "460-478",
          "snippet": "int trace_event_trigger_enable_disable(struct trace_event_file *file,\n\t\t\t\t       int trigger_enable)\n{\n\tint ret = 0;\n\n\tif (trigger_enable) {\n\t\tif (atomic_inc_return(&file->tm_ref) > 1)\n\t\t\treturn ret;\n\t\tset_bit(EVENT_FILE_FL_TRIGGER_MODE_BIT, &file->flags);\n\t\tret = trace_event_enable_disable(file, 1, 1);\n\t} else {\n\t\tif (atomic_dec_return(&file->tm_ref) > 0)\n\t\t\treturn ret;\n\t\tclear_bit(EVENT_FILE_FL_TRIGGER_MODE_BIT, &file->flags);\n\t\tret = trace_event_enable_disable(file, 0, 1);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/security.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/security.h>\n\nint trace_event_trigger_enable_disable(struct trace_event_file *file,\n\t\t\t\t       int trigger_enable)\n{\n\tint ret = 0;\n\n\tif (trigger_enable) {\n\t\tif (atomic_inc_return(&file->tm_ref) > 1)\n\t\t\treturn ret;\n\t\tset_bit(EVENT_FILE_FL_TRIGGER_MODE_BIT, &file->flags);\n\t\tret = trace_event_enable_disable(file, 1, 1);\n\t} else {\n\t\tif (atomic_dec_return(&file->tm_ref) > 0)\n\t\t\treturn ret;\n\t\tclear_bit(EVENT_FILE_FL_TRIGGER_MODE_BIT, &file->flags);\n\t\tret = trace_event_enable_disable(file, 0, 1);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_cond_flag",
          "args": [
            "file"
          ],
          "line": 6438
        },
        "resolved": true,
        "details": {
          "function_name": "update_cond_flag",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_trigger.c",
          "lines": "519-538",
          "snippet": "void update_cond_flag(struct trace_event_file *file)\n{\n\tstruct event_trigger_data *data;\n\tbool set_cond = false;\n\n\tlockdep_assert_held(&event_mutex);\n\n\tlist_for_each_entry(data, &file->triggers, list) {\n\t\tif (data->filter || event_command_post_trigger(data->cmd_ops) ||\n\t\t    event_command_needs_rec(data->cmd_ops)) {\n\t\t\tset_cond = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (set_cond)\n\t\tset_bit(EVENT_FILE_FL_TRIGGER_COND_BIT, &file->flags);\n\telse\n\t\tclear_bit(EVENT_FILE_FL_TRIGGER_COND_BIT, &file->flags);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/security.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/security.h>\n\nvoid update_cond_flag(struct trace_event_file *file)\n{\n\tstruct event_trigger_data *data;\n\tbool set_cond = false;\n\n\tlockdep_assert_held(&event_mutex);\n\n\tlist_for_each_entry(data, &file->triggers, list) {\n\t\tif (data->filter || event_command_post_trigger(data->cmd_ops) ||\n\t\t    event_command_needs_rec(data->cmd_ops)) {\n\t\t\tset_cond = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (set_cond)\n\t\tset_bit(EVENT_FILE_FL_TRIGGER_COND_BIT, &file->flags);\n\telse\n\t\tclear_bit(EVENT_FILE_FL_TRIGGER_COND_BIT, &file->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_rcu",
          "args": [
            "&test->list"
          ],
          "line": 6437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "test",
            "n",
            "&file->triggers",
            "list"
          ],
          "line": 6435
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void hist_enable_unreg_all(struct trace_event_file *file)\n{\n\tstruct event_trigger_data *test, *n;\n\n\tlist_for_each_entry_safe(test, n, &file->triggers, list) {\n\t\tif (test->cmd_ops->trigger_type == ETT_HIST_ENABLE) {\n\t\t\tlist_del_rcu(&test->list);\n\t\t\tupdate_cond_flag(file);\n\t\t\ttrace_event_trigger_enable_disable(file, 0);\n\t\t\tif (test->ops->free)\n\t\t\t\ttest->ops->free(test->ops, test);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "hist_enable_get_trigger_ops",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
    "lines": "6413-6429",
    "snippet": "static struct event_trigger_ops *\nhist_enable_get_trigger_ops(char *cmd, char *param)\n{\n\tstruct event_trigger_ops *ops;\n\tbool enable;\n\n\tenable = (strcmp(cmd, ENABLE_HIST_STR) == 0);\n\n\tif (enable)\n\t\tops = param ? &hist_enable_count_trigger_ops :\n\t\t\t&hist_enable_trigger_ops;\n\telse\n\t\tops = param ? &hist_disable_count_trigger_ops :\n\t\t\t&hist_disable_trigger_ops;\n\n\treturn ops;\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include \"tracing_map.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int event_hist_trigger_parse(struct event_command *cmd_ops,\n\t\t\t\t    struct trace_event_file *file,\n\t\t\t\t    char *glob, char *cmd, char *param);",
      "static struct event_trigger_ops hist_enable_trigger_ops = {\n\t.trigger\t\t= hist_enable_trigger,\n\t.print\t\t\t= event_enable_trigger_print,\n\t.init\t\t\t= event_trigger_init,\n\t.free\t\t\t= event_enable_trigger_free,\n};",
      "static struct event_trigger_ops hist_enable_count_trigger_ops = {\n\t.trigger\t\t= hist_enable_count_trigger,\n\t.print\t\t\t= event_enable_trigger_print,\n\t.init\t\t\t= event_trigger_init,\n\t.free\t\t\t= event_enable_trigger_free,\n};",
      "static struct event_trigger_ops hist_disable_trigger_ops = {\n\t.trigger\t\t= hist_enable_trigger,\n\t.print\t\t\t= event_enable_trigger_print,\n\t.init\t\t\t= event_trigger_init,\n\t.free\t\t\t= event_enable_trigger_free,\n};",
      "static struct event_trigger_ops hist_disable_count_trigger_ops = {\n\t.trigger\t\t= hist_enable_count_trigger,\n\t.print\t\t\t= event_enable_trigger_print,\n\t.init\t\t\t= event_trigger_init,\n\t.free\t\t\t= event_enable_trigger_free,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "cmd",
            "ENABLE_HIST_STR"
          ],
          "line": 6419
        },
        "resolved": true,
        "details": {
          "function_name": "sym_strcmp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/report.c",
          "lines": "356-365",
          "snippet": "static int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}",
          "includes": [
            "#include \"encoding.h\"",
            "#include \"kcsan.h\"",
            "#include <linux/stacktrace.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/delay.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"encoding.h\"\n#include \"kcsan.h\"\n#include <linux/stacktrace.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/lockdep.h>\n#include <linux/kernel.h>\n#include <linux/kallsyms.h>\n#include <linux/jiffies.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n\nstatic int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int event_hist_trigger_parse(struct event_command *cmd_ops,\n\t\t\t\t    struct trace_event_file *file,\n\t\t\t\t    char *glob, char *cmd, char *param);\nstatic struct event_trigger_ops hist_enable_trigger_ops = {\n\t.trigger\t\t= hist_enable_trigger,\n\t.print\t\t\t= event_enable_trigger_print,\n\t.init\t\t\t= event_trigger_init,\n\t.free\t\t\t= event_enable_trigger_free,\n};\nstatic struct event_trigger_ops hist_enable_count_trigger_ops = {\n\t.trigger\t\t= hist_enable_count_trigger,\n\t.print\t\t\t= event_enable_trigger_print,\n\t.init\t\t\t= event_trigger_init,\n\t.free\t\t\t= event_enable_trigger_free,\n};\nstatic struct event_trigger_ops hist_disable_trigger_ops = {\n\t.trigger\t\t= hist_enable_trigger,\n\t.print\t\t\t= event_enable_trigger_print,\n\t.init\t\t\t= event_trigger_init,\n\t.free\t\t\t= event_enable_trigger_free,\n};\nstatic struct event_trigger_ops hist_disable_count_trigger_ops = {\n\t.trigger\t\t= hist_enable_count_trigger,\n\t.print\t\t\t= event_enable_trigger_print,\n\t.init\t\t\t= event_trigger_init,\n\t.free\t\t\t= event_enable_trigger_free,\n};\n\nstatic struct event_trigger_ops *\nhist_enable_get_trigger_ops(char *cmd, char *param)\n{\n\tstruct event_trigger_ops *ops;\n\tbool enable;\n\n\tenable = (strcmp(cmd, ENABLE_HIST_STR) == 0);\n\n\tif (enable)\n\t\tops = param ? &hist_enable_count_trigger_ops :\n\t\t\t&hist_enable_trigger_ops;\n\telse\n\t\tops = param ? &hist_disable_count_trigger_ops :\n\t\t\t&hist_disable_trigger_ops;\n\n\treturn ops;\n}"
  },
  {
    "function_name": "hist_enable_count_trigger",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
    "lines": "6371-6383",
    "snippet": "static void\nhist_enable_count_trigger(struct event_trigger_data *data,\n\t\t\t  struct trace_buffer *buffer,  void *rec,\n\t\t\t  struct ring_buffer_event *event)\n{\n\tif (!data->count)\n\t\treturn;\n\n\tif (data->count != -1)\n\t\t(data->count)--;\n\n\thist_enable_trigger(data, buffer, rec, event);\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include \"tracing_map.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "hist_enable_trigger",
          "args": [
            "data",
            "buffer",
            "rec",
            "event"
          ],
          "line": 6382
        },
        "resolved": true,
        "details": {
          "function_name": "hist_enable_trigger",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "6352-6369",
          "snippet": "static void\nhist_enable_trigger(struct event_trigger_data *data,\n\t\t    struct trace_buffer *buffer,  void *rec,\n\t\t    struct ring_buffer_event *event)\n{\n\tstruct enable_trigger_data *enable_data = data->private_data;\n\tstruct event_trigger_data *test;\n\n\tlist_for_each_entry_rcu(test, &enable_data->file->triggers, list,\n\t\t\t\tlockdep_is_held(&event_mutex)) {\n\t\tif (test->cmd_ops->trigger_type == ETT_EVENT_HIST) {\n\t\t\tif (enable_data->enable)\n\t\t\t\ttest->paused = false;\n\t\t\telse\n\t\t\t\ttest->paused = true;\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);\n\nstatic void\nhist_enable_trigger(struct event_trigger_data *data,\n\t\t    struct trace_buffer *buffer,  void *rec,\n\t\t    struct ring_buffer_event *event)\n{\n\tstruct enable_trigger_data *enable_data = data->private_data;\n\tstruct event_trigger_data *test;\n\n\tlist_for_each_entry_rcu(test, &enable_data->file->triggers, list,\n\t\t\t\tlockdep_is_held(&event_mutex)) {\n\t\tif (test->cmd_ops->trigger_type == ETT_EVENT_HIST) {\n\t\t\tif (enable_data->enable)\n\t\t\t\ttest->paused = false;\n\t\t\telse\n\t\t\t\ttest->paused = true;\n\t\t}\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);\n\nstatic void\nhist_enable_count_trigger(struct event_trigger_data *data,\n\t\t\t  struct trace_buffer *buffer,  void *rec,\n\t\t\t  struct ring_buffer_event *event)\n{\n\tif (!data->count)\n\t\treturn;\n\n\tif (data->count != -1)\n\t\t(data->count)--;\n\n\thist_enable_trigger(data, buffer, rec, event);\n}"
  },
  {
    "function_name": "hist_enable_trigger",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
    "lines": "6352-6369",
    "snippet": "static void\nhist_enable_trigger(struct event_trigger_data *data,\n\t\t    struct trace_buffer *buffer,  void *rec,\n\t\t    struct ring_buffer_event *event)\n{\n\tstruct enable_trigger_data *enable_data = data->private_data;\n\tstruct event_trigger_data *test;\n\n\tlist_for_each_entry_rcu(test, &enable_data->file->triggers, list,\n\t\t\t\tlockdep_is_held(&event_mutex)) {\n\t\tif (test->cmd_ops->trigger_type == ETT_EVENT_HIST) {\n\t\t\tif (enable_data->enable)\n\t\t\t\ttest->paused = false;\n\t\t\telse\n\t\t\t\ttest->paused = true;\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include \"tracing_map.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_for_each_entry_rcu",
          "args": [
            "test",
            "&enable_data->file->triggers",
            "list",
            "lockdep_is_held(&event_mutex)"
          ],
          "line": 6360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_is_held",
          "args": [
            "&event_mutex"
          ],
          "line": 6361
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_lockdep_is_held_nocb",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_nocb.h",
          "lines": "1458-1461",
          "snippet": "static inline int rcu_lockdep_is_held_nocb(struct rcu_data *rdp)\n{\n\treturn 0;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int rcu_lockdep_is_held_nocb(struct rcu_data *rdp)\n{\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);\n\nstatic void\nhist_enable_trigger(struct event_trigger_data *data,\n\t\t    struct trace_buffer *buffer,  void *rec,\n\t\t    struct ring_buffer_event *event)\n{\n\tstruct enable_trigger_data *enable_data = data->private_data;\n\tstruct event_trigger_data *test;\n\n\tlist_for_each_entry_rcu(test, &enable_data->file->triggers, list,\n\t\t\t\tlockdep_is_held(&event_mutex)) {\n\t\tif (test->cmd_ops->trigger_type == ETT_EVENT_HIST) {\n\t\t\tif (enable_data->enable)\n\t\t\t\ttest->paused = false;\n\t\t\telse\n\t\t\t\ttest->paused = true;\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "register_trigger_hist_cmd",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
    "lines": "6342-6350",
    "snippet": "__init int register_trigger_hist_cmd(void)\n{\n\tint ret;\n\n\tret = register_event_command(&trigger_hist_cmd);\n\tWARN_ON(ret < 0);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include \"tracing_map.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct event_command trigger_hist_cmd;",
      "static struct event_command trigger_hist_cmd = {\n\t.name\t\t\t= \"hist\",\n\t.trigger_type\t\t= ETT_EVENT_HIST,\n\t.flags\t\t\t= EVENT_CMD_FL_NEEDS_REC,\n\t.parse\t\t\t= event_hist_trigger_parse,\n\t.reg\t\t\t= hist_register_trigger,\n\t.unreg\t\t\t= hist_unregister_trigger,\n\t.unreg_all\t\t= hist_unreg_all,\n\t.get_trigger_ops\t= event_hist_get_trigger_ops,\n\t.set_filter\t\t= set_trigger_filter,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "ret < 0"
          ],
          "line": 6347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "register_event_command",
          "args": [
            "&trigger_hist_cmd"
          ],
          "line": 6346
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_event_command",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_trigger.c",
          "lines": "365-382",
          "snippet": "__init int unregister_event_command(struct event_command *cmd)\n{\n\tstruct event_command *p, *n;\n\tint ret = -ENODEV;\n\n\tmutex_lock(&trigger_cmd_mutex);\n\tlist_for_each_entry_safe(p, n, &trigger_commands, list) {\n\t\tif (strcmp(cmd->name, p->name) == 0) {\n\t\t\tret = 0;\n\t\t\tlist_del_init(&p->list);\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n out_unlock:\n\tmutex_unlock(&trigger_cmd_mutex);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/security.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(trigger_commands);",
            "static DEFINE_MUTEX(trigger_cmd_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/security.h>\n\nstatic LIST_HEAD(trigger_commands);\nstatic DEFINE_MUTEX(trigger_cmd_mutex);\n\n__init int unregister_event_command(struct event_command *cmd)\n{\n\tstruct event_command *p, *n;\n\tint ret = -ENODEV;\n\n\tmutex_lock(&trigger_cmd_mutex);\n\tlist_for_each_entry_safe(p, n, &trigger_commands, list) {\n\t\tif (strcmp(cmd->name, p->name) == 0) {\n\t\t\tret = 0;\n\t\t\tlist_del_init(&p->list);\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n out_unlock:\n\tmutex_unlock(&trigger_cmd_mutex);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct event_command trigger_hist_cmd;\nstatic struct event_command trigger_hist_cmd = {\n\t.name\t\t\t= \"hist\",\n\t.trigger_type\t\t= ETT_EVENT_HIST,\n\t.flags\t\t\t= EVENT_CMD_FL_NEEDS_REC,\n\t.parse\t\t\t= event_hist_trigger_parse,\n\t.reg\t\t\t= hist_register_trigger,\n\t.unreg\t\t\t= hist_unregister_trigger,\n\t.unreg_all\t\t= hist_unreg_all,\n\t.get_trigger_ops\t= event_hist_get_trigger_ops,\n\t.set_filter\t\t= set_trigger_filter,\n};\n\n__init int register_trigger_hist_cmd(void)\n{\n\tint ret;\n\n\tret = register_event_command(&trigger_hist_cmd);\n\tWARN_ON(ret < 0);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "event_hist_trigger_parse",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
    "lines": "6149-6328",
    "snippet": "static int event_hist_trigger_parse(struct event_command *cmd_ops,\n\t\t\t\t    struct trace_event_file *file,\n\t\t\t\t    char *glob, char *cmd, char *param)\n{\n\tunsigned int hist_trigger_bits = TRACING_MAP_BITS_DEFAULT;\n\tstruct event_trigger_data *trigger_data;\n\tstruct hist_trigger_attrs *attrs;\n\tstruct event_trigger_ops *trigger_ops;\n\tstruct hist_trigger_data *hist_data;\n\tstruct synth_event *se;\n\tconst char *se_name;\n\tbool remove = false;\n\tchar *trigger, *p, *start;\n\tint ret = 0;\n\n\tlockdep_assert_held(&event_mutex);\n\n\tif (glob && strlen(glob)) {\n\t\thist_err_clear();\n\t\tlast_cmd_set(file, param);\n\t}\n\n\tif (!param)\n\t\treturn -EINVAL;\n\n\tif (glob[0] == '!')\n\t\tremove = true;\n\n\t/*\n\t * separate the trigger from the filter (k:v [if filter])\n\t * allowing for whitespace in the trigger\n\t */\n\tp = trigger = param;\n\tdo {\n\t\tp = strstr(p, \"if\");\n\t\tif (!p)\n\t\t\tbreak;\n\t\tif (p == param)\n\t\t\treturn -EINVAL;\n\t\tif (*(p - 1) != ' ' && *(p - 1) != '\\t') {\n\t\t\tp++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (p >= param + strlen(param) - (sizeof(\"if\") - 1) - 1)\n\t\t\treturn -EINVAL;\n\t\tif (*(p + sizeof(\"if\") - 1) != ' ' && *(p + sizeof(\"if\") - 1) != '\\t') {\n\t\t\tp++;\n\t\t\tcontinue;\n\t\t}\n\t\tbreak;\n\t} while (p);\n\n\tif (!p)\n\t\tparam = NULL;\n\telse {\n\t\t*(p - 1) = '\\0';\n\t\tparam = strstrip(p);\n\t\ttrigger = strstrip(trigger);\n\t}\n\n\t/*\n\t * To simplify arithmetic expression parsing, replace occurrences of\n\t * '.sym-offset' modifier with '.symXoffset'\n\t */\n\tstart = strstr(trigger, \".sym-offset\");\n\twhile (start) {\n\t\t*(start + 4) = 'X';\n\t\tstart = strstr(start + 11, \".sym-offset\");\n\t}\n\n\tattrs = parse_hist_trigger_attrs(file->tr, trigger);\n\tif (IS_ERR(attrs))\n\t\treturn PTR_ERR(attrs);\n\n\tif (attrs->map_bits)\n\t\thist_trigger_bits = attrs->map_bits;\n\n\thist_data = create_hist_data(hist_trigger_bits, attrs, file, remove);\n\tif (IS_ERR(hist_data)) {\n\t\tdestroy_hist_trigger_attrs(attrs);\n\t\treturn PTR_ERR(hist_data);\n\t}\n\n\ttrigger_ops = cmd_ops->get_trigger_ops(cmd, trigger);\n\n\ttrigger_data = kzalloc(sizeof(*trigger_data), GFP_KERNEL);\n\tif (!trigger_data) {\n\t\tret = -ENOMEM;\n\t\tgoto out_free;\n\t}\n\n\ttrigger_data->count = -1;\n\ttrigger_data->ops = trigger_ops;\n\ttrigger_data->cmd_ops = cmd_ops;\n\n\tINIT_LIST_HEAD(&trigger_data->list);\n\tRCU_INIT_POINTER(trigger_data->filter, NULL);\n\n\ttrigger_data->private_data = hist_data;\n\n\t/* if param is non-empty, it's supposed to be a filter */\n\tif (param && cmd_ops->set_filter) {\n\t\tret = cmd_ops->set_filter(param, trigger_data, file);\n\t\tif (ret < 0)\n\t\t\tgoto out_free;\n\t}\n\n\tif (remove) {\n\t\tif (!have_hist_trigger_match(trigger_data, file))\n\t\t\tgoto out_free;\n\n\t\tif (hist_trigger_check_refs(trigger_data, file)) {\n\t\t\tret = -EBUSY;\n\t\t\tgoto out_free;\n\t\t}\n\n\t\tcmd_ops->unreg(glob+1, trigger_data, file);\n\t\tse_name = trace_event_name(file->event_call);\n\t\tse = find_synth_event(se_name);\n\t\tif (se)\n\t\t\tse->ref--;\n\t\tret = 0;\n\t\tgoto out_free;\n\t}\n\n\tret = cmd_ops->reg(glob, trigger_data, file);\n\t/*\n\t * The above returns on success the # of triggers registered,\n\t * but if it didn't register any it returns zero.  Consider no\n\t * triggers registered a failure too.\n\t */\n\tif (!ret) {\n\t\tif (!(attrs->pause || attrs->cont || attrs->clear))\n\t\t\tret = -ENOENT;\n\t\tgoto out_free;\n\t} else if (ret < 0)\n\t\tgoto out_free;\n\n\tif (get_named_trigger_data(trigger_data))\n\t\tgoto enable;\n\n\tif (has_hist_vars(hist_data))\n\t\tsave_hist_vars(hist_data);\n\n\tret = create_actions(hist_data);\n\tif (ret)\n\t\tgoto out_unreg;\n\n\tret = tracing_map_init(hist_data->map);\n\tif (ret)\n\t\tgoto out_unreg;\nenable:\n\tret = hist_trigger_enable(trigger_data, file);\n\tif (ret)\n\t\tgoto out_unreg;\n\n\tse_name = trace_event_name(file->event_call);\n\tse = find_synth_event(se_name);\n\tif (se)\n\t\tse->ref++;\n\t/* Just return zero, not the number of registered triggers */\n\tret = 0;\n out:\n\tif (ret == 0)\n\t\thist_err_clear();\n\n\treturn ret;\n out_unreg:\n\tcmd_ops->unreg(glob+1, trigger_data, file);\n out_free:\n\tif (cmd_ops->set_filter)\n\t\tcmd_ops->set_filter(NULL, trigger_data, NULL);\n\n\tremove_hist_vars(hist_data);\n\n\tkfree(trigger_data);\n\n\tdestroy_hist_data(hist_data);\n\tgoto out;\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include \"tracing_map.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int event_hist_trigger_parse(struct event_command *cmd_ops,\n\t\t\t\t    struct trace_event_file *file,\n\t\t\t\t    char *glob, char *cmd, char *param);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "destroy_hist_data",
          "args": [
            "hist_data"
          ],
          "line": 6326
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_hist_data",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "4799-4813",
          "snippet": "static void destroy_hist_data(struct hist_trigger_data *hist_data)\n{\n\tif (!hist_data)\n\t\treturn;\n\n\tdestroy_hist_trigger_attrs(hist_data->attrs);\n\tdestroy_hist_fields(hist_data);\n\ttracing_map_destroy(hist_data->map);\n\n\tdestroy_actions(hist_data);\n\tdestroy_field_vars(hist_data);\n\tdestroy_field_var_hists(hist_data);\n\n\tkfree(hist_data);\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void destroy_hist_data(struct hist_trigger_data *hist_data)\n{\n\tif (!hist_data)\n\t\treturn;\n\n\tdestroy_hist_trigger_attrs(hist_data->attrs);\n\tdestroy_hist_fields(hist_data);\n\ttracing_map_destroy(hist_data->map);\n\n\tdestroy_actions(hist_data);\n\tdestroy_field_vars(hist_data);\n\tdestroy_field_var_hists(hist_data);\n\n\tkfree(hist_data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "trigger_data"
          ],
          "line": 6324
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "remove_hist_vars",
          "args": [
            "hist_data"
          ],
          "line": 6322
        },
        "resolved": true,
        "details": {
          "function_name": "remove_hist_vars",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "1042-1059",
          "snippet": "static void remove_hist_vars(struct hist_trigger_data *hist_data)\n{\n\tstruct trace_array *tr = hist_data->event_file->tr;\n\tstruct hist_var_data *var_data;\n\n\tvar_data = find_hist_vars(hist_data);\n\tif (!var_data)\n\t\treturn;\n\n\tif (WARN_ON(check_var_refs(hist_data)))\n\t\treturn;\n\n\tlist_del(&var_data->list);\n\n\tkfree(var_data);\n\n\ttrace_array_put(tr);\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void remove_hist_vars(struct hist_trigger_data *hist_data)\n{\n\tstruct trace_array *tr = hist_data->event_file->tr;\n\tstruct hist_var_data *var_data;\n\n\tvar_data = find_hist_vars(hist_data);\n\tif (!var_data)\n\t\treturn;\n\n\tif (WARN_ON(check_var_refs(hist_data)))\n\t\treturn;\n\n\tlist_del(&var_data->list);\n\n\tkfree(var_data);\n\n\ttrace_array_put(tr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cmd_ops->set_filter",
          "args": [
            "NULL",
            "trigger_data",
            "NULL"
          ],
          "line": 6320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cmd_ops->unreg",
          "args": [
            "glob+1",
            "trigger_data",
            "file"
          ],
          "line": 6317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hist_err_clear",
          "args": [],
          "line": 6313
        },
        "resolved": true,
        "details": {
          "function_name": "hist_err_clear",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "769-773",
          "snippet": "static void hist_err_clear(void)\n{\n\tlast_cmd[0] = '\\0';\n\tlast_cmd_loc[0] = '\\0';\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char last_cmd[MAX_FILTER_STR_VAL];",
            "static char last_cmd_loc[MAX_FILTER_STR_VAL];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic char last_cmd[MAX_FILTER_STR_VAL];\nstatic char last_cmd_loc[MAX_FILTER_STR_VAL];\n\nstatic void hist_err_clear(void)\n{\n\tlast_cmd[0] = '\\0';\n\tlast_cmd_loc[0] = '\\0';\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_synth_event",
          "args": [
            "se_name"
          ],
          "line": 6306
        },
        "resolved": true,
        "details": {
          "function_name": "find_synth_event",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_synth.c",
          "lines": "748-762",
          "snippet": "struct synth_event *find_synth_event(const char *name)\n{\n\tstruct dyn_event *pos;\n\tstruct synth_event *event;\n\n\tfor_each_dyn_event(pos) {\n\t\tif (!is_synth_event(pos))\n\t\t\tcontinue;\n\t\tevent = to_synth_event(pos);\n\t\tif (strcmp(event->name, name) == 0)\n\t\t\treturn event;\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstruct synth_event *find_synth_event(const char *name)\n{\n\tstruct dyn_event *pos;\n\tstruct synth_event *event;\n\n\tfor_each_dyn_event(pos) {\n\t\tif (!is_synth_event(pos))\n\t\t\tcontinue;\n\t\tevent = to_synth_event(pos);\n\t\tif (strcmp(event->name, name) == 0)\n\t\t\treturn event;\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_event_name",
          "args": [
            "file->event_call"
          ],
          "line": 6305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hist_trigger_enable",
          "args": [
            "trigger_data",
            "file"
          ],
          "line": 6301
        },
        "resolved": true,
        "details": {
          "function_name": "hist_trigger_enable",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "5998-6014",
          "snippet": "static int hist_trigger_enable(struct event_trigger_data *data,\n\t\t\t       struct trace_event_file *file)\n{\n\tint ret = 0;\n\n\tlist_add_tail_rcu(&data->list, &file->triggers);\n\n\tupdate_cond_flag(file);\n\n\tif (trace_event_trigger_enable_disable(file, 1) < 0) {\n\t\tlist_del_rcu(&data->list);\n\t\tupdate_cond_flag(file);\n\t\tret--;\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);\n\nstatic int hist_trigger_enable(struct event_trigger_data *data,\n\t\t\t       struct trace_event_file *file)\n{\n\tint ret = 0;\n\n\tlist_add_tail_rcu(&data->list, &file->triggers);\n\n\tupdate_cond_flag(file);\n\n\tif (trace_event_trigger_enable_disable(file, 1) < 0) {\n\t\tlist_del_rcu(&data->list);\n\t\tupdate_cond_flag(file);\n\t\tret--;\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracing_map_init",
          "args": [
            "hist_data->map"
          ],
          "line": 6297
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_map_init",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/tracing_map.c",
          "lines": "824-838",
          "snippet": "int tracing_map_init(struct tracing_map *map)\n{\n\tint err;\n\n\tif (map->n_fields < 2)\n\t\treturn -EINVAL; /* need at least 1 key and 1 val */\n\n\terr = tracing_map_alloc_elts(map);\n\tif (err)\n\t\treturn err;\n\n\ttracing_map_clear(map);\n\n\treturn err;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/kmemleak.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/jhash.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/kmemleak.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <linux/vmalloc.h>\n\nint tracing_map_init(struct tracing_map *map)\n{\n\tint err;\n\n\tif (map->n_fields < 2)\n\t\treturn -EINVAL; /* need at least 1 key and 1 val */\n\n\terr = tracing_map_alloc_elts(map);\n\tif (err)\n\t\treturn err;\n\n\ttracing_map_clear(map);\n\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "create_actions",
          "args": [
            "hist_data"
          ],
          "line": 6293
        },
        "resolved": true,
        "details": {
          "function_name": "create_actions",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "4617-4642",
          "snippet": "static int create_actions(struct hist_trigger_data *hist_data)\n{\n\tstruct action_data *data;\n\tunsigned int i;\n\tint ret = 0;\n\n\tfor (i = 0; i < hist_data->attrs->n_actions; i++) {\n\t\tdata = hist_data->actions[i];\n\n\t\tif (data->handler == HANDLER_ONMATCH) {\n\t\t\tret = onmatch_create(hist_data, data);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t} else if (data->handler == HANDLER_ONMAX ||\n\t\t\t   data->handler == HANDLER_ONCHANGE) {\n\t\t\tret = track_data_create(hist_data, data);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);\n\nstatic int create_actions(struct hist_trigger_data *hist_data)\n{\n\tstruct action_data *data;\n\tunsigned int i;\n\tint ret = 0;\n\n\tfor (i = 0; i < hist_data->attrs->n_actions; i++) {\n\t\tdata = hist_data->actions[i];\n\n\t\tif (data->handler == HANDLER_ONMATCH) {\n\t\t\tret = onmatch_create(hist_data, data);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t} else if (data->handler == HANDLER_ONMAX ||\n\t\t\t   data->handler == HANDLER_ONCHANGE) {\n\t\t\tret = track_data_create(hist_data, data);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "save_hist_vars",
          "args": [
            "hist_data"
          ],
          "line": 6291
        },
        "resolved": true,
        "details": {
          "function_name": "save_hist_vars",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "1018-1040",
          "snippet": "static int save_hist_vars(struct hist_trigger_data *hist_data)\n{\n\tstruct trace_array *tr = hist_data->event_file->tr;\n\tstruct hist_var_data *var_data;\n\n\tvar_data = find_hist_vars(hist_data);\n\tif (var_data)\n\t\treturn 0;\n\n\tif (tracing_check_open_get_tr(tr))\n\t\treturn -ENODEV;\n\n\tvar_data = kzalloc(sizeof(*var_data), GFP_KERNEL);\n\tif (!var_data) {\n\t\ttrace_array_put(tr);\n\t\treturn -ENOMEM;\n\t}\n\n\tvar_data->hist_data = hist_data;\n\tlist_add(&var_data->list, &tr->hist_vars);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int save_hist_vars(struct hist_trigger_data *hist_data)\n{\n\tstruct trace_array *tr = hist_data->event_file->tr;\n\tstruct hist_var_data *var_data;\n\n\tvar_data = find_hist_vars(hist_data);\n\tif (var_data)\n\t\treturn 0;\n\n\tif (tracing_check_open_get_tr(tr))\n\t\treturn -ENODEV;\n\n\tvar_data = kzalloc(sizeof(*var_data), GFP_KERNEL);\n\tif (!var_data) {\n\t\ttrace_array_put(tr);\n\t\treturn -ENOMEM;\n\t}\n\n\tvar_data->hist_data = hist_data;\n\tlist_add(&var_data->list, &tr->hist_vars);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "has_hist_vars",
          "args": [
            "hist_data"
          ],
          "line": 6290
        },
        "resolved": true,
        "details": {
          "function_name": "has_hist_vars",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "1004-1016",
          "snippet": "static bool has_hist_vars(struct hist_trigger_data *hist_data)\n{\n\tstruct hist_field *hist_field;\n\tint i;\n\n\tfor_each_hist_field(i, hist_data) {\n\t\thist_field = hist_data->fields[i];\n\t\tif (field_has_hist_vars(hist_field, 0))\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic bool has_hist_vars(struct hist_trigger_data *hist_data)\n{\n\tstruct hist_field *hist_field;\n\tint i;\n\n\tfor_each_hist_field(i, hist_data) {\n\t\thist_field = hist_data->fields[i];\n\t\tif (field_has_hist_vars(hist_field, 0))\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_named_trigger_data",
          "args": [
            "trigger_data"
          ],
          "line": 6287
        },
        "resolved": true,
        "details": {
          "function_name": "get_named_trigger_data",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_trigger.c",
          "lines": "1287-1291",
          "snippet": "struct event_trigger_data *\nget_named_trigger_data(struct event_trigger_data *data)\n{\n\treturn data->named_data;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/security.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/security.h>\n\nstruct event_trigger_data *\nget_named_trigger_data(struct event_trigger_data *data)\n{\n\treturn data->named_data;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cmd_ops->reg",
          "args": [
            "glob",
            "trigger_data",
            "file"
          ],
          "line": 6274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_event_name",
          "args": [
            "file->event_call"
          ],
          "line": 6266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cmd_ops->unreg",
          "args": [
            "glob+1",
            "trigger_data",
            "file"
          ],
          "line": 6265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hist_trigger_check_refs",
          "args": [
            "trigger_data",
            "file"
          ],
          "line": 6260
        },
        "resolved": true,
        "details": {
          "function_name": "hist_trigger_check_refs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "6040-6063",
          "snippet": "static bool hist_trigger_check_refs(struct event_trigger_data *data,\n\t\t\t\t    struct trace_event_file *file)\n{\n\tstruct hist_trigger_data *hist_data = data->private_data;\n\tstruct event_trigger_data *test, *named_data = NULL;\n\n\tlockdep_assert_held(&event_mutex);\n\n\tif (hist_data->attrs->name)\n\t\tnamed_data = find_named_trigger(hist_data->attrs->name);\n\n\tlist_for_each_entry(test, &file->triggers, list) {\n\t\tif (test->cmd_ops->trigger_type == ETT_EVENT_HIST) {\n\t\t\tif (!hist_trigger_match(data, test, named_data, false))\n\t\t\t\tcontinue;\n\t\t\thist_data = test->private_data;\n\t\t\tif (check_var_refs(hist_data))\n\t\t\t\treturn true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);\n\nstatic bool hist_trigger_check_refs(struct event_trigger_data *data,\n\t\t\t\t    struct trace_event_file *file)\n{\n\tstruct hist_trigger_data *hist_data = data->private_data;\n\tstruct event_trigger_data *test, *named_data = NULL;\n\n\tlockdep_assert_held(&event_mutex);\n\n\tif (hist_data->attrs->name)\n\t\tnamed_data = find_named_trigger(hist_data->attrs->name);\n\n\tlist_for_each_entry(test, &file->triggers, list) {\n\t\tif (test->cmd_ops->trigger_type == ETT_EVENT_HIST) {\n\t\t\tif (!hist_trigger_match(data, test, named_data, false))\n\t\t\t\tcontinue;\n\t\t\thist_data = test->private_data;\n\t\t\tif (check_var_refs(hist_data))\n\t\t\t\treturn true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "have_hist_trigger_match",
          "args": [
            "trigger_data",
            "file"
          ],
          "line": 6257
        },
        "resolved": true,
        "details": {
          "function_name": "have_hist_trigger_match",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "6016-6038",
          "snippet": "static bool have_hist_trigger_match(struct event_trigger_data *data,\n\t\t\t\t    struct trace_event_file *file)\n{\n\tstruct hist_trigger_data *hist_data = data->private_data;\n\tstruct event_trigger_data *test, *named_data = NULL;\n\tbool match = false;\n\n\tlockdep_assert_held(&event_mutex);\n\n\tif (hist_data->attrs->name)\n\t\tnamed_data = find_named_trigger(hist_data->attrs->name);\n\n\tlist_for_each_entry(test, &file->triggers, list) {\n\t\tif (test->cmd_ops->trigger_type == ETT_EVENT_HIST) {\n\t\t\tif (hist_trigger_match(data, test, named_data, false)) {\n\t\t\t\tmatch = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn match;\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);\n\nstatic bool have_hist_trigger_match(struct event_trigger_data *data,\n\t\t\t\t    struct trace_event_file *file)\n{\n\tstruct hist_trigger_data *hist_data = data->private_data;\n\tstruct event_trigger_data *test, *named_data = NULL;\n\tbool match = false;\n\n\tlockdep_assert_held(&event_mutex);\n\n\tif (hist_data->attrs->name)\n\t\tnamed_data = find_named_trigger(hist_data->attrs->name);\n\n\tlist_for_each_entry(test, &file->triggers, list) {\n\t\tif (test->cmd_ops->trigger_type == ETT_EVENT_HIST) {\n\t\t\tif (hist_trigger_match(data, test, named_data, false)) {\n\t\t\t\tmatch = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn match;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cmd_ops->set_filter",
          "args": [
            "param",
            "trigger_data",
            "file"
          ],
          "line": 6251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RCU_INIT_POINTER",
          "args": [
            "trigger_data->filter",
            "NULL"
          ],
          "line": 6245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&trigger_data->list"
          ],
          "line": 6244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*trigger_data)",
            "GFP_KERNEL"
          ],
          "line": 6234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cmd_ops->get_trigger_ops",
          "args": [
            "cmd",
            "trigger"
          ],
          "line": 6232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "hist_data"
          ],
          "line": 6229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "destroy_hist_trigger_attrs",
          "args": [
            "attrs"
          ],
          "line": 6228
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_hist_trigger_attrs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "1371-1390",
          "snippet": "static void destroy_hist_trigger_attrs(struct hist_trigger_attrs *attrs)\n{\n\tunsigned int i;\n\n\tif (!attrs)\n\t\treturn;\n\n\tfor (i = 0; i < attrs->n_assignments; i++)\n\t\tkfree(attrs->assignment_str[i]);\n\n\tfor (i = 0; i < attrs->n_actions; i++)\n\t\tkfree(attrs->action_str[i]);\n\n\tkfree(attrs->name);\n\tkfree(attrs->sort_key_str);\n\tkfree(attrs->keys_str);\n\tkfree(attrs->vals_str);\n\tkfree(attrs->clock);\n\tkfree(attrs);\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void destroy_hist_trigger_attrs(struct hist_trigger_attrs *attrs)\n{\n\tunsigned int i;\n\n\tif (!attrs)\n\t\treturn;\n\n\tfor (i = 0; i < attrs->n_assignments; i++)\n\t\tkfree(attrs->assignment_str[i]);\n\n\tfor (i = 0; i < attrs->n_actions; i++)\n\t\tkfree(attrs->action_str[i]);\n\n\tkfree(attrs->name);\n\tkfree(attrs->sort_key_str);\n\tkfree(attrs->keys_str);\n\tkfree(attrs->vals_str);\n\tkfree(attrs->clock);\n\tkfree(attrs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "hist_data"
          ],
          "line": 6227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "create_hist_data",
          "args": [
            "hist_trigger_bits",
            "attrs",
            "file",
            "remove"
          ],
          "line": 6226
        },
        "resolved": true,
        "details": {
          "function_name": "create_hist_data",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "4860-4913",
          "snippet": "static struct hist_trigger_data *\ncreate_hist_data(unsigned int map_bits,\n\t\t struct hist_trigger_attrs *attrs,\n\t\t struct trace_event_file *file,\n\t\t bool remove)\n{\n\tconst struct tracing_map_ops *map_ops = NULL;\n\tstruct hist_trigger_data *hist_data;\n\tint ret = 0;\n\n\thist_data = kzalloc(sizeof(*hist_data), GFP_KERNEL);\n\tif (!hist_data)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\thist_data->attrs = attrs;\n\thist_data->remove = remove;\n\thist_data->event_file = file;\n\n\tret = parse_actions(hist_data);\n\tif (ret)\n\t\tgoto free;\n\n\tret = create_hist_fields(hist_data, file);\n\tif (ret)\n\t\tgoto free;\n\n\tret = create_sort_keys(hist_data);\n\tif (ret)\n\t\tgoto free;\n\n\tmap_ops = &hist_trigger_elt_data_ops;\n\n\thist_data->map = tracing_map_create(map_bits, hist_data->key_size,\n\t\t\t\t\t    map_ops, hist_data);\n\tif (IS_ERR(hist_data->map)) {\n\t\tret = PTR_ERR(hist_data->map);\n\t\thist_data->map = NULL;\n\t\tgoto free;\n\t}\n\n\tret = create_tracing_map_fields(hist_data);\n\tif (ret)\n\t\tgoto free;\n out:\n\treturn hist_data;\n free:\n\thist_data->attrs = NULL;\n\n\tdestroy_hist_data(hist_data);\n\n\thist_data = ERR_PTR(ret);\n\n\tgoto out;\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct tracing_map_ops hist_trigger_elt_data_ops = {\n\t.elt_alloc\t= hist_trigger_elt_data_alloc,\n\t.elt_free\t= hist_trigger_elt_data_free,\n\t.elt_init\t= hist_trigger_elt_data_init,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic const struct tracing_map_ops hist_trigger_elt_data_ops = {\n\t.elt_alloc\t= hist_trigger_elt_data_alloc,\n\t.elt_free\t= hist_trigger_elt_data_free,\n\t.elt_init\t= hist_trigger_elt_data_init,\n};\n\nstatic struct hist_trigger_data *\ncreate_hist_data(unsigned int map_bits,\n\t\t struct hist_trigger_attrs *attrs,\n\t\t struct trace_event_file *file,\n\t\t bool remove)\n{\n\tconst struct tracing_map_ops *map_ops = NULL;\n\tstruct hist_trigger_data *hist_data;\n\tint ret = 0;\n\n\thist_data = kzalloc(sizeof(*hist_data), GFP_KERNEL);\n\tif (!hist_data)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\thist_data->attrs = attrs;\n\thist_data->remove = remove;\n\thist_data->event_file = file;\n\n\tret = parse_actions(hist_data);\n\tif (ret)\n\t\tgoto free;\n\n\tret = create_hist_fields(hist_data, file);\n\tif (ret)\n\t\tgoto free;\n\n\tret = create_sort_keys(hist_data);\n\tif (ret)\n\t\tgoto free;\n\n\tmap_ops = &hist_trigger_elt_data_ops;\n\n\thist_data->map = tracing_map_create(map_bits, hist_data->key_size,\n\t\t\t\t\t    map_ops, hist_data);\n\tif (IS_ERR(hist_data->map)) {\n\t\tret = PTR_ERR(hist_data->map);\n\t\thist_data->map = NULL;\n\t\tgoto free;\n\t}\n\n\tret = create_tracing_map_fields(hist_data);\n\tif (ret)\n\t\tgoto free;\n out:\n\treturn hist_data;\n free:\n\thist_data->attrs = NULL;\n\n\tdestroy_hist_data(hist_data);\n\n\thist_data = ERR_PTR(ret);\n\n\tgoto out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "attrs"
          ],
          "line": 6221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "attrs"
          ],
          "line": 6220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parse_hist_trigger_attrs",
          "args": [
            "file->tr",
            "trigger"
          ],
          "line": 6219
        },
        "resolved": true,
        "details": {
          "function_name": "parse_hist_trigger_attrs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "1483-1539",
          "snippet": "static struct hist_trigger_attrs *\nparse_hist_trigger_attrs(struct trace_array *tr, char *trigger_str)\n{\n\tstruct hist_trigger_attrs *attrs;\n\tint ret = 0;\n\n\tattrs = kzalloc(sizeof(*attrs), GFP_KERNEL);\n\tif (!attrs)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\twhile (trigger_str) {\n\t\tchar *str = strsep(&trigger_str, \":\");\n\t\tchar *rhs;\n\n\t\trhs = strchr(str, '=');\n\t\tif (rhs) {\n\t\t\tif (!strlen(++rhs)) {\n\t\t\t\tret = -EINVAL;\n\t\t\t\thist_err(tr, HIST_ERR_EMPTY_ASSIGNMENT, errpos(str));\n\t\t\t\tgoto free;\n\t\t\t}\n\t\t\tret = parse_assignment(tr, str, attrs);\n\t\t\tif (ret)\n\t\t\t\tgoto free;\n\t\t} else if (strcmp(str, \"pause\") == 0)\n\t\t\tattrs->pause = true;\n\t\telse if ((strcmp(str, \"cont\") == 0) ||\n\t\t\t (strcmp(str, \"continue\") == 0))\n\t\t\tattrs->cont = true;\n\t\telse if (strcmp(str, \"clear\") == 0)\n\t\t\tattrs->clear = true;\n\t\telse {\n\t\t\tret = parse_action(str, attrs);\n\t\t\tif (ret)\n\t\t\t\tgoto free;\n\t\t}\n\t}\n\n\tif (!attrs->keys_str) {\n\t\tret = -EINVAL;\n\t\tgoto free;\n\t}\n\n\tif (!attrs->clock) {\n\t\tattrs->clock = kstrdup(\"global\", GFP_KERNEL);\n\t\tif (!attrs->clock) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto free;\n\t\t}\n\t}\n\n\treturn attrs;\n free:\n\tdestroy_hist_trigger_attrs(attrs);\n\n\treturn ERR_PTR(ret);\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct hist_trigger_attrs *\nparse_hist_trigger_attrs(struct trace_array *tr, char *trigger_str)\n{\n\tstruct hist_trigger_attrs *attrs;\n\tint ret = 0;\n\n\tattrs = kzalloc(sizeof(*attrs), GFP_KERNEL);\n\tif (!attrs)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\twhile (trigger_str) {\n\t\tchar *str = strsep(&trigger_str, \":\");\n\t\tchar *rhs;\n\n\t\trhs = strchr(str, '=');\n\t\tif (rhs) {\n\t\t\tif (!strlen(++rhs)) {\n\t\t\t\tret = -EINVAL;\n\t\t\t\thist_err(tr, HIST_ERR_EMPTY_ASSIGNMENT, errpos(str));\n\t\t\t\tgoto free;\n\t\t\t}\n\t\t\tret = parse_assignment(tr, str, attrs);\n\t\t\tif (ret)\n\t\t\t\tgoto free;\n\t\t} else if (strcmp(str, \"pause\") == 0)\n\t\t\tattrs->pause = true;\n\t\telse if ((strcmp(str, \"cont\") == 0) ||\n\t\t\t (strcmp(str, \"continue\") == 0))\n\t\t\tattrs->cont = true;\n\t\telse if (strcmp(str, \"clear\") == 0)\n\t\t\tattrs->clear = true;\n\t\telse {\n\t\t\tret = parse_action(str, attrs);\n\t\t\tif (ret)\n\t\t\t\tgoto free;\n\t\t}\n\t}\n\n\tif (!attrs->keys_str) {\n\t\tret = -EINVAL;\n\t\tgoto free;\n\t}\n\n\tif (!attrs->clock) {\n\t\tattrs->clock = kstrdup(\"global\", GFP_KERNEL);\n\t\tif (!attrs->clock) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto free;\n\t\t}\n\t}\n\n\treturn attrs;\n free:\n\tdestroy_hist_trigger_attrs(attrs);\n\n\treturn ERR_PTR(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "start + 11",
            "\".sym-offset\""
          ],
          "line": 6216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "trigger",
            "\".sym-offset\""
          ],
          "line": 6213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstrip",
          "args": [
            "trigger"
          ],
          "line": 6206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstrip",
          "args": [
            "p"
          ],
          "line": 6205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "param"
          ],
          "line": 6192
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_eprobe.c",
          "lines": "384-401",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/ftrace.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"if\""
          ],
          "line": 6183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "last_cmd_set",
          "args": [
            "file",
            "param"
          ],
          "line": 6168
        },
        "resolved": true,
        "details": {
          "function_name": "last_cmd_set",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "738-761",
          "snippet": "static void last_cmd_set(struct trace_event_file *file, char *str)\n{\n\tconst char *system = NULL, *name = NULL;\n\tstruct trace_event_call *call;\n\n\tif (!str)\n\t\treturn;\n\n\tstrcpy(last_cmd, \"hist:\");\n\tstrncat(last_cmd, str, MAX_FILTER_STR_VAL - 1 - sizeof(\"hist:\"));\n\n\tif (file) {\n\t\tcall = file->event_call;\n\t\tsystem = call->class->system;\n\t\tif (system) {\n\t\t\tname = trace_event_name(call);\n\t\t\tif (!name)\n\t\t\t\tsystem = NULL;\n\t\t}\n\t}\n\n\tif (system)\n\t\tsnprintf(last_cmd_loc, MAX_FILTER_STR_VAL, \"hist:%s:%s\", system, name);\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char last_cmd[MAX_FILTER_STR_VAL];",
            "static char last_cmd_loc[MAX_FILTER_STR_VAL];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic char last_cmd[MAX_FILTER_STR_VAL];\nstatic char last_cmd_loc[MAX_FILTER_STR_VAL];\n\nstatic void last_cmd_set(struct trace_event_file *file, char *str)\n{\n\tconst char *system = NULL, *name = NULL;\n\tstruct trace_event_call *call;\n\n\tif (!str)\n\t\treturn;\n\n\tstrcpy(last_cmd, \"hist:\");\n\tstrncat(last_cmd, str, MAX_FILTER_STR_VAL - 1 - sizeof(\"hist:\"));\n\n\tif (file) {\n\t\tcall = file->event_call;\n\t\tsystem = call->class->system;\n\t\tif (system) {\n\t\t\tname = trace_event_name(call);\n\t\t\tif (!name)\n\t\t\t\tsystem = NULL;\n\t\t}\n\t}\n\n\tif (system)\n\t\tsnprintf(last_cmd_loc, MAX_FILTER_STR_VAL, \"hist:%s:%s\", system, name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&event_mutex"
          ],
          "line": 6164
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int event_hist_trigger_parse(struct event_command *cmd_ops,\n\t\t\t\t    struct trace_event_file *file,\n\t\t\t\t    char *glob, char *cmd, char *param);\n\nstatic int event_hist_trigger_parse(struct event_command *cmd_ops,\n\t\t\t\t    struct trace_event_file *file,\n\t\t\t\t    char *glob, char *cmd, char *param)\n{\n\tunsigned int hist_trigger_bits = TRACING_MAP_BITS_DEFAULT;\n\tstruct event_trigger_data *trigger_data;\n\tstruct hist_trigger_attrs *attrs;\n\tstruct event_trigger_ops *trigger_ops;\n\tstruct hist_trigger_data *hist_data;\n\tstruct synth_event *se;\n\tconst char *se_name;\n\tbool remove = false;\n\tchar *trigger, *p, *start;\n\tint ret = 0;\n\n\tlockdep_assert_held(&event_mutex);\n\n\tif (glob && strlen(glob)) {\n\t\thist_err_clear();\n\t\tlast_cmd_set(file, param);\n\t}\n\n\tif (!param)\n\t\treturn -EINVAL;\n\n\tif (glob[0] == '!')\n\t\tremove = true;\n\n\t/*\n\t * separate the trigger from the filter (k:v [if filter])\n\t * allowing for whitespace in the trigger\n\t */\n\tp = trigger = param;\n\tdo {\n\t\tp = strstr(p, \"if\");\n\t\tif (!p)\n\t\t\tbreak;\n\t\tif (p == param)\n\t\t\treturn -EINVAL;\n\t\tif (*(p - 1) != ' ' && *(p - 1) != '\\t') {\n\t\t\tp++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (p >= param + strlen(param) - (sizeof(\"if\") - 1) - 1)\n\t\t\treturn -EINVAL;\n\t\tif (*(p + sizeof(\"if\") - 1) != ' ' && *(p + sizeof(\"if\") - 1) != '\\t') {\n\t\t\tp++;\n\t\t\tcontinue;\n\t\t}\n\t\tbreak;\n\t} while (p);\n\n\tif (!p)\n\t\tparam = NULL;\n\telse {\n\t\t*(p - 1) = '\\0';\n\t\tparam = strstrip(p);\n\t\ttrigger = strstrip(trigger);\n\t}\n\n\t/*\n\t * To simplify arithmetic expression parsing, replace occurrences of\n\t * '.sym-offset' modifier with '.symXoffset'\n\t */\n\tstart = strstr(trigger, \".sym-offset\");\n\twhile (start) {\n\t\t*(start + 4) = 'X';\n\t\tstart = strstr(start + 11, \".sym-offset\");\n\t}\n\n\tattrs = parse_hist_trigger_attrs(file->tr, trigger);\n\tif (IS_ERR(attrs))\n\t\treturn PTR_ERR(attrs);\n\n\tif (attrs->map_bits)\n\t\thist_trigger_bits = attrs->map_bits;\n\n\thist_data = create_hist_data(hist_trigger_bits, attrs, file, remove);\n\tif (IS_ERR(hist_data)) {\n\t\tdestroy_hist_trigger_attrs(attrs);\n\t\treturn PTR_ERR(hist_data);\n\t}\n\n\ttrigger_ops = cmd_ops->get_trigger_ops(cmd, trigger);\n\n\ttrigger_data = kzalloc(sizeof(*trigger_data), GFP_KERNEL);\n\tif (!trigger_data) {\n\t\tret = -ENOMEM;\n\t\tgoto out_free;\n\t}\n\n\ttrigger_data->count = -1;\n\ttrigger_data->ops = trigger_ops;\n\ttrigger_data->cmd_ops = cmd_ops;\n\n\tINIT_LIST_HEAD(&trigger_data->list);\n\tRCU_INIT_POINTER(trigger_data->filter, NULL);\n\n\ttrigger_data->private_data = hist_data;\n\n\t/* if param is non-empty, it's supposed to be a filter */\n\tif (param && cmd_ops->set_filter) {\n\t\tret = cmd_ops->set_filter(param, trigger_data, file);\n\t\tif (ret < 0)\n\t\t\tgoto out_free;\n\t}\n\n\tif (remove) {\n\t\tif (!have_hist_trigger_match(trigger_data, file))\n\t\t\tgoto out_free;\n\n\t\tif (hist_trigger_check_refs(trigger_data, file)) {\n\t\t\tret = -EBUSY;\n\t\t\tgoto out_free;\n\t\t}\n\n\t\tcmd_ops->unreg(glob+1, trigger_data, file);\n\t\tse_name = trace_event_name(file->event_call);\n\t\tse = find_synth_event(se_name);\n\t\tif (se)\n\t\t\tse->ref--;\n\t\tret = 0;\n\t\tgoto out_free;\n\t}\n\n\tret = cmd_ops->reg(glob, trigger_data, file);\n\t/*\n\t * The above returns on success the # of triggers registered,\n\t * but if it didn't register any it returns zero.  Consider no\n\t * triggers registered a failure too.\n\t */\n\tif (!ret) {\n\t\tif (!(attrs->pause || attrs->cont || attrs->clear))\n\t\t\tret = -ENOENT;\n\t\tgoto out_free;\n\t} else if (ret < 0)\n\t\tgoto out_free;\n\n\tif (get_named_trigger_data(trigger_data))\n\t\tgoto enable;\n\n\tif (has_hist_vars(hist_data))\n\t\tsave_hist_vars(hist_data);\n\n\tret = create_actions(hist_data);\n\tif (ret)\n\t\tgoto out_unreg;\n\n\tret = tracing_map_init(hist_data->map);\n\tif (ret)\n\t\tgoto out_unreg;\nenable:\n\tret = hist_trigger_enable(trigger_data, file);\n\tif (ret)\n\t\tgoto out_unreg;\n\n\tse_name = trace_event_name(file->event_call);\n\tse = find_synth_event(se_name);\n\tif (se)\n\t\tse->ref++;\n\t/* Just return zero, not the number of registered triggers */\n\tret = 0;\n out:\n\tif (ret == 0)\n\t\thist_err_clear();\n\n\treturn ret;\n out_unreg:\n\tcmd_ops->unreg(glob+1, trigger_data, file);\n out_free:\n\tif (cmd_ops->set_filter)\n\t\tcmd_ops->set_filter(NULL, trigger_data, NULL);\n\n\tremove_hist_vars(hist_data);\n\n\tkfree(trigger_data);\n\n\tdestroy_hist_data(hist_data);\n\tgoto out;\n}"
  },
  {
    "function_name": "hist_unreg_all",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
    "lines": "6117-6147",
    "snippet": "static void hist_unreg_all(struct trace_event_file *file)\n{\n\tstruct event_trigger_data *test, *n;\n\tstruct hist_trigger_data *hist_data;\n\tstruct synth_event *se;\n\tconst char *se_name;\n\n\tlockdep_assert_held(&event_mutex);\n\n\tif (hist_file_check_refs(file))\n\t\treturn;\n\n\tlist_for_each_entry_safe(test, n, &file->triggers, list) {\n\t\tif (test->cmd_ops->trigger_type == ETT_EVENT_HIST) {\n\t\t\thist_data = test->private_data;\n\t\t\tlist_del_rcu(&test->list);\n\t\t\ttrace_event_trigger_enable_disable(file, 0);\n\n\t\t\tse_name = trace_event_name(file->event_call);\n\t\t\tse = find_synth_event(se_name);\n\t\t\tif (se)\n\t\t\t\tse->ref--;\n\n\t\t\tupdate_cond_flag(file);\n\t\t\tif (hist_data->enable_timestamps)\n\t\t\t\ttracing_set_filter_buffering(file->tr, false);\n\t\t\tif (test->ops->free)\n\t\t\t\ttest->ops->free(test->ops, test);\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include \"tracing_map.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "test->ops->free",
          "args": [
            "test->ops",
            "test"
          ],
          "line": 6144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tracing_set_filter_buffering",
          "args": [
            "file->tr",
            "false"
          ],
          "line": 6142
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_set_filter_buffering",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "7324-7345",
          "snippet": "int tracing_set_filter_buffering(struct trace_array *tr, bool set)\n{\n\tint ret = 0;\n\n\tmutex_lock(&trace_types_lock);\n\n\tif (set && tr->no_filter_buffering_ref++)\n\t\tgoto out;\n\n\tif (!set) {\n\t\tif (WARN_ON_ONCE(!tr->no_filter_buffering_ref)) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\t--tr->no_filter_buffering_ref;\n\t}\n out:\n\tmutex_unlock(&trace_types_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nint tracing_set_filter_buffering(struct trace_array *tr, bool set)\n{\n\tint ret = 0;\n\n\tmutex_lock(&trace_types_lock);\n\n\tif (set && tr->no_filter_buffering_ref++)\n\t\tgoto out;\n\n\tif (!set) {\n\t\tif (WARN_ON_ONCE(!tr->no_filter_buffering_ref)) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\t--tr->no_filter_buffering_ref;\n\t}\n out:\n\tmutex_unlock(&trace_types_lock);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_cond_flag",
          "args": [
            "file"
          ],
          "line": 6140
        },
        "resolved": true,
        "details": {
          "function_name": "update_cond_flag",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_trigger.c",
          "lines": "519-538",
          "snippet": "void update_cond_flag(struct trace_event_file *file)\n{\n\tstruct event_trigger_data *data;\n\tbool set_cond = false;\n\n\tlockdep_assert_held(&event_mutex);\n\n\tlist_for_each_entry(data, &file->triggers, list) {\n\t\tif (data->filter || event_command_post_trigger(data->cmd_ops) ||\n\t\t    event_command_needs_rec(data->cmd_ops)) {\n\t\t\tset_cond = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (set_cond)\n\t\tset_bit(EVENT_FILE_FL_TRIGGER_COND_BIT, &file->flags);\n\telse\n\t\tclear_bit(EVENT_FILE_FL_TRIGGER_COND_BIT, &file->flags);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/security.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/security.h>\n\nvoid update_cond_flag(struct trace_event_file *file)\n{\n\tstruct event_trigger_data *data;\n\tbool set_cond = false;\n\n\tlockdep_assert_held(&event_mutex);\n\n\tlist_for_each_entry(data, &file->triggers, list) {\n\t\tif (data->filter || event_command_post_trigger(data->cmd_ops) ||\n\t\t    event_command_needs_rec(data->cmd_ops)) {\n\t\t\tset_cond = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (set_cond)\n\t\tset_bit(EVENT_FILE_FL_TRIGGER_COND_BIT, &file->flags);\n\telse\n\t\tclear_bit(EVENT_FILE_FL_TRIGGER_COND_BIT, &file->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_synth_event",
          "args": [
            "se_name"
          ],
          "line": 6136
        },
        "resolved": true,
        "details": {
          "function_name": "find_synth_event",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_synth.c",
          "lines": "748-762",
          "snippet": "struct synth_event *find_synth_event(const char *name)\n{\n\tstruct dyn_event *pos;\n\tstruct synth_event *event;\n\n\tfor_each_dyn_event(pos) {\n\t\tif (!is_synth_event(pos))\n\t\t\tcontinue;\n\t\tevent = to_synth_event(pos);\n\t\tif (strcmp(event->name, name) == 0)\n\t\t\treturn event;\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstruct synth_event *find_synth_event(const char *name)\n{\n\tstruct dyn_event *pos;\n\tstruct synth_event *event;\n\n\tfor_each_dyn_event(pos) {\n\t\tif (!is_synth_event(pos))\n\t\t\tcontinue;\n\t\tevent = to_synth_event(pos);\n\t\tif (strcmp(event->name, name) == 0)\n\t\t\treturn event;\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_event_name",
          "args": [
            "file->event_call"
          ],
          "line": 6135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_event_trigger_enable_disable",
          "args": [
            "file",
            "0"
          ],
          "line": 6133
        },
        "resolved": true,
        "details": {
          "function_name": "trace_event_trigger_enable_disable",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_trigger.c",
          "lines": "460-478",
          "snippet": "int trace_event_trigger_enable_disable(struct trace_event_file *file,\n\t\t\t\t       int trigger_enable)\n{\n\tint ret = 0;\n\n\tif (trigger_enable) {\n\t\tif (atomic_inc_return(&file->tm_ref) > 1)\n\t\t\treturn ret;\n\t\tset_bit(EVENT_FILE_FL_TRIGGER_MODE_BIT, &file->flags);\n\t\tret = trace_event_enable_disable(file, 1, 1);\n\t} else {\n\t\tif (atomic_dec_return(&file->tm_ref) > 0)\n\t\t\treturn ret;\n\t\tclear_bit(EVENT_FILE_FL_TRIGGER_MODE_BIT, &file->flags);\n\t\tret = trace_event_enable_disable(file, 0, 1);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/security.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/security.h>\n\nint trace_event_trigger_enable_disable(struct trace_event_file *file,\n\t\t\t\t       int trigger_enable)\n{\n\tint ret = 0;\n\n\tif (trigger_enable) {\n\t\tif (atomic_inc_return(&file->tm_ref) > 1)\n\t\t\treturn ret;\n\t\tset_bit(EVENT_FILE_FL_TRIGGER_MODE_BIT, &file->flags);\n\t\tret = trace_event_enable_disable(file, 1, 1);\n\t} else {\n\t\tif (atomic_dec_return(&file->tm_ref) > 0)\n\t\t\treturn ret;\n\t\tclear_bit(EVENT_FILE_FL_TRIGGER_MODE_BIT, &file->flags);\n\t\tret = trace_event_enable_disable(file, 0, 1);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_rcu",
          "args": [
            "&test->list"
          ],
          "line": 6132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "test",
            "n",
            "&file->triggers",
            "list"
          ],
          "line": 6129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hist_file_check_refs",
          "args": [
            "file"
          ],
          "line": 6126
        },
        "resolved": true,
        "details": {
          "function_name": "hist_file_check_refs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "6099-6115",
          "snippet": "static bool hist_file_check_refs(struct trace_event_file *file)\n{\n\tstruct hist_trigger_data *hist_data;\n\tstruct event_trigger_data *test;\n\n\tlockdep_assert_held(&event_mutex);\n\n\tlist_for_each_entry(test, &file->triggers, list) {\n\t\tif (test->cmd_ops->trigger_type == ETT_EVENT_HIST) {\n\t\t\thist_data = test->private_data;\n\t\t\tif (check_var_refs(hist_data))\n\t\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic bool hist_file_check_refs(struct trace_event_file *file)\n{\n\tstruct hist_trigger_data *hist_data;\n\tstruct event_trigger_data *test;\n\n\tlockdep_assert_held(&event_mutex);\n\n\tlist_for_each_entry(test, &file->triggers, list) {\n\t\tif (test->cmd_ops->trigger_type == ETT_EVENT_HIST) {\n\t\t\thist_data = test->private_data;\n\t\t\tif (check_var_refs(hist_data))\n\t\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&event_mutex"
          ],
          "line": 6124
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void hist_unreg_all(struct trace_event_file *file)\n{\n\tstruct event_trigger_data *test, *n;\n\tstruct hist_trigger_data *hist_data;\n\tstruct synth_event *se;\n\tconst char *se_name;\n\n\tlockdep_assert_held(&event_mutex);\n\n\tif (hist_file_check_refs(file))\n\t\treturn;\n\n\tlist_for_each_entry_safe(test, n, &file->triggers, list) {\n\t\tif (test->cmd_ops->trigger_type == ETT_EVENT_HIST) {\n\t\t\thist_data = test->private_data;\n\t\t\tlist_del_rcu(&test->list);\n\t\t\ttrace_event_trigger_enable_disable(file, 0);\n\n\t\t\tse_name = trace_event_name(file->event_call);\n\t\t\tse = find_synth_event(se_name);\n\t\t\tif (se)\n\t\t\t\tse->ref--;\n\n\t\t\tupdate_cond_flag(file);\n\t\t\tif (hist_data->enable_timestamps)\n\t\t\t\ttracing_set_filter_buffering(file->tr, false);\n\t\t\tif (test->ops->free)\n\t\t\t\ttest->ops->free(test->ops, test);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "hist_file_check_refs",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
    "lines": "6099-6115",
    "snippet": "static bool hist_file_check_refs(struct trace_event_file *file)\n{\n\tstruct hist_trigger_data *hist_data;\n\tstruct event_trigger_data *test;\n\n\tlockdep_assert_held(&event_mutex);\n\n\tlist_for_each_entry(test, &file->triggers, list) {\n\t\tif (test->cmd_ops->trigger_type == ETT_EVENT_HIST) {\n\t\t\thist_data = test->private_data;\n\t\t\tif (check_var_refs(hist_data))\n\t\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include \"tracing_map.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "check_var_refs",
          "args": [
            "hist_data"
          ],
          "line": 6109
        },
        "resolved": true,
        "details": {
          "function_name": "check_var_refs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "944-961",
          "snippet": "static bool check_var_refs(struct hist_trigger_data *hist_data)\n{\n\tstruct hist_field *field;\n\tbool found = false;\n\tint i;\n\n\tfor_each_hist_field(i, hist_data) {\n\t\tfield = hist_data->fields[i];\n\t\tif (field && field->flags & HIST_FIELD_FL_VAR) {\n\t\t\tif (find_any_var_ref(hist_data, field->var.idx)) {\n\t\t\t\tfound = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn found;\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic bool check_var_refs(struct hist_trigger_data *hist_data)\n{\n\tstruct hist_field *field;\n\tbool found = false;\n\tint i;\n\n\tfor_each_hist_field(i, hist_data) {\n\t\tfield = hist_data->fields[i];\n\t\tif (field && field->flags & HIST_FIELD_FL_VAR) {\n\t\t\tif (find_any_var_ref(hist_data, field->var.idx)) {\n\t\t\t\tfound = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn found;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "test",
            "&file->triggers",
            "list"
          ],
          "line": 6106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&event_mutex"
          ],
          "line": 6104
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic bool hist_file_check_refs(struct trace_event_file *file)\n{\n\tstruct hist_trigger_data *hist_data;\n\tstruct event_trigger_data *test;\n\n\tlockdep_assert_held(&event_mutex);\n\n\tlist_for_each_entry(test, &file->triggers, list) {\n\t\tif (test->cmd_ops->trigger_type == ETT_EVENT_HIST) {\n\t\t\thist_data = test->private_data;\n\t\t\tif (check_var_refs(hist_data))\n\t\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}"
  },
  {
    "function_name": "hist_unregister_trigger",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
    "lines": "6065-6097",
    "snippet": "static void hist_unregister_trigger(char *glob,\n\t\t\t\t    struct event_trigger_data *data,\n\t\t\t\t    struct trace_event_file *file)\n{\n\tstruct hist_trigger_data *hist_data = data->private_data;\n\tstruct event_trigger_data *test, *named_data = NULL;\n\tbool unregistered = false;\n\n\tlockdep_assert_held(&event_mutex);\n\n\tif (hist_data->attrs->name)\n\t\tnamed_data = find_named_trigger(hist_data->attrs->name);\n\n\tlist_for_each_entry(test, &file->triggers, list) {\n\t\tif (test->cmd_ops->trigger_type == ETT_EVENT_HIST) {\n\t\t\tif (!hist_trigger_match(data, test, named_data, false))\n\t\t\t\tcontinue;\n\t\t\tunregistered = true;\n\t\t\tlist_del_rcu(&test->list);\n\t\t\ttrace_event_trigger_enable_disable(file, 0);\n\t\t\tupdate_cond_flag(file);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (unregistered && test->ops->free)\n\t\ttest->ops->free(test->ops, test);\n\n\tif (hist_data->enable_timestamps) {\n\t\tif (!hist_data->remove || unregistered)\n\t\t\ttracing_set_filter_buffering(file->tr, false);\n\t}\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include \"tracing_map.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tracing_set_filter_buffering",
          "args": [
            "file->tr",
            "false"
          ],
          "line": 6095
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_set_filter_buffering",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "7324-7345",
          "snippet": "int tracing_set_filter_buffering(struct trace_array *tr, bool set)\n{\n\tint ret = 0;\n\n\tmutex_lock(&trace_types_lock);\n\n\tif (set && tr->no_filter_buffering_ref++)\n\t\tgoto out;\n\n\tif (!set) {\n\t\tif (WARN_ON_ONCE(!tr->no_filter_buffering_ref)) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\t--tr->no_filter_buffering_ref;\n\t}\n out:\n\tmutex_unlock(&trace_types_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nint tracing_set_filter_buffering(struct trace_array *tr, bool set)\n{\n\tint ret = 0;\n\n\tmutex_lock(&trace_types_lock);\n\n\tif (set && tr->no_filter_buffering_ref++)\n\t\tgoto out;\n\n\tif (!set) {\n\t\tif (WARN_ON_ONCE(!tr->no_filter_buffering_ref)) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\t--tr->no_filter_buffering_ref;\n\t}\n out:\n\tmutex_unlock(&trace_types_lock);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test->ops->free",
          "args": [
            "test->ops",
            "test"
          ],
          "line": 6091
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "update_cond_flag",
          "args": [
            "file"
          ],
          "line": 6085
        },
        "resolved": true,
        "details": {
          "function_name": "update_cond_flag",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_trigger.c",
          "lines": "519-538",
          "snippet": "void update_cond_flag(struct trace_event_file *file)\n{\n\tstruct event_trigger_data *data;\n\tbool set_cond = false;\n\n\tlockdep_assert_held(&event_mutex);\n\n\tlist_for_each_entry(data, &file->triggers, list) {\n\t\tif (data->filter || event_command_post_trigger(data->cmd_ops) ||\n\t\t    event_command_needs_rec(data->cmd_ops)) {\n\t\t\tset_cond = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (set_cond)\n\t\tset_bit(EVENT_FILE_FL_TRIGGER_COND_BIT, &file->flags);\n\telse\n\t\tclear_bit(EVENT_FILE_FL_TRIGGER_COND_BIT, &file->flags);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/security.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/security.h>\n\nvoid update_cond_flag(struct trace_event_file *file)\n{\n\tstruct event_trigger_data *data;\n\tbool set_cond = false;\n\n\tlockdep_assert_held(&event_mutex);\n\n\tlist_for_each_entry(data, &file->triggers, list) {\n\t\tif (data->filter || event_command_post_trigger(data->cmd_ops) ||\n\t\t    event_command_needs_rec(data->cmd_ops)) {\n\t\t\tset_cond = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (set_cond)\n\t\tset_bit(EVENT_FILE_FL_TRIGGER_COND_BIT, &file->flags);\n\telse\n\t\tclear_bit(EVENT_FILE_FL_TRIGGER_COND_BIT, &file->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_event_trigger_enable_disable",
          "args": [
            "file",
            "0"
          ],
          "line": 6084
        },
        "resolved": true,
        "details": {
          "function_name": "trace_event_trigger_enable_disable",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_trigger.c",
          "lines": "460-478",
          "snippet": "int trace_event_trigger_enable_disable(struct trace_event_file *file,\n\t\t\t\t       int trigger_enable)\n{\n\tint ret = 0;\n\n\tif (trigger_enable) {\n\t\tif (atomic_inc_return(&file->tm_ref) > 1)\n\t\t\treturn ret;\n\t\tset_bit(EVENT_FILE_FL_TRIGGER_MODE_BIT, &file->flags);\n\t\tret = trace_event_enable_disable(file, 1, 1);\n\t} else {\n\t\tif (atomic_dec_return(&file->tm_ref) > 0)\n\t\t\treturn ret;\n\t\tclear_bit(EVENT_FILE_FL_TRIGGER_MODE_BIT, &file->flags);\n\t\tret = trace_event_enable_disable(file, 0, 1);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/security.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/security.h>\n\nint trace_event_trigger_enable_disable(struct trace_event_file *file,\n\t\t\t\t       int trigger_enable)\n{\n\tint ret = 0;\n\n\tif (trigger_enable) {\n\t\tif (atomic_inc_return(&file->tm_ref) > 1)\n\t\t\treturn ret;\n\t\tset_bit(EVENT_FILE_FL_TRIGGER_MODE_BIT, &file->flags);\n\t\tret = trace_event_enable_disable(file, 1, 1);\n\t} else {\n\t\tif (atomic_dec_return(&file->tm_ref) > 0)\n\t\t\treturn ret;\n\t\tclear_bit(EVENT_FILE_FL_TRIGGER_MODE_BIT, &file->flags);\n\t\tret = trace_event_enable_disable(file, 0, 1);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_rcu",
          "args": [
            "&test->list"
          ],
          "line": 6083
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hist_trigger_match",
          "args": [
            "data",
            "test",
            "named_data",
            "false"
          ],
          "line": 6080
        },
        "resolved": true,
        "details": {
          "function_name": "hist_trigger_match",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "5842-5911",
          "snippet": "static bool hist_trigger_match(struct event_trigger_data *data,\n\t\t\t       struct event_trigger_data *data_test,\n\t\t\t       struct event_trigger_data *named_data,\n\t\t\t       bool ignore_filter)\n{\n\tstruct tracing_map_sort_key *sort_key, *sort_key_test;\n\tstruct hist_trigger_data *hist_data, *hist_data_test;\n\tstruct hist_field *key_field, *key_field_test;\n\tunsigned int i;\n\n\tif (named_data && (named_data != data_test) &&\n\t    (named_data != data_test->named_data))\n\t\treturn false;\n\n\tif (!named_data && is_named_trigger(data_test))\n\t\treturn false;\n\n\thist_data = data->private_data;\n\thist_data_test = data_test->private_data;\n\n\tif (hist_data->n_vals != hist_data_test->n_vals ||\n\t    hist_data->n_fields != hist_data_test->n_fields ||\n\t    hist_data->n_sort_keys != hist_data_test->n_sort_keys)\n\t\treturn false;\n\n\tif (!ignore_filter) {\n\t\tif ((data->filter_str && !data_test->filter_str) ||\n\t\t   (!data->filter_str && data_test->filter_str))\n\t\t\treturn false;\n\t}\n\n\tfor_each_hist_field(i, hist_data) {\n\t\tkey_field = hist_data->fields[i];\n\t\tkey_field_test = hist_data_test->fields[i];\n\n\t\tif (key_field->flags != key_field_test->flags)\n\t\t\treturn false;\n\t\tif (!compatible_field(key_field->field, key_field_test->field))\n\t\t\treturn false;\n\t\tif (key_field->offset != key_field_test->offset)\n\t\t\treturn false;\n\t\tif (key_field->size != key_field_test->size)\n\t\t\treturn false;\n\t\tif (key_field->is_signed != key_field_test->is_signed)\n\t\t\treturn false;\n\t\tif (!!key_field->var.name != !!key_field_test->var.name)\n\t\t\treturn false;\n\t\tif (key_field->var.name &&\n\t\t    strcmp(key_field->var.name, key_field_test->var.name) != 0)\n\t\t\treturn false;\n\t}\n\n\tfor (i = 0; i < hist_data->n_sort_keys; i++) {\n\t\tsort_key = &hist_data->sort_keys[i];\n\t\tsort_key_test = &hist_data_test->sort_keys[i];\n\n\t\tif (sort_key->field_idx != sort_key_test->field_idx ||\n\t\t    sort_key->descending != sort_key_test->descending)\n\t\t\treturn false;\n\t}\n\n\tif (!ignore_filter && data->filter_str &&\n\t    (strcmp(data->filter_str, data_test->filter_str) != 0))\n\t\treturn false;\n\n\tif (!actions_match(hist_data, hist_data_test))\n\t\treturn false;\n\n\treturn true;\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);\n\nstatic bool hist_trigger_match(struct event_trigger_data *data,\n\t\t\t       struct event_trigger_data *data_test,\n\t\t\t       struct event_trigger_data *named_data,\n\t\t\t       bool ignore_filter)\n{\n\tstruct tracing_map_sort_key *sort_key, *sort_key_test;\n\tstruct hist_trigger_data *hist_data, *hist_data_test;\n\tstruct hist_field *key_field, *key_field_test;\n\tunsigned int i;\n\n\tif (named_data && (named_data != data_test) &&\n\t    (named_data != data_test->named_data))\n\t\treturn false;\n\n\tif (!named_data && is_named_trigger(data_test))\n\t\treturn false;\n\n\thist_data = data->private_data;\n\thist_data_test = data_test->private_data;\n\n\tif (hist_data->n_vals != hist_data_test->n_vals ||\n\t    hist_data->n_fields != hist_data_test->n_fields ||\n\t    hist_data->n_sort_keys != hist_data_test->n_sort_keys)\n\t\treturn false;\n\n\tif (!ignore_filter) {\n\t\tif ((data->filter_str && !data_test->filter_str) ||\n\t\t   (!data->filter_str && data_test->filter_str))\n\t\t\treturn false;\n\t}\n\n\tfor_each_hist_field(i, hist_data) {\n\t\tkey_field = hist_data->fields[i];\n\t\tkey_field_test = hist_data_test->fields[i];\n\n\t\tif (key_field->flags != key_field_test->flags)\n\t\t\treturn false;\n\t\tif (!compatible_field(key_field->field, key_field_test->field))\n\t\t\treturn false;\n\t\tif (key_field->offset != key_field_test->offset)\n\t\t\treturn false;\n\t\tif (key_field->size != key_field_test->size)\n\t\t\treturn false;\n\t\tif (key_field->is_signed != key_field_test->is_signed)\n\t\t\treturn false;\n\t\tif (!!key_field->var.name != !!key_field_test->var.name)\n\t\t\treturn false;\n\t\tif (key_field->var.name &&\n\t\t    strcmp(key_field->var.name, key_field_test->var.name) != 0)\n\t\t\treturn false;\n\t}\n\n\tfor (i = 0; i < hist_data->n_sort_keys; i++) {\n\t\tsort_key = &hist_data->sort_keys[i];\n\t\tsort_key_test = &hist_data_test->sort_keys[i];\n\n\t\tif (sort_key->field_idx != sort_key_test->field_idx ||\n\t\t    sort_key->descending != sort_key_test->descending)\n\t\t\treturn false;\n\t}\n\n\tif (!ignore_filter && data->filter_str &&\n\t    (strcmp(data->filter_str, data_test->filter_str) != 0))\n\t\treturn false;\n\n\tif (!actions_match(hist_data, hist_data_test))\n\t\treturn false;\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "test",
            "&file->triggers",
            "list"
          ],
          "line": 6078
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_named_trigger",
          "args": [
            "hist_data->attrs->name"
          ],
          "line": 6076
        },
        "resolved": true,
        "details": {
          "function_name": "find_named_trigger",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_trigger.c",
          "lines": "1160-1175",
          "snippet": "struct event_trigger_data *find_named_trigger(const char *name)\n{\n\tstruct event_trigger_data *data;\n\n\tif (!name)\n\t\treturn NULL;\n\n\tlist_for_each_entry(data, &named_triggers, named_list) {\n\t\tif (data->named_data)\n\t\t\tcontinue;\n\t\tif (strcmp(data->name, name) == 0)\n\t\t\treturn data;\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/security.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(named_triggers);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/security.h>\n\nstatic LIST_HEAD(named_triggers);\n\nstruct event_trigger_data *find_named_trigger(const char *name)\n{\n\tstruct event_trigger_data *data;\n\n\tif (!name)\n\t\treturn NULL;\n\n\tlist_for_each_entry(data, &named_triggers, named_list) {\n\t\tif (data->named_data)\n\t\t\tcontinue;\n\t\tif (strcmp(data->name, name) == 0)\n\t\t\treturn data;\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&event_mutex"
          ],
          "line": 6073
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);\n\nstatic void hist_unregister_trigger(char *glob,\n\t\t\t\t    struct event_trigger_data *data,\n\t\t\t\t    struct trace_event_file *file)\n{\n\tstruct hist_trigger_data *hist_data = data->private_data;\n\tstruct event_trigger_data *test, *named_data = NULL;\n\tbool unregistered = false;\n\n\tlockdep_assert_held(&event_mutex);\n\n\tif (hist_data->attrs->name)\n\t\tnamed_data = find_named_trigger(hist_data->attrs->name);\n\n\tlist_for_each_entry(test, &file->triggers, list) {\n\t\tif (test->cmd_ops->trigger_type == ETT_EVENT_HIST) {\n\t\t\tif (!hist_trigger_match(data, test, named_data, false))\n\t\t\t\tcontinue;\n\t\t\tunregistered = true;\n\t\t\tlist_del_rcu(&test->list);\n\t\t\ttrace_event_trigger_enable_disable(file, 0);\n\t\t\tupdate_cond_flag(file);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (unregistered && test->ops->free)\n\t\ttest->ops->free(test->ops, test);\n\n\tif (hist_data->enable_timestamps) {\n\t\tif (!hist_data->remove || unregistered)\n\t\t\ttracing_set_filter_buffering(file->tr, false);\n\t}\n}"
  },
  {
    "function_name": "hist_trigger_check_refs",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
    "lines": "6040-6063",
    "snippet": "static bool hist_trigger_check_refs(struct event_trigger_data *data,\n\t\t\t\t    struct trace_event_file *file)\n{\n\tstruct hist_trigger_data *hist_data = data->private_data;\n\tstruct event_trigger_data *test, *named_data = NULL;\n\n\tlockdep_assert_held(&event_mutex);\n\n\tif (hist_data->attrs->name)\n\t\tnamed_data = find_named_trigger(hist_data->attrs->name);\n\n\tlist_for_each_entry(test, &file->triggers, list) {\n\t\tif (test->cmd_ops->trigger_type == ETT_EVENT_HIST) {\n\t\t\tif (!hist_trigger_match(data, test, named_data, false))\n\t\t\t\tcontinue;\n\t\t\thist_data = test->private_data;\n\t\t\tif (check_var_refs(hist_data))\n\t\t\t\treturn true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn false;\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include \"tracing_map.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "check_var_refs",
          "args": [
            "hist_data"
          ],
          "line": 6056
        },
        "resolved": true,
        "details": {
          "function_name": "check_var_refs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "944-961",
          "snippet": "static bool check_var_refs(struct hist_trigger_data *hist_data)\n{\n\tstruct hist_field *field;\n\tbool found = false;\n\tint i;\n\n\tfor_each_hist_field(i, hist_data) {\n\t\tfield = hist_data->fields[i];\n\t\tif (field && field->flags & HIST_FIELD_FL_VAR) {\n\t\t\tif (find_any_var_ref(hist_data, field->var.idx)) {\n\t\t\t\tfound = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn found;\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic bool check_var_refs(struct hist_trigger_data *hist_data)\n{\n\tstruct hist_field *field;\n\tbool found = false;\n\tint i;\n\n\tfor_each_hist_field(i, hist_data) {\n\t\tfield = hist_data->fields[i];\n\t\tif (field && field->flags & HIST_FIELD_FL_VAR) {\n\t\t\tif (find_any_var_ref(hist_data, field->var.idx)) {\n\t\t\t\tfound = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn found;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hist_trigger_match",
          "args": [
            "data",
            "test",
            "named_data",
            "false"
          ],
          "line": 6053
        },
        "resolved": true,
        "details": {
          "function_name": "hist_trigger_match",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "5842-5911",
          "snippet": "static bool hist_trigger_match(struct event_trigger_data *data,\n\t\t\t       struct event_trigger_data *data_test,\n\t\t\t       struct event_trigger_data *named_data,\n\t\t\t       bool ignore_filter)\n{\n\tstruct tracing_map_sort_key *sort_key, *sort_key_test;\n\tstruct hist_trigger_data *hist_data, *hist_data_test;\n\tstruct hist_field *key_field, *key_field_test;\n\tunsigned int i;\n\n\tif (named_data && (named_data != data_test) &&\n\t    (named_data != data_test->named_data))\n\t\treturn false;\n\n\tif (!named_data && is_named_trigger(data_test))\n\t\treturn false;\n\n\thist_data = data->private_data;\n\thist_data_test = data_test->private_data;\n\n\tif (hist_data->n_vals != hist_data_test->n_vals ||\n\t    hist_data->n_fields != hist_data_test->n_fields ||\n\t    hist_data->n_sort_keys != hist_data_test->n_sort_keys)\n\t\treturn false;\n\n\tif (!ignore_filter) {\n\t\tif ((data->filter_str && !data_test->filter_str) ||\n\t\t   (!data->filter_str && data_test->filter_str))\n\t\t\treturn false;\n\t}\n\n\tfor_each_hist_field(i, hist_data) {\n\t\tkey_field = hist_data->fields[i];\n\t\tkey_field_test = hist_data_test->fields[i];\n\n\t\tif (key_field->flags != key_field_test->flags)\n\t\t\treturn false;\n\t\tif (!compatible_field(key_field->field, key_field_test->field))\n\t\t\treturn false;\n\t\tif (key_field->offset != key_field_test->offset)\n\t\t\treturn false;\n\t\tif (key_field->size != key_field_test->size)\n\t\t\treturn false;\n\t\tif (key_field->is_signed != key_field_test->is_signed)\n\t\t\treturn false;\n\t\tif (!!key_field->var.name != !!key_field_test->var.name)\n\t\t\treturn false;\n\t\tif (key_field->var.name &&\n\t\t    strcmp(key_field->var.name, key_field_test->var.name) != 0)\n\t\t\treturn false;\n\t}\n\n\tfor (i = 0; i < hist_data->n_sort_keys; i++) {\n\t\tsort_key = &hist_data->sort_keys[i];\n\t\tsort_key_test = &hist_data_test->sort_keys[i];\n\n\t\tif (sort_key->field_idx != sort_key_test->field_idx ||\n\t\t    sort_key->descending != sort_key_test->descending)\n\t\t\treturn false;\n\t}\n\n\tif (!ignore_filter && data->filter_str &&\n\t    (strcmp(data->filter_str, data_test->filter_str) != 0))\n\t\treturn false;\n\n\tif (!actions_match(hist_data, hist_data_test))\n\t\treturn false;\n\n\treturn true;\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);\n\nstatic bool hist_trigger_match(struct event_trigger_data *data,\n\t\t\t       struct event_trigger_data *data_test,\n\t\t\t       struct event_trigger_data *named_data,\n\t\t\t       bool ignore_filter)\n{\n\tstruct tracing_map_sort_key *sort_key, *sort_key_test;\n\tstruct hist_trigger_data *hist_data, *hist_data_test;\n\tstruct hist_field *key_field, *key_field_test;\n\tunsigned int i;\n\n\tif (named_data && (named_data != data_test) &&\n\t    (named_data != data_test->named_data))\n\t\treturn false;\n\n\tif (!named_data && is_named_trigger(data_test))\n\t\treturn false;\n\n\thist_data = data->private_data;\n\thist_data_test = data_test->private_data;\n\n\tif (hist_data->n_vals != hist_data_test->n_vals ||\n\t    hist_data->n_fields != hist_data_test->n_fields ||\n\t    hist_data->n_sort_keys != hist_data_test->n_sort_keys)\n\t\treturn false;\n\n\tif (!ignore_filter) {\n\t\tif ((data->filter_str && !data_test->filter_str) ||\n\t\t   (!data->filter_str && data_test->filter_str))\n\t\t\treturn false;\n\t}\n\n\tfor_each_hist_field(i, hist_data) {\n\t\tkey_field = hist_data->fields[i];\n\t\tkey_field_test = hist_data_test->fields[i];\n\n\t\tif (key_field->flags != key_field_test->flags)\n\t\t\treturn false;\n\t\tif (!compatible_field(key_field->field, key_field_test->field))\n\t\t\treturn false;\n\t\tif (key_field->offset != key_field_test->offset)\n\t\t\treturn false;\n\t\tif (key_field->size != key_field_test->size)\n\t\t\treturn false;\n\t\tif (key_field->is_signed != key_field_test->is_signed)\n\t\t\treturn false;\n\t\tif (!!key_field->var.name != !!key_field_test->var.name)\n\t\t\treturn false;\n\t\tif (key_field->var.name &&\n\t\t    strcmp(key_field->var.name, key_field_test->var.name) != 0)\n\t\t\treturn false;\n\t}\n\n\tfor (i = 0; i < hist_data->n_sort_keys; i++) {\n\t\tsort_key = &hist_data->sort_keys[i];\n\t\tsort_key_test = &hist_data_test->sort_keys[i];\n\n\t\tif (sort_key->field_idx != sort_key_test->field_idx ||\n\t\t    sort_key->descending != sort_key_test->descending)\n\t\t\treturn false;\n\t}\n\n\tif (!ignore_filter && data->filter_str &&\n\t    (strcmp(data->filter_str, data_test->filter_str) != 0))\n\t\treturn false;\n\n\tif (!actions_match(hist_data, hist_data_test))\n\t\treturn false;\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "test",
            "&file->triggers",
            "list"
          ],
          "line": 6051
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_named_trigger",
          "args": [
            "hist_data->attrs->name"
          ],
          "line": 6049
        },
        "resolved": true,
        "details": {
          "function_name": "find_named_trigger",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_trigger.c",
          "lines": "1160-1175",
          "snippet": "struct event_trigger_data *find_named_trigger(const char *name)\n{\n\tstruct event_trigger_data *data;\n\n\tif (!name)\n\t\treturn NULL;\n\n\tlist_for_each_entry(data, &named_triggers, named_list) {\n\t\tif (data->named_data)\n\t\t\tcontinue;\n\t\tif (strcmp(data->name, name) == 0)\n\t\t\treturn data;\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/security.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(named_triggers);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/security.h>\n\nstatic LIST_HEAD(named_triggers);\n\nstruct event_trigger_data *find_named_trigger(const char *name)\n{\n\tstruct event_trigger_data *data;\n\n\tif (!name)\n\t\treturn NULL;\n\n\tlist_for_each_entry(data, &named_triggers, named_list) {\n\t\tif (data->named_data)\n\t\t\tcontinue;\n\t\tif (strcmp(data->name, name) == 0)\n\t\t\treturn data;\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&event_mutex"
          ],
          "line": 6046
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);\n\nstatic bool hist_trigger_check_refs(struct event_trigger_data *data,\n\t\t\t\t    struct trace_event_file *file)\n{\n\tstruct hist_trigger_data *hist_data = data->private_data;\n\tstruct event_trigger_data *test, *named_data = NULL;\n\n\tlockdep_assert_held(&event_mutex);\n\n\tif (hist_data->attrs->name)\n\t\tnamed_data = find_named_trigger(hist_data->attrs->name);\n\n\tlist_for_each_entry(test, &file->triggers, list) {\n\t\tif (test->cmd_ops->trigger_type == ETT_EVENT_HIST) {\n\t\t\tif (!hist_trigger_match(data, test, named_data, false))\n\t\t\t\tcontinue;\n\t\t\thist_data = test->private_data;\n\t\t\tif (check_var_refs(hist_data))\n\t\t\t\treturn true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn false;\n}"
  },
  {
    "function_name": "have_hist_trigger_match",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
    "lines": "6016-6038",
    "snippet": "static bool have_hist_trigger_match(struct event_trigger_data *data,\n\t\t\t\t    struct trace_event_file *file)\n{\n\tstruct hist_trigger_data *hist_data = data->private_data;\n\tstruct event_trigger_data *test, *named_data = NULL;\n\tbool match = false;\n\n\tlockdep_assert_held(&event_mutex);\n\n\tif (hist_data->attrs->name)\n\t\tnamed_data = find_named_trigger(hist_data->attrs->name);\n\n\tlist_for_each_entry(test, &file->triggers, list) {\n\t\tif (test->cmd_ops->trigger_type == ETT_EVENT_HIST) {\n\t\t\tif (hist_trigger_match(data, test, named_data, false)) {\n\t\t\t\tmatch = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn match;\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include \"tracing_map.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "hist_trigger_match",
          "args": [
            "data",
            "test",
            "named_data",
            "false"
          ],
          "line": 6030
        },
        "resolved": true,
        "details": {
          "function_name": "hist_trigger_match",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "5842-5911",
          "snippet": "static bool hist_trigger_match(struct event_trigger_data *data,\n\t\t\t       struct event_trigger_data *data_test,\n\t\t\t       struct event_trigger_data *named_data,\n\t\t\t       bool ignore_filter)\n{\n\tstruct tracing_map_sort_key *sort_key, *sort_key_test;\n\tstruct hist_trigger_data *hist_data, *hist_data_test;\n\tstruct hist_field *key_field, *key_field_test;\n\tunsigned int i;\n\n\tif (named_data && (named_data != data_test) &&\n\t    (named_data != data_test->named_data))\n\t\treturn false;\n\n\tif (!named_data && is_named_trigger(data_test))\n\t\treturn false;\n\n\thist_data = data->private_data;\n\thist_data_test = data_test->private_data;\n\n\tif (hist_data->n_vals != hist_data_test->n_vals ||\n\t    hist_data->n_fields != hist_data_test->n_fields ||\n\t    hist_data->n_sort_keys != hist_data_test->n_sort_keys)\n\t\treturn false;\n\n\tif (!ignore_filter) {\n\t\tif ((data->filter_str && !data_test->filter_str) ||\n\t\t   (!data->filter_str && data_test->filter_str))\n\t\t\treturn false;\n\t}\n\n\tfor_each_hist_field(i, hist_data) {\n\t\tkey_field = hist_data->fields[i];\n\t\tkey_field_test = hist_data_test->fields[i];\n\n\t\tif (key_field->flags != key_field_test->flags)\n\t\t\treturn false;\n\t\tif (!compatible_field(key_field->field, key_field_test->field))\n\t\t\treturn false;\n\t\tif (key_field->offset != key_field_test->offset)\n\t\t\treturn false;\n\t\tif (key_field->size != key_field_test->size)\n\t\t\treturn false;\n\t\tif (key_field->is_signed != key_field_test->is_signed)\n\t\t\treturn false;\n\t\tif (!!key_field->var.name != !!key_field_test->var.name)\n\t\t\treturn false;\n\t\tif (key_field->var.name &&\n\t\t    strcmp(key_field->var.name, key_field_test->var.name) != 0)\n\t\t\treturn false;\n\t}\n\n\tfor (i = 0; i < hist_data->n_sort_keys; i++) {\n\t\tsort_key = &hist_data->sort_keys[i];\n\t\tsort_key_test = &hist_data_test->sort_keys[i];\n\n\t\tif (sort_key->field_idx != sort_key_test->field_idx ||\n\t\t    sort_key->descending != sort_key_test->descending)\n\t\t\treturn false;\n\t}\n\n\tif (!ignore_filter && data->filter_str &&\n\t    (strcmp(data->filter_str, data_test->filter_str) != 0))\n\t\treturn false;\n\n\tif (!actions_match(hist_data, hist_data_test))\n\t\treturn false;\n\n\treturn true;\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);\n\nstatic bool hist_trigger_match(struct event_trigger_data *data,\n\t\t\t       struct event_trigger_data *data_test,\n\t\t\t       struct event_trigger_data *named_data,\n\t\t\t       bool ignore_filter)\n{\n\tstruct tracing_map_sort_key *sort_key, *sort_key_test;\n\tstruct hist_trigger_data *hist_data, *hist_data_test;\n\tstruct hist_field *key_field, *key_field_test;\n\tunsigned int i;\n\n\tif (named_data && (named_data != data_test) &&\n\t    (named_data != data_test->named_data))\n\t\treturn false;\n\n\tif (!named_data && is_named_trigger(data_test))\n\t\treturn false;\n\n\thist_data = data->private_data;\n\thist_data_test = data_test->private_data;\n\n\tif (hist_data->n_vals != hist_data_test->n_vals ||\n\t    hist_data->n_fields != hist_data_test->n_fields ||\n\t    hist_data->n_sort_keys != hist_data_test->n_sort_keys)\n\t\treturn false;\n\n\tif (!ignore_filter) {\n\t\tif ((data->filter_str && !data_test->filter_str) ||\n\t\t   (!data->filter_str && data_test->filter_str))\n\t\t\treturn false;\n\t}\n\n\tfor_each_hist_field(i, hist_data) {\n\t\tkey_field = hist_data->fields[i];\n\t\tkey_field_test = hist_data_test->fields[i];\n\n\t\tif (key_field->flags != key_field_test->flags)\n\t\t\treturn false;\n\t\tif (!compatible_field(key_field->field, key_field_test->field))\n\t\t\treturn false;\n\t\tif (key_field->offset != key_field_test->offset)\n\t\t\treturn false;\n\t\tif (key_field->size != key_field_test->size)\n\t\t\treturn false;\n\t\tif (key_field->is_signed != key_field_test->is_signed)\n\t\t\treturn false;\n\t\tif (!!key_field->var.name != !!key_field_test->var.name)\n\t\t\treturn false;\n\t\tif (key_field->var.name &&\n\t\t    strcmp(key_field->var.name, key_field_test->var.name) != 0)\n\t\t\treturn false;\n\t}\n\n\tfor (i = 0; i < hist_data->n_sort_keys; i++) {\n\t\tsort_key = &hist_data->sort_keys[i];\n\t\tsort_key_test = &hist_data_test->sort_keys[i];\n\n\t\tif (sort_key->field_idx != sort_key_test->field_idx ||\n\t\t    sort_key->descending != sort_key_test->descending)\n\t\t\treturn false;\n\t}\n\n\tif (!ignore_filter && data->filter_str &&\n\t    (strcmp(data->filter_str, data_test->filter_str) != 0))\n\t\treturn false;\n\n\tif (!actions_match(hist_data, hist_data_test))\n\t\treturn false;\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "test",
            "&file->triggers",
            "list"
          ],
          "line": 6028
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_named_trigger",
          "args": [
            "hist_data->attrs->name"
          ],
          "line": 6026
        },
        "resolved": true,
        "details": {
          "function_name": "find_named_trigger",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_trigger.c",
          "lines": "1160-1175",
          "snippet": "struct event_trigger_data *find_named_trigger(const char *name)\n{\n\tstruct event_trigger_data *data;\n\n\tif (!name)\n\t\treturn NULL;\n\n\tlist_for_each_entry(data, &named_triggers, named_list) {\n\t\tif (data->named_data)\n\t\t\tcontinue;\n\t\tif (strcmp(data->name, name) == 0)\n\t\t\treturn data;\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/security.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(named_triggers);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/security.h>\n\nstatic LIST_HEAD(named_triggers);\n\nstruct event_trigger_data *find_named_trigger(const char *name)\n{\n\tstruct event_trigger_data *data;\n\n\tif (!name)\n\t\treturn NULL;\n\n\tlist_for_each_entry(data, &named_triggers, named_list) {\n\t\tif (data->named_data)\n\t\t\tcontinue;\n\t\tif (strcmp(data->name, name) == 0)\n\t\t\treturn data;\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&event_mutex"
          ],
          "line": 6023
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);\n\nstatic bool have_hist_trigger_match(struct event_trigger_data *data,\n\t\t\t\t    struct trace_event_file *file)\n{\n\tstruct hist_trigger_data *hist_data = data->private_data;\n\tstruct event_trigger_data *test, *named_data = NULL;\n\tbool match = false;\n\n\tlockdep_assert_held(&event_mutex);\n\n\tif (hist_data->attrs->name)\n\t\tnamed_data = find_named_trigger(hist_data->attrs->name);\n\n\tlist_for_each_entry(test, &file->triggers, list) {\n\t\tif (test->cmd_ops->trigger_type == ETT_EVENT_HIST) {\n\t\t\tif (hist_trigger_match(data, test, named_data, false)) {\n\t\t\t\tmatch = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn match;\n}"
  },
  {
    "function_name": "hist_trigger_enable",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
    "lines": "5998-6014",
    "snippet": "static int hist_trigger_enable(struct event_trigger_data *data,\n\t\t\t       struct trace_event_file *file)\n{\n\tint ret = 0;\n\n\tlist_add_tail_rcu(&data->list, &file->triggers);\n\n\tupdate_cond_flag(file);\n\n\tif (trace_event_trigger_enable_disable(file, 1) < 0) {\n\t\tlist_del_rcu(&data->list);\n\t\tupdate_cond_flag(file);\n\t\tret--;\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include \"tracing_map.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "update_cond_flag",
          "args": [
            "file"
          ],
          "line": 6009
        },
        "resolved": true,
        "details": {
          "function_name": "update_cond_flag",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_trigger.c",
          "lines": "519-538",
          "snippet": "void update_cond_flag(struct trace_event_file *file)\n{\n\tstruct event_trigger_data *data;\n\tbool set_cond = false;\n\n\tlockdep_assert_held(&event_mutex);\n\n\tlist_for_each_entry(data, &file->triggers, list) {\n\t\tif (data->filter || event_command_post_trigger(data->cmd_ops) ||\n\t\t    event_command_needs_rec(data->cmd_ops)) {\n\t\t\tset_cond = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (set_cond)\n\t\tset_bit(EVENT_FILE_FL_TRIGGER_COND_BIT, &file->flags);\n\telse\n\t\tclear_bit(EVENT_FILE_FL_TRIGGER_COND_BIT, &file->flags);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/security.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/security.h>\n\nvoid update_cond_flag(struct trace_event_file *file)\n{\n\tstruct event_trigger_data *data;\n\tbool set_cond = false;\n\n\tlockdep_assert_held(&event_mutex);\n\n\tlist_for_each_entry(data, &file->triggers, list) {\n\t\tif (data->filter || event_command_post_trigger(data->cmd_ops) ||\n\t\t    event_command_needs_rec(data->cmd_ops)) {\n\t\t\tset_cond = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (set_cond)\n\t\tset_bit(EVENT_FILE_FL_TRIGGER_COND_BIT, &file->flags);\n\telse\n\t\tclear_bit(EVENT_FILE_FL_TRIGGER_COND_BIT, &file->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_rcu",
          "args": [
            "&data->list"
          ],
          "line": 6008
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_event_trigger_enable_disable",
          "args": [
            "file",
            "1"
          ],
          "line": 6007
        },
        "resolved": true,
        "details": {
          "function_name": "trace_event_trigger_enable_disable",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_trigger.c",
          "lines": "460-478",
          "snippet": "int trace_event_trigger_enable_disable(struct trace_event_file *file,\n\t\t\t\t       int trigger_enable)\n{\n\tint ret = 0;\n\n\tif (trigger_enable) {\n\t\tif (atomic_inc_return(&file->tm_ref) > 1)\n\t\t\treturn ret;\n\t\tset_bit(EVENT_FILE_FL_TRIGGER_MODE_BIT, &file->flags);\n\t\tret = trace_event_enable_disable(file, 1, 1);\n\t} else {\n\t\tif (atomic_dec_return(&file->tm_ref) > 0)\n\t\t\treturn ret;\n\t\tclear_bit(EVENT_FILE_FL_TRIGGER_MODE_BIT, &file->flags);\n\t\tret = trace_event_enable_disable(file, 0, 1);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/security.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/security.h>\n\nint trace_event_trigger_enable_disable(struct trace_event_file *file,\n\t\t\t\t       int trigger_enable)\n{\n\tint ret = 0;\n\n\tif (trigger_enable) {\n\t\tif (atomic_inc_return(&file->tm_ref) > 1)\n\t\t\treturn ret;\n\t\tset_bit(EVENT_FILE_FL_TRIGGER_MODE_BIT, &file->flags);\n\t\tret = trace_event_enable_disable(file, 1, 1);\n\t} else {\n\t\tif (atomic_dec_return(&file->tm_ref) > 0)\n\t\t\treturn ret;\n\t\tclear_bit(EVENT_FILE_FL_TRIGGER_MODE_BIT, &file->flags);\n\t\tret = trace_event_enable_disable(file, 0, 1);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add_tail_rcu",
          "args": [
            "&data->list",
            "&file->triggers"
          ],
          "line": 6003
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);\n\nstatic int hist_trigger_enable(struct event_trigger_data *data,\n\t\t\t       struct trace_event_file *file)\n{\n\tint ret = 0;\n\n\tlist_add_tail_rcu(&data->list, &file->triggers);\n\n\tupdate_cond_flag(file);\n\n\tif (trace_event_trigger_enable_disable(file, 1) < 0) {\n\t\tlist_del_rcu(&data->list);\n\t\tupdate_cond_flag(file);\n\t\tret--;\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "hist_register_trigger",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
    "lines": "5913-5996",
    "snippet": "static int hist_register_trigger(char *glob,\n\t\t\t\t struct event_trigger_data *data,\n\t\t\t\t struct trace_event_file *file)\n{\n\tstruct hist_trigger_data *hist_data = data->private_data;\n\tstruct event_trigger_data *test, *named_data = NULL;\n\tstruct trace_array *tr = file->tr;\n\tint ret = 0;\n\n\tif (hist_data->attrs->name) {\n\t\tnamed_data = find_named_trigger(hist_data->attrs->name);\n\t\tif (named_data) {\n\t\t\tif (!hist_trigger_match(data, named_data, named_data,\n\t\t\t\t\t\ttrue)) {\n\t\t\t\thist_err(tr, HIST_ERR_NAMED_MISMATCH, errpos(hist_data->attrs->name));\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (hist_data->attrs->name && !named_data)\n\t\tgoto new;\n\n\tlockdep_assert_held(&event_mutex);\n\n\tlist_for_each_entry(test, &file->triggers, list) {\n\t\tif (test->cmd_ops->trigger_type == ETT_EVENT_HIST) {\n\t\t\tif (!hist_trigger_match(data, test, named_data, false))\n\t\t\t\tcontinue;\n\t\t\tif (hist_data->attrs->pause)\n\t\t\t\ttest->paused = true;\n\t\t\telse if (hist_data->attrs->cont)\n\t\t\t\ttest->paused = false;\n\t\t\telse if (hist_data->attrs->clear)\n\t\t\t\thist_clear(test);\n\t\t\telse {\n\t\t\t\thist_err(tr, HIST_ERR_TRIGGER_EEXIST, 0);\n\t\t\t\tret = -EEXIST;\n\t\t\t}\n\t\t\tgoto out;\n\t\t}\n\t}\n new:\n\tif (hist_data->attrs->cont || hist_data->attrs->clear) {\n\t\thist_err(tr, HIST_ERR_TRIGGER_ENOENT_CLEAR, 0);\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tif (hist_data->attrs->pause)\n\t\tdata->paused = true;\n\n\tif (named_data) {\n\t\tdata->private_data = named_data->private_data;\n\t\tset_named_trigger_data(data, named_data);\n\t\tdata->ops = &event_hist_trigger_named_ops;\n\t}\n\n\tif (data->ops->init) {\n\t\tret = data->ops->init(data->ops, data);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\n\tif (hist_data->enable_timestamps) {\n\t\tchar *clock = hist_data->attrs->clock;\n\n\t\tret = tracing_set_clock(file->tr, hist_data->attrs->clock);\n\t\tif (ret) {\n\t\t\thist_err(tr, HIST_ERR_SET_CLOCK_FAIL, errpos(clock));\n\t\t\tgoto out;\n\t\t}\n\n\t\ttracing_set_filter_buffering(file->tr, true);\n\t}\n\n\tif (named_data)\n\t\tdestroy_hist_data(hist_data);\n\n\tret++;\n out:\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include \"tracing_map.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);",
      "static struct event_trigger_ops event_hist_trigger_named_ops = {\n\t.trigger\t\t= event_hist_trigger,\n\t.print\t\t\t= event_hist_trigger_print,\n\t.init\t\t\t= event_hist_trigger_named_init,\n\t.free\t\t\t= event_hist_trigger_named_free,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "destroy_hist_data",
          "args": [
            "hist_data"
          ],
          "line": 5991
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_hist_data",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "4799-4813",
          "snippet": "static void destroy_hist_data(struct hist_trigger_data *hist_data)\n{\n\tif (!hist_data)\n\t\treturn;\n\n\tdestroy_hist_trigger_attrs(hist_data->attrs);\n\tdestroy_hist_fields(hist_data);\n\ttracing_map_destroy(hist_data->map);\n\n\tdestroy_actions(hist_data);\n\tdestroy_field_vars(hist_data);\n\tdestroy_field_var_hists(hist_data);\n\n\tkfree(hist_data);\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void destroy_hist_data(struct hist_trigger_data *hist_data)\n{\n\tif (!hist_data)\n\t\treturn;\n\n\tdestroy_hist_trigger_attrs(hist_data->attrs);\n\tdestroy_hist_fields(hist_data);\n\ttracing_map_destroy(hist_data->map);\n\n\tdestroy_actions(hist_data);\n\tdestroy_field_vars(hist_data);\n\tdestroy_field_var_hists(hist_data);\n\n\tkfree(hist_data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracing_set_filter_buffering",
          "args": [
            "file->tr",
            "true"
          ],
          "line": 5987
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_set_filter_buffering",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "7324-7345",
          "snippet": "int tracing_set_filter_buffering(struct trace_array *tr, bool set)\n{\n\tint ret = 0;\n\n\tmutex_lock(&trace_types_lock);\n\n\tif (set && tr->no_filter_buffering_ref++)\n\t\tgoto out;\n\n\tif (!set) {\n\t\tif (WARN_ON_ONCE(!tr->no_filter_buffering_ref)) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\t--tr->no_filter_buffering_ref;\n\t}\n out:\n\tmutex_unlock(&trace_types_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nint tracing_set_filter_buffering(struct trace_array *tr, bool set)\n{\n\tint ret = 0;\n\n\tmutex_lock(&trace_types_lock);\n\n\tif (set && tr->no_filter_buffering_ref++)\n\t\tgoto out;\n\n\tif (!set) {\n\t\tif (WARN_ON_ONCE(!tr->no_filter_buffering_ref)) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\t--tr->no_filter_buffering_ref;\n\t}\n out:\n\tmutex_unlock(&trace_types_lock);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hist_err",
          "args": [
            "tr",
            "HIST_ERR_SET_CLOCK_FAIL",
            "errpos(clock)"
          ],
          "line": 5983
        },
        "resolved": true,
        "details": {
          "function_name": "hist_err",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "763-767",
          "snippet": "static void hist_err(struct trace_array *tr, u8 err_type, u8 err_pos)\n{\n\ttracing_log_err(tr, last_cmd_loc, last_cmd, err_text,\n\t\t\terr_type, err_pos);\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *err_text[] = { ERRORS };",
            "static char last_cmd[MAX_FILTER_STR_VAL];",
            "static char last_cmd_loc[MAX_FILTER_STR_VAL];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic const char *err_text[] = { ERRORS };\nstatic char last_cmd[MAX_FILTER_STR_VAL];\nstatic char last_cmd_loc[MAX_FILTER_STR_VAL];\n\nstatic void hist_err(struct trace_array *tr, u8 err_type, u8 err_pos)\n{\n\ttracing_log_err(tr, last_cmd_loc, last_cmd, err_text,\n\t\t\terr_type, err_pos);\n}"
        }
      },
      {
        "call_info": {
          "callee": "errpos",
          "args": [
            "clock"
          ],
          "line": 5983
        },
        "resolved": true,
        "details": {
          "function_name": "errpos",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "733-736",
          "snippet": "static int errpos(char *str)\n{\n\treturn err_pos(last_cmd, str);\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char last_cmd[MAX_FILTER_STR_VAL];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic char last_cmd[MAX_FILTER_STR_VAL];\n\nstatic int errpos(char *str)\n{\n\treturn err_pos(last_cmd, str);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracing_set_clock",
          "args": [
            "file->tr",
            "hist_data->attrs->clock"
          ],
          "line": 5981
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_set_clock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "7203-7235",
          "snippet": "int tracing_set_clock(struct trace_array *tr, const char *clockstr)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(trace_clocks); i++) {\n\t\tif (strcmp(trace_clocks[i].name, clockstr) == 0)\n\t\t\tbreak;\n\t}\n\tif (i == ARRAY_SIZE(trace_clocks))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&trace_types_lock);\n\n\ttr->clock_id = i;\n\n\tring_buffer_set_clock(tr->array_buffer.buffer, trace_clocks[i].func);\n\n\t/*\n\t * New clock may not be consistent with the previous clock.\n\t * Reset the buffer so that it doesn't have incomparable timestamps.\n\t */\n\ttracing_reset_online_cpus(&tr->array_buffer);\n\n#ifdef CONFIG_TRACER_MAX_TRACE\n\tif (tr->max_buffer.buffer)\n\t\tring_buffer_set_clock(tr->max_buffer.buffer, trace_clocks[i].func);\n\ttracing_reset_online_cpus(&tr->max_buffer);\n#endif\n\n\tmutex_unlock(&trace_types_lock);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct",
            "static struct {\n\tu64 (*func)(void);\n\tconst char *name;\n\tint in_ns;\t\t/* is this clock in nanoseconds? */\n} trace_clocks[] = {\n\t{ trace_clock_local,\t\t\"local\",\t1 },\n\t{ trace_clock_global,\t\t\"global\",\t1 },\n\t{ trace_clock_counter,\t\t\"counter\",\t0 },\n\t{ trace_clock_jiffies,\t\t\"uptime\",\t0 },\n\t{ trace_clock,\t\t\t\"perf\",\t\t1 },\n\t{ ktime_get_mono_fast_ns,\t\"mono\",\t\t1 },\n\t{ ktime_get_raw_fast_ns,\t\"mono_raw\",\t1 },\n\t{ ktime_get_boot_fast_ns,\t\"boot\",\t\t1 },\n\tARCH_TRACE_CLOCKS\n};",
            "static void add_tracer_options(struct trace_array *tr, struct tracer *t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\nstatic struct {\n\tu64 (*func)(void);\n\tconst char *name;\n\tint in_ns;\t\t/* is this clock in nanoseconds? */\n} trace_clocks[] = {\n\t{ trace_clock_local,\t\t\"local\",\t1 },\n\t{ trace_clock_global,\t\t\"global\",\t1 },\n\t{ trace_clock_counter,\t\t\"counter\",\t0 },\n\t{ trace_clock_jiffies,\t\t\"uptime\",\t0 },\n\t{ trace_clock,\t\t\t\"perf\",\t\t1 },\n\t{ ktime_get_mono_fast_ns,\t\"mono\",\t\t1 },\n\t{ ktime_get_raw_fast_ns,\t\"mono_raw\",\t1 },\n\t{ ktime_get_boot_fast_ns,\t\"boot\",\t\t1 },\n\tARCH_TRACE_CLOCKS\n};\nstatic void add_tracer_options(struct trace_array *tr, struct tracer *t);\n\nint tracing_set_clock(struct trace_array *tr, const char *clockstr)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(trace_clocks); i++) {\n\t\tif (strcmp(trace_clocks[i].name, clockstr) == 0)\n\t\t\tbreak;\n\t}\n\tif (i == ARRAY_SIZE(trace_clocks))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&trace_types_lock);\n\n\ttr->clock_id = i;\n\n\tring_buffer_set_clock(tr->array_buffer.buffer, trace_clocks[i].func);\n\n\t/*\n\t * New clock may not be consistent with the previous clock.\n\t * Reset the buffer so that it doesn't have incomparable timestamps.\n\t */\n\ttracing_reset_online_cpus(&tr->array_buffer);\n\n#ifdef CONFIG_TRACER_MAX_TRACE\n\tif (tr->max_buffer.buffer)\n\t\tring_buffer_set_clock(tr->max_buffer.buffer, trace_clocks[i].func);\n\ttracing_reset_online_cpus(&tr->max_buffer);\n#endif\n\n\tmutex_unlock(&trace_types_lock);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "data->ops->init",
          "args": [
            "data->ops",
            "data"
          ],
          "line": 5973
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_named_trigger_data",
          "args": [
            "data",
            "named_data"
          ],
          "line": 5968
        },
        "resolved": true,
        "details": {
          "function_name": "set_named_trigger_data",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_trigger.c",
          "lines": "1281-1285",
          "snippet": "void set_named_trigger_data(struct event_trigger_data *data,\n\t\t\t    struct event_trigger_data *named_data)\n{\n\tdata->named_data = named_data;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/security.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/security.h>\n\nvoid set_named_trigger_data(struct event_trigger_data *data,\n\t\t\t    struct event_trigger_data *named_data)\n{\n\tdata->named_data = named_data;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hist_clear",
          "args": [
            "test"
          ],
          "line": 5948
        },
        "resolved": true,
        "details": {
          "function_name": "hist_clear",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "5808-5821",
          "snippet": "static void hist_clear(struct event_trigger_data *data)\n{\n\tstruct hist_trigger_data *hist_data = data->private_data;\n\n\tif (data->name)\n\t\tpause_named_trigger(data);\n\n\ttracepoint_synchronize_unregister();\n\n\ttracing_map_clear(hist_data->map);\n\n\tif (data->name)\n\t\tunpause_named_trigger(data);\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);\n\nstatic void hist_clear(struct event_trigger_data *data)\n{\n\tstruct hist_trigger_data *hist_data = data->private_data;\n\n\tif (data->name)\n\t\tpause_named_trigger(data);\n\n\ttracepoint_synchronize_unregister();\n\n\ttracing_map_clear(hist_data->map);\n\n\tif (data->name)\n\t\tunpause_named_trigger(data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hist_trigger_match",
          "args": [
            "data",
            "test",
            "named_data",
            "false"
          ],
          "line": 5941
        },
        "resolved": true,
        "details": {
          "function_name": "hist_trigger_match",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "5842-5911",
          "snippet": "static bool hist_trigger_match(struct event_trigger_data *data,\n\t\t\t       struct event_trigger_data *data_test,\n\t\t\t       struct event_trigger_data *named_data,\n\t\t\t       bool ignore_filter)\n{\n\tstruct tracing_map_sort_key *sort_key, *sort_key_test;\n\tstruct hist_trigger_data *hist_data, *hist_data_test;\n\tstruct hist_field *key_field, *key_field_test;\n\tunsigned int i;\n\n\tif (named_data && (named_data != data_test) &&\n\t    (named_data != data_test->named_data))\n\t\treturn false;\n\n\tif (!named_data && is_named_trigger(data_test))\n\t\treturn false;\n\n\thist_data = data->private_data;\n\thist_data_test = data_test->private_data;\n\n\tif (hist_data->n_vals != hist_data_test->n_vals ||\n\t    hist_data->n_fields != hist_data_test->n_fields ||\n\t    hist_data->n_sort_keys != hist_data_test->n_sort_keys)\n\t\treturn false;\n\n\tif (!ignore_filter) {\n\t\tif ((data->filter_str && !data_test->filter_str) ||\n\t\t   (!data->filter_str && data_test->filter_str))\n\t\t\treturn false;\n\t}\n\n\tfor_each_hist_field(i, hist_data) {\n\t\tkey_field = hist_data->fields[i];\n\t\tkey_field_test = hist_data_test->fields[i];\n\n\t\tif (key_field->flags != key_field_test->flags)\n\t\t\treturn false;\n\t\tif (!compatible_field(key_field->field, key_field_test->field))\n\t\t\treturn false;\n\t\tif (key_field->offset != key_field_test->offset)\n\t\t\treturn false;\n\t\tif (key_field->size != key_field_test->size)\n\t\t\treturn false;\n\t\tif (key_field->is_signed != key_field_test->is_signed)\n\t\t\treturn false;\n\t\tif (!!key_field->var.name != !!key_field_test->var.name)\n\t\t\treturn false;\n\t\tif (key_field->var.name &&\n\t\t    strcmp(key_field->var.name, key_field_test->var.name) != 0)\n\t\t\treturn false;\n\t}\n\n\tfor (i = 0; i < hist_data->n_sort_keys; i++) {\n\t\tsort_key = &hist_data->sort_keys[i];\n\t\tsort_key_test = &hist_data_test->sort_keys[i];\n\n\t\tif (sort_key->field_idx != sort_key_test->field_idx ||\n\t\t    sort_key->descending != sort_key_test->descending)\n\t\t\treturn false;\n\t}\n\n\tif (!ignore_filter && data->filter_str &&\n\t    (strcmp(data->filter_str, data_test->filter_str) != 0))\n\t\treturn false;\n\n\tif (!actions_match(hist_data, hist_data_test))\n\t\treturn false;\n\n\treturn true;\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);\n\nstatic bool hist_trigger_match(struct event_trigger_data *data,\n\t\t\t       struct event_trigger_data *data_test,\n\t\t\t       struct event_trigger_data *named_data,\n\t\t\t       bool ignore_filter)\n{\n\tstruct tracing_map_sort_key *sort_key, *sort_key_test;\n\tstruct hist_trigger_data *hist_data, *hist_data_test;\n\tstruct hist_field *key_field, *key_field_test;\n\tunsigned int i;\n\n\tif (named_data && (named_data != data_test) &&\n\t    (named_data != data_test->named_data))\n\t\treturn false;\n\n\tif (!named_data && is_named_trigger(data_test))\n\t\treturn false;\n\n\thist_data = data->private_data;\n\thist_data_test = data_test->private_data;\n\n\tif (hist_data->n_vals != hist_data_test->n_vals ||\n\t    hist_data->n_fields != hist_data_test->n_fields ||\n\t    hist_data->n_sort_keys != hist_data_test->n_sort_keys)\n\t\treturn false;\n\n\tif (!ignore_filter) {\n\t\tif ((data->filter_str && !data_test->filter_str) ||\n\t\t   (!data->filter_str && data_test->filter_str))\n\t\t\treturn false;\n\t}\n\n\tfor_each_hist_field(i, hist_data) {\n\t\tkey_field = hist_data->fields[i];\n\t\tkey_field_test = hist_data_test->fields[i];\n\n\t\tif (key_field->flags != key_field_test->flags)\n\t\t\treturn false;\n\t\tif (!compatible_field(key_field->field, key_field_test->field))\n\t\t\treturn false;\n\t\tif (key_field->offset != key_field_test->offset)\n\t\t\treturn false;\n\t\tif (key_field->size != key_field_test->size)\n\t\t\treturn false;\n\t\tif (key_field->is_signed != key_field_test->is_signed)\n\t\t\treturn false;\n\t\tif (!!key_field->var.name != !!key_field_test->var.name)\n\t\t\treturn false;\n\t\tif (key_field->var.name &&\n\t\t    strcmp(key_field->var.name, key_field_test->var.name) != 0)\n\t\t\treturn false;\n\t}\n\n\tfor (i = 0; i < hist_data->n_sort_keys; i++) {\n\t\tsort_key = &hist_data->sort_keys[i];\n\t\tsort_key_test = &hist_data_test->sort_keys[i];\n\n\t\tif (sort_key->field_idx != sort_key_test->field_idx ||\n\t\t    sort_key->descending != sort_key_test->descending)\n\t\t\treturn false;\n\t}\n\n\tif (!ignore_filter && data->filter_str &&\n\t    (strcmp(data->filter_str, data_test->filter_str) != 0))\n\t\treturn false;\n\n\tif (!actions_match(hist_data, hist_data_test))\n\t\treturn false;\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "test",
            "&file->triggers",
            "list"
          ],
          "line": 5939
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&event_mutex"
          ],
          "line": 5937
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_named_trigger",
          "args": [
            "hist_data->attrs->name"
          ],
          "line": 5923
        },
        "resolved": true,
        "details": {
          "function_name": "find_named_trigger",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_trigger.c",
          "lines": "1160-1175",
          "snippet": "struct event_trigger_data *find_named_trigger(const char *name)\n{\n\tstruct event_trigger_data *data;\n\n\tif (!name)\n\t\treturn NULL;\n\n\tlist_for_each_entry(data, &named_triggers, named_list) {\n\t\tif (data->named_data)\n\t\t\tcontinue;\n\t\tif (strcmp(data->name, name) == 0)\n\t\t\treturn data;\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/security.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(named_triggers);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/security.h>\n\nstatic LIST_HEAD(named_triggers);\n\nstruct event_trigger_data *find_named_trigger(const char *name)\n{\n\tstruct event_trigger_data *data;\n\n\tif (!name)\n\t\treturn NULL;\n\n\tlist_for_each_entry(data, &named_triggers, named_list) {\n\t\tif (data->named_data)\n\t\t\tcontinue;\n\t\tif (strcmp(data->name, name) == 0)\n\t\t\treturn data;\n\t}\n\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);\nstatic struct event_trigger_ops event_hist_trigger_named_ops = {\n\t.trigger\t\t= event_hist_trigger,\n\t.print\t\t\t= event_hist_trigger_print,\n\t.init\t\t\t= event_hist_trigger_named_init,\n\t.free\t\t\t= event_hist_trigger_named_free,\n};\n\nstatic int hist_register_trigger(char *glob,\n\t\t\t\t struct event_trigger_data *data,\n\t\t\t\t struct trace_event_file *file)\n{\n\tstruct hist_trigger_data *hist_data = data->private_data;\n\tstruct event_trigger_data *test, *named_data = NULL;\n\tstruct trace_array *tr = file->tr;\n\tint ret = 0;\n\n\tif (hist_data->attrs->name) {\n\t\tnamed_data = find_named_trigger(hist_data->attrs->name);\n\t\tif (named_data) {\n\t\t\tif (!hist_trigger_match(data, named_data, named_data,\n\t\t\t\t\t\ttrue)) {\n\t\t\t\thist_err(tr, HIST_ERR_NAMED_MISMATCH, errpos(hist_data->attrs->name));\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (hist_data->attrs->name && !named_data)\n\t\tgoto new;\n\n\tlockdep_assert_held(&event_mutex);\n\n\tlist_for_each_entry(test, &file->triggers, list) {\n\t\tif (test->cmd_ops->trigger_type == ETT_EVENT_HIST) {\n\t\t\tif (!hist_trigger_match(data, test, named_data, false))\n\t\t\t\tcontinue;\n\t\t\tif (hist_data->attrs->pause)\n\t\t\t\ttest->paused = true;\n\t\t\telse if (hist_data->attrs->cont)\n\t\t\t\ttest->paused = false;\n\t\t\telse if (hist_data->attrs->clear)\n\t\t\t\thist_clear(test);\n\t\t\telse {\n\t\t\t\thist_err(tr, HIST_ERR_TRIGGER_EEXIST, 0);\n\t\t\t\tret = -EEXIST;\n\t\t\t}\n\t\t\tgoto out;\n\t\t}\n\t}\n new:\n\tif (hist_data->attrs->cont || hist_data->attrs->clear) {\n\t\thist_err(tr, HIST_ERR_TRIGGER_ENOENT_CLEAR, 0);\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tif (hist_data->attrs->pause)\n\t\tdata->paused = true;\n\n\tif (named_data) {\n\t\tdata->private_data = named_data->private_data;\n\t\tset_named_trigger_data(data, named_data);\n\t\tdata->ops = &event_hist_trigger_named_ops;\n\t}\n\n\tif (data->ops->init) {\n\t\tret = data->ops->init(data->ops, data);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\n\tif (hist_data->enable_timestamps) {\n\t\tchar *clock = hist_data->attrs->clock;\n\n\t\tret = tracing_set_clock(file->tr, hist_data->attrs->clock);\n\t\tif (ret) {\n\t\t\thist_err(tr, HIST_ERR_SET_CLOCK_FAIL, errpos(clock));\n\t\t\tgoto out;\n\t\t}\n\n\t\ttracing_set_filter_buffering(file->tr, true);\n\t}\n\n\tif (named_data)\n\t\tdestroy_hist_data(hist_data);\n\n\tret++;\n out:\n\treturn ret;\n}"
  },
  {
    "function_name": "hist_trigger_match",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
    "lines": "5842-5911",
    "snippet": "static bool hist_trigger_match(struct event_trigger_data *data,\n\t\t\t       struct event_trigger_data *data_test,\n\t\t\t       struct event_trigger_data *named_data,\n\t\t\t       bool ignore_filter)\n{\n\tstruct tracing_map_sort_key *sort_key, *sort_key_test;\n\tstruct hist_trigger_data *hist_data, *hist_data_test;\n\tstruct hist_field *key_field, *key_field_test;\n\tunsigned int i;\n\n\tif (named_data && (named_data != data_test) &&\n\t    (named_data != data_test->named_data))\n\t\treturn false;\n\n\tif (!named_data && is_named_trigger(data_test))\n\t\treturn false;\n\n\thist_data = data->private_data;\n\thist_data_test = data_test->private_data;\n\n\tif (hist_data->n_vals != hist_data_test->n_vals ||\n\t    hist_data->n_fields != hist_data_test->n_fields ||\n\t    hist_data->n_sort_keys != hist_data_test->n_sort_keys)\n\t\treturn false;\n\n\tif (!ignore_filter) {\n\t\tif ((data->filter_str && !data_test->filter_str) ||\n\t\t   (!data->filter_str && data_test->filter_str))\n\t\t\treturn false;\n\t}\n\n\tfor_each_hist_field(i, hist_data) {\n\t\tkey_field = hist_data->fields[i];\n\t\tkey_field_test = hist_data_test->fields[i];\n\n\t\tif (key_field->flags != key_field_test->flags)\n\t\t\treturn false;\n\t\tif (!compatible_field(key_field->field, key_field_test->field))\n\t\t\treturn false;\n\t\tif (key_field->offset != key_field_test->offset)\n\t\t\treturn false;\n\t\tif (key_field->size != key_field_test->size)\n\t\t\treturn false;\n\t\tif (key_field->is_signed != key_field_test->is_signed)\n\t\t\treturn false;\n\t\tif (!!key_field->var.name != !!key_field_test->var.name)\n\t\t\treturn false;\n\t\tif (key_field->var.name &&\n\t\t    strcmp(key_field->var.name, key_field_test->var.name) != 0)\n\t\t\treturn false;\n\t}\n\n\tfor (i = 0; i < hist_data->n_sort_keys; i++) {\n\t\tsort_key = &hist_data->sort_keys[i];\n\t\tsort_key_test = &hist_data_test->sort_keys[i];\n\n\t\tif (sort_key->field_idx != sort_key_test->field_idx ||\n\t\t    sort_key->descending != sort_key_test->descending)\n\t\t\treturn false;\n\t}\n\n\tif (!ignore_filter && data->filter_str &&\n\t    (strcmp(data->filter_str, data_test->filter_str) != 0))\n\t\treturn false;\n\n\tif (!actions_match(hist_data, hist_data_test))\n\t\treturn false;\n\n\treturn true;\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include \"tracing_map.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "actions_match",
          "args": [
            "hist_data",
            "hist_data_test"
          ],
          "line": 5907
        },
        "resolved": true,
        "details": {
          "function_name": "actions_match",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "4715-4770",
          "snippet": "static bool actions_match(struct hist_trigger_data *hist_data,\n\t\t\t  struct hist_trigger_data *hist_data_test)\n{\n\tunsigned int i, j;\n\n\tif (hist_data->n_actions != hist_data_test->n_actions)\n\t\treturn false;\n\n\tfor (i = 0; i < hist_data->n_actions; i++) {\n\t\tstruct action_data *data = hist_data->actions[i];\n\t\tstruct action_data *data_test = hist_data_test->actions[i];\n\t\tchar *action_name, *action_name_test;\n\n\t\tif (data->handler != data_test->handler)\n\t\t\treturn false;\n\t\tif (data->action != data_test->action)\n\t\t\treturn false;\n\n\t\tif (data->n_params != data_test->n_params)\n\t\t\treturn false;\n\n\t\tfor (j = 0; j < data->n_params; j++) {\n\t\t\tif (strcmp(data->params[j], data_test->params[j]) != 0)\n\t\t\t\treturn false;\n\t\t}\n\n\t\tif (data->use_trace_keyword)\n\t\t\taction_name = data->synth_event_name;\n\t\telse\n\t\t\taction_name = data->action_name;\n\n\t\tif (data_test->use_trace_keyword)\n\t\t\taction_name_test = data_test->synth_event_name;\n\t\telse\n\t\t\taction_name_test = data_test->action_name;\n\n\t\tif (strcmp(action_name, action_name_test) != 0)\n\t\t\treturn false;\n\n\t\tif (data->handler == HANDLER_ONMATCH) {\n\t\t\tif (strcmp(data->match_data.event_system,\n\t\t\t\t   data_test->match_data.event_system) != 0)\n\t\t\t\treturn false;\n\t\t\tif (strcmp(data->match_data.event,\n\t\t\t\t   data_test->match_data.event) != 0)\n\t\t\t\treturn false;\n\t\t} else if (data->handler == HANDLER_ONMAX ||\n\t\t\t   data->handler == HANDLER_ONCHANGE) {\n\t\t\tif (strcmp(data->track_data.var_str,\n\t\t\t\t   data_test->track_data.var_str) != 0)\n\t\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);\n\nstatic bool actions_match(struct hist_trigger_data *hist_data,\n\t\t\t  struct hist_trigger_data *hist_data_test)\n{\n\tunsigned int i, j;\n\n\tif (hist_data->n_actions != hist_data_test->n_actions)\n\t\treturn false;\n\n\tfor (i = 0; i < hist_data->n_actions; i++) {\n\t\tstruct action_data *data = hist_data->actions[i];\n\t\tstruct action_data *data_test = hist_data_test->actions[i];\n\t\tchar *action_name, *action_name_test;\n\n\t\tif (data->handler != data_test->handler)\n\t\t\treturn false;\n\t\tif (data->action != data_test->action)\n\t\t\treturn false;\n\n\t\tif (data->n_params != data_test->n_params)\n\t\t\treturn false;\n\n\t\tfor (j = 0; j < data->n_params; j++) {\n\t\t\tif (strcmp(data->params[j], data_test->params[j]) != 0)\n\t\t\t\treturn false;\n\t\t}\n\n\t\tif (data->use_trace_keyword)\n\t\t\taction_name = data->synth_event_name;\n\t\telse\n\t\t\taction_name = data->action_name;\n\n\t\tif (data_test->use_trace_keyword)\n\t\t\taction_name_test = data_test->synth_event_name;\n\t\telse\n\t\t\taction_name_test = data_test->action_name;\n\n\t\tif (strcmp(action_name, action_name_test) != 0)\n\t\t\treturn false;\n\n\t\tif (data->handler == HANDLER_ONMATCH) {\n\t\t\tif (strcmp(data->match_data.event_system,\n\t\t\t\t   data_test->match_data.event_system) != 0)\n\t\t\t\treturn false;\n\t\t\tif (strcmp(data->match_data.event,\n\t\t\t\t   data_test->match_data.event) != 0)\n\t\t\t\treturn false;\n\t\t} else if (data->handler == HANDLER_ONMAX ||\n\t\t\t   data->handler == HANDLER_ONCHANGE) {\n\t\t\tif (strcmp(data->track_data.var_str,\n\t\t\t\t   data_test->track_data.var_str) != 0)\n\t\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "data->filter_str",
            "data_test->filter_str"
          ],
          "line": 5904
        },
        "resolved": true,
        "details": {
          "function_name": "sym_strcmp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/report.c",
          "lines": "356-365",
          "snippet": "static int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}",
          "includes": [
            "#include \"encoding.h\"",
            "#include \"kcsan.h\"",
            "#include <linux/stacktrace.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/delay.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"encoding.h\"\n#include \"kcsan.h\"\n#include <linux/stacktrace.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/lockdep.h>\n#include <linux/kernel.h>\n#include <linux/kallsyms.h>\n#include <linux/jiffies.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n\nstatic int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}"
        }
      },
      {
        "call_info": {
          "callee": "compatible_field",
          "args": [
            "key_field->field",
            "key_field_test->field"
          ],
          "line": 5879
        },
        "resolved": true,
        "details": {
          "function_name": "compatible_field",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "5823-5840",
          "snippet": "static bool compatible_field(struct ftrace_event_field *field,\n\t\t\t     struct ftrace_event_field *test_field)\n{\n\tif (field == test_field)\n\t\treturn true;\n\tif (field == NULL || test_field == NULL)\n\t\treturn false;\n\tif (strcmp(field->name, test_field->name) != 0)\n\t\treturn false;\n\tif (strcmp(field->type, test_field->type) != 0)\n\t\treturn false;\n\tif (field->size != test_field->size)\n\t\treturn false;\n\tif (field->is_signed != test_field->is_signed)\n\t\treturn false;\n\n\treturn true;\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic bool compatible_field(struct ftrace_event_field *field,\n\t\t\t     struct ftrace_event_field *test_field)\n{\n\tif (field == test_field)\n\t\treturn true;\n\tif (field == NULL || test_field == NULL)\n\t\treturn false;\n\tif (strcmp(field->name, test_field->name) != 0)\n\t\treturn false;\n\tif (strcmp(field->type, test_field->type) != 0)\n\t\treturn false;\n\tif (field->size != test_field->size)\n\t\treturn false;\n\tif (field->is_signed != test_field->is_signed)\n\t\treturn false;\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_hist_field",
          "args": [
            "i",
            "hist_data"
          ],
          "line": 5873
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_named_trigger",
          "args": [
            "data_test"
          ],
          "line": 5856
        },
        "resolved": true,
        "details": {
          "function_name": "is_named_trigger",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_trigger.c",
          "lines": "1183-1193",
          "snippet": "bool is_named_trigger(struct event_trigger_data *test)\n{\n\tstruct event_trigger_data *data;\n\n\tlist_for_each_entry(data, &named_triggers, named_list) {\n\t\tif (test == data)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/security.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(named_triggers);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/security.h>\n\nstatic LIST_HEAD(named_triggers);\n\nbool is_named_trigger(struct event_trigger_data *test)\n{\n\tstruct event_trigger_data *data;\n\n\tlist_for_each_entry(data, &named_triggers, named_list) {\n\t\tif (test == data)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);\n\nstatic bool hist_trigger_match(struct event_trigger_data *data,\n\t\t\t       struct event_trigger_data *data_test,\n\t\t\t       struct event_trigger_data *named_data,\n\t\t\t       bool ignore_filter)\n{\n\tstruct tracing_map_sort_key *sort_key, *sort_key_test;\n\tstruct hist_trigger_data *hist_data, *hist_data_test;\n\tstruct hist_field *key_field, *key_field_test;\n\tunsigned int i;\n\n\tif (named_data && (named_data != data_test) &&\n\t    (named_data != data_test->named_data))\n\t\treturn false;\n\n\tif (!named_data && is_named_trigger(data_test))\n\t\treturn false;\n\n\thist_data = data->private_data;\n\thist_data_test = data_test->private_data;\n\n\tif (hist_data->n_vals != hist_data_test->n_vals ||\n\t    hist_data->n_fields != hist_data_test->n_fields ||\n\t    hist_data->n_sort_keys != hist_data_test->n_sort_keys)\n\t\treturn false;\n\n\tif (!ignore_filter) {\n\t\tif ((data->filter_str && !data_test->filter_str) ||\n\t\t   (!data->filter_str && data_test->filter_str))\n\t\t\treturn false;\n\t}\n\n\tfor_each_hist_field(i, hist_data) {\n\t\tkey_field = hist_data->fields[i];\n\t\tkey_field_test = hist_data_test->fields[i];\n\n\t\tif (key_field->flags != key_field_test->flags)\n\t\t\treturn false;\n\t\tif (!compatible_field(key_field->field, key_field_test->field))\n\t\t\treturn false;\n\t\tif (key_field->offset != key_field_test->offset)\n\t\t\treturn false;\n\t\tif (key_field->size != key_field_test->size)\n\t\t\treturn false;\n\t\tif (key_field->is_signed != key_field_test->is_signed)\n\t\t\treturn false;\n\t\tif (!!key_field->var.name != !!key_field_test->var.name)\n\t\t\treturn false;\n\t\tif (key_field->var.name &&\n\t\t    strcmp(key_field->var.name, key_field_test->var.name) != 0)\n\t\t\treturn false;\n\t}\n\n\tfor (i = 0; i < hist_data->n_sort_keys; i++) {\n\t\tsort_key = &hist_data->sort_keys[i];\n\t\tsort_key_test = &hist_data_test->sort_keys[i];\n\n\t\tif (sort_key->field_idx != sort_key_test->field_idx ||\n\t\t    sort_key->descending != sort_key_test->descending)\n\t\t\treturn false;\n\t}\n\n\tif (!ignore_filter && data->filter_str &&\n\t    (strcmp(data->filter_str, data_test->filter_str) != 0))\n\t\treturn false;\n\n\tif (!actions_match(hist_data, hist_data_test))\n\t\treturn false;\n\n\treturn true;\n}"
  },
  {
    "function_name": "compatible_field",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
    "lines": "5823-5840",
    "snippet": "static bool compatible_field(struct ftrace_event_field *field,\n\t\t\t     struct ftrace_event_field *test_field)\n{\n\tif (field == test_field)\n\t\treturn true;\n\tif (field == NULL || test_field == NULL)\n\t\treturn false;\n\tif (strcmp(field->name, test_field->name) != 0)\n\t\treturn false;\n\tif (strcmp(field->type, test_field->type) != 0)\n\t\treturn false;\n\tif (field->size != test_field->size)\n\t\treturn false;\n\tif (field->is_signed != test_field->is_signed)\n\t\treturn false;\n\n\treturn true;\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include \"tracing_map.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "field->type",
            "test_field->type"
          ],
          "line": 5832
        },
        "resolved": true,
        "details": {
          "function_name": "sym_strcmp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/report.c",
          "lines": "356-365",
          "snippet": "static int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}",
          "includes": [
            "#include \"encoding.h\"",
            "#include \"kcsan.h\"",
            "#include <linux/stacktrace.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/delay.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"encoding.h\"\n#include \"kcsan.h\"\n#include <linux/stacktrace.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/lockdep.h>\n#include <linux/kernel.h>\n#include <linux/kallsyms.h>\n#include <linux/jiffies.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n\nstatic int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic bool compatible_field(struct ftrace_event_field *field,\n\t\t\t     struct ftrace_event_field *test_field)\n{\n\tif (field == test_field)\n\t\treturn true;\n\tif (field == NULL || test_field == NULL)\n\t\treturn false;\n\tif (strcmp(field->name, test_field->name) != 0)\n\t\treturn false;\n\tif (strcmp(field->type, test_field->type) != 0)\n\t\treturn false;\n\tif (field->size != test_field->size)\n\t\treturn false;\n\tif (field->is_signed != test_field->is_signed)\n\t\treturn false;\n\n\treturn true;\n}"
  },
  {
    "function_name": "hist_clear",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
    "lines": "5808-5821",
    "snippet": "static void hist_clear(struct event_trigger_data *data)\n{\n\tstruct hist_trigger_data *hist_data = data->private_data;\n\n\tif (data->name)\n\t\tpause_named_trigger(data);\n\n\ttracepoint_synchronize_unregister();\n\n\ttracing_map_clear(hist_data->map);\n\n\tif (data->name)\n\t\tunpause_named_trigger(data);\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include \"tracing_map.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "unpause_named_trigger",
          "args": [
            "data"
          ],
          "line": 5820
        },
        "resolved": true,
        "details": {
          "function_name": "unpause_named_trigger",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_trigger.c",
          "lines": "1264-1267",
          "snippet": "void unpause_named_trigger(struct event_trigger_data *data)\n{\n\t__pause_named_trigger(data, false);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/security.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/security.h>\n\nvoid unpause_named_trigger(struct event_trigger_data *data)\n{\n\t__pause_named_trigger(data, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracing_map_clear",
          "args": [
            "hist_data->map"
          ],
          "line": 5817
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_map_clear",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/tracing_map.c",
          "lines": "693-705",
          "snippet": "void tracing_map_clear(struct tracing_map *map)\n{\n\tunsigned int i;\n\n\tatomic_set(&map->next_elt, -1);\n\tatomic64_set(&map->hits, 0);\n\tatomic64_set(&map->drops, 0);\n\n\ttracing_map_array_clear(map->map);\n\n\tfor (i = 0; i < map->max_elts; i++)\n\t\ttracing_map_elt_clear(*(TRACING_MAP_ELT(map->elts, i)));\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/kmemleak.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/jhash.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/kmemleak.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <linux/vmalloc.h>\n\nvoid tracing_map_clear(struct tracing_map *map)\n{\n\tunsigned int i;\n\n\tatomic_set(&map->next_elt, -1);\n\tatomic64_set(&map->hits, 0);\n\tatomic64_set(&map->drops, 0);\n\n\ttracing_map_array_clear(map->map);\n\n\tfor (i = 0; i < map->max_elts; i++)\n\t\ttracing_map_elt_clear(*(TRACING_MAP_ELT(map->elts, i)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracepoint_synchronize_unregister",
          "args": [],
          "line": 5815
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);\n\nstatic void hist_clear(struct event_trigger_data *data)\n{\n\tstruct hist_trigger_data *hist_data = data->private_data;\n\n\tif (data->name)\n\t\tpause_named_trigger(data);\n\n\ttracepoint_synchronize_unregister();\n\n\ttracing_map_clear(hist_data->map);\n\n\tif (data->name)\n\t\tunpause_named_trigger(data);\n}"
  },
  {
    "function_name": "event_hist_get_trigger_ops",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
    "lines": "5802-5806",
    "snippet": "static struct event_trigger_ops *event_hist_get_trigger_ops(char *cmd,\n\t\t\t\t\t\t\t    char *param)\n{\n\treturn &event_hist_trigger_ops;\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include \"tracing_map.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int event_hist_trigger_parse(struct event_command *cmd_ops,\n\t\t\t\t    struct trace_event_file *file,\n\t\t\t\t    char *glob, char *cmd, char *param);",
      "static struct event_trigger_ops event_hist_trigger_ops = {\n\t.trigger\t\t= event_hist_trigger,\n\t.print\t\t\t= event_hist_trigger_print,\n\t.init\t\t\t= event_hist_trigger_init,\n\t.free\t\t\t= event_hist_trigger_free,\n};"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int event_hist_trigger_parse(struct event_command *cmd_ops,\n\t\t\t\t    struct trace_event_file *file,\n\t\t\t\t    char *glob, char *cmd, char *param);\nstatic struct event_trigger_ops event_hist_trigger_ops = {\n\t.trigger\t\t= event_hist_trigger,\n\t.print\t\t\t= event_hist_trigger_print,\n\t.init\t\t\t= event_hist_trigger_init,\n\t.free\t\t\t= event_hist_trigger_free,\n};\n\nstatic struct event_trigger_ops *event_hist_get_trigger_ops(char *cmd,\n\t\t\t\t\t\t\t    char *param)\n{\n\treturn &event_hist_trigger_ops;\n}"
  },
  {
    "function_name": "event_hist_trigger_named_free",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
    "lines": "5780-5793",
    "snippet": "static void event_hist_trigger_named_free(struct event_trigger_ops *ops,\n\t\t\t\t\t  struct event_trigger_data *data)\n{\n\tif (WARN_ON_ONCE(data->ref <= 0))\n\t\treturn;\n\n\tevent_hist_trigger_free(ops, data->named_data);\n\n\tdata->ref--;\n\tif (!data->ref) {\n\t\tdel_named_trigger(data);\n\t\ttrigger_data_free(data);\n\t}\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include \"tracing_map.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trigger_data_free",
          "args": [
            "data"
          ],
          "line": 5791
        },
        "resolved": true,
        "details": {
          "function_name": "trigger_data_free",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_trigger.c",
          "lines": "20-29",
          "snippet": "void trigger_data_free(struct event_trigger_data *data)\n{\n\tif (data->cmd_ops->set_filter)\n\t\tdata->cmd_ops->set_filter(NULL, data, NULL);\n\n\t/* make sure current triggers exit before free */\n\ttracepoint_synchronize_unregister();\n\n\tkfree(data);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/security.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/security.h>\n\nvoid trigger_data_free(struct event_trigger_data *data)\n{\n\tif (data->cmd_ops->set_filter)\n\t\tdata->cmd_ops->set_filter(NULL, data, NULL);\n\n\t/* make sure current triggers exit before free */\n\ttracepoint_synchronize_unregister();\n\n\tkfree(data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "del_named_trigger",
          "args": [
            "data"
          ],
          "line": 5790
        },
        "resolved": true,
        "details": {
          "function_name": "del_named_trigger",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_trigger.c",
          "lines": "1217-1223",
          "snippet": "void del_named_trigger(struct event_trigger_data *data)\n{\n\tkfree(data->name);\n\tdata->name = NULL;\n\n\tlist_del(&data->named_list);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/security.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/security.h>\n\nvoid del_named_trigger(struct event_trigger_data *data)\n{\n\tkfree(data->name);\n\tdata->name = NULL;\n\n\tlist_del(&data->named_list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "event_hist_trigger_free",
          "args": [
            "ops",
            "data->named_data"
          ],
          "line": 5786
        },
        "resolved": true,
        "details": {
          "function_name": "event_hist_trigger_free",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "5738-5759",
          "snippet": "static void event_hist_trigger_free(struct event_trigger_ops *ops,\n\t\t\t\t    struct event_trigger_data *data)\n{\n\tstruct hist_trigger_data *hist_data = data->private_data;\n\n\tif (WARN_ON_ONCE(data->ref <= 0))\n\t\treturn;\n\n\tdata->ref--;\n\tif (!data->ref) {\n\t\tif (data->name)\n\t\t\tdel_named_trigger(data);\n\n\t\ttrigger_data_free(data);\n\n\t\tremove_hist_vars(hist_data);\n\n\t\tunregister_field_var_hists(hist_data);\n\n\t\tdestroy_hist_data(hist_data);\n\t}\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);\n\nstatic void event_hist_trigger_free(struct event_trigger_ops *ops,\n\t\t\t\t    struct event_trigger_data *data)\n{\n\tstruct hist_trigger_data *hist_data = data->private_data;\n\n\tif (WARN_ON_ONCE(data->ref <= 0))\n\t\treturn;\n\n\tdata->ref--;\n\tif (!data->ref) {\n\t\tif (data->name)\n\t\t\tdel_named_trigger(data);\n\n\t\ttrigger_data_free(data);\n\n\t\tremove_hist_vars(hist_data);\n\n\t\tunregister_field_var_hists(hist_data);\n\n\t\tdestroy_hist_data(hist_data);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "data->ref <= 0"
          ],
          "line": 5783
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);\n\nstatic void event_hist_trigger_named_free(struct event_trigger_ops *ops,\n\t\t\t\t\t  struct event_trigger_data *data)\n{\n\tif (WARN_ON_ONCE(data->ref <= 0))\n\t\treturn;\n\n\tevent_hist_trigger_free(ops, data->named_data);\n\n\tdata->ref--;\n\tif (!data->ref) {\n\t\tdel_named_trigger(data);\n\t\ttrigger_data_free(data);\n\t}\n}"
  },
  {
    "function_name": "event_hist_trigger_named_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
    "lines": "5768-5778",
    "snippet": "static int event_hist_trigger_named_init(struct event_trigger_ops *ops,\n\t\t\t\t\t struct event_trigger_data *data)\n{\n\tdata->ref++;\n\n\tsave_named_trigger(data->named_data->name, data);\n\n\tevent_hist_trigger_init(ops, data->named_data);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include \"tracing_map.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "event_hist_trigger_init",
          "args": [
            "ops",
            "data->named_data"
          ],
          "line": 5775
        },
        "resolved": true,
        "details": {
          "function_name": "event_hist_trigger_init",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "5709-5720",
          "snippet": "static int event_hist_trigger_init(struct event_trigger_ops *ops,\n\t\t\t\t   struct event_trigger_data *data)\n{\n\tstruct hist_trigger_data *hist_data = data->private_data;\n\n\tif (!data->ref && hist_data->attrs->name)\n\t\tsave_named_trigger(hist_data->attrs->name, data);\n\n\tdata->ref++;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);\n\nstatic int event_hist_trigger_init(struct event_trigger_ops *ops,\n\t\t\t\t   struct event_trigger_data *data)\n{\n\tstruct hist_trigger_data *hist_data = data->private_data;\n\n\tif (!data->ref && hist_data->attrs->name)\n\t\tsave_named_trigger(hist_data->attrs->name, data);\n\n\tdata->ref++;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "save_named_trigger",
          "args": [
            "data->named_data->name",
            "data"
          ],
          "line": 5773
        },
        "resolved": true,
        "details": {
          "function_name": "save_named_trigger",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_trigger.c",
          "lines": "1202-1211",
          "snippet": "int save_named_trigger(const char *name, struct event_trigger_data *data)\n{\n\tdata->name = kstrdup(name, GFP_KERNEL);\n\tif (!data->name)\n\t\treturn -ENOMEM;\n\n\tlist_add(&data->named_list, &named_triggers);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/security.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(named_triggers);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/security.h>\n\nstatic LIST_HEAD(named_triggers);\n\nint save_named_trigger(const char *name, struct event_trigger_data *data)\n{\n\tdata->name = kstrdup(name, GFP_KERNEL);\n\tif (!data->name)\n\t\treturn -ENOMEM;\n\n\tlist_add(&data->named_list, &named_triggers);\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);\n\nstatic int event_hist_trigger_named_init(struct event_trigger_ops *ops,\n\t\t\t\t\t struct event_trigger_data *data)\n{\n\tdata->ref++;\n\n\tsave_named_trigger(data->named_data->name, data);\n\n\tevent_hist_trigger_init(ops, data->named_data);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "event_hist_trigger_free",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
    "lines": "5738-5759",
    "snippet": "static void event_hist_trigger_free(struct event_trigger_ops *ops,\n\t\t\t\t    struct event_trigger_data *data)\n{\n\tstruct hist_trigger_data *hist_data = data->private_data;\n\n\tif (WARN_ON_ONCE(data->ref <= 0))\n\t\treturn;\n\n\tdata->ref--;\n\tif (!data->ref) {\n\t\tif (data->name)\n\t\t\tdel_named_trigger(data);\n\n\t\ttrigger_data_free(data);\n\n\t\tremove_hist_vars(hist_data);\n\n\t\tunregister_field_var_hists(hist_data);\n\n\t\tdestroy_hist_data(hist_data);\n\t}\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include \"tracing_map.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "destroy_hist_data",
          "args": [
            "hist_data"
          ],
          "line": 5757
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_hist_data",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "4799-4813",
          "snippet": "static void destroy_hist_data(struct hist_trigger_data *hist_data)\n{\n\tif (!hist_data)\n\t\treturn;\n\n\tdestroy_hist_trigger_attrs(hist_data->attrs);\n\tdestroy_hist_fields(hist_data);\n\ttracing_map_destroy(hist_data->map);\n\n\tdestroy_actions(hist_data);\n\tdestroy_field_vars(hist_data);\n\tdestroy_field_var_hists(hist_data);\n\n\tkfree(hist_data);\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void destroy_hist_data(struct hist_trigger_data *hist_data)\n{\n\tif (!hist_data)\n\t\treturn;\n\n\tdestroy_hist_trigger_attrs(hist_data->attrs);\n\tdestroy_hist_fields(hist_data);\n\ttracing_map_destroy(hist_data->map);\n\n\tdestroy_actions(hist_data);\n\tdestroy_field_vars(hist_data);\n\tdestroy_field_var_hists(hist_data);\n\n\tkfree(hist_data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unregister_field_var_hists",
          "args": [
            "hist_data"
          ],
          "line": 5755
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_field_var_hists",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "5722-5736",
          "snippet": "static void unregister_field_var_hists(struct hist_trigger_data *hist_data)\n{\n\tstruct trace_event_file *file;\n\tunsigned int i;\n\tchar *cmd;\n\tint ret;\n\n\tfor (i = 0; i < hist_data->n_field_var_hists; i++) {\n\t\tfile = hist_data->field_var_hists[i]->hist_data->event_file;\n\t\tcmd = hist_data->field_var_hists[i]->cmd;\n\t\tret = event_hist_trigger_parse(&trigger_hist_cmd, file,\n\t\t\t\t\t       \"!hist\", \"hist\", cmd);\n\t\tWARN_ON_ONCE(ret < 0);\n\t}\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct event_command trigger_hist_cmd;",
            "static struct event_command trigger_hist_cmd = {\n\t.name\t\t\t= \"hist\",\n\t.trigger_type\t\t= ETT_EVENT_HIST,\n\t.flags\t\t\t= EVENT_CMD_FL_NEEDS_REC,\n\t.parse\t\t\t= event_hist_trigger_parse,\n\t.reg\t\t\t= hist_register_trigger,\n\t.unreg\t\t\t= hist_unregister_trigger,\n\t.unreg_all\t\t= hist_unreg_all,\n\t.get_trigger_ops\t= event_hist_get_trigger_ops,\n\t.set_filter\t\t= set_trigger_filter,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct event_command trigger_hist_cmd;\nstatic struct event_command trigger_hist_cmd = {\n\t.name\t\t\t= \"hist\",\n\t.trigger_type\t\t= ETT_EVENT_HIST,\n\t.flags\t\t\t= EVENT_CMD_FL_NEEDS_REC,\n\t.parse\t\t\t= event_hist_trigger_parse,\n\t.reg\t\t\t= hist_register_trigger,\n\t.unreg\t\t\t= hist_unregister_trigger,\n\t.unreg_all\t\t= hist_unreg_all,\n\t.get_trigger_ops\t= event_hist_get_trigger_ops,\n\t.set_filter\t\t= set_trigger_filter,\n};\n\nstatic void unregister_field_var_hists(struct hist_trigger_data *hist_data)\n{\n\tstruct trace_event_file *file;\n\tunsigned int i;\n\tchar *cmd;\n\tint ret;\n\n\tfor (i = 0; i < hist_data->n_field_var_hists; i++) {\n\t\tfile = hist_data->field_var_hists[i]->hist_data->event_file;\n\t\tcmd = hist_data->field_var_hists[i]->cmd;\n\t\tret = event_hist_trigger_parse(&trigger_hist_cmd, file,\n\t\t\t\t\t       \"!hist\", \"hist\", cmd);\n\t\tWARN_ON_ONCE(ret < 0);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "remove_hist_vars",
          "args": [
            "hist_data"
          ],
          "line": 5753
        },
        "resolved": true,
        "details": {
          "function_name": "remove_hist_vars",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "1042-1059",
          "snippet": "static void remove_hist_vars(struct hist_trigger_data *hist_data)\n{\n\tstruct trace_array *tr = hist_data->event_file->tr;\n\tstruct hist_var_data *var_data;\n\n\tvar_data = find_hist_vars(hist_data);\n\tif (!var_data)\n\t\treturn;\n\n\tif (WARN_ON(check_var_refs(hist_data)))\n\t\treturn;\n\n\tlist_del(&var_data->list);\n\n\tkfree(var_data);\n\n\ttrace_array_put(tr);\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void remove_hist_vars(struct hist_trigger_data *hist_data)\n{\n\tstruct trace_array *tr = hist_data->event_file->tr;\n\tstruct hist_var_data *var_data;\n\n\tvar_data = find_hist_vars(hist_data);\n\tif (!var_data)\n\t\treturn;\n\n\tif (WARN_ON(check_var_refs(hist_data)))\n\t\treturn;\n\n\tlist_del(&var_data->list);\n\n\tkfree(var_data);\n\n\ttrace_array_put(tr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trigger_data_free",
          "args": [
            "data"
          ],
          "line": 5751
        },
        "resolved": true,
        "details": {
          "function_name": "trigger_data_free",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_trigger.c",
          "lines": "20-29",
          "snippet": "void trigger_data_free(struct event_trigger_data *data)\n{\n\tif (data->cmd_ops->set_filter)\n\t\tdata->cmd_ops->set_filter(NULL, data, NULL);\n\n\t/* make sure current triggers exit before free */\n\ttracepoint_synchronize_unregister();\n\n\tkfree(data);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/security.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/security.h>\n\nvoid trigger_data_free(struct event_trigger_data *data)\n{\n\tif (data->cmd_ops->set_filter)\n\t\tdata->cmd_ops->set_filter(NULL, data, NULL);\n\n\t/* make sure current triggers exit before free */\n\ttracepoint_synchronize_unregister();\n\n\tkfree(data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "del_named_trigger",
          "args": [
            "data"
          ],
          "line": 5749
        },
        "resolved": true,
        "details": {
          "function_name": "del_named_trigger",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_trigger.c",
          "lines": "1217-1223",
          "snippet": "void del_named_trigger(struct event_trigger_data *data)\n{\n\tkfree(data->name);\n\tdata->name = NULL;\n\n\tlist_del(&data->named_list);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/security.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/security.h>\n\nvoid del_named_trigger(struct event_trigger_data *data)\n{\n\tkfree(data->name);\n\tdata->name = NULL;\n\n\tlist_del(&data->named_list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "data->ref <= 0"
          ],
          "line": 5743
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);\n\nstatic void event_hist_trigger_free(struct event_trigger_ops *ops,\n\t\t\t\t    struct event_trigger_data *data)\n{\n\tstruct hist_trigger_data *hist_data = data->private_data;\n\n\tif (WARN_ON_ONCE(data->ref <= 0))\n\t\treturn;\n\n\tdata->ref--;\n\tif (!data->ref) {\n\t\tif (data->name)\n\t\t\tdel_named_trigger(data);\n\n\t\ttrigger_data_free(data);\n\n\t\tremove_hist_vars(hist_data);\n\n\t\tunregister_field_var_hists(hist_data);\n\n\t\tdestroy_hist_data(hist_data);\n\t}\n}"
  },
  {
    "function_name": "unregister_field_var_hists",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
    "lines": "5722-5736",
    "snippet": "static void unregister_field_var_hists(struct hist_trigger_data *hist_data)\n{\n\tstruct trace_event_file *file;\n\tunsigned int i;\n\tchar *cmd;\n\tint ret;\n\n\tfor (i = 0; i < hist_data->n_field_var_hists; i++) {\n\t\tfile = hist_data->field_var_hists[i]->hist_data->event_file;\n\t\tcmd = hist_data->field_var_hists[i]->cmd;\n\t\tret = event_hist_trigger_parse(&trigger_hist_cmd, file,\n\t\t\t\t\t       \"!hist\", \"hist\", cmd);\n\t\tWARN_ON_ONCE(ret < 0);\n\t}\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include \"tracing_map.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct event_command trigger_hist_cmd;",
      "static struct event_command trigger_hist_cmd = {\n\t.name\t\t\t= \"hist\",\n\t.trigger_type\t\t= ETT_EVENT_HIST,\n\t.flags\t\t\t= EVENT_CMD_FL_NEEDS_REC,\n\t.parse\t\t\t= event_hist_trigger_parse,\n\t.reg\t\t\t= hist_register_trigger,\n\t.unreg\t\t\t= hist_unregister_trigger,\n\t.unreg_all\t\t= hist_unreg_all,\n\t.get_trigger_ops\t= event_hist_get_trigger_ops,\n\t.set_filter\t\t= set_trigger_filter,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "ret < 0"
          ],
          "line": 5734
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "event_hist_trigger_parse",
          "args": [
            "&trigger_hist_cmd",
            "file",
            "\"!hist\"",
            "\"hist\"",
            "cmd"
          ],
          "line": 5732
        },
        "resolved": true,
        "details": {
          "function_name": "event_hist_trigger_parse",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "6149-6328",
          "snippet": "static int event_hist_trigger_parse(struct event_command *cmd_ops,\n\t\t\t\t    struct trace_event_file *file,\n\t\t\t\t    char *glob, char *cmd, char *param)\n{\n\tunsigned int hist_trigger_bits = TRACING_MAP_BITS_DEFAULT;\n\tstruct event_trigger_data *trigger_data;\n\tstruct hist_trigger_attrs *attrs;\n\tstruct event_trigger_ops *trigger_ops;\n\tstruct hist_trigger_data *hist_data;\n\tstruct synth_event *se;\n\tconst char *se_name;\n\tbool remove = false;\n\tchar *trigger, *p, *start;\n\tint ret = 0;\n\n\tlockdep_assert_held(&event_mutex);\n\n\tif (glob && strlen(glob)) {\n\t\thist_err_clear();\n\t\tlast_cmd_set(file, param);\n\t}\n\n\tif (!param)\n\t\treturn -EINVAL;\n\n\tif (glob[0] == '!')\n\t\tremove = true;\n\n\t/*\n\t * separate the trigger from the filter (k:v [if filter])\n\t * allowing for whitespace in the trigger\n\t */\n\tp = trigger = param;\n\tdo {\n\t\tp = strstr(p, \"if\");\n\t\tif (!p)\n\t\t\tbreak;\n\t\tif (p == param)\n\t\t\treturn -EINVAL;\n\t\tif (*(p - 1) != ' ' && *(p - 1) != '\\t') {\n\t\t\tp++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (p >= param + strlen(param) - (sizeof(\"if\") - 1) - 1)\n\t\t\treturn -EINVAL;\n\t\tif (*(p + sizeof(\"if\") - 1) != ' ' && *(p + sizeof(\"if\") - 1) != '\\t') {\n\t\t\tp++;\n\t\t\tcontinue;\n\t\t}\n\t\tbreak;\n\t} while (p);\n\n\tif (!p)\n\t\tparam = NULL;\n\telse {\n\t\t*(p - 1) = '\\0';\n\t\tparam = strstrip(p);\n\t\ttrigger = strstrip(trigger);\n\t}\n\n\t/*\n\t * To simplify arithmetic expression parsing, replace occurrences of\n\t * '.sym-offset' modifier with '.symXoffset'\n\t */\n\tstart = strstr(trigger, \".sym-offset\");\n\twhile (start) {\n\t\t*(start + 4) = 'X';\n\t\tstart = strstr(start + 11, \".sym-offset\");\n\t}\n\n\tattrs = parse_hist_trigger_attrs(file->tr, trigger);\n\tif (IS_ERR(attrs))\n\t\treturn PTR_ERR(attrs);\n\n\tif (attrs->map_bits)\n\t\thist_trigger_bits = attrs->map_bits;\n\n\thist_data = create_hist_data(hist_trigger_bits, attrs, file, remove);\n\tif (IS_ERR(hist_data)) {\n\t\tdestroy_hist_trigger_attrs(attrs);\n\t\treturn PTR_ERR(hist_data);\n\t}\n\n\ttrigger_ops = cmd_ops->get_trigger_ops(cmd, trigger);\n\n\ttrigger_data = kzalloc(sizeof(*trigger_data), GFP_KERNEL);\n\tif (!trigger_data) {\n\t\tret = -ENOMEM;\n\t\tgoto out_free;\n\t}\n\n\ttrigger_data->count = -1;\n\ttrigger_data->ops = trigger_ops;\n\ttrigger_data->cmd_ops = cmd_ops;\n\n\tINIT_LIST_HEAD(&trigger_data->list);\n\tRCU_INIT_POINTER(trigger_data->filter, NULL);\n\n\ttrigger_data->private_data = hist_data;\n\n\t/* if param is non-empty, it's supposed to be a filter */\n\tif (param && cmd_ops->set_filter) {\n\t\tret = cmd_ops->set_filter(param, trigger_data, file);\n\t\tif (ret < 0)\n\t\t\tgoto out_free;\n\t}\n\n\tif (remove) {\n\t\tif (!have_hist_trigger_match(trigger_data, file))\n\t\t\tgoto out_free;\n\n\t\tif (hist_trigger_check_refs(trigger_data, file)) {\n\t\t\tret = -EBUSY;\n\t\t\tgoto out_free;\n\t\t}\n\n\t\tcmd_ops->unreg(glob+1, trigger_data, file);\n\t\tse_name = trace_event_name(file->event_call);\n\t\tse = find_synth_event(se_name);\n\t\tif (se)\n\t\t\tse->ref--;\n\t\tret = 0;\n\t\tgoto out_free;\n\t}\n\n\tret = cmd_ops->reg(glob, trigger_data, file);\n\t/*\n\t * The above returns on success the # of triggers registered,\n\t * but if it didn't register any it returns zero.  Consider no\n\t * triggers registered a failure too.\n\t */\n\tif (!ret) {\n\t\tif (!(attrs->pause || attrs->cont || attrs->clear))\n\t\t\tret = -ENOENT;\n\t\tgoto out_free;\n\t} else if (ret < 0)\n\t\tgoto out_free;\n\n\tif (get_named_trigger_data(trigger_data))\n\t\tgoto enable;\n\n\tif (has_hist_vars(hist_data))\n\t\tsave_hist_vars(hist_data);\n\n\tret = create_actions(hist_data);\n\tif (ret)\n\t\tgoto out_unreg;\n\n\tret = tracing_map_init(hist_data->map);\n\tif (ret)\n\t\tgoto out_unreg;\nenable:\n\tret = hist_trigger_enable(trigger_data, file);\n\tif (ret)\n\t\tgoto out_unreg;\n\n\tse_name = trace_event_name(file->event_call);\n\tse = find_synth_event(se_name);\n\tif (se)\n\t\tse->ref++;\n\t/* Just return zero, not the number of registered triggers */\n\tret = 0;\n out:\n\tif (ret == 0)\n\t\thist_err_clear();\n\n\treturn ret;\n out_unreg:\n\tcmd_ops->unreg(glob+1, trigger_data, file);\n out_free:\n\tif (cmd_ops->set_filter)\n\t\tcmd_ops->set_filter(NULL, trigger_data, NULL);\n\n\tremove_hist_vars(hist_data);\n\n\tkfree(trigger_data);\n\n\tdestroy_hist_data(hist_data);\n\tgoto out;\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int event_hist_trigger_parse(struct event_command *cmd_ops,\n\t\t\t\t    struct trace_event_file *file,\n\t\t\t\t    char *glob, char *cmd, char *param);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int event_hist_trigger_parse(struct event_command *cmd_ops,\n\t\t\t\t    struct trace_event_file *file,\n\t\t\t\t    char *glob, char *cmd, char *param);\n\nstatic int event_hist_trigger_parse(struct event_command *cmd_ops,\n\t\t\t\t    struct trace_event_file *file,\n\t\t\t\t    char *glob, char *cmd, char *param)\n{\n\tunsigned int hist_trigger_bits = TRACING_MAP_BITS_DEFAULT;\n\tstruct event_trigger_data *trigger_data;\n\tstruct hist_trigger_attrs *attrs;\n\tstruct event_trigger_ops *trigger_ops;\n\tstruct hist_trigger_data *hist_data;\n\tstruct synth_event *se;\n\tconst char *se_name;\n\tbool remove = false;\n\tchar *trigger, *p, *start;\n\tint ret = 0;\n\n\tlockdep_assert_held(&event_mutex);\n\n\tif (glob && strlen(glob)) {\n\t\thist_err_clear();\n\t\tlast_cmd_set(file, param);\n\t}\n\n\tif (!param)\n\t\treturn -EINVAL;\n\n\tif (glob[0] == '!')\n\t\tremove = true;\n\n\t/*\n\t * separate the trigger from the filter (k:v [if filter])\n\t * allowing for whitespace in the trigger\n\t */\n\tp = trigger = param;\n\tdo {\n\t\tp = strstr(p, \"if\");\n\t\tif (!p)\n\t\t\tbreak;\n\t\tif (p == param)\n\t\t\treturn -EINVAL;\n\t\tif (*(p - 1) != ' ' && *(p - 1) != '\\t') {\n\t\t\tp++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (p >= param + strlen(param) - (sizeof(\"if\") - 1) - 1)\n\t\t\treturn -EINVAL;\n\t\tif (*(p + sizeof(\"if\") - 1) != ' ' && *(p + sizeof(\"if\") - 1) != '\\t') {\n\t\t\tp++;\n\t\t\tcontinue;\n\t\t}\n\t\tbreak;\n\t} while (p);\n\n\tif (!p)\n\t\tparam = NULL;\n\telse {\n\t\t*(p - 1) = '\\0';\n\t\tparam = strstrip(p);\n\t\ttrigger = strstrip(trigger);\n\t}\n\n\t/*\n\t * To simplify arithmetic expression parsing, replace occurrences of\n\t * '.sym-offset' modifier with '.symXoffset'\n\t */\n\tstart = strstr(trigger, \".sym-offset\");\n\twhile (start) {\n\t\t*(start + 4) = 'X';\n\t\tstart = strstr(start + 11, \".sym-offset\");\n\t}\n\n\tattrs = parse_hist_trigger_attrs(file->tr, trigger);\n\tif (IS_ERR(attrs))\n\t\treturn PTR_ERR(attrs);\n\n\tif (attrs->map_bits)\n\t\thist_trigger_bits = attrs->map_bits;\n\n\thist_data = create_hist_data(hist_trigger_bits, attrs, file, remove);\n\tif (IS_ERR(hist_data)) {\n\t\tdestroy_hist_trigger_attrs(attrs);\n\t\treturn PTR_ERR(hist_data);\n\t}\n\n\ttrigger_ops = cmd_ops->get_trigger_ops(cmd, trigger);\n\n\ttrigger_data = kzalloc(sizeof(*trigger_data), GFP_KERNEL);\n\tif (!trigger_data) {\n\t\tret = -ENOMEM;\n\t\tgoto out_free;\n\t}\n\n\ttrigger_data->count = -1;\n\ttrigger_data->ops = trigger_ops;\n\ttrigger_data->cmd_ops = cmd_ops;\n\n\tINIT_LIST_HEAD(&trigger_data->list);\n\tRCU_INIT_POINTER(trigger_data->filter, NULL);\n\n\ttrigger_data->private_data = hist_data;\n\n\t/* if param is non-empty, it's supposed to be a filter */\n\tif (param && cmd_ops->set_filter) {\n\t\tret = cmd_ops->set_filter(param, trigger_data, file);\n\t\tif (ret < 0)\n\t\t\tgoto out_free;\n\t}\n\n\tif (remove) {\n\t\tif (!have_hist_trigger_match(trigger_data, file))\n\t\t\tgoto out_free;\n\n\t\tif (hist_trigger_check_refs(trigger_data, file)) {\n\t\t\tret = -EBUSY;\n\t\t\tgoto out_free;\n\t\t}\n\n\t\tcmd_ops->unreg(glob+1, trigger_data, file);\n\t\tse_name = trace_event_name(file->event_call);\n\t\tse = find_synth_event(se_name);\n\t\tif (se)\n\t\t\tse->ref--;\n\t\tret = 0;\n\t\tgoto out_free;\n\t}\n\n\tret = cmd_ops->reg(glob, trigger_data, file);\n\t/*\n\t * The above returns on success the # of triggers registered,\n\t * but if it didn't register any it returns zero.  Consider no\n\t * triggers registered a failure too.\n\t */\n\tif (!ret) {\n\t\tif (!(attrs->pause || attrs->cont || attrs->clear))\n\t\t\tret = -ENOENT;\n\t\tgoto out_free;\n\t} else if (ret < 0)\n\t\tgoto out_free;\n\n\tif (get_named_trigger_data(trigger_data))\n\t\tgoto enable;\n\n\tif (has_hist_vars(hist_data))\n\t\tsave_hist_vars(hist_data);\n\n\tret = create_actions(hist_data);\n\tif (ret)\n\t\tgoto out_unreg;\n\n\tret = tracing_map_init(hist_data->map);\n\tif (ret)\n\t\tgoto out_unreg;\nenable:\n\tret = hist_trigger_enable(trigger_data, file);\n\tif (ret)\n\t\tgoto out_unreg;\n\n\tse_name = trace_event_name(file->event_call);\n\tse = find_synth_event(se_name);\n\tif (se)\n\t\tse->ref++;\n\t/* Just return zero, not the number of registered triggers */\n\tret = 0;\n out:\n\tif (ret == 0)\n\t\thist_err_clear();\n\n\treturn ret;\n out_unreg:\n\tcmd_ops->unreg(glob+1, trigger_data, file);\n out_free:\n\tif (cmd_ops->set_filter)\n\t\tcmd_ops->set_filter(NULL, trigger_data, NULL);\n\n\tremove_hist_vars(hist_data);\n\n\tkfree(trigger_data);\n\n\tdestroy_hist_data(hist_data);\n\tgoto out;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct event_command trigger_hist_cmd;\nstatic struct event_command trigger_hist_cmd = {\n\t.name\t\t\t= \"hist\",\n\t.trigger_type\t\t= ETT_EVENT_HIST,\n\t.flags\t\t\t= EVENT_CMD_FL_NEEDS_REC,\n\t.parse\t\t\t= event_hist_trigger_parse,\n\t.reg\t\t\t= hist_register_trigger,\n\t.unreg\t\t\t= hist_unregister_trigger,\n\t.unreg_all\t\t= hist_unreg_all,\n\t.get_trigger_ops\t= event_hist_get_trigger_ops,\n\t.set_filter\t\t= set_trigger_filter,\n};\n\nstatic void unregister_field_var_hists(struct hist_trigger_data *hist_data)\n{\n\tstruct trace_event_file *file;\n\tunsigned int i;\n\tchar *cmd;\n\tint ret;\n\n\tfor (i = 0; i < hist_data->n_field_var_hists; i++) {\n\t\tfile = hist_data->field_var_hists[i]->hist_data->event_file;\n\t\tcmd = hist_data->field_var_hists[i]->cmd;\n\t\tret = event_hist_trigger_parse(&trigger_hist_cmd, file,\n\t\t\t\t\t       \"!hist\", \"hist\", cmd);\n\t\tWARN_ON_ONCE(ret < 0);\n\t}\n}"
  },
  {
    "function_name": "event_hist_trigger_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
    "lines": "5709-5720",
    "snippet": "static int event_hist_trigger_init(struct event_trigger_ops *ops,\n\t\t\t\t   struct event_trigger_data *data)\n{\n\tstruct hist_trigger_data *hist_data = data->private_data;\n\n\tif (!data->ref && hist_data->attrs->name)\n\t\tsave_named_trigger(hist_data->attrs->name, data);\n\n\tdata->ref++;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include \"tracing_map.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "save_named_trigger",
          "args": [
            "hist_data->attrs->name",
            "data"
          ],
          "line": 5715
        },
        "resolved": true,
        "details": {
          "function_name": "save_named_trigger",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_trigger.c",
          "lines": "1202-1211",
          "snippet": "int save_named_trigger(const char *name, struct event_trigger_data *data)\n{\n\tdata->name = kstrdup(name, GFP_KERNEL);\n\tif (!data->name)\n\t\treturn -ENOMEM;\n\n\tlist_add(&data->named_list, &named_triggers);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/security.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(named_triggers);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/security.h>\n\nstatic LIST_HEAD(named_triggers);\n\nint save_named_trigger(const char *name, struct event_trigger_data *data)\n{\n\tdata->name = kstrdup(name, GFP_KERNEL);\n\tif (!data->name)\n\t\treturn -ENOMEM;\n\n\tlist_add(&data->named_list, &named_triggers);\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);\n\nstatic int event_hist_trigger_init(struct event_trigger_ops *ops,\n\t\t\t\t   struct event_trigger_data *data)\n{\n\tstruct hist_trigger_data *hist_data = data->private_data;\n\n\tif (!data->ref && hist_data->attrs->name)\n\t\tsave_named_trigger(hist_data->attrs->name, data);\n\n\tdata->ref++;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "event_hist_trigger_print",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
    "lines": "5600-5707",
    "snippet": "static int event_hist_trigger_print(struct seq_file *m,\n\t\t\t\t    struct event_trigger_ops *ops,\n\t\t\t\t    struct event_trigger_data *data)\n{\n\tstruct hist_trigger_data *hist_data = data->private_data;\n\tstruct hist_field *field;\n\tbool have_var = false;\n\tunsigned int i;\n\n\tseq_puts(m, \"hist:\");\n\n\tif (data->name)\n\t\tseq_printf(m, \"%s:\", data->name);\n\n\tseq_puts(m, \"keys=\");\n\n\tfor_each_hist_key_field(i, hist_data) {\n\t\tfield = hist_data->fields[i];\n\n\t\tif (i > hist_data->n_vals)\n\t\t\tseq_puts(m, \",\");\n\n\t\tif (field->flags & HIST_FIELD_FL_STACKTRACE)\n\t\t\tseq_puts(m, \"stacktrace\");\n\t\telse\n\t\t\thist_field_print(m, field);\n\t}\n\n\tseq_puts(m, \":vals=\");\n\n\tfor_each_hist_val_field(i, hist_data) {\n\t\tfield = hist_data->fields[i];\n\t\tif (field->flags & HIST_FIELD_FL_VAR) {\n\t\t\thave_var = true;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (i == HITCOUNT_IDX)\n\t\t\tseq_puts(m, \"hitcount\");\n\t\telse {\n\t\t\tseq_puts(m, \",\");\n\t\t\thist_field_print(m, field);\n\t\t}\n\t}\n\n\tif (have_var) {\n\t\tunsigned int n = 0;\n\n\t\tseq_puts(m, \":\");\n\n\t\tfor_each_hist_val_field(i, hist_data) {\n\t\t\tfield = hist_data->fields[i];\n\n\t\t\tif (field->flags & HIST_FIELD_FL_VAR) {\n\t\t\t\tif (n++)\n\t\t\t\t\tseq_puts(m, \",\");\n\t\t\t\thist_field_print(m, field);\n\t\t\t}\n\t\t}\n\t}\n\n\tseq_puts(m, \":sort=\");\n\n\tfor (i = 0; i < hist_data->n_sort_keys; i++) {\n\t\tstruct tracing_map_sort_key *sort_key;\n\t\tunsigned int idx, first_key_idx;\n\n\t\t/* skip VAR vals */\n\t\tfirst_key_idx = hist_data->n_vals - hist_data->n_vars;\n\n\t\tsort_key = &hist_data->sort_keys[i];\n\t\tidx = sort_key->field_idx;\n\n\t\tif (WARN_ON(idx >= HIST_FIELDS_MAX))\n\t\t\treturn -EINVAL;\n\n\t\tif (i > 0)\n\t\t\tseq_puts(m, \",\");\n\n\t\tif (idx == HITCOUNT_IDX)\n\t\t\tseq_puts(m, \"hitcount\");\n\t\telse {\n\t\t\tif (idx >= first_key_idx)\n\t\t\t\tidx += hist_data->n_vars;\n\t\t\thist_field_print(m, hist_data->fields[idx]);\n\t\t}\n\n\t\tif (sort_key->descending)\n\t\t\tseq_puts(m, \".descending\");\n\t}\n\tseq_printf(m, \":size=%u\", (1 << hist_data->map->map_bits));\n\tif (hist_data->enable_timestamps)\n\t\tseq_printf(m, \":clock=%s\", hist_data->attrs->clock);\n\n\tprint_actions_spec(m, hist_data);\n\n\tif (data->filter_str)\n\t\tseq_printf(m, \" if %s\", data->filter_str);\n\n\tif (data->paused)\n\t\tseq_puts(m, \" [paused]\");\n\telse\n\t\tseq_puts(m, \" [active]\");\n\n\tseq_putc(m, '\\n');\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include \"tracing_map.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define HITCOUNT_IDX\t\t0",
      "#define HIST_FIELDS_MAX\t\t(TRACING_MAP_FIELDS_MAX + TRACING_MAP_VARS_MAX)"
    ],
    "globals_used": [
      "static int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_putc",
          "args": [
            "m",
            "'\\n'"
          ],
          "line": 5704
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_putc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "233-246",
          "snippet": "void trace_seq_putc(struct trace_seq *s, unsigned char c)\n{\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (TRACE_SEQ_BUF_LEFT(s) < 1) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putc(&s->seq, c);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_putc(struct trace_seq *s, unsigned char c)\n{\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (TRACE_SEQ_BUF_LEFT(s) < 1) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putc(&s->seq, c);\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "m",
            "\" [active]\""
          ],
          "line": 5702
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_puts",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "205-220",
          "snippet": "void trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\" if %s\"",
            "data->filter_str"
          ],
          "line": 5697
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "81-100",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_actions_spec",
          "args": [
            "m",
            "hist_data"
          ],
          "line": 5694
        },
        "resolved": true,
        "details": {
          "function_name": "print_actions_spec",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "4773-4787",
          "snippet": "static void print_actions_spec(struct seq_file *m,\n\t\t\t       struct hist_trigger_data *hist_data)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < hist_data->n_actions; i++) {\n\t\tstruct action_data *data = hist_data->actions[i];\n\n\t\tif (data->handler == HANDLER_ONMATCH)\n\t\t\tprint_onmatch_spec(m, hist_data, data);\n\t\telse if (data->handler == HANDLER_ONMAX ||\n\t\t\t data->handler == HANDLER_ONCHANGE)\n\t\t\tprint_track_data_spec(m, hist_data, data);\n\t}\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);\n\nstatic void print_actions_spec(struct seq_file *m,\n\t\t\t       struct hist_trigger_data *hist_data)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < hist_data->n_actions; i++) {\n\t\tstruct action_data *data = hist_data->actions[i];\n\n\t\tif (data->handler == HANDLER_ONMATCH)\n\t\t\tprint_onmatch_spec(m, hist_data, data);\n\t\telse if (data->handler == HANDLER_ONMAX ||\n\t\t\t data->handler == HANDLER_ONCHANGE)\n\t\t\tprint_track_data_spec(m, hist_data, data);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "hist_field_print",
          "args": [
            "m",
            "hist_data->fields[idx]"
          ],
          "line": 5684
        },
        "resolved": true,
        "details": {
          "function_name": "hist_field_print",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "5568-5598",
          "snippet": "static void hist_field_print(struct seq_file *m, struct hist_field *hist_field)\n{\n\tconst char *field_name = hist_field_name(hist_field, 0);\n\n\tif (hist_field->var.name)\n\t\tseq_printf(m, \"%s=\", hist_field->var.name);\n\n\tif (hist_field->flags & HIST_FIELD_FL_CPU)\n\t\tseq_puts(m, \"common_cpu\");\n\telse if (hist_field->flags & HIST_FIELD_FL_CONST)\n\t\tseq_printf(m, \"%llu\", hist_field->constant);\n\telse if (field_name) {\n\t\tif (hist_field->flags & HIST_FIELD_FL_VAR_REF ||\n\t\t    hist_field->flags & HIST_FIELD_FL_ALIAS)\n\t\t\tseq_putc(m, '$');\n\t\tseq_printf(m, \"%s\", field_name);\n\t} else if (hist_field->flags & HIST_FIELD_FL_TIMESTAMP)\n\t\tseq_puts(m, \"common_timestamp\");\n\n\tif (hist_field->flags) {\n\t\tif (!(hist_field->flags & HIST_FIELD_FL_VAR_REF) &&\n\t\t    !(hist_field->flags & HIST_FIELD_FL_EXPR)) {\n\t\t\tconst char *flags = get_hist_field_flags(hist_field);\n\n\t\t\tif (flags)\n\t\t\t\tseq_printf(m, \".%s\", flags);\n\t\t}\n\t}\n\tif (hist_field->buckets)\n\t\tseq_printf(m, \"=%ld\", hist_field->buckets);\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void hist_field_print(struct seq_file *m, struct hist_field *hist_field)\n{\n\tconst char *field_name = hist_field_name(hist_field, 0);\n\n\tif (hist_field->var.name)\n\t\tseq_printf(m, \"%s=\", hist_field->var.name);\n\n\tif (hist_field->flags & HIST_FIELD_FL_CPU)\n\t\tseq_puts(m, \"common_cpu\");\n\telse if (hist_field->flags & HIST_FIELD_FL_CONST)\n\t\tseq_printf(m, \"%llu\", hist_field->constant);\n\telse if (field_name) {\n\t\tif (hist_field->flags & HIST_FIELD_FL_VAR_REF ||\n\t\t    hist_field->flags & HIST_FIELD_FL_ALIAS)\n\t\t\tseq_putc(m, '$');\n\t\tseq_printf(m, \"%s\", field_name);\n\t} else if (hist_field->flags & HIST_FIELD_FL_TIMESTAMP)\n\t\tseq_puts(m, \"common_timestamp\");\n\n\tif (hist_field->flags) {\n\t\tif (!(hist_field->flags & HIST_FIELD_FL_VAR_REF) &&\n\t\t    !(hist_field->flags & HIST_FIELD_FL_EXPR)) {\n\t\t\tconst char *flags = get_hist_field_flags(hist_field);\n\n\t\t\tif (flags)\n\t\t\t\tseq_printf(m, \".%s\", flags);\n\t\t}\n\t}\n\tif (hist_field->buckets)\n\t\tseq_printf(m, \"=%ld\", hist_field->buckets);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "idx >= HIST_FIELDS_MAX"
          ],
          "line": 5673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_hist_val_field",
          "args": [
            "i",
            "hist_data"
          ],
          "line": 5650
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_hist_val_field",
          "args": [
            "i",
            "hist_data"
          ],
          "line": 5630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_hist_key_field",
          "args": [
            "i",
            "hist_data"
          ],
          "line": 5616
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\n#define HITCOUNT_IDX\t\t0\n#define HIST_FIELDS_MAX\t\t(TRACING_MAP_FIELDS_MAX + TRACING_MAP_VARS_MAX)\n\nstatic int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);\n\nstatic int event_hist_trigger_print(struct seq_file *m,\n\t\t\t\t    struct event_trigger_ops *ops,\n\t\t\t\t    struct event_trigger_data *data)\n{\n\tstruct hist_trigger_data *hist_data = data->private_data;\n\tstruct hist_field *field;\n\tbool have_var = false;\n\tunsigned int i;\n\n\tseq_puts(m, \"hist:\");\n\n\tif (data->name)\n\t\tseq_printf(m, \"%s:\", data->name);\n\n\tseq_puts(m, \"keys=\");\n\n\tfor_each_hist_key_field(i, hist_data) {\n\t\tfield = hist_data->fields[i];\n\n\t\tif (i > hist_data->n_vals)\n\t\t\tseq_puts(m, \",\");\n\n\t\tif (field->flags & HIST_FIELD_FL_STACKTRACE)\n\t\t\tseq_puts(m, \"stacktrace\");\n\t\telse\n\t\t\thist_field_print(m, field);\n\t}\n\n\tseq_puts(m, \":vals=\");\n\n\tfor_each_hist_val_field(i, hist_data) {\n\t\tfield = hist_data->fields[i];\n\t\tif (field->flags & HIST_FIELD_FL_VAR) {\n\t\t\thave_var = true;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (i == HITCOUNT_IDX)\n\t\t\tseq_puts(m, \"hitcount\");\n\t\telse {\n\t\t\tseq_puts(m, \",\");\n\t\t\thist_field_print(m, field);\n\t\t}\n\t}\n\n\tif (have_var) {\n\t\tunsigned int n = 0;\n\n\t\tseq_puts(m, \":\");\n\n\t\tfor_each_hist_val_field(i, hist_data) {\n\t\t\tfield = hist_data->fields[i];\n\n\t\t\tif (field->flags & HIST_FIELD_FL_VAR) {\n\t\t\t\tif (n++)\n\t\t\t\t\tseq_puts(m, \",\");\n\t\t\t\thist_field_print(m, field);\n\t\t\t}\n\t\t}\n\t}\n\n\tseq_puts(m, \":sort=\");\n\n\tfor (i = 0; i < hist_data->n_sort_keys; i++) {\n\t\tstruct tracing_map_sort_key *sort_key;\n\t\tunsigned int idx, first_key_idx;\n\n\t\t/* skip VAR vals */\n\t\tfirst_key_idx = hist_data->n_vals - hist_data->n_vars;\n\n\t\tsort_key = &hist_data->sort_keys[i];\n\t\tidx = sort_key->field_idx;\n\n\t\tif (WARN_ON(idx >= HIST_FIELDS_MAX))\n\t\t\treturn -EINVAL;\n\n\t\tif (i > 0)\n\t\t\tseq_puts(m, \",\");\n\n\t\tif (idx == HITCOUNT_IDX)\n\t\t\tseq_puts(m, \"hitcount\");\n\t\telse {\n\t\t\tif (idx >= first_key_idx)\n\t\t\t\tidx += hist_data->n_vars;\n\t\t\thist_field_print(m, hist_data->fields[idx]);\n\t\t}\n\n\t\tif (sort_key->descending)\n\t\t\tseq_puts(m, \".descending\");\n\t}\n\tseq_printf(m, \":size=%u\", (1 << hist_data->map->map_bits));\n\tif (hist_data->enable_timestamps)\n\t\tseq_printf(m, \":clock=%s\", hist_data->attrs->clock);\n\n\tprint_actions_spec(m, hist_data);\n\n\tif (data->filter_str)\n\t\tseq_printf(m, \" if %s\", data->filter_str);\n\n\tif (data->paused)\n\t\tseq_puts(m, \" [paused]\");\n\telse\n\t\tseq_puts(m, \" [active]\");\n\n\tseq_putc(m, '\\n');\n\n\treturn 0;\n}"
  },
  {
    "function_name": "hist_field_print",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
    "lines": "5568-5598",
    "snippet": "static void hist_field_print(struct seq_file *m, struct hist_field *hist_field)\n{\n\tconst char *field_name = hist_field_name(hist_field, 0);\n\n\tif (hist_field->var.name)\n\t\tseq_printf(m, \"%s=\", hist_field->var.name);\n\n\tif (hist_field->flags & HIST_FIELD_FL_CPU)\n\t\tseq_puts(m, \"common_cpu\");\n\telse if (hist_field->flags & HIST_FIELD_FL_CONST)\n\t\tseq_printf(m, \"%llu\", hist_field->constant);\n\telse if (field_name) {\n\t\tif (hist_field->flags & HIST_FIELD_FL_VAR_REF ||\n\t\t    hist_field->flags & HIST_FIELD_FL_ALIAS)\n\t\t\tseq_putc(m, '$');\n\t\tseq_printf(m, \"%s\", field_name);\n\t} else if (hist_field->flags & HIST_FIELD_FL_TIMESTAMP)\n\t\tseq_puts(m, \"common_timestamp\");\n\n\tif (hist_field->flags) {\n\t\tif (!(hist_field->flags & HIST_FIELD_FL_VAR_REF) &&\n\t\t    !(hist_field->flags & HIST_FIELD_FL_EXPR)) {\n\t\t\tconst char *flags = get_hist_field_flags(hist_field);\n\n\t\t\tif (flags)\n\t\t\t\tseq_printf(m, \".%s\", flags);\n\t\t}\n\t}\n\tif (hist_field->buckets)\n\t\tseq_printf(m, \"=%ld\", hist_field->buckets);\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include \"tracing_map.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"=%ld\"",
            "hist_field->buckets"
          ],
          "line": 5597
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "81-100",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_hist_field_flags",
          "args": [
            "hist_field"
          ],
          "line": 5590
        },
        "resolved": true,
        "details": {
          "function_name": "get_hist_field_flags",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "1646-1668",
          "snippet": "static const char *get_hist_field_flags(struct hist_field *hist_field)\n{\n\tconst char *flags_str = NULL;\n\n\tif (hist_field->flags & HIST_FIELD_FL_HEX)\n\t\tflags_str = \"hex\";\n\telse if (hist_field->flags & HIST_FIELD_FL_SYM)\n\t\tflags_str = \"sym\";\n\telse if (hist_field->flags & HIST_FIELD_FL_SYM_OFFSET)\n\t\tflags_str = \"sym-offset\";\n\telse if (hist_field->flags & HIST_FIELD_FL_EXECNAME)\n\t\tflags_str = \"execname\";\n\telse if (hist_field->flags & HIST_FIELD_FL_SYSCALL)\n\t\tflags_str = \"syscall\";\n\telse if (hist_field->flags & HIST_FIELD_FL_LOG2)\n\t\tflags_str = \"log2\";\n\telse if (hist_field->flags & HIST_FIELD_FL_BUCKET)\n\t\tflags_str = \"buckets\";\n\telse if (hist_field->flags & HIST_FIELD_FL_TIMESTAMP_USECS)\n\t\tflags_str = \"usecs\";\n\n\treturn flags_str;\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic const char *get_hist_field_flags(struct hist_field *hist_field)\n{\n\tconst char *flags_str = NULL;\n\n\tif (hist_field->flags & HIST_FIELD_FL_HEX)\n\t\tflags_str = \"hex\";\n\telse if (hist_field->flags & HIST_FIELD_FL_SYM)\n\t\tflags_str = \"sym\";\n\telse if (hist_field->flags & HIST_FIELD_FL_SYM_OFFSET)\n\t\tflags_str = \"sym-offset\";\n\telse if (hist_field->flags & HIST_FIELD_FL_EXECNAME)\n\t\tflags_str = \"execname\";\n\telse if (hist_field->flags & HIST_FIELD_FL_SYSCALL)\n\t\tflags_str = \"syscall\";\n\telse if (hist_field->flags & HIST_FIELD_FL_LOG2)\n\t\tflags_str = \"log2\";\n\telse if (hist_field->flags & HIST_FIELD_FL_BUCKET)\n\t\tflags_str = \"buckets\";\n\telse if (hist_field->flags & HIST_FIELD_FL_TIMESTAMP_USECS)\n\t\tflags_str = \"usecs\";\n\n\treturn flags_str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "m",
            "\"common_timestamp\""
          ],
          "line": 5585
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_puts",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "205-220",
          "snippet": "void trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_putc",
          "args": [
            "m",
            "'$'"
          ],
          "line": 5582
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_putc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "233-246",
          "snippet": "void trace_seq_putc(struct trace_seq *s, unsigned char c)\n{\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (TRACE_SEQ_BUF_LEFT(s) < 1) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putc(&s->seq, c);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_putc(struct trace_seq *s, unsigned char c)\n{\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (TRACE_SEQ_BUF_LEFT(s) < 1) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putc(&s->seq, c);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hist_field_name",
          "args": [
            "hist_field",
            "0"
          ],
          "line": 5570
        },
        "resolved": true,
        "details": {
          "function_name": "hist_field_name",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "1280-1316",
          "snippet": "static const char *hist_field_name(struct hist_field *field,\n\t\t\t\t   unsigned int level)\n{\n\tconst char *field_name = \"\";\n\n\tif (level > 1)\n\t\treturn field_name;\n\n\tif (field->field)\n\t\tfield_name = field->field->name;\n\telse if (field->flags & HIST_FIELD_FL_LOG2 ||\n\t\t field->flags & HIST_FIELD_FL_ALIAS ||\n\t\t field->flags & HIST_FIELD_FL_BUCKET)\n\t\tfield_name = hist_field_name(field->operands[0], ++level);\n\telse if (field->flags & HIST_FIELD_FL_CPU)\n\t\tfield_name = \"common_cpu\";\n\telse if (field->flags & HIST_FIELD_FL_EXPR ||\n\t\t field->flags & HIST_FIELD_FL_VAR_REF) {\n\t\tif (field->system) {\n\t\t\tstatic char full_name[MAX_FILTER_STR_VAL];\n\n\t\t\tstrcat(full_name, field->system);\n\t\t\tstrcat(full_name, \".\");\n\t\t\tstrcat(full_name, field->event_name);\n\t\t\tstrcat(full_name, \".\");\n\t\t\tstrcat(full_name, field->name);\n\t\t\tfield_name = full_name;\n\t\t} else\n\t\t\tfield_name = field->name;\n\t} else if (field->flags & HIST_FIELD_FL_TIMESTAMP)\n\t\tfield_name = \"common_timestamp\";\n\n\tif (field_name == NULL)\n\t\tfield_name = \"\";\n\n\treturn field_name;\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic const char *hist_field_name(struct hist_field *field,\n\t\t\t\t   unsigned int level)\n{\n\tconst char *field_name = \"\";\n\n\tif (level > 1)\n\t\treturn field_name;\n\n\tif (field->field)\n\t\tfield_name = field->field->name;\n\telse if (field->flags & HIST_FIELD_FL_LOG2 ||\n\t\t field->flags & HIST_FIELD_FL_ALIAS ||\n\t\t field->flags & HIST_FIELD_FL_BUCKET)\n\t\tfield_name = hist_field_name(field->operands[0], ++level);\n\telse if (field->flags & HIST_FIELD_FL_CPU)\n\t\tfield_name = \"common_cpu\";\n\telse if (field->flags & HIST_FIELD_FL_EXPR ||\n\t\t field->flags & HIST_FIELD_FL_VAR_REF) {\n\t\tif (field->system) {\n\t\t\tstatic char full_name[MAX_FILTER_STR_VAL];\n\n\t\t\tstrcat(full_name, field->system);\n\t\t\tstrcat(full_name, \".\");\n\t\t\tstrcat(full_name, field->event_name);\n\t\t\tstrcat(full_name, \".\");\n\t\t\tstrcat(full_name, field->name);\n\t\t\tfield_name = full_name;\n\t\t} else\n\t\t\tfield_name = field->name;\n\t} else if (field->flags & HIST_FIELD_FL_TIMESTAMP)\n\t\tfield_name = \"common_timestamp\";\n\n\tif (field_name == NULL)\n\t\tfield_name = \"\";\n\n\treturn field_name;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void hist_field_print(struct seq_file *m, struct hist_field *hist_field)\n{\n\tconst char *field_name = hist_field_name(hist_field, 0);\n\n\tif (hist_field->var.name)\n\t\tseq_printf(m, \"%s=\", hist_field->var.name);\n\n\tif (hist_field->flags & HIST_FIELD_FL_CPU)\n\t\tseq_puts(m, \"common_cpu\");\n\telse if (hist_field->flags & HIST_FIELD_FL_CONST)\n\t\tseq_printf(m, \"%llu\", hist_field->constant);\n\telse if (field_name) {\n\t\tif (hist_field->flags & HIST_FIELD_FL_VAR_REF ||\n\t\t    hist_field->flags & HIST_FIELD_FL_ALIAS)\n\t\t\tseq_putc(m, '$');\n\t\tseq_printf(m, \"%s\", field_name);\n\t} else if (hist_field->flags & HIST_FIELD_FL_TIMESTAMP)\n\t\tseq_puts(m, \"common_timestamp\");\n\n\tif (hist_field->flags) {\n\t\tif (!(hist_field->flags & HIST_FIELD_FL_VAR_REF) &&\n\t\t    !(hist_field->flags & HIST_FIELD_FL_EXPR)) {\n\t\t\tconst char *flags = get_hist_field_flags(hist_field);\n\n\t\t\tif (flags)\n\t\t\t\tseq_printf(m, \".%s\", flags);\n\t\t}\n\t}\n\tif (hist_field->buckets)\n\t\tseq_printf(m, \"=%ld\", hist_field->buckets);\n}"
  },
  {
    "function_name": "event_hist_debug_open",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
    "lines": "5549-5558",
    "snippet": "static int event_hist_debug_open(struct inode *inode, struct file *file)\n{\n\tint ret;\n\n\tret = security_locked_down(LOCKDOWN_TRACEFS);\n\tif (ret)\n\t\treturn ret;\n\n\treturn single_open(file, hist_debug_show, file);\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include \"tracing_map.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "single_open",
          "args": [
            "file",
            "hist_debug_show",
            "file"
          ],
          "line": 5557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "security_locked_down",
          "args": [
            "LOCKDOWN_TRACEFS"
          ],
          "line": 5553
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int event_hist_debug_open(struct inode *inode, struct file *file)\n{\n\tint ret;\n\n\tret = security_locked_down(LOCKDOWN_TRACEFS);\n\tif (ret)\n\t\treturn ret;\n\n\treturn single_open(file, hist_debug_show, file);\n}"
  },
  {
    "function_name": "hist_debug_show",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
    "lines": "5524-5547",
    "snippet": "static int hist_debug_show(struct seq_file *m, void *v)\n{\n\tstruct event_trigger_data *data;\n\tstruct trace_event_file *event_file;\n\tint n = 0, ret = 0;\n\n\tmutex_lock(&event_mutex);\n\n\tevent_file = event_file_data(m->private);\n\tif (unlikely(!event_file)) {\n\t\tret = -ENODEV;\n\t\tgoto out_unlock;\n\t}\n\n\tlist_for_each_entry(data, &event_file->triggers, list) {\n\t\tif (data->cmd_ops->trigger_type == ETT_EVENT_HIST)\n\t\t\thist_trigger_debug_show(m, data, n++);\n\t}\n\n out_unlock:\n\tmutex_unlock(&event_mutex);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include \"tracing_map.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&event_mutex"
          ],
          "line": 5544
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hist_trigger_debug_show",
          "args": [
            "m",
            "data",
            "n++"
          ],
          "line": 5540
        },
        "resolved": true,
        "details": {
          "function_name": "hist_trigger_debug_show",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "5454-5522",
          "snippet": "static void hist_trigger_debug_show(struct seq_file *m,\n\t\t\t\t    struct event_trigger_data *data, int n)\n{\n\tstruct hist_trigger_data *hist_data;\n\tint i, ret;\n\n\tif (n > 0)\n\t\tseq_puts(m, \"\\n\\n\");\n\n\tseq_puts(m, \"# event histogram\\n#\\n# trigger info: \");\n\tdata->ops->print(m, data->ops, data);\n\tseq_puts(m, \"#\\n\\n\");\n\n\thist_data = data->private_data;\n\n\tseq_printf(m, \"hist_data: %p\\n\\n\", hist_data);\n\tseq_printf(m, \"  n_vals: %u\\n\", hist_data->n_vals);\n\tseq_printf(m, \"  n_keys: %u\\n\", hist_data->n_keys);\n\tseq_printf(m, \"  n_fields: %u\\n\", hist_data->n_fields);\n\n\tseq_puts(m, \"\\n  val fields:\\n\\n\");\n\n\tseq_puts(m, \"    hist_data->fields[0]:\\n\");\n\tret = hist_field_debug_show(m, hist_data->fields[0],\n\t\t\t\t    HIST_FIELD_FL_HITCOUNT);\n\tif (ret)\n\t\treturn;\n\n\tfor (i = 1; i < hist_data->n_vals; i++) {\n\t\tseq_printf(m, \"\\n    hist_data->fields[%d]:\\n\", i);\n\t\tret = hist_field_debug_show(m, hist_data->fields[i], 0);\n\t\tif (ret)\n\t\t\treturn;\n\t}\n\n\tseq_puts(m, \"\\n  key fields:\\n\");\n\n\tfor (i = hist_data->n_vals; i < hist_data->n_fields; i++) {\n\t\tseq_printf(m, \"\\n    hist_data->fields[%d]:\\n\", i);\n\t\tret = hist_field_debug_show(m, hist_data->fields[i],\n\t\t\t\t\t    HIST_FIELD_FL_KEY);\n\t\tif (ret)\n\t\t\treturn;\n\t}\n\n\tif (hist_data->n_var_refs)\n\t\tseq_puts(m, \"\\n  variable reference fields:\\n\");\n\n\tfor (i = 0; i < hist_data->n_var_refs; i++) {\n\t\tseq_printf(m, \"\\n    hist_data->var_refs[%d]:\\n\", i);\n\t\tret = hist_field_debug_show(m, hist_data->var_refs[i],\n\t\t\t\t\t    HIST_FIELD_FL_VAR_REF);\n\t\tif (ret)\n\t\t\treturn;\n\t}\n\n\tif (hist_data->n_field_vars)\n\t\tseq_puts(m, \"\\n  field variables:\\n\");\n\n\tfor (i = 0; i < hist_data->n_field_vars; i++) {\n\t\tret = field_var_debug_show(m, hist_data->field_vars[i], i, false);\n\t\tif (ret)\n\t\t\treturn;\n\t}\n\n\tret = hist_actions_debug_show(m, hist_data);\n\tif (ret)\n\t\treturn;\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);\n\nstatic void hist_trigger_debug_show(struct seq_file *m,\n\t\t\t\t    struct event_trigger_data *data, int n)\n{\n\tstruct hist_trigger_data *hist_data;\n\tint i, ret;\n\n\tif (n > 0)\n\t\tseq_puts(m, \"\\n\\n\");\n\n\tseq_puts(m, \"# event histogram\\n#\\n# trigger info: \");\n\tdata->ops->print(m, data->ops, data);\n\tseq_puts(m, \"#\\n\\n\");\n\n\thist_data = data->private_data;\n\n\tseq_printf(m, \"hist_data: %p\\n\\n\", hist_data);\n\tseq_printf(m, \"  n_vals: %u\\n\", hist_data->n_vals);\n\tseq_printf(m, \"  n_keys: %u\\n\", hist_data->n_keys);\n\tseq_printf(m, \"  n_fields: %u\\n\", hist_data->n_fields);\n\n\tseq_puts(m, \"\\n  val fields:\\n\\n\");\n\n\tseq_puts(m, \"    hist_data->fields[0]:\\n\");\n\tret = hist_field_debug_show(m, hist_data->fields[0],\n\t\t\t\t    HIST_FIELD_FL_HITCOUNT);\n\tif (ret)\n\t\treturn;\n\n\tfor (i = 1; i < hist_data->n_vals; i++) {\n\t\tseq_printf(m, \"\\n    hist_data->fields[%d]:\\n\", i);\n\t\tret = hist_field_debug_show(m, hist_data->fields[i], 0);\n\t\tif (ret)\n\t\t\treturn;\n\t}\n\n\tseq_puts(m, \"\\n  key fields:\\n\");\n\n\tfor (i = hist_data->n_vals; i < hist_data->n_fields; i++) {\n\t\tseq_printf(m, \"\\n    hist_data->fields[%d]:\\n\", i);\n\t\tret = hist_field_debug_show(m, hist_data->fields[i],\n\t\t\t\t\t    HIST_FIELD_FL_KEY);\n\t\tif (ret)\n\t\t\treturn;\n\t}\n\n\tif (hist_data->n_var_refs)\n\t\tseq_puts(m, \"\\n  variable reference fields:\\n\");\n\n\tfor (i = 0; i < hist_data->n_var_refs; i++) {\n\t\tseq_printf(m, \"\\n    hist_data->var_refs[%d]:\\n\", i);\n\t\tret = hist_field_debug_show(m, hist_data->var_refs[i],\n\t\t\t\t\t    HIST_FIELD_FL_VAR_REF);\n\t\tif (ret)\n\t\t\treturn;\n\t}\n\n\tif (hist_data->n_field_vars)\n\t\tseq_puts(m, \"\\n  field variables:\\n\");\n\n\tfor (i = 0; i < hist_data->n_field_vars; i++) {\n\t\tret = field_var_debug_show(m, hist_data->field_vars[i], i, false);\n\t\tif (ret)\n\t\t\treturn;\n\t}\n\n\tret = hist_actions_debug_show(m, hist_data);\n\tif (ret)\n\t\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "data",
            "&event_file->triggers",
            "list"
          ],
          "line": 5538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!event_file"
          ],
          "line": 5533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "event_file_data",
          "args": [
            "m->private"
          ],
          "line": 5532
        },
        "resolved": true,
        "details": {
          "function_name": "event_file_data",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.h",
          "lines": "1519-1522",
          "snippet": "static inline void *event_file_data(struct file *filp)\n{\n\treturn READ_ONCE(file_inode(filp)->i_private);\n}",
          "includes": [
            "#include \"trace_entries.h\"",
            "#include \"trace_entries.h\"",
            "#include <asm/syscall.h>\t/* some archs define it here */",
            "#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */",
            "#include \"pid_list.h\"",
            "#include <linux/once_lite.h>",
            "#include <linux/ctype.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/glob.h>",
            "#include <linux/compiler.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/mmiotrace.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_entries.h\"\n#include \"trace_entries.h\"\n#include <asm/syscall.h>\t/* some archs define it here */\n#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */\n#include \"pid_list.h\"\n#include <linux/once_lite.h>\n#include <linux/ctype.h>\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/glob.h>\n#include <linux/compiler.h>\n#include <linux/trace_events.h>\n#include <linux/trace_seq.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <linux/mmiotrace.h>\n#include <linux/ring_buffer.h>\n#include <linux/clocksource.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n#include <linux/fs.h>\n\nstatic inline void *event_file_data(struct file *filp)\n{\n\treturn READ_ONCE(file_inode(filp)->i_private);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&event_mutex"
          ],
          "line": 5530
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);\n\nstatic int hist_debug_show(struct seq_file *m, void *v)\n{\n\tstruct event_trigger_data *data;\n\tstruct trace_event_file *event_file;\n\tint n = 0, ret = 0;\n\n\tmutex_lock(&event_mutex);\n\n\tevent_file = event_file_data(m->private);\n\tif (unlikely(!event_file)) {\n\t\tret = -ENODEV;\n\t\tgoto out_unlock;\n\t}\n\n\tlist_for_each_entry(data, &event_file->triggers, list) {\n\t\tif (data->cmd_ops->trigger_type == ETT_EVENT_HIST)\n\t\t\thist_trigger_debug_show(m, data, n++);\n\t}\n\n out_unlock:\n\tmutex_unlock(&event_mutex);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "hist_trigger_debug_show",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
    "lines": "5454-5522",
    "snippet": "static void hist_trigger_debug_show(struct seq_file *m,\n\t\t\t\t    struct event_trigger_data *data, int n)\n{\n\tstruct hist_trigger_data *hist_data;\n\tint i, ret;\n\n\tif (n > 0)\n\t\tseq_puts(m, \"\\n\\n\");\n\n\tseq_puts(m, \"# event histogram\\n#\\n# trigger info: \");\n\tdata->ops->print(m, data->ops, data);\n\tseq_puts(m, \"#\\n\\n\");\n\n\thist_data = data->private_data;\n\n\tseq_printf(m, \"hist_data: %p\\n\\n\", hist_data);\n\tseq_printf(m, \"  n_vals: %u\\n\", hist_data->n_vals);\n\tseq_printf(m, \"  n_keys: %u\\n\", hist_data->n_keys);\n\tseq_printf(m, \"  n_fields: %u\\n\", hist_data->n_fields);\n\n\tseq_puts(m, \"\\n  val fields:\\n\\n\");\n\n\tseq_puts(m, \"    hist_data->fields[0]:\\n\");\n\tret = hist_field_debug_show(m, hist_data->fields[0],\n\t\t\t\t    HIST_FIELD_FL_HITCOUNT);\n\tif (ret)\n\t\treturn;\n\n\tfor (i = 1; i < hist_data->n_vals; i++) {\n\t\tseq_printf(m, \"\\n    hist_data->fields[%d]:\\n\", i);\n\t\tret = hist_field_debug_show(m, hist_data->fields[i], 0);\n\t\tif (ret)\n\t\t\treturn;\n\t}\n\n\tseq_puts(m, \"\\n  key fields:\\n\");\n\n\tfor (i = hist_data->n_vals; i < hist_data->n_fields; i++) {\n\t\tseq_printf(m, \"\\n    hist_data->fields[%d]:\\n\", i);\n\t\tret = hist_field_debug_show(m, hist_data->fields[i],\n\t\t\t\t\t    HIST_FIELD_FL_KEY);\n\t\tif (ret)\n\t\t\treturn;\n\t}\n\n\tif (hist_data->n_var_refs)\n\t\tseq_puts(m, \"\\n  variable reference fields:\\n\");\n\n\tfor (i = 0; i < hist_data->n_var_refs; i++) {\n\t\tseq_printf(m, \"\\n    hist_data->var_refs[%d]:\\n\", i);\n\t\tret = hist_field_debug_show(m, hist_data->var_refs[i],\n\t\t\t\t\t    HIST_FIELD_FL_VAR_REF);\n\t\tif (ret)\n\t\t\treturn;\n\t}\n\n\tif (hist_data->n_field_vars)\n\t\tseq_puts(m, \"\\n  field variables:\\n\");\n\n\tfor (i = 0; i < hist_data->n_field_vars; i++) {\n\t\tret = field_var_debug_show(m, hist_data->field_vars[i], i, false);\n\t\tif (ret)\n\t\t\treturn;\n\t}\n\n\tret = hist_actions_debug_show(m, hist_data);\n\tif (ret)\n\t\treturn;\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include \"tracing_map.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "hist_actions_debug_show",
          "args": [
            "m",
            "hist_data"
          ],
          "line": 5519
        },
        "resolved": true,
        "details": {
          "function_name": "hist_actions_debug_show",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "5426-5452",
          "snippet": "static int hist_actions_debug_show(struct seq_file *m,\n\t\t\t\t   struct hist_trigger_data *hist_data)\n{\n\tint i, ret = 0;\n\n\tif (hist_data->n_actions)\n\t\tseq_puts(m, \"\\n  action tracking variables (for onmax()/onchange()/onmatch()):\\n\");\n\n\tfor (i = 0; i < hist_data->n_actions; i++) {\n\t\tstruct action_data *action = hist_data->actions[i];\n\n\t\tret = hist_action_debug_show(m, action, i);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\tif (hist_data->n_save_vars)\n\t\tseq_puts(m, \"\\n  save action variables (save() params):\\n\");\n\n\tfor (i = 0; i < hist_data->n_save_vars; i++) {\n\t\tret = field_var_debug_show(m, hist_data->save_vars[i], i, true);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int hist_actions_debug_show(struct seq_file *m,\n\t\t\t\t   struct hist_trigger_data *hist_data)\n{\n\tint i, ret = 0;\n\n\tif (hist_data->n_actions)\n\t\tseq_puts(m, \"\\n  action tracking variables (for onmax()/onchange()/onmatch()):\\n\");\n\n\tfor (i = 0; i < hist_data->n_actions; i++) {\n\t\tstruct action_data *action = hist_data->actions[i];\n\n\t\tret = hist_action_debug_show(m, action, i);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\tif (hist_data->n_save_vars)\n\t\tseq_puts(m, \"\\n  save action variables (save() params):\\n\");\n\n\tfor (i = 0; i < hist_data->n_save_vars; i++) {\n\t\tret = field_var_debug_show(m, hist_data->save_vars[i], i, true);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "field_var_debug_show",
          "args": [
            "m",
            "hist_data->field_vars[i]",
            "i",
            "false"
          ],
          "line": 5514
        },
        "resolved": true,
        "details": {
          "function_name": "field_var_debug_show",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "5359-5394",
          "snippet": "static int field_var_debug_show(struct seq_file *m,\n\t\t\t\tstruct field_var *field_var, unsigned int i,\n\t\t\t\tbool save_vars)\n{\n\tconst char *vars_name = save_vars ? \"save_vars\" : \"field_vars\";\n\tstruct hist_field *field;\n\tint ret = 0;\n\n\tseq_printf(m, \"\\n    hist_data->%s[%d]:\\n\", vars_name, i);\n\n\tfield = field_var->var;\n\n\tseq_printf(m, \"\\n      %s[%d].var:\\n\", vars_name, i);\n\n\thist_field_debug_show_flags(m, field->flags);\n\tseq_printf(m, \"      var.name: %s\\n\", field->var.name);\n\tseq_printf(m, \"      var.idx (into tracing_map_elt.vars[]): %u\\n\",\n\t\t   field->var.idx);\n\n\tfield = field_var->val;\n\n\tseq_printf(m, \"\\n      %s[%d].val:\\n\", vars_name, i);\n\tif (field->field)\n\t\tseq_printf(m, \"      ftrace_event_field name: %s\\n\",\n\t\t\t   field->field->name);\n\telse {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tseq_printf(m, \"      type: %s\\n\", field->type);\n\tseq_printf(m, \"      size: %u\\n\", field->size);\n\tseq_printf(m, \"      is_signed: %u\\n\", field->is_signed);\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int field_var_debug_show(struct seq_file *m,\n\t\t\t\tstruct field_var *field_var, unsigned int i,\n\t\t\t\tbool save_vars)\n{\n\tconst char *vars_name = save_vars ? \"save_vars\" : \"field_vars\";\n\tstruct hist_field *field;\n\tint ret = 0;\n\n\tseq_printf(m, \"\\n    hist_data->%s[%d]:\\n\", vars_name, i);\n\n\tfield = field_var->var;\n\n\tseq_printf(m, \"\\n      %s[%d].var:\\n\", vars_name, i);\n\n\thist_field_debug_show_flags(m, field->flags);\n\tseq_printf(m, \"      var.name: %s\\n\", field->var.name);\n\tseq_printf(m, \"      var.idx (into tracing_map_elt.vars[]): %u\\n\",\n\t\t   field->var.idx);\n\n\tfield = field_var->val;\n\n\tseq_printf(m, \"\\n      %s[%d].val:\\n\", vars_name, i);\n\tif (field->field)\n\t\tseq_printf(m, \"      ftrace_event_field name: %s\\n\",\n\t\t\t   field->field->name);\n\telse {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tseq_printf(m, \"      type: %s\\n\", field->type);\n\tseq_printf(m, \"      size: %u\\n\", field->size);\n\tseq_printf(m, \"      is_signed: %u\\n\", field->is_signed);\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "m",
            "\"\\n  field variables:\\n\""
          ],
          "line": 5511
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_puts",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "205-220",
          "snippet": "void trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hist_field_debug_show",
          "args": [
            "m",
            "hist_data->var_refs[i]",
            "HIST_FIELD_FL_VAR_REF"
          ],
          "line": 5504
        },
        "resolved": true,
        "details": {
          "function_name": "hist_field_debug_show",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "5313-5357",
          "snippet": "static int hist_field_debug_show(struct seq_file *m,\n\t\t\t\t struct hist_field *field, unsigned long flags)\n{\n\tif ((field->flags & flags) != flags) {\n\t\tseq_printf(m, \"ERROR: bad flags - %lx\\n\", flags);\n\t\treturn -EINVAL;\n\t}\n\n\thist_field_debug_show_flags(m, field->flags);\n\tif (field->field)\n\t\tseq_printf(m, \"      ftrace_event_field name: %s\\n\",\n\t\t\t   field->field->name);\n\n\tif (field->flags & HIST_FIELD_FL_VAR) {\n\t\tseq_printf(m, \"      var.name: %s\\n\", field->var.name);\n\t\tseq_printf(m, \"      var.idx (into tracing_map_elt.vars[]): %u\\n\",\n\t\t\t   field->var.idx);\n\t}\n\n\tif (field->flags & HIST_FIELD_FL_CONST)\n\t\tseq_printf(m, \"      constant: %llu\\n\", field->constant);\n\n\tif (field->flags & HIST_FIELD_FL_ALIAS)\n\t\tseq_printf(m, \"      var_ref_idx (into hist_data->var_refs[]): %u\\n\",\n\t\t\t   field->var_ref_idx);\n\n\tif (field->flags & HIST_FIELD_FL_VAR_REF) {\n\t\tseq_printf(m, \"      name: %s\\n\", field->name);\n\t\tseq_printf(m, \"      var.idx (into tracing_map_elt.vars[]): %u\\n\",\n\t\t\t   field->var.idx);\n\t\tseq_printf(m, \"      var.hist_data: %p\\n\", field->var.hist_data);\n\t\tseq_printf(m, \"      var_ref_idx (into hist_data->var_refs[]): %u\\n\",\n\t\t\t   field->var_ref_idx);\n\t\tif (field->system)\n\t\t\tseq_printf(m, \"      system: %s\\n\", field->system);\n\t\tif (field->event_name)\n\t\t\tseq_printf(m, \"      event_name: %s\\n\", field->event_name);\n\t}\n\n\tseq_printf(m, \"      type: %s\\n\", field->type);\n\tseq_printf(m, \"      size: %u\\n\", field->size);\n\tseq_printf(m, \"      is_signed: %u\\n\", field->is_signed);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int hist_field_debug_show(struct seq_file *m,\n\t\t\t\t struct hist_field *field, unsigned long flags)\n{\n\tif ((field->flags & flags) != flags) {\n\t\tseq_printf(m, \"ERROR: bad flags - %lx\\n\", flags);\n\t\treturn -EINVAL;\n\t}\n\n\thist_field_debug_show_flags(m, field->flags);\n\tif (field->field)\n\t\tseq_printf(m, \"      ftrace_event_field name: %s\\n\",\n\t\t\t   field->field->name);\n\n\tif (field->flags & HIST_FIELD_FL_VAR) {\n\t\tseq_printf(m, \"      var.name: %s\\n\", field->var.name);\n\t\tseq_printf(m, \"      var.idx (into tracing_map_elt.vars[]): %u\\n\",\n\t\t\t   field->var.idx);\n\t}\n\n\tif (field->flags & HIST_FIELD_FL_CONST)\n\t\tseq_printf(m, \"      constant: %llu\\n\", field->constant);\n\n\tif (field->flags & HIST_FIELD_FL_ALIAS)\n\t\tseq_printf(m, \"      var_ref_idx (into hist_data->var_refs[]): %u\\n\",\n\t\t\t   field->var_ref_idx);\n\n\tif (field->flags & HIST_FIELD_FL_VAR_REF) {\n\t\tseq_printf(m, \"      name: %s\\n\", field->name);\n\t\tseq_printf(m, \"      var.idx (into tracing_map_elt.vars[]): %u\\n\",\n\t\t\t   field->var.idx);\n\t\tseq_printf(m, \"      var.hist_data: %p\\n\", field->var.hist_data);\n\t\tseq_printf(m, \"      var_ref_idx (into hist_data->var_refs[]): %u\\n\",\n\t\t\t   field->var_ref_idx);\n\t\tif (field->system)\n\t\t\tseq_printf(m, \"      system: %s\\n\", field->system);\n\t\tif (field->event_name)\n\t\t\tseq_printf(m, \"      event_name: %s\\n\", field->event_name);\n\t}\n\n\tseq_printf(m, \"      type: %s\\n\", field->type);\n\tseq_printf(m, \"      size: %u\\n\", field->size);\n\tseq_printf(m, \"      is_signed: %u\\n\", field->is_signed);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"\\n    hist_data->var_refs[%d]:\\n\"",
            "i"
          ],
          "line": 5503
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "81-100",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "data->ops->print",
          "args": [
            "m",
            "data->ops",
            "data"
          ],
          "line": 5464
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);\n\nstatic void hist_trigger_debug_show(struct seq_file *m,\n\t\t\t\t    struct event_trigger_data *data, int n)\n{\n\tstruct hist_trigger_data *hist_data;\n\tint i, ret;\n\n\tif (n > 0)\n\t\tseq_puts(m, \"\\n\\n\");\n\n\tseq_puts(m, \"# event histogram\\n#\\n# trigger info: \");\n\tdata->ops->print(m, data->ops, data);\n\tseq_puts(m, \"#\\n\\n\");\n\n\thist_data = data->private_data;\n\n\tseq_printf(m, \"hist_data: %p\\n\\n\", hist_data);\n\tseq_printf(m, \"  n_vals: %u\\n\", hist_data->n_vals);\n\tseq_printf(m, \"  n_keys: %u\\n\", hist_data->n_keys);\n\tseq_printf(m, \"  n_fields: %u\\n\", hist_data->n_fields);\n\n\tseq_puts(m, \"\\n  val fields:\\n\\n\");\n\n\tseq_puts(m, \"    hist_data->fields[0]:\\n\");\n\tret = hist_field_debug_show(m, hist_data->fields[0],\n\t\t\t\t    HIST_FIELD_FL_HITCOUNT);\n\tif (ret)\n\t\treturn;\n\n\tfor (i = 1; i < hist_data->n_vals; i++) {\n\t\tseq_printf(m, \"\\n    hist_data->fields[%d]:\\n\", i);\n\t\tret = hist_field_debug_show(m, hist_data->fields[i], 0);\n\t\tif (ret)\n\t\t\treturn;\n\t}\n\n\tseq_puts(m, \"\\n  key fields:\\n\");\n\n\tfor (i = hist_data->n_vals; i < hist_data->n_fields; i++) {\n\t\tseq_printf(m, \"\\n    hist_data->fields[%d]:\\n\", i);\n\t\tret = hist_field_debug_show(m, hist_data->fields[i],\n\t\t\t\t\t    HIST_FIELD_FL_KEY);\n\t\tif (ret)\n\t\t\treturn;\n\t}\n\n\tif (hist_data->n_var_refs)\n\t\tseq_puts(m, \"\\n  variable reference fields:\\n\");\n\n\tfor (i = 0; i < hist_data->n_var_refs; i++) {\n\t\tseq_printf(m, \"\\n    hist_data->var_refs[%d]:\\n\", i);\n\t\tret = hist_field_debug_show(m, hist_data->var_refs[i],\n\t\t\t\t\t    HIST_FIELD_FL_VAR_REF);\n\t\tif (ret)\n\t\t\treturn;\n\t}\n\n\tif (hist_data->n_field_vars)\n\t\tseq_puts(m, \"\\n  field variables:\\n\");\n\n\tfor (i = 0; i < hist_data->n_field_vars; i++) {\n\t\tret = field_var_debug_show(m, hist_data->field_vars[i], i, false);\n\t\tif (ret)\n\t\t\treturn;\n\t}\n\n\tret = hist_actions_debug_show(m, hist_data);\n\tif (ret)\n\t\treturn;\n}"
  },
  {
    "function_name": "hist_actions_debug_show",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
    "lines": "5426-5452",
    "snippet": "static int hist_actions_debug_show(struct seq_file *m,\n\t\t\t\t   struct hist_trigger_data *hist_data)\n{\n\tint i, ret = 0;\n\n\tif (hist_data->n_actions)\n\t\tseq_puts(m, \"\\n  action tracking variables (for onmax()/onchange()/onmatch()):\\n\");\n\n\tfor (i = 0; i < hist_data->n_actions; i++) {\n\t\tstruct action_data *action = hist_data->actions[i];\n\n\t\tret = hist_action_debug_show(m, action, i);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\tif (hist_data->n_save_vars)\n\t\tseq_puts(m, \"\\n  save action variables (save() params):\\n\");\n\n\tfor (i = 0; i < hist_data->n_save_vars; i++) {\n\t\tret = field_var_debug_show(m, hist_data->save_vars[i], i, true);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\nout:\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include \"tracing_map.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "field_var_debug_show",
          "args": [
            "m",
            "hist_data->save_vars[i]",
            "i",
            "true"
          ],
          "line": 5446
        },
        "resolved": true,
        "details": {
          "function_name": "field_var_debug_show",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "5359-5394",
          "snippet": "static int field_var_debug_show(struct seq_file *m,\n\t\t\t\tstruct field_var *field_var, unsigned int i,\n\t\t\t\tbool save_vars)\n{\n\tconst char *vars_name = save_vars ? \"save_vars\" : \"field_vars\";\n\tstruct hist_field *field;\n\tint ret = 0;\n\n\tseq_printf(m, \"\\n    hist_data->%s[%d]:\\n\", vars_name, i);\n\n\tfield = field_var->var;\n\n\tseq_printf(m, \"\\n      %s[%d].var:\\n\", vars_name, i);\n\n\thist_field_debug_show_flags(m, field->flags);\n\tseq_printf(m, \"      var.name: %s\\n\", field->var.name);\n\tseq_printf(m, \"      var.idx (into tracing_map_elt.vars[]): %u\\n\",\n\t\t   field->var.idx);\n\n\tfield = field_var->val;\n\n\tseq_printf(m, \"\\n      %s[%d].val:\\n\", vars_name, i);\n\tif (field->field)\n\t\tseq_printf(m, \"      ftrace_event_field name: %s\\n\",\n\t\t\t   field->field->name);\n\telse {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tseq_printf(m, \"      type: %s\\n\", field->type);\n\tseq_printf(m, \"      size: %u\\n\", field->size);\n\tseq_printf(m, \"      is_signed: %u\\n\", field->is_signed);\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int field_var_debug_show(struct seq_file *m,\n\t\t\t\tstruct field_var *field_var, unsigned int i,\n\t\t\t\tbool save_vars)\n{\n\tconst char *vars_name = save_vars ? \"save_vars\" : \"field_vars\";\n\tstruct hist_field *field;\n\tint ret = 0;\n\n\tseq_printf(m, \"\\n    hist_data->%s[%d]:\\n\", vars_name, i);\n\n\tfield = field_var->var;\n\n\tseq_printf(m, \"\\n      %s[%d].var:\\n\", vars_name, i);\n\n\thist_field_debug_show_flags(m, field->flags);\n\tseq_printf(m, \"      var.name: %s\\n\", field->var.name);\n\tseq_printf(m, \"      var.idx (into tracing_map_elt.vars[]): %u\\n\",\n\t\t   field->var.idx);\n\n\tfield = field_var->val;\n\n\tseq_printf(m, \"\\n      %s[%d].val:\\n\", vars_name, i);\n\tif (field->field)\n\t\tseq_printf(m, \"      ftrace_event_field name: %s\\n\",\n\t\t\t   field->field->name);\n\telse {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tseq_printf(m, \"      type: %s\\n\", field->type);\n\tseq_printf(m, \"      size: %u\\n\", field->size);\n\tseq_printf(m, \"      is_signed: %u\\n\", field->is_signed);\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "m",
            "\"\\n  save action variables (save() params):\\n\""
          ],
          "line": 5443
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_puts",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "205-220",
          "snippet": "void trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hist_action_debug_show",
          "args": [
            "m",
            "action",
            "i"
          ],
          "line": 5437
        },
        "resolved": true,
        "details": {
          "function_name": "hist_action_debug_show",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "5396-5424",
          "snippet": "static int hist_action_debug_show(struct seq_file *m,\n\t\t\t\t  struct action_data *data, int i)\n{\n\tint ret = 0;\n\n\tif (data->handler == HANDLER_ONMAX ||\n\t    data->handler == HANDLER_ONCHANGE) {\n\t\tseq_printf(m, \"\\n    hist_data->actions[%d].track_data.var_ref:\\n\", i);\n\t\tret = hist_field_debug_show(m, data->track_data.var_ref,\n\t\t\t\t\t    HIST_FIELD_FL_VAR_REF);\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\tseq_printf(m, \"\\n    hist_data->actions[%d].track_data.track_var:\\n\", i);\n\t\tret = hist_field_debug_show(m, data->track_data.track_var,\n\t\t\t\t\t    HIST_FIELD_FL_VAR);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\tif (data->handler == HANDLER_ONMATCH) {\n\t\tseq_printf(m, \"\\n    hist_data->actions[%d].match_data.event_system: %s\\n\",\n\t\t\t   i, data->match_data.event_system);\n\t\tseq_printf(m, \"    hist_data->actions[%d].match_data.event: %s\\n\",\n\t\t\t   i, data->match_data.event);\n\t}\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);\n\nstatic int hist_action_debug_show(struct seq_file *m,\n\t\t\t\t  struct action_data *data, int i)\n{\n\tint ret = 0;\n\n\tif (data->handler == HANDLER_ONMAX ||\n\t    data->handler == HANDLER_ONCHANGE) {\n\t\tseq_printf(m, \"\\n    hist_data->actions[%d].track_data.var_ref:\\n\", i);\n\t\tret = hist_field_debug_show(m, data->track_data.var_ref,\n\t\t\t\t\t    HIST_FIELD_FL_VAR_REF);\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\tseq_printf(m, \"\\n    hist_data->actions[%d].track_data.track_var:\\n\", i);\n\t\tret = hist_field_debug_show(m, data->track_data.track_var,\n\t\t\t\t\t    HIST_FIELD_FL_VAR);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\tif (data->handler == HANDLER_ONMATCH) {\n\t\tseq_printf(m, \"\\n    hist_data->actions[%d].match_data.event_system: %s\\n\",\n\t\t\t   i, data->match_data.event_system);\n\t\tseq_printf(m, \"    hist_data->actions[%d].match_data.event: %s\\n\",\n\t\t\t   i, data->match_data.event);\n\t}\nout:\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int hist_actions_debug_show(struct seq_file *m,\n\t\t\t\t   struct hist_trigger_data *hist_data)\n{\n\tint i, ret = 0;\n\n\tif (hist_data->n_actions)\n\t\tseq_puts(m, \"\\n  action tracking variables (for onmax()/onchange()/onmatch()):\\n\");\n\n\tfor (i = 0; i < hist_data->n_actions; i++) {\n\t\tstruct action_data *action = hist_data->actions[i];\n\n\t\tret = hist_action_debug_show(m, action, i);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\tif (hist_data->n_save_vars)\n\t\tseq_puts(m, \"\\n  save action variables (save() params):\\n\");\n\n\tfor (i = 0; i < hist_data->n_save_vars; i++) {\n\t\tret = field_var_debug_show(m, hist_data->save_vars[i], i, true);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "hist_action_debug_show",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
    "lines": "5396-5424",
    "snippet": "static int hist_action_debug_show(struct seq_file *m,\n\t\t\t\t  struct action_data *data, int i)\n{\n\tint ret = 0;\n\n\tif (data->handler == HANDLER_ONMAX ||\n\t    data->handler == HANDLER_ONCHANGE) {\n\t\tseq_printf(m, \"\\n    hist_data->actions[%d].track_data.var_ref:\\n\", i);\n\t\tret = hist_field_debug_show(m, data->track_data.var_ref,\n\t\t\t\t\t    HIST_FIELD_FL_VAR_REF);\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\tseq_printf(m, \"\\n    hist_data->actions[%d].track_data.track_var:\\n\", i);\n\t\tret = hist_field_debug_show(m, data->track_data.track_var,\n\t\t\t\t\t    HIST_FIELD_FL_VAR);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\tif (data->handler == HANDLER_ONMATCH) {\n\t\tseq_printf(m, \"\\n    hist_data->actions[%d].match_data.event_system: %s\\n\",\n\t\t\t   i, data->match_data.event_system);\n\t\tseq_printf(m, \"    hist_data->actions[%d].match_data.event: %s\\n\",\n\t\t\t   i, data->match_data.event);\n\t}\nout:\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include \"tracing_map.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"    hist_data->actions[%d].match_data.event: %s\\n\"",
            "i",
            "data->match_data.event"
          ],
          "line": 5419
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "81-100",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "hist_field_debug_show",
          "args": [
            "m",
            "data->track_data.track_var",
            "HIST_FIELD_FL_VAR"
          ],
          "line": 5410
        },
        "resolved": true,
        "details": {
          "function_name": "hist_field_debug_show",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "5313-5357",
          "snippet": "static int hist_field_debug_show(struct seq_file *m,\n\t\t\t\t struct hist_field *field, unsigned long flags)\n{\n\tif ((field->flags & flags) != flags) {\n\t\tseq_printf(m, \"ERROR: bad flags - %lx\\n\", flags);\n\t\treturn -EINVAL;\n\t}\n\n\thist_field_debug_show_flags(m, field->flags);\n\tif (field->field)\n\t\tseq_printf(m, \"      ftrace_event_field name: %s\\n\",\n\t\t\t   field->field->name);\n\n\tif (field->flags & HIST_FIELD_FL_VAR) {\n\t\tseq_printf(m, \"      var.name: %s\\n\", field->var.name);\n\t\tseq_printf(m, \"      var.idx (into tracing_map_elt.vars[]): %u\\n\",\n\t\t\t   field->var.idx);\n\t}\n\n\tif (field->flags & HIST_FIELD_FL_CONST)\n\t\tseq_printf(m, \"      constant: %llu\\n\", field->constant);\n\n\tif (field->flags & HIST_FIELD_FL_ALIAS)\n\t\tseq_printf(m, \"      var_ref_idx (into hist_data->var_refs[]): %u\\n\",\n\t\t\t   field->var_ref_idx);\n\n\tif (field->flags & HIST_FIELD_FL_VAR_REF) {\n\t\tseq_printf(m, \"      name: %s\\n\", field->name);\n\t\tseq_printf(m, \"      var.idx (into tracing_map_elt.vars[]): %u\\n\",\n\t\t\t   field->var.idx);\n\t\tseq_printf(m, \"      var.hist_data: %p\\n\", field->var.hist_data);\n\t\tseq_printf(m, \"      var_ref_idx (into hist_data->var_refs[]): %u\\n\",\n\t\t\t   field->var_ref_idx);\n\t\tif (field->system)\n\t\t\tseq_printf(m, \"      system: %s\\n\", field->system);\n\t\tif (field->event_name)\n\t\t\tseq_printf(m, \"      event_name: %s\\n\", field->event_name);\n\t}\n\n\tseq_printf(m, \"      type: %s\\n\", field->type);\n\tseq_printf(m, \"      size: %u\\n\", field->size);\n\tseq_printf(m, \"      is_signed: %u\\n\", field->is_signed);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int hist_field_debug_show(struct seq_file *m,\n\t\t\t\t struct hist_field *field, unsigned long flags)\n{\n\tif ((field->flags & flags) != flags) {\n\t\tseq_printf(m, \"ERROR: bad flags - %lx\\n\", flags);\n\t\treturn -EINVAL;\n\t}\n\n\thist_field_debug_show_flags(m, field->flags);\n\tif (field->field)\n\t\tseq_printf(m, \"      ftrace_event_field name: %s\\n\",\n\t\t\t   field->field->name);\n\n\tif (field->flags & HIST_FIELD_FL_VAR) {\n\t\tseq_printf(m, \"      var.name: %s\\n\", field->var.name);\n\t\tseq_printf(m, \"      var.idx (into tracing_map_elt.vars[]): %u\\n\",\n\t\t\t   field->var.idx);\n\t}\n\n\tif (field->flags & HIST_FIELD_FL_CONST)\n\t\tseq_printf(m, \"      constant: %llu\\n\", field->constant);\n\n\tif (field->flags & HIST_FIELD_FL_ALIAS)\n\t\tseq_printf(m, \"      var_ref_idx (into hist_data->var_refs[]): %u\\n\",\n\t\t\t   field->var_ref_idx);\n\n\tif (field->flags & HIST_FIELD_FL_VAR_REF) {\n\t\tseq_printf(m, \"      name: %s\\n\", field->name);\n\t\tseq_printf(m, \"      var.idx (into tracing_map_elt.vars[]): %u\\n\",\n\t\t\t   field->var.idx);\n\t\tseq_printf(m, \"      var.hist_data: %p\\n\", field->var.hist_data);\n\t\tseq_printf(m, \"      var_ref_idx (into hist_data->var_refs[]): %u\\n\",\n\t\t\t   field->var_ref_idx);\n\t\tif (field->system)\n\t\t\tseq_printf(m, \"      system: %s\\n\", field->system);\n\t\tif (field->event_name)\n\t\t\tseq_printf(m, \"      event_name: %s\\n\", field->event_name);\n\t}\n\n\tseq_printf(m, \"      type: %s\\n\", field->type);\n\tseq_printf(m, \"      size: %u\\n\", field->size);\n\tseq_printf(m, \"      is_signed: %u\\n\", field->is_signed);\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);\n\nstatic int hist_action_debug_show(struct seq_file *m,\n\t\t\t\t  struct action_data *data, int i)\n{\n\tint ret = 0;\n\n\tif (data->handler == HANDLER_ONMAX ||\n\t    data->handler == HANDLER_ONCHANGE) {\n\t\tseq_printf(m, \"\\n    hist_data->actions[%d].track_data.var_ref:\\n\", i);\n\t\tret = hist_field_debug_show(m, data->track_data.var_ref,\n\t\t\t\t\t    HIST_FIELD_FL_VAR_REF);\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\tseq_printf(m, \"\\n    hist_data->actions[%d].track_data.track_var:\\n\", i);\n\t\tret = hist_field_debug_show(m, data->track_data.track_var,\n\t\t\t\t\t    HIST_FIELD_FL_VAR);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\tif (data->handler == HANDLER_ONMATCH) {\n\t\tseq_printf(m, \"\\n    hist_data->actions[%d].match_data.event_system: %s\\n\",\n\t\t\t   i, data->match_data.event_system);\n\t\tseq_printf(m, \"    hist_data->actions[%d].match_data.event: %s\\n\",\n\t\t\t   i, data->match_data.event);\n\t}\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "field_var_debug_show",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
    "lines": "5359-5394",
    "snippet": "static int field_var_debug_show(struct seq_file *m,\n\t\t\t\tstruct field_var *field_var, unsigned int i,\n\t\t\t\tbool save_vars)\n{\n\tconst char *vars_name = save_vars ? \"save_vars\" : \"field_vars\";\n\tstruct hist_field *field;\n\tint ret = 0;\n\n\tseq_printf(m, \"\\n    hist_data->%s[%d]:\\n\", vars_name, i);\n\n\tfield = field_var->var;\n\n\tseq_printf(m, \"\\n      %s[%d].var:\\n\", vars_name, i);\n\n\thist_field_debug_show_flags(m, field->flags);\n\tseq_printf(m, \"      var.name: %s\\n\", field->var.name);\n\tseq_printf(m, \"      var.idx (into tracing_map_elt.vars[]): %u\\n\",\n\t\t   field->var.idx);\n\n\tfield = field_var->val;\n\n\tseq_printf(m, \"\\n      %s[%d].val:\\n\", vars_name, i);\n\tif (field->field)\n\t\tseq_printf(m, \"      ftrace_event_field name: %s\\n\",\n\t\t\t   field->field->name);\n\telse {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tseq_printf(m, \"      type: %s\\n\", field->type);\n\tseq_printf(m, \"      size: %u\\n\", field->size);\n\tseq_printf(m, \"      is_signed: %u\\n\", field->is_signed);\nout:\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include \"tracing_map.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"      is_signed: %u\\n\"",
            "field->is_signed"
          ],
          "line": 5391
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "81-100",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "hist_field_debug_show_flags",
          "args": [
            "m",
            "field->flags"
          ],
          "line": 5373
        },
        "resolved": true,
        "details": {
          "function_name": "hist_field_debug_show_flags",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "5291-5311",
          "snippet": "static void hist_field_debug_show_flags(struct seq_file *m,\n\t\t\t\t\tunsigned long flags)\n{\n\tseq_puts(m, \"      flags:\\n\");\n\n\tif (flags & HIST_FIELD_FL_KEY)\n\t\tseq_puts(m, \"        HIST_FIELD_FL_KEY\\n\");\n\telse if (flags & HIST_FIELD_FL_HITCOUNT)\n\t\tseq_puts(m, \"        VAL: HIST_FIELD_FL_HITCOUNT\\n\");\n\telse if (flags & HIST_FIELD_FL_VAR)\n\t\tseq_puts(m, \"        HIST_FIELD_FL_VAR\\n\");\n\telse if (flags & HIST_FIELD_FL_VAR_REF)\n\t\tseq_puts(m, \"        HIST_FIELD_FL_VAR_REF\\n\");\n\telse\n\t\tseq_puts(m, \"        VAL: normal u64 value\\n\");\n\n\tif (flags & HIST_FIELD_FL_ALIAS)\n\t\tseq_puts(m, \"        HIST_FIELD_FL_ALIAS\\n\");\n\telse if (flags & HIST_FIELD_FL_CONST)\n\t\tseq_puts(m, \"        HIST_FIELD_FL_CONST\\n\");\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void hist_field_debug_show_flags(struct seq_file *m,\n\t\t\t\t\tunsigned long flags)\n{\n\tseq_puts(m, \"      flags:\\n\");\n\n\tif (flags & HIST_FIELD_FL_KEY)\n\t\tseq_puts(m, \"        HIST_FIELD_FL_KEY\\n\");\n\telse if (flags & HIST_FIELD_FL_HITCOUNT)\n\t\tseq_puts(m, \"        VAL: HIST_FIELD_FL_HITCOUNT\\n\");\n\telse if (flags & HIST_FIELD_FL_VAR)\n\t\tseq_puts(m, \"        HIST_FIELD_FL_VAR\\n\");\n\telse if (flags & HIST_FIELD_FL_VAR_REF)\n\t\tseq_puts(m, \"        HIST_FIELD_FL_VAR_REF\\n\");\n\telse\n\t\tseq_puts(m, \"        VAL: normal u64 value\\n\");\n\n\tif (flags & HIST_FIELD_FL_ALIAS)\n\t\tseq_puts(m, \"        HIST_FIELD_FL_ALIAS\\n\");\n\telse if (flags & HIST_FIELD_FL_CONST)\n\t\tseq_puts(m, \"        HIST_FIELD_FL_CONST\\n\");\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int field_var_debug_show(struct seq_file *m,\n\t\t\t\tstruct field_var *field_var, unsigned int i,\n\t\t\t\tbool save_vars)\n{\n\tconst char *vars_name = save_vars ? \"save_vars\" : \"field_vars\";\n\tstruct hist_field *field;\n\tint ret = 0;\n\n\tseq_printf(m, \"\\n    hist_data->%s[%d]:\\n\", vars_name, i);\n\n\tfield = field_var->var;\n\n\tseq_printf(m, \"\\n      %s[%d].var:\\n\", vars_name, i);\n\n\thist_field_debug_show_flags(m, field->flags);\n\tseq_printf(m, \"      var.name: %s\\n\", field->var.name);\n\tseq_printf(m, \"      var.idx (into tracing_map_elt.vars[]): %u\\n\",\n\t\t   field->var.idx);\n\n\tfield = field_var->val;\n\n\tseq_printf(m, \"\\n      %s[%d].val:\\n\", vars_name, i);\n\tif (field->field)\n\t\tseq_printf(m, \"      ftrace_event_field name: %s\\n\",\n\t\t\t   field->field->name);\n\telse {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tseq_printf(m, \"      type: %s\\n\", field->type);\n\tseq_printf(m, \"      size: %u\\n\", field->size);\n\tseq_printf(m, \"      is_signed: %u\\n\", field->is_signed);\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "hist_field_debug_show",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
    "lines": "5313-5357",
    "snippet": "static int hist_field_debug_show(struct seq_file *m,\n\t\t\t\t struct hist_field *field, unsigned long flags)\n{\n\tif ((field->flags & flags) != flags) {\n\t\tseq_printf(m, \"ERROR: bad flags - %lx\\n\", flags);\n\t\treturn -EINVAL;\n\t}\n\n\thist_field_debug_show_flags(m, field->flags);\n\tif (field->field)\n\t\tseq_printf(m, \"      ftrace_event_field name: %s\\n\",\n\t\t\t   field->field->name);\n\n\tif (field->flags & HIST_FIELD_FL_VAR) {\n\t\tseq_printf(m, \"      var.name: %s\\n\", field->var.name);\n\t\tseq_printf(m, \"      var.idx (into tracing_map_elt.vars[]): %u\\n\",\n\t\t\t   field->var.idx);\n\t}\n\n\tif (field->flags & HIST_FIELD_FL_CONST)\n\t\tseq_printf(m, \"      constant: %llu\\n\", field->constant);\n\n\tif (field->flags & HIST_FIELD_FL_ALIAS)\n\t\tseq_printf(m, \"      var_ref_idx (into hist_data->var_refs[]): %u\\n\",\n\t\t\t   field->var_ref_idx);\n\n\tif (field->flags & HIST_FIELD_FL_VAR_REF) {\n\t\tseq_printf(m, \"      name: %s\\n\", field->name);\n\t\tseq_printf(m, \"      var.idx (into tracing_map_elt.vars[]): %u\\n\",\n\t\t\t   field->var.idx);\n\t\tseq_printf(m, \"      var.hist_data: %p\\n\", field->var.hist_data);\n\t\tseq_printf(m, \"      var_ref_idx (into hist_data->var_refs[]): %u\\n\",\n\t\t\t   field->var_ref_idx);\n\t\tif (field->system)\n\t\t\tseq_printf(m, \"      system: %s\\n\", field->system);\n\t\tif (field->event_name)\n\t\t\tseq_printf(m, \"      event_name: %s\\n\", field->event_name);\n\t}\n\n\tseq_printf(m, \"      type: %s\\n\", field->type);\n\tseq_printf(m, \"      size: %u\\n\", field->size);\n\tseq_printf(m, \"      is_signed: %u\\n\", field->is_signed);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include \"tracing_map.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"      is_signed: %u\\n\"",
            "field->is_signed"
          ],
          "line": 5354
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "81-100",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "hist_field_debug_show_flags",
          "args": [
            "m",
            "field->flags"
          ],
          "line": 5321
        },
        "resolved": true,
        "details": {
          "function_name": "hist_field_debug_show_flags",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "5291-5311",
          "snippet": "static void hist_field_debug_show_flags(struct seq_file *m,\n\t\t\t\t\tunsigned long flags)\n{\n\tseq_puts(m, \"      flags:\\n\");\n\n\tif (flags & HIST_FIELD_FL_KEY)\n\t\tseq_puts(m, \"        HIST_FIELD_FL_KEY\\n\");\n\telse if (flags & HIST_FIELD_FL_HITCOUNT)\n\t\tseq_puts(m, \"        VAL: HIST_FIELD_FL_HITCOUNT\\n\");\n\telse if (flags & HIST_FIELD_FL_VAR)\n\t\tseq_puts(m, \"        HIST_FIELD_FL_VAR\\n\");\n\telse if (flags & HIST_FIELD_FL_VAR_REF)\n\t\tseq_puts(m, \"        HIST_FIELD_FL_VAR_REF\\n\");\n\telse\n\t\tseq_puts(m, \"        VAL: normal u64 value\\n\");\n\n\tif (flags & HIST_FIELD_FL_ALIAS)\n\t\tseq_puts(m, \"        HIST_FIELD_FL_ALIAS\\n\");\n\telse if (flags & HIST_FIELD_FL_CONST)\n\t\tseq_puts(m, \"        HIST_FIELD_FL_CONST\\n\");\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void hist_field_debug_show_flags(struct seq_file *m,\n\t\t\t\t\tunsigned long flags)\n{\n\tseq_puts(m, \"      flags:\\n\");\n\n\tif (flags & HIST_FIELD_FL_KEY)\n\t\tseq_puts(m, \"        HIST_FIELD_FL_KEY\\n\");\n\telse if (flags & HIST_FIELD_FL_HITCOUNT)\n\t\tseq_puts(m, \"        VAL: HIST_FIELD_FL_HITCOUNT\\n\");\n\telse if (flags & HIST_FIELD_FL_VAR)\n\t\tseq_puts(m, \"        HIST_FIELD_FL_VAR\\n\");\n\telse if (flags & HIST_FIELD_FL_VAR_REF)\n\t\tseq_puts(m, \"        HIST_FIELD_FL_VAR_REF\\n\");\n\telse\n\t\tseq_puts(m, \"        VAL: normal u64 value\\n\");\n\n\tif (flags & HIST_FIELD_FL_ALIAS)\n\t\tseq_puts(m, \"        HIST_FIELD_FL_ALIAS\\n\");\n\telse if (flags & HIST_FIELD_FL_CONST)\n\t\tseq_puts(m, \"        HIST_FIELD_FL_CONST\\n\");\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int hist_field_debug_show(struct seq_file *m,\n\t\t\t\t struct hist_field *field, unsigned long flags)\n{\n\tif ((field->flags & flags) != flags) {\n\t\tseq_printf(m, \"ERROR: bad flags - %lx\\n\", flags);\n\t\treturn -EINVAL;\n\t}\n\n\thist_field_debug_show_flags(m, field->flags);\n\tif (field->field)\n\t\tseq_printf(m, \"      ftrace_event_field name: %s\\n\",\n\t\t\t   field->field->name);\n\n\tif (field->flags & HIST_FIELD_FL_VAR) {\n\t\tseq_printf(m, \"      var.name: %s\\n\", field->var.name);\n\t\tseq_printf(m, \"      var.idx (into tracing_map_elt.vars[]): %u\\n\",\n\t\t\t   field->var.idx);\n\t}\n\n\tif (field->flags & HIST_FIELD_FL_CONST)\n\t\tseq_printf(m, \"      constant: %llu\\n\", field->constant);\n\n\tif (field->flags & HIST_FIELD_FL_ALIAS)\n\t\tseq_printf(m, \"      var_ref_idx (into hist_data->var_refs[]): %u\\n\",\n\t\t\t   field->var_ref_idx);\n\n\tif (field->flags & HIST_FIELD_FL_VAR_REF) {\n\t\tseq_printf(m, \"      name: %s\\n\", field->name);\n\t\tseq_printf(m, \"      var.idx (into tracing_map_elt.vars[]): %u\\n\",\n\t\t\t   field->var.idx);\n\t\tseq_printf(m, \"      var.hist_data: %p\\n\", field->var.hist_data);\n\t\tseq_printf(m, \"      var_ref_idx (into hist_data->var_refs[]): %u\\n\",\n\t\t\t   field->var_ref_idx);\n\t\tif (field->system)\n\t\t\tseq_printf(m, \"      system: %s\\n\", field->system);\n\t\tif (field->event_name)\n\t\t\tseq_printf(m, \"      event_name: %s\\n\", field->event_name);\n\t}\n\n\tseq_printf(m, \"      type: %s\\n\", field->type);\n\tseq_printf(m, \"      size: %u\\n\", field->size);\n\tseq_printf(m, \"      is_signed: %u\\n\", field->is_signed);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "hist_field_debug_show_flags",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
    "lines": "5291-5311",
    "snippet": "static void hist_field_debug_show_flags(struct seq_file *m,\n\t\t\t\t\tunsigned long flags)\n{\n\tseq_puts(m, \"      flags:\\n\");\n\n\tif (flags & HIST_FIELD_FL_KEY)\n\t\tseq_puts(m, \"        HIST_FIELD_FL_KEY\\n\");\n\telse if (flags & HIST_FIELD_FL_HITCOUNT)\n\t\tseq_puts(m, \"        VAL: HIST_FIELD_FL_HITCOUNT\\n\");\n\telse if (flags & HIST_FIELD_FL_VAR)\n\t\tseq_puts(m, \"        HIST_FIELD_FL_VAR\\n\");\n\telse if (flags & HIST_FIELD_FL_VAR_REF)\n\t\tseq_puts(m, \"        HIST_FIELD_FL_VAR_REF\\n\");\n\telse\n\t\tseq_puts(m, \"        VAL: normal u64 value\\n\");\n\n\tif (flags & HIST_FIELD_FL_ALIAS)\n\t\tseq_puts(m, \"        HIST_FIELD_FL_ALIAS\\n\");\n\telse if (flags & HIST_FIELD_FL_CONST)\n\t\tseq_puts(m, \"        HIST_FIELD_FL_CONST\\n\");\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include \"tracing_map.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "m",
            "\"        HIST_FIELD_FL_CONST\\n\""
          ],
          "line": 5310
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_puts",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "205-220",
          "snippet": "void trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void hist_field_debug_show_flags(struct seq_file *m,\n\t\t\t\t\tunsigned long flags)\n{\n\tseq_puts(m, \"      flags:\\n\");\n\n\tif (flags & HIST_FIELD_FL_KEY)\n\t\tseq_puts(m, \"        HIST_FIELD_FL_KEY\\n\");\n\telse if (flags & HIST_FIELD_FL_HITCOUNT)\n\t\tseq_puts(m, \"        VAL: HIST_FIELD_FL_HITCOUNT\\n\");\n\telse if (flags & HIST_FIELD_FL_VAR)\n\t\tseq_puts(m, \"        HIST_FIELD_FL_VAR\\n\");\n\telse if (flags & HIST_FIELD_FL_VAR_REF)\n\t\tseq_puts(m, \"        HIST_FIELD_FL_VAR_REF\\n\");\n\telse\n\t\tseq_puts(m, \"        VAL: normal u64 value\\n\");\n\n\tif (flags & HIST_FIELD_FL_ALIAS)\n\t\tseq_puts(m, \"        HIST_FIELD_FL_ALIAS\\n\");\n\telse if (flags & HIST_FIELD_FL_CONST)\n\t\tseq_puts(m, \"        HIST_FIELD_FL_CONST\\n\");\n}"
  },
  {
    "function_name": "event_hist_open",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
    "lines": "5272-5281",
    "snippet": "static int event_hist_open(struct inode *inode, struct file *file)\n{\n\tint ret;\n\n\tret = security_locked_down(LOCKDOWN_TRACEFS);\n\tif (ret)\n\t\treturn ret;\n\n\treturn single_open(file, hist_show, file);\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include \"tracing_map.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "single_open",
          "args": [
            "file",
            "hist_show",
            "file"
          ],
          "line": 5280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "security_locked_down",
          "args": [
            "LOCKDOWN_TRACEFS"
          ],
          "line": 5276
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int event_hist_open(struct inode *inode, struct file *file)\n{\n\tint ret;\n\n\tret = security_locked_down(LOCKDOWN_TRACEFS);\n\tif (ret)\n\t\treturn ret;\n\n\treturn single_open(file, hist_show, file);\n}"
  },
  {
    "function_name": "hist_show",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
    "lines": "5247-5270",
    "snippet": "static int hist_show(struct seq_file *m, void *v)\n{\n\tstruct event_trigger_data *data;\n\tstruct trace_event_file *event_file;\n\tint n = 0, ret = 0;\n\n\tmutex_lock(&event_mutex);\n\n\tevent_file = event_file_data(m->private);\n\tif (unlikely(!event_file)) {\n\t\tret = -ENODEV;\n\t\tgoto out_unlock;\n\t}\n\n\tlist_for_each_entry(data, &event_file->triggers, list) {\n\t\tif (data->cmd_ops->trigger_type == ETT_EVENT_HIST)\n\t\t\thist_trigger_show(m, data, n++);\n\t}\n\n out_unlock:\n\tmutex_unlock(&event_mutex);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include \"tracing_map.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&event_mutex"
          ],
          "line": 5267
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hist_trigger_show",
          "args": [
            "m",
            "data",
            "n++"
          ],
          "line": 5263
        },
        "resolved": true,
        "details": {
          "function_name": "hist_trigger_show",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "5222-5245",
          "snippet": "static void hist_trigger_show(struct seq_file *m,\n\t\t\t      struct event_trigger_data *data, int n)\n{\n\tstruct hist_trigger_data *hist_data;\n\tint n_entries;\n\n\tif (n > 0)\n\t\tseq_puts(m, \"\\n\\n\");\n\n\tseq_puts(m, \"# event histogram\\n#\\n# trigger info: \");\n\tdata->ops->print(m, data->ops, data);\n\tseq_puts(m, \"#\\n\\n\");\n\n\thist_data = data->private_data;\n\tn_entries = print_entries(m, hist_data);\n\tif (n_entries < 0)\n\t\tn_entries = 0;\n\n\ttrack_data_snapshot_print(m, hist_data);\n\n\tseq_printf(m, \"\\nTotals:\\n    Hits: %llu\\n    Entries: %u\\n    Dropped: %llu\\n\",\n\t\t   (u64)atomic64_read(&hist_data->map->hits),\n\t\t   n_entries, (u64)atomic64_read(&hist_data->map->drops));\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);\n\nstatic void hist_trigger_show(struct seq_file *m,\n\t\t\t      struct event_trigger_data *data, int n)\n{\n\tstruct hist_trigger_data *hist_data;\n\tint n_entries;\n\n\tif (n > 0)\n\t\tseq_puts(m, \"\\n\\n\");\n\n\tseq_puts(m, \"# event histogram\\n#\\n# trigger info: \");\n\tdata->ops->print(m, data->ops, data);\n\tseq_puts(m, \"#\\n\\n\");\n\n\thist_data = data->private_data;\n\tn_entries = print_entries(m, hist_data);\n\tif (n_entries < 0)\n\t\tn_entries = 0;\n\n\ttrack_data_snapshot_print(m, hist_data);\n\n\tseq_printf(m, \"\\nTotals:\\n    Hits: %llu\\n    Entries: %u\\n    Dropped: %llu\\n\",\n\t\t   (u64)atomic64_read(&hist_data->map->hits),\n\t\t   n_entries, (u64)atomic64_read(&hist_data->map->drops));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "data",
            "&event_file->triggers",
            "list"
          ],
          "line": 5261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!event_file"
          ],
          "line": 5256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "event_file_data",
          "args": [
            "m->private"
          ],
          "line": 5255
        },
        "resolved": true,
        "details": {
          "function_name": "event_file_data",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.h",
          "lines": "1519-1522",
          "snippet": "static inline void *event_file_data(struct file *filp)\n{\n\treturn READ_ONCE(file_inode(filp)->i_private);\n}",
          "includes": [
            "#include \"trace_entries.h\"",
            "#include \"trace_entries.h\"",
            "#include <asm/syscall.h>\t/* some archs define it here */",
            "#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */",
            "#include \"pid_list.h\"",
            "#include <linux/once_lite.h>",
            "#include <linux/ctype.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/glob.h>",
            "#include <linux/compiler.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/mmiotrace.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_entries.h\"\n#include \"trace_entries.h\"\n#include <asm/syscall.h>\t/* some archs define it here */\n#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */\n#include \"pid_list.h\"\n#include <linux/once_lite.h>\n#include <linux/ctype.h>\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/glob.h>\n#include <linux/compiler.h>\n#include <linux/trace_events.h>\n#include <linux/trace_seq.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <linux/mmiotrace.h>\n#include <linux/ring_buffer.h>\n#include <linux/clocksource.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n#include <linux/fs.h>\n\nstatic inline void *event_file_data(struct file *filp)\n{\n\treturn READ_ONCE(file_inode(filp)->i_private);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&event_mutex"
          ],
          "line": 5253
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);\n\nstatic int hist_show(struct seq_file *m, void *v)\n{\n\tstruct event_trigger_data *data;\n\tstruct trace_event_file *event_file;\n\tint n = 0, ret = 0;\n\n\tmutex_lock(&event_mutex);\n\n\tevent_file = event_file_data(m->private);\n\tif (unlikely(!event_file)) {\n\t\tret = -ENODEV;\n\t\tgoto out_unlock;\n\t}\n\n\tlist_for_each_entry(data, &event_file->triggers, list) {\n\t\tif (data->cmd_ops->trigger_type == ETT_EVENT_HIST)\n\t\t\thist_trigger_show(m, data, n++);\n\t}\n\n out_unlock:\n\tmutex_unlock(&event_mutex);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "hist_trigger_show",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
    "lines": "5222-5245",
    "snippet": "static void hist_trigger_show(struct seq_file *m,\n\t\t\t      struct event_trigger_data *data, int n)\n{\n\tstruct hist_trigger_data *hist_data;\n\tint n_entries;\n\n\tif (n > 0)\n\t\tseq_puts(m, \"\\n\\n\");\n\n\tseq_puts(m, \"# event histogram\\n#\\n# trigger info: \");\n\tdata->ops->print(m, data->ops, data);\n\tseq_puts(m, \"#\\n\\n\");\n\n\thist_data = data->private_data;\n\tn_entries = print_entries(m, hist_data);\n\tif (n_entries < 0)\n\t\tn_entries = 0;\n\n\ttrack_data_snapshot_print(m, hist_data);\n\n\tseq_printf(m, \"\\nTotals:\\n    Hits: %llu\\n    Entries: %u\\n    Dropped: %llu\\n\",\n\t\t   (u64)atomic64_read(&hist_data->map->hits),\n\t\t   n_entries, (u64)atomic64_read(&hist_data->map->drops));\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include \"tracing_map.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"\\nTotals:\\n    Hits: %llu\\n    Entries: %u\\n    Dropped: %llu\\n\"",
            "(u64)atomic64_read(&hist_data->map->hits)",
            "n_entries",
            "(u64)atomic64_read(&hist_data->map->drops)"
          ],
          "line": 5242
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "81-100",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic64_read",
          "args": [
            "&hist_data->map->drops"
          ],
          "line": 5244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic64_read",
          "args": [
            "&hist_data->map->hits"
          ],
          "line": 5243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "track_data_snapshot_print",
          "args": [
            "m",
            "hist_data"
          ],
          "line": 5240
        },
        "resolved": true,
        "details": {
          "function_name": "track_data_snapshot_print",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "3383-3384",
          "snippet": "static void track_data_snapshot_print(struct seq_file *m,\n\t\t\t\t      struct hist_trigger_data *hist_data) {}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void track_data_snapshot_print(struct seq_file *m,\n\t\t\t\t      struct hist_trigger_data *hist_data) {}"
        }
      },
      {
        "call_info": {
          "callee": "print_entries",
          "args": [
            "m",
            "hist_data"
          ],
          "line": 5236
        },
        "resolved": true,
        "details": {
          "function_name": "print_entries",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "5199-5220",
          "snippet": "static int print_entries(struct seq_file *m,\n\t\t\t struct hist_trigger_data *hist_data)\n{\n\tstruct tracing_map_sort_entry **sort_entries = NULL;\n\tstruct tracing_map *map = hist_data->map;\n\tint i, n_entries;\n\n\tn_entries = tracing_map_sort_entries(map, hist_data->sort_keys,\n\t\t\t\t\t     hist_data->n_sort_keys,\n\t\t\t\t\t     &sort_entries);\n\tif (n_entries < 0)\n\t\treturn n_entries;\n\n\tfor (i = 0; i < n_entries; i++)\n\t\thist_trigger_entry_print(m, hist_data,\n\t\t\t\t\t sort_entries[i]->key,\n\t\t\t\t\t sort_entries[i]->elt);\n\n\ttracing_map_destroy_sort_entries(sort_entries, n_entries);\n\n\treturn n_entries;\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int print_entries(struct seq_file *m,\n\t\t\t struct hist_trigger_data *hist_data)\n{\n\tstruct tracing_map_sort_entry **sort_entries = NULL;\n\tstruct tracing_map *map = hist_data->map;\n\tint i, n_entries;\n\n\tn_entries = tracing_map_sort_entries(map, hist_data->sort_keys,\n\t\t\t\t\t     hist_data->n_sort_keys,\n\t\t\t\t\t     &sort_entries);\n\tif (n_entries < 0)\n\t\treturn n_entries;\n\n\tfor (i = 0; i < n_entries; i++)\n\t\thist_trigger_entry_print(m, hist_data,\n\t\t\t\t\t sort_entries[i]->key,\n\t\t\t\t\t sort_entries[i]->elt);\n\n\ttracing_map_destroy_sort_entries(sort_entries, n_entries);\n\n\treturn n_entries;\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "m",
            "\"#\\n\\n\""
          ],
          "line": 5233
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_puts",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "205-220",
          "snippet": "void trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "data->ops->print",
          "args": [
            "m",
            "data->ops",
            "data"
          ],
          "line": 5232
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);\n\nstatic void hist_trigger_show(struct seq_file *m,\n\t\t\t      struct event_trigger_data *data, int n)\n{\n\tstruct hist_trigger_data *hist_data;\n\tint n_entries;\n\n\tif (n > 0)\n\t\tseq_puts(m, \"\\n\\n\");\n\n\tseq_puts(m, \"# event histogram\\n#\\n# trigger info: \");\n\tdata->ops->print(m, data->ops, data);\n\tseq_puts(m, \"#\\n\\n\");\n\n\thist_data = data->private_data;\n\tn_entries = print_entries(m, hist_data);\n\tif (n_entries < 0)\n\t\tn_entries = 0;\n\n\ttrack_data_snapshot_print(m, hist_data);\n\n\tseq_printf(m, \"\\nTotals:\\n    Hits: %llu\\n    Entries: %u\\n    Dropped: %llu\\n\",\n\t\t   (u64)atomic64_read(&hist_data->map->hits),\n\t\t   n_entries, (u64)atomic64_read(&hist_data->map->drops));\n}"
  },
  {
    "function_name": "print_entries",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
    "lines": "5199-5220",
    "snippet": "static int print_entries(struct seq_file *m,\n\t\t\t struct hist_trigger_data *hist_data)\n{\n\tstruct tracing_map_sort_entry **sort_entries = NULL;\n\tstruct tracing_map *map = hist_data->map;\n\tint i, n_entries;\n\n\tn_entries = tracing_map_sort_entries(map, hist_data->sort_keys,\n\t\t\t\t\t     hist_data->n_sort_keys,\n\t\t\t\t\t     &sort_entries);\n\tif (n_entries < 0)\n\t\treturn n_entries;\n\n\tfor (i = 0; i < n_entries; i++)\n\t\thist_trigger_entry_print(m, hist_data,\n\t\t\t\t\t sort_entries[i]->key,\n\t\t\t\t\t sort_entries[i]->elt);\n\n\ttracing_map_destroy_sort_entries(sort_entries, n_entries);\n\n\treturn n_entries;\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include \"tracing_map.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tracing_map_destroy_sort_entries",
          "args": [
            "sort_entries",
            "n_entries"
          ],
          "line": 5217
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_map_destroy_sort_entries",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/tracing_map.c",
          "lines": "935-944",
          "snippet": "void tracing_map_destroy_sort_entries(struct tracing_map_sort_entry **entries,\n\t\t\t\t      unsigned int n_entries)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < n_entries; i++)\n\t\tdestroy_sort_entry(entries[i]);\n\n\tvfree(entries);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/kmemleak.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/jhash.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/kmemleak.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <linux/vmalloc.h>\n\nvoid tracing_map_destroy_sort_entries(struct tracing_map_sort_entry **entries,\n\t\t\t\t      unsigned int n_entries)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < n_entries; i++)\n\t\tdestroy_sort_entry(entries[i]);\n\n\tvfree(entries);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hist_trigger_entry_print",
          "args": [
            "m",
            "hist_data",
            "sort_entries[i]->key",
            "sort_entries[i]->elt"
          ],
          "line": 5213
        },
        "resolved": true,
        "details": {
          "function_name": "hist_trigger_entry_print",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "5165-5197",
          "snippet": "static void hist_trigger_entry_print(struct seq_file *m,\n\t\t\t\t     struct hist_trigger_data *hist_data,\n\t\t\t\t     void *key,\n\t\t\t\t     struct tracing_map_elt *elt)\n{\n\tconst char *field_name;\n\tunsigned int i;\n\n\thist_trigger_print_key(m, hist_data, key, elt);\n\n\tseq_printf(m, \" hitcount: %10llu\",\n\t\t   tracing_map_read_sum(elt, HITCOUNT_IDX));\n\n\tfor (i = 1; i < hist_data->n_vals; i++) {\n\t\tfield_name = hist_field_name(hist_data->fields[i], 0);\n\n\t\tif (hist_data->fields[i]->flags & HIST_FIELD_FL_VAR ||\n\t\t    hist_data->fields[i]->flags & HIST_FIELD_FL_EXPR)\n\t\t\tcontinue;\n\n\t\tif (hist_data->fields[i]->flags & HIST_FIELD_FL_HEX) {\n\t\t\tseq_printf(m, \"  %s: %10llx\", field_name,\n\t\t\t\t   tracing_map_read_sum(elt, i));\n\t\t} else {\n\t\t\tseq_printf(m, \"  %s: %10llu\", field_name,\n\t\t\t\t   tracing_map_read_sum(elt, i));\n\t\t}\n\t}\n\n\tprint_actions(m, hist_data, elt);\n\n\tseq_puts(m, \"\\n\");\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define HITCOUNT_IDX\t\t0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\n#define HITCOUNT_IDX\t\t0\n\nstatic void hist_trigger_entry_print(struct seq_file *m,\n\t\t\t\t     struct hist_trigger_data *hist_data,\n\t\t\t\t     void *key,\n\t\t\t\t     struct tracing_map_elt *elt)\n{\n\tconst char *field_name;\n\tunsigned int i;\n\n\thist_trigger_print_key(m, hist_data, key, elt);\n\n\tseq_printf(m, \" hitcount: %10llu\",\n\t\t   tracing_map_read_sum(elt, HITCOUNT_IDX));\n\n\tfor (i = 1; i < hist_data->n_vals; i++) {\n\t\tfield_name = hist_field_name(hist_data->fields[i], 0);\n\n\t\tif (hist_data->fields[i]->flags & HIST_FIELD_FL_VAR ||\n\t\t    hist_data->fields[i]->flags & HIST_FIELD_FL_EXPR)\n\t\t\tcontinue;\n\n\t\tif (hist_data->fields[i]->flags & HIST_FIELD_FL_HEX) {\n\t\t\tseq_printf(m, \"  %s: %10llx\", field_name,\n\t\t\t\t   tracing_map_read_sum(elt, i));\n\t\t} else {\n\t\t\tseq_printf(m, \"  %s: %10llu\", field_name,\n\t\t\t\t   tracing_map_read_sum(elt, i));\n\t\t}\n\t}\n\n\tprint_actions(m, hist_data, elt);\n\n\tseq_puts(m, \"\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracing_map_sort_entries",
          "args": [
            "map",
            "hist_data->sort_keys",
            "hist_data->n_sort_keys",
            "&sort_entries"
          ],
          "line": 5206
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_map_sort_entries",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/tracing_map.c",
          "lines": "1069-1134",
          "snippet": "int tracing_map_sort_entries(struct tracing_map *map,\n\t\t\t     struct tracing_map_sort_key *sort_keys,\n\t\t\t     unsigned int n_sort_keys,\n\t\t\t     struct tracing_map_sort_entry ***sort_entries)\n{\n\tint (*cmp_entries_fn)(const void *, const void *);\n\tstruct tracing_map_sort_entry *sort_entry, **entries;\n\tint i, n_entries, ret;\n\n\tentries = vmalloc(array_size(sizeof(sort_entry), map->max_elts));\n\tif (!entries)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0, n_entries = 0; i < map->map_size; i++) {\n\t\tstruct tracing_map_entry *entry;\n\n\t\tentry = TRACING_MAP_ENTRY(map->map, i);\n\n\t\tif (!entry->key || !entry->val)\n\t\t\tcontinue;\n\n\t\tentries[n_entries] = create_sort_entry(entry->val->key,\n\t\t\t\t\t\t       entry->val);\n\t\tif (!entries[n_entries++]) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto free;\n\t\t}\n\t}\n\n\tif (n_entries == 0) {\n\t\tret = 0;\n\t\tgoto free;\n\t}\n\n\tif (n_entries == 1) {\n\t\t*sort_entries = entries;\n\t\treturn 1;\n\t}\n\n\tdetect_dups(entries, n_entries, map->key_size);\n\n\tif (is_key(map, sort_keys[0].field_idx))\n\t\tcmp_entries_fn = cmp_entries_key;\n\telse\n\t\tcmp_entries_fn = cmp_entries_sum;\n\n\tset_sort_key(map, &sort_keys[0]);\n\n\tsort(entries, n_entries, sizeof(struct tracing_map_sort_entry *),\n\t     (int (*)(const void *, const void *))cmp_entries_fn, NULL);\n\n\tif (n_sort_keys > 1)\n\t\tsort_secondary(map,\n\t\t\t       (const struct tracing_map_sort_entry **)entries,\n\t\t\t       n_entries,\n\t\t\t       &sort_keys[0],\n\t\t\t       &sort_keys[1]);\n\n\t*sort_entries = entries;\n\n\treturn n_entries;\n free:\n\ttracing_map_destroy_sort_entries(entries, n_entries);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/kmemleak.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/jhash.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/kmemleak.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <linux/vmalloc.h>\n\nint tracing_map_sort_entries(struct tracing_map *map,\n\t\t\t     struct tracing_map_sort_key *sort_keys,\n\t\t\t     unsigned int n_sort_keys,\n\t\t\t     struct tracing_map_sort_entry ***sort_entries)\n{\n\tint (*cmp_entries_fn)(const void *, const void *);\n\tstruct tracing_map_sort_entry *sort_entry, **entries;\n\tint i, n_entries, ret;\n\n\tentries = vmalloc(array_size(sizeof(sort_entry), map->max_elts));\n\tif (!entries)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0, n_entries = 0; i < map->map_size; i++) {\n\t\tstruct tracing_map_entry *entry;\n\n\t\tentry = TRACING_MAP_ENTRY(map->map, i);\n\n\t\tif (!entry->key || !entry->val)\n\t\t\tcontinue;\n\n\t\tentries[n_entries] = create_sort_entry(entry->val->key,\n\t\t\t\t\t\t       entry->val);\n\t\tif (!entries[n_entries++]) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto free;\n\t\t}\n\t}\n\n\tif (n_entries == 0) {\n\t\tret = 0;\n\t\tgoto free;\n\t}\n\n\tif (n_entries == 1) {\n\t\t*sort_entries = entries;\n\t\treturn 1;\n\t}\n\n\tdetect_dups(entries, n_entries, map->key_size);\n\n\tif (is_key(map, sort_keys[0].field_idx))\n\t\tcmp_entries_fn = cmp_entries_key;\n\telse\n\t\tcmp_entries_fn = cmp_entries_sum;\n\n\tset_sort_key(map, &sort_keys[0]);\n\n\tsort(entries, n_entries, sizeof(struct tracing_map_sort_entry *),\n\t     (int (*)(const void *, const void *))cmp_entries_fn, NULL);\n\n\tif (n_sort_keys > 1)\n\t\tsort_secondary(map,\n\t\t\t       (const struct tracing_map_sort_entry **)entries,\n\t\t\t       n_entries,\n\t\t\t       &sort_keys[0],\n\t\t\t       &sort_keys[1]);\n\n\t*sort_entries = entries;\n\n\treturn n_entries;\n free:\n\ttracing_map_destroy_sort_entries(entries, n_entries);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int print_entries(struct seq_file *m,\n\t\t\t struct hist_trigger_data *hist_data)\n{\n\tstruct tracing_map_sort_entry **sort_entries = NULL;\n\tstruct tracing_map *map = hist_data->map;\n\tint i, n_entries;\n\n\tn_entries = tracing_map_sort_entries(map, hist_data->sort_keys,\n\t\t\t\t\t     hist_data->n_sort_keys,\n\t\t\t\t\t     &sort_entries);\n\tif (n_entries < 0)\n\t\treturn n_entries;\n\n\tfor (i = 0; i < n_entries; i++)\n\t\thist_trigger_entry_print(m, hist_data,\n\t\t\t\t\t sort_entries[i]->key,\n\t\t\t\t\t sort_entries[i]->elt);\n\n\ttracing_map_destroy_sort_entries(sort_entries, n_entries);\n\n\treturn n_entries;\n}"
  },
  {
    "function_name": "hist_trigger_entry_print",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
    "lines": "5165-5197",
    "snippet": "static void hist_trigger_entry_print(struct seq_file *m,\n\t\t\t\t     struct hist_trigger_data *hist_data,\n\t\t\t\t     void *key,\n\t\t\t\t     struct tracing_map_elt *elt)\n{\n\tconst char *field_name;\n\tunsigned int i;\n\n\thist_trigger_print_key(m, hist_data, key, elt);\n\n\tseq_printf(m, \" hitcount: %10llu\",\n\t\t   tracing_map_read_sum(elt, HITCOUNT_IDX));\n\n\tfor (i = 1; i < hist_data->n_vals; i++) {\n\t\tfield_name = hist_field_name(hist_data->fields[i], 0);\n\n\t\tif (hist_data->fields[i]->flags & HIST_FIELD_FL_VAR ||\n\t\t    hist_data->fields[i]->flags & HIST_FIELD_FL_EXPR)\n\t\t\tcontinue;\n\n\t\tif (hist_data->fields[i]->flags & HIST_FIELD_FL_HEX) {\n\t\t\tseq_printf(m, \"  %s: %10llx\", field_name,\n\t\t\t\t   tracing_map_read_sum(elt, i));\n\t\t} else {\n\t\t\tseq_printf(m, \"  %s: %10llu\", field_name,\n\t\t\t\t   tracing_map_read_sum(elt, i));\n\t\t}\n\t}\n\n\tprint_actions(m, hist_data, elt);\n\n\tseq_puts(m, \"\\n\");\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include \"tracing_map.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define HITCOUNT_IDX\t\t0"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "m",
            "\"\\n\""
          ],
          "line": 5196
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_puts",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "205-220",
          "snippet": "void trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_actions",
          "args": [
            "m",
            "hist_data",
            "elt"
          ],
          "line": 5194
        },
        "resolved": true,
        "details": {
          "function_name": "print_actions",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "4644-4660",
          "snippet": "static void print_actions(struct seq_file *m,\n\t\t\t  struct hist_trigger_data *hist_data,\n\t\t\t  struct tracing_map_elt *elt)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < hist_data->n_actions; i++) {\n\t\tstruct action_data *data = hist_data->actions[i];\n\n\t\tif (data->action == ACTION_SNAPSHOT)\n\t\t\tcontinue;\n\n\t\tif (data->handler == HANDLER_ONMAX ||\n\t\t    data->handler == HANDLER_ONCHANGE)\n\t\t\ttrack_data_print(m, hist_data, elt, data);\n\t}\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);\n\nstatic void print_actions(struct seq_file *m,\n\t\t\t  struct hist_trigger_data *hist_data,\n\t\t\t  struct tracing_map_elt *elt)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < hist_data->n_actions; i++) {\n\t\tstruct action_data *data = hist_data->actions[i];\n\n\t\tif (data->action == ACTION_SNAPSHOT)\n\t\t\tcontinue;\n\n\t\tif (data->handler == HANDLER_ONMAX ||\n\t\t    data->handler == HANDLER_ONCHANGE)\n\t\t\ttrack_data_print(m, hist_data, elt, data);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"  %s: %10llu\"",
            "field_name",
            "tracing_map_read_sum(elt, i)"
          ],
          "line": 5189
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "81-100",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracing_map_read_sum",
          "args": [
            "elt",
            "i"
          ],
          "line": 5190
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_map_read_sum",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/tracing_map.c",
          "lines": "56-59",
          "snippet": "u64 tracing_map_read_sum(struct tracing_map_elt *elt, unsigned int i)\n{\n\treturn (u64)atomic64_read(&elt->fields[i].sum);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/kmemleak.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/jhash.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/kmemleak.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <linux/vmalloc.h>\n\nu64 tracing_map_read_sum(struct tracing_map_elt *elt, unsigned int i)\n{\n\treturn (u64)atomic64_read(&elt->fields[i].sum);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hist_field_name",
          "args": [
            "hist_data->fields[i]",
            "0"
          ],
          "line": 5179
        },
        "resolved": true,
        "details": {
          "function_name": "hist_field_name",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "1280-1316",
          "snippet": "static const char *hist_field_name(struct hist_field *field,\n\t\t\t\t   unsigned int level)\n{\n\tconst char *field_name = \"\";\n\n\tif (level > 1)\n\t\treturn field_name;\n\n\tif (field->field)\n\t\tfield_name = field->field->name;\n\telse if (field->flags & HIST_FIELD_FL_LOG2 ||\n\t\t field->flags & HIST_FIELD_FL_ALIAS ||\n\t\t field->flags & HIST_FIELD_FL_BUCKET)\n\t\tfield_name = hist_field_name(field->operands[0], ++level);\n\telse if (field->flags & HIST_FIELD_FL_CPU)\n\t\tfield_name = \"common_cpu\";\n\telse if (field->flags & HIST_FIELD_FL_EXPR ||\n\t\t field->flags & HIST_FIELD_FL_VAR_REF) {\n\t\tif (field->system) {\n\t\t\tstatic char full_name[MAX_FILTER_STR_VAL];\n\n\t\t\tstrcat(full_name, field->system);\n\t\t\tstrcat(full_name, \".\");\n\t\t\tstrcat(full_name, field->event_name);\n\t\t\tstrcat(full_name, \".\");\n\t\t\tstrcat(full_name, field->name);\n\t\t\tfield_name = full_name;\n\t\t} else\n\t\t\tfield_name = field->name;\n\t} else if (field->flags & HIST_FIELD_FL_TIMESTAMP)\n\t\tfield_name = \"common_timestamp\";\n\n\tif (field_name == NULL)\n\t\tfield_name = \"\";\n\n\treturn field_name;\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic const char *hist_field_name(struct hist_field *field,\n\t\t\t\t   unsigned int level)\n{\n\tconst char *field_name = \"\";\n\n\tif (level > 1)\n\t\treturn field_name;\n\n\tif (field->field)\n\t\tfield_name = field->field->name;\n\telse if (field->flags & HIST_FIELD_FL_LOG2 ||\n\t\t field->flags & HIST_FIELD_FL_ALIAS ||\n\t\t field->flags & HIST_FIELD_FL_BUCKET)\n\t\tfield_name = hist_field_name(field->operands[0], ++level);\n\telse if (field->flags & HIST_FIELD_FL_CPU)\n\t\tfield_name = \"common_cpu\";\n\telse if (field->flags & HIST_FIELD_FL_EXPR ||\n\t\t field->flags & HIST_FIELD_FL_VAR_REF) {\n\t\tif (field->system) {\n\t\t\tstatic char full_name[MAX_FILTER_STR_VAL];\n\n\t\t\tstrcat(full_name, field->system);\n\t\t\tstrcat(full_name, \".\");\n\t\t\tstrcat(full_name, field->event_name);\n\t\t\tstrcat(full_name, \".\");\n\t\t\tstrcat(full_name, field->name);\n\t\t\tfield_name = full_name;\n\t\t} else\n\t\t\tfield_name = field->name;\n\t} else if (field->flags & HIST_FIELD_FL_TIMESTAMP)\n\t\tfield_name = \"common_timestamp\";\n\n\tif (field_name == NULL)\n\t\tfield_name = \"\";\n\n\treturn field_name;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hist_trigger_print_key",
          "args": [
            "m",
            "hist_data",
            "key",
            "elt"
          ],
          "line": 5173
        },
        "resolved": true,
        "details": {
          "function_name": "hist_trigger_print_key",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "5082-5163",
          "snippet": "static void hist_trigger_print_key(struct seq_file *m,\n\t\t\t\t   struct hist_trigger_data *hist_data,\n\t\t\t\t   void *key,\n\t\t\t\t   struct tracing_map_elt *elt)\n{\n\tstruct hist_field *key_field;\n\tbool multiline = false;\n\tconst char *field_name;\n\tunsigned int i;\n\tu64 uval;\n\n\tseq_puts(m, \"{ \");\n\n\tfor_each_hist_key_field(i, hist_data) {\n\t\tkey_field = hist_data->fields[i];\n\n\t\tif (i > hist_data->n_vals)\n\t\t\tseq_puts(m, \", \");\n\n\t\tfield_name = hist_field_name(key_field, 0);\n\n\t\tif (key_field->flags & HIST_FIELD_FL_HEX) {\n\t\t\tuval = *(u64 *)(key + key_field->offset);\n\t\t\tseq_printf(m, \"%s: %llx\", field_name, uval);\n\t\t} else if (key_field->flags & HIST_FIELD_FL_SYM) {\n\t\t\tuval = *(u64 *)(key + key_field->offset);\n\t\t\tseq_printf(m, \"%s: [%llx] %-45ps\", field_name,\n\t\t\t\t   uval, (void *)(uintptr_t)uval);\n\t\t} else if (key_field->flags & HIST_FIELD_FL_SYM_OFFSET) {\n\t\t\tuval = *(u64 *)(key + key_field->offset);\n\t\t\tseq_printf(m, \"%s: [%llx] %-55pS\", field_name,\n\t\t\t\t   uval, (void *)(uintptr_t)uval);\n\t\t} else if (key_field->flags & HIST_FIELD_FL_EXECNAME) {\n\t\t\tstruct hist_elt_data *elt_data = elt->private_data;\n\t\t\tchar *comm;\n\n\t\t\tif (WARN_ON_ONCE(!elt_data))\n\t\t\t\treturn;\n\n\t\t\tcomm = elt_data->comm;\n\n\t\t\tuval = *(u64 *)(key + key_field->offset);\n\t\t\tseq_printf(m, \"%s: %-16s[%10llu]\", field_name,\n\t\t\t\t   comm, uval);\n\t\t} else if (key_field->flags & HIST_FIELD_FL_SYSCALL) {\n\t\t\tconst char *syscall_name;\n\n\t\t\tuval = *(u64 *)(key + key_field->offset);\n\t\t\tsyscall_name = get_syscall_name(uval);\n\t\t\tif (!syscall_name)\n\t\t\t\tsyscall_name = \"unknown_syscall\";\n\n\t\t\tseq_printf(m, \"%s: %-30s[%3llu]\", field_name,\n\t\t\t\t   syscall_name, uval);\n\t\t} else if (key_field->flags & HIST_FIELD_FL_STACKTRACE) {\n\t\t\tseq_puts(m, \"stacktrace:\\n\");\n\t\t\thist_trigger_stacktrace_print(m,\n\t\t\t\t\t\t      key + key_field->offset,\n\t\t\t\t\t\t      HIST_STACKTRACE_DEPTH);\n\t\t\tmultiline = true;\n\t\t} else if (key_field->flags & HIST_FIELD_FL_LOG2) {\n\t\t\tseq_printf(m, \"%s: ~ 2^%-2llu\", field_name,\n\t\t\t\t   *(u64 *)(key + key_field->offset));\n\t\t} else if (key_field->flags & HIST_FIELD_FL_BUCKET) {\n\t\t\tunsigned long buckets = key_field->buckets;\n\t\t\tuval = *(u64 *)(key + key_field->offset);\n\t\t\tseq_printf(m, \"%s: ~ %llu-%llu\", field_name,\n\t\t\t\t   uval, uval + buckets -1);\n\t\t} else if (key_field->flags & HIST_FIELD_FL_STRING) {\n\t\t\tseq_printf(m, \"%s: %-50s\", field_name,\n\t\t\t\t   (char *)(key + key_field->offset));\n\t\t} else {\n\t\t\tuval = *(u64 *)(key + key_field->offset);\n\t\t\tseq_printf(m, \"%s: %10llu\", field_name, uval);\n\t\t}\n\t}\n\n\tif (!multiline)\n\t\tseq_puts(m, \" \");\n\n\tseq_puts(m, \"}\");\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define HIST_STACKTRACE_DEPTH\t16"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\n#define HIST_STACKTRACE_DEPTH\t16\n\nstatic void hist_trigger_print_key(struct seq_file *m,\n\t\t\t\t   struct hist_trigger_data *hist_data,\n\t\t\t\t   void *key,\n\t\t\t\t   struct tracing_map_elt *elt)\n{\n\tstruct hist_field *key_field;\n\tbool multiline = false;\n\tconst char *field_name;\n\tunsigned int i;\n\tu64 uval;\n\n\tseq_puts(m, \"{ \");\n\n\tfor_each_hist_key_field(i, hist_data) {\n\t\tkey_field = hist_data->fields[i];\n\n\t\tif (i > hist_data->n_vals)\n\t\t\tseq_puts(m, \", \");\n\n\t\tfield_name = hist_field_name(key_field, 0);\n\n\t\tif (key_field->flags & HIST_FIELD_FL_HEX) {\n\t\t\tuval = *(u64 *)(key + key_field->offset);\n\t\t\tseq_printf(m, \"%s: %llx\", field_name, uval);\n\t\t} else if (key_field->flags & HIST_FIELD_FL_SYM) {\n\t\t\tuval = *(u64 *)(key + key_field->offset);\n\t\t\tseq_printf(m, \"%s: [%llx] %-45ps\", field_name,\n\t\t\t\t   uval, (void *)(uintptr_t)uval);\n\t\t} else if (key_field->flags & HIST_FIELD_FL_SYM_OFFSET) {\n\t\t\tuval = *(u64 *)(key + key_field->offset);\n\t\t\tseq_printf(m, \"%s: [%llx] %-55pS\", field_name,\n\t\t\t\t   uval, (void *)(uintptr_t)uval);\n\t\t} else if (key_field->flags & HIST_FIELD_FL_EXECNAME) {\n\t\t\tstruct hist_elt_data *elt_data = elt->private_data;\n\t\t\tchar *comm;\n\n\t\t\tif (WARN_ON_ONCE(!elt_data))\n\t\t\t\treturn;\n\n\t\t\tcomm = elt_data->comm;\n\n\t\t\tuval = *(u64 *)(key + key_field->offset);\n\t\t\tseq_printf(m, \"%s: %-16s[%10llu]\", field_name,\n\t\t\t\t   comm, uval);\n\t\t} else if (key_field->flags & HIST_FIELD_FL_SYSCALL) {\n\t\t\tconst char *syscall_name;\n\n\t\t\tuval = *(u64 *)(key + key_field->offset);\n\t\t\tsyscall_name = get_syscall_name(uval);\n\t\t\tif (!syscall_name)\n\t\t\t\tsyscall_name = \"unknown_syscall\";\n\n\t\t\tseq_printf(m, \"%s: %-30s[%3llu]\", field_name,\n\t\t\t\t   syscall_name, uval);\n\t\t} else if (key_field->flags & HIST_FIELD_FL_STACKTRACE) {\n\t\t\tseq_puts(m, \"stacktrace:\\n\");\n\t\t\thist_trigger_stacktrace_print(m,\n\t\t\t\t\t\t      key + key_field->offset,\n\t\t\t\t\t\t      HIST_STACKTRACE_DEPTH);\n\t\t\tmultiline = true;\n\t\t} else if (key_field->flags & HIST_FIELD_FL_LOG2) {\n\t\t\tseq_printf(m, \"%s: ~ 2^%-2llu\", field_name,\n\t\t\t\t   *(u64 *)(key + key_field->offset));\n\t\t} else if (key_field->flags & HIST_FIELD_FL_BUCKET) {\n\t\t\tunsigned long buckets = key_field->buckets;\n\t\t\tuval = *(u64 *)(key + key_field->offset);\n\t\t\tseq_printf(m, \"%s: ~ %llu-%llu\", field_name,\n\t\t\t\t   uval, uval + buckets -1);\n\t\t} else if (key_field->flags & HIST_FIELD_FL_STRING) {\n\t\t\tseq_printf(m, \"%s: %-50s\", field_name,\n\t\t\t\t   (char *)(key + key_field->offset));\n\t\t} else {\n\t\t\tuval = *(u64 *)(key + key_field->offset);\n\t\t\tseq_printf(m, \"%s: %10llu\", field_name, uval);\n\t\t}\n\t}\n\n\tif (!multiline)\n\t\tseq_puts(m, \" \");\n\n\tseq_puts(m, \"}\");\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\n#define HITCOUNT_IDX\t\t0\n\nstatic void hist_trigger_entry_print(struct seq_file *m,\n\t\t\t\t     struct hist_trigger_data *hist_data,\n\t\t\t\t     void *key,\n\t\t\t\t     struct tracing_map_elt *elt)\n{\n\tconst char *field_name;\n\tunsigned int i;\n\n\thist_trigger_print_key(m, hist_data, key, elt);\n\n\tseq_printf(m, \" hitcount: %10llu\",\n\t\t   tracing_map_read_sum(elt, HITCOUNT_IDX));\n\n\tfor (i = 1; i < hist_data->n_vals; i++) {\n\t\tfield_name = hist_field_name(hist_data->fields[i], 0);\n\n\t\tif (hist_data->fields[i]->flags & HIST_FIELD_FL_VAR ||\n\t\t    hist_data->fields[i]->flags & HIST_FIELD_FL_EXPR)\n\t\t\tcontinue;\n\n\t\tif (hist_data->fields[i]->flags & HIST_FIELD_FL_HEX) {\n\t\t\tseq_printf(m, \"  %s: %10llx\", field_name,\n\t\t\t\t   tracing_map_read_sum(elt, i));\n\t\t} else {\n\t\t\tseq_printf(m, \"  %s: %10llu\", field_name,\n\t\t\t\t   tracing_map_read_sum(elt, i));\n\t\t}\n\t}\n\n\tprint_actions(m, hist_data, elt);\n\n\tseq_puts(m, \"\\n\");\n}"
  },
  {
    "function_name": "hist_trigger_print_key",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
    "lines": "5082-5163",
    "snippet": "static void hist_trigger_print_key(struct seq_file *m,\n\t\t\t\t   struct hist_trigger_data *hist_data,\n\t\t\t\t   void *key,\n\t\t\t\t   struct tracing_map_elt *elt)\n{\n\tstruct hist_field *key_field;\n\tbool multiline = false;\n\tconst char *field_name;\n\tunsigned int i;\n\tu64 uval;\n\n\tseq_puts(m, \"{ \");\n\n\tfor_each_hist_key_field(i, hist_data) {\n\t\tkey_field = hist_data->fields[i];\n\n\t\tif (i > hist_data->n_vals)\n\t\t\tseq_puts(m, \", \");\n\n\t\tfield_name = hist_field_name(key_field, 0);\n\n\t\tif (key_field->flags & HIST_FIELD_FL_HEX) {\n\t\t\tuval = *(u64 *)(key + key_field->offset);\n\t\t\tseq_printf(m, \"%s: %llx\", field_name, uval);\n\t\t} else if (key_field->flags & HIST_FIELD_FL_SYM) {\n\t\t\tuval = *(u64 *)(key + key_field->offset);\n\t\t\tseq_printf(m, \"%s: [%llx] %-45ps\", field_name,\n\t\t\t\t   uval, (void *)(uintptr_t)uval);\n\t\t} else if (key_field->flags & HIST_FIELD_FL_SYM_OFFSET) {\n\t\t\tuval = *(u64 *)(key + key_field->offset);\n\t\t\tseq_printf(m, \"%s: [%llx] %-55pS\", field_name,\n\t\t\t\t   uval, (void *)(uintptr_t)uval);\n\t\t} else if (key_field->flags & HIST_FIELD_FL_EXECNAME) {\n\t\t\tstruct hist_elt_data *elt_data = elt->private_data;\n\t\t\tchar *comm;\n\n\t\t\tif (WARN_ON_ONCE(!elt_data))\n\t\t\t\treturn;\n\n\t\t\tcomm = elt_data->comm;\n\n\t\t\tuval = *(u64 *)(key + key_field->offset);\n\t\t\tseq_printf(m, \"%s: %-16s[%10llu]\", field_name,\n\t\t\t\t   comm, uval);\n\t\t} else if (key_field->flags & HIST_FIELD_FL_SYSCALL) {\n\t\t\tconst char *syscall_name;\n\n\t\t\tuval = *(u64 *)(key + key_field->offset);\n\t\t\tsyscall_name = get_syscall_name(uval);\n\t\t\tif (!syscall_name)\n\t\t\t\tsyscall_name = \"unknown_syscall\";\n\n\t\t\tseq_printf(m, \"%s: %-30s[%3llu]\", field_name,\n\t\t\t\t   syscall_name, uval);\n\t\t} else if (key_field->flags & HIST_FIELD_FL_STACKTRACE) {\n\t\t\tseq_puts(m, \"stacktrace:\\n\");\n\t\t\thist_trigger_stacktrace_print(m,\n\t\t\t\t\t\t      key + key_field->offset,\n\t\t\t\t\t\t      HIST_STACKTRACE_DEPTH);\n\t\t\tmultiline = true;\n\t\t} else if (key_field->flags & HIST_FIELD_FL_LOG2) {\n\t\t\tseq_printf(m, \"%s: ~ 2^%-2llu\", field_name,\n\t\t\t\t   *(u64 *)(key + key_field->offset));\n\t\t} else if (key_field->flags & HIST_FIELD_FL_BUCKET) {\n\t\t\tunsigned long buckets = key_field->buckets;\n\t\t\tuval = *(u64 *)(key + key_field->offset);\n\t\t\tseq_printf(m, \"%s: ~ %llu-%llu\", field_name,\n\t\t\t\t   uval, uval + buckets -1);\n\t\t} else if (key_field->flags & HIST_FIELD_FL_STRING) {\n\t\t\tseq_printf(m, \"%s: %-50s\", field_name,\n\t\t\t\t   (char *)(key + key_field->offset));\n\t\t} else {\n\t\t\tuval = *(u64 *)(key + key_field->offset);\n\t\t\tseq_printf(m, \"%s: %10llu\", field_name, uval);\n\t\t}\n\t}\n\n\tif (!multiline)\n\t\tseq_puts(m, \" \");\n\n\tseq_puts(m, \"}\");\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include \"tracing_map.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define HIST_STACKTRACE_DEPTH\t16"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "m",
            "\"}\""
          ],
          "line": 5162
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_puts",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "205-220",
          "snippet": "void trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"%s: %10llu\"",
            "field_name",
            "uval"
          ],
          "line": 5155
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "81-100",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "hist_trigger_stacktrace_print",
          "args": [
            "m",
            "key + key_field->offset",
            "HIST_STACKTRACE_DEPTH"
          ],
          "line": 5138
        },
        "resolved": true,
        "details": {
          "function_name": "hist_trigger_stacktrace_print",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "5066-5080",
          "snippet": "static void hist_trigger_stacktrace_print(struct seq_file *m,\n\t\t\t\t\t  unsigned long *stacktrace_entries,\n\t\t\t\t\t  unsigned int max_entries)\n{\n\tunsigned int spaces = 8;\n\tunsigned int i;\n\n\tfor (i = 0; i < max_entries; i++) {\n\t\tif (!stacktrace_entries[i])\n\t\t\treturn;\n\n\t\tseq_printf(m, \"%*c\", 1 + spaces, ' ');\n\t\tseq_printf(m, \"%pS\\n\", (void*)stacktrace_entries[i]);\n\t}\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void hist_trigger_stacktrace_print(struct seq_file *m,\n\t\t\t\t\t  unsigned long *stacktrace_entries,\n\t\t\t\t\t  unsigned int max_entries)\n{\n\tunsigned int spaces = 8;\n\tunsigned int i;\n\n\tfor (i = 0; i < max_entries; i++) {\n\t\tif (!stacktrace_entries[i])\n\t\t\treturn;\n\n\t\tseq_printf(m, \"%*c\", 1 + spaces, ' ');\n\t\tseq_printf(m, \"%pS\\n\", (void*)stacktrace_entries[i]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_syscall_name",
          "args": [
            "uval"
          ],
          "line": 5130
        },
        "resolved": true,
        "details": {
          "function_name": "get_syscall_name",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.h",
          "lines": "1919-1922",
          "snippet": "static inline const char *get_syscall_name(int syscall)\n{\n\treturn NULL;\n}",
          "includes": [
            "#include \"trace_entries.h\"",
            "#include \"trace_entries.h\"",
            "#include <asm/syscall.h>\t/* some archs define it here */",
            "#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */",
            "#include \"pid_list.h\"",
            "#include <linux/once_lite.h>",
            "#include <linux/ctype.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/glob.h>",
            "#include <linux/compiler.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/mmiotrace.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_entries.h\"\n#include \"trace_entries.h\"\n#include <asm/syscall.h>\t/* some archs define it here */\n#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */\n#include \"pid_list.h\"\n#include <linux/once_lite.h>\n#include <linux/ctype.h>\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/glob.h>\n#include <linux/compiler.h>\n#include <linux/trace_events.h>\n#include <linux/trace_seq.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <linux/mmiotrace.h>\n#include <linux/ring_buffer.h>\n#include <linux/clocksource.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n#include <linux/fs.h>\n\nstatic inline const char *get_syscall_name(int syscall)\n{\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!elt_data"
          ],
          "line": 5118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hist_field_name",
          "args": [
            "key_field",
            "0"
          ],
          "line": 5101
        },
        "resolved": true,
        "details": {
          "function_name": "hist_field_name",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "1280-1316",
          "snippet": "static const char *hist_field_name(struct hist_field *field,\n\t\t\t\t   unsigned int level)\n{\n\tconst char *field_name = \"\";\n\n\tif (level > 1)\n\t\treturn field_name;\n\n\tif (field->field)\n\t\tfield_name = field->field->name;\n\telse if (field->flags & HIST_FIELD_FL_LOG2 ||\n\t\t field->flags & HIST_FIELD_FL_ALIAS ||\n\t\t field->flags & HIST_FIELD_FL_BUCKET)\n\t\tfield_name = hist_field_name(field->operands[0], ++level);\n\telse if (field->flags & HIST_FIELD_FL_CPU)\n\t\tfield_name = \"common_cpu\";\n\telse if (field->flags & HIST_FIELD_FL_EXPR ||\n\t\t field->flags & HIST_FIELD_FL_VAR_REF) {\n\t\tif (field->system) {\n\t\t\tstatic char full_name[MAX_FILTER_STR_VAL];\n\n\t\t\tstrcat(full_name, field->system);\n\t\t\tstrcat(full_name, \".\");\n\t\t\tstrcat(full_name, field->event_name);\n\t\t\tstrcat(full_name, \".\");\n\t\t\tstrcat(full_name, field->name);\n\t\t\tfield_name = full_name;\n\t\t} else\n\t\t\tfield_name = field->name;\n\t} else if (field->flags & HIST_FIELD_FL_TIMESTAMP)\n\t\tfield_name = \"common_timestamp\";\n\n\tif (field_name == NULL)\n\t\tfield_name = \"\";\n\n\treturn field_name;\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic const char *hist_field_name(struct hist_field *field,\n\t\t\t\t   unsigned int level)\n{\n\tconst char *field_name = \"\";\n\n\tif (level > 1)\n\t\treturn field_name;\n\n\tif (field->field)\n\t\tfield_name = field->field->name;\n\telse if (field->flags & HIST_FIELD_FL_LOG2 ||\n\t\t field->flags & HIST_FIELD_FL_ALIAS ||\n\t\t field->flags & HIST_FIELD_FL_BUCKET)\n\t\tfield_name = hist_field_name(field->operands[0], ++level);\n\telse if (field->flags & HIST_FIELD_FL_CPU)\n\t\tfield_name = \"common_cpu\";\n\telse if (field->flags & HIST_FIELD_FL_EXPR ||\n\t\t field->flags & HIST_FIELD_FL_VAR_REF) {\n\t\tif (field->system) {\n\t\t\tstatic char full_name[MAX_FILTER_STR_VAL];\n\n\t\t\tstrcat(full_name, field->system);\n\t\t\tstrcat(full_name, \".\");\n\t\t\tstrcat(full_name, field->event_name);\n\t\t\tstrcat(full_name, \".\");\n\t\t\tstrcat(full_name, field->name);\n\t\t\tfield_name = full_name;\n\t\t} else\n\t\t\tfield_name = field->name;\n\t} else if (field->flags & HIST_FIELD_FL_TIMESTAMP)\n\t\tfield_name = \"common_timestamp\";\n\n\tif (field_name == NULL)\n\t\tfield_name = \"\";\n\n\treturn field_name;\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_hist_key_field",
          "args": [
            "i",
            "hist_data"
          ],
          "line": 5095
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\n#define HIST_STACKTRACE_DEPTH\t16\n\nstatic void hist_trigger_print_key(struct seq_file *m,\n\t\t\t\t   struct hist_trigger_data *hist_data,\n\t\t\t\t   void *key,\n\t\t\t\t   struct tracing_map_elt *elt)\n{\n\tstruct hist_field *key_field;\n\tbool multiline = false;\n\tconst char *field_name;\n\tunsigned int i;\n\tu64 uval;\n\n\tseq_puts(m, \"{ \");\n\n\tfor_each_hist_key_field(i, hist_data) {\n\t\tkey_field = hist_data->fields[i];\n\n\t\tif (i > hist_data->n_vals)\n\t\t\tseq_puts(m, \", \");\n\n\t\tfield_name = hist_field_name(key_field, 0);\n\n\t\tif (key_field->flags & HIST_FIELD_FL_HEX) {\n\t\t\tuval = *(u64 *)(key + key_field->offset);\n\t\t\tseq_printf(m, \"%s: %llx\", field_name, uval);\n\t\t} else if (key_field->flags & HIST_FIELD_FL_SYM) {\n\t\t\tuval = *(u64 *)(key + key_field->offset);\n\t\t\tseq_printf(m, \"%s: [%llx] %-45ps\", field_name,\n\t\t\t\t   uval, (void *)(uintptr_t)uval);\n\t\t} else if (key_field->flags & HIST_FIELD_FL_SYM_OFFSET) {\n\t\t\tuval = *(u64 *)(key + key_field->offset);\n\t\t\tseq_printf(m, \"%s: [%llx] %-55pS\", field_name,\n\t\t\t\t   uval, (void *)(uintptr_t)uval);\n\t\t} else if (key_field->flags & HIST_FIELD_FL_EXECNAME) {\n\t\t\tstruct hist_elt_data *elt_data = elt->private_data;\n\t\t\tchar *comm;\n\n\t\t\tif (WARN_ON_ONCE(!elt_data))\n\t\t\t\treturn;\n\n\t\t\tcomm = elt_data->comm;\n\n\t\t\tuval = *(u64 *)(key + key_field->offset);\n\t\t\tseq_printf(m, \"%s: %-16s[%10llu]\", field_name,\n\t\t\t\t   comm, uval);\n\t\t} else if (key_field->flags & HIST_FIELD_FL_SYSCALL) {\n\t\t\tconst char *syscall_name;\n\n\t\t\tuval = *(u64 *)(key + key_field->offset);\n\t\t\tsyscall_name = get_syscall_name(uval);\n\t\t\tif (!syscall_name)\n\t\t\t\tsyscall_name = \"unknown_syscall\";\n\n\t\t\tseq_printf(m, \"%s: %-30s[%3llu]\", field_name,\n\t\t\t\t   syscall_name, uval);\n\t\t} else if (key_field->flags & HIST_FIELD_FL_STACKTRACE) {\n\t\t\tseq_puts(m, \"stacktrace:\\n\");\n\t\t\thist_trigger_stacktrace_print(m,\n\t\t\t\t\t\t      key + key_field->offset,\n\t\t\t\t\t\t      HIST_STACKTRACE_DEPTH);\n\t\t\tmultiline = true;\n\t\t} else if (key_field->flags & HIST_FIELD_FL_LOG2) {\n\t\t\tseq_printf(m, \"%s: ~ 2^%-2llu\", field_name,\n\t\t\t\t   *(u64 *)(key + key_field->offset));\n\t\t} else if (key_field->flags & HIST_FIELD_FL_BUCKET) {\n\t\t\tunsigned long buckets = key_field->buckets;\n\t\t\tuval = *(u64 *)(key + key_field->offset);\n\t\t\tseq_printf(m, \"%s: ~ %llu-%llu\", field_name,\n\t\t\t\t   uval, uval + buckets -1);\n\t\t} else if (key_field->flags & HIST_FIELD_FL_STRING) {\n\t\t\tseq_printf(m, \"%s: %-50s\", field_name,\n\t\t\t\t   (char *)(key + key_field->offset));\n\t\t} else {\n\t\t\tuval = *(u64 *)(key + key_field->offset);\n\t\t\tseq_printf(m, \"%s: %10llu\", field_name, uval);\n\t\t}\n\t}\n\n\tif (!multiline)\n\t\tseq_puts(m, \" \");\n\n\tseq_puts(m, \"}\");\n}"
  },
  {
    "function_name": "hist_trigger_stacktrace_print",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
    "lines": "5066-5080",
    "snippet": "static void hist_trigger_stacktrace_print(struct seq_file *m,\n\t\t\t\t\t  unsigned long *stacktrace_entries,\n\t\t\t\t\t  unsigned int max_entries)\n{\n\tunsigned int spaces = 8;\n\tunsigned int i;\n\n\tfor (i = 0; i < max_entries; i++) {\n\t\tif (!stacktrace_entries[i])\n\t\t\treturn;\n\n\t\tseq_printf(m, \"%*c\", 1 + spaces, ' ');\n\t\tseq_printf(m, \"%pS\\n\", (void*)stacktrace_entries[i]);\n\t}\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include \"tracing_map.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"%pS\\n\"",
            "(void*)stacktrace_entries[i]"
          ],
          "line": 5078
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "81-100",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void hist_trigger_stacktrace_print(struct seq_file *m,\n\t\t\t\t\t  unsigned long *stacktrace_entries,\n\t\t\t\t\t  unsigned int max_entries)\n{\n\tunsigned int spaces = 8;\n\tunsigned int i;\n\n\tfor (i = 0; i < max_entries; i++) {\n\t\tif (!stacktrace_entries[i])\n\t\t\treturn;\n\n\t\tseq_printf(m, \"%*c\", 1 + spaces, ' ');\n\t\tseq_printf(m, \"%pS\\n\", (void*)stacktrace_entries[i]);\n\t}\n}"
  },
  {
    "function_name": "event_hist_trigger",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
    "lines": "5011-5064",
    "snippet": "static void event_hist_trigger(struct event_trigger_data *data,\n\t\t\t       struct trace_buffer *buffer, void *rec,\n\t\t\t       struct ring_buffer_event *rbe)\n{\n\tstruct hist_trigger_data *hist_data = data->private_data;\n\tbool use_compound_key = (hist_data->n_keys > 1);\n\tunsigned long entries[HIST_STACKTRACE_DEPTH];\n\tu64 var_ref_vals[TRACING_MAP_VARS_MAX];\n\tchar compound_key[HIST_KEY_SIZE_MAX];\n\tstruct tracing_map_elt *elt = NULL;\n\tstruct hist_field *key_field;\n\tu64 field_contents;\n\tvoid *key = NULL;\n\tunsigned int i;\n\n\tmemset(compound_key, 0, hist_data->key_size);\n\n\tfor_each_hist_key_field(i, hist_data) {\n\t\tkey_field = hist_data->fields[i];\n\n\t\tif (key_field->flags & HIST_FIELD_FL_STACKTRACE) {\n\t\t\tmemset(entries, 0, HIST_STACKTRACE_SIZE);\n\t\t\tstack_trace_save(entries, HIST_STACKTRACE_DEPTH,\n\t\t\t\t\t HIST_STACKTRACE_SKIP);\n\t\t\tkey = entries;\n\t\t} else {\n\t\t\tfield_contents = key_field->fn(key_field, elt, buffer, rbe, rec);\n\t\t\tif (key_field->flags & HIST_FIELD_FL_STRING) {\n\t\t\t\tkey = (void *)(unsigned long)field_contents;\n\t\t\t\tuse_compound_key = true;\n\t\t\t} else\n\t\t\t\tkey = (void *)&field_contents;\n\t\t}\n\n\t\tif (use_compound_key)\n\t\t\tadd_to_key(compound_key, key, key_field, rec);\n\t}\n\n\tif (use_compound_key)\n\t\tkey = compound_key;\n\n\tif (hist_data->n_var_refs &&\n\t    !resolve_var_refs(hist_data, key, var_ref_vals, false))\n\t\treturn;\n\n\telt = tracing_map_insert(hist_data->map, key);\n\tif (!elt)\n\t\treturn;\n\n\thist_trigger_elt_update(hist_data, elt, buffer, rec, rbe, var_ref_vals);\n\n\tif (resolve_var_refs(hist_data, key, var_ref_vals, true))\n\t\thist_trigger_actions(hist_data, elt, buffer, rec, rbe, key, var_ref_vals);\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include \"tracing_map.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define HIST_KEY_SIZE_MAX\t(MAX_FILTER_STR_VAL + HIST_STACKTRACE_SIZE)",
      "#define HIST_STACKTRACE_SKIP\t5",
      "#define HIST_STACKTRACE_SIZE\t(HIST_STACKTRACE_DEPTH * sizeof(unsigned long))",
      "#define HIST_STACKTRACE_DEPTH\t16"
    ],
    "globals_used": [
      "static int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "hist_trigger_actions",
          "args": [
            "hist_data",
            "elt",
            "buffer",
            "rec",
            "rbe",
            "key",
            "var_ref_vals"
          ],
          "line": 5063
        },
        "resolved": true,
        "details": {
          "function_name": "hist_trigger_actions",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "4995-5009",
          "snippet": "static void\nhist_trigger_actions(struct hist_trigger_data *hist_data,\n\t\t     struct tracing_map_elt *elt,\n\t\t     struct trace_buffer *buffer, void *rec,\n\t\t     struct ring_buffer_event *rbe, void *key,\n\t\t     u64 *var_ref_vals)\n{\n\tstruct action_data *data;\n\tunsigned int i;\n\n\tfor (i = 0; i < hist_data->n_actions; i++) {\n\t\tdata = hist_data->actions[i];\n\t\tdata->fn(hist_data, elt, buffer, rec, rbe, key, data, var_ref_vals);\n\t}\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);\n\nstatic void\nhist_trigger_actions(struct hist_trigger_data *hist_data,\n\t\t     struct tracing_map_elt *elt,\n\t\t     struct trace_buffer *buffer, void *rec,\n\t\t     struct ring_buffer_event *rbe, void *key,\n\t\t     u64 *var_ref_vals)\n{\n\tstruct action_data *data;\n\tunsigned int i;\n\n\tfor (i = 0; i < hist_data->n_actions; i++) {\n\t\tdata = hist_data->actions[i];\n\t\tdata->fn(hist_data, elt, buffer, rec, rbe, key, data, var_ref_vals);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "resolve_var_refs",
          "args": [
            "hist_data",
            "key",
            "var_ref_vals",
            "true"
          ],
          "line": 5062
        },
        "resolved": true,
        "details": {
          "function_name": "resolve_var_refs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "1234-1278",
          "snippet": "static bool resolve_var_refs(struct hist_trigger_data *hist_data, void *key,\n\t\t\t     u64 *var_ref_vals, bool self)\n{\n\tstruct hist_trigger_data *var_data;\n\tstruct tracing_map_elt *var_elt;\n\tstruct hist_field *hist_field;\n\tunsigned int i, var_idx;\n\tbool resolved = true;\n\tu64 var_val = 0;\n\n\tfor (i = 0; i < hist_data->n_var_refs; i++) {\n\t\thist_field = hist_data->var_refs[i];\n\t\tvar_idx = hist_field->var.idx;\n\t\tvar_data = hist_field->var.hist_data;\n\n\t\tif (var_data == NULL) {\n\t\t\tresolved = false;\n\t\t\tbreak;\n\t\t}\n\n\t\tif ((self && var_data != hist_data) ||\n\t\t    (!self && var_data == hist_data))\n\t\t\tcontinue;\n\n\t\tvar_elt = tracing_map_lookup(var_data->map, key);\n\t\tif (!var_elt) {\n\t\t\tresolved = false;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!tracing_map_var_set(var_elt, var_idx)) {\n\t\t\tresolved = false;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (self || !hist_field->read_once)\n\t\t\tvar_val = tracing_map_read_var(var_elt, var_idx);\n\t\telse\n\t\t\tvar_val = tracing_map_read_var_once(var_elt, var_idx);\n\n\t\tvar_ref_vals[i] = var_val;\n\t}\n\n\treturn resolved;\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic bool resolve_var_refs(struct hist_trigger_data *hist_data, void *key,\n\t\t\t     u64 *var_ref_vals, bool self)\n{\n\tstruct hist_trigger_data *var_data;\n\tstruct tracing_map_elt *var_elt;\n\tstruct hist_field *hist_field;\n\tunsigned int i, var_idx;\n\tbool resolved = true;\n\tu64 var_val = 0;\n\n\tfor (i = 0; i < hist_data->n_var_refs; i++) {\n\t\thist_field = hist_data->var_refs[i];\n\t\tvar_idx = hist_field->var.idx;\n\t\tvar_data = hist_field->var.hist_data;\n\n\t\tif (var_data == NULL) {\n\t\t\tresolved = false;\n\t\t\tbreak;\n\t\t}\n\n\t\tif ((self && var_data != hist_data) ||\n\t\t    (!self && var_data == hist_data))\n\t\t\tcontinue;\n\n\t\tvar_elt = tracing_map_lookup(var_data->map, key);\n\t\tif (!var_elt) {\n\t\t\tresolved = false;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!tracing_map_var_set(var_elt, var_idx)) {\n\t\t\tresolved = false;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (self || !hist_field->read_once)\n\t\t\tvar_val = tracing_map_read_var(var_elt, var_idx);\n\t\telse\n\t\t\tvar_val = tracing_map_read_var_once(var_elt, var_idx);\n\n\t\tvar_ref_vals[i] = var_val;\n\t}\n\n\treturn resolved;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hist_trigger_elt_update",
          "args": [
            "hist_data",
            "elt",
            "buffer",
            "rec",
            "rbe",
            "var_ref_vals"
          ],
          "line": 5060
        },
        "resolved": true,
        "details": {
          "function_name": "hist_trigger_elt_update",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "4915-4969",
          "snippet": "static void hist_trigger_elt_update(struct hist_trigger_data *hist_data,\n\t\t\t\t    struct tracing_map_elt *elt,\n\t\t\t\t    struct trace_buffer *buffer, void *rec,\n\t\t\t\t    struct ring_buffer_event *rbe,\n\t\t\t\t    u64 *var_ref_vals)\n{\n\tstruct hist_elt_data *elt_data;\n\tstruct hist_field *hist_field;\n\tunsigned int i, var_idx;\n\tu64 hist_val;\n\n\telt_data = elt->private_data;\n\telt_data->var_ref_vals = var_ref_vals;\n\n\tfor_each_hist_val_field(i, hist_data) {\n\t\thist_field = hist_data->fields[i];\n\t\thist_val = hist_field->fn(hist_field, elt, buffer, rbe, rec);\n\t\tif (hist_field->flags & HIST_FIELD_FL_VAR) {\n\t\t\tvar_idx = hist_field->var.idx;\n\n\t\t\tif (hist_field->flags & HIST_FIELD_FL_STRING) {\n\t\t\t\tunsigned int str_start, var_str_idx, idx;\n\t\t\t\tchar *str, *val_str;\n\t\t\t\tunsigned int size;\n\n\t\t\t\tstr_start = hist_data->n_field_var_str +\n\t\t\t\t\thist_data->n_save_var_str;\n\t\t\t\tvar_str_idx = hist_field->var_str_idx;\n\t\t\t\tidx = str_start + var_str_idx;\n\n\t\t\t\tstr = elt_data->field_var_str[idx];\n\t\t\t\tval_str = (char *)(uintptr_t)hist_val;\n\n\t\t\t\tsize = min(hist_field->size, STR_VAR_LEN_MAX);\n\t\t\t\tstrscpy(str, val_str, size);\n\n\t\t\t\thist_val = (u64)(uintptr_t)str;\n\t\t\t}\n\t\t\ttracing_map_set_var(elt, var_idx, hist_val);\n\t\t\tcontinue;\n\t\t}\n\t\ttracing_map_update_sum(elt, i, hist_val);\n\t}\n\n\tfor_each_hist_key_field(i, hist_data) {\n\t\thist_field = hist_data->fields[i];\n\t\tif (hist_field->flags & HIST_FIELD_FL_VAR) {\n\t\t\thist_val = hist_field->fn(hist_field, elt, buffer, rbe, rec);\n\t\t\tvar_idx = hist_field->var.idx;\n\t\t\ttracing_map_set_var(elt, var_idx, hist_val);\n\t\t}\n\t}\n\n\tupdate_field_vars(hist_data, elt, buffer, rbe, rec);\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void hist_trigger_elt_update(struct hist_trigger_data *hist_data,\n\t\t\t\t    struct tracing_map_elt *elt,\n\t\t\t\t    struct trace_buffer *buffer, void *rec,\n\t\t\t\t    struct ring_buffer_event *rbe,\n\t\t\t\t    u64 *var_ref_vals)\n{\n\tstruct hist_elt_data *elt_data;\n\tstruct hist_field *hist_field;\n\tunsigned int i, var_idx;\n\tu64 hist_val;\n\n\telt_data = elt->private_data;\n\telt_data->var_ref_vals = var_ref_vals;\n\n\tfor_each_hist_val_field(i, hist_data) {\n\t\thist_field = hist_data->fields[i];\n\t\thist_val = hist_field->fn(hist_field, elt, buffer, rbe, rec);\n\t\tif (hist_field->flags & HIST_FIELD_FL_VAR) {\n\t\t\tvar_idx = hist_field->var.idx;\n\n\t\t\tif (hist_field->flags & HIST_FIELD_FL_STRING) {\n\t\t\t\tunsigned int str_start, var_str_idx, idx;\n\t\t\t\tchar *str, *val_str;\n\t\t\t\tunsigned int size;\n\n\t\t\t\tstr_start = hist_data->n_field_var_str +\n\t\t\t\t\thist_data->n_save_var_str;\n\t\t\t\tvar_str_idx = hist_field->var_str_idx;\n\t\t\t\tidx = str_start + var_str_idx;\n\n\t\t\t\tstr = elt_data->field_var_str[idx];\n\t\t\t\tval_str = (char *)(uintptr_t)hist_val;\n\n\t\t\t\tsize = min(hist_field->size, STR_VAR_LEN_MAX);\n\t\t\t\tstrscpy(str, val_str, size);\n\n\t\t\t\thist_val = (u64)(uintptr_t)str;\n\t\t\t}\n\t\t\ttracing_map_set_var(elt, var_idx, hist_val);\n\t\t\tcontinue;\n\t\t}\n\t\ttracing_map_update_sum(elt, i, hist_val);\n\t}\n\n\tfor_each_hist_key_field(i, hist_data) {\n\t\thist_field = hist_data->fields[i];\n\t\tif (hist_field->flags & HIST_FIELD_FL_VAR) {\n\t\t\thist_val = hist_field->fn(hist_field, elt, buffer, rbe, rec);\n\t\t\tvar_idx = hist_field->var.idx;\n\t\t\ttracing_map_set_var(elt, var_idx, hist_val);\n\t\t}\n\t}\n\n\tupdate_field_vars(hist_data, elt, buffer, rbe, rec);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracing_map_insert",
          "args": [
            "hist_data->map",
            "key"
          ],
          "line": 5056
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_map_insert",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/tracing_map.c",
          "lines": "634-637",
          "snippet": "struct tracing_map_elt *tracing_map_insert(struct tracing_map *map, void *key)\n{\n\treturn __tracing_map_insert(map, key, false);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/kmemleak.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/jhash.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/kmemleak.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <linux/vmalloc.h>\n\nstruct tracing_map_elt *tracing_map_insert(struct tracing_map *map, void *key)\n{\n\treturn __tracing_map_insert(map, key, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "add_to_key",
          "args": [
            "compound_key",
            "key",
            "key_field",
            "rec"
          ],
          "line": 5046
        },
        "resolved": true,
        "details": {
          "function_name": "add_to_key",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "4971-4993",
          "snippet": "static inline void add_to_key(char *compound_key, void *key,\n\t\t\t      struct hist_field *key_field, void *rec)\n{\n\tsize_t size = key_field->size;\n\n\tif (key_field->flags & HIST_FIELD_FL_STRING) {\n\t\tstruct ftrace_event_field *field;\n\n\t\tfield = key_field->field;\n\t\tif (field->filter_type == FILTER_DYN_STRING ||\n\t\t    field->filter_type == FILTER_RDYN_STRING)\n\t\t\tsize = *(u32 *)(rec + field->offset) >> 16;\n\t\telse if (field->filter_type == FILTER_STATIC_STRING)\n\t\t\tsize = field->size;\n\n\t\t/* ensure NULL-termination */\n\t\tif (size > key_field->size - 1)\n\t\t\tsize = key_field->size - 1;\n\n\t\tstrncpy(compound_key + key_field->offset, (char *)key, size);\n\t} else\n\t\tmemcpy(compound_key + key_field->offset, key, size);\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic inline void add_to_key(char *compound_key, void *key,\n\t\t\t      struct hist_field *key_field, void *rec)\n{\n\tsize_t size = key_field->size;\n\n\tif (key_field->flags & HIST_FIELD_FL_STRING) {\n\t\tstruct ftrace_event_field *field;\n\n\t\tfield = key_field->field;\n\t\tif (field->filter_type == FILTER_DYN_STRING ||\n\t\t    field->filter_type == FILTER_RDYN_STRING)\n\t\t\tsize = *(u32 *)(rec + field->offset) >> 16;\n\t\telse if (field->filter_type == FILTER_STATIC_STRING)\n\t\t\tsize = field->size;\n\n\t\t/* ensure NULL-termination */\n\t\tif (size > key_field->size - 1)\n\t\t\tsize = key_field->size - 1;\n\n\t\tstrncpy(compound_key + key_field->offset, (char *)key, size);\n\t} else\n\t\tmemcpy(compound_key + key_field->offset, key, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "key_field->fn",
          "args": [
            "key_field",
            "elt",
            "buffer",
            "rbe",
            "rec"
          ],
          "line": 5037
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stack_trace_save",
          "args": [
            "entries",
            "HIST_STACKTRACE_DEPTH",
            "HIST_STACKTRACE_SKIP"
          ],
          "line": 5033
        },
        "resolved": true,
        "details": {
          "function_name": "stack_trace_save_tsk_reliable",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/stacktrace.c",
          "lines": "343-353",
          "snippet": "int stack_trace_save_tsk_reliable(struct task_struct *tsk, unsigned long *store,\n\t\t\t\t  unsigned int size)\n{\n\tstruct stack_trace trace = {\n\t\t.entries\t= store,\n\t\t.max_entries\t= size,\n\t};\n\tint ret = save_stack_trace_tsk_reliable(tsk, &trace);\n\n\treturn ret ? ret : trace.nr_entries;\n}",
          "includes": [
            "#include <linux/interrupt.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/task_stack.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/interrupt.h>\n#include <linux/stacktrace.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/task_stack.h>\n\nint stack_trace_save_tsk_reliable(struct task_struct *tsk, unsigned long *store,\n\t\t\t\t  unsigned int size)\n{\n\tstruct stack_trace trace = {\n\t\t.entries\t= store,\n\t\t.max_entries\t= size,\n\t};\n\tint ret = save_stack_trace_tsk_reliable(tsk, &trace);\n\n\treturn ret ? ret : trace.nr_entries;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "entries",
            "0",
            "HIST_STACKTRACE_SIZE"
          ],
          "line": 5032
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_hist_key_field",
          "args": [
            "i",
            "hist_data"
          ],
          "line": 5028
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "compound_key",
            "0",
            "hist_data->key_size"
          ],
          "line": 5026
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\n#define HIST_KEY_SIZE_MAX\t(MAX_FILTER_STR_VAL + HIST_STACKTRACE_SIZE)\n#define HIST_STACKTRACE_SKIP\t5\n#define HIST_STACKTRACE_SIZE\t(HIST_STACKTRACE_DEPTH * sizeof(unsigned long))\n#define HIST_STACKTRACE_DEPTH\t16\n\nstatic int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);\n\nstatic void event_hist_trigger(struct event_trigger_data *data,\n\t\t\t       struct trace_buffer *buffer, void *rec,\n\t\t\t       struct ring_buffer_event *rbe)\n{\n\tstruct hist_trigger_data *hist_data = data->private_data;\n\tbool use_compound_key = (hist_data->n_keys > 1);\n\tunsigned long entries[HIST_STACKTRACE_DEPTH];\n\tu64 var_ref_vals[TRACING_MAP_VARS_MAX];\n\tchar compound_key[HIST_KEY_SIZE_MAX];\n\tstruct tracing_map_elt *elt = NULL;\n\tstruct hist_field *key_field;\n\tu64 field_contents;\n\tvoid *key = NULL;\n\tunsigned int i;\n\n\tmemset(compound_key, 0, hist_data->key_size);\n\n\tfor_each_hist_key_field(i, hist_data) {\n\t\tkey_field = hist_data->fields[i];\n\n\t\tif (key_field->flags & HIST_FIELD_FL_STACKTRACE) {\n\t\t\tmemset(entries, 0, HIST_STACKTRACE_SIZE);\n\t\t\tstack_trace_save(entries, HIST_STACKTRACE_DEPTH,\n\t\t\t\t\t HIST_STACKTRACE_SKIP);\n\t\t\tkey = entries;\n\t\t} else {\n\t\t\tfield_contents = key_field->fn(key_field, elt, buffer, rbe, rec);\n\t\t\tif (key_field->flags & HIST_FIELD_FL_STRING) {\n\t\t\t\tkey = (void *)(unsigned long)field_contents;\n\t\t\t\tuse_compound_key = true;\n\t\t\t} else\n\t\t\t\tkey = (void *)&field_contents;\n\t\t}\n\n\t\tif (use_compound_key)\n\t\t\tadd_to_key(compound_key, key, key_field, rec);\n\t}\n\n\tif (use_compound_key)\n\t\tkey = compound_key;\n\n\tif (hist_data->n_var_refs &&\n\t    !resolve_var_refs(hist_data, key, var_ref_vals, false))\n\t\treturn;\n\n\telt = tracing_map_insert(hist_data->map, key);\n\tif (!elt)\n\t\treturn;\n\n\thist_trigger_elt_update(hist_data, elt, buffer, rec, rbe, var_ref_vals);\n\n\tif (resolve_var_refs(hist_data, key, var_ref_vals, true))\n\t\thist_trigger_actions(hist_data, elt, buffer, rec, rbe, key, var_ref_vals);\n}"
  },
  {
    "function_name": "hist_trigger_actions",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
    "lines": "4995-5009",
    "snippet": "static void\nhist_trigger_actions(struct hist_trigger_data *hist_data,\n\t\t     struct tracing_map_elt *elt,\n\t\t     struct trace_buffer *buffer, void *rec,\n\t\t     struct ring_buffer_event *rbe, void *key,\n\t\t     u64 *var_ref_vals)\n{\n\tstruct action_data *data;\n\tunsigned int i;\n\n\tfor (i = 0; i < hist_data->n_actions; i++) {\n\t\tdata = hist_data->actions[i];\n\t\tdata->fn(hist_data, elt, buffer, rec, rbe, key, data, var_ref_vals);\n\t}\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include \"tracing_map.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "data->fn",
          "args": [
            "hist_data",
            "elt",
            "buffer",
            "rec",
            "rbe",
            "key",
            "data",
            "var_ref_vals"
          ],
          "line": 5007
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);\n\nstatic void\nhist_trigger_actions(struct hist_trigger_data *hist_data,\n\t\t     struct tracing_map_elt *elt,\n\t\t     struct trace_buffer *buffer, void *rec,\n\t\t     struct ring_buffer_event *rbe, void *key,\n\t\t     u64 *var_ref_vals)\n{\n\tstruct action_data *data;\n\tunsigned int i;\n\n\tfor (i = 0; i < hist_data->n_actions; i++) {\n\t\tdata = hist_data->actions[i];\n\t\tdata->fn(hist_data, elt, buffer, rec, rbe, key, data, var_ref_vals);\n\t}\n}"
  },
  {
    "function_name": "add_to_key",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
    "lines": "4971-4993",
    "snippet": "static inline void add_to_key(char *compound_key, void *key,\n\t\t\t      struct hist_field *key_field, void *rec)\n{\n\tsize_t size = key_field->size;\n\n\tif (key_field->flags & HIST_FIELD_FL_STRING) {\n\t\tstruct ftrace_event_field *field;\n\n\t\tfield = key_field->field;\n\t\tif (field->filter_type == FILTER_DYN_STRING ||\n\t\t    field->filter_type == FILTER_RDYN_STRING)\n\t\t\tsize = *(u32 *)(rec + field->offset) >> 16;\n\t\telse if (field->filter_type == FILTER_STATIC_STRING)\n\t\t\tsize = field->size;\n\n\t\t/* ensure NULL-termination */\n\t\tif (size > key_field->size - 1)\n\t\t\tsize = key_field->size - 1;\n\n\t\tstrncpy(compound_key + key_field->offset, (char *)key, size);\n\t} else\n\t\tmemcpy(compound_key + key_field->offset, key, size);\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include \"tracing_map.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "compound_key + key_field->offset",
            "key",
            "size"
          ],
          "line": 4992
        },
        "resolved": true,
        "details": {
          "function_name": "memcpy_skip",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/internal.h",
          "lines": "180-184",
          "snippet": "static inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/refcount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/refcount.h>\n#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n\nstatic inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "compound_key + key_field->offset",
            "(char *)key",
            "size"
          ],
          "line": 4990
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic inline void add_to_key(char *compound_key, void *key,\n\t\t\t      struct hist_field *key_field, void *rec)\n{\n\tsize_t size = key_field->size;\n\n\tif (key_field->flags & HIST_FIELD_FL_STRING) {\n\t\tstruct ftrace_event_field *field;\n\n\t\tfield = key_field->field;\n\t\tif (field->filter_type == FILTER_DYN_STRING ||\n\t\t    field->filter_type == FILTER_RDYN_STRING)\n\t\t\tsize = *(u32 *)(rec + field->offset) >> 16;\n\t\telse if (field->filter_type == FILTER_STATIC_STRING)\n\t\t\tsize = field->size;\n\n\t\t/* ensure NULL-termination */\n\t\tif (size > key_field->size - 1)\n\t\t\tsize = key_field->size - 1;\n\n\t\tstrncpy(compound_key + key_field->offset, (char *)key, size);\n\t} else\n\t\tmemcpy(compound_key + key_field->offset, key, size);\n}"
  },
  {
    "function_name": "hist_trigger_elt_update",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
    "lines": "4915-4969",
    "snippet": "static void hist_trigger_elt_update(struct hist_trigger_data *hist_data,\n\t\t\t\t    struct tracing_map_elt *elt,\n\t\t\t\t    struct trace_buffer *buffer, void *rec,\n\t\t\t\t    struct ring_buffer_event *rbe,\n\t\t\t\t    u64 *var_ref_vals)\n{\n\tstruct hist_elt_data *elt_data;\n\tstruct hist_field *hist_field;\n\tunsigned int i, var_idx;\n\tu64 hist_val;\n\n\telt_data = elt->private_data;\n\telt_data->var_ref_vals = var_ref_vals;\n\n\tfor_each_hist_val_field(i, hist_data) {\n\t\thist_field = hist_data->fields[i];\n\t\thist_val = hist_field->fn(hist_field, elt, buffer, rbe, rec);\n\t\tif (hist_field->flags & HIST_FIELD_FL_VAR) {\n\t\t\tvar_idx = hist_field->var.idx;\n\n\t\t\tif (hist_field->flags & HIST_FIELD_FL_STRING) {\n\t\t\t\tunsigned int str_start, var_str_idx, idx;\n\t\t\t\tchar *str, *val_str;\n\t\t\t\tunsigned int size;\n\n\t\t\t\tstr_start = hist_data->n_field_var_str +\n\t\t\t\t\thist_data->n_save_var_str;\n\t\t\t\tvar_str_idx = hist_field->var_str_idx;\n\t\t\t\tidx = str_start + var_str_idx;\n\n\t\t\t\tstr = elt_data->field_var_str[idx];\n\t\t\t\tval_str = (char *)(uintptr_t)hist_val;\n\n\t\t\t\tsize = min(hist_field->size, STR_VAR_LEN_MAX);\n\t\t\t\tstrscpy(str, val_str, size);\n\n\t\t\t\thist_val = (u64)(uintptr_t)str;\n\t\t\t}\n\t\t\ttracing_map_set_var(elt, var_idx, hist_val);\n\t\t\tcontinue;\n\t\t}\n\t\ttracing_map_update_sum(elt, i, hist_val);\n\t}\n\n\tfor_each_hist_key_field(i, hist_data) {\n\t\thist_field = hist_data->fields[i];\n\t\tif (hist_field->flags & HIST_FIELD_FL_VAR) {\n\t\t\thist_val = hist_field->fn(hist_field, elt, buffer, rbe, rec);\n\t\t\tvar_idx = hist_field->var.idx;\n\t\t\ttracing_map_set_var(elt, var_idx, hist_val);\n\t\t}\n\t}\n\n\tupdate_field_vars(hist_data, elt, buffer, rbe, rec);\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include \"tracing_map.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "update_field_vars",
          "args": [
            "hist_data",
            "elt",
            "buffer",
            "rbe",
            "rec"
          ],
          "line": 4968
        },
        "resolved": true,
        "details": {
          "function_name": "update_field_vars",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "3058-3066",
          "snippet": "static void update_field_vars(struct hist_trigger_data *hist_data,\n\t\t\t      struct tracing_map_elt *elt,\n\t\t\t      struct trace_buffer *buffer,\n\t\t\t      struct ring_buffer_event *rbe,\n\t\t\t      void *rec)\n{\n\t__update_field_vars(elt, buffer, rbe, rec, hist_data->field_vars,\n\t\t\t    hist_data->n_field_vars, 0);\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void update_field_vars(struct hist_trigger_data *hist_data,\n\t\t\t      struct tracing_map_elt *elt,\n\t\t\t      struct trace_buffer *buffer,\n\t\t\t      struct ring_buffer_event *rbe,\n\t\t\t      void *rec)\n{\n\t__update_field_vars(elt, buffer, rbe, rec, hist_data->field_vars,\n\t\t\t    hist_data->n_field_vars, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracing_map_set_var",
          "args": [
            "elt",
            "var_idx",
            "hist_val"
          ],
          "line": 4964
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_map_set_var",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/tracing_map.c",
          "lines": "71-75",
          "snippet": "void tracing_map_set_var(struct tracing_map_elt *elt, unsigned int i, u64 n)\n{\n\tatomic64_set(&elt->vars[i], n);\n\telt->var_set[i] = true;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/kmemleak.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/jhash.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/kmemleak.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <linux/vmalloc.h>\n\nvoid tracing_map_set_var(struct tracing_map_elt *elt, unsigned int i, u64 n)\n{\n\tatomic64_set(&elt->vars[i], n);\n\telt->var_set[i] = true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hist_field->fn",
          "args": [
            "hist_field",
            "elt",
            "buffer",
            "rbe",
            "rec"
          ],
          "line": 4962
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_hist_key_field",
          "args": [
            "i",
            "hist_data"
          ],
          "line": 4959
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tracing_map_update_sum",
          "args": [
            "elt",
            "i",
            "hist_val"
          ],
          "line": 4956
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_map_update_sum",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/tracing_map.c",
          "lines": "39-42",
          "snippet": "void tracing_map_update_sum(struct tracing_map_elt *elt, unsigned int i, u64 n)\n{\n\tatomic64_add(n, &elt->fields[i].sum);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/kmemleak.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/jhash.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/kmemleak.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <linux/vmalloc.h>\n\nvoid tracing_map_update_sum(struct tracing_map_elt *elt, unsigned int i, u64 n)\n{\n\tatomic64_add(n, &elt->fields[i].sum);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strscpy",
          "args": [
            "str",
            "val_str",
            "size"
          ],
          "line": 4949
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "hist_field->size",
            "STR_VAR_LEN_MAX"
          ],
          "line": 4948
        },
        "resolved": true,
        "details": {
          "function_name": "stop_critical_timing",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_irqsoff.c",
          "lines": "403-434",
          "snippet": "static nokprobe_inline void\nstop_critical_timing(unsigned long ip, unsigned long parent_ip)\n{\n\tint cpu;\n\tstruct trace_array *tr = irqsoff_trace;\n\tstruct trace_array_cpu *data;\n\tunsigned int trace_ctx;\n\n\tcpu = raw_smp_processor_id();\n\t/* Always clear the tracing cpu on stopping the trace */\n\tif (unlikely(per_cpu(tracing_cpu, cpu)))\n\t\tper_cpu(tracing_cpu, cpu) = 0;\n\telse\n\t\treturn;\n\n\tif (!tracer_enabled || !tracing_is_enabled())\n\t\treturn;\n\n\tdata = per_cpu_ptr(tr->array_buffer.data, cpu);\n\n\tif (unlikely(!data) ||\n\t    !data->critical_start || atomic_read(&data->disabled))\n\t\treturn;\n\n\tatomic_inc(&data->disabled);\n\n\ttrace_ctx = tracing_gen_ctx();\n\t__trace_function(tr, ip, parent_ip, trace_ctx);\n\tcheck_critical_timing(tr, data, parent_ip ? : ip, cpu);\n\tdata->critical_start = 0;\n\tatomic_dec(&data->disabled);\n}",
          "includes": [
            "#include <trace/events/preemptirq.h>",
            "#include \"trace.h\"",
            "#include <linux/kprobes.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [
            "#define __trace_function trace_function"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/preemptirq.h>\n#include \"trace.h\"\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n\n#define __trace_function trace_function\n\nstatic nokprobe_inline void\nstop_critical_timing(unsigned long ip, unsigned long parent_ip)\n{\n\tint cpu;\n\tstruct trace_array *tr = irqsoff_trace;\n\tstruct trace_array_cpu *data;\n\tunsigned int trace_ctx;\n\n\tcpu = raw_smp_processor_id();\n\t/* Always clear the tracing cpu on stopping the trace */\n\tif (unlikely(per_cpu(tracing_cpu, cpu)))\n\t\tper_cpu(tracing_cpu, cpu) = 0;\n\telse\n\t\treturn;\n\n\tif (!tracer_enabled || !tracing_is_enabled())\n\t\treturn;\n\n\tdata = per_cpu_ptr(tr->array_buffer.data, cpu);\n\n\tif (unlikely(!data) ||\n\t    !data->critical_start || atomic_read(&data->disabled))\n\t\treturn;\n\n\tatomic_inc(&data->disabled);\n\n\ttrace_ctx = tracing_gen_ctx();\n\t__trace_function(tr, ip, parent_ip, trace_ctx);\n\tcheck_critical_timing(tr, data, parent_ip ? : ip, cpu);\n\tdata->critical_start = 0;\n\tatomic_dec(&data->disabled);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hist_field->fn",
          "args": [
            "hist_field",
            "elt",
            "buffer",
            "rbe",
            "rec"
          ],
          "line": 4931
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_hist_val_field",
          "args": [
            "i",
            "hist_data"
          ],
          "line": 4929
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void hist_trigger_elt_update(struct hist_trigger_data *hist_data,\n\t\t\t\t    struct tracing_map_elt *elt,\n\t\t\t\t    struct trace_buffer *buffer, void *rec,\n\t\t\t\t    struct ring_buffer_event *rbe,\n\t\t\t\t    u64 *var_ref_vals)\n{\n\tstruct hist_elt_data *elt_data;\n\tstruct hist_field *hist_field;\n\tunsigned int i, var_idx;\n\tu64 hist_val;\n\n\telt_data = elt->private_data;\n\telt_data->var_ref_vals = var_ref_vals;\n\n\tfor_each_hist_val_field(i, hist_data) {\n\t\thist_field = hist_data->fields[i];\n\t\thist_val = hist_field->fn(hist_field, elt, buffer, rbe, rec);\n\t\tif (hist_field->flags & HIST_FIELD_FL_VAR) {\n\t\t\tvar_idx = hist_field->var.idx;\n\n\t\t\tif (hist_field->flags & HIST_FIELD_FL_STRING) {\n\t\t\t\tunsigned int str_start, var_str_idx, idx;\n\t\t\t\tchar *str, *val_str;\n\t\t\t\tunsigned int size;\n\n\t\t\t\tstr_start = hist_data->n_field_var_str +\n\t\t\t\t\thist_data->n_save_var_str;\n\t\t\t\tvar_str_idx = hist_field->var_str_idx;\n\t\t\t\tidx = str_start + var_str_idx;\n\n\t\t\t\tstr = elt_data->field_var_str[idx];\n\t\t\t\tval_str = (char *)(uintptr_t)hist_val;\n\n\t\t\t\tsize = min(hist_field->size, STR_VAR_LEN_MAX);\n\t\t\t\tstrscpy(str, val_str, size);\n\n\t\t\t\thist_val = (u64)(uintptr_t)str;\n\t\t\t}\n\t\t\ttracing_map_set_var(elt, var_idx, hist_val);\n\t\t\tcontinue;\n\t\t}\n\t\ttracing_map_update_sum(elt, i, hist_val);\n\t}\n\n\tfor_each_hist_key_field(i, hist_data) {\n\t\thist_field = hist_data->fields[i];\n\t\tif (hist_field->flags & HIST_FIELD_FL_VAR) {\n\t\t\thist_val = hist_field->fn(hist_field, elt, buffer, rbe, rec);\n\t\t\tvar_idx = hist_field->var.idx;\n\t\t\ttracing_map_set_var(elt, var_idx, hist_val);\n\t\t}\n\t}\n\n\tupdate_field_vars(hist_data, elt, buffer, rbe, rec);\n}"
  },
  {
    "function_name": "create_hist_data",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
    "lines": "4860-4913",
    "snippet": "static struct hist_trigger_data *\ncreate_hist_data(unsigned int map_bits,\n\t\t struct hist_trigger_attrs *attrs,\n\t\t struct trace_event_file *file,\n\t\t bool remove)\n{\n\tconst struct tracing_map_ops *map_ops = NULL;\n\tstruct hist_trigger_data *hist_data;\n\tint ret = 0;\n\n\thist_data = kzalloc(sizeof(*hist_data), GFP_KERNEL);\n\tif (!hist_data)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\thist_data->attrs = attrs;\n\thist_data->remove = remove;\n\thist_data->event_file = file;\n\n\tret = parse_actions(hist_data);\n\tif (ret)\n\t\tgoto free;\n\n\tret = create_hist_fields(hist_data, file);\n\tif (ret)\n\t\tgoto free;\n\n\tret = create_sort_keys(hist_data);\n\tif (ret)\n\t\tgoto free;\n\n\tmap_ops = &hist_trigger_elt_data_ops;\n\n\thist_data->map = tracing_map_create(map_bits, hist_data->key_size,\n\t\t\t\t\t    map_ops, hist_data);\n\tif (IS_ERR(hist_data->map)) {\n\t\tret = PTR_ERR(hist_data->map);\n\t\thist_data->map = NULL;\n\t\tgoto free;\n\t}\n\n\tret = create_tracing_map_fields(hist_data);\n\tif (ret)\n\t\tgoto free;\n out:\n\treturn hist_data;\n free:\n\thist_data->attrs = NULL;\n\n\tdestroy_hist_data(hist_data);\n\n\thist_data = ERR_PTR(ret);\n\n\tgoto out;\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include \"tracing_map.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct tracing_map_ops hist_trigger_elt_data_ops = {\n\t.elt_alloc\t= hist_trigger_elt_data_alloc,\n\t.elt_free\t= hist_trigger_elt_data_free,\n\t.elt_init\t= hist_trigger_elt_data_init,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "ret"
          ],
          "line": 4910
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "destroy_hist_data",
          "args": [
            "hist_data"
          ],
          "line": 4908
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_hist_data",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "4799-4813",
          "snippet": "static void destroy_hist_data(struct hist_trigger_data *hist_data)\n{\n\tif (!hist_data)\n\t\treturn;\n\n\tdestroy_hist_trigger_attrs(hist_data->attrs);\n\tdestroy_hist_fields(hist_data);\n\ttracing_map_destroy(hist_data->map);\n\n\tdestroy_actions(hist_data);\n\tdestroy_field_vars(hist_data);\n\tdestroy_field_var_hists(hist_data);\n\n\tkfree(hist_data);\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void destroy_hist_data(struct hist_trigger_data *hist_data)\n{\n\tif (!hist_data)\n\t\treturn;\n\n\tdestroy_hist_trigger_attrs(hist_data->attrs);\n\tdestroy_hist_fields(hist_data);\n\ttracing_map_destroy(hist_data->map);\n\n\tdestroy_actions(hist_data);\n\tdestroy_field_vars(hist_data);\n\tdestroy_field_var_hists(hist_data);\n\n\tkfree(hist_data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "create_tracing_map_fields",
          "args": [
            "hist_data"
          ],
          "line": 4900
        },
        "resolved": true,
        "details": {
          "function_name": "create_tracing_map_fields",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "4815-4858",
          "snippet": "static int create_tracing_map_fields(struct hist_trigger_data *hist_data)\n{\n\tstruct tracing_map *map = hist_data->map;\n\tstruct ftrace_event_field *field;\n\tstruct hist_field *hist_field;\n\tint i, idx = 0;\n\n\tfor_each_hist_field(i, hist_data) {\n\t\thist_field = hist_data->fields[i];\n\t\tif (hist_field->flags & HIST_FIELD_FL_KEY) {\n\t\t\ttracing_map_cmp_fn_t cmp_fn;\n\n\t\t\tfield = hist_field->field;\n\n\t\t\tif (hist_field->flags & HIST_FIELD_FL_STACKTRACE)\n\t\t\t\tcmp_fn = tracing_map_cmp_none;\n\t\t\telse if (!field)\n\t\t\t\tcmp_fn = tracing_map_cmp_num(hist_field->size,\n\t\t\t\t\t\t\t     hist_field->is_signed);\n\t\t\telse if (is_string_field(field))\n\t\t\t\tcmp_fn = tracing_map_cmp_string;\n\t\t\telse\n\t\t\t\tcmp_fn = tracing_map_cmp_num(field->size,\n\t\t\t\t\t\t\t     field->is_signed);\n\t\t\tidx = tracing_map_add_key_field(map,\n\t\t\t\t\t\t\thist_field->offset,\n\t\t\t\t\t\t\tcmp_fn);\n\t\t} else if (!(hist_field->flags & HIST_FIELD_FL_VAR))\n\t\t\tidx = tracing_map_add_sum_field(map);\n\n\t\tif (idx < 0)\n\t\t\treturn idx;\n\n\t\tif (hist_field->flags & HIST_FIELD_FL_VAR) {\n\t\t\tidx = tracing_map_add_var(map);\n\t\t\tif (idx < 0)\n\t\t\t\treturn idx;\n\t\t\thist_field->var.idx = idx;\n\t\t\thist_field->var.hist_data = hist_data;\n\t\t}\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int create_tracing_map_fields(struct hist_trigger_data *hist_data)\n{\n\tstruct tracing_map *map = hist_data->map;\n\tstruct ftrace_event_field *field;\n\tstruct hist_field *hist_field;\n\tint i, idx = 0;\n\n\tfor_each_hist_field(i, hist_data) {\n\t\thist_field = hist_data->fields[i];\n\t\tif (hist_field->flags & HIST_FIELD_FL_KEY) {\n\t\t\ttracing_map_cmp_fn_t cmp_fn;\n\n\t\t\tfield = hist_field->field;\n\n\t\t\tif (hist_field->flags & HIST_FIELD_FL_STACKTRACE)\n\t\t\t\tcmp_fn = tracing_map_cmp_none;\n\t\t\telse if (!field)\n\t\t\t\tcmp_fn = tracing_map_cmp_num(hist_field->size,\n\t\t\t\t\t\t\t     hist_field->is_signed);\n\t\t\telse if (is_string_field(field))\n\t\t\t\tcmp_fn = tracing_map_cmp_string;\n\t\t\telse\n\t\t\t\tcmp_fn = tracing_map_cmp_num(field->size,\n\t\t\t\t\t\t\t     field->is_signed);\n\t\t\tidx = tracing_map_add_key_field(map,\n\t\t\t\t\t\t\thist_field->offset,\n\t\t\t\t\t\t\tcmp_fn);\n\t\t} else if (!(hist_field->flags & HIST_FIELD_FL_VAR))\n\t\t\tidx = tracing_map_add_sum_field(map);\n\n\t\tif (idx < 0)\n\t\t\treturn idx;\n\n\t\tif (hist_field->flags & HIST_FIELD_FL_VAR) {\n\t\t\tidx = tracing_map_add_var(map);\n\t\t\tif (idx < 0)\n\t\t\t\treturn idx;\n\t\t\thist_field->var.idx = idx;\n\t\t\thist_field->var.hist_data = hist_data;\n\t\t}\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "hist_data->map"
          ],
          "line": 4895
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "hist_data->map"
          ],
          "line": 4894
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tracing_map_create",
          "args": [
            "map_bits",
            "hist_data->key_size",
            "map_ops",
            "hist_data"
          ],
          "line": 4892
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_map_create",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/tracing_map.c",
          "lines": "763-803",
          "snippet": "struct tracing_map *tracing_map_create(unsigned int map_bits,\n\t\t\t\t       unsigned int key_size,\n\t\t\t\t       const struct tracing_map_ops *ops,\n\t\t\t\t       void *private_data)\n{\n\tstruct tracing_map *map;\n\tunsigned int i;\n\n\tif (map_bits < TRACING_MAP_BITS_MIN ||\n\t    map_bits > TRACING_MAP_BITS_MAX)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tmap = kzalloc(sizeof(*map), GFP_KERNEL);\n\tif (!map)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmap->map_bits = map_bits;\n\tmap->max_elts = (1 << map_bits);\n\tatomic_set(&map->next_elt, -1);\n\n\tmap->map_size = (1 << (map_bits + 1));\n\tmap->ops = ops;\n\n\tmap->private_data = private_data;\n\n\tmap->map = tracing_map_array_alloc(map->map_size,\n\t\t\t\t\t   sizeof(struct tracing_map_entry));\n\tif (!map->map)\n\t\tgoto free;\n\n\tmap->key_size = key_size;\n\tfor (i = 0; i < TRACING_MAP_KEYS_MAX; i++)\n\t\tmap->key_idx[i] = -1;\n out:\n\treturn map;\n free:\n\ttracing_map_destroy(map);\n\tmap = ERR_PTR(-ENOMEM);\n\n\tgoto out;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/kmemleak.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/jhash.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/kmemleak.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <linux/vmalloc.h>\n\nstruct tracing_map *tracing_map_create(unsigned int map_bits,\n\t\t\t\t       unsigned int key_size,\n\t\t\t\t       const struct tracing_map_ops *ops,\n\t\t\t\t       void *private_data)\n{\n\tstruct tracing_map *map;\n\tunsigned int i;\n\n\tif (map_bits < TRACING_MAP_BITS_MIN ||\n\t    map_bits > TRACING_MAP_BITS_MAX)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tmap = kzalloc(sizeof(*map), GFP_KERNEL);\n\tif (!map)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmap->map_bits = map_bits;\n\tmap->max_elts = (1 << map_bits);\n\tatomic_set(&map->next_elt, -1);\n\n\tmap->map_size = (1 << (map_bits + 1));\n\tmap->ops = ops;\n\n\tmap->private_data = private_data;\n\n\tmap->map = tracing_map_array_alloc(map->map_size,\n\t\t\t\t\t   sizeof(struct tracing_map_entry));\n\tif (!map->map)\n\t\tgoto free;\n\n\tmap->key_size = key_size;\n\tfor (i = 0; i < TRACING_MAP_KEYS_MAX; i++)\n\t\tmap->key_idx[i] = -1;\n out:\n\treturn map;\n free:\n\ttracing_map_destroy(map);\n\tmap = ERR_PTR(-ENOMEM);\n\n\tgoto out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "create_sort_keys",
          "args": [
            "hist_data"
          ],
          "line": 4886
        },
        "resolved": true,
        "details": {
          "function_name": "create_sort_keys",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "4464-4549",
          "snippet": "static int create_sort_keys(struct hist_trigger_data *hist_data)\n{\n\tstruct trace_array *tr = hist_data->event_file->tr;\n\tchar *fields_str = hist_data->attrs->sort_key_str;\n\tstruct tracing_map_sort_key *sort_key;\n\tint descending, ret = 0;\n\tunsigned int i, j, k;\n\n\thist_data->n_sort_keys = 1; /* we always have at least one, hitcount */\n\n\tif (!fields_str)\n\t\tgoto out;\n\n\tfor (i = 0; i < TRACING_MAP_SORT_KEYS_MAX; i++) {\n\t\tstruct hist_field *hist_field;\n\t\tchar *field_str, *field_name;\n\t\tconst char *test_name;\n\n\t\tsort_key = &hist_data->sort_keys[i];\n\n\t\tfield_str = strsep(&fields_str, \",\");\n\t\tif (!field_str)\n\t\t\tbreak;\n\n\t\tif (!*field_str) {\n\t\t\tret = -EINVAL;\n\t\t\thist_err(tr, HIST_ERR_EMPTY_SORT_FIELD, errpos(\"sort=\"));\n\t\t\tbreak;\n\t\t}\n\n\t\tif ((i == TRACING_MAP_SORT_KEYS_MAX - 1) && fields_str) {\n\t\t\thist_err(tr, HIST_ERR_TOO_MANY_SORT_FIELDS, errpos(\"sort=\"));\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tfield_name = strsep(&field_str, \".\");\n\t\tif (!field_name || !*field_name) {\n\t\t\tret = -EINVAL;\n\t\t\thist_err(tr, HIST_ERR_EMPTY_SORT_FIELD, errpos(\"sort=\"));\n\t\t\tbreak;\n\t\t}\n\n\t\tif (strcmp(field_name, \"hitcount\") == 0) {\n\t\t\tdescending = is_descending(tr, field_str);\n\t\t\tif (descending < 0) {\n\t\t\t\tret = descending;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsort_key->descending = descending;\n\t\t\tcontinue;\n\t\t}\n\n\t\tfor (j = 1, k = 1; j < hist_data->n_fields; j++) {\n\t\t\tunsigned int idx;\n\n\t\t\thist_field = hist_data->fields[j];\n\t\t\tif (hist_field->flags & HIST_FIELD_FL_VAR)\n\t\t\t\tcontinue;\n\n\t\t\tidx = k++;\n\n\t\t\ttest_name = hist_field_name(hist_field, 0);\n\n\t\t\tif (strcmp(field_name, test_name) == 0) {\n\t\t\t\tsort_key->field_idx = idx;\n\t\t\t\tdescending = is_descending(tr, field_str);\n\t\t\t\tif (descending < 0) {\n\t\t\t\t\tret = descending;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tsort_key->descending = descending;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (j == hist_data->n_fields) {\n\t\t\tret = -EINVAL;\n\t\t\thist_err(tr, HIST_ERR_INVALID_SORT_FIELD, errpos(field_name));\n\t\t\tbreak;\n\t\t}\n\t}\n\n\thist_data->n_sort_keys = i;\n out:\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int create_sort_keys(struct hist_trigger_data *hist_data)\n{\n\tstruct trace_array *tr = hist_data->event_file->tr;\n\tchar *fields_str = hist_data->attrs->sort_key_str;\n\tstruct tracing_map_sort_key *sort_key;\n\tint descending, ret = 0;\n\tunsigned int i, j, k;\n\n\thist_data->n_sort_keys = 1; /* we always have at least one, hitcount */\n\n\tif (!fields_str)\n\t\tgoto out;\n\n\tfor (i = 0; i < TRACING_MAP_SORT_KEYS_MAX; i++) {\n\t\tstruct hist_field *hist_field;\n\t\tchar *field_str, *field_name;\n\t\tconst char *test_name;\n\n\t\tsort_key = &hist_data->sort_keys[i];\n\n\t\tfield_str = strsep(&fields_str, \",\");\n\t\tif (!field_str)\n\t\t\tbreak;\n\n\t\tif (!*field_str) {\n\t\t\tret = -EINVAL;\n\t\t\thist_err(tr, HIST_ERR_EMPTY_SORT_FIELD, errpos(\"sort=\"));\n\t\t\tbreak;\n\t\t}\n\n\t\tif ((i == TRACING_MAP_SORT_KEYS_MAX - 1) && fields_str) {\n\t\t\thist_err(tr, HIST_ERR_TOO_MANY_SORT_FIELDS, errpos(\"sort=\"));\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tfield_name = strsep(&field_str, \".\");\n\t\tif (!field_name || !*field_name) {\n\t\t\tret = -EINVAL;\n\t\t\thist_err(tr, HIST_ERR_EMPTY_SORT_FIELD, errpos(\"sort=\"));\n\t\t\tbreak;\n\t\t}\n\n\t\tif (strcmp(field_name, \"hitcount\") == 0) {\n\t\t\tdescending = is_descending(tr, field_str);\n\t\t\tif (descending < 0) {\n\t\t\t\tret = descending;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsort_key->descending = descending;\n\t\t\tcontinue;\n\t\t}\n\n\t\tfor (j = 1, k = 1; j < hist_data->n_fields; j++) {\n\t\t\tunsigned int idx;\n\n\t\t\thist_field = hist_data->fields[j];\n\t\t\tif (hist_field->flags & HIST_FIELD_FL_VAR)\n\t\t\t\tcontinue;\n\n\t\t\tidx = k++;\n\n\t\t\ttest_name = hist_field_name(hist_field, 0);\n\n\t\t\tif (strcmp(field_name, test_name) == 0) {\n\t\t\t\tsort_key->field_idx = idx;\n\t\t\t\tdescending = is_descending(tr, field_str);\n\t\t\t\tif (descending < 0) {\n\t\t\t\t\tret = descending;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tsort_key->descending = descending;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (j == hist_data->n_fields) {\n\t\t\tret = -EINVAL;\n\t\t\thist_err(tr, HIST_ERR_INVALID_SORT_FIELD, errpos(field_name));\n\t\t\tbreak;\n\t\t}\n\t}\n\n\thist_data->n_sort_keys = i;\n out:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "create_hist_fields",
          "args": [
            "hist_data",
            "file"
          ],
          "line": 4882
        },
        "resolved": true,
        "details": {
          "function_name": "create_hist_fields",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "4422-4446",
          "snippet": "static int create_hist_fields(struct hist_trigger_data *hist_data,\n\t\t\t      struct trace_event_file *file)\n{\n\tint ret;\n\n\tret = parse_var_defs(hist_data);\n\tif (ret)\n\t\tgoto out;\n\n\tret = create_val_fields(hist_data, file);\n\tif (ret)\n\t\tgoto out;\n\n\tret = create_var_fields(hist_data, file);\n\tif (ret)\n\t\tgoto out;\n\n\tret = create_key_fields(hist_data, file);\n\tif (ret)\n\t\tgoto out;\n out:\n\tfree_var_defs(hist_data);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int create_hist_fields(struct hist_trigger_data *hist_data,\n\t\t\t      struct trace_event_file *file)\n{\n\tint ret;\n\n\tret = parse_var_defs(hist_data);\n\tif (ret)\n\t\tgoto out;\n\n\tret = create_val_fields(hist_data, file);\n\tif (ret)\n\t\tgoto out;\n\n\tret = create_var_fields(hist_data, file);\n\tif (ret)\n\t\tgoto out;\n\n\tret = create_key_fields(hist_data, file);\n\tif (ret)\n\t\tgoto out;\n out:\n\tfree_var_defs(hist_data);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "parse_actions",
          "args": [
            "hist_data"
          ],
          "line": 4878
        },
        "resolved": true,
        "details": {
          "function_name": "parse_actions",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "4568-4615",
          "snippet": "static int parse_actions(struct hist_trigger_data *hist_data)\n{\n\tstruct trace_array *tr = hist_data->event_file->tr;\n\tstruct action_data *data;\n\tunsigned int i;\n\tint ret = 0;\n\tchar *str;\n\tint len;\n\n\tfor (i = 0; i < hist_data->attrs->n_actions; i++) {\n\t\tstr = hist_data->attrs->action_str[i];\n\n\t\tif ((len = str_has_prefix(str, \"onmatch(\"))) {\n\t\t\tchar *action_str = str + len;\n\n\t\t\tdata = onmatch_parse(tr, action_str);\n\t\t\tif (IS_ERR(data)) {\n\t\t\t\tret = PTR_ERR(data);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else if ((len = str_has_prefix(str, \"onmax(\"))) {\n\t\t\tchar *action_str = str + len;\n\n\t\t\tdata = track_data_parse(hist_data, action_str,\n\t\t\t\t\t\tHANDLER_ONMAX);\n\t\t\tif (IS_ERR(data)) {\n\t\t\t\tret = PTR_ERR(data);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else if ((len = str_has_prefix(str, \"onchange(\"))) {\n\t\t\tchar *action_str = str + len;\n\n\t\t\tdata = track_data_parse(hist_data, action_str,\n\t\t\t\t\t\tHANDLER_ONCHANGE);\n\t\t\tif (IS_ERR(data)) {\n\t\t\t\tret = PTR_ERR(data);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\thist_data->actions[hist_data->n_actions++] = data;\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);\n\nstatic int parse_actions(struct hist_trigger_data *hist_data)\n{\n\tstruct trace_array *tr = hist_data->event_file->tr;\n\tstruct action_data *data;\n\tunsigned int i;\n\tint ret = 0;\n\tchar *str;\n\tint len;\n\n\tfor (i = 0; i < hist_data->attrs->n_actions; i++) {\n\t\tstr = hist_data->attrs->action_str[i];\n\n\t\tif ((len = str_has_prefix(str, \"onmatch(\"))) {\n\t\t\tchar *action_str = str + len;\n\n\t\t\tdata = onmatch_parse(tr, action_str);\n\t\t\tif (IS_ERR(data)) {\n\t\t\t\tret = PTR_ERR(data);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else if ((len = str_has_prefix(str, \"onmax(\"))) {\n\t\t\tchar *action_str = str + len;\n\n\t\t\tdata = track_data_parse(hist_data, action_str,\n\t\t\t\t\t\tHANDLER_ONMAX);\n\t\t\tif (IS_ERR(data)) {\n\t\t\t\tret = PTR_ERR(data);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else if ((len = str_has_prefix(str, \"onchange(\"))) {\n\t\t\tchar *action_str = str + len;\n\n\t\t\tdata = track_data_parse(hist_data, action_str,\n\t\t\t\t\t\tHANDLER_ONCHANGE);\n\t\t\tif (IS_ERR(data)) {\n\t\t\t\tret = PTR_ERR(data);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\thist_data->actions[hist_data->n_actions++] = data;\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 4872
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*hist_data)",
            "GFP_KERNEL"
          ],
          "line": 4870
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic const struct tracing_map_ops hist_trigger_elt_data_ops = {\n\t.elt_alloc\t= hist_trigger_elt_data_alloc,\n\t.elt_free\t= hist_trigger_elt_data_free,\n\t.elt_init\t= hist_trigger_elt_data_init,\n};\n\nstatic struct hist_trigger_data *\ncreate_hist_data(unsigned int map_bits,\n\t\t struct hist_trigger_attrs *attrs,\n\t\t struct trace_event_file *file,\n\t\t bool remove)\n{\n\tconst struct tracing_map_ops *map_ops = NULL;\n\tstruct hist_trigger_data *hist_data;\n\tint ret = 0;\n\n\thist_data = kzalloc(sizeof(*hist_data), GFP_KERNEL);\n\tif (!hist_data)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\thist_data->attrs = attrs;\n\thist_data->remove = remove;\n\thist_data->event_file = file;\n\n\tret = parse_actions(hist_data);\n\tif (ret)\n\t\tgoto free;\n\n\tret = create_hist_fields(hist_data, file);\n\tif (ret)\n\t\tgoto free;\n\n\tret = create_sort_keys(hist_data);\n\tif (ret)\n\t\tgoto free;\n\n\tmap_ops = &hist_trigger_elt_data_ops;\n\n\thist_data->map = tracing_map_create(map_bits, hist_data->key_size,\n\t\t\t\t\t    map_ops, hist_data);\n\tif (IS_ERR(hist_data->map)) {\n\t\tret = PTR_ERR(hist_data->map);\n\t\thist_data->map = NULL;\n\t\tgoto free;\n\t}\n\n\tret = create_tracing_map_fields(hist_data);\n\tif (ret)\n\t\tgoto free;\n out:\n\treturn hist_data;\n free:\n\thist_data->attrs = NULL;\n\n\tdestroy_hist_data(hist_data);\n\n\thist_data = ERR_PTR(ret);\n\n\tgoto out;\n}"
  },
  {
    "function_name": "create_tracing_map_fields",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
    "lines": "4815-4858",
    "snippet": "static int create_tracing_map_fields(struct hist_trigger_data *hist_data)\n{\n\tstruct tracing_map *map = hist_data->map;\n\tstruct ftrace_event_field *field;\n\tstruct hist_field *hist_field;\n\tint i, idx = 0;\n\n\tfor_each_hist_field(i, hist_data) {\n\t\thist_field = hist_data->fields[i];\n\t\tif (hist_field->flags & HIST_FIELD_FL_KEY) {\n\t\t\ttracing_map_cmp_fn_t cmp_fn;\n\n\t\t\tfield = hist_field->field;\n\n\t\t\tif (hist_field->flags & HIST_FIELD_FL_STACKTRACE)\n\t\t\t\tcmp_fn = tracing_map_cmp_none;\n\t\t\telse if (!field)\n\t\t\t\tcmp_fn = tracing_map_cmp_num(hist_field->size,\n\t\t\t\t\t\t\t     hist_field->is_signed);\n\t\t\telse if (is_string_field(field))\n\t\t\t\tcmp_fn = tracing_map_cmp_string;\n\t\t\telse\n\t\t\t\tcmp_fn = tracing_map_cmp_num(field->size,\n\t\t\t\t\t\t\t     field->is_signed);\n\t\t\tidx = tracing_map_add_key_field(map,\n\t\t\t\t\t\t\thist_field->offset,\n\t\t\t\t\t\t\tcmp_fn);\n\t\t} else if (!(hist_field->flags & HIST_FIELD_FL_VAR))\n\t\t\tidx = tracing_map_add_sum_field(map);\n\n\t\tif (idx < 0)\n\t\t\treturn idx;\n\n\t\tif (hist_field->flags & HIST_FIELD_FL_VAR) {\n\t\t\tidx = tracing_map_add_var(map);\n\t\t\tif (idx < 0)\n\t\t\t\treturn idx;\n\t\t\thist_field->var.idx = idx;\n\t\t\thist_field->var.hist_data = hist_data;\n\t\t}\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include \"tracing_map.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tracing_map_add_var",
          "args": [
            "map"
          ],
          "line": 4849
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_map_add_var",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/tracing_map.c",
          "lines": "244-252",
          "snippet": "int tracing_map_add_var(struct tracing_map *map)\n{\n\tint ret = -EINVAL;\n\n\tif (map->n_vars < TRACING_MAP_VARS_MAX)\n\t\tret = map->n_vars++;\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/kmemleak.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/jhash.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/kmemleak.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <linux/vmalloc.h>\n\nint tracing_map_add_var(struct tracing_map *map)\n{\n\tint ret = -EINVAL;\n\n\tif (map->n_vars < TRACING_MAP_VARS_MAX)\n\t\tret = map->n_vars++;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracing_map_add_sum_field",
          "args": [
            "map"
          ],
          "line": 4843
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_map_add_sum_field",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/tracing_map.c",
          "lines": "227-230",
          "snippet": "int tracing_map_add_sum_field(struct tracing_map *map)\n{\n\treturn tracing_map_add_field(map, tracing_map_cmp_atomic64);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/kmemleak.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/jhash.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/kmemleak.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <linux/vmalloc.h>\n\nint tracing_map_add_sum_field(struct tracing_map *map)\n{\n\treturn tracing_map_add_field(map, tracing_map_cmp_atomic64);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracing_map_add_key_field",
          "args": [
            "map",
            "hist_field->offset",
            "cmp_fn"
          ],
          "line": 4839
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_map_add_key_field",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/tracing_map.c",
          "lines": "270-285",
          "snippet": "int tracing_map_add_key_field(struct tracing_map *map,\n\t\t\t      unsigned int offset,\n\t\t\t      tracing_map_cmp_fn_t cmp_fn)\n\n{\n\tint idx = tracing_map_add_field(map, cmp_fn);\n\n\tif (idx < 0)\n\t\treturn idx;\n\n\tmap->fields[idx].offset = offset;\n\n\tmap->key_idx[map->n_keys++] = idx;\n\n\treturn idx;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/kmemleak.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/jhash.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/kmemleak.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <linux/vmalloc.h>\n\nint tracing_map_add_key_field(struct tracing_map *map,\n\t\t\t      unsigned int offset,\n\t\t\t      tracing_map_cmp_fn_t cmp_fn)\n\n{\n\tint idx = tracing_map_add_field(map, cmp_fn);\n\n\tif (idx < 0)\n\t\treturn idx;\n\n\tmap->fields[idx].offset = offset;\n\n\tmap->key_idx[map->n_keys++] = idx;\n\n\treturn idx;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracing_map_cmp_num",
          "args": [
            "field->size",
            "field->is_signed"
          ],
          "line": 4837
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_map_cmp_num",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/tracing_map.c",
          "lines": "167-200",
          "snippet": "tracing_map_cmp_fn_t tracing_map_cmp_num(int field_size,\n\t\t\t\t\t int field_is_signed)\n{\n\ttracing_map_cmp_fn_t fn = tracing_map_cmp_none;\n\n\tswitch (field_size) {\n\tcase 8:\n\t\tif (field_is_signed)\n\t\t\tfn = tracing_map_cmp_s64;\n\t\telse\n\t\t\tfn = tracing_map_cmp_u64;\n\t\tbreak;\n\tcase 4:\n\t\tif (field_is_signed)\n\t\t\tfn = tracing_map_cmp_s32;\n\t\telse\n\t\t\tfn = tracing_map_cmp_u32;\n\t\tbreak;\n\tcase 2:\n\t\tif (field_is_signed)\n\t\t\tfn = tracing_map_cmp_s16;\n\t\telse\n\t\t\tfn = tracing_map_cmp_u16;\n\t\tbreak;\n\tcase 1:\n\t\tif (field_is_signed)\n\t\t\tfn = tracing_map_cmp_s8;\n\t\telse\n\t\t\tfn = tracing_map_cmp_u8;\n\t\tbreak;\n\t}\n\n\treturn fn;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/kmemleak.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/jhash.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/kmemleak.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <linux/vmalloc.h>\n\ntracing_map_cmp_fn_t tracing_map_cmp_num(int field_size,\n\t\t\t\t\t int field_is_signed)\n{\n\ttracing_map_cmp_fn_t fn = tracing_map_cmp_none;\n\n\tswitch (field_size) {\n\tcase 8:\n\t\tif (field_is_signed)\n\t\t\tfn = tracing_map_cmp_s64;\n\t\telse\n\t\t\tfn = tracing_map_cmp_u64;\n\t\tbreak;\n\tcase 4:\n\t\tif (field_is_signed)\n\t\t\tfn = tracing_map_cmp_s32;\n\t\telse\n\t\t\tfn = tracing_map_cmp_u32;\n\t\tbreak;\n\tcase 2:\n\t\tif (field_is_signed)\n\t\t\tfn = tracing_map_cmp_s16;\n\t\telse\n\t\t\tfn = tracing_map_cmp_u16;\n\t\tbreak;\n\tcase 1:\n\t\tif (field_is_signed)\n\t\t\tfn = tracing_map_cmp_s8;\n\t\telse\n\t\t\tfn = tracing_map_cmp_u8;\n\t\tbreak;\n\t}\n\n\treturn fn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_string_field",
          "args": [
            "field"
          ],
          "line": 4834
        },
        "resolved": true,
        "details": {
          "function_name": "is_string_field",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.h",
          "lines": "1470-1477",
          "snippet": "static inline bool is_string_field(struct ftrace_event_field *field)\n{\n\treturn field->filter_type == FILTER_DYN_STRING ||\n\t       field->filter_type == FILTER_RDYN_STRING ||\n\t       field->filter_type == FILTER_STATIC_STRING ||\n\t       field->filter_type == FILTER_PTR_STRING ||\n\t       field->filter_type == FILTER_COMM;\n}",
          "includes": [
            "#include \"trace_entries.h\"",
            "#include \"trace_entries.h\"",
            "#include <asm/syscall.h>\t/* some archs define it here */",
            "#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */",
            "#include \"pid_list.h\"",
            "#include <linux/once_lite.h>",
            "#include <linux/ctype.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/glob.h>",
            "#include <linux/compiler.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/mmiotrace.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_entries.h\"\n#include \"trace_entries.h\"\n#include <asm/syscall.h>\t/* some archs define it here */\n#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */\n#include \"pid_list.h\"\n#include <linux/once_lite.h>\n#include <linux/ctype.h>\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/glob.h>\n#include <linux/compiler.h>\n#include <linux/trace_events.h>\n#include <linux/trace_seq.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <linux/mmiotrace.h>\n#include <linux/ring_buffer.h>\n#include <linux/clocksource.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n#include <linux/fs.h>\n\nstatic inline bool is_string_field(struct ftrace_event_field *field)\n{\n\treturn field->filter_type == FILTER_DYN_STRING ||\n\t       field->filter_type == FILTER_RDYN_STRING ||\n\t       field->filter_type == FILTER_STATIC_STRING ||\n\t       field->filter_type == FILTER_PTR_STRING ||\n\t       field->filter_type == FILTER_COMM;\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_hist_field",
          "args": [
            "i",
            "hist_data"
          ],
          "line": 4822
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int create_tracing_map_fields(struct hist_trigger_data *hist_data)\n{\n\tstruct tracing_map *map = hist_data->map;\n\tstruct ftrace_event_field *field;\n\tstruct hist_field *hist_field;\n\tint i, idx = 0;\n\n\tfor_each_hist_field(i, hist_data) {\n\t\thist_field = hist_data->fields[i];\n\t\tif (hist_field->flags & HIST_FIELD_FL_KEY) {\n\t\t\ttracing_map_cmp_fn_t cmp_fn;\n\n\t\t\tfield = hist_field->field;\n\n\t\t\tif (hist_field->flags & HIST_FIELD_FL_STACKTRACE)\n\t\t\t\tcmp_fn = tracing_map_cmp_none;\n\t\t\telse if (!field)\n\t\t\t\tcmp_fn = tracing_map_cmp_num(hist_field->size,\n\t\t\t\t\t\t\t     hist_field->is_signed);\n\t\t\telse if (is_string_field(field))\n\t\t\t\tcmp_fn = tracing_map_cmp_string;\n\t\t\telse\n\t\t\t\tcmp_fn = tracing_map_cmp_num(field->size,\n\t\t\t\t\t\t\t     field->is_signed);\n\t\t\tidx = tracing_map_add_key_field(map,\n\t\t\t\t\t\t\thist_field->offset,\n\t\t\t\t\t\t\tcmp_fn);\n\t\t} else if (!(hist_field->flags & HIST_FIELD_FL_VAR))\n\t\t\tidx = tracing_map_add_sum_field(map);\n\n\t\tif (idx < 0)\n\t\t\treturn idx;\n\n\t\tif (hist_field->flags & HIST_FIELD_FL_VAR) {\n\t\t\tidx = tracing_map_add_var(map);\n\t\t\tif (idx < 0)\n\t\t\t\treturn idx;\n\t\t\thist_field->var.idx = idx;\n\t\t\thist_field->var.hist_data = hist_data;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "destroy_hist_data",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
    "lines": "4799-4813",
    "snippet": "static void destroy_hist_data(struct hist_trigger_data *hist_data)\n{\n\tif (!hist_data)\n\t\treturn;\n\n\tdestroy_hist_trigger_attrs(hist_data->attrs);\n\tdestroy_hist_fields(hist_data);\n\ttracing_map_destroy(hist_data->map);\n\n\tdestroy_actions(hist_data);\n\tdestroy_field_vars(hist_data);\n\tdestroy_field_var_hists(hist_data);\n\n\tkfree(hist_data);\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include \"tracing_map.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "hist_data"
          ],
          "line": 4812
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "destroy_field_var_hists",
          "args": [
            "hist_data"
          ],
          "line": 4810
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_field_var_hists",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "4789-4797",
          "snippet": "static void destroy_field_var_hists(struct hist_trigger_data *hist_data)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < hist_data->n_field_var_hists; i++) {\n\t\tkfree(hist_data->field_var_hists[i]->cmd);\n\t\tkfree(hist_data->field_var_hists[i]);\n\t}\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void destroy_field_var_hists(struct hist_trigger_data *hist_data)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < hist_data->n_field_var_hists; i++) {\n\t\tkfree(hist_data->field_var_hists[i]->cmd);\n\t\tkfree(hist_data->field_var_hists[i]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "destroy_field_vars",
          "args": [
            "hist_data"
          ],
          "line": 4809
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_field_vars",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "3733-3742",
          "snippet": "static void destroy_field_vars(struct hist_trigger_data *hist_data)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < hist_data->n_field_vars; i++)\n\t\tdestroy_field_var(hist_data->field_vars[i]);\n\n\tfor (i = 0; i < hist_data->n_save_vars; i++)\n\t\tdestroy_field_var(hist_data->save_vars[i]);\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void destroy_field_vars(struct hist_trigger_data *hist_data)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < hist_data->n_field_vars; i++)\n\t\tdestroy_field_var(hist_data->field_vars[i]);\n\n\tfor (i = 0; i < hist_data->n_save_vars; i++)\n\t\tdestroy_field_var(hist_data->save_vars[i]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "destroy_actions",
          "args": [
            "hist_data"
          ],
          "line": 4808
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_actions",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "4551-4566",
          "snippet": "static void destroy_actions(struct hist_trigger_data *hist_data)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < hist_data->n_actions; i++) {\n\t\tstruct action_data *data = hist_data->actions[i];\n\n\t\tif (data->handler == HANDLER_ONMATCH)\n\t\t\tonmatch_destroy(data);\n\t\telse if (data->handler == HANDLER_ONMAX ||\n\t\t\t data->handler == HANDLER_ONCHANGE)\n\t\t\ttrack_data_destroy(hist_data, data);\n\t\telse\n\t\t\tkfree(data);\n\t}\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);\n\nstatic void destroy_actions(struct hist_trigger_data *hist_data)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < hist_data->n_actions; i++) {\n\t\tstruct action_data *data = hist_data->actions[i];\n\n\t\tif (data->handler == HANDLER_ONMATCH)\n\t\t\tonmatch_destroy(data);\n\t\telse if (data->handler == HANDLER_ONMAX ||\n\t\t\t data->handler == HANDLER_ONCHANGE)\n\t\t\ttrack_data_destroy(hist_data, data);\n\t\telse\n\t\t\tkfree(data);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracing_map_destroy",
          "args": [
            "hist_data->map"
          ],
          "line": 4806
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_map_destroy",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/tracing_map.c",
          "lines": "671-680",
          "snippet": "void tracing_map_destroy(struct tracing_map *map)\n{\n\tif (!map)\n\t\treturn;\n\n\ttracing_map_free_elts(map);\n\n\ttracing_map_array_free(map->map);\n\tkfree(map);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/kmemleak.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/jhash.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/kmemleak.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <linux/vmalloc.h>\n\nvoid tracing_map_destroy(struct tracing_map *map)\n{\n\tif (!map)\n\t\treturn;\n\n\ttracing_map_free_elts(map);\n\n\ttracing_map_array_free(map->map);\n\tkfree(map);\n}"
        }
      },
      {
        "call_info": {
          "callee": "destroy_hist_fields",
          "args": [
            "hist_data"
          ],
          "line": 4805
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_hist_fields",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "2009-2025",
          "snippet": "static void destroy_hist_fields(struct hist_trigger_data *hist_data)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < HIST_FIELDS_MAX; i++) {\n\t\tif (hist_data->fields[i]) {\n\t\t\tdestroy_hist_field(hist_data->fields[i], 0);\n\t\t\thist_data->fields[i] = NULL;\n\t\t}\n\t}\n\n\tfor (i = 0; i < hist_data->n_var_refs; i++) {\n\t\tWARN_ON(!(hist_data->var_refs[i]->flags & HIST_FIELD_FL_VAR_REF));\n\t\t__destroy_hist_field(hist_data->var_refs[i]);\n\t\thist_data->var_refs[i] = NULL;\n\t}\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define HIST_FIELDS_MAX\t\t(TRACING_MAP_FIELDS_MAX + TRACING_MAP_VARS_MAX)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\n#define HIST_FIELDS_MAX\t\t(TRACING_MAP_FIELDS_MAX + TRACING_MAP_VARS_MAX)\n\nstatic void destroy_hist_fields(struct hist_trigger_data *hist_data)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < HIST_FIELDS_MAX; i++) {\n\t\tif (hist_data->fields[i]) {\n\t\t\tdestroy_hist_field(hist_data->fields[i], 0);\n\t\t\thist_data->fields[i] = NULL;\n\t\t}\n\t}\n\n\tfor (i = 0; i < hist_data->n_var_refs; i++) {\n\t\tWARN_ON(!(hist_data->var_refs[i]->flags & HIST_FIELD_FL_VAR_REF));\n\t\t__destroy_hist_field(hist_data->var_refs[i]);\n\t\thist_data->var_refs[i] = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "destroy_hist_trigger_attrs",
          "args": [
            "hist_data->attrs"
          ],
          "line": 4804
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_hist_trigger_attrs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "1371-1390",
          "snippet": "static void destroy_hist_trigger_attrs(struct hist_trigger_attrs *attrs)\n{\n\tunsigned int i;\n\n\tif (!attrs)\n\t\treturn;\n\n\tfor (i = 0; i < attrs->n_assignments; i++)\n\t\tkfree(attrs->assignment_str[i]);\n\n\tfor (i = 0; i < attrs->n_actions; i++)\n\t\tkfree(attrs->action_str[i]);\n\n\tkfree(attrs->name);\n\tkfree(attrs->sort_key_str);\n\tkfree(attrs->keys_str);\n\tkfree(attrs->vals_str);\n\tkfree(attrs->clock);\n\tkfree(attrs);\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void destroy_hist_trigger_attrs(struct hist_trigger_attrs *attrs)\n{\n\tunsigned int i;\n\n\tif (!attrs)\n\t\treturn;\n\n\tfor (i = 0; i < attrs->n_assignments; i++)\n\t\tkfree(attrs->assignment_str[i]);\n\n\tfor (i = 0; i < attrs->n_actions; i++)\n\t\tkfree(attrs->action_str[i]);\n\n\tkfree(attrs->name);\n\tkfree(attrs->sort_key_str);\n\tkfree(attrs->keys_str);\n\tkfree(attrs->vals_str);\n\tkfree(attrs->clock);\n\tkfree(attrs);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void destroy_hist_data(struct hist_trigger_data *hist_data)\n{\n\tif (!hist_data)\n\t\treturn;\n\n\tdestroy_hist_trigger_attrs(hist_data->attrs);\n\tdestroy_hist_fields(hist_data);\n\ttracing_map_destroy(hist_data->map);\n\n\tdestroy_actions(hist_data);\n\tdestroy_field_vars(hist_data);\n\tdestroy_field_var_hists(hist_data);\n\n\tkfree(hist_data);\n}"
  },
  {
    "function_name": "destroy_field_var_hists",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
    "lines": "4789-4797",
    "snippet": "static void destroy_field_var_hists(struct hist_trigger_data *hist_data)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < hist_data->n_field_var_hists; i++) {\n\t\tkfree(hist_data->field_var_hists[i]->cmd);\n\t\tkfree(hist_data->field_var_hists[i]);\n\t}\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include \"tracing_map.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "hist_data->field_var_hists[i]"
          ],
          "line": 4795
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void destroy_field_var_hists(struct hist_trigger_data *hist_data)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < hist_data->n_field_var_hists; i++) {\n\t\tkfree(hist_data->field_var_hists[i]->cmd);\n\t\tkfree(hist_data->field_var_hists[i]);\n\t}\n}"
  },
  {
    "function_name": "print_actions_spec",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
    "lines": "4773-4787",
    "snippet": "static void print_actions_spec(struct seq_file *m,\n\t\t\t       struct hist_trigger_data *hist_data)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < hist_data->n_actions; i++) {\n\t\tstruct action_data *data = hist_data->actions[i];\n\n\t\tif (data->handler == HANDLER_ONMATCH)\n\t\t\tprint_onmatch_spec(m, hist_data, data);\n\t\telse if (data->handler == HANDLER_ONMAX ||\n\t\t\t data->handler == HANDLER_ONCHANGE)\n\t\t\tprint_track_data_spec(m, hist_data, data);\n\t}\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include \"tracing_map.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "print_track_data_spec",
          "args": [
            "m",
            "hist_data",
            "data"
          ],
          "line": 4785
        },
        "resolved": true,
        "details": {
          "function_name": "print_track_data_spec",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "4685-4699",
          "snippet": "static void print_track_data_spec(struct seq_file *m,\n\t\t\t\t  struct hist_trigger_data *hist_data,\n\t\t\t\t  struct action_data *data)\n{\n\tif (data->handler == HANDLER_ONMAX)\n\t\tseq_puts(m, \":onmax(\");\n\telse if (data->handler == HANDLER_ONCHANGE)\n\t\tseq_puts(m, \":onchange(\");\n\tseq_printf(m, \"%s\", data->track_data.var_str);\n\tseq_printf(m, \").%s(\", data->action_name);\n\n\tprint_action_spec(m, hist_data, data);\n\n\tseq_puts(m, \")\");\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);\n\nstatic void print_track_data_spec(struct seq_file *m,\n\t\t\t\t  struct hist_trigger_data *hist_data,\n\t\t\t\t  struct action_data *data)\n{\n\tif (data->handler == HANDLER_ONMAX)\n\t\tseq_puts(m, \":onmax(\");\n\telse if (data->handler == HANDLER_ONCHANGE)\n\t\tseq_puts(m, \":onchange(\");\n\tseq_printf(m, \"%s\", data->track_data.var_str);\n\tseq_printf(m, \").%s(\", data->action_name);\n\n\tprint_action_spec(m, hist_data, data);\n\n\tseq_puts(m, \")\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_onmatch_spec",
          "args": [
            "m",
            "hist_data",
            "data"
          ],
          "line": 4782
        },
        "resolved": true,
        "details": {
          "function_name": "print_onmatch_spec",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "4701-4713",
          "snippet": "static void print_onmatch_spec(struct seq_file *m,\n\t\t\t       struct hist_trigger_data *hist_data,\n\t\t\t       struct action_data *data)\n{\n\tseq_printf(m, \":onmatch(%s.%s).\", data->match_data.event_system,\n\t\t   data->match_data.event);\n\n\tseq_printf(m, \"%s(\", data->action_name);\n\n\tprint_action_spec(m, hist_data, data);\n\n\tseq_puts(m, \")\");\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);\n\nstatic void print_onmatch_spec(struct seq_file *m,\n\t\t\t       struct hist_trigger_data *hist_data,\n\t\t\t       struct action_data *data)\n{\n\tseq_printf(m, \":onmatch(%s.%s).\", data->match_data.event_system,\n\t\t   data->match_data.event);\n\n\tseq_printf(m, \"%s(\", data->action_name);\n\n\tprint_action_spec(m, hist_data, data);\n\n\tseq_puts(m, \")\");\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);\n\nstatic void print_actions_spec(struct seq_file *m,\n\t\t\t       struct hist_trigger_data *hist_data)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < hist_data->n_actions; i++) {\n\t\tstruct action_data *data = hist_data->actions[i];\n\n\t\tif (data->handler == HANDLER_ONMATCH)\n\t\t\tprint_onmatch_spec(m, hist_data, data);\n\t\telse if (data->handler == HANDLER_ONMAX ||\n\t\t\t data->handler == HANDLER_ONCHANGE)\n\t\t\tprint_track_data_spec(m, hist_data, data);\n\t}\n}"
  },
  {
    "function_name": "actions_match",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
    "lines": "4715-4770",
    "snippet": "static bool actions_match(struct hist_trigger_data *hist_data,\n\t\t\t  struct hist_trigger_data *hist_data_test)\n{\n\tunsigned int i, j;\n\n\tif (hist_data->n_actions != hist_data_test->n_actions)\n\t\treturn false;\n\n\tfor (i = 0; i < hist_data->n_actions; i++) {\n\t\tstruct action_data *data = hist_data->actions[i];\n\t\tstruct action_data *data_test = hist_data_test->actions[i];\n\t\tchar *action_name, *action_name_test;\n\n\t\tif (data->handler != data_test->handler)\n\t\t\treturn false;\n\t\tif (data->action != data_test->action)\n\t\t\treturn false;\n\n\t\tif (data->n_params != data_test->n_params)\n\t\t\treturn false;\n\n\t\tfor (j = 0; j < data->n_params; j++) {\n\t\t\tif (strcmp(data->params[j], data_test->params[j]) != 0)\n\t\t\t\treturn false;\n\t\t}\n\n\t\tif (data->use_trace_keyword)\n\t\t\taction_name = data->synth_event_name;\n\t\telse\n\t\t\taction_name = data->action_name;\n\n\t\tif (data_test->use_trace_keyword)\n\t\t\taction_name_test = data_test->synth_event_name;\n\t\telse\n\t\t\taction_name_test = data_test->action_name;\n\n\t\tif (strcmp(action_name, action_name_test) != 0)\n\t\t\treturn false;\n\n\t\tif (data->handler == HANDLER_ONMATCH) {\n\t\t\tif (strcmp(data->match_data.event_system,\n\t\t\t\t   data_test->match_data.event_system) != 0)\n\t\t\t\treturn false;\n\t\t\tif (strcmp(data->match_data.event,\n\t\t\t\t   data_test->match_data.event) != 0)\n\t\t\t\treturn false;\n\t\t} else if (data->handler == HANDLER_ONMAX ||\n\t\t\t   data->handler == HANDLER_ONCHANGE) {\n\t\t\tif (strcmp(data->track_data.var_str,\n\t\t\t\t   data_test->track_data.var_str) != 0)\n\t\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include \"tracing_map.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "data->track_data.var_str",
            "data_test->track_data.var_str"
          ],
          "line": 4763
        },
        "resolved": true,
        "details": {
          "function_name": "sym_strcmp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/report.c",
          "lines": "356-365",
          "snippet": "static int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}",
          "includes": [
            "#include \"encoding.h\"",
            "#include \"kcsan.h\"",
            "#include <linux/stacktrace.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/delay.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"encoding.h\"\n#include \"kcsan.h\"\n#include <linux/stacktrace.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/lockdep.h>\n#include <linux/kernel.h>\n#include <linux/kallsyms.h>\n#include <linux/jiffies.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n\nstatic int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);\n\nstatic bool actions_match(struct hist_trigger_data *hist_data,\n\t\t\t  struct hist_trigger_data *hist_data_test)\n{\n\tunsigned int i, j;\n\n\tif (hist_data->n_actions != hist_data_test->n_actions)\n\t\treturn false;\n\n\tfor (i = 0; i < hist_data->n_actions; i++) {\n\t\tstruct action_data *data = hist_data->actions[i];\n\t\tstruct action_data *data_test = hist_data_test->actions[i];\n\t\tchar *action_name, *action_name_test;\n\n\t\tif (data->handler != data_test->handler)\n\t\t\treturn false;\n\t\tif (data->action != data_test->action)\n\t\t\treturn false;\n\n\t\tif (data->n_params != data_test->n_params)\n\t\t\treturn false;\n\n\t\tfor (j = 0; j < data->n_params; j++) {\n\t\t\tif (strcmp(data->params[j], data_test->params[j]) != 0)\n\t\t\t\treturn false;\n\t\t}\n\n\t\tif (data->use_trace_keyword)\n\t\t\taction_name = data->synth_event_name;\n\t\telse\n\t\t\taction_name = data->action_name;\n\n\t\tif (data_test->use_trace_keyword)\n\t\t\taction_name_test = data_test->synth_event_name;\n\t\telse\n\t\t\taction_name_test = data_test->action_name;\n\n\t\tif (strcmp(action_name, action_name_test) != 0)\n\t\t\treturn false;\n\n\t\tif (data->handler == HANDLER_ONMATCH) {\n\t\t\tif (strcmp(data->match_data.event_system,\n\t\t\t\t   data_test->match_data.event_system) != 0)\n\t\t\t\treturn false;\n\t\t\tif (strcmp(data->match_data.event,\n\t\t\t\t   data_test->match_data.event) != 0)\n\t\t\t\treturn false;\n\t\t} else if (data->handler == HANDLER_ONMAX ||\n\t\t\t   data->handler == HANDLER_ONCHANGE) {\n\t\t\tif (strcmp(data->track_data.var_str,\n\t\t\t\t   data_test->track_data.var_str) != 0)\n\t\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}"
  },
  {
    "function_name": "print_onmatch_spec",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
    "lines": "4701-4713",
    "snippet": "static void print_onmatch_spec(struct seq_file *m,\n\t\t\t       struct hist_trigger_data *hist_data,\n\t\t\t       struct action_data *data)\n{\n\tseq_printf(m, \":onmatch(%s.%s).\", data->match_data.event_system,\n\t\t   data->match_data.event);\n\n\tseq_printf(m, \"%s(\", data->action_name);\n\n\tprint_action_spec(m, hist_data, data);\n\n\tseq_puts(m, \")\");\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include \"tracing_map.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "m",
            "\")\""
          ],
          "line": 4712
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_puts",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "205-220",
          "snippet": "void trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_action_spec",
          "args": [
            "m",
            "hist_data",
            "data"
          ],
          "line": 4710
        },
        "resolved": true,
        "details": {
          "function_name": "print_action_spec",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "4662-4683",
          "snippet": "static void print_action_spec(struct seq_file *m,\n\t\t\t      struct hist_trigger_data *hist_data,\n\t\t\t      struct action_data *data)\n{\n\tunsigned int i;\n\n\tif (data->action == ACTION_SAVE) {\n\t\tfor (i = 0; i < hist_data->n_save_vars; i++) {\n\t\t\tseq_printf(m, \"%s\", hist_data->save_vars[i]->var->var.name);\n\t\t\tif (i < hist_data->n_save_vars - 1)\n\t\t\t\tseq_puts(m, \",\");\n\t\t}\n\t} else if (data->action == ACTION_TRACE) {\n\t\tif (data->use_trace_keyword)\n\t\t\tseq_printf(m, \"%s\", data->synth_event_name);\n\t\tfor (i = 0; i < data->n_params; i++) {\n\t\t\tif (i || data->use_trace_keyword)\n\t\t\t\tseq_puts(m, \",\");\n\t\t\tseq_printf(m, \"%s\", data->params[i]);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);\n\nstatic void print_action_spec(struct seq_file *m,\n\t\t\t      struct hist_trigger_data *hist_data,\n\t\t\t      struct action_data *data)\n{\n\tunsigned int i;\n\n\tif (data->action == ACTION_SAVE) {\n\t\tfor (i = 0; i < hist_data->n_save_vars; i++) {\n\t\t\tseq_printf(m, \"%s\", hist_data->save_vars[i]->var->var.name);\n\t\t\tif (i < hist_data->n_save_vars - 1)\n\t\t\t\tseq_puts(m, \",\");\n\t\t}\n\t} else if (data->action == ACTION_TRACE) {\n\t\tif (data->use_trace_keyword)\n\t\t\tseq_printf(m, \"%s\", data->synth_event_name);\n\t\tfor (i = 0; i < data->n_params; i++) {\n\t\t\tif (i || data->use_trace_keyword)\n\t\t\t\tseq_puts(m, \",\");\n\t\t\tseq_printf(m, \"%s\", data->params[i]);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"%s(\"",
            "data->action_name"
          ],
          "line": 4708
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "81-100",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);\n\nstatic void print_onmatch_spec(struct seq_file *m,\n\t\t\t       struct hist_trigger_data *hist_data,\n\t\t\t       struct action_data *data)\n{\n\tseq_printf(m, \":onmatch(%s.%s).\", data->match_data.event_system,\n\t\t   data->match_data.event);\n\n\tseq_printf(m, \"%s(\", data->action_name);\n\n\tprint_action_spec(m, hist_data, data);\n\n\tseq_puts(m, \")\");\n}"
  },
  {
    "function_name": "print_track_data_spec",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
    "lines": "4685-4699",
    "snippet": "static void print_track_data_spec(struct seq_file *m,\n\t\t\t\t  struct hist_trigger_data *hist_data,\n\t\t\t\t  struct action_data *data)\n{\n\tif (data->handler == HANDLER_ONMAX)\n\t\tseq_puts(m, \":onmax(\");\n\telse if (data->handler == HANDLER_ONCHANGE)\n\t\tseq_puts(m, \":onchange(\");\n\tseq_printf(m, \"%s\", data->track_data.var_str);\n\tseq_printf(m, \").%s(\", data->action_name);\n\n\tprint_action_spec(m, hist_data, data);\n\n\tseq_puts(m, \")\");\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include \"tracing_map.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "m",
            "\")\""
          ],
          "line": 4698
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_puts",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "205-220",
          "snippet": "void trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_action_spec",
          "args": [
            "m",
            "hist_data",
            "data"
          ],
          "line": 4696
        },
        "resolved": true,
        "details": {
          "function_name": "print_action_spec",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "4662-4683",
          "snippet": "static void print_action_spec(struct seq_file *m,\n\t\t\t      struct hist_trigger_data *hist_data,\n\t\t\t      struct action_data *data)\n{\n\tunsigned int i;\n\n\tif (data->action == ACTION_SAVE) {\n\t\tfor (i = 0; i < hist_data->n_save_vars; i++) {\n\t\t\tseq_printf(m, \"%s\", hist_data->save_vars[i]->var->var.name);\n\t\t\tif (i < hist_data->n_save_vars - 1)\n\t\t\t\tseq_puts(m, \",\");\n\t\t}\n\t} else if (data->action == ACTION_TRACE) {\n\t\tif (data->use_trace_keyword)\n\t\t\tseq_printf(m, \"%s\", data->synth_event_name);\n\t\tfor (i = 0; i < data->n_params; i++) {\n\t\t\tif (i || data->use_trace_keyword)\n\t\t\t\tseq_puts(m, \",\");\n\t\t\tseq_printf(m, \"%s\", data->params[i]);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);\n\nstatic void print_action_spec(struct seq_file *m,\n\t\t\t      struct hist_trigger_data *hist_data,\n\t\t\t      struct action_data *data)\n{\n\tunsigned int i;\n\n\tif (data->action == ACTION_SAVE) {\n\t\tfor (i = 0; i < hist_data->n_save_vars; i++) {\n\t\t\tseq_printf(m, \"%s\", hist_data->save_vars[i]->var->var.name);\n\t\t\tif (i < hist_data->n_save_vars - 1)\n\t\t\t\tseq_puts(m, \",\");\n\t\t}\n\t} else if (data->action == ACTION_TRACE) {\n\t\tif (data->use_trace_keyword)\n\t\t\tseq_printf(m, \"%s\", data->synth_event_name);\n\t\tfor (i = 0; i < data->n_params; i++) {\n\t\t\tif (i || data->use_trace_keyword)\n\t\t\t\tseq_puts(m, \",\");\n\t\t\tseq_printf(m, \"%s\", data->params[i]);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\").%s(\"",
            "data->action_name"
          ],
          "line": 4694
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "81-100",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);\n\nstatic void print_track_data_spec(struct seq_file *m,\n\t\t\t\t  struct hist_trigger_data *hist_data,\n\t\t\t\t  struct action_data *data)\n{\n\tif (data->handler == HANDLER_ONMAX)\n\t\tseq_puts(m, \":onmax(\");\n\telse if (data->handler == HANDLER_ONCHANGE)\n\t\tseq_puts(m, \":onchange(\");\n\tseq_printf(m, \"%s\", data->track_data.var_str);\n\tseq_printf(m, \").%s(\", data->action_name);\n\n\tprint_action_spec(m, hist_data, data);\n\n\tseq_puts(m, \")\");\n}"
  },
  {
    "function_name": "print_action_spec",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
    "lines": "4662-4683",
    "snippet": "static void print_action_spec(struct seq_file *m,\n\t\t\t      struct hist_trigger_data *hist_data,\n\t\t\t      struct action_data *data)\n{\n\tunsigned int i;\n\n\tif (data->action == ACTION_SAVE) {\n\t\tfor (i = 0; i < hist_data->n_save_vars; i++) {\n\t\t\tseq_printf(m, \"%s\", hist_data->save_vars[i]->var->var.name);\n\t\t\tif (i < hist_data->n_save_vars - 1)\n\t\t\t\tseq_puts(m, \",\");\n\t\t}\n\t} else if (data->action == ACTION_TRACE) {\n\t\tif (data->use_trace_keyword)\n\t\t\tseq_printf(m, \"%s\", data->synth_event_name);\n\t\tfor (i = 0; i < data->n_params; i++) {\n\t\t\tif (i || data->use_trace_keyword)\n\t\t\t\tseq_puts(m, \",\");\n\t\t\tseq_printf(m, \"%s\", data->params[i]);\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include \"tracing_map.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"%s\"",
            "data->params[i]"
          ],
          "line": 4680
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "81-100",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "m",
            "\",\""
          ],
          "line": 4679
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_puts",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "205-220",
          "snippet": "void trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);\n\nstatic void print_action_spec(struct seq_file *m,\n\t\t\t      struct hist_trigger_data *hist_data,\n\t\t\t      struct action_data *data)\n{\n\tunsigned int i;\n\n\tif (data->action == ACTION_SAVE) {\n\t\tfor (i = 0; i < hist_data->n_save_vars; i++) {\n\t\t\tseq_printf(m, \"%s\", hist_data->save_vars[i]->var->var.name);\n\t\t\tif (i < hist_data->n_save_vars - 1)\n\t\t\t\tseq_puts(m, \",\");\n\t\t}\n\t} else if (data->action == ACTION_TRACE) {\n\t\tif (data->use_trace_keyword)\n\t\t\tseq_printf(m, \"%s\", data->synth_event_name);\n\t\tfor (i = 0; i < data->n_params; i++) {\n\t\t\tif (i || data->use_trace_keyword)\n\t\t\t\tseq_puts(m, \",\");\n\t\t\tseq_printf(m, \"%s\", data->params[i]);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "print_actions",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
    "lines": "4644-4660",
    "snippet": "static void print_actions(struct seq_file *m,\n\t\t\t  struct hist_trigger_data *hist_data,\n\t\t\t  struct tracing_map_elt *elt)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < hist_data->n_actions; i++) {\n\t\tstruct action_data *data = hist_data->actions[i];\n\n\t\tif (data->action == ACTION_SNAPSHOT)\n\t\t\tcontinue;\n\n\t\tif (data->handler == HANDLER_ONMAX ||\n\t\t    data->handler == HANDLER_ONCHANGE)\n\t\t\ttrack_data_print(m, hist_data, elt, data);\n\t}\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include \"tracing_map.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "track_data_print",
          "args": [
            "m",
            "hist_data",
            "elt",
            "data"
          ],
          "line": 4658
        },
        "resolved": true,
        "details": {
          "function_name": "track_data_print",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "3387-3418",
          "snippet": "static void track_data_print(struct seq_file *m,\n\t\t\t     struct hist_trigger_data *hist_data,\n\t\t\t     struct tracing_map_elt *elt,\n\t\t\t     struct action_data *data)\n{\n\tu64 track_val = get_track_val(hist_data, elt, data);\n\tunsigned int i, save_var_idx;\n\n\tif (data->handler == HANDLER_ONMAX)\n\t\tseq_printf(m, \"\\n\\tmax: %10llu\", track_val);\n\telse if (data->handler == HANDLER_ONCHANGE)\n\t\tseq_printf(m, \"\\n\\tchanged: %10llu\", track_val);\n\n\tif (data->action == ACTION_SNAPSHOT)\n\t\treturn;\n\n\tfor (i = 0; i < hist_data->n_save_vars; i++) {\n\t\tstruct hist_field *save_val = hist_data->save_vars[i]->val;\n\t\tstruct hist_field *save_var = hist_data->save_vars[i]->var;\n\t\tu64 val;\n\n\t\tsave_var_idx = save_var->var.idx;\n\n\t\tval = tracing_map_read_var(elt, save_var_idx);\n\n\t\tif (save_val->flags & HIST_FIELD_FL_STRING) {\n\t\t\tseq_printf(m, \"  %s: %-32s\", save_var->var.name,\n\t\t\t\t   (char *)(uintptr_t)(val));\n\t\t} else\n\t\t\tseq_printf(m, \"  %s: %10llu\", save_var->var.name, val);\n\t}\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);\n\nstatic void track_data_print(struct seq_file *m,\n\t\t\t     struct hist_trigger_data *hist_data,\n\t\t\t     struct tracing_map_elt *elt,\n\t\t\t     struct action_data *data)\n{\n\tu64 track_val = get_track_val(hist_data, elt, data);\n\tunsigned int i, save_var_idx;\n\n\tif (data->handler == HANDLER_ONMAX)\n\t\tseq_printf(m, \"\\n\\tmax: %10llu\", track_val);\n\telse if (data->handler == HANDLER_ONCHANGE)\n\t\tseq_printf(m, \"\\n\\tchanged: %10llu\", track_val);\n\n\tif (data->action == ACTION_SNAPSHOT)\n\t\treturn;\n\n\tfor (i = 0; i < hist_data->n_save_vars; i++) {\n\t\tstruct hist_field *save_val = hist_data->save_vars[i]->val;\n\t\tstruct hist_field *save_var = hist_data->save_vars[i]->var;\n\t\tu64 val;\n\n\t\tsave_var_idx = save_var->var.idx;\n\n\t\tval = tracing_map_read_var(elt, save_var_idx);\n\n\t\tif (save_val->flags & HIST_FIELD_FL_STRING) {\n\t\t\tseq_printf(m, \"  %s: %-32s\", save_var->var.name,\n\t\t\t\t   (char *)(uintptr_t)(val));\n\t\t} else\n\t\t\tseq_printf(m, \"  %s: %10llu\", save_var->var.name, val);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);\n\nstatic void print_actions(struct seq_file *m,\n\t\t\t  struct hist_trigger_data *hist_data,\n\t\t\t  struct tracing_map_elt *elt)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < hist_data->n_actions; i++) {\n\t\tstruct action_data *data = hist_data->actions[i];\n\n\t\tif (data->action == ACTION_SNAPSHOT)\n\t\t\tcontinue;\n\n\t\tif (data->handler == HANDLER_ONMAX ||\n\t\t    data->handler == HANDLER_ONCHANGE)\n\t\t\ttrack_data_print(m, hist_data, elt, data);\n\t}\n}"
  },
  {
    "function_name": "create_actions",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
    "lines": "4617-4642",
    "snippet": "static int create_actions(struct hist_trigger_data *hist_data)\n{\n\tstruct action_data *data;\n\tunsigned int i;\n\tint ret = 0;\n\n\tfor (i = 0; i < hist_data->attrs->n_actions; i++) {\n\t\tdata = hist_data->actions[i];\n\n\t\tif (data->handler == HANDLER_ONMATCH) {\n\t\t\tret = onmatch_create(hist_data, data);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t} else if (data->handler == HANDLER_ONMAX ||\n\t\t\t   data->handler == HANDLER_ONCHANGE) {\n\t\t\tret = track_data_create(hist_data, data);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include \"tracing_map.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "track_data_create",
          "args": [
            "hist_data",
            "data"
          ],
          "line": 4632
        },
        "resolved": true,
        "details": {
          "function_name": "track_data_create",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "3479-3527",
          "snippet": "static int track_data_create(struct hist_trigger_data *hist_data,\n\t\t\t     struct action_data *data)\n{\n\tstruct hist_field *var_field, *ref_field, *track_var = NULL;\n\tstruct trace_event_file *file = hist_data->event_file;\n\tstruct trace_array *tr = file->tr;\n\tchar *track_data_var_str;\n\tint ret = 0;\n\n\ttrack_data_var_str = data->track_data.var_str;\n\tif (track_data_var_str[0] != '$') {\n\t\thist_err(tr, HIST_ERR_ONX_NOT_VAR, errpos(track_data_var_str));\n\t\treturn -EINVAL;\n\t}\n\ttrack_data_var_str++;\n\n\tvar_field = find_target_event_var(hist_data, NULL, NULL, track_data_var_str);\n\tif (!var_field) {\n\t\thist_err(tr, HIST_ERR_ONX_VAR_NOT_FOUND, errpos(track_data_var_str));\n\t\treturn -EINVAL;\n\t}\n\n\tref_field = create_var_ref(hist_data, var_field, NULL, NULL);\n\tif (!ref_field)\n\t\treturn -ENOMEM;\n\n\tdata->track_data.var_ref = ref_field;\n\n\tif (data->handler == HANDLER_ONMAX)\n\t\ttrack_var = create_var(hist_data, file, \"__max\", sizeof(u64), \"u64\");\n\tif (IS_ERR(track_var)) {\n\t\thist_err(tr, HIST_ERR_ONX_VAR_CREATE_FAIL, 0);\n\t\tret = PTR_ERR(track_var);\n\t\tgoto out;\n\t}\n\n\tif (data->handler == HANDLER_ONCHANGE)\n\t\ttrack_var = create_var(hist_data, file, \"__change\", sizeof(u64), \"u64\");\n\tif (IS_ERR(track_var)) {\n\t\thist_err(tr, HIST_ERR_ONX_VAR_CREATE_FAIL, 0);\n\t\tret = PTR_ERR(track_var);\n\t\tgoto out;\n\t}\n\tdata->track_data.track_var = track_var;\n\n\tret = action_create(hist_data, data);\n out:\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);\n\nstatic int track_data_create(struct hist_trigger_data *hist_data,\n\t\t\t     struct action_data *data)\n{\n\tstruct hist_field *var_field, *ref_field, *track_var = NULL;\n\tstruct trace_event_file *file = hist_data->event_file;\n\tstruct trace_array *tr = file->tr;\n\tchar *track_data_var_str;\n\tint ret = 0;\n\n\ttrack_data_var_str = data->track_data.var_str;\n\tif (track_data_var_str[0] != '$') {\n\t\thist_err(tr, HIST_ERR_ONX_NOT_VAR, errpos(track_data_var_str));\n\t\treturn -EINVAL;\n\t}\n\ttrack_data_var_str++;\n\n\tvar_field = find_target_event_var(hist_data, NULL, NULL, track_data_var_str);\n\tif (!var_field) {\n\t\thist_err(tr, HIST_ERR_ONX_VAR_NOT_FOUND, errpos(track_data_var_str));\n\t\treturn -EINVAL;\n\t}\n\n\tref_field = create_var_ref(hist_data, var_field, NULL, NULL);\n\tif (!ref_field)\n\t\treturn -ENOMEM;\n\n\tdata->track_data.var_ref = ref_field;\n\n\tif (data->handler == HANDLER_ONMAX)\n\t\ttrack_var = create_var(hist_data, file, \"__max\", sizeof(u64), \"u64\");\n\tif (IS_ERR(track_var)) {\n\t\thist_err(tr, HIST_ERR_ONX_VAR_CREATE_FAIL, 0);\n\t\tret = PTR_ERR(track_var);\n\t\tgoto out;\n\t}\n\n\tif (data->handler == HANDLER_ONCHANGE)\n\t\ttrack_var = create_var(hist_data, file, \"__change\", sizeof(u64), \"u64\");\n\tif (IS_ERR(track_var)) {\n\t\thist_err(tr, HIST_ERR_ONX_VAR_CREATE_FAIL, 0);\n\t\tret = PTR_ERR(track_var);\n\t\tgoto out;\n\t}\n\tdata->track_data.track_var = track_var;\n\n\tret = action_create(hist_data, data);\n out:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "onmatch_create",
          "args": [
            "hist_data",
            "data"
          ],
          "line": 4627
        },
        "resolved": true,
        "details": {
          "function_name": "onmatch_create",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "4032-4036",
          "snippet": "static int onmatch_create(struct hist_trigger_data *hist_data,\n\t\t\t  struct action_data *data)\n{\n\treturn action_create(hist_data, data);\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);\n\nstatic int onmatch_create(struct hist_trigger_data *hist_data,\n\t\t\t  struct action_data *data)\n{\n\treturn action_create(hist_data, data);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);\n\nstatic int create_actions(struct hist_trigger_data *hist_data)\n{\n\tstruct action_data *data;\n\tunsigned int i;\n\tint ret = 0;\n\n\tfor (i = 0; i < hist_data->attrs->n_actions; i++) {\n\t\tdata = hist_data->actions[i];\n\n\t\tif (data->handler == HANDLER_ONMATCH) {\n\t\t\tret = onmatch_create(hist_data, data);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t} else if (data->handler == HANDLER_ONMAX ||\n\t\t\t   data->handler == HANDLER_ONCHANGE) {\n\t\t\tret = track_data_create(hist_data, data);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "parse_actions",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
    "lines": "4568-4615",
    "snippet": "static int parse_actions(struct hist_trigger_data *hist_data)\n{\n\tstruct trace_array *tr = hist_data->event_file->tr;\n\tstruct action_data *data;\n\tunsigned int i;\n\tint ret = 0;\n\tchar *str;\n\tint len;\n\n\tfor (i = 0; i < hist_data->attrs->n_actions; i++) {\n\t\tstr = hist_data->attrs->action_str[i];\n\n\t\tif ((len = str_has_prefix(str, \"onmatch(\"))) {\n\t\t\tchar *action_str = str + len;\n\n\t\t\tdata = onmatch_parse(tr, action_str);\n\t\t\tif (IS_ERR(data)) {\n\t\t\t\tret = PTR_ERR(data);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else if ((len = str_has_prefix(str, \"onmax(\"))) {\n\t\t\tchar *action_str = str + len;\n\n\t\t\tdata = track_data_parse(hist_data, action_str,\n\t\t\t\t\t\tHANDLER_ONMAX);\n\t\t\tif (IS_ERR(data)) {\n\t\t\t\tret = PTR_ERR(data);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else if ((len = str_has_prefix(str, \"onchange(\"))) {\n\t\t\tchar *action_str = str + len;\n\n\t\t\tdata = track_data_parse(hist_data, action_str,\n\t\t\t\t\t\tHANDLER_ONCHANGE);\n\t\t\tif (IS_ERR(data)) {\n\t\t\t\tret = PTR_ERR(data);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\thist_data->actions[hist_data->n_actions++] = data;\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include \"tracing_map.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "data"
          ],
          "line": 4603
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "data"
          ],
          "line": 4602
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "track_data_parse",
          "args": [
            "hist_data",
            "action_str",
            "HANDLER_ONCHANGE"
          ],
          "line": 4600
        },
        "resolved": true,
        "details": {
          "function_name": "track_data_parse",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "3680-3712",
          "snippet": "static struct action_data *track_data_parse(struct hist_trigger_data *hist_data,\n\t\t\t\t\t    char *str, enum handler_id handler)\n{\n\tstruct action_data *data;\n\tint ret = -EINVAL;\n\tchar *var_str;\n\n\tdata = kzalloc(sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tvar_str = strsep(&str, \")\");\n\tif (!var_str || !str) {\n\t\tret = -EINVAL;\n\t\tgoto free;\n\t}\n\n\tdata->track_data.var_str = kstrdup(var_str, GFP_KERNEL);\n\tif (!data->track_data.var_str) {\n\t\tret = -ENOMEM;\n\t\tgoto free;\n\t}\n\n\tret = action_parse(hist_data->event_file->tr, str, data, handler);\n\tif (ret)\n\t\tgoto free;\n out:\n\treturn data;\n free:\n\ttrack_data_destroy(hist_data, data);\n\tdata = ERR_PTR(ret);\n\tgoto out;\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);\n\nstatic struct action_data *track_data_parse(struct hist_trigger_data *hist_data,\n\t\t\t\t\t    char *str, enum handler_id handler)\n{\n\tstruct action_data *data;\n\tint ret = -EINVAL;\n\tchar *var_str;\n\n\tdata = kzalloc(sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tvar_str = strsep(&str, \")\");\n\tif (!var_str || !str) {\n\t\tret = -EINVAL;\n\t\tgoto free;\n\t}\n\n\tdata->track_data.var_str = kstrdup(var_str, GFP_KERNEL);\n\tif (!data->track_data.var_str) {\n\t\tret = -ENOMEM;\n\t\tgoto free;\n\t}\n\n\tret = action_parse(hist_data->event_file->tr, str, data, handler);\n\tif (ret)\n\t\tgoto free;\n out:\n\treturn data;\n free:\n\ttrack_data_destroy(hist_data, data);\n\tdata = ERR_PTR(ret);\n\tgoto out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "str_has_prefix",
          "args": [
            "str",
            "\"onchange(\""
          ],
          "line": 4597
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "data"
          ],
          "line": 4594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "data"
          ],
          "line": 4593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "str_has_prefix",
          "args": [
            "str",
            "\"onmax(\""
          ],
          "line": 4588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "data"
          ],
          "line": 4585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "data"
          ],
          "line": 4584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "onmatch_parse",
          "args": [
            "tr",
            "action_str"
          ],
          "line": 4583
        },
        "resolved": true,
        "details": {
          "function_name": "onmatch_parse",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "4038-4086",
          "snippet": "static struct action_data *onmatch_parse(struct trace_array *tr, char *str)\n{\n\tchar *match_event, *match_event_system;\n\tstruct action_data *data;\n\tint ret = -EINVAL;\n\n\tdata = kzalloc(sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmatch_event = strsep(&str, \")\");\n\tif (!match_event || !str) {\n\t\thist_err(tr, HIST_ERR_NO_CLOSING_PAREN, errpos(match_event));\n\t\tgoto free;\n\t}\n\n\tmatch_event_system = strsep(&match_event, \".\");\n\tif (!match_event) {\n\t\thist_err(tr, HIST_ERR_SUBSYS_NOT_FOUND, errpos(match_event_system));\n\t\tgoto free;\n\t}\n\n\tif (IS_ERR(event_file(tr, match_event_system, match_event))) {\n\t\thist_err(tr, HIST_ERR_INVALID_SUBSYS_EVENT, errpos(match_event));\n\t\tgoto free;\n\t}\n\n\tdata->match_data.event = kstrdup(match_event, GFP_KERNEL);\n\tif (!data->match_data.event) {\n\t\tret = -ENOMEM;\n\t\tgoto free;\n\t}\n\n\tdata->match_data.event_system = kstrdup(match_event_system, GFP_KERNEL);\n\tif (!data->match_data.event_system) {\n\t\tret = -ENOMEM;\n\t\tgoto free;\n\t}\n\n\tret = action_parse(tr, str, data, HANDLER_ONMATCH);\n\tif (ret)\n\t\tgoto free;\n out:\n\treturn data;\n free:\n\tonmatch_destroy(data);\n\tdata = ERR_PTR(ret);\n\tgoto out;\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);\n\nstatic struct action_data *onmatch_parse(struct trace_array *tr, char *str)\n{\n\tchar *match_event, *match_event_system;\n\tstruct action_data *data;\n\tint ret = -EINVAL;\n\n\tdata = kzalloc(sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmatch_event = strsep(&str, \")\");\n\tif (!match_event || !str) {\n\t\thist_err(tr, HIST_ERR_NO_CLOSING_PAREN, errpos(match_event));\n\t\tgoto free;\n\t}\n\n\tmatch_event_system = strsep(&match_event, \".\");\n\tif (!match_event) {\n\t\thist_err(tr, HIST_ERR_SUBSYS_NOT_FOUND, errpos(match_event_system));\n\t\tgoto free;\n\t}\n\n\tif (IS_ERR(event_file(tr, match_event_system, match_event))) {\n\t\thist_err(tr, HIST_ERR_INVALID_SUBSYS_EVENT, errpos(match_event));\n\t\tgoto free;\n\t}\n\n\tdata->match_data.event = kstrdup(match_event, GFP_KERNEL);\n\tif (!data->match_data.event) {\n\t\tret = -ENOMEM;\n\t\tgoto free;\n\t}\n\n\tdata->match_data.event_system = kstrdup(match_event_system, GFP_KERNEL);\n\tif (!data->match_data.event_system) {\n\t\tret = -ENOMEM;\n\t\tgoto free;\n\t}\n\n\tret = action_parse(tr, str, data, HANDLER_ONMATCH);\n\tif (ret)\n\t\tgoto free;\n out:\n\treturn data;\n free:\n\tonmatch_destroy(data);\n\tdata = ERR_PTR(ret);\n\tgoto out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "str_has_prefix",
          "args": [
            "str",
            "\"onmatch(\""
          ],
          "line": 4580
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);\n\nstatic int parse_actions(struct hist_trigger_data *hist_data)\n{\n\tstruct trace_array *tr = hist_data->event_file->tr;\n\tstruct action_data *data;\n\tunsigned int i;\n\tint ret = 0;\n\tchar *str;\n\tint len;\n\n\tfor (i = 0; i < hist_data->attrs->n_actions; i++) {\n\t\tstr = hist_data->attrs->action_str[i];\n\n\t\tif ((len = str_has_prefix(str, \"onmatch(\"))) {\n\t\t\tchar *action_str = str + len;\n\n\t\t\tdata = onmatch_parse(tr, action_str);\n\t\t\tif (IS_ERR(data)) {\n\t\t\t\tret = PTR_ERR(data);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else if ((len = str_has_prefix(str, \"onmax(\"))) {\n\t\t\tchar *action_str = str + len;\n\n\t\t\tdata = track_data_parse(hist_data, action_str,\n\t\t\t\t\t\tHANDLER_ONMAX);\n\t\t\tif (IS_ERR(data)) {\n\t\t\t\tret = PTR_ERR(data);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else if ((len = str_has_prefix(str, \"onchange(\"))) {\n\t\t\tchar *action_str = str + len;\n\n\t\t\tdata = track_data_parse(hist_data, action_str,\n\t\t\t\t\t\tHANDLER_ONCHANGE);\n\t\t\tif (IS_ERR(data)) {\n\t\t\t\tret = PTR_ERR(data);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\thist_data->actions[hist_data->n_actions++] = data;\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "destroy_actions",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
    "lines": "4551-4566",
    "snippet": "static void destroy_actions(struct hist_trigger_data *hist_data)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < hist_data->n_actions; i++) {\n\t\tstruct action_data *data = hist_data->actions[i];\n\n\t\tif (data->handler == HANDLER_ONMATCH)\n\t\t\tonmatch_destroy(data);\n\t\telse if (data->handler == HANDLER_ONMAX ||\n\t\t\t data->handler == HANDLER_ONCHANGE)\n\t\t\ttrack_data_destroy(hist_data, data);\n\t\telse\n\t\t\tkfree(data);\n\t}\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include \"tracing_map.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "data"
          ],
          "line": 4564
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "track_data_destroy",
          "args": [
            "hist_data",
            "data"
          ],
          "line": 4562
        },
        "resolved": true,
        "details": {
          "function_name": "track_data_destroy",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "3454-3474",
          "snippet": "static void track_data_destroy(struct hist_trigger_data *hist_data,\n\t\t\t       struct action_data *data)\n{\n\tstruct trace_event_file *file = hist_data->event_file;\n\n\tdestroy_hist_field(data->track_data.track_var, 0);\n\n\tif (data->action == ACTION_SNAPSHOT) {\n\t\tstruct track_data *track_data;\n\n\t\ttrack_data = tracing_cond_snapshot_data(file->tr);\n\t\tif (track_data && track_data->hist_data == hist_data) {\n\t\t\ttracing_snapshot_cond_disable(file->tr);\n\t\t\ttrack_data_free(track_data);\n\t\t}\n\t}\n\n\tkfree(data->track_data.var_str);\n\n\taction_data_destroy(data);\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);\n\nstatic void track_data_destroy(struct hist_trigger_data *hist_data,\n\t\t\t       struct action_data *data)\n{\n\tstruct trace_event_file *file = hist_data->event_file;\n\n\tdestroy_hist_field(data->track_data.track_var, 0);\n\n\tif (data->action == ACTION_SNAPSHOT) {\n\t\tstruct track_data *track_data;\n\n\t\ttrack_data = tracing_cond_snapshot_data(file->tr);\n\t\tif (track_data && track_data->hist_data == hist_data) {\n\t\t\ttracing_snapshot_cond_disable(file->tr);\n\t\t\ttrack_data_free(track_data);\n\t\t}\n\t}\n\n\tkfree(data->track_data.var_str);\n\n\taction_data_destroy(data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "onmatch_destroy",
          "args": [
            "data"
          ],
          "line": 4559
        },
        "resolved": true,
        "details": {
          "function_name": "onmatch_destroy",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "3714-3720",
          "snippet": "static void onmatch_destroy(struct action_data *data)\n{\n\tkfree(data->match_data.event);\n\tkfree(data->match_data.event_system);\n\n\taction_data_destroy(data);\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);\n\nstatic void onmatch_destroy(struct action_data *data)\n{\n\tkfree(data->match_data.event);\n\tkfree(data->match_data.event_system);\n\n\taction_data_destroy(data);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);\n\nstatic void destroy_actions(struct hist_trigger_data *hist_data)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < hist_data->n_actions; i++) {\n\t\tstruct action_data *data = hist_data->actions[i];\n\n\t\tif (data->handler == HANDLER_ONMATCH)\n\t\t\tonmatch_destroy(data);\n\t\telse if (data->handler == HANDLER_ONMAX ||\n\t\t\t data->handler == HANDLER_ONCHANGE)\n\t\t\ttrack_data_destroy(hist_data, data);\n\t\telse\n\t\t\tkfree(data);\n\t}\n}"
  },
  {
    "function_name": "create_sort_keys",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
    "lines": "4464-4549",
    "snippet": "static int create_sort_keys(struct hist_trigger_data *hist_data)\n{\n\tstruct trace_array *tr = hist_data->event_file->tr;\n\tchar *fields_str = hist_data->attrs->sort_key_str;\n\tstruct tracing_map_sort_key *sort_key;\n\tint descending, ret = 0;\n\tunsigned int i, j, k;\n\n\thist_data->n_sort_keys = 1; /* we always have at least one, hitcount */\n\n\tif (!fields_str)\n\t\tgoto out;\n\n\tfor (i = 0; i < TRACING_MAP_SORT_KEYS_MAX; i++) {\n\t\tstruct hist_field *hist_field;\n\t\tchar *field_str, *field_name;\n\t\tconst char *test_name;\n\n\t\tsort_key = &hist_data->sort_keys[i];\n\n\t\tfield_str = strsep(&fields_str, \",\");\n\t\tif (!field_str)\n\t\t\tbreak;\n\n\t\tif (!*field_str) {\n\t\t\tret = -EINVAL;\n\t\t\thist_err(tr, HIST_ERR_EMPTY_SORT_FIELD, errpos(\"sort=\"));\n\t\t\tbreak;\n\t\t}\n\n\t\tif ((i == TRACING_MAP_SORT_KEYS_MAX - 1) && fields_str) {\n\t\t\thist_err(tr, HIST_ERR_TOO_MANY_SORT_FIELDS, errpos(\"sort=\"));\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tfield_name = strsep(&field_str, \".\");\n\t\tif (!field_name || !*field_name) {\n\t\t\tret = -EINVAL;\n\t\t\thist_err(tr, HIST_ERR_EMPTY_SORT_FIELD, errpos(\"sort=\"));\n\t\t\tbreak;\n\t\t}\n\n\t\tif (strcmp(field_name, \"hitcount\") == 0) {\n\t\t\tdescending = is_descending(tr, field_str);\n\t\t\tif (descending < 0) {\n\t\t\t\tret = descending;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsort_key->descending = descending;\n\t\t\tcontinue;\n\t\t}\n\n\t\tfor (j = 1, k = 1; j < hist_data->n_fields; j++) {\n\t\t\tunsigned int idx;\n\n\t\t\thist_field = hist_data->fields[j];\n\t\t\tif (hist_field->flags & HIST_FIELD_FL_VAR)\n\t\t\t\tcontinue;\n\n\t\t\tidx = k++;\n\n\t\t\ttest_name = hist_field_name(hist_field, 0);\n\n\t\t\tif (strcmp(field_name, test_name) == 0) {\n\t\t\t\tsort_key->field_idx = idx;\n\t\t\t\tdescending = is_descending(tr, field_str);\n\t\t\t\tif (descending < 0) {\n\t\t\t\t\tret = descending;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tsort_key->descending = descending;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (j == hist_data->n_fields) {\n\t\t\tret = -EINVAL;\n\t\t\thist_err(tr, HIST_ERR_INVALID_SORT_FIELD, errpos(field_name));\n\t\t\tbreak;\n\t\t}\n\t}\n\n\thist_data->n_sort_keys = i;\n out:\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include \"tracing_map.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hist_err",
          "args": [
            "tr",
            "HIST_ERR_INVALID_SORT_FIELD",
            "errpos(field_name)"
          ],
          "line": 4541
        },
        "resolved": true,
        "details": {
          "function_name": "hist_err",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "763-767",
          "snippet": "static void hist_err(struct trace_array *tr, u8 err_type, u8 err_pos)\n{\n\ttracing_log_err(tr, last_cmd_loc, last_cmd, err_text,\n\t\t\terr_type, err_pos);\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *err_text[] = { ERRORS };",
            "static char last_cmd[MAX_FILTER_STR_VAL];",
            "static char last_cmd_loc[MAX_FILTER_STR_VAL];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic const char *err_text[] = { ERRORS };\nstatic char last_cmd[MAX_FILTER_STR_VAL];\nstatic char last_cmd_loc[MAX_FILTER_STR_VAL];\n\nstatic void hist_err(struct trace_array *tr, u8 err_type, u8 err_pos)\n{\n\ttracing_log_err(tr, last_cmd_loc, last_cmd, err_text,\n\t\t\terr_type, err_pos);\n}"
        }
      },
      {
        "call_info": {
          "callee": "errpos",
          "args": [
            "field_name"
          ],
          "line": 4541
        },
        "resolved": true,
        "details": {
          "function_name": "errpos",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "733-736",
          "snippet": "static int errpos(char *str)\n{\n\treturn err_pos(last_cmd, str);\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char last_cmd[MAX_FILTER_STR_VAL];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic char last_cmd[MAX_FILTER_STR_VAL];\n\nstatic int errpos(char *str)\n{\n\treturn err_pos(last_cmd, str);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_descending",
          "args": [
            "tr",
            "field_str"
          ],
          "line": 4530
        },
        "resolved": true,
        "details": {
          "function_name": "is_descending",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "4448-4462",
          "snippet": "static int is_descending(struct trace_array *tr, const char *str)\n{\n\tif (!str)\n\t\treturn 0;\n\n\tif (strcmp(str, \"descending\") == 0)\n\t\treturn 1;\n\n\tif (strcmp(str, \"ascending\") == 0)\n\t\treturn 0;\n\n\thist_err(tr, HIST_ERR_INVALID_SORT_MODIFIER, errpos((char *)str));\n\n\treturn -EINVAL;\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int is_descending(struct trace_array *tr, const char *str)\n{\n\tif (!str)\n\t\treturn 0;\n\n\tif (strcmp(str, \"descending\") == 0)\n\t\treturn 1;\n\n\tif (strcmp(str, \"ascending\") == 0)\n\t\treturn 0;\n\n\thist_err(tr, HIST_ERR_INVALID_SORT_MODIFIER, errpos((char *)str));\n\n\treturn -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "field_name",
            "test_name"
          ],
          "line": 4528
        },
        "resolved": true,
        "details": {
          "function_name": "sym_strcmp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/report.c",
          "lines": "356-365",
          "snippet": "static int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}",
          "includes": [
            "#include \"encoding.h\"",
            "#include \"kcsan.h\"",
            "#include <linux/stacktrace.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/delay.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"encoding.h\"\n#include \"kcsan.h\"\n#include <linux/stacktrace.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/lockdep.h>\n#include <linux/kernel.h>\n#include <linux/kallsyms.h>\n#include <linux/jiffies.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n\nstatic int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}"
        }
      },
      {
        "call_info": {
          "callee": "hist_field_name",
          "args": [
            "hist_field",
            "0"
          ],
          "line": 4526
        },
        "resolved": true,
        "details": {
          "function_name": "hist_field_name",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "1280-1316",
          "snippet": "static const char *hist_field_name(struct hist_field *field,\n\t\t\t\t   unsigned int level)\n{\n\tconst char *field_name = \"\";\n\n\tif (level > 1)\n\t\treturn field_name;\n\n\tif (field->field)\n\t\tfield_name = field->field->name;\n\telse if (field->flags & HIST_FIELD_FL_LOG2 ||\n\t\t field->flags & HIST_FIELD_FL_ALIAS ||\n\t\t field->flags & HIST_FIELD_FL_BUCKET)\n\t\tfield_name = hist_field_name(field->operands[0], ++level);\n\telse if (field->flags & HIST_FIELD_FL_CPU)\n\t\tfield_name = \"common_cpu\";\n\telse if (field->flags & HIST_FIELD_FL_EXPR ||\n\t\t field->flags & HIST_FIELD_FL_VAR_REF) {\n\t\tif (field->system) {\n\t\t\tstatic char full_name[MAX_FILTER_STR_VAL];\n\n\t\t\tstrcat(full_name, field->system);\n\t\t\tstrcat(full_name, \".\");\n\t\t\tstrcat(full_name, field->event_name);\n\t\t\tstrcat(full_name, \".\");\n\t\t\tstrcat(full_name, field->name);\n\t\t\tfield_name = full_name;\n\t\t} else\n\t\t\tfield_name = field->name;\n\t} else if (field->flags & HIST_FIELD_FL_TIMESTAMP)\n\t\tfield_name = \"common_timestamp\";\n\n\tif (field_name == NULL)\n\t\tfield_name = \"\";\n\n\treturn field_name;\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic const char *hist_field_name(struct hist_field *field,\n\t\t\t\t   unsigned int level)\n{\n\tconst char *field_name = \"\";\n\n\tif (level > 1)\n\t\treturn field_name;\n\n\tif (field->field)\n\t\tfield_name = field->field->name;\n\telse if (field->flags & HIST_FIELD_FL_LOG2 ||\n\t\t field->flags & HIST_FIELD_FL_ALIAS ||\n\t\t field->flags & HIST_FIELD_FL_BUCKET)\n\t\tfield_name = hist_field_name(field->operands[0], ++level);\n\telse if (field->flags & HIST_FIELD_FL_CPU)\n\t\tfield_name = \"common_cpu\";\n\telse if (field->flags & HIST_FIELD_FL_EXPR ||\n\t\t field->flags & HIST_FIELD_FL_VAR_REF) {\n\t\tif (field->system) {\n\t\t\tstatic char full_name[MAX_FILTER_STR_VAL];\n\n\t\t\tstrcat(full_name, field->system);\n\t\t\tstrcat(full_name, \".\");\n\t\t\tstrcat(full_name, field->event_name);\n\t\t\tstrcat(full_name, \".\");\n\t\t\tstrcat(full_name, field->name);\n\t\t\tfield_name = full_name;\n\t\t} else\n\t\t\tfield_name = field->name;\n\t} else if (field->flags & HIST_FIELD_FL_TIMESTAMP)\n\t\tfield_name = \"common_timestamp\";\n\n\tif (field_name == NULL)\n\t\tfield_name = \"\";\n\n\treturn field_name;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strsep",
          "args": [
            "&field_str",
            "\".\""
          ],
          "line": 4500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strsep",
          "args": [
            "&fields_str",
            "\",\""
          ],
          "line": 4484
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int create_sort_keys(struct hist_trigger_data *hist_data)\n{\n\tstruct trace_array *tr = hist_data->event_file->tr;\n\tchar *fields_str = hist_data->attrs->sort_key_str;\n\tstruct tracing_map_sort_key *sort_key;\n\tint descending, ret = 0;\n\tunsigned int i, j, k;\n\n\thist_data->n_sort_keys = 1; /* we always have at least one, hitcount */\n\n\tif (!fields_str)\n\t\tgoto out;\n\n\tfor (i = 0; i < TRACING_MAP_SORT_KEYS_MAX; i++) {\n\t\tstruct hist_field *hist_field;\n\t\tchar *field_str, *field_name;\n\t\tconst char *test_name;\n\n\t\tsort_key = &hist_data->sort_keys[i];\n\n\t\tfield_str = strsep(&fields_str, \",\");\n\t\tif (!field_str)\n\t\t\tbreak;\n\n\t\tif (!*field_str) {\n\t\t\tret = -EINVAL;\n\t\t\thist_err(tr, HIST_ERR_EMPTY_SORT_FIELD, errpos(\"sort=\"));\n\t\t\tbreak;\n\t\t}\n\n\t\tif ((i == TRACING_MAP_SORT_KEYS_MAX - 1) && fields_str) {\n\t\t\thist_err(tr, HIST_ERR_TOO_MANY_SORT_FIELDS, errpos(\"sort=\"));\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tfield_name = strsep(&field_str, \".\");\n\t\tif (!field_name || !*field_name) {\n\t\t\tret = -EINVAL;\n\t\t\thist_err(tr, HIST_ERR_EMPTY_SORT_FIELD, errpos(\"sort=\"));\n\t\t\tbreak;\n\t\t}\n\n\t\tif (strcmp(field_name, \"hitcount\") == 0) {\n\t\t\tdescending = is_descending(tr, field_str);\n\t\t\tif (descending < 0) {\n\t\t\t\tret = descending;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsort_key->descending = descending;\n\t\t\tcontinue;\n\t\t}\n\n\t\tfor (j = 1, k = 1; j < hist_data->n_fields; j++) {\n\t\t\tunsigned int idx;\n\n\t\t\thist_field = hist_data->fields[j];\n\t\t\tif (hist_field->flags & HIST_FIELD_FL_VAR)\n\t\t\t\tcontinue;\n\n\t\t\tidx = k++;\n\n\t\t\ttest_name = hist_field_name(hist_field, 0);\n\n\t\t\tif (strcmp(field_name, test_name) == 0) {\n\t\t\t\tsort_key->field_idx = idx;\n\t\t\t\tdescending = is_descending(tr, field_str);\n\t\t\t\tif (descending < 0) {\n\t\t\t\t\tret = descending;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tsort_key->descending = descending;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (j == hist_data->n_fields) {\n\t\t\tret = -EINVAL;\n\t\t\thist_err(tr, HIST_ERR_INVALID_SORT_FIELD, errpos(field_name));\n\t\t\tbreak;\n\t\t}\n\t}\n\n\thist_data->n_sort_keys = i;\n out:\n\treturn ret;\n}"
  },
  {
    "function_name": "is_descending",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
    "lines": "4448-4462",
    "snippet": "static int is_descending(struct trace_array *tr, const char *str)\n{\n\tif (!str)\n\t\treturn 0;\n\n\tif (strcmp(str, \"descending\") == 0)\n\t\treturn 1;\n\n\tif (strcmp(str, \"ascending\") == 0)\n\t\treturn 0;\n\n\thist_err(tr, HIST_ERR_INVALID_SORT_MODIFIER, errpos((char *)str));\n\n\treturn -EINVAL;\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include \"tracing_map.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hist_err",
          "args": [
            "tr",
            "HIST_ERR_INVALID_SORT_MODIFIER",
            "errpos((char *)str)"
          ],
          "line": 4459
        },
        "resolved": true,
        "details": {
          "function_name": "hist_err",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "763-767",
          "snippet": "static void hist_err(struct trace_array *tr, u8 err_type, u8 err_pos)\n{\n\ttracing_log_err(tr, last_cmd_loc, last_cmd, err_text,\n\t\t\terr_type, err_pos);\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *err_text[] = { ERRORS };",
            "static char last_cmd[MAX_FILTER_STR_VAL];",
            "static char last_cmd_loc[MAX_FILTER_STR_VAL];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic const char *err_text[] = { ERRORS };\nstatic char last_cmd[MAX_FILTER_STR_VAL];\nstatic char last_cmd_loc[MAX_FILTER_STR_VAL];\n\nstatic void hist_err(struct trace_array *tr, u8 err_type, u8 err_pos)\n{\n\ttracing_log_err(tr, last_cmd_loc, last_cmd, err_text,\n\t\t\terr_type, err_pos);\n}"
        }
      },
      {
        "call_info": {
          "callee": "errpos",
          "args": [
            "(char *)str"
          ],
          "line": 4459
        },
        "resolved": true,
        "details": {
          "function_name": "errpos",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "733-736",
          "snippet": "static int errpos(char *str)\n{\n\treturn err_pos(last_cmd, str);\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char last_cmd[MAX_FILTER_STR_VAL];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic char last_cmd[MAX_FILTER_STR_VAL];\n\nstatic int errpos(char *str)\n{\n\treturn err_pos(last_cmd, str);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "str",
            "\"ascending\""
          ],
          "line": 4456
        },
        "resolved": true,
        "details": {
          "function_name": "sym_strcmp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/report.c",
          "lines": "356-365",
          "snippet": "static int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}",
          "includes": [
            "#include \"encoding.h\"",
            "#include \"kcsan.h\"",
            "#include <linux/stacktrace.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/delay.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"encoding.h\"\n#include \"kcsan.h\"\n#include <linux/stacktrace.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/lockdep.h>\n#include <linux/kernel.h>\n#include <linux/kallsyms.h>\n#include <linux/jiffies.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n\nstatic int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int is_descending(struct trace_array *tr, const char *str)\n{\n\tif (!str)\n\t\treturn 0;\n\n\tif (strcmp(str, \"descending\") == 0)\n\t\treturn 1;\n\n\tif (strcmp(str, \"ascending\") == 0)\n\t\treturn 0;\n\n\thist_err(tr, HIST_ERR_INVALID_SORT_MODIFIER, errpos((char *)str));\n\n\treturn -EINVAL;\n}"
  },
  {
    "function_name": "create_hist_fields",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
    "lines": "4422-4446",
    "snippet": "static int create_hist_fields(struct hist_trigger_data *hist_data,\n\t\t\t      struct trace_event_file *file)\n{\n\tint ret;\n\n\tret = parse_var_defs(hist_data);\n\tif (ret)\n\t\tgoto out;\n\n\tret = create_val_fields(hist_data, file);\n\tif (ret)\n\t\tgoto out;\n\n\tret = create_var_fields(hist_data, file);\n\tif (ret)\n\t\tgoto out;\n\n\tret = create_key_fields(hist_data, file);\n\tif (ret)\n\t\tgoto out;\n out:\n\tfree_var_defs(hist_data);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include \"tracing_map.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_var_defs",
          "args": [
            "hist_data"
          ],
          "line": 4443
        },
        "resolved": true,
        "details": {
          "function_name": "free_var_defs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "4357-4367",
          "snippet": "static void free_var_defs(struct hist_trigger_data *hist_data)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < hist_data->attrs->var_defs.n_vars; i++) {\n\t\tkfree(hist_data->attrs->var_defs.name[i]);\n\t\tkfree(hist_data->attrs->var_defs.expr[i]);\n\t}\n\n\thist_data->attrs->var_defs.n_vars = 0;\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void free_var_defs(struct hist_trigger_data *hist_data)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < hist_data->attrs->var_defs.n_vars; i++) {\n\t\tkfree(hist_data->attrs->var_defs.name[i]);\n\t\tkfree(hist_data->attrs->var_defs.expr[i]);\n\t}\n\n\thist_data->attrs->var_defs.n_vars = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "create_key_fields",
          "args": [
            "hist_data",
            "file"
          ],
          "line": 4439
        },
        "resolved": true,
        "details": {
          "function_name": "create_key_fields",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "4307-4335",
          "snippet": "static int create_key_fields(struct hist_trigger_data *hist_data,\n\t\t\t     struct trace_event_file *file)\n{\n\tunsigned int i, key_offset = 0, n_vals = hist_data->n_vals;\n\tchar *fields_str, *field_str;\n\tint ret = -EINVAL;\n\n\tfields_str = hist_data->attrs->keys_str;\n\tif (!fields_str)\n\t\tgoto out;\n\n\tfor (i = n_vals; i < n_vals + TRACING_MAP_KEYS_MAX; i++) {\n\t\tfield_str = strsep(&fields_str, \",\");\n\t\tif (!field_str)\n\t\t\tbreak;\n\t\tret = create_key_field(hist_data, i, key_offset,\n\t\t\t\t       file, field_str);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tkey_offset += ret;\n\t}\n\tif (fields_str) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\tret = 0;\n out:\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int create_key_fields(struct hist_trigger_data *hist_data,\n\t\t\t     struct trace_event_file *file)\n{\n\tunsigned int i, key_offset = 0, n_vals = hist_data->n_vals;\n\tchar *fields_str, *field_str;\n\tint ret = -EINVAL;\n\n\tfields_str = hist_data->attrs->keys_str;\n\tif (!fields_str)\n\t\tgoto out;\n\n\tfor (i = n_vals; i < n_vals + TRACING_MAP_KEYS_MAX; i++) {\n\t\tfield_str = strsep(&fields_str, \",\");\n\t\tif (!field_str)\n\t\t\tbreak;\n\t\tret = create_key_field(hist_data, i, key_offset,\n\t\t\t\t       file, field_str);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tkey_offset += ret;\n\t}\n\tif (fields_str) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\tret = 0;\n out:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "create_var_fields",
          "args": [
            "hist_data",
            "file"
          ],
          "line": 4435
        },
        "resolved": true,
        "details": {
          "function_name": "create_var_fields",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "4337-4355",
          "snippet": "static int create_var_fields(struct hist_trigger_data *hist_data,\n\t\t\t     struct trace_event_file *file)\n{\n\tunsigned int i, j = hist_data->n_vals;\n\tint ret = 0;\n\n\tunsigned int n_vars = hist_data->attrs->var_defs.n_vars;\n\n\tfor (i = 0; i < n_vars; i++) {\n\t\tchar *var_name = hist_data->attrs->var_defs.name[i];\n\t\tchar *expr = hist_data->attrs->var_defs.expr[i];\n\n\t\tret = create_var_field(hist_data, j++, file, var_name, expr);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n out:\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int create_var_fields(struct hist_trigger_data *hist_data,\n\t\t\t     struct trace_event_file *file)\n{\n\tunsigned int i, j = hist_data->n_vals;\n\tint ret = 0;\n\n\tunsigned int n_vars = hist_data->attrs->var_defs.n_vars;\n\n\tfor (i = 0; i < n_vars; i++) {\n\t\tchar *var_name = hist_data->attrs->var_defs.name[i];\n\t\tchar *expr = hist_data->attrs->var_defs.expr[i];\n\n\t\tret = create_var_field(hist_data, j++, file, var_name, expr);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n out:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "create_val_fields",
          "args": [
            "hist_data",
            "file"
          ],
          "line": 4431
        },
        "resolved": true,
        "details": {
          "function_name": "create_val_fields",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "4209-4242",
          "snippet": "static int create_val_fields(struct hist_trigger_data *hist_data,\n\t\t\t     struct trace_event_file *file)\n{\n\tchar *fields_str, *field_str;\n\tunsigned int i, j = 1;\n\tint ret;\n\n\tret = create_hitcount_val(hist_data);\n\tif (ret)\n\t\tgoto out;\n\n\tfields_str = hist_data->attrs->vals_str;\n\tif (!fields_str)\n\t\tgoto out;\n\n\tfor (i = 0, j = 1; i < TRACING_MAP_VALS_MAX &&\n\t\t     j < TRACING_MAP_VALS_MAX; i++) {\n\t\tfield_str = strsep(&fields_str, \",\");\n\t\tif (!field_str)\n\t\t\tbreak;\n\n\t\tif (strcmp(field_str, \"hitcount\") == 0)\n\t\t\tcontinue;\n\n\t\tret = create_val_field(hist_data, j++, file, field_str);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\tif (fields_str && (strcmp(fields_str, \"hitcount\") != 0))\n\t\tret = -EINVAL;\n out:\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int create_val_fields(struct hist_trigger_data *hist_data,\n\t\t\t     struct trace_event_file *file)\n{\n\tchar *fields_str, *field_str;\n\tunsigned int i, j = 1;\n\tint ret;\n\n\tret = create_hitcount_val(hist_data);\n\tif (ret)\n\t\tgoto out;\n\n\tfields_str = hist_data->attrs->vals_str;\n\tif (!fields_str)\n\t\tgoto out;\n\n\tfor (i = 0, j = 1; i < TRACING_MAP_VALS_MAX &&\n\t\t     j < TRACING_MAP_VALS_MAX; i++) {\n\t\tfield_str = strsep(&fields_str, \",\");\n\t\tif (!field_str)\n\t\t\tbreak;\n\n\t\tif (strcmp(field_str, \"hitcount\") == 0)\n\t\t\tcontinue;\n\n\t\tret = create_val_field(hist_data, j++, file, field_str);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\tif (fields_str && (strcmp(fields_str, \"hitcount\") != 0))\n\t\tret = -EINVAL;\n out:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "parse_var_defs",
          "args": [
            "hist_data"
          ],
          "line": 4427
        },
        "resolved": true,
        "details": {
          "function_name": "parse_var_defs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "4369-4420",
          "snippet": "static int parse_var_defs(struct hist_trigger_data *hist_data)\n{\n\tstruct trace_array *tr = hist_data->event_file->tr;\n\tchar *s, *str, *var_name, *field_str;\n\tunsigned int i, j, n_vars = 0;\n\tint ret = 0;\n\n\tfor (i = 0; i < hist_data->attrs->n_assignments; i++) {\n\t\tstr = hist_data->attrs->assignment_str[i];\n\t\tfor (j = 0; j < TRACING_MAP_VARS_MAX; j++) {\n\t\t\tfield_str = strsep(&str, \",\");\n\t\t\tif (!field_str)\n\t\t\t\tbreak;\n\n\t\t\tvar_name = strsep(&field_str, \"=\");\n\t\t\tif (!var_name || !field_str) {\n\t\t\t\thist_err(tr, HIST_ERR_MALFORMED_ASSIGNMENT,\n\t\t\t\t\t errpos(var_name));\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto free;\n\t\t\t}\n\n\t\t\tif (n_vars == TRACING_MAP_VARS_MAX) {\n\t\t\t\thist_err(tr, HIST_ERR_TOO_MANY_VARS, errpos(var_name));\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto free;\n\t\t\t}\n\n\t\t\ts = kstrdup(var_name, GFP_KERNEL);\n\t\t\tif (!s) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto free;\n\t\t\t}\n\t\t\thist_data->attrs->var_defs.name[n_vars] = s;\n\n\t\t\ts = kstrdup(field_str, GFP_KERNEL);\n\t\t\tif (!s) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto free;\n\t\t\t}\n\t\t\thist_data->attrs->var_defs.expr[n_vars++] = s;\n\n\t\t\thist_data->attrs->var_defs.n_vars = n_vars;\n\t\t}\n\t}\n\n\treturn ret;\n free:\n\tfree_var_defs(hist_data);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int parse_var_defs(struct hist_trigger_data *hist_data)\n{\n\tstruct trace_array *tr = hist_data->event_file->tr;\n\tchar *s, *str, *var_name, *field_str;\n\tunsigned int i, j, n_vars = 0;\n\tint ret = 0;\n\n\tfor (i = 0; i < hist_data->attrs->n_assignments; i++) {\n\t\tstr = hist_data->attrs->assignment_str[i];\n\t\tfor (j = 0; j < TRACING_MAP_VARS_MAX; j++) {\n\t\t\tfield_str = strsep(&str, \",\");\n\t\t\tif (!field_str)\n\t\t\t\tbreak;\n\n\t\t\tvar_name = strsep(&field_str, \"=\");\n\t\t\tif (!var_name || !field_str) {\n\t\t\t\thist_err(tr, HIST_ERR_MALFORMED_ASSIGNMENT,\n\t\t\t\t\t errpos(var_name));\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto free;\n\t\t\t}\n\n\t\t\tif (n_vars == TRACING_MAP_VARS_MAX) {\n\t\t\t\thist_err(tr, HIST_ERR_TOO_MANY_VARS, errpos(var_name));\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto free;\n\t\t\t}\n\n\t\t\ts = kstrdup(var_name, GFP_KERNEL);\n\t\t\tif (!s) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto free;\n\t\t\t}\n\t\t\thist_data->attrs->var_defs.name[n_vars] = s;\n\n\t\t\ts = kstrdup(field_str, GFP_KERNEL);\n\t\t\tif (!s) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto free;\n\t\t\t}\n\t\t\thist_data->attrs->var_defs.expr[n_vars++] = s;\n\n\t\t\thist_data->attrs->var_defs.n_vars = n_vars;\n\t\t}\n\t}\n\n\treturn ret;\n free:\n\tfree_var_defs(hist_data);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int create_hist_fields(struct hist_trigger_data *hist_data,\n\t\t\t      struct trace_event_file *file)\n{\n\tint ret;\n\n\tret = parse_var_defs(hist_data);\n\tif (ret)\n\t\tgoto out;\n\n\tret = create_val_fields(hist_data, file);\n\tif (ret)\n\t\tgoto out;\n\n\tret = create_var_fields(hist_data, file);\n\tif (ret)\n\t\tgoto out;\n\n\tret = create_key_fields(hist_data, file);\n\tif (ret)\n\t\tgoto out;\n out:\n\tfree_var_defs(hist_data);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "parse_var_defs",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
    "lines": "4369-4420",
    "snippet": "static int parse_var_defs(struct hist_trigger_data *hist_data)\n{\n\tstruct trace_array *tr = hist_data->event_file->tr;\n\tchar *s, *str, *var_name, *field_str;\n\tunsigned int i, j, n_vars = 0;\n\tint ret = 0;\n\n\tfor (i = 0; i < hist_data->attrs->n_assignments; i++) {\n\t\tstr = hist_data->attrs->assignment_str[i];\n\t\tfor (j = 0; j < TRACING_MAP_VARS_MAX; j++) {\n\t\t\tfield_str = strsep(&str, \",\");\n\t\t\tif (!field_str)\n\t\t\t\tbreak;\n\n\t\t\tvar_name = strsep(&field_str, \"=\");\n\t\t\tif (!var_name || !field_str) {\n\t\t\t\thist_err(tr, HIST_ERR_MALFORMED_ASSIGNMENT,\n\t\t\t\t\t errpos(var_name));\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto free;\n\t\t\t}\n\n\t\t\tif (n_vars == TRACING_MAP_VARS_MAX) {\n\t\t\t\thist_err(tr, HIST_ERR_TOO_MANY_VARS, errpos(var_name));\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto free;\n\t\t\t}\n\n\t\t\ts = kstrdup(var_name, GFP_KERNEL);\n\t\t\tif (!s) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto free;\n\t\t\t}\n\t\t\thist_data->attrs->var_defs.name[n_vars] = s;\n\n\t\t\ts = kstrdup(field_str, GFP_KERNEL);\n\t\t\tif (!s) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto free;\n\t\t\t}\n\t\t\thist_data->attrs->var_defs.expr[n_vars++] = s;\n\n\t\t\thist_data->attrs->var_defs.n_vars = n_vars;\n\t\t}\n\t}\n\n\treturn ret;\n free:\n\tfree_var_defs(hist_data);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include \"tracing_map.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_var_defs",
          "args": [
            "hist_data"
          ],
          "line": 4417
        },
        "resolved": true,
        "details": {
          "function_name": "free_var_defs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "4357-4367",
          "snippet": "static void free_var_defs(struct hist_trigger_data *hist_data)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < hist_data->attrs->var_defs.n_vars; i++) {\n\t\tkfree(hist_data->attrs->var_defs.name[i]);\n\t\tkfree(hist_data->attrs->var_defs.expr[i]);\n\t}\n\n\thist_data->attrs->var_defs.n_vars = 0;\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void free_var_defs(struct hist_trigger_data *hist_data)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < hist_data->attrs->var_defs.n_vars; i++) {\n\t\tkfree(hist_data->attrs->var_defs.name[i]);\n\t\tkfree(hist_data->attrs->var_defs.expr[i]);\n\t}\n\n\thist_data->attrs->var_defs.n_vars = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "field_str",
            "GFP_KERNEL"
          ],
          "line": 4404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "var_name",
            "GFP_KERNEL"
          ],
          "line": 4397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hist_err",
          "args": [
            "tr",
            "HIST_ERR_TOO_MANY_VARS",
            "errpos(var_name)"
          ],
          "line": 4392
        },
        "resolved": true,
        "details": {
          "function_name": "hist_err",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "763-767",
          "snippet": "static void hist_err(struct trace_array *tr, u8 err_type, u8 err_pos)\n{\n\ttracing_log_err(tr, last_cmd_loc, last_cmd, err_text,\n\t\t\terr_type, err_pos);\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *err_text[] = { ERRORS };",
            "static char last_cmd[MAX_FILTER_STR_VAL];",
            "static char last_cmd_loc[MAX_FILTER_STR_VAL];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic const char *err_text[] = { ERRORS };\nstatic char last_cmd[MAX_FILTER_STR_VAL];\nstatic char last_cmd_loc[MAX_FILTER_STR_VAL];\n\nstatic void hist_err(struct trace_array *tr, u8 err_type, u8 err_pos)\n{\n\ttracing_log_err(tr, last_cmd_loc, last_cmd, err_text,\n\t\t\terr_type, err_pos);\n}"
        }
      },
      {
        "call_info": {
          "callee": "errpos",
          "args": [
            "var_name"
          ],
          "line": 4392
        },
        "resolved": true,
        "details": {
          "function_name": "errpos",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "733-736",
          "snippet": "static int errpos(char *str)\n{\n\treturn err_pos(last_cmd, str);\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char last_cmd[MAX_FILTER_STR_VAL];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic char last_cmd[MAX_FILTER_STR_VAL];\n\nstatic int errpos(char *str)\n{\n\treturn err_pos(last_cmd, str);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strsep",
          "args": [
            "&field_str",
            "\"=\""
          ],
          "line": 4383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strsep",
          "args": [
            "&str",
            "\",\""
          ],
          "line": 4379
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int parse_var_defs(struct hist_trigger_data *hist_data)\n{\n\tstruct trace_array *tr = hist_data->event_file->tr;\n\tchar *s, *str, *var_name, *field_str;\n\tunsigned int i, j, n_vars = 0;\n\tint ret = 0;\n\n\tfor (i = 0; i < hist_data->attrs->n_assignments; i++) {\n\t\tstr = hist_data->attrs->assignment_str[i];\n\t\tfor (j = 0; j < TRACING_MAP_VARS_MAX; j++) {\n\t\t\tfield_str = strsep(&str, \",\");\n\t\t\tif (!field_str)\n\t\t\t\tbreak;\n\n\t\t\tvar_name = strsep(&field_str, \"=\");\n\t\t\tif (!var_name || !field_str) {\n\t\t\t\thist_err(tr, HIST_ERR_MALFORMED_ASSIGNMENT,\n\t\t\t\t\t errpos(var_name));\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto free;\n\t\t\t}\n\n\t\t\tif (n_vars == TRACING_MAP_VARS_MAX) {\n\t\t\t\thist_err(tr, HIST_ERR_TOO_MANY_VARS, errpos(var_name));\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto free;\n\t\t\t}\n\n\t\t\ts = kstrdup(var_name, GFP_KERNEL);\n\t\t\tif (!s) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto free;\n\t\t\t}\n\t\t\thist_data->attrs->var_defs.name[n_vars] = s;\n\n\t\t\ts = kstrdup(field_str, GFP_KERNEL);\n\t\t\tif (!s) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto free;\n\t\t\t}\n\t\t\thist_data->attrs->var_defs.expr[n_vars++] = s;\n\n\t\t\thist_data->attrs->var_defs.n_vars = n_vars;\n\t\t}\n\t}\n\n\treturn ret;\n free:\n\tfree_var_defs(hist_data);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "free_var_defs",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
    "lines": "4357-4367",
    "snippet": "static void free_var_defs(struct hist_trigger_data *hist_data)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < hist_data->attrs->var_defs.n_vars; i++) {\n\t\tkfree(hist_data->attrs->var_defs.name[i]);\n\t\tkfree(hist_data->attrs->var_defs.expr[i]);\n\t}\n\n\thist_data->attrs->var_defs.n_vars = 0;\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include \"tracing_map.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "hist_data->attrs->var_defs.expr[i]"
          ],
          "line": 4363
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void free_var_defs(struct hist_trigger_data *hist_data)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < hist_data->attrs->var_defs.n_vars; i++) {\n\t\tkfree(hist_data->attrs->var_defs.name[i]);\n\t\tkfree(hist_data->attrs->var_defs.expr[i]);\n\t}\n\n\thist_data->attrs->var_defs.n_vars = 0;\n}"
  },
  {
    "function_name": "create_var_fields",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
    "lines": "4337-4355",
    "snippet": "static int create_var_fields(struct hist_trigger_data *hist_data,\n\t\t\t     struct trace_event_file *file)\n{\n\tunsigned int i, j = hist_data->n_vals;\n\tint ret = 0;\n\n\tunsigned int n_vars = hist_data->attrs->var_defs.n_vars;\n\n\tfor (i = 0; i < n_vars; i++) {\n\t\tchar *var_name = hist_data->attrs->var_defs.name[i];\n\t\tchar *expr = hist_data->attrs->var_defs.expr[i];\n\n\t\tret = create_var_field(hist_data, j++, file, var_name, expr);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n out:\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include \"tracing_map.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "create_var_field",
          "args": [
            "hist_data",
            "j++",
            "file",
            "var_name",
            "expr"
          ],
          "line": 4349
        },
        "resolved": true,
        "details": {
          "function_name": "create_var_field",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "4176-4207",
          "snippet": "static int create_var_field(struct hist_trigger_data *hist_data,\n\t\t\t    unsigned int val_idx,\n\t\t\t    struct trace_event_file *file,\n\t\t\t    char *var_name, char *expr_str)\n{\n\tstruct trace_array *tr = hist_data->event_file->tr;\n\tunsigned long flags = 0;\n\tint ret;\n\n\tif (WARN_ON(val_idx >= TRACING_MAP_VALS_MAX + TRACING_MAP_VARS_MAX))\n\t\treturn -EINVAL;\n\n\tif (find_var(hist_data, file, var_name) && !hist_data->remove) {\n\t\thist_err(tr, HIST_ERR_DUPLICATE_VAR, errpos(var_name));\n\t\treturn -EINVAL;\n\t}\n\n\tflags |= HIST_FIELD_FL_VAR;\n\thist_data->n_vars++;\n\tif (WARN_ON(hist_data->n_vars > TRACING_MAP_VARS_MAX))\n\t\treturn -EINVAL;\n\n\tret = __create_val_field(hist_data, val_idx, file, var_name, expr_str, flags);\n\n\tif (!ret && hist_data->fields[val_idx]->flags & HIST_FIELD_FL_EXECNAME)\n\t\tupdate_var_execname(hist_data->fields[val_idx]);\n\n\tif (!ret && hist_data->fields[val_idx]->flags & HIST_FIELD_FL_STRING)\n\t\thist_data->fields[val_idx]->var_str_idx = hist_data->n_var_str++;\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int create_var_field(struct hist_trigger_data *hist_data,\n\t\t\t    unsigned int val_idx,\n\t\t\t    struct trace_event_file *file,\n\t\t\t    char *var_name, char *expr_str)\n{\n\tstruct trace_array *tr = hist_data->event_file->tr;\n\tunsigned long flags = 0;\n\tint ret;\n\n\tif (WARN_ON(val_idx >= TRACING_MAP_VALS_MAX + TRACING_MAP_VARS_MAX))\n\t\treturn -EINVAL;\n\n\tif (find_var(hist_data, file, var_name) && !hist_data->remove) {\n\t\thist_err(tr, HIST_ERR_DUPLICATE_VAR, errpos(var_name));\n\t\treturn -EINVAL;\n\t}\n\n\tflags |= HIST_FIELD_FL_VAR;\n\thist_data->n_vars++;\n\tif (WARN_ON(hist_data->n_vars > TRACING_MAP_VARS_MAX))\n\t\treturn -EINVAL;\n\n\tret = __create_val_field(hist_data, val_idx, file, var_name, expr_str, flags);\n\n\tif (!ret && hist_data->fields[val_idx]->flags & HIST_FIELD_FL_EXECNAME)\n\t\tupdate_var_execname(hist_data->fields[val_idx]);\n\n\tif (!ret && hist_data->fields[val_idx]->flags & HIST_FIELD_FL_STRING)\n\t\thist_data->fields[val_idx]->var_str_idx = hist_data->n_var_str++;\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int create_var_fields(struct hist_trigger_data *hist_data,\n\t\t\t     struct trace_event_file *file)\n{\n\tunsigned int i, j = hist_data->n_vals;\n\tint ret = 0;\n\n\tunsigned int n_vars = hist_data->attrs->var_defs.n_vars;\n\n\tfor (i = 0; i < n_vars; i++) {\n\t\tchar *var_name = hist_data->attrs->var_defs.name[i];\n\t\tchar *expr = hist_data->attrs->var_defs.expr[i];\n\n\t\tret = create_var_field(hist_data, j++, file, var_name, expr);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n out:\n\treturn ret;\n}"
  },
  {
    "function_name": "create_key_fields",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
    "lines": "4307-4335",
    "snippet": "static int create_key_fields(struct hist_trigger_data *hist_data,\n\t\t\t     struct trace_event_file *file)\n{\n\tunsigned int i, key_offset = 0, n_vals = hist_data->n_vals;\n\tchar *fields_str, *field_str;\n\tint ret = -EINVAL;\n\n\tfields_str = hist_data->attrs->keys_str;\n\tif (!fields_str)\n\t\tgoto out;\n\n\tfor (i = n_vals; i < n_vals + TRACING_MAP_KEYS_MAX; i++) {\n\t\tfield_str = strsep(&fields_str, \",\");\n\t\tif (!field_str)\n\t\t\tbreak;\n\t\tret = create_key_field(hist_data, i, key_offset,\n\t\t\t\t       file, field_str);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tkey_offset += ret;\n\t}\n\tif (fields_str) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\tret = 0;\n out:\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include \"tracing_map.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "create_key_field",
          "args": [
            "hist_data",
            "i",
            "key_offset",
            "file",
            "field_str"
          ],
          "line": 4322
        },
        "resolved": true,
        "details": {
          "function_name": "create_key_field",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "4244-4305",
          "snippet": "static int create_key_field(struct hist_trigger_data *hist_data,\n\t\t\t    unsigned int key_idx,\n\t\t\t    unsigned int key_offset,\n\t\t\t    struct trace_event_file *file,\n\t\t\t    char *field_str)\n{\n\tstruct trace_array *tr = hist_data->event_file->tr;\n\tstruct hist_field *hist_field = NULL;\n\tunsigned long flags = 0;\n\tunsigned int key_size;\n\tint ret = 0, n_subexprs = 0;\n\n\tif (WARN_ON(key_idx >= HIST_FIELDS_MAX))\n\t\treturn -EINVAL;\n\n\tflags |= HIST_FIELD_FL_KEY;\n\n\tif (strcmp(field_str, \"stacktrace\") == 0) {\n\t\tflags |= HIST_FIELD_FL_STACKTRACE;\n\t\tkey_size = sizeof(unsigned long) * HIST_STACKTRACE_DEPTH;\n\t\thist_field = create_hist_field(hist_data, NULL, flags, NULL);\n\t} else {\n\t\thist_field = parse_expr(hist_data, file, field_str, flags,\n\t\t\t\t\tNULL, &n_subexprs);\n\t\tif (IS_ERR(hist_field)) {\n\t\t\tret = PTR_ERR(hist_field);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (field_has_hist_vars(hist_field, 0))\t{\n\t\t\thist_err(tr, HIST_ERR_INVALID_REF_KEY, errpos(field_str));\n\t\t\tdestroy_hist_field(hist_field, 0);\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tkey_size = hist_field->size;\n\t}\n\n\thist_data->fields[key_idx] = hist_field;\n\n\tkey_size = ALIGN(key_size, sizeof(u64));\n\thist_data->fields[key_idx]->size = key_size;\n\thist_data->fields[key_idx]->offset = key_offset;\n\n\thist_data->key_size += key_size;\n\n\tif (hist_data->key_size > HIST_KEY_SIZE_MAX) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\thist_data->n_keys++;\n\thist_data->n_fields++;\n\n\tif (WARN_ON(hist_data->n_keys > TRACING_MAP_KEYS_MAX))\n\t\treturn -EINVAL;\n\n\tret = key_size;\n out:\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define HIST_KEY_SIZE_MAX\t(MAX_FILTER_STR_VAL + HIST_STACKTRACE_SIZE)",
            "#define HIST_STACKTRACE_DEPTH\t16",
            "#define HIST_FIELDS_MAX\t\t(TRACING_MAP_FIELDS_MAX + TRACING_MAP_VARS_MAX)"
          ],
          "globals_used": [
            "static struct hist_field *parse_expr(struct hist_trigger_data *hist_data,\n\t\t\t\t     struct trace_event_file *file,\n\t\t\t\t     char *str, unsigned long flags,\n\t\t\t\t     char *var_name, unsigned int *n_subexprs);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\n#define HIST_KEY_SIZE_MAX\t(MAX_FILTER_STR_VAL + HIST_STACKTRACE_SIZE)\n#define HIST_STACKTRACE_DEPTH\t16\n#define HIST_FIELDS_MAX\t\t(TRACING_MAP_FIELDS_MAX + TRACING_MAP_VARS_MAX)\n\nstatic struct hist_field *parse_expr(struct hist_trigger_data *hist_data,\n\t\t\t\t     struct trace_event_file *file,\n\t\t\t\t     char *str, unsigned long flags,\n\t\t\t\t     char *var_name, unsigned int *n_subexprs);\n\nstatic int create_key_field(struct hist_trigger_data *hist_data,\n\t\t\t    unsigned int key_idx,\n\t\t\t    unsigned int key_offset,\n\t\t\t    struct trace_event_file *file,\n\t\t\t    char *field_str)\n{\n\tstruct trace_array *tr = hist_data->event_file->tr;\n\tstruct hist_field *hist_field = NULL;\n\tunsigned long flags = 0;\n\tunsigned int key_size;\n\tint ret = 0, n_subexprs = 0;\n\n\tif (WARN_ON(key_idx >= HIST_FIELDS_MAX))\n\t\treturn -EINVAL;\n\n\tflags |= HIST_FIELD_FL_KEY;\n\n\tif (strcmp(field_str, \"stacktrace\") == 0) {\n\t\tflags |= HIST_FIELD_FL_STACKTRACE;\n\t\tkey_size = sizeof(unsigned long) * HIST_STACKTRACE_DEPTH;\n\t\thist_field = create_hist_field(hist_data, NULL, flags, NULL);\n\t} else {\n\t\thist_field = parse_expr(hist_data, file, field_str, flags,\n\t\t\t\t\tNULL, &n_subexprs);\n\t\tif (IS_ERR(hist_field)) {\n\t\t\tret = PTR_ERR(hist_field);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (field_has_hist_vars(hist_field, 0))\t{\n\t\t\thist_err(tr, HIST_ERR_INVALID_REF_KEY, errpos(field_str));\n\t\t\tdestroy_hist_field(hist_field, 0);\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tkey_size = hist_field->size;\n\t}\n\n\thist_data->fields[key_idx] = hist_field;\n\n\tkey_size = ALIGN(key_size, sizeof(u64));\n\thist_data->fields[key_idx]->size = key_size;\n\thist_data->fields[key_idx]->offset = key_offset;\n\n\thist_data->key_size += key_size;\n\n\tif (hist_data->key_size > HIST_KEY_SIZE_MAX) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\thist_data->n_keys++;\n\thist_data->n_fields++;\n\n\tif (WARN_ON(hist_data->n_keys > TRACING_MAP_KEYS_MAX))\n\t\treturn -EINVAL;\n\n\tret = key_size;\n out:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strsep",
          "args": [
            "&fields_str",
            "\",\""
          ],
          "line": 4319
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int create_key_fields(struct hist_trigger_data *hist_data,\n\t\t\t     struct trace_event_file *file)\n{\n\tunsigned int i, key_offset = 0, n_vals = hist_data->n_vals;\n\tchar *fields_str, *field_str;\n\tint ret = -EINVAL;\n\n\tfields_str = hist_data->attrs->keys_str;\n\tif (!fields_str)\n\t\tgoto out;\n\n\tfor (i = n_vals; i < n_vals + TRACING_MAP_KEYS_MAX; i++) {\n\t\tfield_str = strsep(&fields_str, \",\");\n\t\tif (!field_str)\n\t\t\tbreak;\n\t\tret = create_key_field(hist_data, i, key_offset,\n\t\t\t\t       file, field_str);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tkey_offset += ret;\n\t}\n\tif (fields_str) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\tret = 0;\n out:\n\treturn ret;\n}"
  },
  {
    "function_name": "create_key_field",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
    "lines": "4244-4305",
    "snippet": "static int create_key_field(struct hist_trigger_data *hist_data,\n\t\t\t    unsigned int key_idx,\n\t\t\t    unsigned int key_offset,\n\t\t\t    struct trace_event_file *file,\n\t\t\t    char *field_str)\n{\n\tstruct trace_array *tr = hist_data->event_file->tr;\n\tstruct hist_field *hist_field = NULL;\n\tunsigned long flags = 0;\n\tunsigned int key_size;\n\tint ret = 0, n_subexprs = 0;\n\n\tif (WARN_ON(key_idx >= HIST_FIELDS_MAX))\n\t\treturn -EINVAL;\n\n\tflags |= HIST_FIELD_FL_KEY;\n\n\tif (strcmp(field_str, \"stacktrace\") == 0) {\n\t\tflags |= HIST_FIELD_FL_STACKTRACE;\n\t\tkey_size = sizeof(unsigned long) * HIST_STACKTRACE_DEPTH;\n\t\thist_field = create_hist_field(hist_data, NULL, flags, NULL);\n\t} else {\n\t\thist_field = parse_expr(hist_data, file, field_str, flags,\n\t\t\t\t\tNULL, &n_subexprs);\n\t\tif (IS_ERR(hist_field)) {\n\t\t\tret = PTR_ERR(hist_field);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (field_has_hist_vars(hist_field, 0))\t{\n\t\t\thist_err(tr, HIST_ERR_INVALID_REF_KEY, errpos(field_str));\n\t\t\tdestroy_hist_field(hist_field, 0);\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tkey_size = hist_field->size;\n\t}\n\n\thist_data->fields[key_idx] = hist_field;\n\n\tkey_size = ALIGN(key_size, sizeof(u64));\n\thist_data->fields[key_idx]->size = key_size;\n\thist_data->fields[key_idx]->offset = key_offset;\n\n\thist_data->key_size += key_size;\n\n\tif (hist_data->key_size > HIST_KEY_SIZE_MAX) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\thist_data->n_keys++;\n\thist_data->n_fields++;\n\n\tif (WARN_ON(hist_data->n_keys > TRACING_MAP_KEYS_MAX))\n\t\treturn -EINVAL;\n\n\tret = key_size;\n out:\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include \"tracing_map.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define HIST_KEY_SIZE_MAX\t(MAX_FILTER_STR_VAL + HIST_STACKTRACE_SIZE)",
      "#define HIST_STACKTRACE_DEPTH\t16",
      "#define HIST_FIELDS_MAX\t\t(TRACING_MAP_FIELDS_MAX + TRACING_MAP_VARS_MAX)"
    ],
    "globals_used": [
      "static struct hist_field *parse_expr(struct hist_trigger_data *hist_data,\n\t\t\t\t     struct trace_event_file *file,\n\t\t\t\t     char *str, unsigned long flags,\n\t\t\t\t     char *var_name, unsigned int *n_subexprs);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "hist_data->n_keys > TRACING_MAP_KEYS_MAX"
          ],
          "line": 4299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ALIGN",
          "args": [
            "key_size",
            "sizeof(u64)"
          ],
          "line": 4285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "destroy_hist_field",
          "args": [
            "hist_field",
            "0"
          ],
          "line": 4275
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_hist_field",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "1864-1882",
          "snippet": "static void destroy_hist_field(struct hist_field *hist_field,\n\t\t\t       unsigned int level)\n{\n\tunsigned int i;\n\n\tif (level > 3)\n\t\treturn;\n\n\tif (!hist_field)\n\t\treturn;\n\n\tif (hist_field->flags & HIST_FIELD_FL_VAR_REF)\n\t\treturn; /* var refs will be destroyed separately */\n\n\tfor (i = 0; i < HIST_FIELD_OPERANDS_MAX; i++)\n\t\tdestroy_hist_field(hist_field->operands[i], level + 1);\n\n\t__destroy_hist_field(hist_field);\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define HIST_FIELD_OPERANDS_MAX\t2"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\n#define HIST_FIELD_OPERANDS_MAX\t2\n\nstatic void destroy_hist_field(struct hist_field *hist_field,\n\t\t\t       unsigned int level)\n{\n\tunsigned int i;\n\n\tif (level > 3)\n\t\treturn;\n\n\tif (!hist_field)\n\t\treturn;\n\n\tif (hist_field->flags & HIST_FIELD_FL_VAR_REF)\n\t\treturn; /* var refs will be destroyed separately */\n\n\tfor (i = 0; i < HIST_FIELD_OPERANDS_MAX; i++)\n\t\tdestroy_hist_field(hist_field->operands[i], level + 1);\n\n\t__destroy_hist_field(hist_field);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hist_err",
          "args": [
            "tr",
            "HIST_ERR_INVALID_REF_KEY",
            "errpos(field_str)"
          ],
          "line": 4274
        },
        "resolved": true,
        "details": {
          "function_name": "hist_err",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "763-767",
          "snippet": "static void hist_err(struct trace_array *tr, u8 err_type, u8 err_pos)\n{\n\ttracing_log_err(tr, last_cmd_loc, last_cmd, err_text,\n\t\t\terr_type, err_pos);\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *err_text[] = { ERRORS };",
            "static char last_cmd[MAX_FILTER_STR_VAL];",
            "static char last_cmd_loc[MAX_FILTER_STR_VAL];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic const char *err_text[] = { ERRORS };\nstatic char last_cmd[MAX_FILTER_STR_VAL];\nstatic char last_cmd_loc[MAX_FILTER_STR_VAL];\n\nstatic void hist_err(struct trace_array *tr, u8 err_type, u8 err_pos)\n{\n\ttracing_log_err(tr, last_cmd_loc, last_cmd, err_text,\n\t\t\terr_type, err_pos);\n}"
        }
      },
      {
        "call_info": {
          "callee": "errpos",
          "args": [
            "field_str"
          ],
          "line": 4274
        },
        "resolved": true,
        "details": {
          "function_name": "errpos",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "733-736",
          "snippet": "static int errpos(char *str)\n{\n\treturn err_pos(last_cmd, str);\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char last_cmd[MAX_FILTER_STR_VAL];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic char last_cmd[MAX_FILTER_STR_VAL];\n\nstatic int errpos(char *str)\n{\n\treturn err_pos(last_cmd, str);\n}"
        }
      },
      {
        "call_info": {
          "callee": "field_has_hist_vars",
          "args": [
            "hist_field",
            "0"
          ],
          "line": 4273
        },
        "resolved": true,
        "details": {
          "function_name": "field_has_hist_vars",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "978-1002",
          "snippet": "static bool field_has_hist_vars(struct hist_field *hist_field,\n\t\t\t\tunsigned int level)\n{\n\tint i;\n\n\tif (level > 3)\n\t\treturn false;\n\n\tif (!hist_field)\n\t\treturn false;\n\n\tif (hist_field->flags & HIST_FIELD_FL_VAR ||\n\t    hist_field->flags & HIST_FIELD_FL_VAR_REF)\n\t\treturn true;\n\n\tfor (i = 0; i < HIST_FIELD_OPERANDS_MAX; i++) {\n\t\tstruct hist_field *operand;\n\n\t\toperand = hist_field->operands[i];\n\t\tif (field_has_hist_vars(operand, level + 1))\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define HIST_FIELD_OPERANDS_MAX\t2"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\n#define HIST_FIELD_OPERANDS_MAX\t2\n\nstatic bool field_has_hist_vars(struct hist_field *hist_field,\n\t\t\t\tunsigned int level)\n{\n\tint i;\n\n\tif (level > 3)\n\t\treturn false;\n\n\tif (!hist_field)\n\t\treturn false;\n\n\tif (hist_field->flags & HIST_FIELD_FL_VAR ||\n\t    hist_field->flags & HIST_FIELD_FL_VAR_REF)\n\t\treturn true;\n\n\tfor (i = 0; i < HIST_FIELD_OPERANDS_MAX; i++) {\n\t\tstruct hist_field *operand;\n\n\t\toperand = hist_field->operands[i];\n\t\tif (field_has_hist_vars(operand, level + 1))\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "hist_field"
          ],
          "line": 4269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "hist_field"
          ],
          "line": 4268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parse_expr",
          "args": [
            "hist_data",
            "file",
            "field_str",
            "flags",
            "NULL",
            "&n_subexprs"
          ],
          "line": 4266
        },
        "resolved": true,
        "details": {
          "function_name": "parse_expr",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "2564-2744",
          "snippet": "static struct hist_field *parse_expr(struct hist_trigger_data *hist_data,\n\t\t\t\t     struct trace_event_file *file,\n\t\t\t\t     char *str, unsigned long flags,\n\t\t\t\t     char *var_name, unsigned int *n_subexprs)\n{\n\tstruct hist_field *operand1 = NULL, *operand2 = NULL, *expr = NULL;\n\tstruct hist_field *var1 = NULL, *var2 = NULL;\n\tunsigned long operand_flags, operand2_flags;\n\tint field_op, ret = -EINVAL;\n\tchar *sep, *operand1_str;\n\thist_field_fn_t op_fn;\n\tbool combine_consts;\n\n\tif (*n_subexprs > 3) {\n\t\thist_err(file->tr, HIST_ERR_TOO_MANY_SUBEXPR, errpos(str));\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tfield_op = contains_operator(str, &sep);\n\n\tif (field_op == FIELD_OP_NONE)\n\t\treturn parse_atom(hist_data, file, str, &flags, var_name);\n\n\tif (field_op == FIELD_OP_UNARY_MINUS)\n\t\treturn parse_unary(hist_data, file, str, flags, var_name, n_subexprs);\n\n\t/* Binary operator found, increment n_subexprs */\n\t++*n_subexprs;\n\n\t/* Split the expression string at the root operator */\n\tif (!sep)\n\t\treturn ERR_PTR(-EINVAL);\n\n\t*sep = '\\0';\n\toperand1_str = str;\n\tstr = sep+1;\n\n\t/* Binary operator requires both operands */\n\tif (*operand1_str == '\\0' || *str == '\\0')\n\t\treturn ERR_PTR(-EINVAL);\n\n\toperand_flags = 0;\n\n\t/* LHS of string is an expression e.g. a+b in a+b+c */\n\toperand1 = parse_expr(hist_data, file, operand1_str, operand_flags, NULL, n_subexprs);\n\tif (IS_ERR(operand1))\n\t\treturn ERR_CAST(operand1);\n\n\tif (operand1->flags & HIST_FIELD_FL_STRING) {\n\t\thist_err(file->tr, HIST_ERR_INVALID_STR_OPERAND, errpos(operand1_str));\n\t\tret = -EINVAL;\n\t\tgoto free_op1;\n\t}\n\n\t/* RHS of string is another expression e.g. c in a+b+c */\n\toperand_flags = 0;\n\toperand2 = parse_expr(hist_data, file, str, operand_flags, NULL, n_subexprs);\n\tif (IS_ERR(operand2)) {\n\t\tret = PTR_ERR(operand2);\n\t\tgoto free_op1;\n\t}\n\tif (operand2->flags & HIST_FIELD_FL_STRING) {\n\t\thist_err(file->tr, HIST_ERR_INVALID_STR_OPERAND, errpos(str));\n\t\tret = -EINVAL;\n\t\tgoto free_operands;\n\t}\n\n\tswitch (field_op) {\n\tcase FIELD_OP_MINUS:\n\t\top_fn = hist_field_minus;\n\t\tbreak;\n\tcase FIELD_OP_PLUS:\n\t\top_fn = hist_field_plus;\n\t\tbreak;\n\tcase FIELD_OP_DIV:\n\t\top_fn = hist_field_div;\n\t\tbreak;\n\tcase FIELD_OP_MULT:\n\t\top_fn = hist_field_mult;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tgoto free_operands;\n\t}\n\n\tret = check_expr_operands(file->tr, operand1, operand2, &var1, &var2);\n\tif (ret)\n\t\tgoto free_operands;\n\n\toperand_flags = var1 ? var1->flags : operand1->flags;\n\toperand2_flags = var2 ? var2->flags : operand2->flags;\n\n\t/*\n\t * If both operands are constant, the expression can be\n\t * collapsed to a single constant.\n\t */\n\tcombine_consts = operand_flags & operand2_flags & HIST_FIELD_FL_CONST;\n\n\tflags |= combine_consts ? HIST_FIELD_FL_CONST : HIST_FIELD_FL_EXPR;\n\n\tflags |= operand1->flags &\n\t\t(HIST_FIELD_FL_TIMESTAMP | HIST_FIELD_FL_TIMESTAMP_USECS);\n\n\texpr = create_hist_field(hist_data, NULL, flags, var_name);\n\tif (!expr) {\n\t\tret = -ENOMEM;\n\t\tgoto free_operands;\n\t}\n\n\toperand1->read_once = true;\n\toperand2->read_once = true;\n\n\t/* The operands are now owned and free'd by 'expr' */\n\texpr->operands[0] = operand1;\n\texpr->operands[1] = operand2;\n\n\tif (field_op == FIELD_OP_DIV &&\n\t\t\toperand2_flags & HIST_FIELD_FL_CONST) {\n\t\tu64 divisor = var2 ? var2->constant : operand2->constant;\n\n\t\tif (!divisor) {\n\t\t\thist_err(file->tr, HIST_ERR_DIVISION_BY_ZERO, errpos(str));\n\t\t\tret = -EDOM;\n\t\t\tgoto free_expr;\n\t\t}\n\n\t\t/*\n\t\t * Copy the divisor here so we don't have to look it up\n\t\t * later if this is a var ref\n\t\t */\n\t\toperand2->constant = divisor;\n\t\top_fn = hist_field_get_div_fn(operand2);\n\t}\n\n\tif (combine_consts) {\n\t\tif (var1)\n\t\t\texpr->operands[0] = var1;\n\t\tif (var2)\n\t\t\texpr->operands[1] = var2;\n\n\t\texpr->constant = op_fn(expr, NULL, NULL, NULL, NULL);\n\n\t\texpr->operands[0] = NULL;\n\t\texpr->operands[1] = NULL;\n\n\t\t/*\n\t\t * var refs won't be destroyed immediately\n\t\t * See: destroy_hist_field()\n\t\t */\n\t\tdestroy_hist_field(operand2, 0);\n\t\tdestroy_hist_field(operand1, 0);\n\n\t\texpr->name = expr_str(expr, 0);\n\t} else {\n\t\texpr->fn = op_fn;\n\n\t\t/* The operand sizes should be the same, so just pick one */\n\t\texpr->size = operand1->size;\n\n\t\texpr->operator = field_op;\n\t\texpr->type = kstrdup_const(operand1->type, GFP_KERNEL);\n\t\tif (!expr->type) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto free_expr;\n\t\t}\n\n\t\texpr->name = expr_str(expr, 0);\n\t}\n\n\treturn expr;\n\nfree_operands:\n\tdestroy_hist_field(operand2, 0);\nfree_op1:\n\tdestroy_hist_field(operand1, 0);\n\treturn ERR_PTR(ret);\n\nfree_expr:\n\tdestroy_hist_field(expr, 0);\n\treturn ERR_PTR(ret);\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hist_field *parse_expr(struct hist_trigger_data *hist_data,\n\t\t\t\t     struct trace_event_file *file,\n\t\t\t\t     char *str, unsigned long flags,\n\t\t\t\t     char *var_name, unsigned int *n_subexprs);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct hist_field *parse_expr(struct hist_trigger_data *hist_data,\n\t\t\t\t     struct trace_event_file *file,\n\t\t\t\t     char *str, unsigned long flags,\n\t\t\t\t     char *var_name, unsigned int *n_subexprs);\n\nstatic struct hist_field *parse_expr(struct hist_trigger_data *hist_data,\n\t\t\t\t     struct trace_event_file *file,\n\t\t\t\t     char *str, unsigned long flags,\n\t\t\t\t     char *var_name, unsigned int *n_subexprs)\n{\n\tstruct hist_field *operand1 = NULL, *operand2 = NULL, *expr = NULL;\n\tstruct hist_field *var1 = NULL, *var2 = NULL;\n\tunsigned long operand_flags, operand2_flags;\n\tint field_op, ret = -EINVAL;\n\tchar *sep, *operand1_str;\n\thist_field_fn_t op_fn;\n\tbool combine_consts;\n\n\tif (*n_subexprs > 3) {\n\t\thist_err(file->tr, HIST_ERR_TOO_MANY_SUBEXPR, errpos(str));\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tfield_op = contains_operator(str, &sep);\n\n\tif (field_op == FIELD_OP_NONE)\n\t\treturn parse_atom(hist_data, file, str, &flags, var_name);\n\n\tif (field_op == FIELD_OP_UNARY_MINUS)\n\t\treturn parse_unary(hist_data, file, str, flags, var_name, n_subexprs);\n\n\t/* Binary operator found, increment n_subexprs */\n\t++*n_subexprs;\n\n\t/* Split the expression string at the root operator */\n\tif (!sep)\n\t\treturn ERR_PTR(-EINVAL);\n\n\t*sep = '\\0';\n\toperand1_str = str;\n\tstr = sep+1;\n\n\t/* Binary operator requires both operands */\n\tif (*operand1_str == '\\0' || *str == '\\0')\n\t\treturn ERR_PTR(-EINVAL);\n\n\toperand_flags = 0;\n\n\t/* LHS of string is an expression e.g. a+b in a+b+c */\n\toperand1 = parse_expr(hist_data, file, operand1_str, operand_flags, NULL, n_subexprs);\n\tif (IS_ERR(operand1))\n\t\treturn ERR_CAST(operand1);\n\n\tif (operand1->flags & HIST_FIELD_FL_STRING) {\n\t\thist_err(file->tr, HIST_ERR_INVALID_STR_OPERAND, errpos(operand1_str));\n\t\tret = -EINVAL;\n\t\tgoto free_op1;\n\t}\n\n\t/* RHS of string is another expression e.g. c in a+b+c */\n\toperand_flags = 0;\n\toperand2 = parse_expr(hist_data, file, str, operand_flags, NULL, n_subexprs);\n\tif (IS_ERR(operand2)) {\n\t\tret = PTR_ERR(operand2);\n\t\tgoto free_op1;\n\t}\n\tif (operand2->flags & HIST_FIELD_FL_STRING) {\n\t\thist_err(file->tr, HIST_ERR_INVALID_STR_OPERAND, errpos(str));\n\t\tret = -EINVAL;\n\t\tgoto free_operands;\n\t}\n\n\tswitch (field_op) {\n\tcase FIELD_OP_MINUS:\n\t\top_fn = hist_field_minus;\n\t\tbreak;\n\tcase FIELD_OP_PLUS:\n\t\top_fn = hist_field_plus;\n\t\tbreak;\n\tcase FIELD_OP_DIV:\n\t\top_fn = hist_field_div;\n\t\tbreak;\n\tcase FIELD_OP_MULT:\n\t\top_fn = hist_field_mult;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tgoto free_operands;\n\t}\n\n\tret = check_expr_operands(file->tr, operand1, operand2, &var1, &var2);\n\tif (ret)\n\t\tgoto free_operands;\n\n\toperand_flags = var1 ? var1->flags : operand1->flags;\n\toperand2_flags = var2 ? var2->flags : operand2->flags;\n\n\t/*\n\t * If both operands are constant, the expression can be\n\t * collapsed to a single constant.\n\t */\n\tcombine_consts = operand_flags & operand2_flags & HIST_FIELD_FL_CONST;\n\n\tflags |= combine_consts ? HIST_FIELD_FL_CONST : HIST_FIELD_FL_EXPR;\n\n\tflags |= operand1->flags &\n\t\t(HIST_FIELD_FL_TIMESTAMP | HIST_FIELD_FL_TIMESTAMP_USECS);\n\n\texpr = create_hist_field(hist_data, NULL, flags, var_name);\n\tif (!expr) {\n\t\tret = -ENOMEM;\n\t\tgoto free_operands;\n\t}\n\n\toperand1->read_once = true;\n\toperand2->read_once = true;\n\n\t/* The operands are now owned and free'd by 'expr' */\n\texpr->operands[0] = operand1;\n\texpr->operands[1] = operand2;\n\n\tif (field_op == FIELD_OP_DIV &&\n\t\t\toperand2_flags & HIST_FIELD_FL_CONST) {\n\t\tu64 divisor = var2 ? var2->constant : operand2->constant;\n\n\t\tif (!divisor) {\n\t\t\thist_err(file->tr, HIST_ERR_DIVISION_BY_ZERO, errpos(str));\n\t\t\tret = -EDOM;\n\t\t\tgoto free_expr;\n\t\t}\n\n\t\t/*\n\t\t * Copy the divisor here so we don't have to look it up\n\t\t * later if this is a var ref\n\t\t */\n\t\toperand2->constant = divisor;\n\t\top_fn = hist_field_get_div_fn(operand2);\n\t}\n\n\tif (combine_consts) {\n\t\tif (var1)\n\t\t\texpr->operands[0] = var1;\n\t\tif (var2)\n\t\t\texpr->operands[1] = var2;\n\n\t\texpr->constant = op_fn(expr, NULL, NULL, NULL, NULL);\n\n\t\texpr->operands[0] = NULL;\n\t\texpr->operands[1] = NULL;\n\n\t\t/*\n\t\t * var refs won't be destroyed immediately\n\t\t * See: destroy_hist_field()\n\t\t */\n\t\tdestroy_hist_field(operand2, 0);\n\t\tdestroy_hist_field(operand1, 0);\n\n\t\texpr->name = expr_str(expr, 0);\n\t} else {\n\t\texpr->fn = op_fn;\n\n\t\t/* The operand sizes should be the same, so just pick one */\n\t\texpr->size = operand1->size;\n\n\t\texpr->operator = field_op;\n\t\texpr->type = kstrdup_const(operand1->type, GFP_KERNEL);\n\t\tif (!expr->type) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto free_expr;\n\t\t}\n\n\t\texpr->name = expr_str(expr, 0);\n\t}\n\n\treturn expr;\n\nfree_operands:\n\tdestroy_hist_field(operand2, 0);\nfree_op1:\n\tdestroy_hist_field(operand1, 0);\n\treturn ERR_PTR(ret);\n\nfree_expr:\n\tdestroy_hist_field(expr, 0);\n\treturn ERR_PTR(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "create_hist_field",
          "args": [
            "hist_data",
            "NULL",
            "flags",
            "NULL"
          ],
          "line": 4264
        },
        "resolved": true,
        "details": {
          "function_name": "create_hist_field",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "1884-2007",
          "snippet": "static struct hist_field *create_hist_field(struct hist_trigger_data *hist_data,\n\t\t\t\t\t    struct ftrace_event_field *field,\n\t\t\t\t\t    unsigned long flags,\n\t\t\t\t\t    char *var_name)\n{\n\tstruct hist_field *hist_field;\n\n\tif (field && is_function_field(field))\n\t\treturn NULL;\n\n\thist_field = kzalloc(sizeof(struct hist_field), GFP_KERNEL);\n\tif (!hist_field)\n\t\treturn NULL;\n\n\thist_field->ref = 1;\n\n\thist_field->hist_data = hist_data;\n\n\tif (flags & HIST_FIELD_FL_EXPR || flags & HIST_FIELD_FL_ALIAS)\n\t\tgoto out; /* caller will populate */\n\n\tif (flags & HIST_FIELD_FL_VAR_REF) {\n\t\thist_field->fn = hist_field_var_ref;\n\t\tgoto out;\n\t}\n\n\tif (flags & HIST_FIELD_FL_HITCOUNT) {\n\t\thist_field->fn = hist_field_counter;\n\t\thist_field->size = sizeof(u64);\n\t\thist_field->type = \"u64\";\n\t\tgoto out;\n\t}\n\n\tif (flags & HIST_FIELD_FL_CONST) {\n\t\thist_field->fn = hist_field_const;\n\t\thist_field->size = sizeof(u64);\n\t\thist_field->type = kstrdup(\"u64\", GFP_KERNEL);\n\t\tif (!hist_field->type)\n\t\t\tgoto free;\n\t\tgoto out;\n\t}\n\n\tif (flags & HIST_FIELD_FL_STACKTRACE) {\n\t\thist_field->fn = hist_field_none;\n\t\tgoto out;\n\t}\n\n\tif (flags & (HIST_FIELD_FL_LOG2 | HIST_FIELD_FL_BUCKET)) {\n\t\tunsigned long fl = flags & ~(HIST_FIELD_FL_LOG2 | HIST_FIELD_FL_BUCKET);\n\t\thist_field->fn = flags & HIST_FIELD_FL_LOG2 ? hist_field_log2 :\n\t\t\thist_field_bucket;\n\t\thist_field->operands[0] = create_hist_field(hist_data, field, fl, NULL);\n\t\thist_field->size = hist_field->operands[0]->size;\n\t\thist_field->type = kstrdup_const(hist_field->operands[0]->type, GFP_KERNEL);\n\t\tif (!hist_field->type)\n\t\t\tgoto free;\n\t\tgoto out;\n\t}\n\n\tif (flags & HIST_FIELD_FL_TIMESTAMP) {\n\t\thist_field->fn = hist_field_timestamp;\n\t\thist_field->size = sizeof(u64);\n\t\thist_field->type = \"u64\";\n\t\tgoto out;\n\t}\n\n\tif (flags & HIST_FIELD_FL_CPU) {\n\t\thist_field->fn = hist_field_cpu;\n\t\thist_field->size = sizeof(int);\n\t\thist_field->type = \"unsigned int\";\n\t\tgoto out;\n\t}\n\n\tif (WARN_ON_ONCE(!field))\n\t\tgoto out;\n\n\t/* Pointers to strings are just pointers and dangerous to dereference */\n\tif (is_string_field(field) &&\n\t    (field->filter_type != FILTER_PTR_STRING)) {\n\t\tflags |= HIST_FIELD_FL_STRING;\n\n\t\thist_field->size = MAX_FILTER_STR_VAL;\n\t\thist_field->type = kstrdup_const(field->type, GFP_KERNEL);\n\t\tif (!hist_field->type)\n\t\t\tgoto free;\n\n\t\tif (field->filter_type == FILTER_STATIC_STRING) {\n\t\t\thist_field->fn = hist_field_string;\n\t\t\thist_field->size = field->size;\n\t\t} else if (field->filter_type == FILTER_DYN_STRING) {\n\t\t\thist_field->fn = hist_field_dynstring;\n\t\t} else if (field->filter_type == FILTER_RDYN_STRING)\n\t\t\thist_field->fn = hist_field_reldynstring;\n\t\telse\n\t\t\thist_field->fn = hist_field_pstring;\n\t} else {\n\t\thist_field->size = field->size;\n\t\thist_field->is_signed = field->is_signed;\n\t\thist_field->type = kstrdup_const(field->type, GFP_KERNEL);\n\t\tif (!hist_field->type)\n\t\t\tgoto free;\n\n\t\thist_field->fn = select_value_fn(field->size,\n\t\t\t\t\t\t field->is_signed);\n\t\tif (!hist_field->fn) {\n\t\t\tdestroy_hist_field(hist_field, 0);\n\t\t\treturn NULL;\n\t\t}\n\t}\n out:\n\thist_field->field = field;\n\thist_field->flags = flags;\n\n\tif (var_name) {\n\t\thist_field->var.name = kstrdup(var_name, GFP_KERNEL);\n\t\tif (!hist_field->var.name)\n\t\t\tgoto free;\n\t}\n\n\treturn hist_field;\n free:\n\tdestroy_hist_field(hist_field, 0);\n\treturn NULL;\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct hist_field *create_hist_field(struct hist_trigger_data *hist_data,\n\t\t\t\t\t    struct ftrace_event_field *field,\n\t\t\t\t\t    unsigned long flags,\n\t\t\t\t\t    char *var_name)\n{\n\tstruct hist_field *hist_field;\n\n\tif (field && is_function_field(field))\n\t\treturn NULL;\n\n\thist_field = kzalloc(sizeof(struct hist_field), GFP_KERNEL);\n\tif (!hist_field)\n\t\treturn NULL;\n\n\thist_field->ref = 1;\n\n\thist_field->hist_data = hist_data;\n\n\tif (flags & HIST_FIELD_FL_EXPR || flags & HIST_FIELD_FL_ALIAS)\n\t\tgoto out; /* caller will populate */\n\n\tif (flags & HIST_FIELD_FL_VAR_REF) {\n\t\thist_field->fn = hist_field_var_ref;\n\t\tgoto out;\n\t}\n\n\tif (flags & HIST_FIELD_FL_HITCOUNT) {\n\t\thist_field->fn = hist_field_counter;\n\t\thist_field->size = sizeof(u64);\n\t\thist_field->type = \"u64\";\n\t\tgoto out;\n\t}\n\n\tif (flags & HIST_FIELD_FL_CONST) {\n\t\thist_field->fn = hist_field_const;\n\t\thist_field->size = sizeof(u64);\n\t\thist_field->type = kstrdup(\"u64\", GFP_KERNEL);\n\t\tif (!hist_field->type)\n\t\t\tgoto free;\n\t\tgoto out;\n\t}\n\n\tif (flags & HIST_FIELD_FL_STACKTRACE) {\n\t\thist_field->fn = hist_field_none;\n\t\tgoto out;\n\t}\n\n\tif (flags & (HIST_FIELD_FL_LOG2 | HIST_FIELD_FL_BUCKET)) {\n\t\tunsigned long fl = flags & ~(HIST_FIELD_FL_LOG2 | HIST_FIELD_FL_BUCKET);\n\t\thist_field->fn = flags & HIST_FIELD_FL_LOG2 ? hist_field_log2 :\n\t\t\thist_field_bucket;\n\t\thist_field->operands[0] = create_hist_field(hist_data, field, fl, NULL);\n\t\thist_field->size = hist_field->operands[0]->size;\n\t\thist_field->type = kstrdup_const(hist_field->operands[0]->type, GFP_KERNEL);\n\t\tif (!hist_field->type)\n\t\t\tgoto free;\n\t\tgoto out;\n\t}\n\n\tif (flags & HIST_FIELD_FL_TIMESTAMP) {\n\t\thist_field->fn = hist_field_timestamp;\n\t\thist_field->size = sizeof(u64);\n\t\thist_field->type = \"u64\";\n\t\tgoto out;\n\t}\n\n\tif (flags & HIST_FIELD_FL_CPU) {\n\t\thist_field->fn = hist_field_cpu;\n\t\thist_field->size = sizeof(int);\n\t\thist_field->type = \"unsigned int\";\n\t\tgoto out;\n\t}\n\n\tif (WARN_ON_ONCE(!field))\n\t\tgoto out;\n\n\t/* Pointers to strings are just pointers and dangerous to dereference */\n\tif (is_string_field(field) &&\n\t    (field->filter_type != FILTER_PTR_STRING)) {\n\t\tflags |= HIST_FIELD_FL_STRING;\n\n\t\thist_field->size = MAX_FILTER_STR_VAL;\n\t\thist_field->type = kstrdup_const(field->type, GFP_KERNEL);\n\t\tif (!hist_field->type)\n\t\t\tgoto free;\n\n\t\tif (field->filter_type == FILTER_STATIC_STRING) {\n\t\t\thist_field->fn = hist_field_string;\n\t\t\thist_field->size = field->size;\n\t\t} else if (field->filter_type == FILTER_DYN_STRING) {\n\t\t\thist_field->fn = hist_field_dynstring;\n\t\t} else if (field->filter_type == FILTER_RDYN_STRING)\n\t\t\thist_field->fn = hist_field_reldynstring;\n\t\telse\n\t\t\thist_field->fn = hist_field_pstring;\n\t} else {\n\t\thist_field->size = field->size;\n\t\thist_field->is_signed = field->is_signed;\n\t\thist_field->type = kstrdup_const(field->type, GFP_KERNEL);\n\t\tif (!hist_field->type)\n\t\t\tgoto free;\n\n\t\thist_field->fn = select_value_fn(field->size,\n\t\t\t\t\t\t field->is_signed);\n\t\tif (!hist_field->fn) {\n\t\t\tdestroy_hist_field(hist_field, 0);\n\t\t\treturn NULL;\n\t\t}\n\t}\n out:\n\thist_field->field = field;\n\thist_field->flags = flags;\n\n\tif (var_name) {\n\t\thist_field->var.name = kstrdup(var_name, GFP_KERNEL);\n\t\tif (!hist_field->var.name)\n\t\t\tgoto free;\n\t}\n\n\treturn hist_field;\n free:\n\tdestroy_hist_field(hist_field, 0);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "field_str",
            "\"stacktrace\""
          ],
          "line": 4261
        },
        "resolved": true,
        "details": {
          "function_name": "sym_strcmp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/report.c",
          "lines": "356-365",
          "snippet": "static int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}",
          "includes": [
            "#include \"encoding.h\"",
            "#include \"kcsan.h\"",
            "#include <linux/stacktrace.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/delay.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"encoding.h\"\n#include \"kcsan.h\"\n#include <linux/stacktrace.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/lockdep.h>\n#include <linux/kernel.h>\n#include <linux/kallsyms.h>\n#include <linux/jiffies.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n\nstatic int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "key_idx >= HIST_FIELDS_MAX"
          ],
          "line": 4256
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\n#define HIST_KEY_SIZE_MAX\t(MAX_FILTER_STR_VAL + HIST_STACKTRACE_SIZE)\n#define HIST_STACKTRACE_DEPTH\t16\n#define HIST_FIELDS_MAX\t\t(TRACING_MAP_FIELDS_MAX + TRACING_MAP_VARS_MAX)\n\nstatic struct hist_field *parse_expr(struct hist_trigger_data *hist_data,\n\t\t\t\t     struct trace_event_file *file,\n\t\t\t\t     char *str, unsigned long flags,\n\t\t\t\t     char *var_name, unsigned int *n_subexprs);\n\nstatic int create_key_field(struct hist_trigger_data *hist_data,\n\t\t\t    unsigned int key_idx,\n\t\t\t    unsigned int key_offset,\n\t\t\t    struct trace_event_file *file,\n\t\t\t    char *field_str)\n{\n\tstruct trace_array *tr = hist_data->event_file->tr;\n\tstruct hist_field *hist_field = NULL;\n\tunsigned long flags = 0;\n\tunsigned int key_size;\n\tint ret = 0, n_subexprs = 0;\n\n\tif (WARN_ON(key_idx >= HIST_FIELDS_MAX))\n\t\treturn -EINVAL;\n\n\tflags |= HIST_FIELD_FL_KEY;\n\n\tif (strcmp(field_str, \"stacktrace\") == 0) {\n\t\tflags |= HIST_FIELD_FL_STACKTRACE;\n\t\tkey_size = sizeof(unsigned long) * HIST_STACKTRACE_DEPTH;\n\t\thist_field = create_hist_field(hist_data, NULL, flags, NULL);\n\t} else {\n\t\thist_field = parse_expr(hist_data, file, field_str, flags,\n\t\t\t\t\tNULL, &n_subexprs);\n\t\tif (IS_ERR(hist_field)) {\n\t\t\tret = PTR_ERR(hist_field);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (field_has_hist_vars(hist_field, 0))\t{\n\t\t\thist_err(tr, HIST_ERR_INVALID_REF_KEY, errpos(field_str));\n\t\t\tdestroy_hist_field(hist_field, 0);\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tkey_size = hist_field->size;\n\t}\n\n\thist_data->fields[key_idx] = hist_field;\n\n\tkey_size = ALIGN(key_size, sizeof(u64));\n\thist_data->fields[key_idx]->size = key_size;\n\thist_data->fields[key_idx]->offset = key_offset;\n\n\thist_data->key_size += key_size;\n\n\tif (hist_data->key_size > HIST_KEY_SIZE_MAX) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\thist_data->n_keys++;\n\thist_data->n_fields++;\n\n\tif (WARN_ON(hist_data->n_keys > TRACING_MAP_KEYS_MAX))\n\t\treturn -EINVAL;\n\n\tret = key_size;\n out:\n\treturn ret;\n}"
  },
  {
    "function_name": "create_val_fields",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
    "lines": "4209-4242",
    "snippet": "static int create_val_fields(struct hist_trigger_data *hist_data,\n\t\t\t     struct trace_event_file *file)\n{\n\tchar *fields_str, *field_str;\n\tunsigned int i, j = 1;\n\tint ret;\n\n\tret = create_hitcount_val(hist_data);\n\tif (ret)\n\t\tgoto out;\n\n\tfields_str = hist_data->attrs->vals_str;\n\tif (!fields_str)\n\t\tgoto out;\n\n\tfor (i = 0, j = 1; i < TRACING_MAP_VALS_MAX &&\n\t\t     j < TRACING_MAP_VALS_MAX; i++) {\n\t\tfield_str = strsep(&fields_str, \",\");\n\t\tif (!field_str)\n\t\t\tbreak;\n\n\t\tif (strcmp(field_str, \"hitcount\") == 0)\n\t\t\tcontinue;\n\n\t\tret = create_val_field(hist_data, j++, file, field_str);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\tif (fields_str && (strcmp(fields_str, \"hitcount\") != 0))\n\t\tret = -EINVAL;\n out:\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include \"tracing_map.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "fields_str",
            "\"hitcount\""
          ],
          "line": 4238
        },
        "resolved": true,
        "details": {
          "function_name": "sym_strcmp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/report.c",
          "lines": "356-365",
          "snippet": "static int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}",
          "includes": [
            "#include \"encoding.h\"",
            "#include \"kcsan.h\"",
            "#include <linux/stacktrace.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/delay.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"encoding.h\"\n#include \"kcsan.h\"\n#include <linux/stacktrace.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/lockdep.h>\n#include <linux/kernel.h>\n#include <linux/kallsyms.h>\n#include <linux/jiffies.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n\nstatic int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}"
        }
      },
      {
        "call_info": {
          "callee": "create_val_field",
          "args": [
            "hist_data",
            "j++",
            "file",
            "field_str"
          ],
          "line": 4233
        },
        "resolved": true,
        "details": {
          "function_name": "create_val_field",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "4130-4139",
          "snippet": "static int create_val_field(struct hist_trigger_data *hist_data,\n\t\t\t    unsigned int val_idx,\n\t\t\t    struct trace_event_file *file,\n\t\t\t    char *field_str)\n{\n\tif (WARN_ON(val_idx >= TRACING_MAP_VALS_MAX))\n\t\treturn -EINVAL;\n\n\treturn __create_val_field(hist_data, val_idx, file, NULL, field_str, 0);\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int create_val_field(struct hist_trigger_data *hist_data,\n\t\t\t    unsigned int val_idx,\n\t\t\t    struct trace_event_file *file,\n\t\t\t    char *field_str)\n{\n\tif (WARN_ON(val_idx >= TRACING_MAP_VALS_MAX))\n\t\treturn -EINVAL;\n\n\treturn __create_val_field(hist_data, val_idx, file, NULL, field_str, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strsep",
          "args": [
            "&fields_str",
            "\",\""
          ],
          "line": 4226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "create_hitcount_val",
          "args": [
            "hist_data"
          ],
          "line": 4216
        },
        "resolved": true,
        "details": {
          "function_name": "create_hitcount_val",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "4088-4102",
          "snippet": "static int create_hitcount_val(struct hist_trigger_data *hist_data)\n{\n\thist_data->fields[HITCOUNT_IDX] =\n\t\tcreate_hist_field(hist_data, NULL, HIST_FIELD_FL_HITCOUNT, NULL);\n\tif (!hist_data->fields[HITCOUNT_IDX])\n\t\treturn -ENOMEM;\n\n\thist_data->n_vals++;\n\thist_data->n_fields++;\n\n\tif (WARN_ON(hist_data->n_vals > TRACING_MAP_VALS_MAX))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define HITCOUNT_IDX\t\t0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\n#define HITCOUNT_IDX\t\t0\n\nstatic int create_hitcount_val(struct hist_trigger_data *hist_data)\n{\n\thist_data->fields[HITCOUNT_IDX] =\n\t\tcreate_hist_field(hist_data, NULL, HIST_FIELD_FL_HITCOUNT, NULL);\n\tif (!hist_data->fields[HITCOUNT_IDX])\n\t\treturn -ENOMEM;\n\n\thist_data->n_vals++;\n\thist_data->n_fields++;\n\n\tif (WARN_ON(hist_data->n_vals > TRACING_MAP_VALS_MAX))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int create_val_fields(struct hist_trigger_data *hist_data,\n\t\t\t     struct trace_event_file *file)\n{\n\tchar *fields_str, *field_str;\n\tunsigned int i, j = 1;\n\tint ret;\n\n\tret = create_hitcount_val(hist_data);\n\tif (ret)\n\t\tgoto out;\n\n\tfields_str = hist_data->attrs->vals_str;\n\tif (!fields_str)\n\t\tgoto out;\n\n\tfor (i = 0, j = 1; i < TRACING_MAP_VALS_MAX &&\n\t\t     j < TRACING_MAP_VALS_MAX; i++) {\n\t\tfield_str = strsep(&fields_str, \",\");\n\t\tif (!field_str)\n\t\t\tbreak;\n\n\t\tif (strcmp(field_str, \"hitcount\") == 0)\n\t\t\tcontinue;\n\n\t\tret = create_val_field(hist_data, j++, file, field_str);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\tif (fields_str && (strcmp(fields_str, \"hitcount\") != 0))\n\t\tret = -EINVAL;\n out:\n\treturn ret;\n}"
  },
  {
    "function_name": "create_var_field",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
    "lines": "4176-4207",
    "snippet": "static int create_var_field(struct hist_trigger_data *hist_data,\n\t\t\t    unsigned int val_idx,\n\t\t\t    struct trace_event_file *file,\n\t\t\t    char *var_name, char *expr_str)\n{\n\tstruct trace_array *tr = hist_data->event_file->tr;\n\tunsigned long flags = 0;\n\tint ret;\n\n\tif (WARN_ON(val_idx >= TRACING_MAP_VALS_MAX + TRACING_MAP_VARS_MAX))\n\t\treturn -EINVAL;\n\n\tif (find_var(hist_data, file, var_name) && !hist_data->remove) {\n\t\thist_err(tr, HIST_ERR_DUPLICATE_VAR, errpos(var_name));\n\t\treturn -EINVAL;\n\t}\n\n\tflags |= HIST_FIELD_FL_VAR;\n\thist_data->n_vars++;\n\tif (WARN_ON(hist_data->n_vars > TRACING_MAP_VARS_MAX))\n\t\treturn -EINVAL;\n\n\tret = __create_val_field(hist_data, val_idx, file, var_name, expr_str, flags);\n\n\tif (!ret && hist_data->fields[val_idx]->flags & HIST_FIELD_FL_EXECNAME)\n\t\tupdate_var_execname(hist_data->fields[val_idx]);\n\n\tif (!ret && hist_data->fields[val_idx]->flags & HIST_FIELD_FL_STRING)\n\t\thist_data->fields[val_idx]->var_str_idx = hist_data->n_var_str++;\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include \"tracing_map.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "update_var_execname",
          "args": [
            "hist_data->fields[val_idx]"
          ],
          "line": 4201
        },
        "resolved": true,
        "details": {
          "function_name": "update_var_execname",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "4163-4174",
          "snippet": "static void update_var_execname(struct hist_field *hist_field)\n{\n\thist_field->flags = HIST_FIELD_FL_STRING | HIST_FIELD_FL_VAR |\n\t\tHIST_FIELD_FL_EXECNAME;\n\thist_field->size = MAX_FILTER_STR_VAL;\n\thist_field->is_signed = 0;\n\n\tkfree_const(hist_field->type);\n\thist_field->type = \"char[]\";\n\n\thist_field->fn = hist_field_execname;\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void update_var_execname(struct hist_field *hist_field)\n{\n\thist_field->flags = HIST_FIELD_FL_STRING | HIST_FIELD_FL_VAR |\n\t\tHIST_FIELD_FL_EXECNAME;\n\thist_field->size = MAX_FILTER_STR_VAL;\n\thist_field->is_signed = 0;\n\n\tkfree_const(hist_field->type);\n\thist_field->type = \"char[]\";\n\n\thist_field->fn = hist_field_execname;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__create_val_field",
          "args": [
            "hist_data",
            "val_idx",
            "file",
            "var_name",
            "expr_str",
            "flags"
          ],
          "line": 4198
        },
        "resolved": true,
        "details": {
          "function_name": "__create_val_field",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "4104-4128",
          "snippet": "static int __create_val_field(struct hist_trigger_data *hist_data,\n\t\t\t      unsigned int val_idx,\n\t\t\t      struct trace_event_file *file,\n\t\t\t      char *var_name, char *field_str,\n\t\t\t      unsigned long flags)\n{\n\tstruct hist_field *hist_field;\n\tint ret = 0, n_subexprs = 0;\n\n\thist_field = parse_expr(hist_data, file, field_str, flags, var_name, &n_subexprs);\n\tif (IS_ERR(hist_field)) {\n\t\tret = PTR_ERR(hist_field);\n\t\tgoto out;\n\t}\n\n\thist_data->fields[val_idx] = hist_field;\n\n\t++hist_data->n_vals;\n\t++hist_data->n_fields;\n\n\tif (WARN_ON(hist_data->n_vals > TRACING_MAP_VALS_MAX + TRACING_MAP_VARS_MAX))\n\t\tret = -EINVAL;\n out:\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hist_field *parse_expr(struct hist_trigger_data *hist_data,\n\t\t\t\t     struct trace_event_file *file,\n\t\t\t\t     char *str, unsigned long flags,\n\t\t\t\t     char *var_name, unsigned int *n_subexprs);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct hist_field *parse_expr(struct hist_trigger_data *hist_data,\n\t\t\t\t     struct trace_event_file *file,\n\t\t\t\t     char *str, unsigned long flags,\n\t\t\t\t     char *var_name, unsigned int *n_subexprs);\n\nstatic int __create_val_field(struct hist_trigger_data *hist_data,\n\t\t\t      unsigned int val_idx,\n\t\t\t      struct trace_event_file *file,\n\t\t\t      char *var_name, char *field_str,\n\t\t\t      unsigned long flags)\n{\n\tstruct hist_field *hist_field;\n\tint ret = 0, n_subexprs = 0;\n\n\thist_field = parse_expr(hist_data, file, field_str, flags, var_name, &n_subexprs);\n\tif (IS_ERR(hist_field)) {\n\t\tret = PTR_ERR(hist_field);\n\t\tgoto out;\n\t}\n\n\thist_data->fields[val_idx] = hist_field;\n\n\t++hist_data->n_vals;\n\t++hist_data->n_fields;\n\n\tif (WARN_ON(hist_data->n_vals > TRACING_MAP_VALS_MAX + TRACING_MAP_VARS_MAX))\n\t\tret = -EINVAL;\n out:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "hist_data->n_vars > TRACING_MAP_VARS_MAX"
          ],
          "line": 4195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hist_err",
          "args": [
            "tr",
            "HIST_ERR_DUPLICATE_VAR",
            "errpos(var_name)"
          ],
          "line": 4189
        },
        "resolved": true,
        "details": {
          "function_name": "hist_err",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "763-767",
          "snippet": "static void hist_err(struct trace_array *tr, u8 err_type, u8 err_pos)\n{\n\ttracing_log_err(tr, last_cmd_loc, last_cmd, err_text,\n\t\t\terr_type, err_pos);\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *err_text[] = { ERRORS };",
            "static char last_cmd[MAX_FILTER_STR_VAL];",
            "static char last_cmd_loc[MAX_FILTER_STR_VAL];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic const char *err_text[] = { ERRORS };\nstatic char last_cmd[MAX_FILTER_STR_VAL];\nstatic char last_cmd_loc[MAX_FILTER_STR_VAL];\n\nstatic void hist_err(struct trace_array *tr, u8 err_type, u8 err_pos)\n{\n\ttracing_log_err(tr, last_cmd_loc, last_cmd, err_text,\n\t\t\terr_type, err_pos);\n}"
        }
      },
      {
        "call_info": {
          "callee": "errpos",
          "args": [
            "var_name"
          ],
          "line": 4189
        },
        "resolved": true,
        "details": {
          "function_name": "errpos",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "733-736",
          "snippet": "static int errpos(char *str)\n{\n\treturn err_pos(last_cmd, str);\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char last_cmd[MAX_FILTER_STR_VAL];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic char last_cmd[MAX_FILTER_STR_VAL];\n\nstatic int errpos(char *str)\n{\n\treturn err_pos(last_cmd, str);\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_var",
          "args": [
            "hist_data",
            "file",
            "var_name"
          ],
          "line": 4188
        },
        "resolved": true,
        "details": {
          "function_name": "find_var",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "1079-1103",
          "snippet": "static struct hist_field *find_var(struct hist_trigger_data *hist_data,\n\t\t\t\t   struct trace_event_file *file,\n\t\t\t\t   const char *var_name)\n{\n\tstruct hist_trigger_data *test_data;\n\tstruct event_trigger_data *test;\n\tstruct hist_field *hist_field;\n\n\tlockdep_assert_held(&event_mutex);\n\n\thist_field = find_var_field(hist_data, var_name);\n\tif (hist_field)\n\t\treturn hist_field;\n\n\tlist_for_each_entry(test, &file->triggers, list) {\n\t\tif (test->cmd_ops->trigger_type == ETT_EVENT_HIST) {\n\t\t\ttest_data = test->private_data;\n\t\t\thist_field = find_var_field(test_data, var_name);\n\t\t\tif (hist_field)\n\t\t\t\treturn hist_field;\n\t\t}\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct hist_field *find_var(struct hist_trigger_data *hist_data,\n\t\t\t\t   struct trace_event_file *file,\n\t\t\t\t   const char *var_name)\n{\n\tstruct hist_trigger_data *test_data;\n\tstruct event_trigger_data *test;\n\tstruct hist_field *hist_field;\n\n\tlockdep_assert_held(&event_mutex);\n\n\thist_field = find_var_field(hist_data, var_name);\n\tif (hist_field)\n\t\treturn hist_field;\n\n\tlist_for_each_entry(test, &file->triggers, list) {\n\t\tif (test->cmd_ops->trigger_type == ETT_EVENT_HIST) {\n\t\t\ttest_data = test->private_data;\n\t\t\thist_field = find_var_field(test_data, var_name);\n\t\t\tif (hist_field)\n\t\t\t\treturn hist_field;\n\t\t}\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "val_idx >= TRACING_MAP_VALS_MAX + TRACING_MAP_VARS_MAX"
          ],
          "line": 4185
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int create_var_field(struct hist_trigger_data *hist_data,\n\t\t\t    unsigned int val_idx,\n\t\t\t    struct trace_event_file *file,\n\t\t\t    char *var_name, char *expr_str)\n{\n\tstruct trace_array *tr = hist_data->event_file->tr;\n\tunsigned long flags = 0;\n\tint ret;\n\n\tif (WARN_ON(val_idx >= TRACING_MAP_VALS_MAX + TRACING_MAP_VARS_MAX))\n\t\treturn -EINVAL;\n\n\tif (find_var(hist_data, file, var_name) && !hist_data->remove) {\n\t\thist_err(tr, HIST_ERR_DUPLICATE_VAR, errpos(var_name));\n\t\treturn -EINVAL;\n\t}\n\n\tflags |= HIST_FIELD_FL_VAR;\n\thist_data->n_vars++;\n\tif (WARN_ON(hist_data->n_vars > TRACING_MAP_VARS_MAX))\n\t\treturn -EINVAL;\n\n\tret = __create_val_field(hist_data, val_idx, file, var_name, expr_str, flags);\n\n\tif (!ret && hist_data->fields[val_idx]->flags & HIST_FIELD_FL_EXECNAME)\n\t\tupdate_var_execname(hist_data->fields[val_idx]);\n\n\tif (!ret && hist_data->fields[val_idx]->flags & HIST_FIELD_FL_STRING)\n\t\thist_data->fields[val_idx]->var_str_idx = hist_data->n_var_str++;\n\n\treturn ret;\n}"
  },
  {
    "function_name": "update_var_execname",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
    "lines": "4163-4174",
    "snippet": "static void update_var_execname(struct hist_field *hist_field)\n{\n\thist_field->flags = HIST_FIELD_FL_STRING | HIST_FIELD_FL_VAR |\n\t\tHIST_FIELD_FL_EXECNAME;\n\thist_field->size = MAX_FILTER_STR_VAL;\n\thist_field->is_signed = 0;\n\n\tkfree_const(hist_field->type);\n\thist_field->type = \"char[]\";\n\n\thist_field->fn = hist_field_execname;\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include \"tracing_map.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree_const",
          "args": [
            "hist_field->type"
          ],
          "line": 4170
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void update_var_execname(struct hist_field *hist_field)\n{\n\thist_field->flags = HIST_FIELD_FL_STRING | HIST_FIELD_FL_VAR |\n\t\tHIST_FIELD_FL_EXECNAME;\n\thist_field->size = MAX_FILTER_STR_VAL;\n\thist_field->is_signed = 0;\n\n\tkfree_const(hist_field->type);\n\thist_field->type = \"char[]\";\n\n\thist_field->fn = hist_field_execname;\n}"
  },
  {
    "function_name": "hist_field_execname",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
    "lines": "4143-4160",
    "snippet": "static u64 hist_field_execname(struct hist_field *hist_field,\n\t\t\t       struct tracing_map_elt *elt,\n\t\t\t       struct trace_buffer *buffer,\n\t\t\t       struct ring_buffer_event *rbe,\n\t\t\t       void *event)\n{\n\tstruct hist_elt_data *elt_data;\n\n\tif (WARN_ON_ONCE(!elt))\n\t\treturn (u64)(unsigned long)no_comm;\n\n\telt_data = elt->private_data;\n\n\tif (WARN_ON_ONCE(!elt_data->comm))\n\t\treturn (u64)(unsigned long)no_comm;\n\n\treturn (u64)(unsigned long)(elt_data->comm);\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include \"tracing_map.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const char *no_comm = \"(no comm)\";"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!elt_data->comm"
          ],
          "line": 4156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!elt"
          ],
          "line": 4151
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic const char *no_comm = \"(no comm)\";\n\nstatic u64 hist_field_execname(struct hist_field *hist_field,\n\t\t\t       struct tracing_map_elt *elt,\n\t\t\t       struct trace_buffer *buffer,\n\t\t\t       struct ring_buffer_event *rbe,\n\t\t\t       void *event)\n{\n\tstruct hist_elt_data *elt_data;\n\n\tif (WARN_ON_ONCE(!elt))\n\t\treturn (u64)(unsigned long)no_comm;\n\n\telt_data = elt->private_data;\n\n\tif (WARN_ON_ONCE(!elt_data->comm))\n\t\treturn (u64)(unsigned long)no_comm;\n\n\treturn (u64)(unsigned long)(elt_data->comm);\n}"
  },
  {
    "function_name": "create_val_field",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
    "lines": "4130-4139",
    "snippet": "static int create_val_field(struct hist_trigger_data *hist_data,\n\t\t\t    unsigned int val_idx,\n\t\t\t    struct trace_event_file *file,\n\t\t\t    char *field_str)\n{\n\tif (WARN_ON(val_idx >= TRACING_MAP_VALS_MAX))\n\t\treturn -EINVAL;\n\n\treturn __create_val_field(hist_data, val_idx, file, NULL, field_str, 0);\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include \"tracing_map.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__create_val_field",
          "args": [
            "hist_data",
            "val_idx",
            "file",
            "NULL",
            "field_str",
            "0"
          ],
          "line": 4138
        },
        "resolved": true,
        "details": {
          "function_name": "__create_val_field",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "4104-4128",
          "snippet": "static int __create_val_field(struct hist_trigger_data *hist_data,\n\t\t\t      unsigned int val_idx,\n\t\t\t      struct trace_event_file *file,\n\t\t\t      char *var_name, char *field_str,\n\t\t\t      unsigned long flags)\n{\n\tstruct hist_field *hist_field;\n\tint ret = 0, n_subexprs = 0;\n\n\thist_field = parse_expr(hist_data, file, field_str, flags, var_name, &n_subexprs);\n\tif (IS_ERR(hist_field)) {\n\t\tret = PTR_ERR(hist_field);\n\t\tgoto out;\n\t}\n\n\thist_data->fields[val_idx] = hist_field;\n\n\t++hist_data->n_vals;\n\t++hist_data->n_fields;\n\n\tif (WARN_ON(hist_data->n_vals > TRACING_MAP_VALS_MAX + TRACING_MAP_VARS_MAX))\n\t\tret = -EINVAL;\n out:\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hist_field *parse_expr(struct hist_trigger_data *hist_data,\n\t\t\t\t     struct trace_event_file *file,\n\t\t\t\t     char *str, unsigned long flags,\n\t\t\t\t     char *var_name, unsigned int *n_subexprs);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct hist_field *parse_expr(struct hist_trigger_data *hist_data,\n\t\t\t\t     struct trace_event_file *file,\n\t\t\t\t     char *str, unsigned long flags,\n\t\t\t\t     char *var_name, unsigned int *n_subexprs);\n\nstatic int __create_val_field(struct hist_trigger_data *hist_data,\n\t\t\t      unsigned int val_idx,\n\t\t\t      struct trace_event_file *file,\n\t\t\t      char *var_name, char *field_str,\n\t\t\t      unsigned long flags)\n{\n\tstruct hist_field *hist_field;\n\tint ret = 0, n_subexprs = 0;\n\n\thist_field = parse_expr(hist_data, file, field_str, flags, var_name, &n_subexprs);\n\tif (IS_ERR(hist_field)) {\n\t\tret = PTR_ERR(hist_field);\n\t\tgoto out;\n\t}\n\n\thist_data->fields[val_idx] = hist_field;\n\n\t++hist_data->n_vals;\n\t++hist_data->n_fields;\n\n\tif (WARN_ON(hist_data->n_vals > TRACING_MAP_VALS_MAX + TRACING_MAP_VARS_MAX))\n\t\tret = -EINVAL;\n out:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "val_idx >= TRACING_MAP_VALS_MAX"
          ],
          "line": 4135
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int create_val_field(struct hist_trigger_data *hist_data,\n\t\t\t    unsigned int val_idx,\n\t\t\t    struct trace_event_file *file,\n\t\t\t    char *field_str)\n{\n\tif (WARN_ON(val_idx >= TRACING_MAP_VALS_MAX))\n\t\treturn -EINVAL;\n\n\treturn __create_val_field(hist_data, val_idx, file, NULL, field_str, 0);\n}"
  },
  {
    "function_name": "__create_val_field",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
    "lines": "4104-4128",
    "snippet": "static int __create_val_field(struct hist_trigger_data *hist_data,\n\t\t\t      unsigned int val_idx,\n\t\t\t      struct trace_event_file *file,\n\t\t\t      char *var_name, char *field_str,\n\t\t\t      unsigned long flags)\n{\n\tstruct hist_field *hist_field;\n\tint ret = 0, n_subexprs = 0;\n\n\thist_field = parse_expr(hist_data, file, field_str, flags, var_name, &n_subexprs);\n\tif (IS_ERR(hist_field)) {\n\t\tret = PTR_ERR(hist_field);\n\t\tgoto out;\n\t}\n\n\thist_data->fields[val_idx] = hist_field;\n\n\t++hist_data->n_vals;\n\t++hist_data->n_fields;\n\n\tif (WARN_ON(hist_data->n_vals > TRACING_MAP_VALS_MAX + TRACING_MAP_VARS_MAX))\n\t\tret = -EINVAL;\n out:\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include \"tracing_map.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct hist_field *parse_expr(struct hist_trigger_data *hist_data,\n\t\t\t\t     struct trace_event_file *file,\n\t\t\t\t     char *str, unsigned long flags,\n\t\t\t\t     char *var_name, unsigned int *n_subexprs);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "hist_data->n_vals > TRACING_MAP_VALS_MAX + TRACING_MAP_VARS_MAX"
          ],
          "line": 4124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "hist_field"
          ],
          "line": 4115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "hist_field"
          ],
          "line": 4114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parse_expr",
          "args": [
            "hist_data",
            "file",
            "field_str",
            "flags",
            "var_name",
            "&n_subexprs"
          ],
          "line": 4113
        },
        "resolved": true,
        "details": {
          "function_name": "parse_expr",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "2564-2744",
          "snippet": "static struct hist_field *parse_expr(struct hist_trigger_data *hist_data,\n\t\t\t\t     struct trace_event_file *file,\n\t\t\t\t     char *str, unsigned long flags,\n\t\t\t\t     char *var_name, unsigned int *n_subexprs)\n{\n\tstruct hist_field *operand1 = NULL, *operand2 = NULL, *expr = NULL;\n\tstruct hist_field *var1 = NULL, *var2 = NULL;\n\tunsigned long operand_flags, operand2_flags;\n\tint field_op, ret = -EINVAL;\n\tchar *sep, *operand1_str;\n\thist_field_fn_t op_fn;\n\tbool combine_consts;\n\n\tif (*n_subexprs > 3) {\n\t\thist_err(file->tr, HIST_ERR_TOO_MANY_SUBEXPR, errpos(str));\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tfield_op = contains_operator(str, &sep);\n\n\tif (field_op == FIELD_OP_NONE)\n\t\treturn parse_atom(hist_data, file, str, &flags, var_name);\n\n\tif (field_op == FIELD_OP_UNARY_MINUS)\n\t\treturn parse_unary(hist_data, file, str, flags, var_name, n_subexprs);\n\n\t/* Binary operator found, increment n_subexprs */\n\t++*n_subexprs;\n\n\t/* Split the expression string at the root operator */\n\tif (!sep)\n\t\treturn ERR_PTR(-EINVAL);\n\n\t*sep = '\\0';\n\toperand1_str = str;\n\tstr = sep+1;\n\n\t/* Binary operator requires both operands */\n\tif (*operand1_str == '\\0' || *str == '\\0')\n\t\treturn ERR_PTR(-EINVAL);\n\n\toperand_flags = 0;\n\n\t/* LHS of string is an expression e.g. a+b in a+b+c */\n\toperand1 = parse_expr(hist_data, file, operand1_str, operand_flags, NULL, n_subexprs);\n\tif (IS_ERR(operand1))\n\t\treturn ERR_CAST(operand1);\n\n\tif (operand1->flags & HIST_FIELD_FL_STRING) {\n\t\thist_err(file->tr, HIST_ERR_INVALID_STR_OPERAND, errpos(operand1_str));\n\t\tret = -EINVAL;\n\t\tgoto free_op1;\n\t}\n\n\t/* RHS of string is another expression e.g. c in a+b+c */\n\toperand_flags = 0;\n\toperand2 = parse_expr(hist_data, file, str, operand_flags, NULL, n_subexprs);\n\tif (IS_ERR(operand2)) {\n\t\tret = PTR_ERR(operand2);\n\t\tgoto free_op1;\n\t}\n\tif (operand2->flags & HIST_FIELD_FL_STRING) {\n\t\thist_err(file->tr, HIST_ERR_INVALID_STR_OPERAND, errpos(str));\n\t\tret = -EINVAL;\n\t\tgoto free_operands;\n\t}\n\n\tswitch (field_op) {\n\tcase FIELD_OP_MINUS:\n\t\top_fn = hist_field_minus;\n\t\tbreak;\n\tcase FIELD_OP_PLUS:\n\t\top_fn = hist_field_plus;\n\t\tbreak;\n\tcase FIELD_OP_DIV:\n\t\top_fn = hist_field_div;\n\t\tbreak;\n\tcase FIELD_OP_MULT:\n\t\top_fn = hist_field_mult;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tgoto free_operands;\n\t}\n\n\tret = check_expr_operands(file->tr, operand1, operand2, &var1, &var2);\n\tif (ret)\n\t\tgoto free_operands;\n\n\toperand_flags = var1 ? var1->flags : operand1->flags;\n\toperand2_flags = var2 ? var2->flags : operand2->flags;\n\n\t/*\n\t * If both operands are constant, the expression can be\n\t * collapsed to a single constant.\n\t */\n\tcombine_consts = operand_flags & operand2_flags & HIST_FIELD_FL_CONST;\n\n\tflags |= combine_consts ? HIST_FIELD_FL_CONST : HIST_FIELD_FL_EXPR;\n\n\tflags |= operand1->flags &\n\t\t(HIST_FIELD_FL_TIMESTAMP | HIST_FIELD_FL_TIMESTAMP_USECS);\n\n\texpr = create_hist_field(hist_data, NULL, flags, var_name);\n\tif (!expr) {\n\t\tret = -ENOMEM;\n\t\tgoto free_operands;\n\t}\n\n\toperand1->read_once = true;\n\toperand2->read_once = true;\n\n\t/* The operands are now owned and free'd by 'expr' */\n\texpr->operands[0] = operand1;\n\texpr->operands[1] = operand2;\n\n\tif (field_op == FIELD_OP_DIV &&\n\t\t\toperand2_flags & HIST_FIELD_FL_CONST) {\n\t\tu64 divisor = var2 ? var2->constant : operand2->constant;\n\n\t\tif (!divisor) {\n\t\t\thist_err(file->tr, HIST_ERR_DIVISION_BY_ZERO, errpos(str));\n\t\t\tret = -EDOM;\n\t\t\tgoto free_expr;\n\t\t}\n\n\t\t/*\n\t\t * Copy the divisor here so we don't have to look it up\n\t\t * later if this is a var ref\n\t\t */\n\t\toperand2->constant = divisor;\n\t\top_fn = hist_field_get_div_fn(operand2);\n\t}\n\n\tif (combine_consts) {\n\t\tif (var1)\n\t\t\texpr->operands[0] = var1;\n\t\tif (var2)\n\t\t\texpr->operands[1] = var2;\n\n\t\texpr->constant = op_fn(expr, NULL, NULL, NULL, NULL);\n\n\t\texpr->operands[0] = NULL;\n\t\texpr->operands[1] = NULL;\n\n\t\t/*\n\t\t * var refs won't be destroyed immediately\n\t\t * See: destroy_hist_field()\n\t\t */\n\t\tdestroy_hist_field(operand2, 0);\n\t\tdestroy_hist_field(operand1, 0);\n\n\t\texpr->name = expr_str(expr, 0);\n\t} else {\n\t\texpr->fn = op_fn;\n\n\t\t/* The operand sizes should be the same, so just pick one */\n\t\texpr->size = operand1->size;\n\n\t\texpr->operator = field_op;\n\t\texpr->type = kstrdup_const(operand1->type, GFP_KERNEL);\n\t\tif (!expr->type) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto free_expr;\n\t\t}\n\n\t\texpr->name = expr_str(expr, 0);\n\t}\n\n\treturn expr;\n\nfree_operands:\n\tdestroy_hist_field(operand2, 0);\nfree_op1:\n\tdestroy_hist_field(operand1, 0);\n\treturn ERR_PTR(ret);\n\nfree_expr:\n\tdestroy_hist_field(expr, 0);\n\treturn ERR_PTR(ret);\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hist_field *parse_expr(struct hist_trigger_data *hist_data,\n\t\t\t\t     struct trace_event_file *file,\n\t\t\t\t     char *str, unsigned long flags,\n\t\t\t\t     char *var_name, unsigned int *n_subexprs);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct hist_field *parse_expr(struct hist_trigger_data *hist_data,\n\t\t\t\t     struct trace_event_file *file,\n\t\t\t\t     char *str, unsigned long flags,\n\t\t\t\t     char *var_name, unsigned int *n_subexprs);\n\nstatic struct hist_field *parse_expr(struct hist_trigger_data *hist_data,\n\t\t\t\t     struct trace_event_file *file,\n\t\t\t\t     char *str, unsigned long flags,\n\t\t\t\t     char *var_name, unsigned int *n_subexprs)\n{\n\tstruct hist_field *operand1 = NULL, *operand2 = NULL, *expr = NULL;\n\tstruct hist_field *var1 = NULL, *var2 = NULL;\n\tunsigned long operand_flags, operand2_flags;\n\tint field_op, ret = -EINVAL;\n\tchar *sep, *operand1_str;\n\thist_field_fn_t op_fn;\n\tbool combine_consts;\n\n\tif (*n_subexprs > 3) {\n\t\thist_err(file->tr, HIST_ERR_TOO_MANY_SUBEXPR, errpos(str));\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tfield_op = contains_operator(str, &sep);\n\n\tif (field_op == FIELD_OP_NONE)\n\t\treturn parse_atom(hist_data, file, str, &flags, var_name);\n\n\tif (field_op == FIELD_OP_UNARY_MINUS)\n\t\treturn parse_unary(hist_data, file, str, flags, var_name, n_subexprs);\n\n\t/* Binary operator found, increment n_subexprs */\n\t++*n_subexprs;\n\n\t/* Split the expression string at the root operator */\n\tif (!sep)\n\t\treturn ERR_PTR(-EINVAL);\n\n\t*sep = '\\0';\n\toperand1_str = str;\n\tstr = sep+1;\n\n\t/* Binary operator requires both operands */\n\tif (*operand1_str == '\\0' || *str == '\\0')\n\t\treturn ERR_PTR(-EINVAL);\n\n\toperand_flags = 0;\n\n\t/* LHS of string is an expression e.g. a+b in a+b+c */\n\toperand1 = parse_expr(hist_data, file, operand1_str, operand_flags, NULL, n_subexprs);\n\tif (IS_ERR(operand1))\n\t\treturn ERR_CAST(operand1);\n\n\tif (operand1->flags & HIST_FIELD_FL_STRING) {\n\t\thist_err(file->tr, HIST_ERR_INVALID_STR_OPERAND, errpos(operand1_str));\n\t\tret = -EINVAL;\n\t\tgoto free_op1;\n\t}\n\n\t/* RHS of string is another expression e.g. c in a+b+c */\n\toperand_flags = 0;\n\toperand2 = parse_expr(hist_data, file, str, operand_flags, NULL, n_subexprs);\n\tif (IS_ERR(operand2)) {\n\t\tret = PTR_ERR(operand2);\n\t\tgoto free_op1;\n\t}\n\tif (operand2->flags & HIST_FIELD_FL_STRING) {\n\t\thist_err(file->tr, HIST_ERR_INVALID_STR_OPERAND, errpos(str));\n\t\tret = -EINVAL;\n\t\tgoto free_operands;\n\t}\n\n\tswitch (field_op) {\n\tcase FIELD_OP_MINUS:\n\t\top_fn = hist_field_minus;\n\t\tbreak;\n\tcase FIELD_OP_PLUS:\n\t\top_fn = hist_field_plus;\n\t\tbreak;\n\tcase FIELD_OP_DIV:\n\t\top_fn = hist_field_div;\n\t\tbreak;\n\tcase FIELD_OP_MULT:\n\t\top_fn = hist_field_mult;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tgoto free_operands;\n\t}\n\n\tret = check_expr_operands(file->tr, operand1, operand2, &var1, &var2);\n\tif (ret)\n\t\tgoto free_operands;\n\n\toperand_flags = var1 ? var1->flags : operand1->flags;\n\toperand2_flags = var2 ? var2->flags : operand2->flags;\n\n\t/*\n\t * If both operands are constant, the expression can be\n\t * collapsed to a single constant.\n\t */\n\tcombine_consts = operand_flags & operand2_flags & HIST_FIELD_FL_CONST;\n\n\tflags |= combine_consts ? HIST_FIELD_FL_CONST : HIST_FIELD_FL_EXPR;\n\n\tflags |= operand1->flags &\n\t\t(HIST_FIELD_FL_TIMESTAMP | HIST_FIELD_FL_TIMESTAMP_USECS);\n\n\texpr = create_hist_field(hist_data, NULL, flags, var_name);\n\tif (!expr) {\n\t\tret = -ENOMEM;\n\t\tgoto free_operands;\n\t}\n\n\toperand1->read_once = true;\n\toperand2->read_once = true;\n\n\t/* The operands are now owned and free'd by 'expr' */\n\texpr->operands[0] = operand1;\n\texpr->operands[1] = operand2;\n\n\tif (field_op == FIELD_OP_DIV &&\n\t\t\toperand2_flags & HIST_FIELD_FL_CONST) {\n\t\tu64 divisor = var2 ? var2->constant : operand2->constant;\n\n\t\tif (!divisor) {\n\t\t\thist_err(file->tr, HIST_ERR_DIVISION_BY_ZERO, errpos(str));\n\t\t\tret = -EDOM;\n\t\t\tgoto free_expr;\n\t\t}\n\n\t\t/*\n\t\t * Copy the divisor here so we don't have to look it up\n\t\t * later if this is a var ref\n\t\t */\n\t\toperand2->constant = divisor;\n\t\top_fn = hist_field_get_div_fn(operand2);\n\t}\n\n\tif (combine_consts) {\n\t\tif (var1)\n\t\t\texpr->operands[0] = var1;\n\t\tif (var2)\n\t\t\texpr->operands[1] = var2;\n\n\t\texpr->constant = op_fn(expr, NULL, NULL, NULL, NULL);\n\n\t\texpr->operands[0] = NULL;\n\t\texpr->operands[1] = NULL;\n\n\t\t/*\n\t\t * var refs won't be destroyed immediately\n\t\t * See: destroy_hist_field()\n\t\t */\n\t\tdestroy_hist_field(operand2, 0);\n\t\tdestroy_hist_field(operand1, 0);\n\n\t\texpr->name = expr_str(expr, 0);\n\t} else {\n\t\texpr->fn = op_fn;\n\n\t\t/* The operand sizes should be the same, so just pick one */\n\t\texpr->size = operand1->size;\n\n\t\texpr->operator = field_op;\n\t\texpr->type = kstrdup_const(operand1->type, GFP_KERNEL);\n\t\tif (!expr->type) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto free_expr;\n\t\t}\n\n\t\texpr->name = expr_str(expr, 0);\n\t}\n\n\treturn expr;\n\nfree_operands:\n\tdestroy_hist_field(operand2, 0);\nfree_op1:\n\tdestroy_hist_field(operand1, 0);\n\treturn ERR_PTR(ret);\n\nfree_expr:\n\tdestroy_hist_field(expr, 0);\n\treturn ERR_PTR(ret);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct hist_field *parse_expr(struct hist_trigger_data *hist_data,\n\t\t\t\t     struct trace_event_file *file,\n\t\t\t\t     char *str, unsigned long flags,\n\t\t\t\t     char *var_name, unsigned int *n_subexprs);\n\nstatic int __create_val_field(struct hist_trigger_data *hist_data,\n\t\t\t      unsigned int val_idx,\n\t\t\t      struct trace_event_file *file,\n\t\t\t      char *var_name, char *field_str,\n\t\t\t      unsigned long flags)\n{\n\tstruct hist_field *hist_field;\n\tint ret = 0, n_subexprs = 0;\n\n\thist_field = parse_expr(hist_data, file, field_str, flags, var_name, &n_subexprs);\n\tif (IS_ERR(hist_field)) {\n\t\tret = PTR_ERR(hist_field);\n\t\tgoto out;\n\t}\n\n\thist_data->fields[val_idx] = hist_field;\n\n\t++hist_data->n_vals;\n\t++hist_data->n_fields;\n\n\tif (WARN_ON(hist_data->n_vals > TRACING_MAP_VALS_MAX + TRACING_MAP_VARS_MAX))\n\t\tret = -EINVAL;\n out:\n\treturn ret;\n}"
  },
  {
    "function_name": "create_hitcount_val",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
    "lines": "4088-4102",
    "snippet": "static int create_hitcount_val(struct hist_trigger_data *hist_data)\n{\n\thist_data->fields[HITCOUNT_IDX] =\n\t\tcreate_hist_field(hist_data, NULL, HIST_FIELD_FL_HITCOUNT, NULL);\n\tif (!hist_data->fields[HITCOUNT_IDX])\n\t\treturn -ENOMEM;\n\n\thist_data->n_vals++;\n\thist_data->n_fields++;\n\n\tif (WARN_ON(hist_data->n_vals > TRACING_MAP_VALS_MAX))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include \"tracing_map.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define HITCOUNT_IDX\t\t0"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "hist_data->n_vals > TRACING_MAP_VALS_MAX"
          ],
          "line": 4098
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "create_hist_field",
          "args": [
            "hist_data",
            "NULL",
            "HIST_FIELD_FL_HITCOUNT",
            "NULL"
          ],
          "line": 4091
        },
        "resolved": true,
        "details": {
          "function_name": "create_hist_field",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "1884-2007",
          "snippet": "static struct hist_field *create_hist_field(struct hist_trigger_data *hist_data,\n\t\t\t\t\t    struct ftrace_event_field *field,\n\t\t\t\t\t    unsigned long flags,\n\t\t\t\t\t    char *var_name)\n{\n\tstruct hist_field *hist_field;\n\n\tif (field && is_function_field(field))\n\t\treturn NULL;\n\n\thist_field = kzalloc(sizeof(struct hist_field), GFP_KERNEL);\n\tif (!hist_field)\n\t\treturn NULL;\n\n\thist_field->ref = 1;\n\n\thist_field->hist_data = hist_data;\n\n\tif (flags & HIST_FIELD_FL_EXPR || flags & HIST_FIELD_FL_ALIAS)\n\t\tgoto out; /* caller will populate */\n\n\tif (flags & HIST_FIELD_FL_VAR_REF) {\n\t\thist_field->fn = hist_field_var_ref;\n\t\tgoto out;\n\t}\n\n\tif (flags & HIST_FIELD_FL_HITCOUNT) {\n\t\thist_field->fn = hist_field_counter;\n\t\thist_field->size = sizeof(u64);\n\t\thist_field->type = \"u64\";\n\t\tgoto out;\n\t}\n\n\tif (flags & HIST_FIELD_FL_CONST) {\n\t\thist_field->fn = hist_field_const;\n\t\thist_field->size = sizeof(u64);\n\t\thist_field->type = kstrdup(\"u64\", GFP_KERNEL);\n\t\tif (!hist_field->type)\n\t\t\tgoto free;\n\t\tgoto out;\n\t}\n\n\tif (flags & HIST_FIELD_FL_STACKTRACE) {\n\t\thist_field->fn = hist_field_none;\n\t\tgoto out;\n\t}\n\n\tif (flags & (HIST_FIELD_FL_LOG2 | HIST_FIELD_FL_BUCKET)) {\n\t\tunsigned long fl = flags & ~(HIST_FIELD_FL_LOG2 | HIST_FIELD_FL_BUCKET);\n\t\thist_field->fn = flags & HIST_FIELD_FL_LOG2 ? hist_field_log2 :\n\t\t\thist_field_bucket;\n\t\thist_field->operands[0] = create_hist_field(hist_data, field, fl, NULL);\n\t\thist_field->size = hist_field->operands[0]->size;\n\t\thist_field->type = kstrdup_const(hist_field->operands[0]->type, GFP_KERNEL);\n\t\tif (!hist_field->type)\n\t\t\tgoto free;\n\t\tgoto out;\n\t}\n\n\tif (flags & HIST_FIELD_FL_TIMESTAMP) {\n\t\thist_field->fn = hist_field_timestamp;\n\t\thist_field->size = sizeof(u64);\n\t\thist_field->type = \"u64\";\n\t\tgoto out;\n\t}\n\n\tif (flags & HIST_FIELD_FL_CPU) {\n\t\thist_field->fn = hist_field_cpu;\n\t\thist_field->size = sizeof(int);\n\t\thist_field->type = \"unsigned int\";\n\t\tgoto out;\n\t}\n\n\tif (WARN_ON_ONCE(!field))\n\t\tgoto out;\n\n\t/* Pointers to strings are just pointers and dangerous to dereference */\n\tif (is_string_field(field) &&\n\t    (field->filter_type != FILTER_PTR_STRING)) {\n\t\tflags |= HIST_FIELD_FL_STRING;\n\n\t\thist_field->size = MAX_FILTER_STR_VAL;\n\t\thist_field->type = kstrdup_const(field->type, GFP_KERNEL);\n\t\tif (!hist_field->type)\n\t\t\tgoto free;\n\n\t\tif (field->filter_type == FILTER_STATIC_STRING) {\n\t\t\thist_field->fn = hist_field_string;\n\t\t\thist_field->size = field->size;\n\t\t} else if (field->filter_type == FILTER_DYN_STRING) {\n\t\t\thist_field->fn = hist_field_dynstring;\n\t\t} else if (field->filter_type == FILTER_RDYN_STRING)\n\t\t\thist_field->fn = hist_field_reldynstring;\n\t\telse\n\t\t\thist_field->fn = hist_field_pstring;\n\t} else {\n\t\thist_field->size = field->size;\n\t\thist_field->is_signed = field->is_signed;\n\t\thist_field->type = kstrdup_const(field->type, GFP_KERNEL);\n\t\tif (!hist_field->type)\n\t\t\tgoto free;\n\n\t\thist_field->fn = select_value_fn(field->size,\n\t\t\t\t\t\t field->is_signed);\n\t\tif (!hist_field->fn) {\n\t\t\tdestroy_hist_field(hist_field, 0);\n\t\t\treturn NULL;\n\t\t}\n\t}\n out:\n\thist_field->field = field;\n\thist_field->flags = flags;\n\n\tif (var_name) {\n\t\thist_field->var.name = kstrdup(var_name, GFP_KERNEL);\n\t\tif (!hist_field->var.name)\n\t\t\tgoto free;\n\t}\n\n\treturn hist_field;\n free:\n\tdestroy_hist_field(hist_field, 0);\n\treturn NULL;\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct hist_field *create_hist_field(struct hist_trigger_data *hist_data,\n\t\t\t\t\t    struct ftrace_event_field *field,\n\t\t\t\t\t    unsigned long flags,\n\t\t\t\t\t    char *var_name)\n{\n\tstruct hist_field *hist_field;\n\n\tif (field && is_function_field(field))\n\t\treturn NULL;\n\n\thist_field = kzalloc(sizeof(struct hist_field), GFP_KERNEL);\n\tif (!hist_field)\n\t\treturn NULL;\n\n\thist_field->ref = 1;\n\n\thist_field->hist_data = hist_data;\n\n\tif (flags & HIST_FIELD_FL_EXPR || flags & HIST_FIELD_FL_ALIAS)\n\t\tgoto out; /* caller will populate */\n\n\tif (flags & HIST_FIELD_FL_VAR_REF) {\n\t\thist_field->fn = hist_field_var_ref;\n\t\tgoto out;\n\t}\n\n\tif (flags & HIST_FIELD_FL_HITCOUNT) {\n\t\thist_field->fn = hist_field_counter;\n\t\thist_field->size = sizeof(u64);\n\t\thist_field->type = \"u64\";\n\t\tgoto out;\n\t}\n\n\tif (flags & HIST_FIELD_FL_CONST) {\n\t\thist_field->fn = hist_field_const;\n\t\thist_field->size = sizeof(u64);\n\t\thist_field->type = kstrdup(\"u64\", GFP_KERNEL);\n\t\tif (!hist_field->type)\n\t\t\tgoto free;\n\t\tgoto out;\n\t}\n\n\tif (flags & HIST_FIELD_FL_STACKTRACE) {\n\t\thist_field->fn = hist_field_none;\n\t\tgoto out;\n\t}\n\n\tif (flags & (HIST_FIELD_FL_LOG2 | HIST_FIELD_FL_BUCKET)) {\n\t\tunsigned long fl = flags & ~(HIST_FIELD_FL_LOG2 | HIST_FIELD_FL_BUCKET);\n\t\thist_field->fn = flags & HIST_FIELD_FL_LOG2 ? hist_field_log2 :\n\t\t\thist_field_bucket;\n\t\thist_field->operands[0] = create_hist_field(hist_data, field, fl, NULL);\n\t\thist_field->size = hist_field->operands[0]->size;\n\t\thist_field->type = kstrdup_const(hist_field->operands[0]->type, GFP_KERNEL);\n\t\tif (!hist_field->type)\n\t\t\tgoto free;\n\t\tgoto out;\n\t}\n\n\tif (flags & HIST_FIELD_FL_TIMESTAMP) {\n\t\thist_field->fn = hist_field_timestamp;\n\t\thist_field->size = sizeof(u64);\n\t\thist_field->type = \"u64\";\n\t\tgoto out;\n\t}\n\n\tif (flags & HIST_FIELD_FL_CPU) {\n\t\thist_field->fn = hist_field_cpu;\n\t\thist_field->size = sizeof(int);\n\t\thist_field->type = \"unsigned int\";\n\t\tgoto out;\n\t}\n\n\tif (WARN_ON_ONCE(!field))\n\t\tgoto out;\n\n\t/* Pointers to strings are just pointers and dangerous to dereference */\n\tif (is_string_field(field) &&\n\t    (field->filter_type != FILTER_PTR_STRING)) {\n\t\tflags |= HIST_FIELD_FL_STRING;\n\n\t\thist_field->size = MAX_FILTER_STR_VAL;\n\t\thist_field->type = kstrdup_const(field->type, GFP_KERNEL);\n\t\tif (!hist_field->type)\n\t\t\tgoto free;\n\n\t\tif (field->filter_type == FILTER_STATIC_STRING) {\n\t\t\thist_field->fn = hist_field_string;\n\t\t\thist_field->size = field->size;\n\t\t} else if (field->filter_type == FILTER_DYN_STRING) {\n\t\t\thist_field->fn = hist_field_dynstring;\n\t\t} else if (field->filter_type == FILTER_RDYN_STRING)\n\t\t\thist_field->fn = hist_field_reldynstring;\n\t\telse\n\t\t\thist_field->fn = hist_field_pstring;\n\t} else {\n\t\thist_field->size = field->size;\n\t\thist_field->is_signed = field->is_signed;\n\t\thist_field->type = kstrdup_const(field->type, GFP_KERNEL);\n\t\tif (!hist_field->type)\n\t\t\tgoto free;\n\n\t\thist_field->fn = select_value_fn(field->size,\n\t\t\t\t\t\t field->is_signed);\n\t\tif (!hist_field->fn) {\n\t\t\tdestroy_hist_field(hist_field, 0);\n\t\t\treturn NULL;\n\t\t}\n\t}\n out:\n\thist_field->field = field;\n\thist_field->flags = flags;\n\n\tif (var_name) {\n\t\thist_field->var.name = kstrdup(var_name, GFP_KERNEL);\n\t\tif (!hist_field->var.name)\n\t\t\tgoto free;\n\t}\n\n\treturn hist_field;\n free:\n\tdestroy_hist_field(hist_field, 0);\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\n#define HITCOUNT_IDX\t\t0\n\nstatic int create_hitcount_val(struct hist_trigger_data *hist_data)\n{\n\thist_data->fields[HITCOUNT_IDX] =\n\t\tcreate_hist_field(hist_data, NULL, HIST_FIELD_FL_HITCOUNT, NULL);\n\tif (!hist_data->fields[HITCOUNT_IDX])\n\t\treturn -ENOMEM;\n\n\thist_data->n_vals++;\n\thist_data->n_fields++;\n\n\tif (WARN_ON(hist_data->n_vals > TRACING_MAP_VALS_MAX))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "onmatch_parse",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
    "lines": "4038-4086",
    "snippet": "static struct action_data *onmatch_parse(struct trace_array *tr, char *str)\n{\n\tchar *match_event, *match_event_system;\n\tstruct action_data *data;\n\tint ret = -EINVAL;\n\n\tdata = kzalloc(sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmatch_event = strsep(&str, \")\");\n\tif (!match_event || !str) {\n\t\thist_err(tr, HIST_ERR_NO_CLOSING_PAREN, errpos(match_event));\n\t\tgoto free;\n\t}\n\n\tmatch_event_system = strsep(&match_event, \".\");\n\tif (!match_event) {\n\t\thist_err(tr, HIST_ERR_SUBSYS_NOT_FOUND, errpos(match_event_system));\n\t\tgoto free;\n\t}\n\n\tif (IS_ERR(event_file(tr, match_event_system, match_event))) {\n\t\thist_err(tr, HIST_ERR_INVALID_SUBSYS_EVENT, errpos(match_event));\n\t\tgoto free;\n\t}\n\n\tdata->match_data.event = kstrdup(match_event, GFP_KERNEL);\n\tif (!data->match_data.event) {\n\t\tret = -ENOMEM;\n\t\tgoto free;\n\t}\n\n\tdata->match_data.event_system = kstrdup(match_event_system, GFP_KERNEL);\n\tif (!data->match_data.event_system) {\n\t\tret = -ENOMEM;\n\t\tgoto free;\n\t}\n\n\tret = action_parse(tr, str, data, HANDLER_ONMATCH);\n\tif (ret)\n\t\tgoto free;\n out:\n\treturn data;\n free:\n\tonmatch_destroy(data);\n\tdata = ERR_PTR(ret);\n\tgoto out;\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include \"tracing_map.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "ret"
          ],
          "line": 4084
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "onmatch_destroy",
          "args": [
            "data"
          ],
          "line": 4083
        },
        "resolved": true,
        "details": {
          "function_name": "onmatch_destroy",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "3714-3720",
          "snippet": "static void onmatch_destroy(struct action_data *data)\n{\n\tkfree(data->match_data.event);\n\tkfree(data->match_data.event_system);\n\n\taction_data_destroy(data);\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);\n\nstatic void onmatch_destroy(struct action_data *data)\n{\n\tkfree(data->match_data.event);\n\tkfree(data->match_data.event_system);\n\n\taction_data_destroy(data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "action_parse",
          "args": [
            "tr",
            "str",
            "data",
            "HANDLER_ONMATCH"
          ],
          "line": 4077
        },
        "resolved": true,
        "details": {
          "function_name": "action_parse",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "3575-3678",
          "snippet": "static int action_parse(struct trace_array *tr, char *str, struct action_data *data,\n\t\t\tenum handler_id handler)\n{\n\tchar *action_name;\n\tint ret = 0;\n\n\tstrsep(&str, \".\");\n\tif (!str) {\n\t\thist_err(tr, HIST_ERR_ACTION_NOT_FOUND, 0);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\taction_name = strsep(&str, \"(\");\n\tif (!action_name || !str) {\n\t\thist_err(tr, HIST_ERR_ACTION_NOT_FOUND, 0);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (str_has_prefix(action_name, \"save\")) {\n\t\tchar *params = strsep(&str, \")\");\n\n\t\tif (!params) {\n\t\t\thist_err(tr, HIST_ERR_NO_SAVE_PARAMS, 0);\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = parse_action_params(tr, params, data);\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\tif (handler == HANDLER_ONMAX)\n\t\t\tdata->track_data.check_val = check_track_val_max;\n\t\telse if (handler == HANDLER_ONCHANGE)\n\t\t\tdata->track_data.check_val = check_track_val_changed;\n\t\telse {\n\t\t\thist_err(tr, HIST_ERR_ACTION_MISMATCH, errpos(action_name));\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tdata->track_data.save_data = save_track_data_vars;\n\t\tdata->fn = ontrack_action;\n\t\tdata->action = ACTION_SAVE;\n\t} else if (str_has_prefix(action_name, \"snapshot\")) {\n\t\tchar *params = strsep(&str, \")\");\n\n\t\tif (!str) {\n\t\t\thist_err(tr, HIST_ERR_NO_CLOSING_PAREN, errpos(params));\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (handler == HANDLER_ONMAX)\n\t\t\tdata->track_data.check_val = check_track_val_max;\n\t\telse if (handler == HANDLER_ONCHANGE)\n\t\t\tdata->track_data.check_val = check_track_val_changed;\n\t\telse {\n\t\t\thist_err(tr, HIST_ERR_ACTION_MISMATCH, errpos(action_name));\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tdata->track_data.save_data = save_track_data_snapshot;\n\t\tdata->fn = ontrack_action;\n\t\tdata->action = ACTION_SNAPSHOT;\n\t} else {\n\t\tchar *params = strsep(&str, \")\");\n\n\t\tif (str_has_prefix(action_name, \"trace\"))\n\t\t\tdata->use_trace_keyword = true;\n\n\t\tif (params) {\n\t\t\tret = parse_action_params(tr, params, data);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t}\n\n\t\tif (handler == HANDLER_ONMAX)\n\t\t\tdata->track_data.check_val = check_track_val_max;\n\t\telse if (handler == HANDLER_ONCHANGE)\n\t\t\tdata->track_data.check_val = check_track_val_changed;\n\n\t\tif (handler != HANDLER_ONMATCH) {\n\t\t\tdata->track_data.save_data = action_trace;\n\t\t\tdata->fn = ontrack_action;\n\t\t} else\n\t\t\tdata->fn = action_trace;\n\n\t\tdata->action = ACTION_TRACE;\n\t}\n\n\tdata->action_name = kstrdup(action_name, GFP_KERNEL);\n\tif (!data->action_name) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tdata->handler = handler;\n out:\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);\n\nstatic int action_parse(struct trace_array *tr, char *str, struct action_data *data,\n\t\t\tenum handler_id handler)\n{\n\tchar *action_name;\n\tint ret = 0;\n\n\tstrsep(&str, \".\");\n\tif (!str) {\n\t\thist_err(tr, HIST_ERR_ACTION_NOT_FOUND, 0);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\taction_name = strsep(&str, \"(\");\n\tif (!action_name || !str) {\n\t\thist_err(tr, HIST_ERR_ACTION_NOT_FOUND, 0);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (str_has_prefix(action_name, \"save\")) {\n\t\tchar *params = strsep(&str, \")\");\n\n\t\tif (!params) {\n\t\t\thist_err(tr, HIST_ERR_NO_SAVE_PARAMS, 0);\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = parse_action_params(tr, params, data);\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\tif (handler == HANDLER_ONMAX)\n\t\t\tdata->track_data.check_val = check_track_val_max;\n\t\telse if (handler == HANDLER_ONCHANGE)\n\t\t\tdata->track_data.check_val = check_track_val_changed;\n\t\telse {\n\t\t\thist_err(tr, HIST_ERR_ACTION_MISMATCH, errpos(action_name));\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tdata->track_data.save_data = save_track_data_vars;\n\t\tdata->fn = ontrack_action;\n\t\tdata->action = ACTION_SAVE;\n\t} else if (str_has_prefix(action_name, \"snapshot\")) {\n\t\tchar *params = strsep(&str, \")\");\n\n\t\tif (!str) {\n\t\t\thist_err(tr, HIST_ERR_NO_CLOSING_PAREN, errpos(params));\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (handler == HANDLER_ONMAX)\n\t\t\tdata->track_data.check_val = check_track_val_max;\n\t\telse if (handler == HANDLER_ONCHANGE)\n\t\t\tdata->track_data.check_val = check_track_val_changed;\n\t\telse {\n\t\t\thist_err(tr, HIST_ERR_ACTION_MISMATCH, errpos(action_name));\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tdata->track_data.save_data = save_track_data_snapshot;\n\t\tdata->fn = ontrack_action;\n\t\tdata->action = ACTION_SNAPSHOT;\n\t} else {\n\t\tchar *params = strsep(&str, \")\");\n\n\t\tif (str_has_prefix(action_name, \"trace\"))\n\t\t\tdata->use_trace_keyword = true;\n\n\t\tif (params) {\n\t\t\tret = parse_action_params(tr, params, data);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t}\n\n\t\tif (handler == HANDLER_ONMAX)\n\t\t\tdata->track_data.check_val = check_track_val_max;\n\t\telse if (handler == HANDLER_ONCHANGE)\n\t\t\tdata->track_data.check_val = check_track_val_changed;\n\n\t\tif (handler != HANDLER_ONMATCH) {\n\t\t\tdata->track_data.save_data = action_trace;\n\t\t\tdata->fn = ontrack_action;\n\t\t} else\n\t\t\tdata->fn = action_trace;\n\n\t\tdata->action = ACTION_TRACE;\n\t}\n\n\tdata->action_name = kstrdup(action_name, GFP_KERNEL);\n\tif (!data->action_name) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tdata->handler = handler;\n out:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "match_event_system",
            "GFP_KERNEL"
          ],
          "line": 4071
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "match_event",
            "GFP_KERNEL"
          ],
          "line": 4065
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hist_err",
          "args": [
            "tr",
            "HIST_ERR_INVALID_SUBSYS_EVENT",
            "errpos(match_event)"
          ],
          "line": 4061
        },
        "resolved": true,
        "details": {
          "function_name": "hist_err",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "763-767",
          "snippet": "static void hist_err(struct trace_array *tr, u8 err_type, u8 err_pos)\n{\n\ttracing_log_err(tr, last_cmd_loc, last_cmd, err_text,\n\t\t\terr_type, err_pos);\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *err_text[] = { ERRORS };",
            "static char last_cmd[MAX_FILTER_STR_VAL];",
            "static char last_cmd_loc[MAX_FILTER_STR_VAL];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic const char *err_text[] = { ERRORS };\nstatic char last_cmd[MAX_FILTER_STR_VAL];\nstatic char last_cmd_loc[MAX_FILTER_STR_VAL];\n\nstatic void hist_err(struct trace_array *tr, u8 err_type, u8 err_pos)\n{\n\ttracing_log_err(tr, last_cmd_loc, last_cmd, err_text,\n\t\t\terr_type, err_pos);\n}"
        }
      },
      {
        "call_info": {
          "callee": "errpos",
          "args": [
            "match_event"
          ],
          "line": 4061
        },
        "resolved": true,
        "details": {
          "function_name": "errpos",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "733-736",
          "snippet": "static int errpos(char *str)\n{\n\treturn err_pos(last_cmd, str);\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char last_cmd[MAX_FILTER_STR_VAL];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic char last_cmd[MAX_FILTER_STR_VAL];\n\nstatic int errpos(char *str)\n{\n\treturn err_pos(last_cmd, str);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "event_file(tr, match_event_system, match_event)"
          ],
          "line": 4060
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "event_file",
          "args": [
            "tr",
            "match_event_system",
            "match_event"
          ],
          "line": 4060
        },
        "resolved": true,
        "details": {
          "function_name": "event_file",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "2820-2830",
          "snippet": "static struct trace_event_file *event_file(struct trace_array *tr,\n\t\t\t\t\t   char *system, char *event_name)\n{\n\tstruct trace_event_file *file;\n\n\tfile = __find_event_file(tr, system, event_name);\n\tif (!file)\n\t\treturn ERR_PTR(-EINVAL);\n\n\treturn file;\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct trace_event_file *event_file(struct trace_array *tr,\n\t\t\t\t\t   char *system, char *event_name)\n{\n\tstruct trace_event_file *file;\n\n\tfile = __find_event_file(tr, system, event_name);\n\tif (!file)\n\t\treturn ERR_PTR(-EINVAL);\n\n\treturn file;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strsep",
          "args": [
            "&match_event",
            "\".\""
          ],
          "line": 4054
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strsep",
          "args": [
            "&str",
            "\")\""
          ],
          "line": 4048
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 4046
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*data)",
            "GFP_KERNEL"
          ],
          "line": 4044
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);\n\nstatic struct action_data *onmatch_parse(struct trace_array *tr, char *str)\n{\n\tchar *match_event, *match_event_system;\n\tstruct action_data *data;\n\tint ret = -EINVAL;\n\n\tdata = kzalloc(sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmatch_event = strsep(&str, \")\");\n\tif (!match_event || !str) {\n\t\thist_err(tr, HIST_ERR_NO_CLOSING_PAREN, errpos(match_event));\n\t\tgoto free;\n\t}\n\n\tmatch_event_system = strsep(&match_event, \".\");\n\tif (!match_event) {\n\t\thist_err(tr, HIST_ERR_SUBSYS_NOT_FOUND, errpos(match_event_system));\n\t\tgoto free;\n\t}\n\n\tif (IS_ERR(event_file(tr, match_event_system, match_event))) {\n\t\thist_err(tr, HIST_ERR_INVALID_SUBSYS_EVENT, errpos(match_event));\n\t\tgoto free;\n\t}\n\n\tdata->match_data.event = kstrdup(match_event, GFP_KERNEL);\n\tif (!data->match_data.event) {\n\t\tret = -ENOMEM;\n\t\tgoto free;\n\t}\n\n\tdata->match_data.event_system = kstrdup(match_event_system, GFP_KERNEL);\n\tif (!data->match_data.event_system) {\n\t\tret = -ENOMEM;\n\t\tgoto free;\n\t}\n\n\tret = action_parse(tr, str, data, HANDLER_ONMATCH);\n\tif (ret)\n\t\tgoto free;\n out:\n\treturn data;\n free:\n\tonmatch_destroy(data);\n\tdata = ERR_PTR(ret);\n\tgoto out;\n}"
  },
  {
    "function_name": "onmatch_create",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
    "lines": "4032-4036",
    "snippet": "static int onmatch_create(struct hist_trigger_data *hist_data,\n\t\t\t  struct action_data *data)\n{\n\treturn action_create(hist_data, data);\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include \"tracing_map.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "action_create",
          "args": [
            "hist_data",
            "data"
          ],
          "line": 4035
        },
        "resolved": true,
        "details": {
          "function_name": "action_create",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "3970-4030",
          "snippet": "static int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data)\n{\n\tstruct trace_event_file *file = hist_data->event_file;\n\tstruct trace_array *tr = file->tr;\n\tstruct track_data *track_data;\n\tstruct field_var *field_var;\n\tunsigned int i;\n\tchar *param;\n\tint ret = 0;\n\n\tif (data->action == ACTION_TRACE)\n\t\treturn trace_action_create(hist_data, data);\n\n\tif (data->action == ACTION_SNAPSHOT) {\n\t\ttrack_data = track_data_alloc(hist_data->key_size, data, hist_data);\n\t\tif (IS_ERR(track_data)) {\n\t\t\tret = PTR_ERR(track_data);\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = tracing_snapshot_cond_enable(file->tr, track_data,\n\t\t\t\t\t\t   cond_snapshot_update);\n\t\tif (ret)\n\t\t\ttrack_data_free(track_data);\n\n\t\tgoto out;\n\t}\n\n\tif (data->action == ACTION_SAVE) {\n\t\tif (hist_data->n_save_vars) {\n\t\t\tret = -EEXIST;\n\t\t\thist_err(tr, HIST_ERR_TOO_MANY_SAVE_ACTIONS, 0);\n\t\t\tgoto out;\n\t\t}\n\n\t\tfor (i = 0; i < data->n_params; i++) {\n\t\t\tparam = kstrdup(data->params[i], GFP_KERNEL);\n\t\t\tif (!param) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tfield_var = create_target_field_var(hist_data, NULL, NULL, param);\n\t\t\tif (IS_ERR(field_var)) {\n\t\t\t\thist_err(tr, HIST_ERR_FIELD_VAR_CREATE_FAIL,\n\t\t\t\t\t errpos(param));\n\t\t\t\tret = PTR_ERR(field_var);\n\t\t\t\tkfree(param);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\thist_data->save_vars[hist_data->n_save_vars++] = field_var;\n\t\t\tif (field_var->val->flags & HIST_FIELD_FL_STRING)\n\t\t\t\thist_data->n_save_var_str++;\n\t\t\tkfree(param);\n\t\t}\n\t}\n out:\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int event_hist_trigger_parse(struct event_command *cmd_ops,\n\t\t\t\t    struct trace_event_file *file,\n\t\t\t\t    char *glob, char *cmd, char *param);",
            "static int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int event_hist_trigger_parse(struct event_command *cmd_ops,\n\t\t\t\t    struct trace_event_file *file,\n\t\t\t\t    char *glob, char *cmd, char *param);\nstatic int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);\n\nstatic int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data)\n{\n\tstruct trace_event_file *file = hist_data->event_file;\n\tstruct trace_array *tr = file->tr;\n\tstruct track_data *track_data;\n\tstruct field_var *field_var;\n\tunsigned int i;\n\tchar *param;\n\tint ret = 0;\n\n\tif (data->action == ACTION_TRACE)\n\t\treturn trace_action_create(hist_data, data);\n\n\tif (data->action == ACTION_SNAPSHOT) {\n\t\ttrack_data = track_data_alloc(hist_data->key_size, data, hist_data);\n\t\tif (IS_ERR(track_data)) {\n\t\t\tret = PTR_ERR(track_data);\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = tracing_snapshot_cond_enable(file->tr, track_data,\n\t\t\t\t\t\t   cond_snapshot_update);\n\t\tif (ret)\n\t\t\ttrack_data_free(track_data);\n\n\t\tgoto out;\n\t}\n\n\tif (data->action == ACTION_SAVE) {\n\t\tif (hist_data->n_save_vars) {\n\t\t\tret = -EEXIST;\n\t\t\thist_err(tr, HIST_ERR_TOO_MANY_SAVE_ACTIONS, 0);\n\t\t\tgoto out;\n\t\t}\n\n\t\tfor (i = 0; i < data->n_params; i++) {\n\t\t\tparam = kstrdup(data->params[i], GFP_KERNEL);\n\t\t\tif (!param) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tfield_var = create_target_field_var(hist_data, NULL, NULL, param);\n\t\t\tif (IS_ERR(field_var)) {\n\t\t\t\thist_err(tr, HIST_ERR_FIELD_VAR_CREATE_FAIL,\n\t\t\t\t\t errpos(param));\n\t\t\t\tret = PTR_ERR(field_var);\n\t\t\t\tkfree(param);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\thist_data->save_vars[hist_data->n_save_vars++] = field_var;\n\t\t\tif (field_var->val->flags & HIST_FIELD_FL_STRING)\n\t\t\t\thist_data->n_save_var_str++;\n\t\t\tkfree(param);\n\t\t}\n\t}\n out:\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);\n\nstatic int onmatch_create(struct hist_trigger_data *hist_data,\n\t\t\t  struct action_data *data)\n{\n\treturn action_create(hist_data, data);\n}"
  },
  {
    "function_name": "action_create",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
    "lines": "3970-4030",
    "snippet": "static int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data)\n{\n\tstruct trace_event_file *file = hist_data->event_file;\n\tstruct trace_array *tr = file->tr;\n\tstruct track_data *track_data;\n\tstruct field_var *field_var;\n\tunsigned int i;\n\tchar *param;\n\tint ret = 0;\n\n\tif (data->action == ACTION_TRACE)\n\t\treturn trace_action_create(hist_data, data);\n\n\tif (data->action == ACTION_SNAPSHOT) {\n\t\ttrack_data = track_data_alloc(hist_data->key_size, data, hist_data);\n\t\tif (IS_ERR(track_data)) {\n\t\t\tret = PTR_ERR(track_data);\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = tracing_snapshot_cond_enable(file->tr, track_data,\n\t\t\t\t\t\t   cond_snapshot_update);\n\t\tif (ret)\n\t\t\ttrack_data_free(track_data);\n\n\t\tgoto out;\n\t}\n\n\tif (data->action == ACTION_SAVE) {\n\t\tif (hist_data->n_save_vars) {\n\t\t\tret = -EEXIST;\n\t\t\thist_err(tr, HIST_ERR_TOO_MANY_SAVE_ACTIONS, 0);\n\t\t\tgoto out;\n\t\t}\n\n\t\tfor (i = 0; i < data->n_params; i++) {\n\t\t\tparam = kstrdup(data->params[i], GFP_KERNEL);\n\t\t\tif (!param) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tfield_var = create_target_field_var(hist_data, NULL, NULL, param);\n\t\t\tif (IS_ERR(field_var)) {\n\t\t\t\thist_err(tr, HIST_ERR_FIELD_VAR_CREATE_FAIL,\n\t\t\t\t\t errpos(param));\n\t\t\t\tret = PTR_ERR(field_var);\n\t\t\t\tkfree(param);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\thist_data->save_vars[hist_data->n_save_vars++] = field_var;\n\t\t\tif (field_var->val->flags & HIST_FIELD_FL_STRING)\n\t\t\t\thist_data->n_save_var_str++;\n\t\t\tkfree(param);\n\t\t}\n\t}\n out:\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include \"tracing_map.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int event_hist_trigger_parse(struct event_command *cmd_ops,\n\t\t\t\t    struct trace_event_file *file,\n\t\t\t\t    char *glob, char *cmd, char *param);",
      "static int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "param"
          ],
          "line": 4025
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "field_var"
          ],
          "line": 4017
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hist_err",
          "args": [
            "tr",
            "HIST_ERR_FIELD_VAR_CREATE_FAIL",
            "errpos(param)"
          ],
          "line": 4015
        },
        "resolved": true,
        "details": {
          "function_name": "hist_err",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "763-767",
          "snippet": "static void hist_err(struct trace_array *tr, u8 err_type, u8 err_pos)\n{\n\ttracing_log_err(tr, last_cmd_loc, last_cmd, err_text,\n\t\t\terr_type, err_pos);\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *err_text[] = { ERRORS };",
            "static char last_cmd[MAX_FILTER_STR_VAL];",
            "static char last_cmd_loc[MAX_FILTER_STR_VAL];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic const char *err_text[] = { ERRORS };\nstatic char last_cmd[MAX_FILTER_STR_VAL];\nstatic char last_cmd_loc[MAX_FILTER_STR_VAL];\n\nstatic void hist_err(struct trace_array *tr, u8 err_type, u8 err_pos)\n{\n\ttracing_log_err(tr, last_cmd_loc, last_cmd, err_text,\n\t\t\terr_type, err_pos);\n}"
        }
      },
      {
        "call_info": {
          "callee": "errpos",
          "args": [
            "param"
          ],
          "line": 4016
        },
        "resolved": true,
        "details": {
          "function_name": "errpos",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "733-736",
          "snippet": "static int errpos(char *str)\n{\n\treturn err_pos(last_cmd, str);\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char last_cmd[MAX_FILTER_STR_VAL];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic char last_cmd[MAX_FILTER_STR_VAL];\n\nstatic int errpos(char *str)\n{\n\treturn err_pos(last_cmd, str);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "field_var"
          ],
          "line": 4014
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "create_target_field_var",
          "args": [
            "hist_data",
            "NULL",
            "NULL",
            "param"
          ],
          "line": 4013
        },
        "resolved": true,
        "details": {
          "function_name": "create_target_field_var",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "3188-3210",
          "snippet": "static struct field_var *\ncreate_target_field_var(struct hist_trigger_data *target_hist_data,\n\t\t\tchar *subsys_name, char *event_name, char *var_name)\n{\n\tstruct trace_event_file *file = target_hist_data->event_file;\n\n\tif (subsys_name) {\n\t\tstruct trace_event_call *call;\n\n\t\tif (!event_name)\n\t\t\treturn NULL;\n\n\t\tcall = file->event_call;\n\n\t\tif (strcmp(subsys_name, call->class->system) != 0)\n\t\t\treturn NULL;\n\n\t\tif (strcmp(event_name, trace_event_name(call)) != 0)\n\t\t\treturn NULL;\n\t}\n\n\treturn create_field_var(target_hist_data, file, var_name);\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct field_var *\ncreate_target_field_var(struct hist_trigger_data *target_hist_data,\n\t\t\tchar *subsys_name, char *event_name, char *var_name)\n{\n\tstruct trace_event_file *file = target_hist_data->event_file;\n\n\tif (subsys_name) {\n\t\tstruct trace_event_call *call;\n\n\t\tif (!event_name)\n\t\t\treturn NULL;\n\n\t\tcall = file->event_call;\n\n\t\tif (strcmp(subsys_name, call->class->system) != 0)\n\t\t\treturn NULL;\n\n\t\tif (strcmp(event_name, trace_event_name(call)) != 0)\n\t\t\treturn NULL;\n\t}\n\n\treturn create_field_var(target_hist_data, file, var_name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "data->params[i]",
            "GFP_KERNEL"
          ],
          "line": 4007
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "track_data_free",
          "args": [
            "track_data"
          ],
          "line": 3994
        },
        "resolved": true,
        "details": {
          "function_name": "track_data_free",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "675-691",
          "snippet": "static void track_data_free(struct track_data *track_data)\n{\n\tstruct hist_elt_data *elt_data;\n\n\tif (!track_data)\n\t\treturn;\n\n\tkfree(track_data->key);\n\n\telt_data = track_data->elt.private_data;\n\tif (elt_data) {\n\t\tkfree(elt_data->comm);\n\t\tkfree(elt_data);\n\t}\n\n\tkfree(track_data);\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void track_data_free(struct track_data *track_data)\n{\n\tstruct hist_elt_data *elt_data;\n\n\tif (!track_data)\n\t\treturn;\n\n\tkfree(track_data->key);\n\n\telt_data = track_data->elt.private_data;\n\tif (elt_data) {\n\t\tkfree(elt_data->comm);\n\t\tkfree(elt_data);\n\t}\n\n\tkfree(track_data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracing_snapshot_cond_enable",
          "args": [
            "file->tr",
            "track_data",
            "cond_snapshot_update"
          ],
          "line": 3991
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_snapshot_cond_enable",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "1392-1395",
          "snippet": "int tracing_snapshot_cond_enable(struct trace_array *tr, void *cond_data, cond_update_fn_t update)\n{\n\treturn -ENODEV;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nint tracing_snapshot_cond_enable(struct trace_array *tr, void *cond_data, cond_update_fn_t update)\n{\n\treturn -ENODEV;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "track_data"
          ],
          "line": 3987
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "track_data"
          ],
          "line": 3986
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "track_data_alloc",
          "args": [
            "hist_data->key_size",
            "data",
            "hist_data"
          ],
          "line": 3985
        },
        "resolved": true,
        "details": {
          "function_name": "track_data_alloc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "693-728",
          "snippet": "static struct track_data *track_data_alloc(unsigned int key_len,\n\t\t\t\t\t   struct action_data *action_data,\n\t\t\t\t\t   struct hist_trigger_data *hist_data)\n{\n\tstruct track_data *data = kzalloc(sizeof(*data), GFP_KERNEL);\n\tstruct hist_elt_data *elt_data;\n\n\tif (!data)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tdata->key = kzalloc(key_len, GFP_KERNEL);\n\tif (!data->key) {\n\t\ttrack_data_free(data);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tdata->key_len = key_len;\n\tdata->action_data = action_data;\n\tdata->hist_data = hist_data;\n\n\telt_data = kzalloc(sizeof(*elt_data), GFP_KERNEL);\n\tif (!elt_data) {\n\t\ttrack_data_free(data);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tdata->elt.private_data = elt_data;\n\n\telt_data->comm = kzalloc(TASK_COMM_LEN, GFP_KERNEL);\n\tif (!elt_data->comm) {\n\t\ttrack_data_free(data);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\treturn data;\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);\n\nstatic struct track_data *track_data_alloc(unsigned int key_len,\n\t\t\t\t\t   struct action_data *action_data,\n\t\t\t\t\t   struct hist_trigger_data *hist_data)\n{\n\tstruct track_data *data = kzalloc(sizeof(*data), GFP_KERNEL);\n\tstruct hist_elt_data *elt_data;\n\n\tif (!data)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tdata->key = kzalloc(key_len, GFP_KERNEL);\n\tif (!data->key) {\n\t\ttrack_data_free(data);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tdata->key_len = key_len;\n\tdata->action_data = action_data;\n\tdata->hist_data = hist_data;\n\n\telt_data = kzalloc(sizeof(*elt_data), GFP_KERNEL);\n\tif (!elt_data) {\n\t\ttrack_data_free(data);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tdata->elt.private_data = elt_data;\n\n\telt_data->comm = kzalloc(TASK_COMM_LEN, GFP_KERNEL);\n\tif (!elt_data->comm) {\n\t\ttrack_data_free(data);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\treturn data;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_action_create",
          "args": [
            "hist_data",
            "data"
          ],
          "line": 3982
        },
        "resolved": true,
        "details": {
          "function_name": "trace_action_create",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "3861-3968",
          "snippet": "static int trace_action_create(struct hist_trigger_data *hist_data,\n\t\t\t       struct action_data *data)\n{\n\tstruct trace_array *tr = hist_data->event_file->tr;\n\tchar *event_name, *param, *system = NULL;\n\tstruct hist_field *hist_field, *var_ref;\n\tunsigned int i;\n\tunsigned int field_pos = 0;\n\tstruct synth_event *event;\n\tchar *synth_event_name;\n\tint var_ref_idx, ret = 0;\n\n\tlockdep_assert_held(&event_mutex);\n\n\tif (data->use_trace_keyword)\n\t\tsynth_event_name = data->synth_event_name;\n\telse\n\t\tsynth_event_name = data->action_name;\n\n\tevent = find_synth_event(synth_event_name);\n\tif (!event) {\n\t\thist_err(tr, HIST_ERR_SYNTH_EVENT_NOT_FOUND, errpos(synth_event_name));\n\t\treturn -EINVAL;\n\t}\n\n\tevent->ref++;\n\n\tfor (i = 0; i < data->n_params; i++) {\n\t\tchar *p;\n\n\t\tp = param = kstrdup(data->params[i], GFP_KERNEL);\n\t\tif (!param) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err;\n\t\t}\n\n\t\tsystem = strsep(&param, \".\");\n\t\tif (!param) {\n\t\t\tparam = (char *)system;\n\t\t\tsystem = event_name = NULL;\n\t\t} else {\n\t\t\tevent_name = strsep(&param, \".\");\n\t\t\tif (!param) {\n\t\t\t\tkfree(p);\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t}\n\n\t\tif (param[0] == '$')\n\t\t\thist_field = trace_action_find_var(hist_data, data,\n\t\t\t\t\t\t\t   system, event_name,\n\t\t\t\t\t\t\t   param);\n\t\telse\n\t\t\thist_field = trace_action_create_field_var(hist_data,\n\t\t\t\t\t\t\t\t   data,\n\t\t\t\t\t\t\t\t   system,\n\t\t\t\t\t\t\t\t   event_name,\n\t\t\t\t\t\t\t\t   param);\n\n\t\tif (!hist_field) {\n\t\t\tkfree(p);\n\t\t\tret = -EINVAL;\n\t\t\tgoto err;\n\t\t}\n\n\t\tif (check_synth_field(event, hist_field, field_pos) == 0) {\n\t\t\tvar_ref = create_var_ref(hist_data, hist_field,\n\t\t\t\t\t\t system, event_name);\n\t\t\tif (!var_ref) {\n\t\t\t\tkfree(p);\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto err;\n\t\t\t}\n\n\t\t\tvar_ref_idx = find_var_ref_idx(hist_data, var_ref);\n\t\t\tif (WARN_ON(var_ref_idx < 0)) {\n\t\t\t\tret = var_ref_idx;\n\t\t\t\tgoto err;\n\t\t\t}\n\n\t\t\tdata->var_ref_idx[i] = var_ref_idx;\n\n\t\t\tfield_pos++;\n\t\t\tkfree(p);\n\t\t\tcontinue;\n\t\t}\n\n\t\thist_err(tr, HIST_ERR_SYNTH_TYPE_MISMATCH, errpos(param));\n\t\tkfree(p);\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tif (field_pos != event->n_fields) {\n\t\thist_err(tr, HIST_ERR_SYNTH_COUNT_MISMATCH, errpos(event->name));\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tdata->synth_event = event;\n out:\n\treturn ret;\n err:\n\tevent->ref--;\n\n\tgoto out;\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int event_hist_trigger_parse(struct event_command *cmd_ops,\n\t\t\t\t    struct trace_event_file *file,\n\t\t\t\t    char *glob, char *cmd, char *param);",
            "static int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int event_hist_trigger_parse(struct event_command *cmd_ops,\n\t\t\t\t    struct trace_event_file *file,\n\t\t\t\t    char *glob, char *cmd, char *param);\nstatic int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);\n\nstatic int trace_action_create(struct hist_trigger_data *hist_data,\n\t\t\t       struct action_data *data)\n{\n\tstruct trace_array *tr = hist_data->event_file->tr;\n\tchar *event_name, *param, *system = NULL;\n\tstruct hist_field *hist_field, *var_ref;\n\tunsigned int i;\n\tunsigned int field_pos = 0;\n\tstruct synth_event *event;\n\tchar *synth_event_name;\n\tint var_ref_idx, ret = 0;\n\n\tlockdep_assert_held(&event_mutex);\n\n\tif (data->use_trace_keyword)\n\t\tsynth_event_name = data->synth_event_name;\n\telse\n\t\tsynth_event_name = data->action_name;\n\n\tevent = find_synth_event(synth_event_name);\n\tif (!event) {\n\t\thist_err(tr, HIST_ERR_SYNTH_EVENT_NOT_FOUND, errpos(synth_event_name));\n\t\treturn -EINVAL;\n\t}\n\n\tevent->ref++;\n\n\tfor (i = 0; i < data->n_params; i++) {\n\t\tchar *p;\n\n\t\tp = param = kstrdup(data->params[i], GFP_KERNEL);\n\t\tif (!param) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err;\n\t\t}\n\n\t\tsystem = strsep(&param, \".\");\n\t\tif (!param) {\n\t\t\tparam = (char *)system;\n\t\t\tsystem = event_name = NULL;\n\t\t} else {\n\t\t\tevent_name = strsep(&param, \".\");\n\t\t\tif (!param) {\n\t\t\t\tkfree(p);\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t}\n\n\t\tif (param[0] == '$')\n\t\t\thist_field = trace_action_find_var(hist_data, data,\n\t\t\t\t\t\t\t   system, event_name,\n\t\t\t\t\t\t\t   param);\n\t\telse\n\t\t\thist_field = trace_action_create_field_var(hist_data,\n\t\t\t\t\t\t\t\t   data,\n\t\t\t\t\t\t\t\t   system,\n\t\t\t\t\t\t\t\t   event_name,\n\t\t\t\t\t\t\t\t   param);\n\n\t\tif (!hist_field) {\n\t\t\tkfree(p);\n\t\t\tret = -EINVAL;\n\t\t\tgoto err;\n\t\t}\n\n\t\tif (check_synth_field(event, hist_field, field_pos) == 0) {\n\t\t\tvar_ref = create_var_ref(hist_data, hist_field,\n\t\t\t\t\t\t system, event_name);\n\t\t\tif (!var_ref) {\n\t\t\t\tkfree(p);\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto err;\n\t\t\t}\n\n\t\t\tvar_ref_idx = find_var_ref_idx(hist_data, var_ref);\n\t\t\tif (WARN_ON(var_ref_idx < 0)) {\n\t\t\t\tret = var_ref_idx;\n\t\t\t\tgoto err;\n\t\t\t}\n\n\t\t\tdata->var_ref_idx[i] = var_ref_idx;\n\n\t\t\tfield_pos++;\n\t\t\tkfree(p);\n\t\t\tcontinue;\n\t\t}\n\n\t\thist_err(tr, HIST_ERR_SYNTH_TYPE_MISMATCH, errpos(param));\n\t\tkfree(p);\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tif (field_pos != event->n_fields) {\n\t\thist_err(tr, HIST_ERR_SYNTH_COUNT_MISMATCH, errpos(event->name));\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tdata->synth_event = event;\n out:\n\treturn ret;\n err:\n\tevent->ref--;\n\n\tgoto out;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int event_hist_trigger_parse(struct event_command *cmd_ops,\n\t\t\t\t    struct trace_event_file *file,\n\t\t\t\t    char *glob, char *cmd, char *param);\nstatic int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);\n\nstatic int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data)\n{\n\tstruct trace_event_file *file = hist_data->event_file;\n\tstruct trace_array *tr = file->tr;\n\tstruct track_data *track_data;\n\tstruct field_var *field_var;\n\tunsigned int i;\n\tchar *param;\n\tint ret = 0;\n\n\tif (data->action == ACTION_TRACE)\n\t\treturn trace_action_create(hist_data, data);\n\n\tif (data->action == ACTION_SNAPSHOT) {\n\t\ttrack_data = track_data_alloc(hist_data->key_size, data, hist_data);\n\t\tif (IS_ERR(track_data)) {\n\t\t\tret = PTR_ERR(track_data);\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = tracing_snapshot_cond_enable(file->tr, track_data,\n\t\t\t\t\t\t   cond_snapshot_update);\n\t\tif (ret)\n\t\t\ttrack_data_free(track_data);\n\n\t\tgoto out;\n\t}\n\n\tif (data->action == ACTION_SAVE) {\n\t\tif (hist_data->n_save_vars) {\n\t\t\tret = -EEXIST;\n\t\t\thist_err(tr, HIST_ERR_TOO_MANY_SAVE_ACTIONS, 0);\n\t\t\tgoto out;\n\t\t}\n\n\t\tfor (i = 0; i < data->n_params; i++) {\n\t\t\tparam = kstrdup(data->params[i], GFP_KERNEL);\n\t\t\tif (!param) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tfield_var = create_target_field_var(hist_data, NULL, NULL, param);\n\t\t\tif (IS_ERR(field_var)) {\n\t\t\t\thist_err(tr, HIST_ERR_FIELD_VAR_CREATE_FAIL,\n\t\t\t\t\t errpos(param));\n\t\t\t\tret = PTR_ERR(field_var);\n\t\t\t\tkfree(param);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\thist_data->save_vars[hist_data->n_save_vars++] = field_var;\n\t\t\tif (field_var->val->flags & HIST_FIELD_FL_STRING)\n\t\t\t\thist_data->n_save_var_str++;\n\t\t\tkfree(param);\n\t\t}\n\t}\n out:\n\treturn ret;\n}"
  },
  {
    "function_name": "trace_action_create",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
    "lines": "3861-3968",
    "snippet": "static int trace_action_create(struct hist_trigger_data *hist_data,\n\t\t\t       struct action_data *data)\n{\n\tstruct trace_array *tr = hist_data->event_file->tr;\n\tchar *event_name, *param, *system = NULL;\n\tstruct hist_field *hist_field, *var_ref;\n\tunsigned int i;\n\tunsigned int field_pos = 0;\n\tstruct synth_event *event;\n\tchar *synth_event_name;\n\tint var_ref_idx, ret = 0;\n\n\tlockdep_assert_held(&event_mutex);\n\n\tif (data->use_trace_keyword)\n\t\tsynth_event_name = data->synth_event_name;\n\telse\n\t\tsynth_event_name = data->action_name;\n\n\tevent = find_synth_event(synth_event_name);\n\tif (!event) {\n\t\thist_err(tr, HIST_ERR_SYNTH_EVENT_NOT_FOUND, errpos(synth_event_name));\n\t\treturn -EINVAL;\n\t}\n\n\tevent->ref++;\n\n\tfor (i = 0; i < data->n_params; i++) {\n\t\tchar *p;\n\n\t\tp = param = kstrdup(data->params[i], GFP_KERNEL);\n\t\tif (!param) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err;\n\t\t}\n\n\t\tsystem = strsep(&param, \".\");\n\t\tif (!param) {\n\t\t\tparam = (char *)system;\n\t\t\tsystem = event_name = NULL;\n\t\t} else {\n\t\t\tevent_name = strsep(&param, \".\");\n\t\t\tif (!param) {\n\t\t\t\tkfree(p);\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t}\n\n\t\tif (param[0] == '$')\n\t\t\thist_field = trace_action_find_var(hist_data, data,\n\t\t\t\t\t\t\t   system, event_name,\n\t\t\t\t\t\t\t   param);\n\t\telse\n\t\t\thist_field = trace_action_create_field_var(hist_data,\n\t\t\t\t\t\t\t\t   data,\n\t\t\t\t\t\t\t\t   system,\n\t\t\t\t\t\t\t\t   event_name,\n\t\t\t\t\t\t\t\t   param);\n\n\t\tif (!hist_field) {\n\t\t\tkfree(p);\n\t\t\tret = -EINVAL;\n\t\t\tgoto err;\n\t\t}\n\n\t\tif (check_synth_field(event, hist_field, field_pos) == 0) {\n\t\t\tvar_ref = create_var_ref(hist_data, hist_field,\n\t\t\t\t\t\t system, event_name);\n\t\t\tif (!var_ref) {\n\t\t\t\tkfree(p);\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto err;\n\t\t\t}\n\n\t\t\tvar_ref_idx = find_var_ref_idx(hist_data, var_ref);\n\t\t\tif (WARN_ON(var_ref_idx < 0)) {\n\t\t\t\tret = var_ref_idx;\n\t\t\t\tgoto err;\n\t\t\t}\n\n\t\t\tdata->var_ref_idx[i] = var_ref_idx;\n\n\t\t\tfield_pos++;\n\t\t\tkfree(p);\n\t\t\tcontinue;\n\t\t}\n\n\t\thist_err(tr, HIST_ERR_SYNTH_TYPE_MISMATCH, errpos(param));\n\t\tkfree(p);\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tif (field_pos != event->n_fields) {\n\t\thist_err(tr, HIST_ERR_SYNTH_COUNT_MISMATCH, errpos(event->name));\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tdata->synth_event = event;\n out:\n\treturn ret;\n err:\n\tevent->ref--;\n\n\tgoto out;\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include \"tracing_map.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int event_hist_trigger_parse(struct event_command *cmd_ops,\n\t\t\t\t    struct trace_event_file *file,\n\t\t\t\t    char *glob, char *cmd, char *param);",
      "static int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "hist_err",
          "args": [
            "tr",
            "HIST_ERR_SYNTH_COUNT_MISMATCH",
            "errpos(event->name)"
          ],
          "line": 3956
        },
        "resolved": true,
        "details": {
          "function_name": "hist_err",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "763-767",
          "snippet": "static void hist_err(struct trace_array *tr, u8 err_type, u8 err_pos)\n{\n\ttracing_log_err(tr, last_cmd_loc, last_cmd, err_text,\n\t\t\terr_type, err_pos);\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *err_text[] = { ERRORS };",
            "static char last_cmd[MAX_FILTER_STR_VAL];",
            "static char last_cmd_loc[MAX_FILTER_STR_VAL];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic const char *err_text[] = { ERRORS };\nstatic char last_cmd[MAX_FILTER_STR_VAL];\nstatic char last_cmd_loc[MAX_FILTER_STR_VAL];\n\nstatic void hist_err(struct trace_array *tr, u8 err_type, u8 err_pos)\n{\n\ttracing_log_err(tr, last_cmd_loc, last_cmd, err_text,\n\t\t\terr_type, err_pos);\n}"
        }
      },
      {
        "call_info": {
          "callee": "errpos",
          "args": [
            "event->name"
          ],
          "line": 3956
        },
        "resolved": true,
        "details": {
          "function_name": "errpos",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "733-736",
          "snippet": "static int errpos(char *str)\n{\n\treturn err_pos(last_cmd, str);\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char last_cmd[MAX_FILTER_STR_VAL];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic char last_cmd[MAX_FILTER_STR_VAL];\n\nstatic int errpos(char *str)\n{\n\treturn err_pos(last_cmd, str);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "p"
          ],
          "line": 3950
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "var_ref_idx < 0"
          ],
          "line": 3937
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_var_ref_idx",
          "args": [
            "hist_data",
            "var_ref"
          ],
          "line": 3936
        },
        "resolved": true,
        "details": {
          "function_name": "find_var_ref_idx",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "2083-2097",
          "snippet": "static int find_var_ref_idx(struct hist_trigger_data *hist_data,\n\t\t\t    struct hist_field *var_field)\n{\n\tstruct hist_field *ref_field;\n\tint i;\n\n\tfor (i = 0; i < hist_data->n_var_refs; i++) {\n\t\tref_field = hist_data->var_refs[i];\n\t\tif (ref_field->var.idx == var_field->var.idx &&\n\t\t    ref_field->var.hist_data == var_field->hist_data)\n\t\t\treturn i;\n\t}\n\n\treturn -ENOENT;\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int find_var_ref_idx(struct hist_trigger_data *hist_data,\n\t\t\t    struct hist_field *var_field)\n{\n\tstruct hist_field *ref_field;\n\tint i;\n\n\tfor (i = 0; i < hist_data->n_var_refs; i++) {\n\t\tref_field = hist_data->var_refs[i];\n\t\tif (ref_field->var.idx == var_field->var.idx &&\n\t\t    ref_field->var.hist_data == var_field->hist_data)\n\t\t\treturn i;\n\t}\n\n\treturn -ENOENT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "create_var_ref",
          "args": [
            "hist_data",
            "hist_field",
            "system",
            "event_name"
          ],
          "line": 3928
        },
        "resolved": true,
        "details": {
          "function_name": "create_var_ref",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "2114-2144",
          "snippet": "static struct hist_field *create_var_ref(struct hist_trigger_data *hist_data,\n\t\t\t\t\t struct hist_field *var_field,\n\t\t\t\t\t char *system, char *event_name)\n{\n\tunsigned long flags = HIST_FIELD_FL_VAR_REF;\n\tstruct hist_field *ref_field;\n\tint i;\n\n\t/* Check if the variable already exists */\n\tfor (i = 0; i < hist_data->n_var_refs; i++) {\n\t\tref_field = hist_data->var_refs[i];\n\t\tif (ref_field->var.idx == var_field->var.idx &&\n\t\t    ref_field->var.hist_data == var_field->hist_data) {\n\t\t\tget_hist_field(ref_field);\n\t\t\treturn ref_field;\n\t\t}\n\t}\n\n\tref_field = create_hist_field(var_field->hist_data, NULL, flags, NULL);\n\tif (ref_field) {\n\t\tif (init_var_ref(ref_field, var_field, system, event_name)) {\n\t\t\tdestroy_hist_field(ref_field, 0);\n\t\t\treturn NULL;\n\t\t}\n\n\t\thist_data->var_refs[hist_data->n_var_refs] = ref_field;\n\t\tref_field->var_ref_idx = hist_data->n_var_refs++;\n\t}\n\n\treturn ref_field;\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct hist_field *create_var_ref(struct hist_trigger_data *hist_data,\n\t\t\t\t\t struct hist_field *var_field,\n\t\t\t\t\t char *system, char *event_name)\n{\n\tunsigned long flags = HIST_FIELD_FL_VAR_REF;\n\tstruct hist_field *ref_field;\n\tint i;\n\n\t/* Check if the variable already exists */\n\tfor (i = 0; i < hist_data->n_var_refs; i++) {\n\t\tref_field = hist_data->var_refs[i];\n\t\tif (ref_field->var.idx == var_field->var.idx &&\n\t\t    ref_field->var.hist_data == var_field->hist_data) {\n\t\t\tget_hist_field(ref_field);\n\t\t\treturn ref_field;\n\t\t}\n\t}\n\n\tref_field = create_hist_field(var_field->hist_data, NULL, flags, NULL);\n\tif (ref_field) {\n\t\tif (init_var_ref(ref_field, var_field, system, event_name)) {\n\t\t\tdestroy_hist_field(ref_field, 0);\n\t\t\treturn NULL;\n\t\t}\n\n\t\thist_data->var_refs[hist_data->n_var_refs] = ref_field;\n\t\tref_field->var_ref_idx = hist_data->n_var_refs++;\n\t}\n\n\treturn ref_field;\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_synth_field",
          "args": [
            "event",
            "hist_field",
            "field_pos"
          ],
          "line": 3927
        },
        "resolved": true,
        "details": {
          "function_name": "check_synth_field",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "3754-3781",
          "snippet": "static int check_synth_field(struct synth_event *event,\n\t\t\t     struct hist_field *hist_field,\n\t\t\t     unsigned int field_pos)\n{\n\tstruct synth_field *field;\n\n\tif (field_pos >= event->n_fields)\n\t\treturn -EINVAL;\n\n\tfield = event->fields[field_pos];\n\n\t/*\n\t * A dynamic string synth field can accept static or\n\t * dynamic. A static string synth field can only accept a\n\t * same-sized static string, which is checked for later.\n\t */\n\tif (strstr(hist_field->type, \"char[\") && field->is_string\n\t    && field->is_dynamic)\n\t\treturn 0;\n\n\tif (strcmp(field->type, hist_field->type) != 0) {\n\t\tif (field->size != hist_field->size ||\n\t\t    (!field->is_string && field->is_signed != hist_field->is_signed))\n\t\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int check_synth_field(struct synth_event *event,\n\t\t\t     struct hist_field *hist_field,\n\t\t\t     unsigned int field_pos)\n{\n\tstruct synth_field *field;\n\n\tif (field_pos >= event->n_fields)\n\t\treturn -EINVAL;\n\n\tfield = event->fields[field_pos];\n\n\t/*\n\t * A dynamic string synth field can accept static or\n\t * dynamic. A static string synth field can only accept a\n\t * same-sized static string, which is checked for later.\n\t */\n\tif (strstr(hist_field->type, \"char[\") && field->is_string\n\t    && field->is_dynamic)\n\t\treturn 0;\n\n\tif (strcmp(field->type, hist_field->type) != 0) {\n\t\tif (field->size != hist_field->size ||\n\t\t    (!field->is_string && field->is_signed != hist_field->is_signed))\n\t\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_action_create_field_var",
          "args": [
            "hist_data",
            "data",
            "system",
            "event_name",
            "param"
          ],
          "line": 3915
        },
        "resolved": true,
        "details": {
          "function_name": "trace_action_create_field_var",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "3809-3859",
          "snippet": "static struct hist_field *\ntrace_action_create_field_var(struct hist_trigger_data *hist_data,\n\t\t\t      struct action_data *data, char *system,\n\t\t\t      char *event, char *var)\n{\n\tstruct hist_field *hist_field = NULL;\n\tstruct field_var *field_var;\n\n\t/*\n\t * First try to create a field var on the target event (the\n\t * currently being defined).  This will create a variable for\n\t * unqualified fields on the target event, or if qualified,\n\t * target fields that have qualified names matching the target.\n\t */\n\tfield_var = create_target_field_var(hist_data, system, event, var);\n\n\tif (field_var && !IS_ERR(field_var)) {\n\t\tsave_field_var(hist_data, field_var);\n\t\thist_field = field_var->var;\n\t} else {\n\t\tfield_var = NULL;\n\t\t/*\n\t\t * If no explicit system.event is specified, default to\n\t\t * looking for fields on the onmatch(system.event.xxx)\n\t\t * event.\n\t\t */\n\t\tif (!system && data->handler == HANDLER_ONMATCH) {\n\t\t\tsystem = data->match_data.event_system;\n\t\t\tevent = data->match_data.event;\n\t\t}\n\n\t\tif (!event)\n\t\t\tgoto free;\n\t\t/*\n\t\t * At this point, we're looking at a field on another\n\t\t * event.  Because we can't modify a hist trigger on\n\t\t * another event to add a variable for a field, we need\n\t\t * to create a new trigger on that event and create the\n\t\t * variable at the same time.\n\t\t */\n\t\thist_field = create_field_var_hist(hist_data, system, event, var);\n\t\tif (IS_ERR(hist_field))\n\t\t\tgoto free;\n\t}\n out:\n\treturn hist_field;\n free:\n\tdestroy_field_var(field_var);\n\thist_field = NULL;\n\tgoto out;\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);\n\nstatic struct hist_field *\ntrace_action_create_field_var(struct hist_trigger_data *hist_data,\n\t\t\t      struct action_data *data, char *system,\n\t\t\t      char *event, char *var)\n{\n\tstruct hist_field *hist_field = NULL;\n\tstruct field_var *field_var;\n\n\t/*\n\t * First try to create a field var on the target event (the\n\t * currently being defined).  This will create a variable for\n\t * unqualified fields on the target event, or if qualified,\n\t * target fields that have qualified names matching the target.\n\t */\n\tfield_var = create_target_field_var(hist_data, system, event, var);\n\n\tif (field_var && !IS_ERR(field_var)) {\n\t\tsave_field_var(hist_data, field_var);\n\t\thist_field = field_var->var;\n\t} else {\n\t\tfield_var = NULL;\n\t\t/*\n\t\t * If no explicit system.event is specified, default to\n\t\t * looking for fields on the onmatch(system.event.xxx)\n\t\t * event.\n\t\t */\n\t\tif (!system && data->handler == HANDLER_ONMATCH) {\n\t\t\tsystem = data->match_data.event_system;\n\t\t\tevent = data->match_data.event;\n\t\t}\n\n\t\tif (!event)\n\t\t\tgoto free;\n\t\t/*\n\t\t * At this point, we're looking at a field on another\n\t\t * event.  Because we can't modify a hist trigger on\n\t\t * another event to add a variable for a field, we need\n\t\t * to create a new trigger on that event and create the\n\t\t * variable at the same time.\n\t\t */\n\t\thist_field = create_field_var_hist(hist_data, system, event, var);\n\t\tif (IS_ERR(hist_field))\n\t\t\tgoto free;\n\t}\n out:\n\treturn hist_field;\n free:\n\tdestroy_field_var(field_var);\n\thist_field = NULL;\n\tgoto out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_action_find_var",
          "args": [
            "hist_data",
            "data",
            "system",
            "event_name",
            "param"
          ],
          "line": 3911
        },
        "resolved": true,
        "details": {
          "function_name": "trace_action_find_var",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "3783-3807",
          "snippet": "static struct hist_field *\ntrace_action_find_var(struct hist_trigger_data *hist_data,\n\t\t      struct action_data *data,\n\t\t      char *system, char *event, char *var)\n{\n\tstruct trace_array *tr = hist_data->event_file->tr;\n\tstruct hist_field *hist_field;\n\n\tvar++; /* skip '$' */\n\n\thist_field = find_target_event_var(hist_data, system, event, var);\n\tif (!hist_field) {\n\t\tif (!system && data->handler == HANDLER_ONMATCH) {\n\t\t\tsystem = data->match_data.event_system;\n\t\t\tevent = data->match_data.event;\n\t\t}\n\n\t\thist_field = find_event_var(hist_data, system, event, var);\n\t}\n\n\tif (!hist_field)\n\t\thist_err(tr, HIST_ERR_PARAM_NOT_FOUND, errpos(var));\n\n\treturn hist_field;\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);\n\nstatic struct hist_field *\ntrace_action_find_var(struct hist_trigger_data *hist_data,\n\t\t      struct action_data *data,\n\t\t      char *system, char *event, char *var)\n{\n\tstruct trace_array *tr = hist_data->event_file->tr;\n\tstruct hist_field *hist_field;\n\n\tvar++; /* skip '$' */\n\n\thist_field = find_target_event_var(hist_data, system, event, var);\n\tif (!hist_field) {\n\t\tif (!system && data->handler == HANDLER_ONMATCH) {\n\t\t\tsystem = data->match_data.event_system;\n\t\t\tevent = data->match_data.event;\n\t\t}\n\n\t\thist_field = find_event_var(hist_data, system, event, var);\n\t}\n\n\tif (!hist_field)\n\t\thist_err(tr, HIST_ERR_PARAM_NOT_FOUND, errpos(var));\n\n\treturn hist_field;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strsep",
          "args": [
            "&param",
            "\".\""
          ],
          "line": 3902
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strsep",
          "args": [
            "&param",
            "\".\""
          ],
          "line": 3897
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "data->params[i]",
            "GFP_KERNEL"
          ],
          "line": 3891
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_synth_event",
          "args": [
            "synth_event_name"
          ],
          "line": 3880
        },
        "resolved": true,
        "details": {
          "function_name": "find_synth_event",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_synth.c",
          "lines": "748-762",
          "snippet": "struct synth_event *find_synth_event(const char *name)\n{\n\tstruct dyn_event *pos;\n\tstruct synth_event *event;\n\n\tfor_each_dyn_event(pos) {\n\t\tif (!is_synth_event(pos))\n\t\t\tcontinue;\n\t\tevent = to_synth_event(pos);\n\t\tif (strcmp(event->name, name) == 0)\n\t\t\treturn event;\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstruct synth_event *find_synth_event(const char *name)\n{\n\tstruct dyn_event *pos;\n\tstruct synth_event *event;\n\n\tfor_each_dyn_event(pos) {\n\t\tif (!is_synth_event(pos))\n\t\t\tcontinue;\n\t\tevent = to_synth_event(pos);\n\t\tif (strcmp(event->name, name) == 0)\n\t\t\treturn event;\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&event_mutex"
          ],
          "line": 3873
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int event_hist_trigger_parse(struct event_command *cmd_ops,\n\t\t\t\t    struct trace_event_file *file,\n\t\t\t\t    char *glob, char *cmd, char *param);\nstatic int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);\n\nstatic int trace_action_create(struct hist_trigger_data *hist_data,\n\t\t\t       struct action_data *data)\n{\n\tstruct trace_array *tr = hist_data->event_file->tr;\n\tchar *event_name, *param, *system = NULL;\n\tstruct hist_field *hist_field, *var_ref;\n\tunsigned int i;\n\tunsigned int field_pos = 0;\n\tstruct synth_event *event;\n\tchar *synth_event_name;\n\tint var_ref_idx, ret = 0;\n\n\tlockdep_assert_held(&event_mutex);\n\n\tif (data->use_trace_keyword)\n\t\tsynth_event_name = data->synth_event_name;\n\telse\n\t\tsynth_event_name = data->action_name;\n\n\tevent = find_synth_event(synth_event_name);\n\tif (!event) {\n\t\thist_err(tr, HIST_ERR_SYNTH_EVENT_NOT_FOUND, errpos(synth_event_name));\n\t\treturn -EINVAL;\n\t}\n\n\tevent->ref++;\n\n\tfor (i = 0; i < data->n_params; i++) {\n\t\tchar *p;\n\n\t\tp = param = kstrdup(data->params[i], GFP_KERNEL);\n\t\tif (!param) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err;\n\t\t}\n\n\t\tsystem = strsep(&param, \".\");\n\t\tif (!param) {\n\t\t\tparam = (char *)system;\n\t\t\tsystem = event_name = NULL;\n\t\t} else {\n\t\t\tevent_name = strsep(&param, \".\");\n\t\t\tif (!param) {\n\t\t\t\tkfree(p);\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t}\n\n\t\tif (param[0] == '$')\n\t\t\thist_field = trace_action_find_var(hist_data, data,\n\t\t\t\t\t\t\t   system, event_name,\n\t\t\t\t\t\t\t   param);\n\t\telse\n\t\t\thist_field = trace_action_create_field_var(hist_data,\n\t\t\t\t\t\t\t\t   data,\n\t\t\t\t\t\t\t\t   system,\n\t\t\t\t\t\t\t\t   event_name,\n\t\t\t\t\t\t\t\t   param);\n\n\t\tif (!hist_field) {\n\t\t\tkfree(p);\n\t\t\tret = -EINVAL;\n\t\t\tgoto err;\n\t\t}\n\n\t\tif (check_synth_field(event, hist_field, field_pos) == 0) {\n\t\t\tvar_ref = create_var_ref(hist_data, hist_field,\n\t\t\t\t\t\t system, event_name);\n\t\t\tif (!var_ref) {\n\t\t\t\tkfree(p);\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto err;\n\t\t\t}\n\n\t\t\tvar_ref_idx = find_var_ref_idx(hist_data, var_ref);\n\t\t\tif (WARN_ON(var_ref_idx < 0)) {\n\t\t\t\tret = var_ref_idx;\n\t\t\t\tgoto err;\n\t\t\t}\n\n\t\t\tdata->var_ref_idx[i] = var_ref_idx;\n\n\t\t\tfield_pos++;\n\t\t\tkfree(p);\n\t\t\tcontinue;\n\t\t}\n\n\t\thist_err(tr, HIST_ERR_SYNTH_TYPE_MISMATCH, errpos(param));\n\t\tkfree(p);\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tif (field_pos != event->n_fields) {\n\t\thist_err(tr, HIST_ERR_SYNTH_COUNT_MISMATCH, errpos(event->name));\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tdata->synth_event = event;\n out:\n\treturn ret;\n err:\n\tevent->ref--;\n\n\tgoto out;\n}"
  },
  {
    "function_name": "trace_action_create_field_var",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
    "lines": "3809-3859",
    "snippet": "static struct hist_field *\ntrace_action_create_field_var(struct hist_trigger_data *hist_data,\n\t\t\t      struct action_data *data, char *system,\n\t\t\t      char *event, char *var)\n{\n\tstruct hist_field *hist_field = NULL;\n\tstruct field_var *field_var;\n\n\t/*\n\t * First try to create a field var on the target event (the\n\t * currently being defined).  This will create a variable for\n\t * unqualified fields on the target event, or if qualified,\n\t * target fields that have qualified names matching the target.\n\t */\n\tfield_var = create_target_field_var(hist_data, system, event, var);\n\n\tif (field_var && !IS_ERR(field_var)) {\n\t\tsave_field_var(hist_data, field_var);\n\t\thist_field = field_var->var;\n\t} else {\n\t\tfield_var = NULL;\n\t\t/*\n\t\t * If no explicit system.event is specified, default to\n\t\t * looking for fields on the onmatch(system.event.xxx)\n\t\t * event.\n\t\t */\n\t\tif (!system && data->handler == HANDLER_ONMATCH) {\n\t\t\tsystem = data->match_data.event_system;\n\t\t\tevent = data->match_data.event;\n\t\t}\n\n\t\tif (!event)\n\t\t\tgoto free;\n\t\t/*\n\t\t * At this point, we're looking at a field on another\n\t\t * event.  Because we can't modify a hist trigger on\n\t\t * another event to add a variable for a field, we need\n\t\t * to create a new trigger on that event and create the\n\t\t * variable at the same time.\n\t\t */\n\t\thist_field = create_field_var_hist(hist_data, system, event, var);\n\t\tif (IS_ERR(hist_field))\n\t\t\tgoto free;\n\t}\n out:\n\treturn hist_field;\n free:\n\tdestroy_field_var(field_var);\n\thist_field = NULL;\n\tgoto out;\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include \"tracing_map.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "destroy_field_var",
          "args": [
            "field_var"
          ],
          "line": 3856
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_field_var_hists",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "4789-4797",
          "snippet": "static void destroy_field_var_hists(struct hist_trigger_data *hist_data)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < hist_data->n_field_var_hists; i++) {\n\t\tkfree(hist_data->field_var_hists[i]->cmd);\n\t\tkfree(hist_data->field_var_hists[i]);\n\t}\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void destroy_field_var_hists(struct hist_trigger_data *hist_data)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < hist_data->n_field_var_hists; i++) {\n\t\tkfree(hist_data->field_var_hists[i]->cmd);\n\t\tkfree(hist_data->field_var_hists[i]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "hist_field"
          ],
          "line": 3850
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "create_field_var_hist",
          "args": [
            "hist_data",
            "system",
            "event",
            "var"
          ],
          "line": 3849
        },
        "resolved": true,
        "details": {
          "function_name": "create_field_var_hist",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "2878-2996",
          "snippet": "static struct hist_field *\ncreate_field_var_hist(struct hist_trigger_data *target_hist_data,\n\t\t      char *subsys_name, char *event_name, char *field_name)\n{\n\tstruct trace_array *tr = target_hist_data->event_file->tr;\n\tstruct hist_trigger_data *hist_data;\n\tunsigned int i, n, first = true;\n\tstruct field_var_hist *var_hist;\n\tstruct trace_event_file *file;\n\tstruct hist_field *key_field;\n\tstruct hist_field *event_var;\n\tchar *saved_filter;\n\tchar *cmd;\n\tint ret;\n\n\tif (target_hist_data->n_field_var_hists >= SYNTH_FIELDS_MAX) {\n\t\thist_err(tr, HIST_ERR_TOO_MANY_FIELD_VARS, errpos(field_name));\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tfile = event_file(tr, subsys_name, event_name);\n\n\tif (IS_ERR(file)) {\n\t\thist_err(tr, HIST_ERR_EVENT_FILE_NOT_FOUND, errpos(field_name));\n\t\tret = PTR_ERR(file);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\t/*\n\t * Look for a histogram compatible with target.  We'll use the\n\t * found histogram specification to create a new matching\n\t * histogram with our variable on it.  target_hist_data is not\n\t * yet a registered histogram so we can't use that.\n\t */\n\thist_data = find_compatible_hist(target_hist_data, file);\n\tif (!hist_data) {\n\t\thist_err(tr, HIST_ERR_HIST_NOT_FOUND, errpos(field_name));\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\t/* See if a synthetic field variable has already been created */\n\tevent_var = find_synthetic_field_var(target_hist_data, subsys_name,\n\t\t\t\t\t     event_name, field_name);\n\tif (!IS_ERR_OR_NULL(event_var))\n\t\treturn event_var;\n\n\tvar_hist = kzalloc(sizeof(*var_hist), GFP_KERNEL);\n\tif (!var_hist)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tcmd = kzalloc(MAX_FILTER_STR_VAL, GFP_KERNEL);\n\tif (!cmd) {\n\t\tkfree(var_hist);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\t/* Use the same keys as the compatible histogram */\n\tstrcat(cmd, \"keys=\");\n\n\tfor_each_hist_key_field(i, hist_data) {\n\t\tkey_field = hist_data->fields[i];\n\t\tif (!first)\n\t\t\tstrcat(cmd, \",\");\n\t\tstrcat(cmd, key_field->field->name);\n\t\tfirst = false;\n\t}\n\n\t/* Create the synthetic field variable specification */\n\tstrcat(cmd, \":synthetic_\");\n\tstrcat(cmd, field_name);\n\tstrcat(cmd, \"=\");\n\tstrcat(cmd, field_name);\n\n\t/* Use the same filter as the compatible histogram */\n\tsaved_filter = find_trigger_filter(hist_data, file);\n\tif (saved_filter) {\n\t\tstrcat(cmd, \" if \");\n\t\tstrcat(cmd, saved_filter);\n\t}\n\n\tvar_hist->cmd = kstrdup(cmd, GFP_KERNEL);\n\tif (!var_hist->cmd) {\n\t\tkfree(cmd);\n\t\tkfree(var_hist);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\t/* Save the compatible histogram information */\n\tvar_hist->hist_data = hist_data;\n\n\t/* Create the new histogram with our variable */\n\tret = event_hist_trigger_parse(&trigger_hist_cmd, file,\n\t\t\t\t       \"\", \"hist\", cmd);\n\tif (ret) {\n\t\tkfree(cmd);\n\t\tkfree(var_hist->cmd);\n\t\tkfree(var_hist);\n\t\thist_err(tr, HIST_ERR_HIST_CREATE_FAIL, errpos(field_name));\n\t\treturn ERR_PTR(ret);\n\t}\n\n\tkfree(cmd);\n\n\t/* If we can't find the variable, something went wrong */\n\tevent_var = find_synthetic_field_var(target_hist_data, subsys_name,\n\t\t\t\t\t     event_name, field_name);\n\tif (IS_ERR_OR_NULL(event_var)) {\n\t\tkfree(var_hist->cmd);\n\t\tkfree(var_hist);\n\t\thist_err(tr, HIST_ERR_SYNTH_VAR_NOT_FOUND, errpos(field_name));\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tn = target_hist_data->n_field_var_hists;\n\ttarget_hist_data->field_var_hists[n] = var_hist;\n\ttarget_hist_data->n_field_var_hists++;\n\n\treturn event_var;\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct event_command trigger_hist_cmd;",
            "static struct event_command trigger_hist_cmd = {\n\t.name\t\t\t= \"hist\",\n\t.trigger_type\t\t= ETT_EVENT_HIST,\n\t.flags\t\t\t= EVENT_CMD_FL_NEEDS_REC,\n\t.parse\t\t\t= event_hist_trigger_parse,\n\t.reg\t\t\t= hist_register_trigger,\n\t.unreg\t\t\t= hist_unregister_trigger,\n\t.unreg_all\t\t= hist_unreg_all,\n\t.get_trigger_ops\t= event_hist_get_trigger_ops,\n\t.set_filter\t\t= set_trigger_filter,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct event_command trigger_hist_cmd;\nstatic struct event_command trigger_hist_cmd = {\n\t.name\t\t\t= \"hist\",\n\t.trigger_type\t\t= ETT_EVENT_HIST,\n\t.flags\t\t\t= EVENT_CMD_FL_NEEDS_REC,\n\t.parse\t\t\t= event_hist_trigger_parse,\n\t.reg\t\t\t= hist_register_trigger,\n\t.unreg\t\t\t= hist_unregister_trigger,\n\t.unreg_all\t\t= hist_unreg_all,\n\t.get_trigger_ops\t= event_hist_get_trigger_ops,\n\t.set_filter\t\t= set_trigger_filter,\n};\n\nstatic struct hist_field *\ncreate_field_var_hist(struct hist_trigger_data *target_hist_data,\n\t\t      char *subsys_name, char *event_name, char *field_name)\n{\n\tstruct trace_array *tr = target_hist_data->event_file->tr;\n\tstruct hist_trigger_data *hist_data;\n\tunsigned int i, n, first = true;\n\tstruct field_var_hist *var_hist;\n\tstruct trace_event_file *file;\n\tstruct hist_field *key_field;\n\tstruct hist_field *event_var;\n\tchar *saved_filter;\n\tchar *cmd;\n\tint ret;\n\n\tif (target_hist_data->n_field_var_hists >= SYNTH_FIELDS_MAX) {\n\t\thist_err(tr, HIST_ERR_TOO_MANY_FIELD_VARS, errpos(field_name));\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tfile = event_file(tr, subsys_name, event_name);\n\n\tif (IS_ERR(file)) {\n\t\thist_err(tr, HIST_ERR_EVENT_FILE_NOT_FOUND, errpos(field_name));\n\t\tret = PTR_ERR(file);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\t/*\n\t * Look for a histogram compatible with target.  We'll use the\n\t * found histogram specification to create a new matching\n\t * histogram with our variable on it.  target_hist_data is not\n\t * yet a registered histogram so we can't use that.\n\t */\n\thist_data = find_compatible_hist(target_hist_data, file);\n\tif (!hist_data) {\n\t\thist_err(tr, HIST_ERR_HIST_NOT_FOUND, errpos(field_name));\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\t/* See if a synthetic field variable has already been created */\n\tevent_var = find_synthetic_field_var(target_hist_data, subsys_name,\n\t\t\t\t\t     event_name, field_name);\n\tif (!IS_ERR_OR_NULL(event_var))\n\t\treturn event_var;\n\n\tvar_hist = kzalloc(sizeof(*var_hist), GFP_KERNEL);\n\tif (!var_hist)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tcmd = kzalloc(MAX_FILTER_STR_VAL, GFP_KERNEL);\n\tif (!cmd) {\n\t\tkfree(var_hist);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\t/* Use the same keys as the compatible histogram */\n\tstrcat(cmd, \"keys=\");\n\n\tfor_each_hist_key_field(i, hist_data) {\n\t\tkey_field = hist_data->fields[i];\n\t\tif (!first)\n\t\t\tstrcat(cmd, \",\");\n\t\tstrcat(cmd, key_field->field->name);\n\t\tfirst = false;\n\t}\n\n\t/* Create the synthetic field variable specification */\n\tstrcat(cmd, \":synthetic_\");\n\tstrcat(cmd, field_name);\n\tstrcat(cmd, \"=\");\n\tstrcat(cmd, field_name);\n\n\t/* Use the same filter as the compatible histogram */\n\tsaved_filter = find_trigger_filter(hist_data, file);\n\tif (saved_filter) {\n\t\tstrcat(cmd, \" if \");\n\t\tstrcat(cmd, saved_filter);\n\t}\n\n\tvar_hist->cmd = kstrdup(cmd, GFP_KERNEL);\n\tif (!var_hist->cmd) {\n\t\tkfree(cmd);\n\t\tkfree(var_hist);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\t/* Save the compatible histogram information */\n\tvar_hist->hist_data = hist_data;\n\n\t/* Create the new histogram with our variable */\n\tret = event_hist_trigger_parse(&trigger_hist_cmd, file,\n\t\t\t\t       \"\", \"hist\", cmd);\n\tif (ret) {\n\t\tkfree(cmd);\n\t\tkfree(var_hist->cmd);\n\t\tkfree(var_hist);\n\t\thist_err(tr, HIST_ERR_HIST_CREATE_FAIL, errpos(field_name));\n\t\treturn ERR_PTR(ret);\n\t}\n\n\tkfree(cmd);\n\n\t/* If we can't find the variable, something went wrong */\n\tevent_var = find_synthetic_field_var(target_hist_data, subsys_name,\n\t\t\t\t\t     event_name, field_name);\n\tif (IS_ERR_OR_NULL(event_var)) {\n\t\tkfree(var_hist->cmd);\n\t\tkfree(var_hist);\n\t\thist_err(tr, HIST_ERR_SYNTH_VAR_NOT_FOUND, errpos(field_name));\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tn = target_hist_data->n_field_var_hists;\n\ttarget_hist_data->field_var_hists[n] = var_hist;\n\ttarget_hist_data->n_field_var_hists++;\n\n\treturn event_var;\n}"
        }
      },
      {
        "call_info": {
          "callee": "save_field_var",
          "args": [
            "hist_data",
            "field_var"
          ],
          "line": 3826
        },
        "resolved": true,
        "details": {
          "function_name": "save_field_var",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "3744-3751",
          "snippet": "static void save_field_var(struct hist_trigger_data *hist_data,\n\t\t\t   struct field_var *field_var)\n{\n\thist_data->field_vars[hist_data->n_field_vars++] = field_var;\n\n\tif (field_var->val->flags & HIST_FIELD_FL_STRING)\n\t\thist_data->n_field_var_str++;\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void save_field_var(struct hist_trigger_data *hist_data,\n\t\t\t   struct field_var *field_var)\n{\n\thist_data->field_vars[hist_data->n_field_vars++] = field_var;\n\n\tif (field_var->val->flags & HIST_FIELD_FL_STRING)\n\t\thist_data->n_field_var_str++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "field_var"
          ],
          "line": 3825
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "create_target_field_var",
          "args": [
            "hist_data",
            "system",
            "event",
            "var"
          ],
          "line": 3823
        },
        "resolved": true,
        "details": {
          "function_name": "create_target_field_var",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "3188-3210",
          "snippet": "static struct field_var *\ncreate_target_field_var(struct hist_trigger_data *target_hist_data,\n\t\t\tchar *subsys_name, char *event_name, char *var_name)\n{\n\tstruct trace_event_file *file = target_hist_data->event_file;\n\n\tif (subsys_name) {\n\t\tstruct trace_event_call *call;\n\n\t\tif (!event_name)\n\t\t\treturn NULL;\n\n\t\tcall = file->event_call;\n\n\t\tif (strcmp(subsys_name, call->class->system) != 0)\n\t\t\treturn NULL;\n\n\t\tif (strcmp(event_name, trace_event_name(call)) != 0)\n\t\t\treturn NULL;\n\t}\n\n\treturn create_field_var(target_hist_data, file, var_name);\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct field_var *\ncreate_target_field_var(struct hist_trigger_data *target_hist_data,\n\t\t\tchar *subsys_name, char *event_name, char *var_name)\n{\n\tstruct trace_event_file *file = target_hist_data->event_file;\n\n\tif (subsys_name) {\n\t\tstruct trace_event_call *call;\n\n\t\tif (!event_name)\n\t\t\treturn NULL;\n\n\t\tcall = file->event_call;\n\n\t\tif (strcmp(subsys_name, call->class->system) != 0)\n\t\t\treturn NULL;\n\n\t\tif (strcmp(event_name, trace_event_name(call)) != 0)\n\t\t\treturn NULL;\n\t}\n\n\treturn create_field_var(target_hist_data, file, var_name);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);\n\nstatic struct hist_field *\ntrace_action_create_field_var(struct hist_trigger_data *hist_data,\n\t\t\t      struct action_data *data, char *system,\n\t\t\t      char *event, char *var)\n{\n\tstruct hist_field *hist_field = NULL;\n\tstruct field_var *field_var;\n\n\t/*\n\t * First try to create a field var on the target event (the\n\t * currently being defined).  This will create a variable for\n\t * unqualified fields on the target event, or if qualified,\n\t * target fields that have qualified names matching the target.\n\t */\n\tfield_var = create_target_field_var(hist_data, system, event, var);\n\n\tif (field_var && !IS_ERR(field_var)) {\n\t\tsave_field_var(hist_data, field_var);\n\t\thist_field = field_var->var;\n\t} else {\n\t\tfield_var = NULL;\n\t\t/*\n\t\t * If no explicit system.event is specified, default to\n\t\t * looking for fields on the onmatch(system.event.xxx)\n\t\t * event.\n\t\t */\n\t\tif (!system && data->handler == HANDLER_ONMATCH) {\n\t\t\tsystem = data->match_data.event_system;\n\t\t\tevent = data->match_data.event;\n\t\t}\n\n\t\tif (!event)\n\t\t\tgoto free;\n\t\t/*\n\t\t * At this point, we're looking at a field on another\n\t\t * event.  Because we can't modify a hist trigger on\n\t\t * another event to add a variable for a field, we need\n\t\t * to create a new trigger on that event and create the\n\t\t * variable at the same time.\n\t\t */\n\t\thist_field = create_field_var_hist(hist_data, system, event, var);\n\t\tif (IS_ERR(hist_field))\n\t\t\tgoto free;\n\t}\n out:\n\treturn hist_field;\n free:\n\tdestroy_field_var(field_var);\n\thist_field = NULL;\n\tgoto out;\n}"
  },
  {
    "function_name": "trace_action_find_var",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
    "lines": "3783-3807",
    "snippet": "static struct hist_field *\ntrace_action_find_var(struct hist_trigger_data *hist_data,\n\t\t      struct action_data *data,\n\t\t      char *system, char *event, char *var)\n{\n\tstruct trace_array *tr = hist_data->event_file->tr;\n\tstruct hist_field *hist_field;\n\n\tvar++; /* skip '$' */\n\n\thist_field = find_target_event_var(hist_data, system, event, var);\n\tif (!hist_field) {\n\t\tif (!system && data->handler == HANDLER_ONMATCH) {\n\t\t\tsystem = data->match_data.event_system;\n\t\t\tevent = data->match_data.event;\n\t\t}\n\n\t\thist_field = find_event_var(hist_data, system, event, var);\n\t}\n\n\tif (!hist_field)\n\t\thist_err(tr, HIST_ERR_PARAM_NOT_FOUND, errpos(var));\n\n\treturn hist_field;\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include \"tracing_map.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "hist_err",
          "args": [
            "tr",
            "HIST_ERR_PARAM_NOT_FOUND",
            "errpos(var)"
          ],
          "line": 3804
        },
        "resolved": true,
        "details": {
          "function_name": "hist_err",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "763-767",
          "snippet": "static void hist_err(struct trace_array *tr, u8 err_type, u8 err_pos)\n{\n\ttracing_log_err(tr, last_cmd_loc, last_cmd, err_text,\n\t\t\terr_type, err_pos);\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *err_text[] = { ERRORS };",
            "static char last_cmd[MAX_FILTER_STR_VAL];",
            "static char last_cmd_loc[MAX_FILTER_STR_VAL];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic const char *err_text[] = { ERRORS };\nstatic char last_cmd[MAX_FILTER_STR_VAL];\nstatic char last_cmd_loc[MAX_FILTER_STR_VAL];\n\nstatic void hist_err(struct trace_array *tr, u8 err_type, u8 err_pos)\n{\n\ttracing_log_err(tr, last_cmd_loc, last_cmd, err_text,\n\t\t\terr_type, err_pos);\n}"
        }
      },
      {
        "call_info": {
          "callee": "errpos",
          "args": [
            "var"
          ],
          "line": 3804
        },
        "resolved": true,
        "details": {
          "function_name": "errpos",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "733-736",
          "snippet": "static int errpos(char *str)\n{\n\treturn err_pos(last_cmd, str);\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char last_cmd[MAX_FILTER_STR_VAL];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic char last_cmd[MAX_FILTER_STR_VAL];\n\nstatic int errpos(char *str)\n{\n\treturn err_pos(last_cmd, str);\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_event_var",
          "args": [
            "hist_data",
            "system",
            "event",
            "var"
          ],
          "line": 3800
        },
        "resolved": true,
        "details": {
          "function_name": "find_event_var",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "1190-1214",
          "snippet": "static struct hist_field *find_event_var(struct hist_trigger_data *hist_data,\n\t\t\t\t\t char *system,\n\t\t\t\t\t char *event_name,\n\t\t\t\t\t char *var_name)\n{\n\tstruct trace_array *tr = hist_data->event_file->tr;\n\tstruct hist_field *hist_field = NULL;\n\tstruct trace_event_file *file;\n\n\tif (!system || !event_name) {\n\t\thist_field = find_match_var(hist_data, var_name);\n\t\tif (IS_ERR(hist_field))\n\t\t\treturn NULL;\n\t\tif (hist_field)\n\t\t\treturn hist_field;\n\t}\n\n\tfile = find_var_file(tr, system, event_name, var_name);\n\tif (!file)\n\t\treturn NULL;\n\n\thist_field = find_file_var(file, var_name);\n\n\treturn hist_field;\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct hist_field *find_event_var(struct hist_trigger_data *hist_data,\n\t\t\t\t\t char *system,\n\t\t\t\t\t char *event_name,\n\t\t\t\t\t char *var_name)\n{\n\tstruct trace_array *tr = hist_data->event_file->tr;\n\tstruct hist_field *hist_field = NULL;\n\tstruct trace_event_file *file;\n\n\tif (!system || !event_name) {\n\t\thist_field = find_match_var(hist_data, var_name);\n\t\tif (IS_ERR(hist_field))\n\t\t\treturn NULL;\n\t\tif (hist_field)\n\t\t\treturn hist_field;\n\t}\n\n\tfile = find_var_file(tr, system, event_name, var_name);\n\tif (!file)\n\t\treturn NULL;\n\n\thist_field = find_file_var(file, var_name);\n\n\treturn hist_field;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_target_event_var",
          "args": [
            "hist_data",
            "system",
            "event",
            "var"
          ],
          "line": 3793
        },
        "resolved": true,
        "details": {
          "function_name": "find_target_event_var",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "2998-3023",
          "snippet": "static struct hist_field *\nfind_target_event_var(struct hist_trigger_data *hist_data,\n\t\t      char *subsys_name, char *event_name, char *var_name)\n{\n\tstruct trace_event_file *file = hist_data->event_file;\n\tstruct hist_field *hist_field = NULL;\n\n\tif (subsys_name) {\n\t\tstruct trace_event_call *call;\n\n\t\tif (!event_name)\n\t\t\treturn NULL;\n\n\t\tcall = file->event_call;\n\n\t\tif (strcmp(subsys_name, call->class->system) != 0)\n\t\t\treturn NULL;\n\n\t\tif (strcmp(event_name, trace_event_name(call)) != 0)\n\t\t\treturn NULL;\n\t}\n\n\thist_field = find_var_field(hist_data, var_name);\n\n\treturn hist_field;\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct hist_field *\nfind_target_event_var(struct hist_trigger_data *hist_data,\n\t\t      char *subsys_name, char *event_name, char *var_name)\n{\n\tstruct trace_event_file *file = hist_data->event_file;\n\tstruct hist_field *hist_field = NULL;\n\n\tif (subsys_name) {\n\t\tstruct trace_event_call *call;\n\n\t\tif (!event_name)\n\t\t\treturn NULL;\n\n\t\tcall = file->event_call;\n\n\t\tif (strcmp(subsys_name, call->class->system) != 0)\n\t\t\treturn NULL;\n\n\t\tif (strcmp(event_name, trace_event_name(call)) != 0)\n\t\t\treturn NULL;\n\t}\n\n\thist_field = find_var_field(hist_data, var_name);\n\n\treturn hist_field;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);\n\nstatic struct hist_field *\ntrace_action_find_var(struct hist_trigger_data *hist_data,\n\t\t      struct action_data *data,\n\t\t      char *system, char *event, char *var)\n{\n\tstruct trace_array *tr = hist_data->event_file->tr;\n\tstruct hist_field *hist_field;\n\n\tvar++; /* skip '$' */\n\n\thist_field = find_target_event_var(hist_data, system, event, var);\n\tif (!hist_field) {\n\t\tif (!system && data->handler == HANDLER_ONMATCH) {\n\t\t\tsystem = data->match_data.event_system;\n\t\t\tevent = data->match_data.event;\n\t\t}\n\n\t\thist_field = find_event_var(hist_data, system, event, var);\n\t}\n\n\tif (!hist_field)\n\t\thist_err(tr, HIST_ERR_PARAM_NOT_FOUND, errpos(var));\n\n\treturn hist_field;\n}"
  },
  {
    "function_name": "check_synth_field",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
    "lines": "3754-3781",
    "snippet": "static int check_synth_field(struct synth_event *event,\n\t\t\t     struct hist_field *hist_field,\n\t\t\t     unsigned int field_pos)\n{\n\tstruct synth_field *field;\n\n\tif (field_pos >= event->n_fields)\n\t\treturn -EINVAL;\n\n\tfield = event->fields[field_pos];\n\n\t/*\n\t * A dynamic string synth field can accept static or\n\t * dynamic. A static string synth field can only accept a\n\t * same-sized static string, which is checked for later.\n\t */\n\tif (strstr(hist_field->type, \"char[\") && field->is_string\n\t    && field->is_dynamic)\n\t\treturn 0;\n\n\tif (strcmp(field->type, hist_field->type) != 0) {\n\t\tif (field->size != hist_field->size ||\n\t\t    (!field->is_string && field->is_signed != hist_field->is_signed))\n\t\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include \"tracing_map.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "field->type",
            "hist_field->type"
          ],
          "line": 3774
        },
        "resolved": true,
        "details": {
          "function_name": "sym_strcmp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/report.c",
          "lines": "356-365",
          "snippet": "static int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}",
          "includes": [
            "#include \"encoding.h\"",
            "#include \"kcsan.h\"",
            "#include <linux/stacktrace.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/delay.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"encoding.h\"\n#include \"kcsan.h\"\n#include <linux/stacktrace.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/lockdep.h>\n#include <linux/kernel.h>\n#include <linux/kallsyms.h>\n#include <linux/jiffies.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n\nstatic int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}"
        }
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "hist_field->type",
            "\"char[\""
          ],
          "line": 3770
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int check_synth_field(struct synth_event *event,\n\t\t\t     struct hist_field *hist_field,\n\t\t\t     unsigned int field_pos)\n{\n\tstruct synth_field *field;\n\n\tif (field_pos >= event->n_fields)\n\t\treturn -EINVAL;\n\n\tfield = event->fields[field_pos];\n\n\t/*\n\t * A dynamic string synth field can accept static or\n\t * dynamic. A static string synth field can only accept a\n\t * same-sized static string, which is checked for later.\n\t */\n\tif (strstr(hist_field->type, \"char[\") && field->is_string\n\t    && field->is_dynamic)\n\t\treturn 0;\n\n\tif (strcmp(field->type, hist_field->type) != 0) {\n\t\tif (field->size != hist_field->size ||\n\t\t    (!field->is_string && field->is_signed != hist_field->is_signed))\n\t\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "save_field_var",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
    "lines": "3744-3751",
    "snippet": "static void save_field_var(struct hist_trigger_data *hist_data,\n\t\t\t   struct field_var *field_var)\n{\n\thist_data->field_vars[hist_data->n_field_vars++] = field_var;\n\n\tif (field_var->val->flags & HIST_FIELD_FL_STRING)\n\t\thist_data->n_field_var_str++;\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include \"tracing_map.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void save_field_var(struct hist_trigger_data *hist_data,\n\t\t\t   struct field_var *field_var)\n{\n\thist_data->field_vars[hist_data->n_field_vars++] = field_var;\n\n\tif (field_var->val->flags & HIST_FIELD_FL_STRING)\n\t\thist_data->n_field_var_str++;\n}"
  },
  {
    "function_name": "destroy_field_vars",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
    "lines": "3733-3742",
    "snippet": "static void destroy_field_vars(struct hist_trigger_data *hist_data)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < hist_data->n_field_vars; i++)\n\t\tdestroy_field_var(hist_data->field_vars[i]);\n\n\tfor (i = 0; i < hist_data->n_save_vars; i++)\n\t\tdestroy_field_var(hist_data->save_vars[i]);\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include \"tracing_map.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "destroy_field_var",
          "args": [
            "hist_data->save_vars[i]"
          ],
          "line": 3741
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_field_var_hists",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "4789-4797",
          "snippet": "static void destroy_field_var_hists(struct hist_trigger_data *hist_data)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < hist_data->n_field_var_hists; i++) {\n\t\tkfree(hist_data->field_var_hists[i]->cmd);\n\t\tkfree(hist_data->field_var_hists[i]);\n\t}\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void destroy_field_var_hists(struct hist_trigger_data *hist_data)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < hist_data->n_field_var_hists; i++) {\n\t\tkfree(hist_data->field_var_hists[i]->cmd);\n\t\tkfree(hist_data->field_var_hists[i]);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void destroy_field_vars(struct hist_trigger_data *hist_data)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < hist_data->n_field_vars; i++)\n\t\tdestroy_field_var(hist_data->field_vars[i]);\n\n\tfor (i = 0; i < hist_data->n_save_vars; i++)\n\t\tdestroy_field_var(hist_data->save_vars[i]);\n}"
  },
  {
    "function_name": "destroy_field_var",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
    "lines": "3722-3731",
    "snippet": "static void destroy_field_var(struct field_var *field_var)\n{\n\tif (!field_var)\n\t\treturn;\n\n\tdestroy_hist_field(field_var->var, 0);\n\tdestroy_hist_field(field_var->val, 0);\n\n\tkfree(field_var);\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include \"tracing_map.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "field_var"
          ],
          "line": 3730
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "destroy_hist_field",
          "args": [
            "field_var->val",
            "0"
          ],
          "line": 3728
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_hist_field",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "1864-1882",
          "snippet": "static void destroy_hist_field(struct hist_field *hist_field,\n\t\t\t       unsigned int level)\n{\n\tunsigned int i;\n\n\tif (level > 3)\n\t\treturn;\n\n\tif (!hist_field)\n\t\treturn;\n\n\tif (hist_field->flags & HIST_FIELD_FL_VAR_REF)\n\t\treturn; /* var refs will be destroyed separately */\n\n\tfor (i = 0; i < HIST_FIELD_OPERANDS_MAX; i++)\n\t\tdestroy_hist_field(hist_field->operands[i], level + 1);\n\n\t__destroy_hist_field(hist_field);\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define HIST_FIELD_OPERANDS_MAX\t2"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\n#define HIST_FIELD_OPERANDS_MAX\t2\n\nstatic void destroy_hist_field(struct hist_field *hist_field,\n\t\t\t       unsigned int level)\n{\n\tunsigned int i;\n\n\tif (level > 3)\n\t\treturn;\n\n\tif (!hist_field)\n\t\treturn;\n\n\tif (hist_field->flags & HIST_FIELD_FL_VAR_REF)\n\t\treturn; /* var refs will be destroyed separately */\n\n\tfor (i = 0; i < HIST_FIELD_OPERANDS_MAX; i++)\n\t\tdestroy_hist_field(hist_field->operands[i], level + 1);\n\n\t__destroy_hist_field(hist_field);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void destroy_field_var(struct field_var *field_var)\n{\n\tif (!field_var)\n\t\treturn;\n\n\tdestroy_hist_field(field_var->var, 0);\n\tdestroy_hist_field(field_var->val, 0);\n\n\tkfree(field_var);\n}"
  },
  {
    "function_name": "onmatch_destroy",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
    "lines": "3714-3720",
    "snippet": "static void onmatch_destroy(struct action_data *data)\n{\n\tkfree(data->match_data.event);\n\tkfree(data->match_data.event_system);\n\n\taction_data_destroy(data);\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include \"tracing_map.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "action_data_destroy",
          "args": [
            "data"
          ],
          "line": 3719
        },
        "resolved": true,
        "details": {
          "function_name": "action_data_destroy",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "3435-3452",
          "snippet": "static void action_data_destroy(struct action_data *data)\n{\n\tunsigned int i;\n\n\tlockdep_assert_held(&event_mutex);\n\n\tkfree(data->action_name);\n\n\tfor (i = 0; i < data->n_params; i++)\n\t\tkfree(data->params[i]);\n\n\tif (data->synth_event)\n\t\tdata->synth_event->ref--;\n\n\tkfree(data->synth_event_name);\n\n\tkfree(data);\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);\n\nstatic void action_data_destroy(struct action_data *data)\n{\n\tunsigned int i;\n\n\tlockdep_assert_held(&event_mutex);\n\n\tkfree(data->action_name);\n\n\tfor (i = 0; i < data->n_params; i++)\n\t\tkfree(data->params[i]);\n\n\tif (data->synth_event)\n\t\tdata->synth_event->ref--;\n\n\tkfree(data->synth_event_name);\n\n\tkfree(data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "data->match_data.event_system"
          ],
          "line": 3717
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);\n\nstatic void onmatch_destroy(struct action_data *data)\n{\n\tkfree(data->match_data.event);\n\tkfree(data->match_data.event_system);\n\n\taction_data_destroy(data);\n}"
  },
  {
    "function_name": "track_data_parse",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
    "lines": "3680-3712",
    "snippet": "static struct action_data *track_data_parse(struct hist_trigger_data *hist_data,\n\t\t\t\t\t    char *str, enum handler_id handler)\n{\n\tstruct action_data *data;\n\tint ret = -EINVAL;\n\tchar *var_str;\n\n\tdata = kzalloc(sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tvar_str = strsep(&str, \")\");\n\tif (!var_str || !str) {\n\t\tret = -EINVAL;\n\t\tgoto free;\n\t}\n\n\tdata->track_data.var_str = kstrdup(var_str, GFP_KERNEL);\n\tif (!data->track_data.var_str) {\n\t\tret = -ENOMEM;\n\t\tgoto free;\n\t}\n\n\tret = action_parse(hist_data->event_file->tr, str, data, handler);\n\tif (ret)\n\t\tgoto free;\n out:\n\treturn data;\n free:\n\ttrack_data_destroy(hist_data, data);\n\tdata = ERR_PTR(ret);\n\tgoto out;\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include \"tracing_map.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "ret"
          ],
          "line": 3710
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "track_data_destroy",
          "args": [
            "hist_data",
            "data"
          ],
          "line": 3709
        },
        "resolved": true,
        "details": {
          "function_name": "track_data_destroy",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "3454-3474",
          "snippet": "static void track_data_destroy(struct hist_trigger_data *hist_data,\n\t\t\t       struct action_data *data)\n{\n\tstruct trace_event_file *file = hist_data->event_file;\n\n\tdestroy_hist_field(data->track_data.track_var, 0);\n\n\tif (data->action == ACTION_SNAPSHOT) {\n\t\tstruct track_data *track_data;\n\n\t\ttrack_data = tracing_cond_snapshot_data(file->tr);\n\t\tif (track_data && track_data->hist_data == hist_data) {\n\t\t\ttracing_snapshot_cond_disable(file->tr);\n\t\t\ttrack_data_free(track_data);\n\t\t}\n\t}\n\n\tkfree(data->track_data.var_str);\n\n\taction_data_destroy(data);\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);\n\nstatic void track_data_destroy(struct hist_trigger_data *hist_data,\n\t\t\t       struct action_data *data)\n{\n\tstruct trace_event_file *file = hist_data->event_file;\n\n\tdestroy_hist_field(data->track_data.track_var, 0);\n\n\tif (data->action == ACTION_SNAPSHOT) {\n\t\tstruct track_data *track_data;\n\n\t\ttrack_data = tracing_cond_snapshot_data(file->tr);\n\t\tif (track_data && track_data->hist_data == hist_data) {\n\t\t\ttracing_snapshot_cond_disable(file->tr);\n\t\t\ttrack_data_free(track_data);\n\t\t}\n\t}\n\n\tkfree(data->track_data.var_str);\n\n\taction_data_destroy(data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "action_parse",
          "args": [
            "hist_data->event_file->tr",
            "str",
            "data",
            "handler"
          ],
          "line": 3703
        },
        "resolved": true,
        "details": {
          "function_name": "action_parse",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "3575-3678",
          "snippet": "static int action_parse(struct trace_array *tr, char *str, struct action_data *data,\n\t\t\tenum handler_id handler)\n{\n\tchar *action_name;\n\tint ret = 0;\n\n\tstrsep(&str, \".\");\n\tif (!str) {\n\t\thist_err(tr, HIST_ERR_ACTION_NOT_FOUND, 0);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\taction_name = strsep(&str, \"(\");\n\tif (!action_name || !str) {\n\t\thist_err(tr, HIST_ERR_ACTION_NOT_FOUND, 0);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (str_has_prefix(action_name, \"save\")) {\n\t\tchar *params = strsep(&str, \")\");\n\n\t\tif (!params) {\n\t\t\thist_err(tr, HIST_ERR_NO_SAVE_PARAMS, 0);\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = parse_action_params(tr, params, data);\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\tif (handler == HANDLER_ONMAX)\n\t\t\tdata->track_data.check_val = check_track_val_max;\n\t\telse if (handler == HANDLER_ONCHANGE)\n\t\t\tdata->track_data.check_val = check_track_val_changed;\n\t\telse {\n\t\t\thist_err(tr, HIST_ERR_ACTION_MISMATCH, errpos(action_name));\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tdata->track_data.save_data = save_track_data_vars;\n\t\tdata->fn = ontrack_action;\n\t\tdata->action = ACTION_SAVE;\n\t} else if (str_has_prefix(action_name, \"snapshot\")) {\n\t\tchar *params = strsep(&str, \")\");\n\n\t\tif (!str) {\n\t\t\thist_err(tr, HIST_ERR_NO_CLOSING_PAREN, errpos(params));\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (handler == HANDLER_ONMAX)\n\t\t\tdata->track_data.check_val = check_track_val_max;\n\t\telse if (handler == HANDLER_ONCHANGE)\n\t\t\tdata->track_data.check_val = check_track_val_changed;\n\t\telse {\n\t\t\thist_err(tr, HIST_ERR_ACTION_MISMATCH, errpos(action_name));\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tdata->track_data.save_data = save_track_data_snapshot;\n\t\tdata->fn = ontrack_action;\n\t\tdata->action = ACTION_SNAPSHOT;\n\t} else {\n\t\tchar *params = strsep(&str, \")\");\n\n\t\tif (str_has_prefix(action_name, \"trace\"))\n\t\t\tdata->use_trace_keyword = true;\n\n\t\tif (params) {\n\t\t\tret = parse_action_params(tr, params, data);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t}\n\n\t\tif (handler == HANDLER_ONMAX)\n\t\t\tdata->track_data.check_val = check_track_val_max;\n\t\telse if (handler == HANDLER_ONCHANGE)\n\t\t\tdata->track_data.check_val = check_track_val_changed;\n\n\t\tif (handler != HANDLER_ONMATCH) {\n\t\t\tdata->track_data.save_data = action_trace;\n\t\t\tdata->fn = ontrack_action;\n\t\t} else\n\t\t\tdata->fn = action_trace;\n\n\t\tdata->action = ACTION_TRACE;\n\t}\n\n\tdata->action_name = kstrdup(action_name, GFP_KERNEL);\n\tif (!data->action_name) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tdata->handler = handler;\n out:\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);\n\nstatic int action_parse(struct trace_array *tr, char *str, struct action_data *data,\n\t\t\tenum handler_id handler)\n{\n\tchar *action_name;\n\tint ret = 0;\n\n\tstrsep(&str, \".\");\n\tif (!str) {\n\t\thist_err(tr, HIST_ERR_ACTION_NOT_FOUND, 0);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\taction_name = strsep(&str, \"(\");\n\tif (!action_name || !str) {\n\t\thist_err(tr, HIST_ERR_ACTION_NOT_FOUND, 0);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (str_has_prefix(action_name, \"save\")) {\n\t\tchar *params = strsep(&str, \")\");\n\n\t\tif (!params) {\n\t\t\thist_err(tr, HIST_ERR_NO_SAVE_PARAMS, 0);\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = parse_action_params(tr, params, data);\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\tif (handler == HANDLER_ONMAX)\n\t\t\tdata->track_data.check_val = check_track_val_max;\n\t\telse if (handler == HANDLER_ONCHANGE)\n\t\t\tdata->track_data.check_val = check_track_val_changed;\n\t\telse {\n\t\t\thist_err(tr, HIST_ERR_ACTION_MISMATCH, errpos(action_name));\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tdata->track_data.save_data = save_track_data_vars;\n\t\tdata->fn = ontrack_action;\n\t\tdata->action = ACTION_SAVE;\n\t} else if (str_has_prefix(action_name, \"snapshot\")) {\n\t\tchar *params = strsep(&str, \")\");\n\n\t\tif (!str) {\n\t\t\thist_err(tr, HIST_ERR_NO_CLOSING_PAREN, errpos(params));\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (handler == HANDLER_ONMAX)\n\t\t\tdata->track_data.check_val = check_track_val_max;\n\t\telse if (handler == HANDLER_ONCHANGE)\n\t\t\tdata->track_data.check_val = check_track_val_changed;\n\t\telse {\n\t\t\thist_err(tr, HIST_ERR_ACTION_MISMATCH, errpos(action_name));\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tdata->track_data.save_data = save_track_data_snapshot;\n\t\tdata->fn = ontrack_action;\n\t\tdata->action = ACTION_SNAPSHOT;\n\t} else {\n\t\tchar *params = strsep(&str, \")\");\n\n\t\tif (str_has_prefix(action_name, \"trace\"))\n\t\t\tdata->use_trace_keyword = true;\n\n\t\tif (params) {\n\t\t\tret = parse_action_params(tr, params, data);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t}\n\n\t\tif (handler == HANDLER_ONMAX)\n\t\t\tdata->track_data.check_val = check_track_val_max;\n\t\telse if (handler == HANDLER_ONCHANGE)\n\t\t\tdata->track_data.check_val = check_track_val_changed;\n\n\t\tif (handler != HANDLER_ONMATCH) {\n\t\t\tdata->track_data.save_data = action_trace;\n\t\t\tdata->fn = ontrack_action;\n\t\t} else\n\t\t\tdata->fn = action_trace;\n\n\t\tdata->action = ACTION_TRACE;\n\t}\n\n\tdata->action_name = kstrdup(action_name, GFP_KERNEL);\n\tif (!data->action_name) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tdata->handler = handler;\n out:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "var_str",
            "GFP_KERNEL"
          ],
          "line": 3697
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strsep",
          "args": [
            "&str",
            "\")\""
          ],
          "line": 3691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 3689
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*data)",
            "GFP_KERNEL"
          ],
          "line": 3687
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);\n\nstatic struct action_data *track_data_parse(struct hist_trigger_data *hist_data,\n\t\t\t\t\t    char *str, enum handler_id handler)\n{\n\tstruct action_data *data;\n\tint ret = -EINVAL;\n\tchar *var_str;\n\n\tdata = kzalloc(sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tvar_str = strsep(&str, \")\");\n\tif (!var_str || !str) {\n\t\tret = -EINVAL;\n\t\tgoto free;\n\t}\n\n\tdata->track_data.var_str = kstrdup(var_str, GFP_KERNEL);\n\tif (!data->track_data.var_str) {\n\t\tret = -ENOMEM;\n\t\tgoto free;\n\t}\n\n\tret = action_parse(hist_data->event_file->tr, str, data, handler);\n\tif (ret)\n\t\tgoto free;\n out:\n\treturn data;\n free:\n\ttrack_data_destroy(hist_data, data);\n\tdata = ERR_PTR(ret);\n\tgoto out;\n}"
  },
  {
    "function_name": "action_parse",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
    "lines": "3575-3678",
    "snippet": "static int action_parse(struct trace_array *tr, char *str, struct action_data *data,\n\t\t\tenum handler_id handler)\n{\n\tchar *action_name;\n\tint ret = 0;\n\n\tstrsep(&str, \".\");\n\tif (!str) {\n\t\thist_err(tr, HIST_ERR_ACTION_NOT_FOUND, 0);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\taction_name = strsep(&str, \"(\");\n\tif (!action_name || !str) {\n\t\thist_err(tr, HIST_ERR_ACTION_NOT_FOUND, 0);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (str_has_prefix(action_name, \"save\")) {\n\t\tchar *params = strsep(&str, \")\");\n\n\t\tif (!params) {\n\t\t\thist_err(tr, HIST_ERR_NO_SAVE_PARAMS, 0);\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = parse_action_params(tr, params, data);\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\tif (handler == HANDLER_ONMAX)\n\t\t\tdata->track_data.check_val = check_track_val_max;\n\t\telse if (handler == HANDLER_ONCHANGE)\n\t\t\tdata->track_data.check_val = check_track_val_changed;\n\t\telse {\n\t\t\thist_err(tr, HIST_ERR_ACTION_MISMATCH, errpos(action_name));\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tdata->track_data.save_data = save_track_data_vars;\n\t\tdata->fn = ontrack_action;\n\t\tdata->action = ACTION_SAVE;\n\t} else if (str_has_prefix(action_name, \"snapshot\")) {\n\t\tchar *params = strsep(&str, \")\");\n\n\t\tif (!str) {\n\t\t\thist_err(tr, HIST_ERR_NO_CLOSING_PAREN, errpos(params));\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (handler == HANDLER_ONMAX)\n\t\t\tdata->track_data.check_val = check_track_val_max;\n\t\telse if (handler == HANDLER_ONCHANGE)\n\t\t\tdata->track_data.check_val = check_track_val_changed;\n\t\telse {\n\t\t\thist_err(tr, HIST_ERR_ACTION_MISMATCH, errpos(action_name));\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tdata->track_data.save_data = save_track_data_snapshot;\n\t\tdata->fn = ontrack_action;\n\t\tdata->action = ACTION_SNAPSHOT;\n\t} else {\n\t\tchar *params = strsep(&str, \")\");\n\n\t\tif (str_has_prefix(action_name, \"trace\"))\n\t\t\tdata->use_trace_keyword = true;\n\n\t\tif (params) {\n\t\t\tret = parse_action_params(tr, params, data);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t}\n\n\t\tif (handler == HANDLER_ONMAX)\n\t\t\tdata->track_data.check_val = check_track_val_max;\n\t\telse if (handler == HANDLER_ONCHANGE)\n\t\t\tdata->track_data.check_val = check_track_val_changed;\n\n\t\tif (handler != HANDLER_ONMATCH) {\n\t\t\tdata->track_data.save_data = action_trace;\n\t\t\tdata->fn = ontrack_action;\n\t\t} else\n\t\t\tdata->fn = action_trace;\n\n\t\tdata->action = ACTION_TRACE;\n\t}\n\n\tdata->action_name = kstrdup(action_name, GFP_KERNEL);\n\tif (!data->action_name) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tdata->handler = handler;\n out:\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include \"tracing_map.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "action_name",
            "GFP_KERNEL"
          ],
          "line": 3669
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parse_action_params",
          "args": [
            "tr",
            "params",
            "data"
          ],
          "line": 3650
        },
        "resolved": true,
        "details": {
          "function_name": "parse_action_params",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "3529-3573",
          "snippet": "static int parse_action_params(struct trace_array *tr, char *params,\n\t\t\t       struct action_data *data)\n{\n\tchar *param, *saved_param;\n\tbool first_param = true;\n\tint ret = 0;\n\n\twhile (params) {\n\t\tif (data->n_params >= SYNTH_FIELDS_MAX) {\n\t\t\thist_err(tr, HIST_ERR_TOO_MANY_PARAMS, 0);\n\t\t\tgoto out;\n\t\t}\n\n\t\tparam = strsep(&params, \",\");\n\t\tif (!param) {\n\t\t\thist_err(tr, HIST_ERR_PARAM_NOT_FOUND, 0);\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tparam = strstrip(param);\n\t\tif (strlen(param) < 2) {\n\t\t\thist_err(tr, HIST_ERR_INVALID_PARAM, errpos(param));\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tsaved_param = kstrdup(param, GFP_KERNEL);\n\t\tif (!saved_param) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (first_param && data->use_trace_keyword) {\n\t\t\tdata->synth_event_name = saved_param;\n\t\t\tfirst_param = false;\n\t\t\tcontinue;\n\t\t}\n\t\tfirst_param = false;\n\n\t\tdata->params[data->n_params++] = saved_param;\n\t}\n out:\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int event_hist_trigger_parse(struct event_command *cmd_ops,\n\t\t\t\t    struct trace_event_file *file,\n\t\t\t\t    char *glob, char *cmd, char *param);",
            "static int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int event_hist_trigger_parse(struct event_command *cmd_ops,\n\t\t\t\t    struct trace_event_file *file,\n\t\t\t\t    char *glob, char *cmd, char *param);\nstatic int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);\n\nstatic int parse_action_params(struct trace_array *tr, char *params,\n\t\t\t       struct action_data *data)\n{\n\tchar *param, *saved_param;\n\tbool first_param = true;\n\tint ret = 0;\n\n\twhile (params) {\n\t\tif (data->n_params >= SYNTH_FIELDS_MAX) {\n\t\t\thist_err(tr, HIST_ERR_TOO_MANY_PARAMS, 0);\n\t\t\tgoto out;\n\t\t}\n\n\t\tparam = strsep(&params, \",\");\n\t\tif (!param) {\n\t\t\thist_err(tr, HIST_ERR_PARAM_NOT_FOUND, 0);\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tparam = strstrip(param);\n\t\tif (strlen(param) < 2) {\n\t\t\thist_err(tr, HIST_ERR_INVALID_PARAM, errpos(param));\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tsaved_param = kstrdup(param, GFP_KERNEL);\n\t\tif (!saved_param) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (first_param && data->use_trace_keyword) {\n\t\t\tdata->synth_event_name = saved_param;\n\t\t\tfirst_param = false;\n\t\t\tcontinue;\n\t\t}\n\t\tfirst_param = false;\n\n\t\tdata->params[data->n_params++] = saved_param;\n\t}\n out:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "str_has_prefix",
          "args": [
            "action_name",
            "\"trace\""
          ],
          "line": 3646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strsep",
          "args": [
            "&str",
            "\")\""
          ],
          "line": 3644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hist_err",
          "args": [
            "tr",
            "HIST_ERR_ACTION_MISMATCH",
            "errpos(action_name)"
          ],
          "line": 3635
        },
        "resolved": true,
        "details": {
          "function_name": "hist_err",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "763-767",
          "snippet": "static void hist_err(struct trace_array *tr, u8 err_type, u8 err_pos)\n{\n\ttracing_log_err(tr, last_cmd_loc, last_cmd, err_text,\n\t\t\terr_type, err_pos);\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *err_text[] = { ERRORS };",
            "static char last_cmd[MAX_FILTER_STR_VAL];",
            "static char last_cmd_loc[MAX_FILTER_STR_VAL];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic const char *err_text[] = { ERRORS };\nstatic char last_cmd[MAX_FILTER_STR_VAL];\nstatic char last_cmd_loc[MAX_FILTER_STR_VAL];\n\nstatic void hist_err(struct trace_array *tr, u8 err_type, u8 err_pos)\n{\n\ttracing_log_err(tr, last_cmd_loc, last_cmd, err_text,\n\t\t\terr_type, err_pos);\n}"
        }
      },
      {
        "call_info": {
          "callee": "errpos",
          "args": [
            "action_name"
          ],
          "line": 3635
        },
        "resolved": true,
        "details": {
          "function_name": "errpos",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "733-736",
          "snippet": "static int errpos(char *str)\n{\n\treturn err_pos(last_cmd, str);\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char last_cmd[MAX_FILTER_STR_VAL];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic char last_cmd[MAX_FILTER_STR_VAL];\n\nstatic int errpos(char *str)\n{\n\treturn err_pos(last_cmd, str);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strsep",
          "args": [
            "&str",
            "\")\""
          ],
          "line": 3622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "str_has_prefix",
          "args": [
            "action_name",
            "\"snapshot\""
          ],
          "line": 3621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strsep",
          "args": [
            "&str",
            "\")\""
          ],
          "line": 3596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "str_has_prefix",
          "args": [
            "action_name",
            "\"save\""
          ],
          "line": 3595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strsep",
          "args": [
            "&str",
            "\"(\""
          ],
          "line": 3588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strsep",
          "args": [
            "&str",
            "\".\""
          ],
          "line": 3581
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);\n\nstatic int action_parse(struct trace_array *tr, char *str, struct action_data *data,\n\t\t\tenum handler_id handler)\n{\n\tchar *action_name;\n\tint ret = 0;\n\n\tstrsep(&str, \".\");\n\tif (!str) {\n\t\thist_err(tr, HIST_ERR_ACTION_NOT_FOUND, 0);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\taction_name = strsep(&str, \"(\");\n\tif (!action_name || !str) {\n\t\thist_err(tr, HIST_ERR_ACTION_NOT_FOUND, 0);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (str_has_prefix(action_name, \"save\")) {\n\t\tchar *params = strsep(&str, \")\");\n\n\t\tif (!params) {\n\t\t\thist_err(tr, HIST_ERR_NO_SAVE_PARAMS, 0);\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = parse_action_params(tr, params, data);\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\tif (handler == HANDLER_ONMAX)\n\t\t\tdata->track_data.check_val = check_track_val_max;\n\t\telse if (handler == HANDLER_ONCHANGE)\n\t\t\tdata->track_data.check_val = check_track_val_changed;\n\t\telse {\n\t\t\thist_err(tr, HIST_ERR_ACTION_MISMATCH, errpos(action_name));\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tdata->track_data.save_data = save_track_data_vars;\n\t\tdata->fn = ontrack_action;\n\t\tdata->action = ACTION_SAVE;\n\t} else if (str_has_prefix(action_name, \"snapshot\")) {\n\t\tchar *params = strsep(&str, \")\");\n\n\t\tif (!str) {\n\t\t\thist_err(tr, HIST_ERR_NO_CLOSING_PAREN, errpos(params));\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (handler == HANDLER_ONMAX)\n\t\t\tdata->track_data.check_val = check_track_val_max;\n\t\telse if (handler == HANDLER_ONCHANGE)\n\t\t\tdata->track_data.check_val = check_track_val_changed;\n\t\telse {\n\t\t\thist_err(tr, HIST_ERR_ACTION_MISMATCH, errpos(action_name));\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tdata->track_data.save_data = save_track_data_snapshot;\n\t\tdata->fn = ontrack_action;\n\t\tdata->action = ACTION_SNAPSHOT;\n\t} else {\n\t\tchar *params = strsep(&str, \")\");\n\n\t\tif (str_has_prefix(action_name, \"trace\"))\n\t\t\tdata->use_trace_keyword = true;\n\n\t\tif (params) {\n\t\t\tret = parse_action_params(tr, params, data);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t}\n\n\t\tif (handler == HANDLER_ONMAX)\n\t\t\tdata->track_data.check_val = check_track_val_max;\n\t\telse if (handler == HANDLER_ONCHANGE)\n\t\t\tdata->track_data.check_val = check_track_val_changed;\n\n\t\tif (handler != HANDLER_ONMATCH) {\n\t\t\tdata->track_data.save_data = action_trace;\n\t\t\tdata->fn = ontrack_action;\n\t\t} else\n\t\t\tdata->fn = action_trace;\n\n\t\tdata->action = ACTION_TRACE;\n\t}\n\n\tdata->action_name = kstrdup(action_name, GFP_KERNEL);\n\tif (!data->action_name) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tdata->handler = handler;\n out:\n\treturn ret;\n}"
  },
  {
    "function_name": "parse_action_params",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
    "lines": "3529-3573",
    "snippet": "static int parse_action_params(struct trace_array *tr, char *params,\n\t\t\t       struct action_data *data)\n{\n\tchar *param, *saved_param;\n\tbool first_param = true;\n\tint ret = 0;\n\n\twhile (params) {\n\t\tif (data->n_params >= SYNTH_FIELDS_MAX) {\n\t\t\thist_err(tr, HIST_ERR_TOO_MANY_PARAMS, 0);\n\t\t\tgoto out;\n\t\t}\n\n\t\tparam = strsep(&params, \",\");\n\t\tif (!param) {\n\t\t\thist_err(tr, HIST_ERR_PARAM_NOT_FOUND, 0);\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tparam = strstrip(param);\n\t\tif (strlen(param) < 2) {\n\t\t\thist_err(tr, HIST_ERR_INVALID_PARAM, errpos(param));\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tsaved_param = kstrdup(param, GFP_KERNEL);\n\t\tif (!saved_param) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (first_param && data->use_trace_keyword) {\n\t\t\tdata->synth_event_name = saved_param;\n\t\t\tfirst_param = false;\n\t\t\tcontinue;\n\t\t}\n\t\tfirst_param = false;\n\n\t\tdata->params[data->n_params++] = saved_param;\n\t}\n out:\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include \"tracing_map.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int event_hist_trigger_parse(struct event_command *cmd_ops,\n\t\t\t\t    struct trace_event_file *file,\n\t\t\t\t    char *glob, char *cmd, char *param);",
      "static int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "param",
            "GFP_KERNEL"
          ],
          "line": 3556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hist_err",
          "args": [
            "tr",
            "HIST_ERR_INVALID_PARAM",
            "errpos(param)"
          ],
          "line": 3551
        },
        "resolved": true,
        "details": {
          "function_name": "hist_err",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "763-767",
          "snippet": "static void hist_err(struct trace_array *tr, u8 err_type, u8 err_pos)\n{\n\ttracing_log_err(tr, last_cmd_loc, last_cmd, err_text,\n\t\t\terr_type, err_pos);\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *err_text[] = { ERRORS };",
            "static char last_cmd[MAX_FILTER_STR_VAL];",
            "static char last_cmd_loc[MAX_FILTER_STR_VAL];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic const char *err_text[] = { ERRORS };\nstatic char last_cmd[MAX_FILTER_STR_VAL];\nstatic char last_cmd_loc[MAX_FILTER_STR_VAL];\n\nstatic void hist_err(struct trace_array *tr, u8 err_type, u8 err_pos)\n{\n\ttracing_log_err(tr, last_cmd_loc, last_cmd, err_text,\n\t\t\terr_type, err_pos);\n}"
        }
      },
      {
        "call_info": {
          "callee": "errpos",
          "args": [
            "param"
          ],
          "line": 3551
        },
        "resolved": true,
        "details": {
          "function_name": "errpos",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "733-736",
          "snippet": "static int errpos(char *str)\n{\n\treturn err_pos(last_cmd, str);\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char last_cmd[MAX_FILTER_STR_VAL];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic char last_cmd[MAX_FILTER_STR_VAL];\n\nstatic int errpos(char *str)\n{\n\treturn err_pos(last_cmd, str);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "param"
          ],
          "line": 3550
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_eprobe.c",
          "lines": "384-401",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/ftrace.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strstrip",
          "args": [
            "param"
          ],
          "line": 3549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strsep",
          "args": [
            "&params",
            "\",\""
          ],
          "line": 3542
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int event_hist_trigger_parse(struct event_command *cmd_ops,\n\t\t\t\t    struct trace_event_file *file,\n\t\t\t\t    char *glob, char *cmd, char *param);\nstatic int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);\n\nstatic int parse_action_params(struct trace_array *tr, char *params,\n\t\t\t       struct action_data *data)\n{\n\tchar *param, *saved_param;\n\tbool first_param = true;\n\tint ret = 0;\n\n\twhile (params) {\n\t\tif (data->n_params >= SYNTH_FIELDS_MAX) {\n\t\t\thist_err(tr, HIST_ERR_TOO_MANY_PARAMS, 0);\n\t\t\tgoto out;\n\t\t}\n\n\t\tparam = strsep(&params, \",\");\n\t\tif (!param) {\n\t\t\thist_err(tr, HIST_ERR_PARAM_NOT_FOUND, 0);\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tparam = strstrip(param);\n\t\tif (strlen(param) < 2) {\n\t\t\thist_err(tr, HIST_ERR_INVALID_PARAM, errpos(param));\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tsaved_param = kstrdup(param, GFP_KERNEL);\n\t\tif (!saved_param) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (first_param && data->use_trace_keyword) {\n\t\t\tdata->synth_event_name = saved_param;\n\t\t\tfirst_param = false;\n\t\t\tcontinue;\n\t\t}\n\t\tfirst_param = false;\n\n\t\tdata->params[data->n_params++] = saved_param;\n\t}\n out:\n\treturn ret;\n}"
  },
  {
    "function_name": "track_data_create",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
    "lines": "3479-3527",
    "snippet": "static int track_data_create(struct hist_trigger_data *hist_data,\n\t\t\t     struct action_data *data)\n{\n\tstruct hist_field *var_field, *ref_field, *track_var = NULL;\n\tstruct trace_event_file *file = hist_data->event_file;\n\tstruct trace_array *tr = file->tr;\n\tchar *track_data_var_str;\n\tint ret = 0;\n\n\ttrack_data_var_str = data->track_data.var_str;\n\tif (track_data_var_str[0] != '$') {\n\t\thist_err(tr, HIST_ERR_ONX_NOT_VAR, errpos(track_data_var_str));\n\t\treturn -EINVAL;\n\t}\n\ttrack_data_var_str++;\n\n\tvar_field = find_target_event_var(hist_data, NULL, NULL, track_data_var_str);\n\tif (!var_field) {\n\t\thist_err(tr, HIST_ERR_ONX_VAR_NOT_FOUND, errpos(track_data_var_str));\n\t\treturn -EINVAL;\n\t}\n\n\tref_field = create_var_ref(hist_data, var_field, NULL, NULL);\n\tif (!ref_field)\n\t\treturn -ENOMEM;\n\n\tdata->track_data.var_ref = ref_field;\n\n\tif (data->handler == HANDLER_ONMAX)\n\t\ttrack_var = create_var(hist_data, file, \"__max\", sizeof(u64), \"u64\");\n\tif (IS_ERR(track_var)) {\n\t\thist_err(tr, HIST_ERR_ONX_VAR_CREATE_FAIL, 0);\n\t\tret = PTR_ERR(track_var);\n\t\tgoto out;\n\t}\n\n\tif (data->handler == HANDLER_ONCHANGE)\n\t\ttrack_var = create_var(hist_data, file, \"__change\", sizeof(u64), \"u64\");\n\tif (IS_ERR(track_var)) {\n\t\thist_err(tr, HIST_ERR_ONX_VAR_CREATE_FAIL, 0);\n\t\tret = PTR_ERR(track_var);\n\t\tgoto out;\n\t}\n\tdata->track_data.track_var = track_var;\n\n\tret = action_create(hist_data, data);\n out:\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include \"tracing_map.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "action_create",
          "args": [
            "hist_data",
            "data"
          ],
          "line": 3524
        },
        "resolved": true,
        "details": {
          "function_name": "action_create",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "3970-4030",
          "snippet": "static int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data)\n{\n\tstruct trace_event_file *file = hist_data->event_file;\n\tstruct trace_array *tr = file->tr;\n\tstruct track_data *track_data;\n\tstruct field_var *field_var;\n\tunsigned int i;\n\tchar *param;\n\tint ret = 0;\n\n\tif (data->action == ACTION_TRACE)\n\t\treturn trace_action_create(hist_data, data);\n\n\tif (data->action == ACTION_SNAPSHOT) {\n\t\ttrack_data = track_data_alloc(hist_data->key_size, data, hist_data);\n\t\tif (IS_ERR(track_data)) {\n\t\t\tret = PTR_ERR(track_data);\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = tracing_snapshot_cond_enable(file->tr, track_data,\n\t\t\t\t\t\t   cond_snapshot_update);\n\t\tif (ret)\n\t\t\ttrack_data_free(track_data);\n\n\t\tgoto out;\n\t}\n\n\tif (data->action == ACTION_SAVE) {\n\t\tif (hist_data->n_save_vars) {\n\t\t\tret = -EEXIST;\n\t\t\thist_err(tr, HIST_ERR_TOO_MANY_SAVE_ACTIONS, 0);\n\t\t\tgoto out;\n\t\t}\n\n\t\tfor (i = 0; i < data->n_params; i++) {\n\t\t\tparam = kstrdup(data->params[i], GFP_KERNEL);\n\t\t\tif (!param) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tfield_var = create_target_field_var(hist_data, NULL, NULL, param);\n\t\t\tif (IS_ERR(field_var)) {\n\t\t\t\thist_err(tr, HIST_ERR_FIELD_VAR_CREATE_FAIL,\n\t\t\t\t\t errpos(param));\n\t\t\t\tret = PTR_ERR(field_var);\n\t\t\t\tkfree(param);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\thist_data->save_vars[hist_data->n_save_vars++] = field_var;\n\t\t\tif (field_var->val->flags & HIST_FIELD_FL_STRING)\n\t\t\t\thist_data->n_save_var_str++;\n\t\t\tkfree(param);\n\t\t}\n\t}\n out:\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int event_hist_trigger_parse(struct event_command *cmd_ops,\n\t\t\t\t    struct trace_event_file *file,\n\t\t\t\t    char *glob, char *cmd, char *param);",
            "static int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int event_hist_trigger_parse(struct event_command *cmd_ops,\n\t\t\t\t    struct trace_event_file *file,\n\t\t\t\t    char *glob, char *cmd, char *param);\nstatic int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);\n\nstatic int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data)\n{\n\tstruct trace_event_file *file = hist_data->event_file;\n\tstruct trace_array *tr = file->tr;\n\tstruct track_data *track_data;\n\tstruct field_var *field_var;\n\tunsigned int i;\n\tchar *param;\n\tint ret = 0;\n\n\tif (data->action == ACTION_TRACE)\n\t\treturn trace_action_create(hist_data, data);\n\n\tif (data->action == ACTION_SNAPSHOT) {\n\t\ttrack_data = track_data_alloc(hist_data->key_size, data, hist_data);\n\t\tif (IS_ERR(track_data)) {\n\t\t\tret = PTR_ERR(track_data);\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = tracing_snapshot_cond_enable(file->tr, track_data,\n\t\t\t\t\t\t   cond_snapshot_update);\n\t\tif (ret)\n\t\t\ttrack_data_free(track_data);\n\n\t\tgoto out;\n\t}\n\n\tif (data->action == ACTION_SAVE) {\n\t\tif (hist_data->n_save_vars) {\n\t\t\tret = -EEXIST;\n\t\t\thist_err(tr, HIST_ERR_TOO_MANY_SAVE_ACTIONS, 0);\n\t\t\tgoto out;\n\t\t}\n\n\t\tfor (i = 0; i < data->n_params; i++) {\n\t\t\tparam = kstrdup(data->params[i], GFP_KERNEL);\n\t\t\tif (!param) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tfield_var = create_target_field_var(hist_data, NULL, NULL, param);\n\t\t\tif (IS_ERR(field_var)) {\n\t\t\t\thist_err(tr, HIST_ERR_FIELD_VAR_CREATE_FAIL,\n\t\t\t\t\t errpos(param));\n\t\t\t\tret = PTR_ERR(field_var);\n\t\t\t\tkfree(param);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\thist_data->save_vars[hist_data->n_save_vars++] = field_var;\n\t\t\tif (field_var->val->flags & HIST_FIELD_FL_STRING)\n\t\t\t\thist_data->n_save_var_str++;\n\t\t\tkfree(param);\n\t\t}\n\t}\n out:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "track_var"
          ],
          "line": 3519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hist_err",
          "args": [
            "tr",
            "HIST_ERR_ONX_VAR_CREATE_FAIL",
            "0"
          ],
          "line": 3518
        },
        "resolved": true,
        "details": {
          "function_name": "hist_err",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "763-767",
          "snippet": "static void hist_err(struct trace_array *tr, u8 err_type, u8 err_pos)\n{\n\ttracing_log_err(tr, last_cmd_loc, last_cmd, err_text,\n\t\t\terr_type, err_pos);\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *err_text[] = { ERRORS };",
            "static char last_cmd[MAX_FILTER_STR_VAL];",
            "static char last_cmd_loc[MAX_FILTER_STR_VAL];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic const char *err_text[] = { ERRORS };\nstatic char last_cmd[MAX_FILTER_STR_VAL];\nstatic char last_cmd_loc[MAX_FILTER_STR_VAL];\n\nstatic void hist_err(struct trace_array *tr, u8 err_type, u8 err_pos)\n{\n\ttracing_log_err(tr, last_cmd_loc, last_cmd, err_text,\n\t\t\terr_type, err_pos);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "track_var"
          ],
          "line": 3517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "create_var",
          "args": [
            "hist_data",
            "file",
            "\"__change\"",
            "sizeof(u64)",
            "\"u64\""
          ],
          "line": 3516
        },
        "resolved": true,
        "details": {
          "function_name": "create_var_field",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "4176-4207",
          "snippet": "static int create_var_field(struct hist_trigger_data *hist_data,\n\t\t\t    unsigned int val_idx,\n\t\t\t    struct trace_event_file *file,\n\t\t\t    char *var_name, char *expr_str)\n{\n\tstruct trace_array *tr = hist_data->event_file->tr;\n\tunsigned long flags = 0;\n\tint ret;\n\n\tif (WARN_ON(val_idx >= TRACING_MAP_VALS_MAX + TRACING_MAP_VARS_MAX))\n\t\treturn -EINVAL;\n\n\tif (find_var(hist_data, file, var_name) && !hist_data->remove) {\n\t\thist_err(tr, HIST_ERR_DUPLICATE_VAR, errpos(var_name));\n\t\treturn -EINVAL;\n\t}\n\n\tflags |= HIST_FIELD_FL_VAR;\n\thist_data->n_vars++;\n\tif (WARN_ON(hist_data->n_vars > TRACING_MAP_VARS_MAX))\n\t\treturn -EINVAL;\n\n\tret = __create_val_field(hist_data, val_idx, file, var_name, expr_str, flags);\n\n\tif (!ret && hist_data->fields[val_idx]->flags & HIST_FIELD_FL_EXECNAME)\n\t\tupdate_var_execname(hist_data->fields[val_idx]);\n\n\tif (!ret && hist_data->fields[val_idx]->flags & HIST_FIELD_FL_STRING)\n\t\thist_data->fields[val_idx]->var_str_idx = hist_data->n_var_str++;\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int create_var_field(struct hist_trigger_data *hist_data,\n\t\t\t    unsigned int val_idx,\n\t\t\t    struct trace_event_file *file,\n\t\t\t    char *var_name, char *expr_str)\n{\n\tstruct trace_array *tr = hist_data->event_file->tr;\n\tunsigned long flags = 0;\n\tint ret;\n\n\tif (WARN_ON(val_idx >= TRACING_MAP_VALS_MAX + TRACING_MAP_VARS_MAX))\n\t\treturn -EINVAL;\n\n\tif (find_var(hist_data, file, var_name) && !hist_data->remove) {\n\t\thist_err(tr, HIST_ERR_DUPLICATE_VAR, errpos(var_name));\n\t\treturn -EINVAL;\n\t}\n\n\tflags |= HIST_FIELD_FL_VAR;\n\thist_data->n_vars++;\n\tif (WARN_ON(hist_data->n_vars > TRACING_MAP_VARS_MAX))\n\t\treturn -EINVAL;\n\n\tret = __create_val_field(hist_data, val_idx, file, var_name, expr_str, flags);\n\n\tif (!ret && hist_data->fields[val_idx]->flags & HIST_FIELD_FL_EXECNAME)\n\t\tupdate_var_execname(hist_data->fields[val_idx]);\n\n\tif (!ret && hist_data->fields[val_idx]->flags & HIST_FIELD_FL_STRING)\n\t\thist_data->fields[val_idx]->var_str_idx = hist_data->n_var_str++;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "track_var"
          ],
          "line": 3511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "track_var"
          ],
          "line": 3509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "create_var_ref",
          "args": [
            "hist_data",
            "var_field",
            "NULL",
            "NULL"
          ],
          "line": 3501
        },
        "resolved": true,
        "details": {
          "function_name": "create_var_ref",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "2114-2144",
          "snippet": "static struct hist_field *create_var_ref(struct hist_trigger_data *hist_data,\n\t\t\t\t\t struct hist_field *var_field,\n\t\t\t\t\t char *system, char *event_name)\n{\n\tunsigned long flags = HIST_FIELD_FL_VAR_REF;\n\tstruct hist_field *ref_field;\n\tint i;\n\n\t/* Check if the variable already exists */\n\tfor (i = 0; i < hist_data->n_var_refs; i++) {\n\t\tref_field = hist_data->var_refs[i];\n\t\tif (ref_field->var.idx == var_field->var.idx &&\n\t\t    ref_field->var.hist_data == var_field->hist_data) {\n\t\t\tget_hist_field(ref_field);\n\t\t\treturn ref_field;\n\t\t}\n\t}\n\n\tref_field = create_hist_field(var_field->hist_data, NULL, flags, NULL);\n\tif (ref_field) {\n\t\tif (init_var_ref(ref_field, var_field, system, event_name)) {\n\t\t\tdestroy_hist_field(ref_field, 0);\n\t\t\treturn NULL;\n\t\t}\n\n\t\thist_data->var_refs[hist_data->n_var_refs] = ref_field;\n\t\tref_field->var_ref_idx = hist_data->n_var_refs++;\n\t}\n\n\treturn ref_field;\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct hist_field *create_var_ref(struct hist_trigger_data *hist_data,\n\t\t\t\t\t struct hist_field *var_field,\n\t\t\t\t\t char *system, char *event_name)\n{\n\tunsigned long flags = HIST_FIELD_FL_VAR_REF;\n\tstruct hist_field *ref_field;\n\tint i;\n\n\t/* Check if the variable already exists */\n\tfor (i = 0; i < hist_data->n_var_refs; i++) {\n\t\tref_field = hist_data->var_refs[i];\n\t\tif (ref_field->var.idx == var_field->var.idx &&\n\t\t    ref_field->var.hist_data == var_field->hist_data) {\n\t\t\tget_hist_field(ref_field);\n\t\t\treturn ref_field;\n\t\t}\n\t}\n\n\tref_field = create_hist_field(var_field->hist_data, NULL, flags, NULL);\n\tif (ref_field) {\n\t\tif (init_var_ref(ref_field, var_field, system, event_name)) {\n\t\t\tdestroy_hist_field(ref_field, 0);\n\t\t\treturn NULL;\n\t\t}\n\n\t\thist_data->var_refs[hist_data->n_var_refs] = ref_field;\n\t\tref_field->var_ref_idx = hist_data->n_var_refs++;\n\t}\n\n\treturn ref_field;\n}"
        }
      },
      {
        "call_info": {
          "callee": "errpos",
          "args": [
            "track_data_var_str"
          ],
          "line": 3497
        },
        "resolved": true,
        "details": {
          "function_name": "errpos",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "733-736",
          "snippet": "static int errpos(char *str)\n{\n\treturn err_pos(last_cmd, str);\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char last_cmd[MAX_FILTER_STR_VAL];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic char last_cmd[MAX_FILTER_STR_VAL];\n\nstatic int errpos(char *str)\n{\n\treturn err_pos(last_cmd, str);\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_target_event_var",
          "args": [
            "hist_data",
            "NULL",
            "NULL",
            "track_data_var_str"
          ],
          "line": 3495
        },
        "resolved": true,
        "details": {
          "function_name": "find_target_event_var",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "2998-3023",
          "snippet": "static struct hist_field *\nfind_target_event_var(struct hist_trigger_data *hist_data,\n\t\t      char *subsys_name, char *event_name, char *var_name)\n{\n\tstruct trace_event_file *file = hist_data->event_file;\n\tstruct hist_field *hist_field = NULL;\n\n\tif (subsys_name) {\n\t\tstruct trace_event_call *call;\n\n\t\tif (!event_name)\n\t\t\treturn NULL;\n\n\t\tcall = file->event_call;\n\n\t\tif (strcmp(subsys_name, call->class->system) != 0)\n\t\t\treturn NULL;\n\n\t\tif (strcmp(event_name, trace_event_name(call)) != 0)\n\t\t\treturn NULL;\n\t}\n\n\thist_field = find_var_field(hist_data, var_name);\n\n\treturn hist_field;\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct hist_field *\nfind_target_event_var(struct hist_trigger_data *hist_data,\n\t\t      char *subsys_name, char *event_name, char *var_name)\n{\n\tstruct trace_event_file *file = hist_data->event_file;\n\tstruct hist_field *hist_field = NULL;\n\n\tif (subsys_name) {\n\t\tstruct trace_event_call *call;\n\n\t\tif (!event_name)\n\t\t\treturn NULL;\n\n\t\tcall = file->event_call;\n\n\t\tif (strcmp(subsys_name, call->class->system) != 0)\n\t\t\treturn NULL;\n\n\t\tif (strcmp(event_name, trace_event_name(call)) != 0)\n\t\t\treturn NULL;\n\t}\n\n\thist_field = find_var_field(hist_data, var_name);\n\n\treturn hist_field;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);\n\nstatic int track_data_create(struct hist_trigger_data *hist_data,\n\t\t\t     struct action_data *data)\n{\n\tstruct hist_field *var_field, *ref_field, *track_var = NULL;\n\tstruct trace_event_file *file = hist_data->event_file;\n\tstruct trace_array *tr = file->tr;\n\tchar *track_data_var_str;\n\tint ret = 0;\n\n\ttrack_data_var_str = data->track_data.var_str;\n\tif (track_data_var_str[0] != '$') {\n\t\thist_err(tr, HIST_ERR_ONX_NOT_VAR, errpos(track_data_var_str));\n\t\treturn -EINVAL;\n\t}\n\ttrack_data_var_str++;\n\n\tvar_field = find_target_event_var(hist_data, NULL, NULL, track_data_var_str);\n\tif (!var_field) {\n\t\thist_err(tr, HIST_ERR_ONX_VAR_NOT_FOUND, errpos(track_data_var_str));\n\t\treturn -EINVAL;\n\t}\n\n\tref_field = create_var_ref(hist_data, var_field, NULL, NULL);\n\tif (!ref_field)\n\t\treturn -ENOMEM;\n\n\tdata->track_data.var_ref = ref_field;\n\n\tif (data->handler == HANDLER_ONMAX)\n\t\ttrack_var = create_var(hist_data, file, \"__max\", sizeof(u64), \"u64\");\n\tif (IS_ERR(track_var)) {\n\t\thist_err(tr, HIST_ERR_ONX_VAR_CREATE_FAIL, 0);\n\t\tret = PTR_ERR(track_var);\n\t\tgoto out;\n\t}\n\n\tif (data->handler == HANDLER_ONCHANGE)\n\t\ttrack_var = create_var(hist_data, file, \"__change\", sizeof(u64), \"u64\");\n\tif (IS_ERR(track_var)) {\n\t\thist_err(tr, HIST_ERR_ONX_VAR_CREATE_FAIL, 0);\n\t\tret = PTR_ERR(track_var);\n\t\tgoto out;\n\t}\n\tdata->track_data.track_var = track_var;\n\n\tret = action_create(hist_data, data);\n out:\n\treturn ret;\n}"
  },
  {
    "function_name": "track_data_destroy",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
    "lines": "3454-3474",
    "snippet": "static void track_data_destroy(struct hist_trigger_data *hist_data,\n\t\t\t       struct action_data *data)\n{\n\tstruct trace_event_file *file = hist_data->event_file;\n\n\tdestroy_hist_field(data->track_data.track_var, 0);\n\n\tif (data->action == ACTION_SNAPSHOT) {\n\t\tstruct track_data *track_data;\n\n\t\ttrack_data = tracing_cond_snapshot_data(file->tr);\n\t\tif (track_data && track_data->hist_data == hist_data) {\n\t\t\ttracing_snapshot_cond_disable(file->tr);\n\t\t\ttrack_data_free(track_data);\n\t\t}\n\t}\n\n\tkfree(data->track_data.var_str);\n\n\taction_data_destroy(data);\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include \"tracing_map.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "action_data_destroy",
          "args": [
            "data"
          ],
          "line": 3473
        },
        "resolved": true,
        "details": {
          "function_name": "action_data_destroy",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "3435-3452",
          "snippet": "static void action_data_destroy(struct action_data *data)\n{\n\tunsigned int i;\n\n\tlockdep_assert_held(&event_mutex);\n\n\tkfree(data->action_name);\n\n\tfor (i = 0; i < data->n_params; i++)\n\t\tkfree(data->params[i]);\n\n\tif (data->synth_event)\n\t\tdata->synth_event->ref--;\n\n\tkfree(data->synth_event_name);\n\n\tkfree(data);\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);\n\nstatic void action_data_destroy(struct action_data *data)\n{\n\tunsigned int i;\n\n\tlockdep_assert_held(&event_mutex);\n\n\tkfree(data->action_name);\n\n\tfor (i = 0; i < data->n_params; i++)\n\t\tkfree(data->params[i]);\n\n\tif (data->synth_event)\n\t\tdata->synth_event->ref--;\n\n\tkfree(data->synth_event_name);\n\n\tkfree(data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "data->track_data.var_str"
          ],
          "line": 3471
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "track_data_free",
          "args": [
            "track_data"
          ],
          "line": 3467
        },
        "resolved": true,
        "details": {
          "function_name": "track_data_free",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "675-691",
          "snippet": "static void track_data_free(struct track_data *track_data)\n{\n\tstruct hist_elt_data *elt_data;\n\n\tif (!track_data)\n\t\treturn;\n\n\tkfree(track_data->key);\n\n\telt_data = track_data->elt.private_data;\n\tif (elt_data) {\n\t\tkfree(elt_data->comm);\n\t\tkfree(elt_data);\n\t}\n\n\tkfree(track_data);\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void track_data_free(struct track_data *track_data)\n{\n\tstruct hist_elt_data *elt_data;\n\n\tif (!track_data)\n\t\treturn;\n\n\tkfree(track_data->key);\n\n\telt_data = track_data->elt.private_data;\n\tif (elt_data) {\n\t\tkfree(elt_data->comm);\n\t\tkfree(elt_data);\n\t}\n\n\tkfree(track_data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracing_snapshot_cond_disable",
          "args": [
            "file->tr"
          ],
          "line": 3466
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_snapshot_cond_disable",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "1397-1400",
          "snippet": "int tracing_snapshot_cond_disable(struct trace_array *tr)\n{\n\treturn false;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nint tracing_snapshot_cond_disable(struct trace_array *tr)\n{\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracing_cond_snapshot_data",
          "args": [
            "file->tr"
          ],
          "line": 3464
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_cond_snapshot_data",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "1387-1390",
          "snippet": "void *tracing_cond_snapshot_data(struct trace_array *tr)\n{\n\treturn NULL;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nvoid *tracing_cond_snapshot_data(struct trace_array *tr)\n{\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "destroy_hist_field",
          "args": [
            "data->track_data.track_var",
            "0"
          ],
          "line": 3459
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_hist_field",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "1864-1882",
          "snippet": "static void destroy_hist_field(struct hist_field *hist_field,\n\t\t\t       unsigned int level)\n{\n\tunsigned int i;\n\n\tif (level > 3)\n\t\treturn;\n\n\tif (!hist_field)\n\t\treturn;\n\n\tif (hist_field->flags & HIST_FIELD_FL_VAR_REF)\n\t\treturn; /* var refs will be destroyed separately */\n\n\tfor (i = 0; i < HIST_FIELD_OPERANDS_MAX; i++)\n\t\tdestroy_hist_field(hist_field->operands[i], level + 1);\n\n\t__destroy_hist_field(hist_field);\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define HIST_FIELD_OPERANDS_MAX\t2"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\n#define HIST_FIELD_OPERANDS_MAX\t2\n\nstatic void destroy_hist_field(struct hist_field *hist_field,\n\t\t\t       unsigned int level)\n{\n\tunsigned int i;\n\n\tif (level > 3)\n\t\treturn;\n\n\tif (!hist_field)\n\t\treturn;\n\n\tif (hist_field->flags & HIST_FIELD_FL_VAR_REF)\n\t\treturn; /* var refs will be destroyed separately */\n\n\tfor (i = 0; i < HIST_FIELD_OPERANDS_MAX; i++)\n\t\tdestroy_hist_field(hist_field->operands[i], level + 1);\n\n\t__destroy_hist_field(hist_field);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);\n\nstatic void track_data_destroy(struct hist_trigger_data *hist_data,\n\t\t\t       struct action_data *data)\n{\n\tstruct trace_event_file *file = hist_data->event_file;\n\n\tdestroy_hist_field(data->track_data.track_var, 0);\n\n\tif (data->action == ACTION_SNAPSHOT) {\n\t\tstruct track_data *track_data;\n\n\t\ttrack_data = tracing_cond_snapshot_data(file->tr);\n\t\tif (track_data && track_data->hist_data == hist_data) {\n\t\t\ttracing_snapshot_cond_disable(file->tr);\n\t\t\ttrack_data_free(track_data);\n\t\t}\n\t}\n\n\tkfree(data->track_data.var_str);\n\n\taction_data_destroy(data);\n}"
  },
  {
    "function_name": "action_data_destroy",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
    "lines": "3435-3452",
    "snippet": "static void action_data_destroy(struct action_data *data)\n{\n\tunsigned int i;\n\n\tlockdep_assert_held(&event_mutex);\n\n\tkfree(data->action_name);\n\n\tfor (i = 0; i < data->n_params; i++)\n\t\tkfree(data->params[i]);\n\n\tif (data->synth_event)\n\t\tdata->synth_event->ref--;\n\n\tkfree(data->synth_event_name);\n\n\tkfree(data);\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include \"tracing_map.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "data"
          ],
          "line": 3451
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&event_mutex"
          ],
          "line": 3439
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);\n\nstatic void action_data_destroy(struct action_data *data)\n{\n\tunsigned int i;\n\n\tlockdep_assert_held(&event_mutex);\n\n\tkfree(data->action_name);\n\n\tfor (i = 0; i < data->n_params; i++)\n\t\tkfree(data->params[i]);\n\n\tif (data->synth_event)\n\t\tdata->synth_event->ref--;\n\n\tkfree(data->synth_event_name);\n\n\tkfree(data);\n}"
  },
  {
    "function_name": "ontrack_action",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
    "lines": "3420-3433",
    "snippet": "static void ontrack_action(struct hist_trigger_data *hist_data,\n\t\t\t   struct tracing_map_elt *elt,\n\t\t\t   struct trace_buffer *buffer, void *rec,\n\t\t\t   struct ring_buffer_event *rbe, void *key,\n\t\t\t   struct action_data *data, u64 *var_ref_vals)\n{\n\tu64 var_val = var_ref_vals[data->track_data.var_ref->var_ref_idx];\n\n\tif (check_track_val(elt, data, var_val)) {\n\t\tsave_track_val(hist_data, elt, data, var_val);\n\t\tsave_track_data(hist_data, elt, buffer, rec, rbe,\n\t\t\t\tkey, data, var_ref_vals);\n\t}\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include \"tracing_map.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "save_track_data",
          "args": [
            "hist_data",
            "elt",
            "buffer",
            "rec",
            "rbe",
            "key",
            "data",
            "var_ref_vals"
          ],
          "line": 3430
        },
        "resolved": true,
        "details": {
          "function_name": "save_track_data_snapshot",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "3377-3382",
          "snippet": "static void save_track_data_snapshot(struct hist_trigger_data *hist_data,\n\t\t\t\t     struct tracing_map_elt *elt,\n\t\t\t\t     struct trace_buffer *buffer, void *rec,\n\t\t\t\t     struct ring_buffer_event *rbe, void *key,\n\t\t\t\t     struct action_data *data,\n\t\t\t\t     u64 *var_ref_vals) {}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);\n\nstatic void save_track_data_snapshot(struct hist_trigger_data *hist_data,\n\t\t\t\t     struct tracing_map_elt *elt,\n\t\t\t\t     struct trace_buffer *buffer, void *rec,\n\t\t\t\t     struct ring_buffer_event *rbe, void *key,\n\t\t\t\t     struct action_data *data,\n\t\t\t\t     u64 *var_ref_vals) {}"
        }
      },
      {
        "call_info": {
          "callee": "save_track_val",
          "args": [
            "hist_data",
            "elt",
            "data",
            "var_val"
          ],
          "line": 3429
        },
        "resolved": true,
        "details": {
          "function_name": "save_track_val",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "3240-3247",
          "snippet": "static void save_track_val(struct hist_trigger_data *hist_data,\n\t\t\t   struct tracing_map_elt *elt,\n\t\t\t   struct action_data *data, u64 var_val)\n{\n\tunsigned int track_var_idx = data->track_data.track_var->var.idx;\n\n\ttracing_map_set_var(elt, track_var_idx, var_val);\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);\n\nstatic void save_track_val(struct hist_trigger_data *hist_data,\n\t\t\t   struct tracing_map_elt *elt,\n\t\t\t   struct action_data *data, u64 var_val)\n{\n\tunsigned int track_var_idx = data->track_data.track_var->var.idx;\n\n\ttracing_map_set_var(elt, track_var_idx, var_val);\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_track_val",
          "args": [
            "elt",
            "data",
            "var_val"
          ],
          "line": 3428
        },
        "resolved": true,
        "details": {
          "function_name": "check_track_val",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "3260-3271",
          "snippet": "static bool check_track_val(struct tracing_map_elt *elt,\n\t\t\t    struct action_data *data,\n\t\t\t    u64 var_val)\n{\n\tstruct hist_trigger_data *hist_data;\n\tu64 track_val;\n\n\thist_data = data->track_data.track_var->hist_data;\n\ttrack_val = get_track_val(hist_data, elt, data);\n\n\treturn data->track_data.check_val(track_val, var_val);\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);\n\nstatic bool check_track_val(struct tracing_map_elt *elt,\n\t\t\t    struct action_data *data,\n\t\t\t    u64 var_val)\n{\n\tstruct hist_trigger_data *hist_data;\n\tu64 track_val;\n\n\thist_data = data->track_data.track_var->hist_data;\n\ttrack_val = get_track_val(hist_data, elt, data);\n\n\treturn data->track_data.check_val(track_val, var_val);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);\n\nstatic void ontrack_action(struct hist_trigger_data *hist_data,\n\t\t\t   struct tracing_map_elt *elt,\n\t\t\t   struct trace_buffer *buffer, void *rec,\n\t\t\t   struct ring_buffer_event *rbe, void *key,\n\t\t\t   struct action_data *data, u64 *var_ref_vals)\n{\n\tu64 var_val = var_ref_vals[data->track_data.var_ref->var_ref_idx];\n\n\tif (check_track_val(elt, data, var_val)) {\n\t\tsave_track_val(hist_data, elt, data, var_val);\n\t\tsave_track_data(hist_data, elt, buffer, rec, rbe,\n\t\t\t\tkey, data, var_ref_vals);\n\t}\n}"
  },
  {
    "function_name": "track_data_print",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
    "lines": "3387-3418",
    "snippet": "static void track_data_print(struct seq_file *m,\n\t\t\t     struct hist_trigger_data *hist_data,\n\t\t\t     struct tracing_map_elt *elt,\n\t\t\t     struct action_data *data)\n{\n\tu64 track_val = get_track_val(hist_data, elt, data);\n\tunsigned int i, save_var_idx;\n\n\tif (data->handler == HANDLER_ONMAX)\n\t\tseq_printf(m, \"\\n\\tmax: %10llu\", track_val);\n\telse if (data->handler == HANDLER_ONCHANGE)\n\t\tseq_printf(m, \"\\n\\tchanged: %10llu\", track_val);\n\n\tif (data->action == ACTION_SNAPSHOT)\n\t\treturn;\n\n\tfor (i = 0; i < hist_data->n_save_vars; i++) {\n\t\tstruct hist_field *save_val = hist_data->save_vars[i]->val;\n\t\tstruct hist_field *save_var = hist_data->save_vars[i]->var;\n\t\tu64 val;\n\n\t\tsave_var_idx = save_var->var.idx;\n\n\t\tval = tracing_map_read_var(elt, save_var_idx);\n\n\t\tif (save_val->flags & HIST_FIELD_FL_STRING) {\n\t\t\tseq_printf(m, \"  %s: %-32s\", save_var->var.name,\n\t\t\t\t   (char *)(uintptr_t)(val));\n\t\t} else\n\t\t\tseq_printf(m, \"  %s: %10llu\", save_var->var.name, val);\n\t}\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include \"tracing_map.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"  %s: %10llu\"",
            "save_var->var.name",
            "val"
          ],
          "line": 3416
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "81-100",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracing_map_read_var",
          "args": [
            "elt",
            "save_var_idx"
          ],
          "line": 3410
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_map_read_var_once",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/tracing_map.c",
          "lines": "122-126",
          "snippet": "u64 tracing_map_read_var_once(struct tracing_map_elt *elt, unsigned int i)\n{\n\telt->var_set[i] = false;\n\treturn (u64)atomic64_read(&elt->vars[i]);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/kmemleak.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/jhash.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/kmemleak.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <linux/vmalloc.h>\n\nu64 tracing_map_read_var_once(struct tracing_map_elt *elt, unsigned int i)\n{\n\telt->var_set[i] = false;\n\treturn (u64)atomic64_read(&elt->vars[i]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_track_val",
          "args": [
            "hist_data",
            "elt",
            "data"
          ],
          "line": 3392
        },
        "resolved": true,
        "details": {
          "function_name": "get_track_val",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "3228-3238",
          "snippet": "static u64 get_track_val(struct hist_trigger_data *hist_data,\n\t\t\t struct tracing_map_elt *elt,\n\t\t\t struct action_data *data)\n{\n\tunsigned int track_var_idx = data->track_data.track_var->var.idx;\n\tu64 track_val;\n\n\ttrack_val = tracing_map_read_var(elt, track_var_idx);\n\n\treturn track_val;\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);\n\nstatic u64 get_track_val(struct hist_trigger_data *hist_data,\n\t\t\t struct tracing_map_elt *elt,\n\t\t\t struct action_data *data)\n{\n\tunsigned int track_var_idx = data->track_data.track_var->var.idx;\n\tu64 track_val;\n\n\ttrack_val = tracing_map_read_var(elt, track_var_idx);\n\n\treturn track_val;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);\n\nstatic void track_data_print(struct seq_file *m,\n\t\t\t     struct hist_trigger_data *hist_data,\n\t\t\t     struct tracing_map_elt *elt,\n\t\t\t     struct action_data *data)\n{\n\tu64 track_val = get_track_val(hist_data, elt, data);\n\tunsigned int i, save_var_idx;\n\n\tif (data->handler == HANDLER_ONMAX)\n\t\tseq_printf(m, \"\\n\\tmax: %10llu\", track_val);\n\telse if (data->handler == HANDLER_ONCHANGE)\n\t\tseq_printf(m, \"\\n\\tchanged: %10llu\", track_val);\n\n\tif (data->action == ACTION_SNAPSHOT)\n\t\treturn;\n\n\tfor (i = 0; i < hist_data->n_save_vars; i++) {\n\t\tstruct hist_field *save_val = hist_data->save_vars[i]->val;\n\t\tstruct hist_field *save_var = hist_data->save_vars[i]->var;\n\t\tu64 val;\n\n\t\tsave_var_idx = save_var->var.idx;\n\n\t\tval = tracing_map_read_var(elt, save_var_idx);\n\n\t\tif (save_val->flags & HIST_FIELD_FL_STRING) {\n\t\t\tseq_printf(m, \"  %s: %-32s\", save_var->var.name,\n\t\t\t\t   (char *)(uintptr_t)(val));\n\t\t} else\n\t\t\tseq_printf(m, \"  %s: %10llu\", save_var->var.name, val);\n\t}\n}"
  },
  {
    "function_name": "track_data_snapshot_print",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
    "lines": "3383-3384",
    "snippet": "static void track_data_snapshot_print(struct seq_file *m,\n\t\t\t\t      struct hist_trigger_data *hist_data) {}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include \"tracing_map.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void track_data_snapshot_print(struct seq_file *m,\n\t\t\t\t      struct hist_trigger_data *hist_data) {}"
  },
  {
    "function_name": "save_track_data_snapshot",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
    "lines": "3377-3382",
    "snippet": "static void save_track_data_snapshot(struct hist_trigger_data *hist_data,\n\t\t\t\t     struct tracing_map_elt *elt,\n\t\t\t\t     struct trace_buffer *buffer, void *rec,\n\t\t\t\t     struct ring_buffer_event *rbe, void *key,\n\t\t\t\t     struct action_data *data,\n\t\t\t\t     u64 *var_ref_vals) {}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include \"tracing_map.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);\n\nstatic void save_track_data_snapshot(struct hist_trigger_data *hist_data,\n\t\t\t\t     struct tracing_map_elt *elt,\n\t\t\t\t     struct trace_buffer *buffer, void *rec,\n\t\t\t\t     struct ring_buffer_event *rbe, void *key,\n\t\t\t\t     struct action_data *data,\n\t\t\t\t     u64 *var_ref_vals) {}"
  },
  {
    "function_name": "cond_snapshot_update",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
    "lines": "3373-3376",
    "snippet": "static bool cond_snapshot_update(struct trace_array *tr, void *cond_data)\n{\n\treturn false;\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include \"tracing_map.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic bool cond_snapshot_update(struct trace_array *tr, void *cond_data)\n{\n\treturn false;\n}"
  },
  {
    "function_name": "track_data_snapshot_print",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
    "lines": "3345-3371",
    "snippet": "static void track_data_snapshot_print(struct seq_file *m,\n\t\t\t\t      struct hist_trigger_data *hist_data)\n{\n\tstruct trace_event_file *file = hist_data->event_file;\n\tstruct track_data *track_data;\n\tstruct action_data *action;\n\n\ttrack_data = tracing_cond_snapshot_data(file->tr);\n\tif (!track_data)\n\t\treturn;\n\n\tif (!track_data->updated)\n\t\treturn;\n\n\taction = snapshot_action(hist_data);\n\tif (!action)\n\t\treturn;\n\n\tseq_puts(m, \"\\nSnapshot taken (see tracing/snapshot).  Details:\\n\");\n\tseq_printf(m, \"\\ttriggering value { %s(%s) }: %10llu\",\n\t\t   action->handler == HANDLER_ONMAX ? \"onmax\" : \"onchange\",\n\t\t   action->track_data.var_str, track_data->track_val);\n\n\tseq_puts(m, \"\\ttriggered by event with key: \");\n\thist_trigger_print_key(m, hist_data, track_data->key, &track_data->elt);\n\tseq_putc(m, '\\n');\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include \"tracing_map.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_putc",
          "args": [
            "m",
            "'\\n'"
          ],
          "line": 3370
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_putc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "233-246",
          "snippet": "void trace_seq_putc(struct trace_seq *s, unsigned char c)\n{\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (TRACE_SEQ_BUF_LEFT(s) < 1) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putc(&s->seq, c);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_putc(struct trace_seq *s, unsigned char c)\n{\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (TRACE_SEQ_BUF_LEFT(s) < 1) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putc(&s->seq, c);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hist_trigger_print_key",
          "args": [
            "m",
            "hist_data",
            "track_data->key",
            "&track_data->elt"
          ],
          "line": 3369
        },
        "resolved": true,
        "details": {
          "function_name": "hist_trigger_print_key",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "5082-5163",
          "snippet": "static void hist_trigger_print_key(struct seq_file *m,\n\t\t\t\t   struct hist_trigger_data *hist_data,\n\t\t\t\t   void *key,\n\t\t\t\t   struct tracing_map_elt *elt)\n{\n\tstruct hist_field *key_field;\n\tbool multiline = false;\n\tconst char *field_name;\n\tunsigned int i;\n\tu64 uval;\n\n\tseq_puts(m, \"{ \");\n\n\tfor_each_hist_key_field(i, hist_data) {\n\t\tkey_field = hist_data->fields[i];\n\n\t\tif (i > hist_data->n_vals)\n\t\t\tseq_puts(m, \", \");\n\n\t\tfield_name = hist_field_name(key_field, 0);\n\n\t\tif (key_field->flags & HIST_FIELD_FL_HEX) {\n\t\t\tuval = *(u64 *)(key + key_field->offset);\n\t\t\tseq_printf(m, \"%s: %llx\", field_name, uval);\n\t\t} else if (key_field->flags & HIST_FIELD_FL_SYM) {\n\t\t\tuval = *(u64 *)(key + key_field->offset);\n\t\t\tseq_printf(m, \"%s: [%llx] %-45ps\", field_name,\n\t\t\t\t   uval, (void *)(uintptr_t)uval);\n\t\t} else if (key_field->flags & HIST_FIELD_FL_SYM_OFFSET) {\n\t\t\tuval = *(u64 *)(key + key_field->offset);\n\t\t\tseq_printf(m, \"%s: [%llx] %-55pS\", field_name,\n\t\t\t\t   uval, (void *)(uintptr_t)uval);\n\t\t} else if (key_field->flags & HIST_FIELD_FL_EXECNAME) {\n\t\t\tstruct hist_elt_data *elt_data = elt->private_data;\n\t\t\tchar *comm;\n\n\t\t\tif (WARN_ON_ONCE(!elt_data))\n\t\t\t\treturn;\n\n\t\t\tcomm = elt_data->comm;\n\n\t\t\tuval = *(u64 *)(key + key_field->offset);\n\t\t\tseq_printf(m, \"%s: %-16s[%10llu]\", field_name,\n\t\t\t\t   comm, uval);\n\t\t} else if (key_field->flags & HIST_FIELD_FL_SYSCALL) {\n\t\t\tconst char *syscall_name;\n\n\t\t\tuval = *(u64 *)(key + key_field->offset);\n\t\t\tsyscall_name = get_syscall_name(uval);\n\t\t\tif (!syscall_name)\n\t\t\t\tsyscall_name = \"unknown_syscall\";\n\n\t\t\tseq_printf(m, \"%s: %-30s[%3llu]\", field_name,\n\t\t\t\t   syscall_name, uval);\n\t\t} else if (key_field->flags & HIST_FIELD_FL_STACKTRACE) {\n\t\t\tseq_puts(m, \"stacktrace:\\n\");\n\t\t\thist_trigger_stacktrace_print(m,\n\t\t\t\t\t\t      key + key_field->offset,\n\t\t\t\t\t\t      HIST_STACKTRACE_DEPTH);\n\t\t\tmultiline = true;\n\t\t} else if (key_field->flags & HIST_FIELD_FL_LOG2) {\n\t\t\tseq_printf(m, \"%s: ~ 2^%-2llu\", field_name,\n\t\t\t\t   *(u64 *)(key + key_field->offset));\n\t\t} else if (key_field->flags & HIST_FIELD_FL_BUCKET) {\n\t\t\tunsigned long buckets = key_field->buckets;\n\t\t\tuval = *(u64 *)(key + key_field->offset);\n\t\t\tseq_printf(m, \"%s: ~ %llu-%llu\", field_name,\n\t\t\t\t   uval, uval + buckets -1);\n\t\t} else if (key_field->flags & HIST_FIELD_FL_STRING) {\n\t\t\tseq_printf(m, \"%s: %-50s\", field_name,\n\t\t\t\t   (char *)(key + key_field->offset));\n\t\t} else {\n\t\t\tuval = *(u64 *)(key + key_field->offset);\n\t\t\tseq_printf(m, \"%s: %10llu\", field_name, uval);\n\t\t}\n\t}\n\n\tif (!multiline)\n\t\tseq_puts(m, \" \");\n\n\tseq_puts(m, \"}\");\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define HIST_STACKTRACE_DEPTH\t16"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\n#define HIST_STACKTRACE_DEPTH\t16\n\nstatic void hist_trigger_print_key(struct seq_file *m,\n\t\t\t\t   struct hist_trigger_data *hist_data,\n\t\t\t\t   void *key,\n\t\t\t\t   struct tracing_map_elt *elt)\n{\n\tstruct hist_field *key_field;\n\tbool multiline = false;\n\tconst char *field_name;\n\tunsigned int i;\n\tu64 uval;\n\n\tseq_puts(m, \"{ \");\n\n\tfor_each_hist_key_field(i, hist_data) {\n\t\tkey_field = hist_data->fields[i];\n\n\t\tif (i > hist_data->n_vals)\n\t\t\tseq_puts(m, \", \");\n\n\t\tfield_name = hist_field_name(key_field, 0);\n\n\t\tif (key_field->flags & HIST_FIELD_FL_HEX) {\n\t\t\tuval = *(u64 *)(key + key_field->offset);\n\t\t\tseq_printf(m, \"%s: %llx\", field_name, uval);\n\t\t} else if (key_field->flags & HIST_FIELD_FL_SYM) {\n\t\t\tuval = *(u64 *)(key + key_field->offset);\n\t\t\tseq_printf(m, \"%s: [%llx] %-45ps\", field_name,\n\t\t\t\t   uval, (void *)(uintptr_t)uval);\n\t\t} else if (key_field->flags & HIST_FIELD_FL_SYM_OFFSET) {\n\t\t\tuval = *(u64 *)(key + key_field->offset);\n\t\t\tseq_printf(m, \"%s: [%llx] %-55pS\", field_name,\n\t\t\t\t   uval, (void *)(uintptr_t)uval);\n\t\t} else if (key_field->flags & HIST_FIELD_FL_EXECNAME) {\n\t\t\tstruct hist_elt_data *elt_data = elt->private_data;\n\t\t\tchar *comm;\n\n\t\t\tif (WARN_ON_ONCE(!elt_data))\n\t\t\t\treturn;\n\n\t\t\tcomm = elt_data->comm;\n\n\t\t\tuval = *(u64 *)(key + key_field->offset);\n\t\t\tseq_printf(m, \"%s: %-16s[%10llu]\", field_name,\n\t\t\t\t   comm, uval);\n\t\t} else if (key_field->flags & HIST_FIELD_FL_SYSCALL) {\n\t\t\tconst char *syscall_name;\n\n\t\t\tuval = *(u64 *)(key + key_field->offset);\n\t\t\tsyscall_name = get_syscall_name(uval);\n\t\t\tif (!syscall_name)\n\t\t\t\tsyscall_name = \"unknown_syscall\";\n\n\t\t\tseq_printf(m, \"%s: %-30s[%3llu]\", field_name,\n\t\t\t\t   syscall_name, uval);\n\t\t} else if (key_field->flags & HIST_FIELD_FL_STACKTRACE) {\n\t\t\tseq_puts(m, \"stacktrace:\\n\");\n\t\t\thist_trigger_stacktrace_print(m,\n\t\t\t\t\t\t      key + key_field->offset,\n\t\t\t\t\t\t      HIST_STACKTRACE_DEPTH);\n\t\t\tmultiline = true;\n\t\t} else if (key_field->flags & HIST_FIELD_FL_LOG2) {\n\t\t\tseq_printf(m, \"%s: ~ 2^%-2llu\", field_name,\n\t\t\t\t   *(u64 *)(key + key_field->offset));\n\t\t} else if (key_field->flags & HIST_FIELD_FL_BUCKET) {\n\t\t\tunsigned long buckets = key_field->buckets;\n\t\t\tuval = *(u64 *)(key + key_field->offset);\n\t\t\tseq_printf(m, \"%s: ~ %llu-%llu\", field_name,\n\t\t\t\t   uval, uval + buckets -1);\n\t\t} else if (key_field->flags & HIST_FIELD_FL_STRING) {\n\t\t\tseq_printf(m, \"%s: %-50s\", field_name,\n\t\t\t\t   (char *)(key + key_field->offset));\n\t\t} else {\n\t\t\tuval = *(u64 *)(key + key_field->offset);\n\t\t\tseq_printf(m, \"%s: %10llu\", field_name, uval);\n\t\t}\n\t}\n\n\tif (!multiline)\n\t\tseq_puts(m, \" \");\n\n\tseq_puts(m, \"}\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "m",
            "\"\\ttriggered by event with key: \""
          ],
          "line": 3368
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_puts",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "205-220",
          "snippet": "void trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"\\ttriggering value { %s(%s) }: %10llu\"",
            "action->handler == HANDLER_ONMAX ? \"onmax\" : \"onchange\"",
            "action->track_data.var_str",
            "track_data->track_val"
          ],
          "line": 3364
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "81-100",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "snapshot_action",
          "args": [
            "hist_data"
          ],
          "line": 3359
        },
        "resolved": true,
        "details": {
          "function_name": "snapshot_action",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "3328-3343",
          "snippet": "static struct action_data *snapshot_action(struct hist_trigger_data *hist_data)\n{\n\tunsigned int i;\n\n\tif (!hist_data->n_actions)\n\t\treturn NULL;\n\n\tfor (i = 0; i < hist_data->n_actions; i++) {\n\t\tstruct action_data *data = hist_data->actions[i];\n\n\t\tif (data->action == ACTION_SNAPSHOT)\n\t\t\treturn data;\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);\n\nstatic struct action_data *snapshot_action(struct hist_trigger_data *hist_data)\n{\n\tunsigned int i;\n\n\tif (!hist_data->n_actions)\n\t\treturn NULL;\n\n\tfor (i = 0; i < hist_data->n_actions; i++) {\n\t\tstruct action_data *data = hist_data->actions[i];\n\n\t\tif (data->action == ACTION_SNAPSHOT)\n\t\t\treturn data;\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracing_cond_snapshot_data",
          "args": [
            "file->tr"
          ],
          "line": 3352
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_cond_snapshot_data",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "1387-1390",
          "snippet": "void *tracing_cond_snapshot_data(struct trace_array *tr)\n{\n\treturn NULL;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nvoid *tracing_cond_snapshot_data(struct trace_array *tr)\n{\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void track_data_snapshot_print(struct seq_file *m,\n\t\t\t\t      struct hist_trigger_data *hist_data)\n{\n\tstruct trace_event_file *file = hist_data->event_file;\n\tstruct track_data *track_data;\n\tstruct action_data *action;\n\n\ttrack_data = tracing_cond_snapshot_data(file->tr);\n\tif (!track_data)\n\t\treturn;\n\n\tif (!track_data->updated)\n\t\treturn;\n\n\taction = snapshot_action(hist_data);\n\tif (!action)\n\t\treturn;\n\n\tseq_puts(m, \"\\nSnapshot taken (see tracing/snapshot).  Details:\\n\");\n\tseq_printf(m, \"\\ttriggering value { %s(%s) }: %10llu\",\n\t\t   action->handler == HANDLER_ONMAX ? \"onmax\" : \"onchange\",\n\t\t   action->track_data.var_str, track_data->track_val);\n\n\tseq_puts(m, \"\\ttriggered by event with key: \");\n\thist_trigger_print_key(m, hist_data, track_data->key, &track_data->elt);\n\tseq_putc(m, '\\n');\n}"
  },
  {
    "function_name": "snapshot_action",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
    "lines": "3328-3343",
    "snippet": "static struct action_data *snapshot_action(struct hist_trigger_data *hist_data)\n{\n\tunsigned int i;\n\n\tif (!hist_data->n_actions)\n\t\treturn NULL;\n\n\tfor (i = 0; i < hist_data->n_actions; i++) {\n\t\tstruct action_data *data = hist_data->actions[i];\n\n\t\tif (data->action == ACTION_SNAPSHOT)\n\t\t\treturn data;\n\t}\n\n\treturn NULL;\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include \"tracing_map.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);\n\nstatic struct action_data *snapshot_action(struct hist_trigger_data *hist_data)\n{\n\tunsigned int i;\n\n\tif (!hist_data->n_actions)\n\t\treturn NULL;\n\n\tfor (i = 0; i < hist_data->n_actions; i++) {\n\t\tstruct action_data *data = hist_data->actions[i];\n\n\t\tif (data->action == ACTION_SNAPSHOT)\n\t\t\treturn data;\n\t}\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "save_track_data_snapshot",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
    "lines": "3307-3321",
    "snippet": "static void save_track_data_snapshot(struct hist_trigger_data *hist_data,\n\t\t\t\t     struct tracing_map_elt *elt,\n\t\t\t\t     struct trace_buffer *buffer, void *rec,\n\t\t\t\t     struct ring_buffer_event *rbe, void *key,\n\t\t\t\t     struct action_data *data,\n\t\t\t\t     u64 *var_ref_vals)\n{\n\tstruct trace_event_file *file = hist_data->event_file;\n\tstruct snapshot_context context;\n\n\tcontext.elt = elt;\n\tcontext.key = key;\n\n\ttracing_snapshot_cond(file->tr, &context);\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include \"tracing_map.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tracing_snapshot_cond",
          "args": [
            "file->tr",
            "&context"
          ],
          "line": 3320
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_snapshot_cond",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "1370-1373",
          "snippet": "void tracing_snapshot_cond(struct trace_array *tr, void *cond_data)\n{\n\tWARN_ONCE(1, \"Snapshot feature not enabled, but internal conditional snapshot used\");\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nvoid tracing_snapshot_cond(struct trace_array *tr, void *cond_data)\n{\n\tWARN_ONCE(1, \"Snapshot feature not enabled, but internal conditional snapshot used\");\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);\n\nstatic void save_track_data_snapshot(struct hist_trigger_data *hist_data,\n\t\t\t\t     struct tracing_map_elt *elt,\n\t\t\t\t     struct trace_buffer *buffer, void *rec,\n\t\t\t\t     struct ring_buffer_event *rbe, void *key,\n\t\t\t\t     struct action_data *data,\n\t\t\t\t     u64 *var_ref_vals)\n{\n\tstruct trace_event_file *file = hist_data->event_file;\n\tstruct snapshot_context context;\n\n\tcontext.elt = elt;\n\tcontext.key = key;\n\n\ttracing_snapshot_cond(file->tr, &context);\n}"
  },
  {
    "function_name": "cond_snapshot_update",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
    "lines": "3274-3305",
    "snippet": "static bool cond_snapshot_update(struct trace_array *tr, void *cond_data)\n{\n\t/* called with tr->max_lock held */\n\tstruct track_data *track_data = tr->cond_snapshot->cond_data;\n\tstruct hist_elt_data *elt_data, *track_elt_data;\n\tstruct snapshot_context *context = cond_data;\n\tstruct action_data *action;\n\tu64 track_val;\n\n\tif (!track_data)\n\t\treturn false;\n\n\taction = track_data->action_data;\n\n\ttrack_val = get_track_val(track_data->hist_data, context->elt,\n\t\t\t\t  track_data->action_data);\n\n\tif (!action->track_data.check_val(track_data->track_val, track_val))\n\t\treturn false;\n\n\ttrack_data->track_val = track_val;\n\tmemcpy(track_data->key, context->key, track_data->key_len);\n\n\telt_data = context->elt->private_data;\n\ttrack_elt_data = track_data->elt.private_data;\n\tif (elt_data->comm)\n\t\tstrncpy(track_elt_data->comm, elt_data->comm, TASK_COMM_LEN);\n\n\ttrack_data->updated = true;\n\n\treturn true;\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include \"tracing_map.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "track_elt_data->comm",
            "elt_data->comm",
            "TASK_COMM_LEN"
          ],
          "line": 3300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "track_data->key",
            "context->key",
            "track_data->key_len"
          ],
          "line": 3295
        },
        "resolved": true,
        "details": {
          "function_name": "memcpy_skip",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/internal.h",
          "lines": "180-184",
          "snippet": "static inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/refcount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/refcount.h>\n#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n\nstatic inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "action->track_data.check_val",
          "args": [
            "track_data->track_val",
            "track_val"
          ],
          "line": 3291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_track_val",
          "args": [
            "track_data->hist_data",
            "context->elt",
            "track_data->action_data"
          ],
          "line": 3288
        },
        "resolved": true,
        "details": {
          "function_name": "get_track_val",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "3228-3238",
          "snippet": "static u64 get_track_val(struct hist_trigger_data *hist_data,\n\t\t\t struct tracing_map_elt *elt,\n\t\t\t struct action_data *data)\n{\n\tunsigned int track_var_idx = data->track_data.track_var->var.idx;\n\tu64 track_val;\n\n\ttrack_val = tracing_map_read_var(elt, track_var_idx);\n\n\treturn track_val;\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);\n\nstatic u64 get_track_val(struct hist_trigger_data *hist_data,\n\t\t\t struct tracing_map_elt *elt,\n\t\t\t struct action_data *data)\n{\n\tunsigned int track_var_idx = data->track_data.track_var->var.idx;\n\tu64 track_val;\n\n\ttrack_val = tracing_map_read_var(elt, track_var_idx);\n\n\treturn track_val;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic bool cond_snapshot_update(struct trace_array *tr, void *cond_data)\n{\n\t/* called with tr->max_lock held */\n\tstruct track_data *track_data = tr->cond_snapshot->cond_data;\n\tstruct hist_elt_data *elt_data, *track_elt_data;\n\tstruct snapshot_context *context = cond_data;\n\tstruct action_data *action;\n\tu64 track_val;\n\n\tif (!track_data)\n\t\treturn false;\n\n\taction = track_data->action_data;\n\n\ttrack_val = get_track_val(track_data->hist_data, context->elt,\n\t\t\t\t  track_data->action_data);\n\n\tif (!action->track_data.check_val(track_data->track_val, track_val))\n\t\treturn false;\n\n\ttrack_data->track_val = track_val;\n\tmemcpy(track_data->key, context->key, track_data->key_len);\n\n\telt_data = context->elt->private_data;\n\ttrack_elt_data = track_data->elt.private_data;\n\tif (elt_data->comm)\n\t\tstrncpy(track_elt_data->comm, elt_data->comm, TASK_COMM_LEN);\n\n\ttrack_data->updated = true;\n\n\treturn true;\n}"
  },
  {
    "function_name": "check_track_val",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
    "lines": "3260-3271",
    "snippet": "static bool check_track_val(struct tracing_map_elt *elt,\n\t\t\t    struct action_data *data,\n\t\t\t    u64 var_val)\n{\n\tstruct hist_trigger_data *hist_data;\n\tu64 track_val;\n\n\thist_data = data->track_data.track_var->hist_data;\n\ttrack_val = get_track_val(hist_data, elt, data);\n\n\treturn data->track_data.check_val(track_val, var_val);\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include \"tracing_map.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "data->track_data.check_val",
          "args": [
            "track_val",
            "var_val"
          ],
          "line": 3270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_track_val",
          "args": [
            "hist_data",
            "elt",
            "data"
          ],
          "line": 3268
        },
        "resolved": true,
        "details": {
          "function_name": "get_track_val",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "3228-3238",
          "snippet": "static u64 get_track_val(struct hist_trigger_data *hist_data,\n\t\t\t struct tracing_map_elt *elt,\n\t\t\t struct action_data *data)\n{\n\tunsigned int track_var_idx = data->track_data.track_var->var.idx;\n\tu64 track_val;\n\n\ttrack_val = tracing_map_read_var(elt, track_var_idx);\n\n\treturn track_val;\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);\n\nstatic u64 get_track_val(struct hist_trigger_data *hist_data,\n\t\t\t struct tracing_map_elt *elt,\n\t\t\t struct action_data *data)\n{\n\tunsigned int track_var_idx = data->track_data.track_var->var.idx;\n\tu64 track_val;\n\n\ttrack_val = tracing_map_read_var(elt, track_var_idx);\n\n\treturn track_val;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);\n\nstatic bool check_track_val(struct tracing_map_elt *elt,\n\t\t\t    struct action_data *data,\n\t\t\t    u64 var_val)\n{\n\tstruct hist_trigger_data *hist_data;\n\tu64 track_val;\n\n\thist_data = data->track_data.track_var->hist_data;\n\ttrack_val = get_track_val(hist_data, elt, data);\n\n\treturn data->track_data.check_val(track_val, var_val);\n}"
  },
  {
    "function_name": "save_track_data",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
    "lines": "3249-3258",
    "snippet": "static void save_track_data(struct hist_trigger_data *hist_data,\n\t\t\t    struct tracing_map_elt *elt,\n\t\t\t    struct trace_buffer *buffer, void *rec,\n\t\t\t    struct ring_buffer_event *rbe, void *key,\n\t\t\t    struct action_data *data, u64 *var_ref_vals)\n{\n\tif (data->track_data.save_data)\n\t\tdata->track_data.save_data(hist_data, elt, buffer, rec, rbe,\n\t\t\t\t\t   key, data, var_ref_vals);\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include \"tracing_map.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "data->track_data.save_data",
          "args": [
            "hist_data",
            "elt",
            "buffer",
            "rec",
            "rbe",
            "key",
            "data",
            "var_ref_vals"
          ],
          "line": 3256
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);\n\nstatic void save_track_data(struct hist_trigger_data *hist_data,\n\t\t\t    struct tracing_map_elt *elt,\n\t\t\t    struct trace_buffer *buffer, void *rec,\n\t\t\t    struct ring_buffer_event *rbe, void *key,\n\t\t\t    struct action_data *data, u64 *var_ref_vals)\n{\n\tif (data->track_data.save_data)\n\t\tdata->track_data.save_data(hist_data, elt, buffer, rec, rbe,\n\t\t\t\t\t   key, data, var_ref_vals);\n}"
  },
  {
    "function_name": "save_track_val",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
    "lines": "3240-3247",
    "snippet": "static void save_track_val(struct hist_trigger_data *hist_data,\n\t\t\t   struct tracing_map_elt *elt,\n\t\t\t   struct action_data *data, u64 var_val)\n{\n\tunsigned int track_var_idx = data->track_data.track_var->var.idx;\n\n\ttracing_map_set_var(elt, track_var_idx, var_val);\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include \"tracing_map.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tracing_map_set_var",
          "args": [
            "elt",
            "track_var_idx",
            "var_val"
          ],
          "line": 3246
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_map_set_var",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/tracing_map.c",
          "lines": "71-75",
          "snippet": "void tracing_map_set_var(struct tracing_map_elt *elt, unsigned int i, u64 n)\n{\n\tatomic64_set(&elt->vars[i], n);\n\telt->var_set[i] = true;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/kmemleak.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/jhash.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/kmemleak.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <linux/vmalloc.h>\n\nvoid tracing_map_set_var(struct tracing_map_elt *elt, unsigned int i, u64 n)\n{\n\tatomic64_set(&elt->vars[i], n);\n\telt->var_set[i] = true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);\n\nstatic void save_track_val(struct hist_trigger_data *hist_data,\n\t\t\t   struct tracing_map_elt *elt,\n\t\t\t   struct action_data *data, u64 var_val)\n{\n\tunsigned int track_var_idx = data->track_data.track_var->var.idx;\n\n\ttracing_map_set_var(elt, track_var_idx, var_val);\n}"
  },
  {
    "function_name": "get_track_val",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
    "lines": "3228-3238",
    "snippet": "static u64 get_track_val(struct hist_trigger_data *hist_data,\n\t\t\t struct tracing_map_elt *elt,\n\t\t\t struct action_data *data)\n{\n\tunsigned int track_var_idx = data->track_data.track_var->var.idx;\n\tu64 track_val;\n\n\ttrack_val = tracing_map_read_var(elt, track_var_idx);\n\n\treturn track_val;\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include \"tracing_map.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tracing_map_read_var",
          "args": [
            "elt",
            "track_var_idx"
          ],
          "line": 3235
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_map_read_var_once",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/tracing_map.c",
          "lines": "122-126",
          "snippet": "u64 tracing_map_read_var_once(struct tracing_map_elt *elt, unsigned int i)\n{\n\telt->var_set[i] = false;\n\treturn (u64)atomic64_read(&elt->vars[i]);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/kmemleak.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/jhash.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/kmemleak.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <linux/vmalloc.h>\n\nu64 tracing_map_read_var_once(struct tracing_map_elt *elt, unsigned int i)\n{\n\telt->var_set[i] = false;\n\treturn (u64)atomic64_read(&elt->vars[i]);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);\n\nstatic u64 get_track_val(struct hist_trigger_data *hist_data,\n\t\t\t struct tracing_map_elt *elt,\n\t\t\t struct action_data *data)\n{\n\tunsigned int track_var_idx = data->track_data.track_var->var.idx;\n\tu64 track_val;\n\n\ttrack_val = tracing_map_read_var(elt, track_var_idx);\n\n\treturn track_val;\n}"
  },
  {
    "function_name": "check_track_val_changed",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
    "lines": "3220-3226",
    "snippet": "static bool check_track_val_changed(u64 track_val, u64 var_val)\n{\n\tif (var_val == track_val)\n\t\treturn false;\n\n\treturn true;\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include \"tracing_map.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic bool check_track_val_changed(u64 track_val, u64 var_val)\n{\n\tif (var_val == track_val)\n\t\treturn false;\n\n\treturn true;\n}"
  },
  {
    "function_name": "check_track_val_max",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
    "lines": "3212-3218",
    "snippet": "static bool check_track_val_max(u64 track_val, u64 var_val)\n{\n\tif (var_val <= track_val)\n\t\treturn false;\n\n\treturn true;\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include \"tracing_map.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic bool check_track_val_max(u64 track_val, u64 var_val)\n{\n\tif (var_val <= track_val)\n\t\treturn false;\n\n\treturn true;\n}"
  },
  {
    "function_name": "create_target_field_var",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
    "lines": "3188-3210",
    "snippet": "static struct field_var *\ncreate_target_field_var(struct hist_trigger_data *target_hist_data,\n\t\t\tchar *subsys_name, char *event_name, char *var_name)\n{\n\tstruct trace_event_file *file = target_hist_data->event_file;\n\n\tif (subsys_name) {\n\t\tstruct trace_event_call *call;\n\n\t\tif (!event_name)\n\t\t\treturn NULL;\n\n\t\tcall = file->event_call;\n\n\t\tif (strcmp(subsys_name, call->class->system) != 0)\n\t\t\treturn NULL;\n\n\t\tif (strcmp(event_name, trace_event_name(call)) != 0)\n\t\t\treturn NULL;\n\t}\n\n\treturn create_field_var(target_hist_data, file, var_name);\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include \"tracing_map.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "create_field_var",
          "args": [
            "target_hist_data",
            "file",
            "var_name"
          ],
          "line": 3209
        },
        "resolved": true,
        "details": {
          "function_name": "create_field_var",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "3120-3166",
          "snippet": "static struct field_var *create_field_var(struct hist_trigger_data *hist_data,\n\t\t\t\t\t  struct trace_event_file *file,\n\t\t\t\t\t  char *field_name)\n{\n\tstruct hist_field *val = NULL, *var = NULL;\n\tunsigned long flags = HIST_FIELD_FL_VAR;\n\tstruct trace_array *tr = file->tr;\n\tstruct field_var *field_var;\n\tint ret = 0;\n\n\tif (hist_data->n_field_vars >= SYNTH_FIELDS_MAX) {\n\t\thist_err(tr, HIST_ERR_TOO_MANY_FIELD_VARS, errpos(field_name));\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tval = parse_atom(hist_data, file, field_name, &flags, NULL);\n\tif (IS_ERR(val)) {\n\t\thist_err(tr, HIST_ERR_FIELD_VAR_PARSE_FAIL, errpos(field_name));\n\t\tret = PTR_ERR(val);\n\t\tgoto err;\n\t}\n\n\tvar = create_var(hist_data, file, field_name, val->size, val->type);\n\tif (IS_ERR(var)) {\n\t\thist_err(tr, HIST_ERR_VAR_CREATE_FIND_FAIL, errpos(field_name));\n\t\tkfree(val);\n\t\tret = PTR_ERR(var);\n\t\tgoto err;\n\t}\n\n\tfield_var = kzalloc(sizeof(struct field_var), GFP_KERNEL);\n\tif (!field_var) {\n\t\tkfree(val);\n\t\tkfree(var);\n\t\tret =  -ENOMEM;\n\t\tgoto err;\n\t}\n\n\tfield_var->var = var;\n\tfield_var->val = val;\n out:\n\treturn field_var;\n err:\n\tfield_var = ERR_PTR(ret);\n\tgoto out;\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct field_var *create_field_var(struct hist_trigger_data *hist_data,\n\t\t\t\t\t  struct trace_event_file *file,\n\t\t\t\t\t  char *field_name)\n{\n\tstruct hist_field *val = NULL, *var = NULL;\n\tunsigned long flags = HIST_FIELD_FL_VAR;\n\tstruct trace_array *tr = file->tr;\n\tstruct field_var *field_var;\n\tint ret = 0;\n\n\tif (hist_data->n_field_vars >= SYNTH_FIELDS_MAX) {\n\t\thist_err(tr, HIST_ERR_TOO_MANY_FIELD_VARS, errpos(field_name));\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tval = parse_atom(hist_data, file, field_name, &flags, NULL);\n\tif (IS_ERR(val)) {\n\t\thist_err(tr, HIST_ERR_FIELD_VAR_PARSE_FAIL, errpos(field_name));\n\t\tret = PTR_ERR(val);\n\t\tgoto err;\n\t}\n\n\tvar = create_var(hist_data, file, field_name, val->size, val->type);\n\tif (IS_ERR(var)) {\n\t\thist_err(tr, HIST_ERR_VAR_CREATE_FIND_FAIL, errpos(field_name));\n\t\tkfree(val);\n\t\tret = PTR_ERR(var);\n\t\tgoto err;\n\t}\n\n\tfield_var = kzalloc(sizeof(struct field_var), GFP_KERNEL);\n\tif (!field_var) {\n\t\tkfree(val);\n\t\tkfree(var);\n\t\tret =  -ENOMEM;\n\t\tgoto err;\n\t}\n\n\tfield_var->var = var;\n\tfield_var->val = val;\n out:\n\treturn field_var;\n err:\n\tfield_var = ERR_PTR(ret);\n\tgoto out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "event_name",
            "trace_event_name(call)"
          ],
          "line": 3205
        },
        "resolved": true,
        "details": {
          "function_name": "sym_strcmp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/report.c",
          "lines": "356-365",
          "snippet": "static int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}",
          "includes": [
            "#include \"encoding.h\"",
            "#include \"kcsan.h\"",
            "#include <linux/stacktrace.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/delay.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"encoding.h\"\n#include \"kcsan.h\"\n#include <linux/stacktrace.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/lockdep.h>\n#include <linux/kernel.h>\n#include <linux/kallsyms.h>\n#include <linux/jiffies.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n\nstatic int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_event_name",
          "args": [
            "call"
          ],
          "line": 3205
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct field_var *\ncreate_target_field_var(struct hist_trigger_data *target_hist_data,\n\t\t\tchar *subsys_name, char *event_name, char *var_name)\n{\n\tstruct trace_event_file *file = target_hist_data->event_file;\n\n\tif (subsys_name) {\n\t\tstruct trace_event_call *call;\n\n\t\tif (!event_name)\n\t\t\treturn NULL;\n\n\t\tcall = file->event_call;\n\n\t\tif (strcmp(subsys_name, call->class->system) != 0)\n\t\t\treturn NULL;\n\n\t\tif (strcmp(event_name, trace_event_name(call)) != 0)\n\t\t\treturn NULL;\n\t}\n\n\treturn create_field_var(target_hist_data, file, var_name);\n}"
  },
  {
    "function_name": "create_field_var",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
    "lines": "3120-3166",
    "snippet": "static struct field_var *create_field_var(struct hist_trigger_data *hist_data,\n\t\t\t\t\t  struct trace_event_file *file,\n\t\t\t\t\t  char *field_name)\n{\n\tstruct hist_field *val = NULL, *var = NULL;\n\tunsigned long flags = HIST_FIELD_FL_VAR;\n\tstruct trace_array *tr = file->tr;\n\tstruct field_var *field_var;\n\tint ret = 0;\n\n\tif (hist_data->n_field_vars >= SYNTH_FIELDS_MAX) {\n\t\thist_err(tr, HIST_ERR_TOO_MANY_FIELD_VARS, errpos(field_name));\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tval = parse_atom(hist_data, file, field_name, &flags, NULL);\n\tif (IS_ERR(val)) {\n\t\thist_err(tr, HIST_ERR_FIELD_VAR_PARSE_FAIL, errpos(field_name));\n\t\tret = PTR_ERR(val);\n\t\tgoto err;\n\t}\n\n\tvar = create_var(hist_data, file, field_name, val->size, val->type);\n\tif (IS_ERR(var)) {\n\t\thist_err(tr, HIST_ERR_VAR_CREATE_FIND_FAIL, errpos(field_name));\n\t\tkfree(val);\n\t\tret = PTR_ERR(var);\n\t\tgoto err;\n\t}\n\n\tfield_var = kzalloc(sizeof(struct field_var), GFP_KERNEL);\n\tif (!field_var) {\n\t\tkfree(val);\n\t\tkfree(var);\n\t\tret =  -ENOMEM;\n\t\tgoto err;\n\t}\n\n\tfield_var->var = var;\n\tfield_var->val = val;\n out:\n\treturn field_var;\n err:\n\tfield_var = ERR_PTR(ret);\n\tgoto out;\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include \"tracing_map.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "ret"
          ],
          "line": 3164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "var"
          ],
          "line": 3154
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct field_var)",
            "GFP_KERNEL"
          ],
          "line": 3151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "var"
          ],
          "line": 3147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hist_err",
          "args": [
            "tr",
            "HIST_ERR_VAR_CREATE_FIND_FAIL",
            "errpos(field_name)"
          ],
          "line": 3145
        },
        "resolved": true,
        "details": {
          "function_name": "hist_err",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "763-767",
          "snippet": "static void hist_err(struct trace_array *tr, u8 err_type, u8 err_pos)\n{\n\ttracing_log_err(tr, last_cmd_loc, last_cmd, err_text,\n\t\t\terr_type, err_pos);\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *err_text[] = { ERRORS };",
            "static char last_cmd[MAX_FILTER_STR_VAL];",
            "static char last_cmd_loc[MAX_FILTER_STR_VAL];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic const char *err_text[] = { ERRORS };\nstatic char last_cmd[MAX_FILTER_STR_VAL];\nstatic char last_cmd_loc[MAX_FILTER_STR_VAL];\n\nstatic void hist_err(struct trace_array *tr, u8 err_type, u8 err_pos)\n{\n\ttracing_log_err(tr, last_cmd_loc, last_cmd, err_text,\n\t\t\terr_type, err_pos);\n}"
        }
      },
      {
        "call_info": {
          "callee": "errpos",
          "args": [
            "field_name"
          ],
          "line": 3145
        },
        "resolved": true,
        "details": {
          "function_name": "errpos",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "733-736",
          "snippet": "static int errpos(char *str)\n{\n\treturn err_pos(last_cmd, str);\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char last_cmd[MAX_FILTER_STR_VAL];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic char last_cmd[MAX_FILTER_STR_VAL];\n\nstatic int errpos(char *str)\n{\n\treturn err_pos(last_cmd, str);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "var"
          ],
          "line": 3144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "create_var",
          "args": [
            "hist_data",
            "file",
            "field_name",
            "val->size",
            "val->type"
          ],
          "line": 3143
        },
        "resolved": true,
        "details": {
          "function_name": "create_var_field",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "4176-4207",
          "snippet": "static int create_var_field(struct hist_trigger_data *hist_data,\n\t\t\t    unsigned int val_idx,\n\t\t\t    struct trace_event_file *file,\n\t\t\t    char *var_name, char *expr_str)\n{\n\tstruct trace_array *tr = hist_data->event_file->tr;\n\tunsigned long flags = 0;\n\tint ret;\n\n\tif (WARN_ON(val_idx >= TRACING_MAP_VALS_MAX + TRACING_MAP_VARS_MAX))\n\t\treturn -EINVAL;\n\n\tif (find_var(hist_data, file, var_name) && !hist_data->remove) {\n\t\thist_err(tr, HIST_ERR_DUPLICATE_VAR, errpos(var_name));\n\t\treturn -EINVAL;\n\t}\n\n\tflags |= HIST_FIELD_FL_VAR;\n\thist_data->n_vars++;\n\tif (WARN_ON(hist_data->n_vars > TRACING_MAP_VARS_MAX))\n\t\treturn -EINVAL;\n\n\tret = __create_val_field(hist_data, val_idx, file, var_name, expr_str, flags);\n\n\tif (!ret && hist_data->fields[val_idx]->flags & HIST_FIELD_FL_EXECNAME)\n\t\tupdate_var_execname(hist_data->fields[val_idx]);\n\n\tif (!ret && hist_data->fields[val_idx]->flags & HIST_FIELD_FL_STRING)\n\t\thist_data->fields[val_idx]->var_str_idx = hist_data->n_var_str++;\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int create_var_field(struct hist_trigger_data *hist_data,\n\t\t\t    unsigned int val_idx,\n\t\t\t    struct trace_event_file *file,\n\t\t\t    char *var_name, char *expr_str)\n{\n\tstruct trace_array *tr = hist_data->event_file->tr;\n\tunsigned long flags = 0;\n\tint ret;\n\n\tif (WARN_ON(val_idx >= TRACING_MAP_VALS_MAX + TRACING_MAP_VARS_MAX))\n\t\treturn -EINVAL;\n\n\tif (find_var(hist_data, file, var_name) && !hist_data->remove) {\n\t\thist_err(tr, HIST_ERR_DUPLICATE_VAR, errpos(var_name));\n\t\treturn -EINVAL;\n\t}\n\n\tflags |= HIST_FIELD_FL_VAR;\n\thist_data->n_vars++;\n\tif (WARN_ON(hist_data->n_vars > TRACING_MAP_VARS_MAX))\n\t\treturn -EINVAL;\n\n\tret = __create_val_field(hist_data, val_idx, file, var_name, expr_str, flags);\n\n\tif (!ret && hist_data->fields[val_idx]->flags & HIST_FIELD_FL_EXECNAME)\n\t\tupdate_var_execname(hist_data->fields[val_idx]);\n\n\tif (!ret && hist_data->fields[val_idx]->flags & HIST_FIELD_FL_STRING)\n\t\thist_data->fields[val_idx]->var_str_idx = hist_data->n_var_str++;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "val"
          ],
          "line": 3139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "val"
          ],
          "line": 3137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parse_atom",
          "args": [
            "hist_data",
            "file",
            "field_name",
            "&flags",
            "NULL"
          ],
          "line": 3136
        },
        "resolved": true,
        "details": {
          "function_name": "parse_atom",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "2357-2427",
          "snippet": "static struct hist_field *parse_atom(struct hist_trigger_data *hist_data,\n\t\t\t\t     struct trace_event_file *file, char *str,\n\t\t\t\t     unsigned long *flags, char *var_name)\n{\n\tchar *s, *ref_system = NULL, *ref_event = NULL, *ref_var = str;\n\tstruct ftrace_event_field *field = NULL;\n\tstruct hist_field *hist_field = NULL;\n\tunsigned long buckets = 0;\n\tint ret = 0;\n\n\tif (isdigit(str[0])) {\n\t\thist_field = parse_const(hist_data, str, var_name, flags);\n\t\tif (!hist_field) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\treturn hist_field;\n\t}\n\n\ts = strchr(str, '.');\n\tif (s) {\n\t\ts = strchr(++s, '.');\n\t\tif (s) {\n\t\t\tref_system = strsep(&str, \".\");\n\t\t\tif (!str) {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tref_event = strsep(&str, \".\");\n\t\t\tif (!str) {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tref_var = str;\n\t\t}\n\t}\n\n\ts = local_field_var_ref(hist_data, ref_system, ref_event, ref_var);\n\tif (!s) {\n\t\thist_field = parse_var_ref(hist_data, ref_system,\n\t\t\t\t\t   ref_event, ref_var);\n\t\tif (hist_field) {\n\t\t\tif (var_name) {\n\t\t\t\thist_field = create_alias(hist_data, hist_field, var_name);\n\t\t\t\tif (!hist_field) {\n\t\t\t\t\tret = -ENOMEM;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn hist_field;\n\t\t}\n\t} else\n\t\tstr = s;\n\n\tfield = parse_field(hist_data, file, str, flags, &buckets);\n\tif (IS_ERR(field)) {\n\t\tret = PTR_ERR(field);\n\t\tgoto out;\n\t}\n\n\thist_field = create_hist_field(hist_data, field, *flags, var_name);\n\tif (!hist_field) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\thist_field->buckets = buckets;\n\n\treturn hist_field;\n out:\n\treturn ERR_PTR(ret);\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct hist_field *parse_atom(struct hist_trigger_data *hist_data,\n\t\t\t\t     struct trace_event_file *file, char *str,\n\t\t\t\t     unsigned long *flags, char *var_name)\n{\n\tchar *s, *ref_system = NULL, *ref_event = NULL, *ref_var = str;\n\tstruct ftrace_event_field *field = NULL;\n\tstruct hist_field *hist_field = NULL;\n\tunsigned long buckets = 0;\n\tint ret = 0;\n\n\tif (isdigit(str[0])) {\n\t\thist_field = parse_const(hist_data, str, var_name, flags);\n\t\tif (!hist_field) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\treturn hist_field;\n\t}\n\n\ts = strchr(str, '.');\n\tif (s) {\n\t\ts = strchr(++s, '.');\n\t\tif (s) {\n\t\t\tref_system = strsep(&str, \".\");\n\t\t\tif (!str) {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tref_event = strsep(&str, \".\");\n\t\t\tif (!str) {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tref_var = str;\n\t\t}\n\t}\n\n\ts = local_field_var_ref(hist_data, ref_system, ref_event, ref_var);\n\tif (!s) {\n\t\thist_field = parse_var_ref(hist_data, ref_system,\n\t\t\t\t\t   ref_event, ref_var);\n\t\tif (hist_field) {\n\t\t\tif (var_name) {\n\t\t\t\thist_field = create_alias(hist_data, hist_field, var_name);\n\t\t\t\tif (!hist_field) {\n\t\t\t\t\tret = -ENOMEM;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn hist_field;\n\t\t}\n\t} else\n\t\tstr = s;\n\n\tfield = parse_field(hist_data, file, str, flags, &buckets);\n\tif (IS_ERR(field)) {\n\t\tret = PTR_ERR(field);\n\t\tgoto out;\n\t}\n\n\thist_field = create_hist_field(hist_data, field, *flags, var_name);\n\tif (!hist_field) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\thist_field->buckets = buckets;\n\n\treturn hist_field;\n out:\n\treturn ERR_PTR(ret);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct field_var *create_field_var(struct hist_trigger_data *hist_data,\n\t\t\t\t\t  struct trace_event_file *file,\n\t\t\t\t\t  char *field_name)\n{\n\tstruct hist_field *val = NULL, *var = NULL;\n\tunsigned long flags = HIST_FIELD_FL_VAR;\n\tstruct trace_array *tr = file->tr;\n\tstruct field_var *field_var;\n\tint ret = 0;\n\n\tif (hist_data->n_field_vars >= SYNTH_FIELDS_MAX) {\n\t\thist_err(tr, HIST_ERR_TOO_MANY_FIELD_VARS, errpos(field_name));\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tval = parse_atom(hist_data, file, field_name, &flags, NULL);\n\tif (IS_ERR(val)) {\n\t\thist_err(tr, HIST_ERR_FIELD_VAR_PARSE_FAIL, errpos(field_name));\n\t\tret = PTR_ERR(val);\n\t\tgoto err;\n\t}\n\n\tvar = create_var(hist_data, file, field_name, val->size, val->type);\n\tif (IS_ERR(var)) {\n\t\thist_err(tr, HIST_ERR_VAR_CREATE_FIND_FAIL, errpos(field_name));\n\t\tkfree(val);\n\t\tret = PTR_ERR(var);\n\t\tgoto err;\n\t}\n\n\tfield_var = kzalloc(sizeof(struct field_var), GFP_KERNEL);\n\tif (!field_var) {\n\t\tkfree(val);\n\t\tkfree(var);\n\t\tret =  -ENOMEM;\n\t\tgoto err;\n\t}\n\n\tfield_var->var = var;\n\tfield_var->val = val;\n out:\n\treturn field_var;\n err:\n\tfield_var = ERR_PTR(ret);\n\tgoto out;\n}"
  },
  {
    "function_name": "create_var",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
    "lines": "3078-3118",
    "snippet": "static struct hist_field *create_var(struct hist_trigger_data *hist_data,\n\t\t\t\t     struct trace_event_file *file,\n\t\t\t\t     char *name, int size, const char *type)\n{\n\tstruct hist_field *var;\n\tint idx;\n\n\tif (find_var(hist_data, file, name) && !hist_data->remove) {\n\t\tvar = ERR_PTR(-EINVAL);\n\t\tgoto out;\n\t}\n\n\tvar = kzalloc(sizeof(struct hist_field), GFP_KERNEL);\n\tif (!var) {\n\t\tvar = ERR_PTR(-ENOMEM);\n\t\tgoto out;\n\t}\n\n\tidx = tracing_map_add_var(hist_data->map);\n\tif (idx < 0) {\n\t\tkfree(var);\n\t\tvar = ERR_PTR(-EINVAL);\n\t\tgoto out;\n\t}\n\n\tvar->ref = 1;\n\tvar->flags = HIST_FIELD_FL_VAR;\n\tvar->var.idx = idx;\n\tvar->var.hist_data = var->hist_data = hist_data;\n\tvar->size = size;\n\tvar->var.name = kstrdup(name, GFP_KERNEL);\n\tvar->type = kstrdup_const(type, GFP_KERNEL);\n\tif (!var->var.name || !var->type) {\n\t\tkfree_const(var->type);\n\t\tkfree(var->var.name);\n\t\tkfree(var);\n\t\tvar = ERR_PTR(-ENOMEM);\n\t}\n out:\n\treturn var;\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include \"tracing_map.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 3114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "var"
          ],
          "line": 3113
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree_const",
          "args": [
            "var->type"
          ],
          "line": 3111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrdup_const",
          "args": [
            "type",
            "GFP_KERNEL"
          ],
          "line": 3109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "name",
            "GFP_KERNEL"
          ],
          "line": 3108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EINVAL"
          ],
          "line": 3099
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tracing_map_add_var",
          "args": [
            "hist_data->map"
          ],
          "line": 3096
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_map_add_var",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/tracing_map.c",
          "lines": "244-252",
          "snippet": "int tracing_map_add_var(struct tracing_map *map)\n{\n\tint ret = -EINVAL;\n\n\tif (map->n_vars < TRACING_MAP_VARS_MAX)\n\t\tret = map->n_vars++;\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/kmemleak.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/jhash.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/kmemleak.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <linux/vmalloc.h>\n\nint tracing_map_add_var(struct tracing_map *map)\n{\n\tint ret = -EINVAL;\n\n\tif (map->n_vars < TRACING_MAP_VARS_MAX)\n\t\tret = map->n_vars++;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 3092
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct hist_field)",
            "GFP_KERNEL"
          ],
          "line": 3090
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EINVAL"
          ],
          "line": 3086
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_var",
          "args": [
            "hist_data",
            "file",
            "name"
          ],
          "line": 3085
        },
        "resolved": true,
        "details": {
          "function_name": "find_var",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "1079-1103",
          "snippet": "static struct hist_field *find_var(struct hist_trigger_data *hist_data,\n\t\t\t\t   struct trace_event_file *file,\n\t\t\t\t   const char *var_name)\n{\n\tstruct hist_trigger_data *test_data;\n\tstruct event_trigger_data *test;\n\tstruct hist_field *hist_field;\n\n\tlockdep_assert_held(&event_mutex);\n\n\thist_field = find_var_field(hist_data, var_name);\n\tif (hist_field)\n\t\treturn hist_field;\n\n\tlist_for_each_entry(test, &file->triggers, list) {\n\t\tif (test->cmd_ops->trigger_type == ETT_EVENT_HIST) {\n\t\t\ttest_data = test->private_data;\n\t\t\thist_field = find_var_field(test_data, var_name);\n\t\t\tif (hist_field)\n\t\t\t\treturn hist_field;\n\t\t}\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct hist_field *find_var(struct hist_trigger_data *hist_data,\n\t\t\t\t   struct trace_event_file *file,\n\t\t\t\t   const char *var_name)\n{\n\tstruct hist_trigger_data *test_data;\n\tstruct event_trigger_data *test;\n\tstruct hist_field *hist_field;\n\n\tlockdep_assert_held(&event_mutex);\n\n\thist_field = find_var_field(hist_data, var_name);\n\tif (hist_field)\n\t\treturn hist_field;\n\n\tlist_for_each_entry(test, &file->triggers, list) {\n\t\tif (test->cmd_ops->trigger_type == ETT_EVENT_HIST) {\n\t\t\ttest_data = test->private_data;\n\t\t\thist_field = find_var_field(test_data, var_name);\n\t\t\tif (hist_field)\n\t\t\t\treturn hist_field;\n\t\t}\n\t}\n\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct hist_field *create_var(struct hist_trigger_data *hist_data,\n\t\t\t\t     struct trace_event_file *file,\n\t\t\t\t     char *name, int size, const char *type)\n{\n\tstruct hist_field *var;\n\tint idx;\n\n\tif (find_var(hist_data, file, name) && !hist_data->remove) {\n\t\tvar = ERR_PTR(-EINVAL);\n\t\tgoto out;\n\t}\n\n\tvar = kzalloc(sizeof(struct hist_field), GFP_KERNEL);\n\tif (!var) {\n\t\tvar = ERR_PTR(-ENOMEM);\n\t\tgoto out;\n\t}\n\n\tidx = tracing_map_add_var(hist_data->map);\n\tif (idx < 0) {\n\t\tkfree(var);\n\t\tvar = ERR_PTR(-EINVAL);\n\t\tgoto out;\n\t}\n\n\tvar->ref = 1;\n\tvar->flags = HIST_FIELD_FL_VAR;\n\tvar->var.idx = idx;\n\tvar->var.hist_data = var->hist_data = hist_data;\n\tvar->size = size;\n\tvar->var.name = kstrdup(name, GFP_KERNEL);\n\tvar->type = kstrdup_const(type, GFP_KERNEL);\n\tif (!var->var.name || !var->type) {\n\t\tkfree_const(var->type);\n\t\tkfree(var->var.name);\n\t\tkfree(var);\n\t\tvar = ERR_PTR(-ENOMEM);\n\t}\n out:\n\treturn var;\n}"
  },
  {
    "function_name": "save_track_data_vars",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
    "lines": "3068-3076",
    "snippet": "static void save_track_data_vars(struct hist_trigger_data *hist_data,\n\t\t\t\t struct tracing_map_elt *elt,\n\t\t\t\t struct trace_buffer *buffer,  void *rec,\n\t\t\t\t struct ring_buffer_event *rbe, void *key,\n\t\t\t\t struct action_data *data, u64 *var_ref_vals)\n{\n\t__update_field_vars(elt, buffer, rbe, rec, hist_data->save_vars,\n\t\t\t    hist_data->n_save_vars, hist_data->n_field_var_str);\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include \"tracing_map.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__update_field_vars",
          "args": [
            "elt",
            "buffer",
            "rbe",
            "rec",
            "hist_data->save_vars",
            "hist_data->n_save_vars",
            "hist_data->n_field_var_str"
          ],
          "line": 3074
        },
        "resolved": true,
        "details": {
          "function_name": "__update_field_vars",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "3025-3056",
          "snippet": "static inline void __update_field_vars(struct tracing_map_elt *elt,\n\t\t\t\t       struct trace_buffer *buffer,\n\t\t\t\t       struct ring_buffer_event *rbe,\n\t\t\t\t       void *rec,\n\t\t\t\t       struct field_var **field_vars,\n\t\t\t\t       unsigned int n_field_vars,\n\t\t\t\t       unsigned int field_var_str_start)\n{\n\tstruct hist_elt_data *elt_data = elt->private_data;\n\tunsigned int i, j, var_idx;\n\tu64 var_val;\n\n\tfor (i = 0, j = field_var_str_start; i < n_field_vars; i++) {\n\t\tstruct field_var *field_var = field_vars[i];\n\t\tstruct hist_field *var = field_var->var;\n\t\tstruct hist_field *val = field_var->val;\n\n\t\tvar_val = val->fn(val, elt, buffer, rbe, rec);\n\t\tvar_idx = var->var.idx;\n\n\t\tif (val->flags & HIST_FIELD_FL_STRING) {\n\t\t\tchar *str = elt_data->field_var_str[j++];\n\t\t\tchar *val_str = (char *)(uintptr_t)var_val;\n\t\t\tunsigned int size;\n\n\t\t\tsize = min(val->size, STR_VAR_LEN_MAX);\n\t\t\tstrscpy(str, val_str, size);\n\t\t\tvar_val = (u64)(uintptr_t)str;\n\t\t}\n\t\ttracing_map_set_var(elt, var_idx, var_val);\n\t}\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic inline void __update_field_vars(struct tracing_map_elt *elt,\n\t\t\t\t       struct trace_buffer *buffer,\n\t\t\t\t       struct ring_buffer_event *rbe,\n\t\t\t\t       void *rec,\n\t\t\t\t       struct field_var **field_vars,\n\t\t\t\t       unsigned int n_field_vars,\n\t\t\t\t       unsigned int field_var_str_start)\n{\n\tstruct hist_elt_data *elt_data = elt->private_data;\n\tunsigned int i, j, var_idx;\n\tu64 var_val;\n\n\tfor (i = 0, j = field_var_str_start; i < n_field_vars; i++) {\n\t\tstruct field_var *field_var = field_vars[i];\n\t\tstruct hist_field *var = field_var->var;\n\t\tstruct hist_field *val = field_var->val;\n\n\t\tvar_val = val->fn(val, elt, buffer, rbe, rec);\n\t\tvar_idx = var->var.idx;\n\n\t\tif (val->flags & HIST_FIELD_FL_STRING) {\n\t\t\tchar *str = elt_data->field_var_str[j++];\n\t\t\tchar *val_str = (char *)(uintptr_t)var_val;\n\t\t\tunsigned int size;\n\n\t\t\tsize = min(val->size, STR_VAR_LEN_MAX);\n\t\t\tstrscpy(str, val_str, size);\n\t\t\tvar_val = (u64)(uintptr_t)str;\n\t\t}\n\t\ttracing_map_set_var(elt, var_idx, var_val);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);\n\nstatic void save_track_data_vars(struct hist_trigger_data *hist_data,\n\t\t\t\t struct tracing_map_elt *elt,\n\t\t\t\t struct trace_buffer *buffer,  void *rec,\n\t\t\t\t struct ring_buffer_event *rbe, void *key,\n\t\t\t\t struct action_data *data, u64 *var_ref_vals)\n{\n\t__update_field_vars(elt, buffer, rbe, rec, hist_data->save_vars,\n\t\t\t    hist_data->n_save_vars, hist_data->n_field_var_str);\n}"
  },
  {
    "function_name": "update_field_vars",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
    "lines": "3058-3066",
    "snippet": "static void update_field_vars(struct hist_trigger_data *hist_data,\n\t\t\t      struct tracing_map_elt *elt,\n\t\t\t      struct trace_buffer *buffer,\n\t\t\t      struct ring_buffer_event *rbe,\n\t\t\t      void *rec)\n{\n\t__update_field_vars(elt, buffer, rbe, rec, hist_data->field_vars,\n\t\t\t    hist_data->n_field_vars, 0);\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include \"tracing_map.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__update_field_vars",
          "args": [
            "elt",
            "buffer",
            "rbe",
            "rec",
            "hist_data->field_vars",
            "hist_data->n_field_vars",
            "0"
          ],
          "line": 3064
        },
        "resolved": true,
        "details": {
          "function_name": "__update_field_vars",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "3025-3056",
          "snippet": "static inline void __update_field_vars(struct tracing_map_elt *elt,\n\t\t\t\t       struct trace_buffer *buffer,\n\t\t\t\t       struct ring_buffer_event *rbe,\n\t\t\t\t       void *rec,\n\t\t\t\t       struct field_var **field_vars,\n\t\t\t\t       unsigned int n_field_vars,\n\t\t\t\t       unsigned int field_var_str_start)\n{\n\tstruct hist_elt_data *elt_data = elt->private_data;\n\tunsigned int i, j, var_idx;\n\tu64 var_val;\n\n\tfor (i = 0, j = field_var_str_start; i < n_field_vars; i++) {\n\t\tstruct field_var *field_var = field_vars[i];\n\t\tstruct hist_field *var = field_var->var;\n\t\tstruct hist_field *val = field_var->val;\n\n\t\tvar_val = val->fn(val, elt, buffer, rbe, rec);\n\t\tvar_idx = var->var.idx;\n\n\t\tif (val->flags & HIST_FIELD_FL_STRING) {\n\t\t\tchar *str = elt_data->field_var_str[j++];\n\t\t\tchar *val_str = (char *)(uintptr_t)var_val;\n\t\t\tunsigned int size;\n\n\t\t\tsize = min(val->size, STR_VAR_LEN_MAX);\n\t\t\tstrscpy(str, val_str, size);\n\t\t\tvar_val = (u64)(uintptr_t)str;\n\t\t}\n\t\ttracing_map_set_var(elt, var_idx, var_val);\n\t}\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic inline void __update_field_vars(struct tracing_map_elt *elt,\n\t\t\t\t       struct trace_buffer *buffer,\n\t\t\t\t       struct ring_buffer_event *rbe,\n\t\t\t\t       void *rec,\n\t\t\t\t       struct field_var **field_vars,\n\t\t\t\t       unsigned int n_field_vars,\n\t\t\t\t       unsigned int field_var_str_start)\n{\n\tstruct hist_elt_data *elt_data = elt->private_data;\n\tunsigned int i, j, var_idx;\n\tu64 var_val;\n\n\tfor (i = 0, j = field_var_str_start; i < n_field_vars; i++) {\n\t\tstruct field_var *field_var = field_vars[i];\n\t\tstruct hist_field *var = field_var->var;\n\t\tstruct hist_field *val = field_var->val;\n\n\t\tvar_val = val->fn(val, elt, buffer, rbe, rec);\n\t\tvar_idx = var->var.idx;\n\n\t\tif (val->flags & HIST_FIELD_FL_STRING) {\n\t\t\tchar *str = elt_data->field_var_str[j++];\n\t\t\tchar *val_str = (char *)(uintptr_t)var_val;\n\t\t\tunsigned int size;\n\n\t\t\tsize = min(val->size, STR_VAR_LEN_MAX);\n\t\t\tstrscpy(str, val_str, size);\n\t\t\tvar_val = (u64)(uintptr_t)str;\n\t\t}\n\t\ttracing_map_set_var(elt, var_idx, var_val);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void update_field_vars(struct hist_trigger_data *hist_data,\n\t\t\t      struct tracing_map_elt *elt,\n\t\t\t      struct trace_buffer *buffer,\n\t\t\t      struct ring_buffer_event *rbe,\n\t\t\t      void *rec)\n{\n\t__update_field_vars(elt, buffer, rbe, rec, hist_data->field_vars,\n\t\t\t    hist_data->n_field_vars, 0);\n}"
  },
  {
    "function_name": "__update_field_vars",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
    "lines": "3025-3056",
    "snippet": "static inline void __update_field_vars(struct tracing_map_elt *elt,\n\t\t\t\t       struct trace_buffer *buffer,\n\t\t\t\t       struct ring_buffer_event *rbe,\n\t\t\t\t       void *rec,\n\t\t\t\t       struct field_var **field_vars,\n\t\t\t\t       unsigned int n_field_vars,\n\t\t\t\t       unsigned int field_var_str_start)\n{\n\tstruct hist_elt_data *elt_data = elt->private_data;\n\tunsigned int i, j, var_idx;\n\tu64 var_val;\n\n\tfor (i = 0, j = field_var_str_start; i < n_field_vars; i++) {\n\t\tstruct field_var *field_var = field_vars[i];\n\t\tstruct hist_field *var = field_var->var;\n\t\tstruct hist_field *val = field_var->val;\n\n\t\tvar_val = val->fn(val, elt, buffer, rbe, rec);\n\t\tvar_idx = var->var.idx;\n\n\t\tif (val->flags & HIST_FIELD_FL_STRING) {\n\t\t\tchar *str = elt_data->field_var_str[j++];\n\t\t\tchar *val_str = (char *)(uintptr_t)var_val;\n\t\t\tunsigned int size;\n\n\t\t\tsize = min(val->size, STR_VAR_LEN_MAX);\n\t\t\tstrscpy(str, val_str, size);\n\t\t\tvar_val = (u64)(uintptr_t)str;\n\t\t}\n\t\ttracing_map_set_var(elt, var_idx, var_val);\n\t}\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include \"tracing_map.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tracing_map_set_var",
          "args": [
            "elt",
            "var_idx",
            "var_val"
          ],
          "line": 3054
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_map_set_var",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/tracing_map.c",
          "lines": "71-75",
          "snippet": "void tracing_map_set_var(struct tracing_map_elt *elt, unsigned int i, u64 n)\n{\n\tatomic64_set(&elt->vars[i], n);\n\telt->var_set[i] = true;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/kmemleak.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/jhash.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/kmemleak.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <linux/vmalloc.h>\n\nvoid tracing_map_set_var(struct tracing_map_elt *elt, unsigned int i, u64 n)\n{\n\tatomic64_set(&elt->vars[i], n);\n\telt->var_set[i] = true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strscpy",
          "args": [
            "str",
            "val_str",
            "size"
          ],
          "line": 3051
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "val->size",
            "STR_VAR_LEN_MAX"
          ],
          "line": 3050
        },
        "resolved": true,
        "details": {
          "function_name": "stop_critical_timing",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_irqsoff.c",
          "lines": "403-434",
          "snippet": "static nokprobe_inline void\nstop_critical_timing(unsigned long ip, unsigned long parent_ip)\n{\n\tint cpu;\n\tstruct trace_array *tr = irqsoff_trace;\n\tstruct trace_array_cpu *data;\n\tunsigned int trace_ctx;\n\n\tcpu = raw_smp_processor_id();\n\t/* Always clear the tracing cpu on stopping the trace */\n\tif (unlikely(per_cpu(tracing_cpu, cpu)))\n\t\tper_cpu(tracing_cpu, cpu) = 0;\n\telse\n\t\treturn;\n\n\tif (!tracer_enabled || !tracing_is_enabled())\n\t\treturn;\n\n\tdata = per_cpu_ptr(tr->array_buffer.data, cpu);\n\n\tif (unlikely(!data) ||\n\t    !data->critical_start || atomic_read(&data->disabled))\n\t\treturn;\n\n\tatomic_inc(&data->disabled);\n\n\ttrace_ctx = tracing_gen_ctx();\n\t__trace_function(tr, ip, parent_ip, trace_ctx);\n\tcheck_critical_timing(tr, data, parent_ip ? : ip, cpu);\n\tdata->critical_start = 0;\n\tatomic_dec(&data->disabled);\n}",
          "includes": [
            "#include <trace/events/preemptirq.h>",
            "#include \"trace.h\"",
            "#include <linux/kprobes.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [
            "#define __trace_function trace_function"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/preemptirq.h>\n#include \"trace.h\"\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n\n#define __trace_function trace_function\n\nstatic nokprobe_inline void\nstop_critical_timing(unsigned long ip, unsigned long parent_ip)\n{\n\tint cpu;\n\tstruct trace_array *tr = irqsoff_trace;\n\tstruct trace_array_cpu *data;\n\tunsigned int trace_ctx;\n\n\tcpu = raw_smp_processor_id();\n\t/* Always clear the tracing cpu on stopping the trace */\n\tif (unlikely(per_cpu(tracing_cpu, cpu)))\n\t\tper_cpu(tracing_cpu, cpu) = 0;\n\telse\n\t\treturn;\n\n\tif (!tracer_enabled || !tracing_is_enabled())\n\t\treturn;\n\n\tdata = per_cpu_ptr(tr->array_buffer.data, cpu);\n\n\tif (unlikely(!data) ||\n\t    !data->critical_start || atomic_read(&data->disabled))\n\t\treturn;\n\n\tatomic_inc(&data->disabled);\n\n\ttrace_ctx = tracing_gen_ctx();\n\t__trace_function(tr, ip, parent_ip, trace_ctx);\n\tcheck_critical_timing(tr, data, parent_ip ? : ip, cpu);\n\tdata->critical_start = 0;\n\tatomic_dec(&data->disabled);\n}"
        }
      },
      {
        "call_info": {
          "callee": "val->fn",
          "args": [
            "val",
            "elt",
            "buffer",
            "rbe",
            "rec"
          ],
          "line": 3042
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic inline void __update_field_vars(struct tracing_map_elt *elt,\n\t\t\t\t       struct trace_buffer *buffer,\n\t\t\t\t       struct ring_buffer_event *rbe,\n\t\t\t\t       void *rec,\n\t\t\t\t       struct field_var **field_vars,\n\t\t\t\t       unsigned int n_field_vars,\n\t\t\t\t       unsigned int field_var_str_start)\n{\n\tstruct hist_elt_data *elt_data = elt->private_data;\n\tunsigned int i, j, var_idx;\n\tu64 var_val;\n\n\tfor (i = 0, j = field_var_str_start; i < n_field_vars; i++) {\n\t\tstruct field_var *field_var = field_vars[i];\n\t\tstruct hist_field *var = field_var->var;\n\t\tstruct hist_field *val = field_var->val;\n\n\t\tvar_val = val->fn(val, elt, buffer, rbe, rec);\n\t\tvar_idx = var->var.idx;\n\n\t\tif (val->flags & HIST_FIELD_FL_STRING) {\n\t\t\tchar *str = elt_data->field_var_str[j++];\n\t\t\tchar *val_str = (char *)(uintptr_t)var_val;\n\t\t\tunsigned int size;\n\n\t\t\tsize = min(val->size, STR_VAR_LEN_MAX);\n\t\t\tstrscpy(str, val_str, size);\n\t\t\tvar_val = (u64)(uintptr_t)str;\n\t\t}\n\t\ttracing_map_set_var(elt, var_idx, var_val);\n\t}\n}"
  },
  {
    "function_name": "find_target_event_var",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
    "lines": "2998-3023",
    "snippet": "static struct hist_field *\nfind_target_event_var(struct hist_trigger_data *hist_data,\n\t\t      char *subsys_name, char *event_name, char *var_name)\n{\n\tstruct trace_event_file *file = hist_data->event_file;\n\tstruct hist_field *hist_field = NULL;\n\n\tif (subsys_name) {\n\t\tstruct trace_event_call *call;\n\n\t\tif (!event_name)\n\t\t\treturn NULL;\n\n\t\tcall = file->event_call;\n\n\t\tif (strcmp(subsys_name, call->class->system) != 0)\n\t\t\treturn NULL;\n\n\t\tif (strcmp(event_name, trace_event_name(call)) != 0)\n\t\t\treturn NULL;\n\t}\n\n\thist_field = find_var_field(hist_data, var_name);\n\n\treturn hist_field;\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include \"tracing_map.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "find_var_field",
          "args": [
            "hist_data",
            "var_name"
          ],
          "line": 3020
        },
        "resolved": true,
        "details": {
          "function_name": "find_var_field",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "1061-1077",
          "snippet": "static struct hist_field *find_var_field(struct hist_trigger_data *hist_data,\n\t\t\t\t\t const char *var_name)\n{\n\tstruct hist_field *hist_field, *found = NULL;\n\tint i;\n\n\tfor_each_hist_field(i, hist_data) {\n\t\thist_field = hist_data->fields[i];\n\t\tif (hist_field && hist_field->flags & HIST_FIELD_FL_VAR &&\n\t\t    strcmp(hist_field->var.name, var_name) == 0) {\n\t\t\tfound = hist_field;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn found;\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct hist_field *find_var_field(struct hist_trigger_data *hist_data,\n\t\t\t\t\t const char *var_name)\n{\n\tstruct hist_field *hist_field, *found = NULL;\n\tint i;\n\n\tfor_each_hist_field(i, hist_data) {\n\t\thist_field = hist_data->fields[i];\n\t\tif (hist_field && hist_field->flags & HIST_FIELD_FL_VAR &&\n\t\t    strcmp(hist_field->var.name, var_name) == 0) {\n\t\t\tfound = hist_field;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn found;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "event_name",
            "trace_event_name(call)"
          ],
          "line": 3016
        },
        "resolved": true,
        "details": {
          "function_name": "sym_strcmp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/report.c",
          "lines": "356-365",
          "snippet": "static int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}",
          "includes": [
            "#include \"encoding.h\"",
            "#include \"kcsan.h\"",
            "#include <linux/stacktrace.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/delay.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"encoding.h\"\n#include \"kcsan.h\"\n#include <linux/stacktrace.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/lockdep.h>\n#include <linux/kernel.h>\n#include <linux/kallsyms.h>\n#include <linux/jiffies.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n\nstatic int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_event_name",
          "args": [
            "call"
          ],
          "line": 3016
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct hist_field *\nfind_target_event_var(struct hist_trigger_data *hist_data,\n\t\t      char *subsys_name, char *event_name, char *var_name)\n{\n\tstruct trace_event_file *file = hist_data->event_file;\n\tstruct hist_field *hist_field = NULL;\n\n\tif (subsys_name) {\n\t\tstruct trace_event_call *call;\n\n\t\tif (!event_name)\n\t\t\treturn NULL;\n\n\t\tcall = file->event_call;\n\n\t\tif (strcmp(subsys_name, call->class->system) != 0)\n\t\t\treturn NULL;\n\n\t\tif (strcmp(event_name, trace_event_name(call)) != 0)\n\t\t\treturn NULL;\n\t}\n\n\thist_field = find_var_field(hist_data, var_name);\n\n\treturn hist_field;\n}"
  },
  {
    "function_name": "create_field_var_hist",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
    "lines": "2878-2996",
    "snippet": "static struct hist_field *\ncreate_field_var_hist(struct hist_trigger_data *target_hist_data,\n\t\t      char *subsys_name, char *event_name, char *field_name)\n{\n\tstruct trace_array *tr = target_hist_data->event_file->tr;\n\tstruct hist_trigger_data *hist_data;\n\tunsigned int i, n, first = true;\n\tstruct field_var_hist *var_hist;\n\tstruct trace_event_file *file;\n\tstruct hist_field *key_field;\n\tstruct hist_field *event_var;\n\tchar *saved_filter;\n\tchar *cmd;\n\tint ret;\n\n\tif (target_hist_data->n_field_var_hists >= SYNTH_FIELDS_MAX) {\n\t\thist_err(tr, HIST_ERR_TOO_MANY_FIELD_VARS, errpos(field_name));\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tfile = event_file(tr, subsys_name, event_name);\n\n\tif (IS_ERR(file)) {\n\t\thist_err(tr, HIST_ERR_EVENT_FILE_NOT_FOUND, errpos(field_name));\n\t\tret = PTR_ERR(file);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\t/*\n\t * Look for a histogram compatible with target.  We'll use the\n\t * found histogram specification to create a new matching\n\t * histogram with our variable on it.  target_hist_data is not\n\t * yet a registered histogram so we can't use that.\n\t */\n\thist_data = find_compatible_hist(target_hist_data, file);\n\tif (!hist_data) {\n\t\thist_err(tr, HIST_ERR_HIST_NOT_FOUND, errpos(field_name));\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\t/* See if a synthetic field variable has already been created */\n\tevent_var = find_synthetic_field_var(target_hist_data, subsys_name,\n\t\t\t\t\t     event_name, field_name);\n\tif (!IS_ERR_OR_NULL(event_var))\n\t\treturn event_var;\n\n\tvar_hist = kzalloc(sizeof(*var_hist), GFP_KERNEL);\n\tif (!var_hist)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tcmd = kzalloc(MAX_FILTER_STR_VAL, GFP_KERNEL);\n\tif (!cmd) {\n\t\tkfree(var_hist);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\t/* Use the same keys as the compatible histogram */\n\tstrcat(cmd, \"keys=\");\n\n\tfor_each_hist_key_field(i, hist_data) {\n\t\tkey_field = hist_data->fields[i];\n\t\tif (!first)\n\t\t\tstrcat(cmd, \",\");\n\t\tstrcat(cmd, key_field->field->name);\n\t\tfirst = false;\n\t}\n\n\t/* Create the synthetic field variable specification */\n\tstrcat(cmd, \":synthetic_\");\n\tstrcat(cmd, field_name);\n\tstrcat(cmd, \"=\");\n\tstrcat(cmd, field_name);\n\n\t/* Use the same filter as the compatible histogram */\n\tsaved_filter = find_trigger_filter(hist_data, file);\n\tif (saved_filter) {\n\t\tstrcat(cmd, \" if \");\n\t\tstrcat(cmd, saved_filter);\n\t}\n\n\tvar_hist->cmd = kstrdup(cmd, GFP_KERNEL);\n\tif (!var_hist->cmd) {\n\t\tkfree(cmd);\n\t\tkfree(var_hist);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\t/* Save the compatible histogram information */\n\tvar_hist->hist_data = hist_data;\n\n\t/* Create the new histogram with our variable */\n\tret = event_hist_trigger_parse(&trigger_hist_cmd, file,\n\t\t\t\t       \"\", \"hist\", cmd);\n\tif (ret) {\n\t\tkfree(cmd);\n\t\tkfree(var_hist->cmd);\n\t\tkfree(var_hist);\n\t\thist_err(tr, HIST_ERR_HIST_CREATE_FAIL, errpos(field_name));\n\t\treturn ERR_PTR(ret);\n\t}\n\n\tkfree(cmd);\n\n\t/* If we can't find the variable, something went wrong */\n\tevent_var = find_synthetic_field_var(target_hist_data, subsys_name,\n\t\t\t\t\t     event_name, field_name);\n\tif (IS_ERR_OR_NULL(event_var)) {\n\t\tkfree(var_hist->cmd);\n\t\tkfree(var_hist);\n\t\thist_err(tr, HIST_ERR_SYNTH_VAR_NOT_FOUND, errpos(field_name));\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tn = target_hist_data->n_field_var_hists;\n\ttarget_hist_data->field_var_hists[n] = var_hist;\n\ttarget_hist_data->n_field_var_hists++;\n\n\treturn event_var;\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include \"tracing_map.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct event_command trigger_hist_cmd;",
      "static struct event_command trigger_hist_cmd = {\n\t.name\t\t\t= \"hist\",\n\t.trigger_type\t\t= ETT_EVENT_HIST,\n\t.flags\t\t\t= EVENT_CMD_FL_NEEDS_REC,\n\t.parse\t\t\t= event_hist_trigger_parse,\n\t.reg\t\t\t= hist_register_trigger,\n\t.unreg\t\t\t= hist_unregister_trigger,\n\t.unreg_all\t\t= hist_unreg_all,\n\t.get_trigger_ops\t= event_hist_get_trigger_ops,\n\t.set_filter\t\t= set_trigger_filter,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EINVAL"
          ],
          "line": 2988
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hist_err",
          "args": [
            "tr",
            "HIST_ERR_SYNTH_VAR_NOT_FOUND",
            "errpos(field_name)"
          ],
          "line": 2987
        },
        "resolved": true,
        "details": {
          "function_name": "hist_err",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "763-767",
          "snippet": "static void hist_err(struct trace_array *tr, u8 err_type, u8 err_pos)\n{\n\ttracing_log_err(tr, last_cmd_loc, last_cmd, err_text,\n\t\t\terr_type, err_pos);\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *err_text[] = { ERRORS };",
            "static char last_cmd[MAX_FILTER_STR_VAL];",
            "static char last_cmd_loc[MAX_FILTER_STR_VAL];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic const char *err_text[] = { ERRORS };\nstatic char last_cmd[MAX_FILTER_STR_VAL];\nstatic char last_cmd_loc[MAX_FILTER_STR_VAL];\n\nstatic void hist_err(struct trace_array *tr, u8 err_type, u8 err_pos)\n{\n\ttracing_log_err(tr, last_cmd_loc, last_cmd, err_text,\n\t\t\terr_type, err_pos);\n}"
        }
      },
      {
        "call_info": {
          "callee": "errpos",
          "args": [
            "field_name"
          ],
          "line": 2987
        },
        "resolved": true,
        "details": {
          "function_name": "errpos",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "733-736",
          "snippet": "static int errpos(char *str)\n{\n\treturn err_pos(last_cmd, str);\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char last_cmd[MAX_FILTER_STR_VAL];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic char last_cmd[MAX_FILTER_STR_VAL];\n\nstatic int errpos(char *str)\n{\n\treturn err_pos(last_cmd, str);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "var_hist"
          ],
          "line": 2986
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR_OR_NULL",
          "args": [
            "event_var"
          ],
          "line": 2984
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_synthetic_field_var",
          "args": [
            "target_hist_data",
            "subsys_name",
            "event_name",
            "field_name"
          ],
          "line": 2982
        },
        "resolved": true,
        "details": {
          "function_name": "find_synthetic_field_var",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "2832-2851",
          "snippet": "static struct hist_field *\nfind_synthetic_field_var(struct hist_trigger_data *target_hist_data,\n\t\t\t char *system, char *event_name, char *field_name)\n{\n\tstruct hist_field *event_var;\n\tchar *synthetic_name;\n\n\tsynthetic_name = kzalloc(MAX_FILTER_STR_VAL, GFP_KERNEL);\n\tif (!synthetic_name)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tstrcpy(synthetic_name, \"synthetic_\");\n\tstrcat(synthetic_name, field_name);\n\n\tevent_var = find_event_var(target_hist_data, system, event_name, synthetic_name);\n\n\tkfree(synthetic_name);\n\n\treturn event_var;\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct hist_field *\nfind_synthetic_field_var(struct hist_trigger_data *target_hist_data,\n\t\t\t char *system, char *event_name, char *field_name)\n{\n\tstruct hist_field *event_var;\n\tchar *synthetic_name;\n\n\tsynthetic_name = kzalloc(MAX_FILTER_STR_VAL, GFP_KERNEL);\n\tif (!synthetic_name)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tstrcpy(synthetic_name, \"synthetic_\");\n\tstrcat(synthetic_name, field_name);\n\n\tevent_var = find_event_var(target_hist_data, system, event_name, synthetic_name);\n\n\tkfree(synthetic_name);\n\n\treturn event_var;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "ret"
          ],
          "line": 2976
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "event_hist_trigger_parse",
          "args": [
            "&trigger_hist_cmd",
            "file",
            "\"\"",
            "\"hist\"",
            "cmd"
          ],
          "line": 2969
        },
        "resolved": true,
        "details": {
          "function_name": "event_hist_trigger_parse",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "6149-6328",
          "snippet": "static int event_hist_trigger_parse(struct event_command *cmd_ops,\n\t\t\t\t    struct trace_event_file *file,\n\t\t\t\t    char *glob, char *cmd, char *param)\n{\n\tunsigned int hist_trigger_bits = TRACING_MAP_BITS_DEFAULT;\n\tstruct event_trigger_data *trigger_data;\n\tstruct hist_trigger_attrs *attrs;\n\tstruct event_trigger_ops *trigger_ops;\n\tstruct hist_trigger_data *hist_data;\n\tstruct synth_event *se;\n\tconst char *se_name;\n\tbool remove = false;\n\tchar *trigger, *p, *start;\n\tint ret = 0;\n\n\tlockdep_assert_held(&event_mutex);\n\n\tif (glob && strlen(glob)) {\n\t\thist_err_clear();\n\t\tlast_cmd_set(file, param);\n\t}\n\n\tif (!param)\n\t\treturn -EINVAL;\n\n\tif (glob[0] == '!')\n\t\tremove = true;\n\n\t/*\n\t * separate the trigger from the filter (k:v [if filter])\n\t * allowing for whitespace in the trigger\n\t */\n\tp = trigger = param;\n\tdo {\n\t\tp = strstr(p, \"if\");\n\t\tif (!p)\n\t\t\tbreak;\n\t\tif (p == param)\n\t\t\treturn -EINVAL;\n\t\tif (*(p - 1) != ' ' && *(p - 1) != '\\t') {\n\t\t\tp++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (p >= param + strlen(param) - (sizeof(\"if\") - 1) - 1)\n\t\t\treturn -EINVAL;\n\t\tif (*(p + sizeof(\"if\") - 1) != ' ' && *(p + sizeof(\"if\") - 1) != '\\t') {\n\t\t\tp++;\n\t\t\tcontinue;\n\t\t}\n\t\tbreak;\n\t} while (p);\n\n\tif (!p)\n\t\tparam = NULL;\n\telse {\n\t\t*(p - 1) = '\\0';\n\t\tparam = strstrip(p);\n\t\ttrigger = strstrip(trigger);\n\t}\n\n\t/*\n\t * To simplify arithmetic expression parsing, replace occurrences of\n\t * '.sym-offset' modifier with '.symXoffset'\n\t */\n\tstart = strstr(trigger, \".sym-offset\");\n\twhile (start) {\n\t\t*(start + 4) = 'X';\n\t\tstart = strstr(start + 11, \".sym-offset\");\n\t}\n\n\tattrs = parse_hist_trigger_attrs(file->tr, trigger);\n\tif (IS_ERR(attrs))\n\t\treturn PTR_ERR(attrs);\n\n\tif (attrs->map_bits)\n\t\thist_trigger_bits = attrs->map_bits;\n\n\thist_data = create_hist_data(hist_trigger_bits, attrs, file, remove);\n\tif (IS_ERR(hist_data)) {\n\t\tdestroy_hist_trigger_attrs(attrs);\n\t\treturn PTR_ERR(hist_data);\n\t}\n\n\ttrigger_ops = cmd_ops->get_trigger_ops(cmd, trigger);\n\n\ttrigger_data = kzalloc(sizeof(*trigger_data), GFP_KERNEL);\n\tif (!trigger_data) {\n\t\tret = -ENOMEM;\n\t\tgoto out_free;\n\t}\n\n\ttrigger_data->count = -1;\n\ttrigger_data->ops = trigger_ops;\n\ttrigger_data->cmd_ops = cmd_ops;\n\n\tINIT_LIST_HEAD(&trigger_data->list);\n\tRCU_INIT_POINTER(trigger_data->filter, NULL);\n\n\ttrigger_data->private_data = hist_data;\n\n\t/* if param is non-empty, it's supposed to be a filter */\n\tif (param && cmd_ops->set_filter) {\n\t\tret = cmd_ops->set_filter(param, trigger_data, file);\n\t\tif (ret < 0)\n\t\t\tgoto out_free;\n\t}\n\n\tif (remove) {\n\t\tif (!have_hist_trigger_match(trigger_data, file))\n\t\t\tgoto out_free;\n\n\t\tif (hist_trigger_check_refs(trigger_data, file)) {\n\t\t\tret = -EBUSY;\n\t\t\tgoto out_free;\n\t\t}\n\n\t\tcmd_ops->unreg(glob+1, trigger_data, file);\n\t\tse_name = trace_event_name(file->event_call);\n\t\tse = find_synth_event(se_name);\n\t\tif (se)\n\t\t\tse->ref--;\n\t\tret = 0;\n\t\tgoto out_free;\n\t}\n\n\tret = cmd_ops->reg(glob, trigger_data, file);\n\t/*\n\t * The above returns on success the # of triggers registered,\n\t * but if it didn't register any it returns zero.  Consider no\n\t * triggers registered a failure too.\n\t */\n\tif (!ret) {\n\t\tif (!(attrs->pause || attrs->cont || attrs->clear))\n\t\t\tret = -ENOENT;\n\t\tgoto out_free;\n\t} else if (ret < 0)\n\t\tgoto out_free;\n\n\tif (get_named_trigger_data(trigger_data))\n\t\tgoto enable;\n\n\tif (has_hist_vars(hist_data))\n\t\tsave_hist_vars(hist_data);\n\n\tret = create_actions(hist_data);\n\tif (ret)\n\t\tgoto out_unreg;\n\n\tret = tracing_map_init(hist_data->map);\n\tif (ret)\n\t\tgoto out_unreg;\nenable:\n\tret = hist_trigger_enable(trigger_data, file);\n\tif (ret)\n\t\tgoto out_unreg;\n\n\tse_name = trace_event_name(file->event_call);\n\tse = find_synth_event(se_name);\n\tif (se)\n\t\tse->ref++;\n\t/* Just return zero, not the number of registered triggers */\n\tret = 0;\n out:\n\tif (ret == 0)\n\t\thist_err_clear();\n\n\treturn ret;\n out_unreg:\n\tcmd_ops->unreg(glob+1, trigger_data, file);\n out_free:\n\tif (cmd_ops->set_filter)\n\t\tcmd_ops->set_filter(NULL, trigger_data, NULL);\n\n\tremove_hist_vars(hist_data);\n\n\tkfree(trigger_data);\n\n\tdestroy_hist_data(hist_data);\n\tgoto out;\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int event_hist_trigger_parse(struct event_command *cmd_ops,\n\t\t\t\t    struct trace_event_file *file,\n\t\t\t\t    char *glob, char *cmd, char *param);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int event_hist_trigger_parse(struct event_command *cmd_ops,\n\t\t\t\t    struct trace_event_file *file,\n\t\t\t\t    char *glob, char *cmd, char *param);\n\nstatic int event_hist_trigger_parse(struct event_command *cmd_ops,\n\t\t\t\t    struct trace_event_file *file,\n\t\t\t\t    char *glob, char *cmd, char *param)\n{\n\tunsigned int hist_trigger_bits = TRACING_MAP_BITS_DEFAULT;\n\tstruct event_trigger_data *trigger_data;\n\tstruct hist_trigger_attrs *attrs;\n\tstruct event_trigger_ops *trigger_ops;\n\tstruct hist_trigger_data *hist_data;\n\tstruct synth_event *se;\n\tconst char *se_name;\n\tbool remove = false;\n\tchar *trigger, *p, *start;\n\tint ret = 0;\n\n\tlockdep_assert_held(&event_mutex);\n\n\tif (glob && strlen(glob)) {\n\t\thist_err_clear();\n\t\tlast_cmd_set(file, param);\n\t}\n\n\tif (!param)\n\t\treturn -EINVAL;\n\n\tif (glob[0] == '!')\n\t\tremove = true;\n\n\t/*\n\t * separate the trigger from the filter (k:v [if filter])\n\t * allowing for whitespace in the trigger\n\t */\n\tp = trigger = param;\n\tdo {\n\t\tp = strstr(p, \"if\");\n\t\tif (!p)\n\t\t\tbreak;\n\t\tif (p == param)\n\t\t\treturn -EINVAL;\n\t\tif (*(p - 1) != ' ' && *(p - 1) != '\\t') {\n\t\t\tp++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (p >= param + strlen(param) - (sizeof(\"if\") - 1) - 1)\n\t\t\treturn -EINVAL;\n\t\tif (*(p + sizeof(\"if\") - 1) != ' ' && *(p + sizeof(\"if\") - 1) != '\\t') {\n\t\t\tp++;\n\t\t\tcontinue;\n\t\t}\n\t\tbreak;\n\t} while (p);\n\n\tif (!p)\n\t\tparam = NULL;\n\telse {\n\t\t*(p - 1) = '\\0';\n\t\tparam = strstrip(p);\n\t\ttrigger = strstrip(trigger);\n\t}\n\n\t/*\n\t * To simplify arithmetic expression parsing, replace occurrences of\n\t * '.sym-offset' modifier with '.symXoffset'\n\t */\n\tstart = strstr(trigger, \".sym-offset\");\n\twhile (start) {\n\t\t*(start + 4) = 'X';\n\t\tstart = strstr(start + 11, \".sym-offset\");\n\t}\n\n\tattrs = parse_hist_trigger_attrs(file->tr, trigger);\n\tif (IS_ERR(attrs))\n\t\treturn PTR_ERR(attrs);\n\n\tif (attrs->map_bits)\n\t\thist_trigger_bits = attrs->map_bits;\n\n\thist_data = create_hist_data(hist_trigger_bits, attrs, file, remove);\n\tif (IS_ERR(hist_data)) {\n\t\tdestroy_hist_trigger_attrs(attrs);\n\t\treturn PTR_ERR(hist_data);\n\t}\n\n\ttrigger_ops = cmd_ops->get_trigger_ops(cmd, trigger);\n\n\ttrigger_data = kzalloc(sizeof(*trigger_data), GFP_KERNEL);\n\tif (!trigger_data) {\n\t\tret = -ENOMEM;\n\t\tgoto out_free;\n\t}\n\n\ttrigger_data->count = -1;\n\ttrigger_data->ops = trigger_ops;\n\ttrigger_data->cmd_ops = cmd_ops;\n\n\tINIT_LIST_HEAD(&trigger_data->list);\n\tRCU_INIT_POINTER(trigger_data->filter, NULL);\n\n\ttrigger_data->private_data = hist_data;\n\n\t/* if param is non-empty, it's supposed to be a filter */\n\tif (param && cmd_ops->set_filter) {\n\t\tret = cmd_ops->set_filter(param, trigger_data, file);\n\t\tif (ret < 0)\n\t\t\tgoto out_free;\n\t}\n\n\tif (remove) {\n\t\tif (!have_hist_trigger_match(trigger_data, file))\n\t\t\tgoto out_free;\n\n\t\tif (hist_trigger_check_refs(trigger_data, file)) {\n\t\t\tret = -EBUSY;\n\t\t\tgoto out_free;\n\t\t}\n\n\t\tcmd_ops->unreg(glob+1, trigger_data, file);\n\t\tse_name = trace_event_name(file->event_call);\n\t\tse = find_synth_event(se_name);\n\t\tif (se)\n\t\t\tse->ref--;\n\t\tret = 0;\n\t\tgoto out_free;\n\t}\n\n\tret = cmd_ops->reg(glob, trigger_data, file);\n\t/*\n\t * The above returns on success the # of triggers registered,\n\t * but if it didn't register any it returns zero.  Consider no\n\t * triggers registered a failure too.\n\t */\n\tif (!ret) {\n\t\tif (!(attrs->pause || attrs->cont || attrs->clear))\n\t\t\tret = -ENOENT;\n\t\tgoto out_free;\n\t} else if (ret < 0)\n\t\tgoto out_free;\n\n\tif (get_named_trigger_data(trigger_data))\n\t\tgoto enable;\n\n\tif (has_hist_vars(hist_data))\n\t\tsave_hist_vars(hist_data);\n\n\tret = create_actions(hist_data);\n\tif (ret)\n\t\tgoto out_unreg;\n\n\tret = tracing_map_init(hist_data->map);\n\tif (ret)\n\t\tgoto out_unreg;\nenable:\n\tret = hist_trigger_enable(trigger_data, file);\n\tif (ret)\n\t\tgoto out_unreg;\n\n\tse_name = trace_event_name(file->event_call);\n\tse = find_synth_event(se_name);\n\tif (se)\n\t\tse->ref++;\n\t/* Just return zero, not the number of registered triggers */\n\tret = 0;\n out:\n\tif (ret == 0)\n\t\thist_err_clear();\n\n\treturn ret;\n out_unreg:\n\tcmd_ops->unreg(glob+1, trigger_data, file);\n out_free:\n\tif (cmd_ops->set_filter)\n\t\tcmd_ops->set_filter(NULL, trigger_data, NULL);\n\n\tremove_hist_vars(hist_data);\n\n\tkfree(trigger_data);\n\n\tdestroy_hist_data(hist_data);\n\tgoto out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 2962
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "cmd",
            "GFP_KERNEL"
          ],
          "line": 2958
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "cmd",
            "saved_filter"
          ],
          "line": 2955
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "cmd",
            "\" if \""
          ],
          "line": 2954
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_trigger_filter",
          "args": [
            "hist_data",
            "file"
          ],
          "line": 2952
        },
        "resolved": true,
        "details": {
          "function_name": "find_trigger_filter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "2746-2761",
          "snippet": "static char *find_trigger_filter(struct hist_trigger_data *hist_data,\n\t\t\t\t struct trace_event_file *file)\n{\n\tstruct event_trigger_data *test;\n\n\tlockdep_assert_held(&event_mutex);\n\n\tlist_for_each_entry(test, &file->triggers, list) {\n\t\tif (test->cmd_ops->trigger_type == ETT_EVENT_HIST) {\n\t\t\tif (test->private_data == hist_data)\n\t\t\t\treturn test->filter_str;\n\t\t}\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic char *find_trigger_filter(struct hist_trigger_data *hist_data,\n\t\t\t\t struct trace_event_file *file)\n{\n\tstruct event_trigger_data *test;\n\n\tlockdep_assert_held(&event_mutex);\n\n\tlist_for_each_entry(test, &file->triggers, list) {\n\t\tif (test->cmd_ops->trigger_type == ETT_EVENT_HIST) {\n\t\t\tif (test->private_data == hist_data)\n\t\t\t\treturn test->filter_str;\n\t\t}\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "cmd",
            "field_name"
          ],
          "line": 2949
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "cmd",
            "\"=\""
          ],
          "line": 2948
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "cmd",
            "field_name"
          ],
          "line": 2947
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "cmd",
            "\":synthetic_\""
          ],
          "line": 2946
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "cmd",
            "key_field->field->name"
          ],
          "line": 2941
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "cmd",
            "\",\""
          ],
          "line": 2940
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_hist_key_field",
          "args": [
            "i",
            "hist_data"
          ],
          "line": 2937
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "cmd",
            "\"keys=\""
          ],
          "line": 2935
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 2931
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "MAX_FILTER_STR_VAL",
            "GFP_KERNEL"
          ],
          "line": 2928
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 2926
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*var_hist)",
            "GFP_KERNEL"
          ],
          "line": 2924
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR_OR_NULL",
          "args": [
            "event_var"
          ],
          "line": 2921
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EINVAL"
          ],
          "line": 2915
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_compatible_hist",
          "args": [
            "target_hist_data",
            "file"
          ],
          "line": 2912
        },
        "resolved": true,
        "details": {
          "function_name": "find_compatible_hist",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "2796-2818",
          "snippet": "static struct hist_trigger_data *\nfind_compatible_hist(struct hist_trigger_data *target_hist_data,\n\t\t     struct trace_event_file *file)\n{\n\tstruct hist_trigger_data *hist_data;\n\tstruct event_trigger_data *test;\n\tunsigned int n_keys;\n\n\tlockdep_assert_held(&event_mutex);\n\n\tn_keys = target_hist_data->n_fields - target_hist_data->n_vals;\n\n\tlist_for_each_entry(test, &file->triggers, list) {\n\t\tif (test->cmd_ops->trigger_type == ETT_EVENT_HIST) {\n\t\t\thist_data = test->private_data;\n\n\t\t\tif (compatible_keys(target_hist_data, hist_data, n_keys))\n\t\t\t\treturn hist_data;\n\t\t}\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct hist_trigger_data *\nfind_compatible_hist(struct hist_trigger_data *target_hist_data,\n\t\t     struct trace_event_file *file)\n{\n\tstruct hist_trigger_data *hist_data;\n\tstruct event_trigger_data *test;\n\tunsigned int n_keys;\n\n\tlockdep_assert_held(&event_mutex);\n\n\tn_keys = target_hist_data->n_fields - target_hist_data->n_vals;\n\n\tlist_for_each_entry(test, &file->triggers, list) {\n\t\tif (test->cmd_ops->trigger_type == ETT_EVENT_HIST) {\n\t\t\thist_data = test->private_data;\n\n\t\t\tif (compatible_keys(target_hist_data, hist_data, n_keys))\n\t\t\t\treturn hist_data;\n\t\t}\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "ret"
          ],
          "line": 2903
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "file"
          ],
          "line": 2902
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "file"
          ],
          "line": 2900
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "event_file",
          "args": [
            "tr",
            "subsys_name",
            "event_name"
          ],
          "line": 2898
        },
        "resolved": true,
        "details": {
          "function_name": "event_file",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "2820-2830",
          "snippet": "static struct trace_event_file *event_file(struct trace_array *tr,\n\t\t\t\t\t   char *system, char *event_name)\n{\n\tstruct trace_event_file *file;\n\n\tfile = __find_event_file(tr, system, event_name);\n\tif (!file)\n\t\treturn ERR_PTR(-EINVAL);\n\n\treturn file;\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct trace_event_file *event_file(struct trace_array *tr,\n\t\t\t\t\t   char *system, char *event_name)\n{\n\tstruct trace_event_file *file;\n\n\tfile = __find_event_file(tr, system, event_name);\n\tif (!file)\n\t\treturn ERR_PTR(-EINVAL);\n\n\treturn file;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EINVAL"
          ],
          "line": 2895
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct event_command trigger_hist_cmd;\nstatic struct event_command trigger_hist_cmd = {\n\t.name\t\t\t= \"hist\",\n\t.trigger_type\t\t= ETT_EVENT_HIST,\n\t.flags\t\t\t= EVENT_CMD_FL_NEEDS_REC,\n\t.parse\t\t\t= event_hist_trigger_parse,\n\t.reg\t\t\t= hist_register_trigger,\n\t.unreg\t\t\t= hist_unregister_trigger,\n\t.unreg_all\t\t= hist_unreg_all,\n\t.get_trigger_ops\t= event_hist_get_trigger_ops,\n\t.set_filter\t\t= set_trigger_filter,\n};\n\nstatic struct hist_field *\ncreate_field_var_hist(struct hist_trigger_data *target_hist_data,\n\t\t      char *subsys_name, char *event_name, char *field_name)\n{\n\tstruct trace_array *tr = target_hist_data->event_file->tr;\n\tstruct hist_trigger_data *hist_data;\n\tunsigned int i, n, first = true;\n\tstruct field_var_hist *var_hist;\n\tstruct trace_event_file *file;\n\tstruct hist_field *key_field;\n\tstruct hist_field *event_var;\n\tchar *saved_filter;\n\tchar *cmd;\n\tint ret;\n\n\tif (target_hist_data->n_field_var_hists >= SYNTH_FIELDS_MAX) {\n\t\thist_err(tr, HIST_ERR_TOO_MANY_FIELD_VARS, errpos(field_name));\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tfile = event_file(tr, subsys_name, event_name);\n\n\tif (IS_ERR(file)) {\n\t\thist_err(tr, HIST_ERR_EVENT_FILE_NOT_FOUND, errpos(field_name));\n\t\tret = PTR_ERR(file);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\t/*\n\t * Look for a histogram compatible with target.  We'll use the\n\t * found histogram specification to create a new matching\n\t * histogram with our variable on it.  target_hist_data is not\n\t * yet a registered histogram so we can't use that.\n\t */\n\thist_data = find_compatible_hist(target_hist_data, file);\n\tif (!hist_data) {\n\t\thist_err(tr, HIST_ERR_HIST_NOT_FOUND, errpos(field_name));\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\t/* See if a synthetic field variable has already been created */\n\tevent_var = find_synthetic_field_var(target_hist_data, subsys_name,\n\t\t\t\t\t     event_name, field_name);\n\tif (!IS_ERR_OR_NULL(event_var))\n\t\treturn event_var;\n\n\tvar_hist = kzalloc(sizeof(*var_hist), GFP_KERNEL);\n\tif (!var_hist)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tcmd = kzalloc(MAX_FILTER_STR_VAL, GFP_KERNEL);\n\tif (!cmd) {\n\t\tkfree(var_hist);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\t/* Use the same keys as the compatible histogram */\n\tstrcat(cmd, \"keys=\");\n\n\tfor_each_hist_key_field(i, hist_data) {\n\t\tkey_field = hist_data->fields[i];\n\t\tif (!first)\n\t\t\tstrcat(cmd, \",\");\n\t\tstrcat(cmd, key_field->field->name);\n\t\tfirst = false;\n\t}\n\n\t/* Create the synthetic field variable specification */\n\tstrcat(cmd, \":synthetic_\");\n\tstrcat(cmd, field_name);\n\tstrcat(cmd, \"=\");\n\tstrcat(cmd, field_name);\n\n\t/* Use the same filter as the compatible histogram */\n\tsaved_filter = find_trigger_filter(hist_data, file);\n\tif (saved_filter) {\n\t\tstrcat(cmd, \" if \");\n\t\tstrcat(cmd, saved_filter);\n\t}\n\n\tvar_hist->cmd = kstrdup(cmd, GFP_KERNEL);\n\tif (!var_hist->cmd) {\n\t\tkfree(cmd);\n\t\tkfree(var_hist);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\t/* Save the compatible histogram information */\n\tvar_hist->hist_data = hist_data;\n\n\t/* Create the new histogram with our variable */\n\tret = event_hist_trigger_parse(&trigger_hist_cmd, file,\n\t\t\t\t       \"\", \"hist\", cmd);\n\tif (ret) {\n\t\tkfree(cmd);\n\t\tkfree(var_hist->cmd);\n\t\tkfree(var_hist);\n\t\thist_err(tr, HIST_ERR_HIST_CREATE_FAIL, errpos(field_name));\n\t\treturn ERR_PTR(ret);\n\t}\n\n\tkfree(cmd);\n\n\t/* If we can't find the variable, something went wrong */\n\tevent_var = find_synthetic_field_var(target_hist_data, subsys_name,\n\t\t\t\t\t     event_name, field_name);\n\tif (IS_ERR_OR_NULL(event_var)) {\n\t\tkfree(var_hist->cmd);\n\t\tkfree(var_hist);\n\t\thist_err(tr, HIST_ERR_SYNTH_VAR_NOT_FOUND, errpos(field_name));\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tn = target_hist_data->n_field_var_hists;\n\ttarget_hist_data->field_var_hists[n] = var_hist;\n\ttarget_hist_data->n_field_var_hists++;\n\n\treturn event_var;\n}"
  },
  {
    "function_name": "find_synthetic_field_var",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
    "lines": "2832-2851",
    "snippet": "static struct hist_field *\nfind_synthetic_field_var(struct hist_trigger_data *target_hist_data,\n\t\t\t char *system, char *event_name, char *field_name)\n{\n\tstruct hist_field *event_var;\n\tchar *synthetic_name;\n\n\tsynthetic_name = kzalloc(MAX_FILTER_STR_VAL, GFP_KERNEL);\n\tif (!synthetic_name)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tstrcpy(synthetic_name, \"synthetic_\");\n\tstrcat(synthetic_name, field_name);\n\n\tevent_var = find_event_var(target_hist_data, system, event_name, synthetic_name);\n\n\tkfree(synthetic_name);\n\n\treturn event_var;\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include \"tracing_map.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "synthetic_name"
          ],
          "line": 2848
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_event_var",
          "args": [
            "target_hist_data",
            "system",
            "event_name",
            "synthetic_name"
          ],
          "line": 2846
        },
        "resolved": true,
        "details": {
          "function_name": "find_event_var",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "1190-1214",
          "snippet": "static struct hist_field *find_event_var(struct hist_trigger_data *hist_data,\n\t\t\t\t\t char *system,\n\t\t\t\t\t char *event_name,\n\t\t\t\t\t char *var_name)\n{\n\tstruct trace_array *tr = hist_data->event_file->tr;\n\tstruct hist_field *hist_field = NULL;\n\tstruct trace_event_file *file;\n\n\tif (!system || !event_name) {\n\t\thist_field = find_match_var(hist_data, var_name);\n\t\tif (IS_ERR(hist_field))\n\t\t\treturn NULL;\n\t\tif (hist_field)\n\t\t\treturn hist_field;\n\t}\n\n\tfile = find_var_file(tr, system, event_name, var_name);\n\tif (!file)\n\t\treturn NULL;\n\n\thist_field = find_file_var(file, var_name);\n\n\treturn hist_field;\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct hist_field *find_event_var(struct hist_trigger_data *hist_data,\n\t\t\t\t\t char *system,\n\t\t\t\t\t char *event_name,\n\t\t\t\t\t char *var_name)\n{\n\tstruct trace_array *tr = hist_data->event_file->tr;\n\tstruct hist_field *hist_field = NULL;\n\tstruct trace_event_file *file;\n\n\tif (!system || !event_name) {\n\t\thist_field = find_match_var(hist_data, var_name);\n\t\tif (IS_ERR(hist_field))\n\t\t\treturn NULL;\n\t\tif (hist_field)\n\t\t\treturn hist_field;\n\t}\n\n\tfile = find_var_file(tr, system, event_name, var_name);\n\tif (!file)\n\t\treturn NULL;\n\n\thist_field = find_file_var(file, var_name);\n\n\treturn hist_field;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "synthetic_name",
            "field_name"
          ],
          "line": 2844
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "synthetic_name",
            "\"synthetic_\""
          ],
          "line": 2843
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 2841
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "MAX_FILTER_STR_VAL",
            "GFP_KERNEL"
          ],
          "line": 2839
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct hist_field *\nfind_synthetic_field_var(struct hist_trigger_data *target_hist_data,\n\t\t\t char *system, char *event_name, char *field_name)\n{\n\tstruct hist_field *event_var;\n\tchar *synthetic_name;\n\n\tsynthetic_name = kzalloc(MAX_FILTER_STR_VAL, GFP_KERNEL);\n\tif (!synthetic_name)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tstrcpy(synthetic_name, \"synthetic_\");\n\tstrcat(synthetic_name, field_name);\n\n\tevent_var = find_event_var(target_hist_data, system, event_name, synthetic_name);\n\n\tkfree(synthetic_name);\n\n\treturn event_var;\n}"
  },
  {
    "function_name": "event_file",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
    "lines": "2820-2830",
    "snippet": "static struct trace_event_file *event_file(struct trace_array *tr,\n\t\t\t\t\t   char *system, char *event_name)\n{\n\tstruct trace_event_file *file;\n\n\tfile = __find_event_file(tr, system, event_name);\n\tif (!file)\n\t\treturn ERR_PTR(-EINVAL);\n\n\treturn file;\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include \"tracing_map.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EINVAL"
          ],
          "line": 2827
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__find_event_file",
          "args": [
            "tr",
            "system",
            "event_name"
          ],
          "line": 2825
        },
        "resolved": true,
        "details": {
          "function_name": "__find_event_file",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
          "lines": "2920-2940",
          "snippet": "struct trace_event_file *\n__find_event_file(struct trace_array *tr, const char *system, const char *event)\n{\n\tstruct trace_event_file *file;\n\tstruct trace_event_call *call;\n\tconst char *name;\n\n\tlist_for_each_entry(file, &tr->events, list) {\n\n\t\tcall = file->event_call;\n\t\tname = trace_event_name(call);\n\n\t\tif (!name || !call->class)\n\t\t\tcontinue;\n\n\t\tif (strcmp(event, name) == 0 &&\n\t\t    strcmp(system, call->class->system) == 0)\n\t\t\treturn file;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/syscall.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_npid_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_release(struct inode *inode, struct file *file);",
            "static void __add_event_to_tracers(struct trace_event_call *call);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_npid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\nstatic void __add_event_to_tracers(struct trace_event_call *call);\n\nstruct trace_event_file *\n__find_event_file(struct trace_array *tr, const char *system, const char *event)\n{\n\tstruct trace_event_file *file;\n\tstruct trace_event_call *call;\n\tconst char *name;\n\n\tlist_for_each_entry(file, &tr->events, list) {\n\n\t\tcall = file->event_call;\n\t\tname = trace_event_name(call);\n\n\t\tif (!name || !call->class)\n\t\t\tcontinue;\n\n\t\tif (strcmp(event, name) == 0 &&\n\t\t    strcmp(system, call->class->system) == 0)\n\t\t\treturn file;\n\t}\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct trace_event_file *event_file(struct trace_array *tr,\n\t\t\t\t\t   char *system, char *event_name)\n{\n\tstruct trace_event_file *file;\n\n\tfile = __find_event_file(tr, system, event_name);\n\tif (!file)\n\t\treturn ERR_PTR(-EINVAL);\n\n\treturn file;\n}"
  },
  {
    "function_name": "find_compatible_hist",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
    "lines": "2796-2818",
    "snippet": "static struct hist_trigger_data *\nfind_compatible_hist(struct hist_trigger_data *target_hist_data,\n\t\t     struct trace_event_file *file)\n{\n\tstruct hist_trigger_data *hist_data;\n\tstruct event_trigger_data *test;\n\tunsigned int n_keys;\n\n\tlockdep_assert_held(&event_mutex);\n\n\tn_keys = target_hist_data->n_fields - target_hist_data->n_vals;\n\n\tlist_for_each_entry(test, &file->triggers, list) {\n\t\tif (test->cmd_ops->trigger_type == ETT_EVENT_HIST) {\n\t\t\thist_data = test->private_data;\n\n\t\t\tif (compatible_keys(target_hist_data, hist_data, n_keys))\n\t\t\t\treturn hist_data;\n\t\t}\n\t}\n\n\treturn NULL;\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include \"tracing_map.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "compatible_keys",
          "args": [
            "target_hist_data",
            "hist_data",
            "n_keys"
          ],
          "line": 2812
        },
        "resolved": true,
        "details": {
          "function_name": "compatible_keys",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "2768-2794",
          "snippet": "static bool compatible_keys(struct hist_trigger_data *target_hist_data,\n\t\t\t    struct hist_trigger_data *hist_data,\n\t\t\t    unsigned int n_keys)\n{\n\tstruct hist_field *target_hist_field, *hist_field;\n\tunsigned int n, i, j;\n\n\tif (hist_data->n_fields - hist_data->n_vals != n_keys)\n\t\treturn false;\n\n\ti = hist_data->n_vals;\n\tj = target_hist_data->n_vals;\n\n\tfor (n = 0; n < n_keys; n++) {\n\t\thist_field = hist_data->fields[i + n];\n\t\ttarget_hist_field = target_hist_data->fields[j + n];\n\n\t\tif (strcmp(hist_field->type, target_hist_field->type) != 0)\n\t\t\treturn false;\n\t\tif (hist_field->size != target_hist_field->size)\n\t\t\treturn false;\n\t\tif (hist_field->is_signed != target_hist_field->is_signed)\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic bool compatible_keys(struct hist_trigger_data *target_hist_data,\n\t\t\t    struct hist_trigger_data *hist_data,\n\t\t\t    unsigned int n_keys)\n{\n\tstruct hist_field *target_hist_field, *hist_field;\n\tunsigned int n, i, j;\n\n\tif (hist_data->n_fields - hist_data->n_vals != n_keys)\n\t\treturn false;\n\n\ti = hist_data->n_vals;\n\tj = target_hist_data->n_vals;\n\n\tfor (n = 0; n < n_keys; n++) {\n\t\thist_field = hist_data->fields[i + n];\n\t\ttarget_hist_field = target_hist_data->fields[j + n];\n\n\t\tif (strcmp(hist_field->type, target_hist_field->type) != 0)\n\t\t\treturn false;\n\t\tif (hist_field->size != target_hist_field->size)\n\t\t\treturn false;\n\t\tif (hist_field->is_signed != target_hist_field->is_signed)\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "test",
            "&file->triggers",
            "list"
          ],
          "line": 2808
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&event_mutex"
          ],
          "line": 2804
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct hist_trigger_data *\nfind_compatible_hist(struct hist_trigger_data *target_hist_data,\n\t\t     struct trace_event_file *file)\n{\n\tstruct hist_trigger_data *hist_data;\n\tstruct event_trigger_data *test;\n\tunsigned int n_keys;\n\n\tlockdep_assert_held(&event_mutex);\n\n\tn_keys = target_hist_data->n_fields - target_hist_data->n_vals;\n\n\tlist_for_each_entry(test, &file->triggers, list) {\n\t\tif (test->cmd_ops->trigger_type == ETT_EVENT_HIST) {\n\t\t\thist_data = test->private_data;\n\n\t\t\tif (compatible_keys(target_hist_data, hist_data, n_keys))\n\t\t\t\treturn hist_data;\n\t\t}\n\t}\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "compatible_keys",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
    "lines": "2768-2794",
    "snippet": "static bool compatible_keys(struct hist_trigger_data *target_hist_data,\n\t\t\t    struct hist_trigger_data *hist_data,\n\t\t\t    unsigned int n_keys)\n{\n\tstruct hist_field *target_hist_field, *hist_field;\n\tunsigned int n, i, j;\n\n\tif (hist_data->n_fields - hist_data->n_vals != n_keys)\n\t\treturn false;\n\n\ti = hist_data->n_vals;\n\tj = target_hist_data->n_vals;\n\n\tfor (n = 0; n < n_keys; n++) {\n\t\thist_field = hist_data->fields[i + n];\n\t\ttarget_hist_field = target_hist_data->fields[j + n];\n\n\t\tif (strcmp(hist_field->type, target_hist_field->type) != 0)\n\t\t\treturn false;\n\t\tif (hist_field->size != target_hist_field->size)\n\t\t\treturn false;\n\t\tif (hist_field->is_signed != target_hist_field->is_signed)\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include \"tracing_map.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "hist_field->type",
            "target_hist_field->type"
          ],
          "line": 2785
        },
        "resolved": true,
        "details": {
          "function_name": "sym_strcmp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/report.c",
          "lines": "356-365",
          "snippet": "static int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}",
          "includes": [
            "#include \"encoding.h\"",
            "#include \"kcsan.h\"",
            "#include <linux/stacktrace.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/delay.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"encoding.h\"\n#include \"kcsan.h\"\n#include <linux/stacktrace.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/lockdep.h>\n#include <linux/kernel.h>\n#include <linux/kallsyms.h>\n#include <linux/jiffies.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n\nstatic int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic bool compatible_keys(struct hist_trigger_data *target_hist_data,\n\t\t\t    struct hist_trigger_data *hist_data,\n\t\t\t    unsigned int n_keys)\n{\n\tstruct hist_field *target_hist_field, *hist_field;\n\tunsigned int n, i, j;\n\n\tif (hist_data->n_fields - hist_data->n_vals != n_keys)\n\t\treturn false;\n\n\ti = hist_data->n_vals;\n\tj = target_hist_data->n_vals;\n\n\tfor (n = 0; n < n_keys; n++) {\n\t\thist_field = hist_data->fields[i + n];\n\t\ttarget_hist_field = target_hist_data->fields[j + n];\n\n\t\tif (strcmp(hist_field->type, target_hist_field->type) != 0)\n\t\t\treturn false;\n\t\tif (hist_field->size != target_hist_field->size)\n\t\t\treturn false;\n\t\tif (hist_field->is_signed != target_hist_field->is_signed)\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}"
  },
  {
    "function_name": "find_trigger_filter",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
    "lines": "2746-2761",
    "snippet": "static char *find_trigger_filter(struct hist_trigger_data *hist_data,\n\t\t\t\t struct trace_event_file *file)\n{\n\tstruct event_trigger_data *test;\n\n\tlockdep_assert_held(&event_mutex);\n\n\tlist_for_each_entry(test, &file->triggers, list) {\n\t\tif (test->cmd_ops->trigger_type == ETT_EVENT_HIST) {\n\t\t\tif (test->private_data == hist_data)\n\t\t\t\treturn test->filter_str;\n\t\t}\n\t}\n\n\treturn NULL;\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include \"tracing_map.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "test",
            "&file->triggers",
            "list"
          ],
          "line": 2753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&event_mutex"
          ],
          "line": 2751
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic char *find_trigger_filter(struct hist_trigger_data *hist_data,\n\t\t\t\t struct trace_event_file *file)\n{\n\tstruct event_trigger_data *test;\n\n\tlockdep_assert_held(&event_mutex);\n\n\tlist_for_each_entry(test, &file->triggers, list) {\n\t\tif (test->cmd_ops->trigger_type == ETT_EVENT_HIST) {\n\t\t\tif (test->private_data == hist_data)\n\t\t\t\treturn test->filter_str;\n\t\t}\n\t}\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "parse_expr",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
    "lines": "2564-2744",
    "snippet": "static struct hist_field *parse_expr(struct hist_trigger_data *hist_data,\n\t\t\t\t     struct trace_event_file *file,\n\t\t\t\t     char *str, unsigned long flags,\n\t\t\t\t     char *var_name, unsigned int *n_subexprs)\n{\n\tstruct hist_field *operand1 = NULL, *operand2 = NULL, *expr = NULL;\n\tstruct hist_field *var1 = NULL, *var2 = NULL;\n\tunsigned long operand_flags, operand2_flags;\n\tint field_op, ret = -EINVAL;\n\tchar *sep, *operand1_str;\n\thist_field_fn_t op_fn;\n\tbool combine_consts;\n\n\tif (*n_subexprs > 3) {\n\t\thist_err(file->tr, HIST_ERR_TOO_MANY_SUBEXPR, errpos(str));\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tfield_op = contains_operator(str, &sep);\n\n\tif (field_op == FIELD_OP_NONE)\n\t\treturn parse_atom(hist_data, file, str, &flags, var_name);\n\n\tif (field_op == FIELD_OP_UNARY_MINUS)\n\t\treturn parse_unary(hist_data, file, str, flags, var_name, n_subexprs);\n\n\t/* Binary operator found, increment n_subexprs */\n\t++*n_subexprs;\n\n\t/* Split the expression string at the root operator */\n\tif (!sep)\n\t\treturn ERR_PTR(-EINVAL);\n\n\t*sep = '\\0';\n\toperand1_str = str;\n\tstr = sep+1;\n\n\t/* Binary operator requires both operands */\n\tif (*operand1_str == '\\0' || *str == '\\0')\n\t\treturn ERR_PTR(-EINVAL);\n\n\toperand_flags = 0;\n\n\t/* LHS of string is an expression e.g. a+b in a+b+c */\n\toperand1 = parse_expr(hist_data, file, operand1_str, operand_flags, NULL, n_subexprs);\n\tif (IS_ERR(operand1))\n\t\treturn ERR_CAST(operand1);\n\n\tif (operand1->flags & HIST_FIELD_FL_STRING) {\n\t\thist_err(file->tr, HIST_ERR_INVALID_STR_OPERAND, errpos(operand1_str));\n\t\tret = -EINVAL;\n\t\tgoto free_op1;\n\t}\n\n\t/* RHS of string is another expression e.g. c in a+b+c */\n\toperand_flags = 0;\n\toperand2 = parse_expr(hist_data, file, str, operand_flags, NULL, n_subexprs);\n\tif (IS_ERR(operand2)) {\n\t\tret = PTR_ERR(operand2);\n\t\tgoto free_op1;\n\t}\n\tif (operand2->flags & HIST_FIELD_FL_STRING) {\n\t\thist_err(file->tr, HIST_ERR_INVALID_STR_OPERAND, errpos(str));\n\t\tret = -EINVAL;\n\t\tgoto free_operands;\n\t}\n\n\tswitch (field_op) {\n\tcase FIELD_OP_MINUS:\n\t\top_fn = hist_field_minus;\n\t\tbreak;\n\tcase FIELD_OP_PLUS:\n\t\top_fn = hist_field_plus;\n\t\tbreak;\n\tcase FIELD_OP_DIV:\n\t\top_fn = hist_field_div;\n\t\tbreak;\n\tcase FIELD_OP_MULT:\n\t\top_fn = hist_field_mult;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tgoto free_operands;\n\t}\n\n\tret = check_expr_operands(file->tr, operand1, operand2, &var1, &var2);\n\tif (ret)\n\t\tgoto free_operands;\n\n\toperand_flags = var1 ? var1->flags : operand1->flags;\n\toperand2_flags = var2 ? var2->flags : operand2->flags;\n\n\t/*\n\t * If both operands are constant, the expression can be\n\t * collapsed to a single constant.\n\t */\n\tcombine_consts = operand_flags & operand2_flags & HIST_FIELD_FL_CONST;\n\n\tflags |= combine_consts ? HIST_FIELD_FL_CONST : HIST_FIELD_FL_EXPR;\n\n\tflags |= operand1->flags &\n\t\t(HIST_FIELD_FL_TIMESTAMP | HIST_FIELD_FL_TIMESTAMP_USECS);\n\n\texpr = create_hist_field(hist_data, NULL, flags, var_name);\n\tif (!expr) {\n\t\tret = -ENOMEM;\n\t\tgoto free_operands;\n\t}\n\n\toperand1->read_once = true;\n\toperand2->read_once = true;\n\n\t/* The operands are now owned and free'd by 'expr' */\n\texpr->operands[0] = operand1;\n\texpr->operands[1] = operand2;\n\n\tif (field_op == FIELD_OP_DIV &&\n\t\t\toperand2_flags & HIST_FIELD_FL_CONST) {\n\t\tu64 divisor = var2 ? var2->constant : operand2->constant;\n\n\t\tif (!divisor) {\n\t\t\thist_err(file->tr, HIST_ERR_DIVISION_BY_ZERO, errpos(str));\n\t\t\tret = -EDOM;\n\t\t\tgoto free_expr;\n\t\t}\n\n\t\t/*\n\t\t * Copy the divisor here so we don't have to look it up\n\t\t * later if this is a var ref\n\t\t */\n\t\toperand2->constant = divisor;\n\t\top_fn = hist_field_get_div_fn(operand2);\n\t}\n\n\tif (combine_consts) {\n\t\tif (var1)\n\t\t\texpr->operands[0] = var1;\n\t\tif (var2)\n\t\t\texpr->operands[1] = var2;\n\n\t\texpr->constant = op_fn(expr, NULL, NULL, NULL, NULL);\n\n\t\texpr->operands[0] = NULL;\n\t\texpr->operands[1] = NULL;\n\n\t\t/*\n\t\t * var refs won't be destroyed immediately\n\t\t * See: destroy_hist_field()\n\t\t */\n\t\tdestroy_hist_field(operand2, 0);\n\t\tdestroy_hist_field(operand1, 0);\n\n\t\texpr->name = expr_str(expr, 0);\n\t} else {\n\t\texpr->fn = op_fn;\n\n\t\t/* The operand sizes should be the same, so just pick one */\n\t\texpr->size = operand1->size;\n\n\t\texpr->operator = field_op;\n\t\texpr->type = kstrdup_const(operand1->type, GFP_KERNEL);\n\t\tif (!expr->type) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto free_expr;\n\t\t}\n\n\t\texpr->name = expr_str(expr, 0);\n\t}\n\n\treturn expr;\n\nfree_operands:\n\tdestroy_hist_field(operand2, 0);\nfree_op1:\n\tdestroy_hist_field(operand1, 0);\n\treturn ERR_PTR(ret);\n\nfree_expr:\n\tdestroy_hist_field(expr, 0);\n\treturn ERR_PTR(ret);\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include \"tracing_map.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct hist_field *parse_expr(struct hist_trigger_data *hist_data,\n\t\t\t\t     struct trace_event_file *file,\n\t\t\t\t     char *str, unsigned long flags,\n\t\t\t\t     char *var_name, unsigned int *n_subexprs);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "ret"
          ],
          "line": 2743
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "destroy_hist_field",
          "args": [
            "expr",
            "0"
          ],
          "line": 2742
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_hist_field",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "1864-1882",
          "snippet": "static void destroy_hist_field(struct hist_field *hist_field,\n\t\t\t       unsigned int level)\n{\n\tunsigned int i;\n\n\tif (level > 3)\n\t\treturn;\n\n\tif (!hist_field)\n\t\treturn;\n\n\tif (hist_field->flags & HIST_FIELD_FL_VAR_REF)\n\t\treturn; /* var refs will be destroyed separately */\n\n\tfor (i = 0; i < HIST_FIELD_OPERANDS_MAX; i++)\n\t\tdestroy_hist_field(hist_field->operands[i], level + 1);\n\n\t__destroy_hist_field(hist_field);\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define HIST_FIELD_OPERANDS_MAX\t2"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\n#define HIST_FIELD_OPERANDS_MAX\t2\n\nstatic void destroy_hist_field(struct hist_field *hist_field,\n\t\t\t       unsigned int level)\n{\n\tunsigned int i;\n\n\tif (level > 3)\n\t\treturn;\n\n\tif (!hist_field)\n\t\treturn;\n\n\tif (hist_field->flags & HIST_FIELD_FL_VAR_REF)\n\t\treturn; /* var refs will be destroyed separately */\n\n\tfor (i = 0; i < HIST_FIELD_OPERANDS_MAX; i++)\n\t\tdestroy_hist_field(hist_field->operands[i], level + 1);\n\n\t__destroy_hist_field(hist_field);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "ret"
          ],
          "line": 2739
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "expr_str",
          "args": [
            "expr",
            "0"
          ],
          "line": 2730
        },
        "resolved": true,
        "details": {
          "function_name": "expr_str",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "1693-1749",
          "snippet": "static char *expr_str(struct hist_field *field, unsigned int level)\n{\n\tchar *expr;\n\n\tif (level > 1)\n\t\treturn NULL;\n\n\texpr = kzalloc(MAX_FILTER_STR_VAL, GFP_KERNEL);\n\tif (!expr)\n\t\treturn NULL;\n\n\tif (!field->operands[0]) {\n\t\texpr_field_str(field, expr);\n\t\treturn expr;\n\t}\n\n\tif (field->operator == FIELD_OP_UNARY_MINUS) {\n\t\tchar *subexpr;\n\n\t\tstrcat(expr, \"-(\");\n\t\tsubexpr = expr_str(field->operands[0], ++level);\n\t\tif (!subexpr) {\n\t\t\tkfree(expr);\n\t\t\treturn NULL;\n\t\t}\n\t\tstrcat(expr, subexpr);\n\t\tstrcat(expr, \")\");\n\n\t\tkfree(subexpr);\n\n\t\treturn expr;\n\t}\n\n\texpr_field_str(field->operands[0], expr);\n\n\tswitch (field->operator) {\n\tcase FIELD_OP_MINUS:\n\t\tstrcat(expr, \"-\");\n\t\tbreak;\n\tcase FIELD_OP_PLUS:\n\t\tstrcat(expr, \"+\");\n\t\tbreak;\n\tcase FIELD_OP_DIV:\n\t\tstrcat(expr, \"/\");\n\t\tbreak;\n\tcase FIELD_OP_MULT:\n\t\tstrcat(expr, \"*\");\n\t\tbreak;\n\tdefault:\n\t\tkfree(expr);\n\t\treturn NULL;\n\t}\n\n\texpr_field_str(field->operands[1], expr);\n\n\treturn expr;\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic char *expr_str(struct hist_field *field, unsigned int level)\n{\n\tchar *expr;\n\n\tif (level > 1)\n\t\treturn NULL;\n\n\texpr = kzalloc(MAX_FILTER_STR_VAL, GFP_KERNEL);\n\tif (!expr)\n\t\treturn NULL;\n\n\tif (!field->operands[0]) {\n\t\texpr_field_str(field, expr);\n\t\treturn expr;\n\t}\n\n\tif (field->operator == FIELD_OP_UNARY_MINUS) {\n\t\tchar *subexpr;\n\n\t\tstrcat(expr, \"-(\");\n\t\tsubexpr = expr_str(field->operands[0], ++level);\n\t\tif (!subexpr) {\n\t\t\tkfree(expr);\n\t\t\treturn NULL;\n\t\t}\n\t\tstrcat(expr, subexpr);\n\t\tstrcat(expr, \")\");\n\n\t\tkfree(subexpr);\n\n\t\treturn expr;\n\t}\n\n\texpr_field_str(field->operands[0], expr);\n\n\tswitch (field->operator) {\n\tcase FIELD_OP_MINUS:\n\t\tstrcat(expr, \"-\");\n\t\tbreak;\n\tcase FIELD_OP_PLUS:\n\t\tstrcat(expr, \"+\");\n\t\tbreak;\n\tcase FIELD_OP_DIV:\n\t\tstrcat(expr, \"/\");\n\t\tbreak;\n\tcase FIELD_OP_MULT:\n\t\tstrcat(expr, \"*\");\n\t\tbreak;\n\tdefault:\n\t\tkfree(expr);\n\t\treturn NULL;\n\t}\n\n\texpr_field_str(field->operands[1], expr);\n\n\treturn expr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kstrdup_const",
          "args": [
            "operand1->type",
            "GFP_KERNEL"
          ],
          "line": 2724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "op_fn",
          "args": [
            "expr",
            "NULL",
            "NULL",
            "NULL",
            "NULL"
          ],
          "line": 2704
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hist_field_get_div_fn",
          "args": [
            "operand2"
          ],
          "line": 2695
        },
        "resolved": true,
        "details": {
          "function_name": "hist_field_get_div_fn",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "660-673",
          "snippet": "static hist_field_fn_t hist_field_get_div_fn(struct hist_field *divisor)\n{\n\tu64 div = divisor->constant;\n\n\tif (!(div & (div - 1)))\n\t\treturn div_by_power_of_two;\n\n\t/* If the divisor is too large, do a regular division */\n\tif (div > (1 << HIST_DIV_SHIFT))\n\t\treturn div_by_not_power_of_two;\n\n\tdivisor->div_multiplier = div64_u64((u64)(1 << HIST_DIV_SHIFT), div);\n\treturn div_by_mult_and_shift;\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define HIST_DIV_SHIFT\t\t20  /* For optimizing division by constants */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\n#define HIST_DIV_SHIFT\t\t20  /* For optimizing division by constants */\n\nstatic hist_field_fn_t hist_field_get_div_fn(struct hist_field *divisor)\n{\n\tu64 div = divisor->constant;\n\n\tif (!(div & (div - 1)))\n\t\treturn div_by_power_of_two;\n\n\t/* If the divisor is too large, do a regular division */\n\tif (div > (1 << HIST_DIV_SHIFT))\n\t\treturn div_by_not_power_of_two;\n\n\tdivisor->div_multiplier = div64_u64((u64)(1 << HIST_DIV_SHIFT), div);\n\treturn div_by_mult_and_shift;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hist_err",
          "args": [
            "file->tr",
            "HIST_ERR_DIVISION_BY_ZERO",
            "errpos(str)"
          ],
          "line": 2685
        },
        "resolved": true,
        "details": {
          "function_name": "hist_err",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "763-767",
          "snippet": "static void hist_err(struct trace_array *tr, u8 err_type, u8 err_pos)\n{\n\ttracing_log_err(tr, last_cmd_loc, last_cmd, err_text,\n\t\t\terr_type, err_pos);\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *err_text[] = { ERRORS };",
            "static char last_cmd[MAX_FILTER_STR_VAL];",
            "static char last_cmd_loc[MAX_FILTER_STR_VAL];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic const char *err_text[] = { ERRORS };\nstatic char last_cmd[MAX_FILTER_STR_VAL];\nstatic char last_cmd_loc[MAX_FILTER_STR_VAL];\n\nstatic void hist_err(struct trace_array *tr, u8 err_type, u8 err_pos)\n{\n\ttracing_log_err(tr, last_cmd_loc, last_cmd, err_text,\n\t\t\terr_type, err_pos);\n}"
        }
      },
      {
        "call_info": {
          "callee": "errpos",
          "args": [
            "str"
          ],
          "line": 2685
        },
        "resolved": true,
        "details": {
          "function_name": "errpos",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "733-736",
          "snippet": "static int errpos(char *str)\n{\n\treturn err_pos(last_cmd, str);\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char last_cmd[MAX_FILTER_STR_VAL];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic char last_cmd[MAX_FILTER_STR_VAL];\n\nstatic int errpos(char *str)\n{\n\treturn err_pos(last_cmd, str);\n}"
        }
      },
      {
        "call_info": {
          "callee": "create_hist_field",
          "args": [
            "hist_data",
            "NULL",
            "flags",
            "var_name"
          ],
          "line": 2667
        },
        "resolved": true,
        "details": {
          "function_name": "create_hist_field",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "1884-2007",
          "snippet": "static struct hist_field *create_hist_field(struct hist_trigger_data *hist_data,\n\t\t\t\t\t    struct ftrace_event_field *field,\n\t\t\t\t\t    unsigned long flags,\n\t\t\t\t\t    char *var_name)\n{\n\tstruct hist_field *hist_field;\n\n\tif (field && is_function_field(field))\n\t\treturn NULL;\n\n\thist_field = kzalloc(sizeof(struct hist_field), GFP_KERNEL);\n\tif (!hist_field)\n\t\treturn NULL;\n\n\thist_field->ref = 1;\n\n\thist_field->hist_data = hist_data;\n\n\tif (flags & HIST_FIELD_FL_EXPR || flags & HIST_FIELD_FL_ALIAS)\n\t\tgoto out; /* caller will populate */\n\n\tif (flags & HIST_FIELD_FL_VAR_REF) {\n\t\thist_field->fn = hist_field_var_ref;\n\t\tgoto out;\n\t}\n\n\tif (flags & HIST_FIELD_FL_HITCOUNT) {\n\t\thist_field->fn = hist_field_counter;\n\t\thist_field->size = sizeof(u64);\n\t\thist_field->type = \"u64\";\n\t\tgoto out;\n\t}\n\n\tif (flags & HIST_FIELD_FL_CONST) {\n\t\thist_field->fn = hist_field_const;\n\t\thist_field->size = sizeof(u64);\n\t\thist_field->type = kstrdup(\"u64\", GFP_KERNEL);\n\t\tif (!hist_field->type)\n\t\t\tgoto free;\n\t\tgoto out;\n\t}\n\n\tif (flags & HIST_FIELD_FL_STACKTRACE) {\n\t\thist_field->fn = hist_field_none;\n\t\tgoto out;\n\t}\n\n\tif (flags & (HIST_FIELD_FL_LOG2 | HIST_FIELD_FL_BUCKET)) {\n\t\tunsigned long fl = flags & ~(HIST_FIELD_FL_LOG2 | HIST_FIELD_FL_BUCKET);\n\t\thist_field->fn = flags & HIST_FIELD_FL_LOG2 ? hist_field_log2 :\n\t\t\thist_field_bucket;\n\t\thist_field->operands[0] = create_hist_field(hist_data, field, fl, NULL);\n\t\thist_field->size = hist_field->operands[0]->size;\n\t\thist_field->type = kstrdup_const(hist_field->operands[0]->type, GFP_KERNEL);\n\t\tif (!hist_field->type)\n\t\t\tgoto free;\n\t\tgoto out;\n\t}\n\n\tif (flags & HIST_FIELD_FL_TIMESTAMP) {\n\t\thist_field->fn = hist_field_timestamp;\n\t\thist_field->size = sizeof(u64);\n\t\thist_field->type = \"u64\";\n\t\tgoto out;\n\t}\n\n\tif (flags & HIST_FIELD_FL_CPU) {\n\t\thist_field->fn = hist_field_cpu;\n\t\thist_field->size = sizeof(int);\n\t\thist_field->type = \"unsigned int\";\n\t\tgoto out;\n\t}\n\n\tif (WARN_ON_ONCE(!field))\n\t\tgoto out;\n\n\t/* Pointers to strings are just pointers and dangerous to dereference */\n\tif (is_string_field(field) &&\n\t    (field->filter_type != FILTER_PTR_STRING)) {\n\t\tflags |= HIST_FIELD_FL_STRING;\n\n\t\thist_field->size = MAX_FILTER_STR_VAL;\n\t\thist_field->type = kstrdup_const(field->type, GFP_KERNEL);\n\t\tif (!hist_field->type)\n\t\t\tgoto free;\n\n\t\tif (field->filter_type == FILTER_STATIC_STRING) {\n\t\t\thist_field->fn = hist_field_string;\n\t\t\thist_field->size = field->size;\n\t\t} else if (field->filter_type == FILTER_DYN_STRING) {\n\t\t\thist_field->fn = hist_field_dynstring;\n\t\t} else if (field->filter_type == FILTER_RDYN_STRING)\n\t\t\thist_field->fn = hist_field_reldynstring;\n\t\telse\n\t\t\thist_field->fn = hist_field_pstring;\n\t} else {\n\t\thist_field->size = field->size;\n\t\thist_field->is_signed = field->is_signed;\n\t\thist_field->type = kstrdup_const(field->type, GFP_KERNEL);\n\t\tif (!hist_field->type)\n\t\t\tgoto free;\n\n\t\thist_field->fn = select_value_fn(field->size,\n\t\t\t\t\t\t field->is_signed);\n\t\tif (!hist_field->fn) {\n\t\t\tdestroy_hist_field(hist_field, 0);\n\t\t\treturn NULL;\n\t\t}\n\t}\n out:\n\thist_field->field = field;\n\thist_field->flags = flags;\n\n\tif (var_name) {\n\t\thist_field->var.name = kstrdup(var_name, GFP_KERNEL);\n\t\tif (!hist_field->var.name)\n\t\t\tgoto free;\n\t}\n\n\treturn hist_field;\n free:\n\tdestroy_hist_field(hist_field, 0);\n\treturn NULL;\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct hist_field *create_hist_field(struct hist_trigger_data *hist_data,\n\t\t\t\t\t    struct ftrace_event_field *field,\n\t\t\t\t\t    unsigned long flags,\n\t\t\t\t\t    char *var_name)\n{\n\tstruct hist_field *hist_field;\n\n\tif (field && is_function_field(field))\n\t\treturn NULL;\n\n\thist_field = kzalloc(sizeof(struct hist_field), GFP_KERNEL);\n\tif (!hist_field)\n\t\treturn NULL;\n\n\thist_field->ref = 1;\n\n\thist_field->hist_data = hist_data;\n\n\tif (flags & HIST_FIELD_FL_EXPR || flags & HIST_FIELD_FL_ALIAS)\n\t\tgoto out; /* caller will populate */\n\n\tif (flags & HIST_FIELD_FL_VAR_REF) {\n\t\thist_field->fn = hist_field_var_ref;\n\t\tgoto out;\n\t}\n\n\tif (flags & HIST_FIELD_FL_HITCOUNT) {\n\t\thist_field->fn = hist_field_counter;\n\t\thist_field->size = sizeof(u64);\n\t\thist_field->type = \"u64\";\n\t\tgoto out;\n\t}\n\n\tif (flags & HIST_FIELD_FL_CONST) {\n\t\thist_field->fn = hist_field_const;\n\t\thist_field->size = sizeof(u64);\n\t\thist_field->type = kstrdup(\"u64\", GFP_KERNEL);\n\t\tif (!hist_field->type)\n\t\t\tgoto free;\n\t\tgoto out;\n\t}\n\n\tif (flags & HIST_FIELD_FL_STACKTRACE) {\n\t\thist_field->fn = hist_field_none;\n\t\tgoto out;\n\t}\n\n\tif (flags & (HIST_FIELD_FL_LOG2 | HIST_FIELD_FL_BUCKET)) {\n\t\tunsigned long fl = flags & ~(HIST_FIELD_FL_LOG2 | HIST_FIELD_FL_BUCKET);\n\t\thist_field->fn = flags & HIST_FIELD_FL_LOG2 ? hist_field_log2 :\n\t\t\thist_field_bucket;\n\t\thist_field->operands[0] = create_hist_field(hist_data, field, fl, NULL);\n\t\thist_field->size = hist_field->operands[0]->size;\n\t\thist_field->type = kstrdup_const(hist_field->operands[0]->type, GFP_KERNEL);\n\t\tif (!hist_field->type)\n\t\t\tgoto free;\n\t\tgoto out;\n\t}\n\n\tif (flags & HIST_FIELD_FL_TIMESTAMP) {\n\t\thist_field->fn = hist_field_timestamp;\n\t\thist_field->size = sizeof(u64);\n\t\thist_field->type = \"u64\";\n\t\tgoto out;\n\t}\n\n\tif (flags & HIST_FIELD_FL_CPU) {\n\t\thist_field->fn = hist_field_cpu;\n\t\thist_field->size = sizeof(int);\n\t\thist_field->type = \"unsigned int\";\n\t\tgoto out;\n\t}\n\n\tif (WARN_ON_ONCE(!field))\n\t\tgoto out;\n\n\t/* Pointers to strings are just pointers and dangerous to dereference */\n\tif (is_string_field(field) &&\n\t    (field->filter_type != FILTER_PTR_STRING)) {\n\t\tflags |= HIST_FIELD_FL_STRING;\n\n\t\thist_field->size = MAX_FILTER_STR_VAL;\n\t\thist_field->type = kstrdup_const(field->type, GFP_KERNEL);\n\t\tif (!hist_field->type)\n\t\t\tgoto free;\n\n\t\tif (field->filter_type == FILTER_STATIC_STRING) {\n\t\t\thist_field->fn = hist_field_string;\n\t\t\thist_field->size = field->size;\n\t\t} else if (field->filter_type == FILTER_DYN_STRING) {\n\t\t\thist_field->fn = hist_field_dynstring;\n\t\t} else if (field->filter_type == FILTER_RDYN_STRING)\n\t\t\thist_field->fn = hist_field_reldynstring;\n\t\telse\n\t\t\thist_field->fn = hist_field_pstring;\n\t} else {\n\t\thist_field->size = field->size;\n\t\thist_field->is_signed = field->is_signed;\n\t\thist_field->type = kstrdup_const(field->type, GFP_KERNEL);\n\t\tif (!hist_field->type)\n\t\t\tgoto free;\n\n\t\thist_field->fn = select_value_fn(field->size,\n\t\t\t\t\t\t field->is_signed);\n\t\tif (!hist_field->fn) {\n\t\t\tdestroy_hist_field(hist_field, 0);\n\t\t\treturn NULL;\n\t\t}\n\t}\n out:\n\thist_field->field = field;\n\thist_field->flags = flags;\n\n\tif (var_name) {\n\t\thist_field->var.name = kstrdup(var_name, GFP_KERNEL);\n\t\tif (!hist_field->var.name)\n\t\t\tgoto free;\n\t}\n\n\treturn hist_field;\n free:\n\tdestroy_hist_field(hist_field, 0);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_expr_operands",
          "args": [
            "file->tr",
            "operand1",
            "operand2",
            "&var1",
            "&var2"
          ],
          "line": 2649
        },
        "resolved": true,
        "details": {
          "function_name": "check_expr_operands",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "2524-2562",
          "snippet": "static int check_expr_operands(struct trace_array *tr,\n\t\t\t       struct hist_field *operand1,\n\t\t\t       struct hist_field *operand2,\n\t\t\t       struct hist_field **var1,\n\t\t\t       struct hist_field **var2)\n{\n\tunsigned long operand1_flags = operand1->flags;\n\tunsigned long operand2_flags = operand2->flags;\n\n\tif ((operand1_flags & HIST_FIELD_FL_VAR_REF) ||\n\t    (operand1_flags & HIST_FIELD_FL_ALIAS)) {\n\t\tstruct hist_field *var;\n\n\t\tvar = find_var_field(operand1->var.hist_data, operand1->name);\n\t\tif (!var)\n\t\t\treturn -EINVAL;\n\t\toperand1_flags = var->flags;\n\t\t*var1 = var;\n\t}\n\n\tif ((operand2_flags & HIST_FIELD_FL_VAR_REF) ||\n\t    (operand2_flags & HIST_FIELD_FL_ALIAS)) {\n\t\tstruct hist_field *var;\n\n\t\tvar = find_var_field(operand2->var.hist_data, operand2->name);\n\t\tif (!var)\n\t\t\treturn -EINVAL;\n\t\toperand2_flags = var->flags;\n\t\t*var2 = var;\n\t}\n\n\tif ((operand1_flags & HIST_FIELD_FL_TIMESTAMP_USECS) !=\n\t    (operand2_flags & HIST_FIELD_FL_TIMESTAMP_USECS)) {\n\t\thist_err(tr, HIST_ERR_TIMESTAMP_MISMATCH, 0);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int check_expr_operands(struct trace_array *tr,\n\t\t\t       struct hist_field *operand1,\n\t\t\t       struct hist_field *operand2,\n\t\t\t       struct hist_field **var1,\n\t\t\t       struct hist_field **var2)\n{\n\tunsigned long operand1_flags = operand1->flags;\n\tunsigned long operand2_flags = operand2->flags;\n\n\tif ((operand1_flags & HIST_FIELD_FL_VAR_REF) ||\n\t    (operand1_flags & HIST_FIELD_FL_ALIAS)) {\n\t\tstruct hist_field *var;\n\n\t\tvar = find_var_field(operand1->var.hist_data, operand1->name);\n\t\tif (!var)\n\t\t\treturn -EINVAL;\n\t\toperand1_flags = var->flags;\n\t\t*var1 = var;\n\t}\n\n\tif ((operand2_flags & HIST_FIELD_FL_VAR_REF) ||\n\t    (operand2_flags & HIST_FIELD_FL_ALIAS)) {\n\t\tstruct hist_field *var;\n\n\t\tvar = find_var_field(operand2->var.hist_data, operand2->name);\n\t\tif (!var)\n\t\t\treturn -EINVAL;\n\t\toperand2_flags = var->flags;\n\t\t*var2 = var;\n\t}\n\n\tif ((operand1_flags & HIST_FIELD_FL_TIMESTAMP_USECS) !=\n\t    (operand2_flags & HIST_FIELD_FL_TIMESTAMP_USECS)) {\n\t\thist_err(tr, HIST_ERR_TIMESTAMP_MISMATCH, 0);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "operand2"
          ],
          "line": 2622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "operand2"
          ],
          "line": 2621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parse_expr",
          "args": [
            "hist_data",
            "file",
            "str",
            "operand_flags",
            "NULL",
            "n_subexprs"
          ],
          "line": 2620
        },
        "resolved": true,
        "details": {
          "function_name": "parse_expr",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "2564-2744",
          "snippet": "static struct hist_field *parse_expr(struct hist_trigger_data *hist_data,\n\t\t\t\t     struct trace_event_file *file,\n\t\t\t\t     char *str, unsigned long flags,\n\t\t\t\t     char *var_name, unsigned int *n_subexprs)\n{\n\tstruct hist_field *operand1 = NULL, *operand2 = NULL, *expr = NULL;\n\tstruct hist_field *var1 = NULL, *var2 = NULL;\n\tunsigned long operand_flags, operand2_flags;\n\tint field_op, ret = -EINVAL;\n\tchar *sep, *operand1_str;\n\thist_field_fn_t op_fn;\n\tbool combine_consts;\n\n\tif (*n_subexprs > 3) {\n\t\thist_err(file->tr, HIST_ERR_TOO_MANY_SUBEXPR, errpos(str));\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tfield_op = contains_operator(str, &sep);\n\n\tif (field_op == FIELD_OP_NONE)\n\t\treturn parse_atom(hist_data, file, str, &flags, var_name);\n\n\tif (field_op == FIELD_OP_UNARY_MINUS)\n\t\treturn parse_unary(hist_data, file, str, flags, var_name, n_subexprs);\n\n\t/* Binary operator found, increment n_subexprs */\n\t++*n_subexprs;\n\n\t/* Split the expression string at the root operator */\n\tif (!sep)\n\t\treturn ERR_PTR(-EINVAL);\n\n\t*sep = '\\0';\n\toperand1_str = str;\n\tstr = sep+1;\n\n\t/* Binary operator requires both operands */\n\tif (*operand1_str == '\\0' || *str == '\\0')\n\t\treturn ERR_PTR(-EINVAL);\n\n\toperand_flags = 0;\n\n\t/* LHS of string is an expression e.g. a+b in a+b+c */\n\toperand1 = parse_expr(hist_data, file, operand1_str, operand_flags, NULL, n_subexprs);\n\tif (IS_ERR(operand1))\n\t\treturn ERR_CAST(operand1);\n\n\tif (operand1->flags & HIST_FIELD_FL_STRING) {\n\t\thist_err(file->tr, HIST_ERR_INVALID_STR_OPERAND, errpos(operand1_str));\n\t\tret = -EINVAL;\n\t\tgoto free_op1;\n\t}\n\n\t/* RHS of string is another expression e.g. c in a+b+c */\n\toperand_flags = 0;\n\toperand2 = parse_expr(hist_data, file, str, operand_flags, NULL, n_subexprs);\n\tif (IS_ERR(operand2)) {\n\t\tret = PTR_ERR(operand2);\n\t\tgoto free_op1;\n\t}\n\tif (operand2->flags & HIST_FIELD_FL_STRING) {\n\t\thist_err(file->tr, HIST_ERR_INVALID_STR_OPERAND, errpos(str));\n\t\tret = -EINVAL;\n\t\tgoto free_operands;\n\t}\n\n\tswitch (field_op) {\n\tcase FIELD_OP_MINUS:\n\t\top_fn = hist_field_minus;\n\t\tbreak;\n\tcase FIELD_OP_PLUS:\n\t\top_fn = hist_field_plus;\n\t\tbreak;\n\tcase FIELD_OP_DIV:\n\t\top_fn = hist_field_div;\n\t\tbreak;\n\tcase FIELD_OP_MULT:\n\t\top_fn = hist_field_mult;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tgoto free_operands;\n\t}\n\n\tret = check_expr_operands(file->tr, operand1, operand2, &var1, &var2);\n\tif (ret)\n\t\tgoto free_operands;\n\n\toperand_flags = var1 ? var1->flags : operand1->flags;\n\toperand2_flags = var2 ? var2->flags : operand2->flags;\n\n\t/*\n\t * If both operands are constant, the expression can be\n\t * collapsed to a single constant.\n\t */\n\tcombine_consts = operand_flags & operand2_flags & HIST_FIELD_FL_CONST;\n\n\tflags |= combine_consts ? HIST_FIELD_FL_CONST : HIST_FIELD_FL_EXPR;\n\n\tflags |= operand1->flags &\n\t\t(HIST_FIELD_FL_TIMESTAMP | HIST_FIELD_FL_TIMESTAMP_USECS);\n\n\texpr = create_hist_field(hist_data, NULL, flags, var_name);\n\tif (!expr) {\n\t\tret = -ENOMEM;\n\t\tgoto free_operands;\n\t}\n\n\toperand1->read_once = true;\n\toperand2->read_once = true;\n\n\t/* The operands are now owned and free'd by 'expr' */\n\texpr->operands[0] = operand1;\n\texpr->operands[1] = operand2;\n\n\tif (field_op == FIELD_OP_DIV &&\n\t\t\toperand2_flags & HIST_FIELD_FL_CONST) {\n\t\tu64 divisor = var2 ? var2->constant : operand2->constant;\n\n\t\tif (!divisor) {\n\t\t\thist_err(file->tr, HIST_ERR_DIVISION_BY_ZERO, errpos(str));\n\t\t\tret = -EDOM;\n\t\t\tgoto free_expr;\n\t\t}\n\n\t\t/*\n\t\t * Copy the divisor here so we don't have to look it up\n\t\t * later if this is a var ref\n\t\t */\n\t\toperand2->constant = divisor;\n\t\top_fn = hist_field_get_div_fn(operand2);\n\t}\n\n\tif (combine_consts) {\n\t\tif (var1)\n\t\t\texpr->operands[0] = var1;\n\t\tif (var2)\n\t\t\texpr->operands[1] = var2;\n\n\t\texpr->constant = op_fn(expr, NULL, NULL, NULL, NULL);\n\n\t\texpr->operands[0] = NULL;\n\t\texpr->operands[1] = NULL;\n\n\t\t/*\n\t\t * var refs won't be destroyed immediately\n\t\t * See: destroy_hist_field()\n\t\t */\n\t\tdestroy_hist_field(operand2, 0);\n\t\tdestroy_hist_field(operand1, 0);\n\n\t\texpr->name = expr_str(expr, 0);\n\t} else {\n\t\texpr->fn = op_fn;\n\n\t\t/* The operand sizes should be the same, so just pick one */\n\t\texpr->size = operand1->size;\n\n\t\texpr->operator = field_op;\n\t\texpr->type = kstrdup_const(operand1->type, GFP_KERNEL);\n\t\tif (!expr->type) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto free_expr;\n\t\t}\n\n\t\texpr->name = expr_str(expr, 0);\n\t}\n\n\treturn expr;\n\nfree_operands:\n\tdestroy_hist_field(operand2, 0);\nfree_op1:\n\tdestroy_hist_field(operand1, 0);\n\treturn ERR_PTR(ret);\n\nfree_expr:\n\tdestroy_hist_field(expr, 0);\n\treturn ERR_PTR(ret);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "ERR_CAST",
          "args": [
            "operand1"
          ],
          "line": 2610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "operand1"
          ],
          "line": 2609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EINVAL"
          ],
          "line": 2603
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EINVAL"
          ],
          "line": 2595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parse_unary",
          "args": [
            "hist_data",
            "file",
            "str",
            "flags",
            "var_name",
            "n_subexprs"
          ],
          "line": 2588
        },
        "resolved": true,
        "details": {
          "function_name": "parse_unary",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "2434-2518",
          "snippet": "static struct hist_field *parse_unary(struct hist_trigger_data *hist_data,\n\t\t\t\t      struct trace_event_file *file,\n\t\t\t\t      char *str, unsigned long flags,\n\t\t\t\t      char *var_name, unsigned int *n_subexprs)\n{\n\tstruct hist_field *operand1, *expr = NULL;\n\tunsigned long operand_flags;\n\tint ret = 0;\n\tchar *s;\n\n\t/* Unary minus operator, increment n_subexprs */\n\t++*n_subexprs;\n\n\t/* we support only -(xxx) i.e. explicit parens required */\n\n\tif (*n_subexprs > 3) {\n\t\thist_err(file->tr, HIST_ERR_TOO_MANY_SUBEXPR, errpos(str));\n\t\tret = -EINVAL;\n\t\tgoto free;\n\t}\n\n\tstr++; /* skip leading '-' */\n\n\ts = strchr(str, '(');\n\tif (s)\n\t\tstr++;\n\telse {\n\t\tret = -EINVAL;\n\t\tgoto free;\n\t}\n\n\ts = strrchr(str, ')');\n\tif (s) {\n\t\t /* unary minus not supported in sub-expressions */\n\t\tif (*(s+1) != '\\0') {\n\t\t\thist_err(file->tr, HIST_ERR_UNARY_MINUS_SUBEXPR,\n\t\t\t\t errpos(str));\n\t\t\tret = -EINVAL;\n\t\t\tgoto free;\n\t\t}\n\t\t*s = '\\0';\n\t}\n\telse {\n\t\tret = -EINVAL; /* no closing ')' */\n\t\tgoto free;\n\t}\n\n\tflags |= HIST_FIELD_FL_EXPR;\n\texpr = create_hist_field(hist_data, NULL, flags, var_name);\n\tif (!expr) {\n\t\tret = -ENOMEM;\n\t\tgoto free;\n\t}\n\n\toperand_flags = 0;\n\toperand1 = parse_expr(hist_data, file, str, operand_flags, NULL, n_subexprs);\n\tif (IS_ERR(operand1)) {\n\t\tret = PTR_ERR(operand1);\n\t\tgoto free;\n\t}\n\tif (operand1->flags & HIST_FIELD_FL_STRING) {\n\t\t/* String type can not be the operand of unary operator. */\n\t\thist_err(file->tr, HIST_ERR_INVALID_STR_OPERAND, errpos(str));\n\t\tdestroy_hist_field(operand1, 0);\n\t\tret = -EINVAL;\n\t\tgoto free;\n\t}\n\n\texpr->flags |= operand1->flags &\n\t\t(HIST_FIELD_FL_TIMESTAMP | HIST_FIELD_FL_TIMESTAMP_USECS);\n\texpr->fn = hist_field_unary_minus;\n\texpr->operands[0] = operand1;\n\texpr->operator = FIELD_OP_UNARY_MINUS;\n\texpr->name = expr_str(expr, 0);\n\texpr->type = kstrdup_const(operand1->type, GFP_KERNEL);\n\tif (!expr->type) {\n\t\tret = -ENOMEM;\n\t\tgoto free;\n\t}\n\n\treturn expr;\n free:\n\tdestroy_hist_field(expr, 0);\n\treturn ERR_PTR(ret);\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hist_field *parse_expr(struct hist_trigger_data *hist_data,\n\t\t\t\t     struct trace_event_file *file,\n\t\t\t\t     char *str, unsigned long flags,\n\t\t\t\t     char *var_name, unsigned int *n_subexprs);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct hist_field *parse_expr(struct hist_trigger_data *hist_data,\n\t\t\t\t     struct trace_event_file *file,\n\t\t\t\t     char *str, unsigned long flags,\n\t\t\t\t     char *var_name, unsigned int *n_subexprs);\n\nstatic struct hist_field *parse_unary(struct hist_trigger_data *hist_data,\n\t\t\t\t      struct trace_event_file *file,\n\t\t\t\t      char *str, unsigned long flags,\n\t\t\t\t      char *var_name, unsigned int *n_subexprs)\n{\n\tstruct hist_field *operand1, *expr = NULL;\n\tunsigned long operand_flags;\n\tint ret = 0;\n\tchar *s;\n\n\t/* Unary minus operator, increment n_subexprs */\n\t++*n_subexprs;\n\n\t/* we support only -(xxx) i.e. explicit parens required */\n\n\tif (*n_subexprs > 3) {\n\t\thist_err(file->tr, HIST_ERR_TOO_MANY_SUBEXPR, errpos(str));\n\t\tret = -EINVAL;\n\t\tgoto free;\n\t}\n\n\tstr++; /* skip leading '-' */\n\n\ts = strchr(str, '(');\n\tif (s)\n\t\tstr++;\n\telse {\n\t\tret = -EINVAL;\n\t\tgoto free;\n\t}\n\n\ts = strrchr(str, ')');\n\tif (s) {\n\t\t /* unary minus not supported in sub-expressions */\n\t\tif (*(s+1) != '\\0') {\n\t\t\thist_err(file->tr, HIST_ERR_UNARY_MINUS_SUBEXPR,\n\t\t\t\t errpos(str));\n\t\t\tret = -EINVAL;\n\t\t\tgoto free;\n\t\t}\n\t\t*s = '\\0';\n\t}\n\telse {\n\t\tret = -EINVAL; /* no closing ')' */\n\t\tgoto free;\n\t}\n\n\tflags |= HIST_FIELD_FL_EXPR;\n\texpr = create_hist_field(hist_data, NULL, flags, var_name);\n\tif (!expr) {\n\t\tret = -ENOMEM;\n\t\tgoto free;\n\t}\n\n\toperand_flags = 0;\n\toperand1 = parse_expr(hist_data, file, str, operand_flags, NULL, n_subexprs);\n\tif (IS_ERR(operand1)) {\n\t\tret = PTR_ERR(operand1);\n\t\tgoto free;\n\t}\n\tif (operand1->flags & HIST_FIELD_FL_STRING) {\n\t\t/* String type can not be the operand of unary operator. */\n\t\thist_err(file->tr, HIST_ERR_INVALID_STR_OPERAND, errpos(str));\n\t\tdestroy_hist_field(operand1, 0);\n\t\tret = -EINVAL;\n\t\tgoto free;\n\t}\n\n\texpr->flags |= operand1->flags &\n\t\t(HIST_FIELD_FL_TIMESTAMP | HIST_FIELD_FL_TIMESTAMP_USECS);\n\texpr->fn = hist_field_unary_minus;\n\texpr->operands[0] = operand1;\n\texpr->operator = FIELD_OP_UNARY_MINUS;\n\texpr->name = expr_str(expr, 0);\n\texpr->type = kstrdup_const(operand1->type, GFP_KERNEL);\n\tif (!expr->type) {\n\t\tret = -ENOMEM;\n\t\tgoto free;\n\t}\n\n\treturn expr;\n free:\n\tdestroy_hist_field(expr, 0);\n\treturn ERR_PTR(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "parse_atom",
          "args": [
            "hist_data",
            "file",
            "str",
            "&flags",
            "var_name"
          ],
          "line": 2585
        },
        "resolved": true,
        "details": {
          "function_name": "parse_atom",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "2357-2427",
          "snippet": "static struct hist_field *parse_atom(struct hist_trigger_data *hist_data,\n\t\t\t\t     struct trace_event_file *file, char *str,\n\t\t\t\t     unsigned long *flags, char *var_name)\n{\n\tchar *s, *ref_system = NULL, *ref_event = NULL, *ref_var = str;\n\tstruct ftrace_event_field *field = NULL;\n\tstruct hist_field *hist_field = NULL;\n\tunsigned long buckets = 0;\n\tint ret = 0;\n\n\tif (isdigit(str[0])) {\n\t\thist_field = parse_const(hist_data, str, var_name, flags);\n\t\tif (!hist_field) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\treturn hist_field;\n\t}\n\n\ts = strchr(str, '.');\n\tif (s) {\n\t\ts = strchr(++s, '.');\n\t\tif (s) {\n\t\t\tref_system = strsep(&str, \".\");\n\t\t\tif (!str) {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tref_event = strsep(&str, \".\");\n\t\t\tif (!str) {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tref_var = str;\n\t\t}\n\t}\n\n\ts = local_field_var_ref(hist_data, ref_system, ref_event, ref_var);\n\tif (!s) {\n\t\thist_field = parse_var_ref(hist_data, ref_system,\n\t\t\t\t\t   ref_event, ref_var);\n\t\tif (hist_field) {\n\t\t\tif (var_name) {\n\t\t\t\thist_field = create_alias(hist_data, hist_field, var_name);\n\t\t\t\tif (!hist_field) {\n\t\t\t\t\tret = -ENOMEM;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn hist_field;\n\t\t}\n\t} else\n\t\tstr = s;\n\n\tfield = parse_field(hist_data, file, str, flags, &buckets);\n\tif (IS_ERR(field)) {\n\t\tret = PTR_ERR(field);\n\t\tgoto out;\n\t}\n\n\thist_field = create_hist_field(hist_data, field, *flags, var_name);\n\tif (!hist_field) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\thist_field->buckets = buckets;\n\n\treturn hist_field;\n out:\n\treturn ERR_PTR(ret);\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct hist_field *parse_atom(struct hist_trigger_data *hist_data,\n\t\t\t\t     struct trace_event_file *file, char *str,\n\t\t\t\t     unsigned long *flags, char *var_name)\n{\n\tchar *s, *ref_system = NULL, *ref_event = NULL, *ref_var = str;\n\tstruct ftrace_event_field *field = NULL;\n\tstruct hist_field *hist_field = NULL;\n\tunsigned long buckets = 0;\n\tint ret = 0;\n\n\tif (isdigit(str[0])) {\n\t\thist_field = parse_const(hist_data, str, var_name, flags);\n\t\tif (!hist_field) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\treturn hist_field;\n\t}\n\n\ts = strchr(str, '.');\n\tif (s) {\n\t\ts = strchr(++s, '.');\n\t\tif (s) {\n\t\t\tref_system = strsep(&str, \".\");\n\t\t\tif (!str) {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tref_event = strsep(&str, \".\");\n\t\t\tif (!str) {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tref_var = str;\n\t\t}\n\t}\n\n\ts = local_field_var_ref(hist_data, ref_system, ref_event, ref_var);\n\tif (!s) {\n\t\thist_field = parse_var_ref(hist_data, ref_system,\n\t\t\t\t\t   ref_event, ref_var);\n\t\tif (hist_field) {\n\t\t\tif (var_name) {\n\t\t\t\thist_field = create_alias(hist_data, hist_field, var_name);\n\t\t\t\tif (!hist_field) {\n\t\t\t\t\tret = -ENOMEM;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn hist_field;\n\t\t}\n\t} else\n\t\tstr = s;\n\n\tfield = parse_field(hist_data, file, str, flags, &buckets);\n\tif (IS_ERR(field)) {\n\t\tret = PTR_ERR(field);\n\t\tgoto out;\n\t}\n\n\thist_field = create_hist_field(hist_data, field, *flags, var_name);\n\tif (!hist_field) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\thist_field->buckets = buckets;\n\n\treturn hist_field;\n out:\n\treturn ERR_PTR(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "contains_operator",
          "args": [
            "str",
            "&sep"
          ],
          "line": 2582
        },
        "resolved": true,
        "details": {
          "function_name": "contains_operator",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "1755-1840",
          "snippet": "static int contains_operator(char *str, char **sep)\n{\n\tenum field_op_id field_op = FIELD_OP_NONE;\n\tchar *minus_op, *plus_op, *div_op, *mult_op;\n\n\n\t/*\n\t * Report the last occurrence of the operators first, so that the\n\t * expression is evaluated left to right. This is important since\n\t * subtraction and division are not associative.\n\t *\n\t *\te.g\n\t *\t\t64/8/4/2 is 1, i.e 64/8/4/2 = ((64/8)/4)/2\n\t *\t\t14-7-5-2 is 0, i.e 14-7-5-2 = ((14-7)-5)-2\n\t */\n\n\t/*\n\t * First, find lower precedence addition and subtraction\n\t * since the expression will be evaluated recursively.\n\t */\n\tminus_op = strrchr(str, '-');\n\tif (minus_op) {\n\t\t/*\n\t\t * Unary minus is not supported in sub-expressions. If\n\t\t * present, it is always the next root operator.\n\t\t */\n\t\tif (minus_op == str) {\n\t\t\tfield_op = FIELD_OP_UNARY_MINUS;\n\t\t\tgoto out;\n\t\t}\n\n\t\tfield_op = FIELD_OP_MINUS;\n\t}\n\n\tplus_op = strrchr(str, '+');\n\tif (plus_op || minus_op) {\n\t\t/*\n\t\t * For operators of the same precedence use to rightmost as the\n\t\t * root, so that the expression is evaluated left to right.\n\t\t */\n\t\tif (plus_op > minus_op)\n\t\t\tfield_op = FIELD_OP_PLUS;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Multiplication and division have higher precedence than addition and\n\t * subtraction.\n\t */\n\tdiv_op = strrchr(str, '/');\n\tif (div_op)\n\t\tfield_op = FIELD_OP_DIV;\n\n\tmult_op = strrchr(str, '*');\n\t/*\n\t * For operators of the same precedence use to rightmost as the\n\t * root, so that the expression is evaluated left to right.\n\t */\n\tif (mult_op > div_op)\n\t\tfield_op = FIELD_OP_MULT;\n\nout:\n\tif (sep) {\n\t\tswitch (field_op) {\n\t\tcase FIELD_OP_UNARY_MINUS:\n\t\tcase FIELD_OP_MINUS:\n\t\t\t*sep = minus_op;\n\t\t\tbreak;\n\t\tcase FIELD_OP_PLUS:\n\t\t\t*sep = plus_op;\n\t\t\tbreak;\n\t\tcase FIELD_OP_DIV:\n\t\t\t*sep = div_op;\n\t\t\tbreak;\n\t\tcase FIELD_OP_MULT:\n\t\t\t*sep = mult_op;\n\t\t\tbreak;\n\t\tcase FIELD_OP_NONE:\n\t\tdefault:\n\t\t\t*sep = NULL;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn field_op;\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int contains_operator(char *str, char **sep)\n{\n\tenum field_op_id field_op = FIELD_OP_NONE;\n\tchar *minus_op, *plus_op, *div_op, *mult_op;\n\n\n\t/*\n\t * Report the last occurrence of the operators first, so that the\n\t * expression is evaluated left to right. This is important since\n\t * subtraction and division are not associative.\n\t *\n\t *\te.g\n\t *\t\t64/8/4/2 is 1, i.e 64/8/4/2 = ((64/8)/4)/2\n\t *\t\t14-7-5-2 is 0, i.e 14-7-5-2 = ((14-7)-5)-2\n\t */\n\n\t/*\n\t * First, find lower precedence addition and subtraction\n\t * since the expression will be evaluated recursively.\n\t */\n\tminus_op = strrchr(str, '-');\n\tif (minus_op) {\n\t\t/*\n\t\t * Unary minus is not supported in sub-expressions. If\n\t\t * present, it is always the next root operator.\n\t\t */\n\t\tif (minus_op == str) {\n\t\t\tfield_op = FIELD_OP_UNARY_MINUS;\n\t\t\tgoto out;\n\t\t}\n\n\t\tfield_op = FIELD_OP_MINUS;\n\t}\n\n\tplus_op = strrchr(str, '+');\n\tif (plus_op || minus_op) {\n\t\t/*\n\t\t * For operators of the same precedence use to rightmost as the\n\t\t * root, so that the expression is evaluated left to right.\n\t\t */\n\t\tif (plus_op > minus_op)\n\t\t\tfield_op = FIELD_OP_PLUS;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Multiplication and division have higher precedence than addition and\n\t * subtraction.\n\t */\n\tdiv_op = strrchr(str, '/');\n\tif (div_op)\n\t\tfield_op = FIELD_OP_DIV;\n\n\tmult_op = strrchr(str, '*');\n\t/*\n\t * For operators of the same precedence use to rightmost as the\n\t * root, so that the expression is evaluated left to right.\n\t */\n\tif (mult_op > div_op)\n\t\tfield_op = FIELD_OP_MULT;\n\nout:\n\tif (sep) {\n\t\tswitch (field_op) {\n\t\tcase FIELD_OP_UNARY_MINUS:\n\t\tcase FIELD_OP_MINUS:\n\t\t\t*sep = minus_op;\n\t\t\tbreak;\n\t\tcase FIELD_OP_PLUS:\n\t\t\t*sep = plus_op;\n\t\t\tbreak;\n\t\tcase FIELD_OP_DIV:\n\t\t\t*sep = div_op;\n\t\t\tbreak;\n\t\tcase FIELD_OP_MULT:\n\t\t\t*sep = mult_op;\n\t\t\tbreak;\n\t\tcase FIELD_OP_NONE:\n\t\tdefault:\n\t\t\t*sep = NULL;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn field_op;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EINVAL"
          ],
          "line": 2579
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct hist_field *parse_expr(struct hist_trigger_data *hist_data,\n\t\t\t\t     struct trace_event_file *file,\n\t\t\t\t     char *str, unsigned long flags,\n\t\t\t\t     char *var_name, unsigned int *n_subexprs);\n\nstatic struct hist_field *parse_expr(struct hist_trigger_data *hist_data,\n\t\t\t\t     struct trace_event_file *file,\n\t\t\t\t     char *str, unsigned long flags,\n\t\t\t\t     char *var_name, unsigned int *n_subexprs)\n{\n\tstruct hist_field *operand1 = NULL, *operand2 = NULL, *expr = NULL;\n\tstruct hist_field *var1 = NULL, *var2 = NULL;\n\tunsigned long operand_flags, operand2_flags;\n\tint field_op, ret = -EINVAL;\n\tchar *sep, *operand1_str;\n\thist_field_fn_t op_fn;\n\tbool combine_consts;\n\n\tif (*n_subexprs > 3) {\n\t\thist_err(file->tr, HIST_ERR_TOO_MANY_SUBEXPR, errpos(str));\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tfield_op = contains_operator(str, &sep);\n\n\tif (field_op == FIELD_OP_NONE)\n\t\treturn parse_atom(hist_data, file, str, &flags, var_name);\n\n\tif (field_op == FIELD_OP_UNARY_MINUS)\n\t\treturn parse_unary(hist_data, file, str, flags, var_name, n_subexprs);\n\n\t/* Binary operator found, increment n_subexprs */\n\t++*n_subexprs;\n\n\t/* Split the expression string at the root operator */\n\tif (!sep)\n\t\treturn ERR_PTR(-EINVAL);\n\n\t*sep = '\\0';\n\toperand1_str = str;\n\tstr = sep+1;\n\n\t/* Binary operator requires both operands */\n\tif (*operand1_str == '\\0' || *str == '\\0')\n\t\treturn ERR_PTR(-EINVAL);\n\n\toperand_flags = 0;\n\n\t/* LHS of string is an expression e.g. a+b in a+b+c */\n\toperand1 = parse_expr(hist_data, file, operand1_str, operand_flags, NULL, n_subexprs);\n\tif (IS_ERR(operand1))\n\t\treturn ERR_CAST(operand1);\n\n\tif (operand1->flags & HIST_FIELD_FL_STRING) {\n\t\thist_err(file->tr, HIST_ERR_INVALID_STR_OPERAND, errpos(operand1_str));\n\t\tret = -EINVAL;\n\t\tgoto free_op1;\n\t}\n\n\t/* RHS of string is another expression e.g. c in a+b+c */\n\toperand_flags = 0;\n\toperand2 = parse_expr(hist_data, file, str, operand_flags, NULL, n_subexprs);\n\tif (IS_ERR(operand2)) {\n\t\tret = PTR_ERR(operand2);\n\t\tgoto free_op1;\n\t}\n\tif (operand2->flags & HIST_FIELD_FL_STRING) {\n\t\thist_err(file->tr, HIST_ERR_INVALID_STR_OPERAND, errpos(str));\n\t\tret = -EINVAL;\n\t\tgoto free_operands;\n\t}\n\n\tswitch (field_op) {\n\tcase FIELD_OP_MINUS:\n\t\top_fn = hist_field_minus;\n\t\tbreak;\n\tcase FIELD_OP_PLUS:\n\t\top_fn = hist_field_plus;\n\t\tbreak;\n\tcase FIELD_OP_DIV:\n\t\top_fn = hist_field_div;\n\t\tbreak;\n\tcase FIELD_OP_MULT:\n\t\top_fn = hist_field_mult;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tgoto free_operands;\n\t}\n\n\tret = check_expr_operands(file->tr, operand1, operand2, &var1, &var2);\n\tif (ret)\n\t\tgoto free_operands;\n\n\toperand_flags = var1 ? var1->flags : operand1->flags;\n\toperand2_flags = var2 ? var2->flags : operand2->flags;\n\n\t/*\n\t * If both operands are constant, the expression can be\n\t * collapsed to a single constant.\n\t */\n\tcombine_consts = operand_flags & operand2_flags & HIST_FIELD_FL_CONST;\n\n\tflags |= combine_consts ? HIST_FIELD_FL_CONST : HIST_FIELD_FL_EXPR;\n\n\tflags |= operand1->flags &\n\t\t(HIST_FIELD_FL_TIMESTAMP | HIST_FIELD_FL_TIMESTAMP_USECS);\n\n\texpr = create_hist_field(hist_data, NULL, flags, var_name);\n\tif (!expr) {\n\t\tret = -ENOMEM;\n\t\tgoto free_operands;\n\t}\n\n\toperand1->read_once = true;\n\toperand2->read_once = true;\n\n\t/* The operands are now owned and free'd by 'expr' */\n\texpr->operands[0] = operand1;\n\texpr->operands[1] = operand2;\n\n\tif (field_op == FIELD_OP_DIV &&\n\t\t\toperand2_flags & HIST_FIELD_FL_CONST) {\n\t\tu64 divisor = var2 ? var2->constant : operand2->constant;\n\n\t\tif (!divisor) {\n\t\t\thist_err(file->tr, HIST_ERR_DIVISION_BY_ZERO, errpos(str));\n\t\t\tret = -EDOM;\n\t\t\tgoto free_expr;\n\t\t}\n\n\t\t/*\n\t\t * Copy the divisor here so we don't have to look it up\n\t\t * later if this is a var ref\n\t\t */\n\t\toperand2->constant = divisor;\n\t\top_fn = hist_field_get_div_fn(operand2);\n\t}\n\n\tif (combine_consts) {\n\t\tif (var1)\n\t\t\texpr->operands[0] = var1;\n\t\tif (var2)\n\t\t\texpr->operands[1] = var2;\n\n\t\texpr->constant = op_fn(expr, NULL, NULL, NULL, NULL);\n\n\t\texpr->operands[0] = NULL;\n\t\texpr->operands[1] = NULL;\n\n\t\t/*\n\t\t * var refs won't be destroyed immediately\n\t\t * See: destroy_hist_field()\n\t\t */\n\t\tdestroy_hist_field(operand2, 0);\n\t\tdestroy_hist_field(operand1, 0);\n\n\t\texpr->name = expr_str(expr, 0);\n\t} else {\n\t\texpr->fn = op_fn;\n\n\t\t/* The operand sizes should be the same, so just pick one */\n\t\texpr->size = operand1->size;\n\n\t\texpr->operator = field_op;\n\t\texpr->type = kstrdup_const(operand1->type, GFP_KERNEL);\n\t\tif (!expr->type) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto free_expr;\n\t\t}\n\n\t\texpr->name = expr_str(expr, 0);\n\t}\n\n\treturn expr;\n\nfree_operands:\n\tdestroy_hist_field(operand2, 0);\nfree_op1:\n\tdestroy_hist_field(operand1, 0);\n\treturn ERR_PTR(ret);\n\nfree_expr:\n\tdestroy_hist_field(expr, 0);\n\treturn ERR_PTR(ret);\n}"
  },
  {
    "function_name": "check_expr_operands",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
    "lines": "2524-2562",
    "snippet": "static int check_expr_operands(struct trace_array *tr,\n\t\t\t       struct hist_field *operand1,\n\t\t\t       struct hist_field *operand2,\n\t\t\t       struct hist_field **var1,\n\t\t\t       struct hist_field **var2)\n{\n\tunsigned long operand1_flags = operand1->flags;\n\tunsigned long operand2_flags = operand2->flags;\n\n\tif ((operand1_flags & HIST_FIELD_FL_VAR_REF) ||\n\t    (operand1_flags & HIST_FIELD_FL_ALIAS)) {\n\t\tstruct hist_field *var;\n\n\t\tvar = find_var_field(operand1->var.hist_data, operand1->name);\n\t\tif (!var)\n\t\t\treturn -EINVAL;\n\t\toperand1_flags = var->flags;\n\t\t*var1 = var;\n\t}\n\n\tif ((operand2_flags & HIST_FIELD_FL_VAR_REF) ||\n\t    (operand2_flags & HIST_FIELD_FL_ALIAS)) {\n\t\tstruct hist_field *var;\n\n\t\tvar = find_var_field(operand2->var.hist_data, operand2->name);\n\t\tif (!var)\n\t\t\treturn -EINVAL;\n\t\toperand2_flags = var->flags;\n\t\t*var2 = var;\n\t}\n\n\tif ((operand1_flags & HIST_FIELD_FL_TIMESTAMP_USECS) !=\n\t    (operand2_flags & HIST_FIELD_FL_TIMESTAMP_USECS)) {\n\t\thist_err(tr, HIST_ERR_TIMESTAMP_MISMATCH, 0);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include \"tracing_map.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hist_err",
          "args": [
            "tr",
            "HIST_ERR_TIMESTAMP_MISMATCH",
            "0"
          ],
          "line": 2557
        },
        "resolved": true,
        "details": {
          "function_name": "hist_err",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "763-767",
          "snippet": "static void hist_err(struct trace_array *tr, u8 err_type, u8 err_pos)\n{\n\ttracing_log_err(tr, last_cmd_loc, last_cmd, err_text,\n\t\t\terr_type, err_pos);\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *err_text[] = { ERRORS };",
            "static char last_cmd[MAX_FILTER_STR_VAL];",
            "static char last_cmd_loc[MAX_FILTER_STR_VAL];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic const char *err_text[] = { ERRORS };\nstatic char last_cmd[MAX_FILTER_STR_VAL];\nstatic char last_cmd_loc[MAX_FILTER_STR_VAL];\n\nstatic void hist_err(struct trace_array *tr, u8 err_type, u8 err_pos)\n{\n\ttracing_log_err(tr, last_cmd_loc, last_cmd, err_text,\n\t\t\terr_type, err_pos);\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_var_field",
          "args": [
            "operand2->var.hist_data",
            "operand2->name"
          ],
          "line": 2548
        },
        "resolved": true,
        "details": {
          "function_name": "find_var_field",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "1061-1077",
          "snippet": "static struct hist_field *find_var_field(struct hist_trigger_data *hist_data,\n\t\t\t\t\t const char *var_name)\n{\n\tstruct hist_field *hist_field, *found = NULL;\n\tint i;\n\n\tfor_each_hist_field(i, hist_data) {\n\t\thist_field = hist_data->fields[i];\n\t\tif (hist_field && hist_field->flags & HIST_FIELD_FL_VAR &&\n\t\t    strcmp(hist_field->var.name, var_name) == 0) {\n\t\t\tfound = hist_field;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn found;\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct hist_field *find_var_field(struct hist_trigger_data *hist_data,\n\t\t\t\t\t const char *var_name)\n{\n\tstruct hist_field *hist_field, *found = NULL;\n\tint i;\n\n\tfor_each_hist_field(i, hist_data) {\n\t\thist_field = hist_data->fields[i];\n\t\tif (hist_field && hist_field->flags & HIST_FIELD_FL_VAR &&\n\t\t    strcmp(hist_field->var.name, var_name) == 0) {\n\t\t\tfound = hist_field;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn found;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int check_expr_operands(struct trace_array *tr,\n\t\t\t       struct hist_field *operand1,\n\t\t\t       struct hist_field *operand2,\n\t\t\t       struct hist_field **var1,\n\t\t\t       struct hist_field **var2)\n{\n\tunsigned long operand1_flags = operand1->flags;\n\tunsigned long operand2_flags = operand2->flags;\n\n\tif ((operand1_flags & HIST_FIELD_FL_VAR_REF) ||\n\t    (operand1_flags & HIST_FIELD_FL_ALIAS)) {\n\t\tstruct hist_field *var;\n\n\t\tvar = find_var_field(operand1->var.hist_data, operand1->name);\n\t\tif (!var)\n\t\t\treturn -EINVAL;\n\t\toperand1_flags = var->flags;\n\t\t*var1 = var;\n\t}\n\n\tif ((operand2_flags & HIST_FIELD_FL_VAR_REF) ||\n\t    (operand2_flags & HIST_FIELD_FL_ALIAS)) {\n\t\tstruct hist_field *var;\n\n\t\tvar = find_var_field(operand2->var.hist_data, operand2->name);\n\t\tif (!var)\n\t\t\treturn -EINVAL;\n\t\toperand2_flags = var->flags;\n\t\t*var2 = var;\n\t}\n\n\tif ((operand1_flags & HIST_FIELD_FL_TIMESTAMP_USECS) !=\n\t    (operand2_flags & HIST_FIELD_FL_TIMESTAMP_USECS)) {\n\t\thist_err(tr, HIST_ERR_TIMESTAMP_MISMATCH, 0);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "parse_unary",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
    "lines": "2434-2518",
    "snippet": "static struct hist_field *parse_unary(struct hist_trigger_data *hist_data,\n\t\t\t\t      struct trace_event_file *file,\n\t\t\t\t      char *str, unsigned long flags,\n\t\t\t\t      char *var_name, unsigned int *n_subexprs)\n{\n\tstruct hist_field *operand1, *expr = NULL;\n\tunsigned long operand_flags;\n\tint ret = 0;\n\tchar *s;\n\n\t/* Unary minus operator, increment n_subexprs */\n\t++*n_subexprs;\n\n\t/* we support only -(xxx) i.e. explicit parens required */\n\n\tif (*n_subexprs > 3) {\n\t\thist_err(file->tr, HIST_ERR_TOO_MANY_SUBEXPR, errpos(str));\n\t\tret = -EINVAL;\n\t\tgoto free;\n\t}\n\n\tstr++; /* skip leading '-' */\n\n\ts = strchr(str, '(');\n\tif (s)\n\t\tstr++;\n\telse {\n\t\tret = -EINVAL;\n\t\tgoto free;\n\t}\n\n\ts = strrchr(str, ')');\n\tif (s) {\n\t\t /* unary minus not supported in sub-expressions */\n\t\tif (*(s+1) != '\\0') {\n\t\t\thist_err(file->tr, HIST_ERR_UNARY_MINUS_SUBEXPR,\n\t\t\t\t errpos(str));\n\t\t\tret = -EINVAL;\n\t\t\tgoto free;\n\t\t}\n\t\t*s = '\\0';\n\t}\n\telse {\n\t\tret = -EINVAL; /* no closing ')' */\n\t\tgoto free;\n\t}\n\n\tflags |= HIST_FIELD_FL_EXPR;\n\texpr = create_hist_field(hist_data, NULL, flags, var_name);\n\tif (!expr) {\n\t\tret = -ENOMEM;\n\t\tgoto free;\n\t}\n\n\toperand_flags = 0;\n\toperand1 = parse_expr(hist_data, file, str, operand_flags, NULL, n_subexprs);\n\tif (IS_ERR(operand1)) {\n\t\tret = PTR_ERR(operand1);\n\t\tgoto free;\n\t}\n\tif (operand1->flags & HIST_FIELD_FL_STRING) {\n\t\t/* String type can not be the operand of unary operator. */\n\t\thist_err(file->tr, HIST_ERR_INVALID_STR_OPERAND, errpos(str));\n\t\tdestroy_hist_field(operand1, 0);\n\t\tret = -EINVAL;\n\t\tgoto free;\n\t}\n\n\texpr->flags |= operand1->flags &\n\t\t(HIST_FIELD_FL_TIMESTAMP | HIST_FIELD_FL_TIMESTAMP_USECS);\n\texpr->fn = hist_field_unary_minus;\n\texpr->operands[0] = operand1;\n\texpr->operator = FIELD_OP_UNARY_MINUS;\n\texpr->name = expr_str(expr, 0);\n\texpr->type = kstrdup_const(operand1->type, GFP_KERNEL);\n\tif (!expr->type) {\n\t\tret = -ENOMEM;\n\t\tgoto free;\n\t}\n\n\treturn expr;\n free:\n\tdestroy_hist_field(expr, 0);\n\treturn ERR_PTR(ret);\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include \"tracing_map.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct hist_field *parse_expr(struct hist_trigger_data *hist_data,\n\t\t\t\t     struct trace_event_file *file,\n\t\t\t\t     char *str, unsigned long flags,\n\t\t\t\t     char *var_name, unsigned int *n_subexprs);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "ret"
          ],
          "line": 2517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "destroy_hist_field",
          "args": [
            "expr",
            "0"
          ],
          "line": 2516
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_hist_field",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "1864-1882",
          "snippet": "static void destroy_hist_field(struct hist_field *hist_field,\n\t\t\t       unsigned int level)\n{\n\tunsigned int i;\n\n\tif (level > 3)\n\t\treturn;\n\n\tif (!hist_field)\n\t\treturn;\n\n\tif (hist_field->flags & HIST_FIELD_FL_VAR_REF)\n\t\treturn; /* var refs will be destroyed separately */\n\n\tfor (i = 0; i < HIST_FIELD_OPERANDS_MAX; i++)\n\t\tdestroy_hist_field(hist_field->operands[i], level + 1);\n\n\t__destroy_hist_field(hist_field);\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define HIST_FIELD_OPERANDS_MAX\t2"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\n#define HIST_FIELD_OPERANDS_MAX\t2\n\nstatic void destroy_hist_field(struct hist_field *hist_field,\n\t\t\t       unsigned int level)\n{\n\tunsigned int i;\n\n\tif (level > 3)\n\t\treturn;\n\n\tif (!hist_field)\n\t\treturn;\n\n\tif (hist_field->flags & HIST_FIELD_FL_VAR_REF)\n\t\treturn; /* var refs will be destroyed separately */\n\n\tfor (i = 0; i < HIST_FIELD_OPERANDS_MAX; i++)\n\t\tdestroy_hist_field(hist_field->operands[i], level + 1);\n\n\t__destroy_hist_field(hist_field);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kstrdup_const",
          "args": [
            "operand1->type",
            "GFP_KERNEL"
          ],
          "line": 2508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "expr_str",
          "args": [
            "expr",
            "0"
          ],
          "line": 2507
        },
        "resolved": true,
        "details": {
          "function_name": "expr_str",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "1693-1749",
          "snippet": "static char *expr_str(struct hist_field *field, unsigned int level)\n{\n\tchar *expr;\n\n\tif (level > 1)\n\t\treturn NULL;\n\n\texpr = kzalloc(MAX_FILTER_STR_VAL, GFP_KERNEL);\n\tif (!expr)\n\t\treturn NULL;\n\n\tif (!field->operands[0]) {\n\t\texpr_field_str(field, expr);\n\t\treturn expr;\n\t}\n\n\tif (field->operator == FIELD_OP_UNARY_MINUS) {\n\t\tchar *subexpr;\n\n\t\tstrcat(expr, \"-(\");\n\t\tsubexpr = expr_str(field->operands[0], ++level);\n\t\tif (!subexpr) {\n\t\t\tkfree(expr);\n\t\t\treturn NULL;\n\t\t}\n\t\tstrcat(expr, subexpr);\n\t\tstrcat(expr, \")\");\n\n\t\tkfree(subexpr);\n\n\t\treturn expr;\n\t}\n\n\texpr_field_str(field->operands[0], expr);\n\n\tswitch (field->operator) {\n\tcase FIELD_OP_MINUS:\n\t\tstrcat(expr, \"-\");\n\t\tbreak;\n\tcase FIELD_OP_PLUS:\n\t\tstrcat(expr, \"+\");\n\t\tbreak;\n\tcase FIELD_OP_DIV:\n\t\tstrcat(expr, \"/\");\n\t\tbreak;\n\tcase FIELD_OP_MULT:\n\t\tstrcat(expr, \"*\");\n\t\tbreak;\n\tdefault:\n\t\tkfree(expr);\n\t\treturn NULL;\n\t}\n\n\texpr_field_str(field->operands[1], expr);\n\n\treturn expr;\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic char *expr_str(struct hist_field *field, unsigned int level)\n{\n\tchar *expr;\n\n\tif (level > 1)\n\t\treturn NULL;\n\n\texpr = kzalloc(MAX_FILTER_STR_VAL, GFP_KERNEL);\n\tif (!expr)\n\t\treturn NULL;\n\n\tif (!field->operands[0]) {\n\t\texpr_field_str(field, expr);\n\t\treturn expr;\n\t}\n\n\tif (field->operator == FIELD_OP_UNARY_MINUS) {\n\t\tchar *subexpr;\n\n\t\tstrcat(expr, \"-(\");\n\t\tsubexpr = expr_str(field->operands[0], ++level);\n\t\tif (!subexpr) {\n\t\t\tkfree(expr);\n\t\t\treturn NULL;\n\t\t}\n\t\tstrcat(expr, subexpr);\n\t\tstrcat(expr, \")\");\n\n\t\tkfree(subexpr);\n\n\t\treturn expr;\n\t}\n\n\texpr_field_str(field->operands[0], expr);\n\n\tswitch (field->operator) {\n\tcase FIELD_OP_MINUS:\n\t\tstrcat(expr, \"-\");\n\t\tbreak;\n\tcase FIELD_OP_PLUS:\n\t\tstrcat(expr, \"+\");\n\t\tbreak;\n\tcase FIELD_OP_DIV:\n\t\tstrcat(expr, \"/\");\n\t\tbreak;\n\tcase FIELD_OP_MULT:\n\t\tstrcat(expr, \"*\");\n\t\tbreak;\n\tdefault:\n\t\tkfree(expr);\n\t\treturn NULL;\n\t}\n\n\texpr_field_str(field->operands[1], expr);\n\n\treturn expr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hist_err",
          "args": [
            "file->tr",
            "HIST_ERR_INVALID_STR_OPERAND",
            "errpos(str)"
          ],
          "line": 2496
        },
        "resolved": true,
        "details": {
          "function_name": "hist_err",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "763-767",
          "snippet": "static void hist_err(struct trace_array *tr, u8 err_type, u8 err_pos)\n{\n\ttracing_log_err(tr, last_cmd_loc, last_cmd, err_text,\n\t\t\terr_type, err_pos);\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *err_text[] = { ERRORS };",
            "static char last_cmd[MAX_FILTER_STR_VAL];",
            "static char last_cmd_loc[MAX_FILTER_STR_VAL];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic const char *err_text[] = { ERRORS };\nstatic char last_cmd[MAX_FILTER_STR_VAL];\nstatic char last_cmd_loc[MAX_FILTER_STR_VAL];\n\nstatic void hist_err(struct trace_array *tr, u8 err_type, u8 err_pos)\n{\n\ttracing_log_err(tr, last_cmd_loc, last_cmd, err_text,\n\t\t\terr_type, err_pos);\n}"
        }
      },
      {
        "call_info": {
          "callee": "errpos",
          "args": [
            "str"
          ],
          "line": 2496
        },
        "resolved": true,
        "details": {
          "function_name": "errpos",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "733-736",
          "snippet": "static int errpos(char *str)\n{\n\treturn err_pos(last_cmd, str);\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char last_cmd[MAX_FILTER_STR_VAL];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic char last_cmd[MAX_FILTER_STR_VAL];\n\nstatic int errpos(char *str)\n{\n\treturn err_pos(last_cmd, str);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "operand1"
          ],
          "line": 2491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "operand1"
          ],
          "line": 2490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parse_expr",
          "args": [
            "hist_data",
            "file",
            "str",
            "operand_flags",
            "NULL",
            "n_subexprs"
          ],
          "line": 2489
        },
        "resolved": true,
        "details": {
          "function_name": "parse_expr",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "2564-2744",
          "snippet": "static struct hist_field *parse_expr(struct hist_trigger_data *hist_data,\n\t\t\t\t     struct trace_event_file *file,\n\t\t\t\t     char *str, unsigned long flags,\n\t\t\t\t     char *var_name, unsigned int *n_subexprs)\n{\n\tstruct hist_field *operand1 = NULL, *operand2 = NULL, *expr = NULL;\n\tstruct hist_field *var1 = NULL, *var2 = NULL;\n\tunsigned long operand_flags, operand2_flags;\n\tint field_op, ret = -EINVAL;\n\tchar *sep, *operand1_str;\n\thist_field_fn_t op_fn;\n\tbool combine_consts;\n\n\tif (*n_subexprs > 3) {\n\t\thist_err(file->tr, HIST_ERR_TOO_MANY_SUBEXPR, errpos(str));\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tfield_op = contains_operator(str, &sep);\n\n\tif (field_op == FIELD_OP_NONE)\n\t\treturn parse_atom(hist_data, file, str, &flags, var_name);\n\n\tif (field_op == FIELD_OP_UNARY_MINUS)\n\t\treturn parse_unary(hist_data, file, str, flags, var_name, n_subexprs);\n\n\t/* Binary operator found, increment n_subexprs */\n\t++*n_subexprs;\n\n\t/* Split the expression string at the root operator */\n\tif (!sep)\n\t\treturn ERR_PTR(-EINVAL);\n\n\t*sep = '\\0';\n\toperand1_str = str;\n\tstr = sep+1;\n\n\t/* Binary operator requires both operands */\n\tif (*operand1_str == '\\0' || *str == '\\0')\n\t\treturn ERR_PTR(-EINVAL);\n\n\toperand_flags = 0;\n\n\t/* LHS of string is an expression e.g. a+b in a+b+c */\n\toperand1 = parse_expr(hist_data, file, operand1_str, operand_flags, NULL, n_subexprs);\n\tif (IS_ERR(operand1))\n\t\treturn ERR_CAST(operand1);\n\n\tif (operand1->flags & HIST_FIELD_FL_STRING) {\n\t\thist_err(file->tr, HIST_ERR_INVALID_STR_OPERAND, errpos(operand1_str));\n\t\tret = -EINVAL;\n\t\tgoto free_op1;\n\t}\n\n\t/* RHS of string is another expression e.g. c in a+b+c */\n\toperand_flags = 0;\n\toperand2 = parse_expr(hist_data, file, str, operand_flags, NULL, n_subexprs);\n\tif (IS_ERR(operand2)) {\n\t\tret = PTR_ERR(operand2);\n\t\tgoto free_op1;\n\t}\n\tif (operand2->flags & HIST_FIELD_FL_STRING) {\n\t\thist_err(file->tr, HIST_ERR_INVALID_STR_OPERAND, errpos(str));\n\t\tret = -EINVAL;\n\t\tgoto free_operands;\n\t}\n\n\tswitch (field_op) {\n\tcase FIELD_OP_MINUS:\n\t\top_fn = hist_field_minus;\n\t\tbreak;\n\tcase FIELD_OP_PLUS:\n\t\top_fn = hist_field_plus;\n\t\tbreak;\n\tcase FIELD_OP_DIV:\n\t\top_fn = hist_field_div;\n\t\tbreak;\n\tcase FIELD_OP_MULT:\n\t\top_fn = hist_field_mult;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tgoto free_operands;\n\t}\n\n\tret = check_expr_operands(file->tr, operand1, operand2, &var1, &var2);\n\tif (ret)\n\t\tgoto free_operands;\n\n\toperand_flags = var1 ? var1->flags : operand1->flags;\n\toperand2_flags = var2 ? var2->flags : operand2->flags;\n\n\t/*\n\t * If both operands are constant, the expression can be\n\t * collapsed to a single constant.\n\t */\n\tcombine_consts = operand_flags & operand2_flags & HIST_FIELD_FL_CONST;\n\n\tflags |= combine_consts ? HIST_FIELD_FL_CONST : HIST_FIELD_FL_EXPR;\n\n\tflags |= operand1->flags &\n\t\t(HIST_FIELD_FL_TIMESTAMP | HIST_FIELD_FL_TIMESTAMP_USECS);\n\n\texpr = create_hist_field(hist_data, NULL, flags, var_name);\n\tif (!expr) {\n\t\tret = -ENOMEM;\n\t\tgoto free_operands;\n\t}\n\n\toperand1->read_once = true;\n\toperand2->read_once = true;\n\n\t/* The operands are now owned and free'd by 'expr' */\n\texpr->operands[0] = operand1;\n\texpr->operands[1] = operand2;\n\n\tif (field_op == FIELD_OP_DIV &&\n\t\t\toperand2_flags & HIST_FIELD_FL_CONST) {\n\t\tu64 divisor = var2 ? var2->constant : operand2->constant;\n\n\t\tif (!divisor) {\n\t\t\thist_err(file->tr, HIST_ERR_DIVISION_BY_ZERO, errpos(str));\n\t\t\tret = -EDOM;\n\t\t\tgoto free_expr;\n\t\t}\n\n\t\t/*\n\t\t * Copy the divisor here so we don't have to look it up\n\t\t * later if this is a var ref\n\t\t */\n\t\toperand2->constant = divisor;\n\t\top_fn = hist_field_get_div_fn(operand2);\n\t}\n\n\tif (combine_consts) {\n\t\tif (var1)\n\t\t\texpr->operands[0] = var1;\n\t\tif (var2)\n\t\t\texpr->operands[1] = var2;\n\n\t\texpr->constant = op_fn(expr, NULL, NULL, NULL, NULL);\n\n\t\texpr->operands[0] = NULL;\n\t\texpr->operands[1] = NULL;\n\n\t\t/*\n\t\t * var refs won't be destroyed immediately\n\t\t * See: destroy_hist_field()\n\t\t */\n\t\tdestroy_hist_field(operand2, 0);\n\t\tdestroy_hist_field(operand1, 0);\n\n\t\texpr->name = expr_str(expr, 0);\n\t} else {\n\t\texpr->fn = op_fn;\n\n\t\t/* The operand sizes should be the same, so just pick one */\n\t\texpr->size = operand1->size;\n\n\t\texpr->operator = field_op;\n\t\texpr->type = kstrdup_const(operand1->type, GFP_KERNEL);\n\t\tif (!expr->type) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto free_expr;\n\t\t}\n\n\t\texpr->name = expr_str(expr, 0);\n\t}\n\n\treturn expr;\n\nfree_operands:\n\tdestroy_hist_field(operand2, 0);\nfree_op1:\n\tdestroy_hist_field(operand1, 0);\n\treturn ERR_PTR(ret);\n\nfree_expr:\n\tdestroy_hist_field(expr, 0);\n\treturn ERR_PTR(ret);\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hist_field *parse_expr(struct hist_trigger_data *hist_data,\n\t\t\t\t     struct trace_event_file *file,\n\t\t\t\t     char *str, unsigned long flags,\n\t\t\t\t     char *var_name, unsigned int *n_subexprs);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct hist_field *parse_expr(struct hist_trigger_data *hist_data,\n\t\t\t\t     struct trace_event_file *file,\n\t\t\t\t     char *str, unsigned long flags,\n\t\t\t\t     char *var_name, unsigned int *n_subexprs);\n\nstatic struct hist_field *parse_expr(struct hist_trigger_data *hist_data,\n\t\t\t\t     struct trace_event_file *file,\n\t\t\t\t     char *str, unsigned long flags,\n\t\t\t\t     char *var_name, unsigned int *n_subexprs)\n{\n\tstruct hist_field *operand1 = NULL, *operand2 = NULL, *expr = NULL;\n\tstruct hist_field *var1 = NULL, *var2 = NULL;\n\tunsigned long operand_flags, operand2_flags;\n\tint field_op, ret = -EINVAL;\n\tchar *sep, *operand1_str;\n\thist_field_fn_t op_fn;\n\tbool combine_consts;\n\n\tif (*n_subexprs > 3) {\n\t\thist_err(file->tr, HIST_ERR_TOO_MANY_SUBEXPR, errpos(str));\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tfield_op = contains_operator(str, &sep);\n\n\tif (field_op == FIELD_OP_NONE)\n\t\treturn parse_atom(hist_data, file, str, &flags, var_name);\n\n\tif (field_op == FIELD_OP_UNARY_MINUS)\n\t\treturn parse_unary(hist_data, file, str, flags, var_name, n_subexprs);\n\n\t/* Binary operator found, increment n_subexprs */\n\t++*n_subexprs;\n\n\t/* Split the expression string at the root operator */\n\tif (!sep)\n\t\treturn ERR_PTR(-EINVAL);\n\n\t*sep = '\\0';\n\toperand1_str = str;\n\tstr = sep+1;\n\n\t/* Binary operator requires both operands */\n\tif (*operand1_str == '\\0' || *str == '\\0')\n\t\treturn ERR_PTR(-EINVAL);\n\n\toperand_flags = 0;\n\n\t/* LHS of string is an expression e.g. a+b in a+b+c */\n\toperand1 = parse_expr(hist_data, file, operand1_str, operand_flags, NULL, n_subexprs);\n\tif (IS_ERR(operand1))\n\t\treturn ERR_CAST(operand1);\n\n\tif (operand1->flags & HIST_FIELD_FL_STRING) {\n\t\thist_err(file->tr, HIST_ERR_INVALID_STR_OPERAND, errpos(operand1_str));\n\t\tret = -EINVAL;\n\t\tgoto free_op1;\n\t}\n\n\t/* RHS of string is another expression e.g. c in a+b+c */\n\toperand_flags = 0;\n\toperand2 = parse_expr(hist_data, file, str, operand_flags, NULL, n_subexprs);\n\tif (IS_ERR(operand2)) {\n\t\tret = PTR_ERR(operand2);\n\t\tgoto free_op1;\n\t}\n\tif (operand2->flags & HIST_FIELD_FL_STRING) {\n\t\thist_err(file->tr, HIST_ERR_INVALID_STR_OPERAND, errpos(str));\n\t\tret = -EINVAL;\n\t\tgoto free_operands;\n\t}\n\n\tswitch (field_op) {\n\tcase FIELD_OP_MINUS:\n\t\top_fn = hist_field_minus;\n\t\tbreak;\n\tcase FIELD_OP_PLUS:\n\t\top_fn = hist_field_plus;\n\t\tbreak;\n\tcase FIELD_OP_DIV:\n\t\top_fn = hist_field_div;\n\t\tbreak;\n\tcase FIELD_OP_MULT:\n\t\top_fn = hist_field_mult;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tgoto free_operands;\n\t}\n\n\tret = check_expr_operands(file->tr, operand1, operand2, &var1, &var2);\n\tif (ret)\n\t\tgoto free_operands;\n\n\toperand_flags = var1 ? var1->flags : operand1->flags;\n\toperand2_flags = var2 ? var2->flags : operand2->flags;\n\n\t/*\n\t * If both operands are constant, the expression can be\n\t * collapsed to a single constant.\n\t */\n\tcombine_consts = operand_flags & operand2_flags & HIST_FIELD_FL_CONST;\n\n\tflags |= combine_consts ? HIST_FIELD_FL_CONST : HIST_FIELD_FL_EXPR;\n\n\tflags |= operand1->flags &\n\t\t(HIST_FIELD_FL_TIMESTAMP | HIST_FIELD_FL_TIMESTAMP_USECS);\n\n\texpr = create_hist_field(hist_data, NULL, flags, var_name);\n\tif (!expr) {\n\t\tret = -ENOMEM;\n\t\tgoto free_operands;\n\t}\n\n\toperand1->read_once = true;\n\toperand2->read_once = true;\n\n\t/* The operands are now owned and free'd by 'expr' */\n\texpr->operands[0] = operand1;\n\texpr->operands[1] = operand2;\n\n\tif (field_op == FIELD_OP_DIV &&\n\t\t\toperand2_flags & HIST_FIELD_FL_CONST) {\n\t\tu64 divisor = var2 ? var2->constant : operand2->constant;\n\n\t\tif (!divisor) {\n\t\t\thist_err(file->tr, HIST_ERR_DIVISION_BY_ZERO, errpos(str));\n\t\t\tret = -EDOM;\n\t\t\tgoto free_expr;\n\t\t}\n\n\t\t/*\n\t\t * Copy the divisor here so we don't have to look it up\n\t\t * later if this is a var ref\n\t\t */\n\t\toperand2->constant = divisor;\n\t\top_fn = hist_field_get_div_fn(operand2);\n\t}\n\n\tif (combine_consts) {\n\t\tif (var1)\n\t\t\texpr->operands[0] = var1;\n\t\tif (var2)\n\t\t\texpr->operands[1] = var2;\n\n\t\texpr->constant = op_fn(expr, NULL, NULL, NULL, NULL);\n\n\t\texpr->operands[0] = NULL;\n\t\texpr->operands[1] = NULL;\n\n\t\t/*\n\t\t * var refs won't be destroyed immediately\n\t\t * See: destroy_hist_field()\n\t\t */\n\t\tdestroy_hist_field(operand2, 0);\n\t\tdestroy_hist_field(operand1, 0);\n\n\t\texpr->name = expr_str(expr, 0);\n\t} else {\n\t\texpr->fn = op_fn;\n\n\t\t/* The operand sizes should be the same, so just pick one */\n\t\texpr->size = operand1->size;\n\n\t\texpr->operator = field_op;\n\t\texpr->type = kstrdup_const(operand1->type, GFP_KERNEL);\n\t\tif (!expr->type) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto free_expr;\n\t\t}\n\n\t\texpr->name = expr_str(expr, 0);\n\t}\n\n\treturn expr;\n\nfree_operands:\n\tdestroy_hist_field(operand2, 0);\nfree_op1:\n\tdestroy_hist_field(operand1, 0);\n\treturn ERR_PTR(ret);\n\nfree_expr:\n\tdestroy_hist_field(expr, 0);\n\treturn ERR_PTR(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "create_hist_field",
          "args": [
            "hist_data",
            "NULL",
            "flags",
            "var_name"
          ],
          "line": 2482
        },
        "resolved": true,
        "details": {
          "function_name": "create_hist_field",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "1884-2007",
          "snippet": "static struct hist_field *create_hist_field(struct hist_trigger_data *hist_data,\n\t\t\t\t\t    struct ftrace_event_field *field,\n\t\t\t\t\t    unsigned long flags,\n\t\t\t\t\t    char *var_name)\n{\n\tstruct hist_field *hist_field;\n\n\tif (field && is_function_field(field))\n\t\treturn NULL;\n\n\thist_field = kzalloc(sizeof(struct hist_field), GFP_KERNEL);\n\tif (!hist_field)\n\t\treturn NULL;\n\n\thist_field->ref = 1;\n\n\thist_field->hist_data = hist_data;\n\n\tif (flags & HIST_FIELD_FL_EXPR || flags & HIST_FIELD_FL_ALIAS)\n\t\tgoto out; /* caller will populate */\n\n\tif (flags & HIST_FIELD_FL_VAR_REF) {\n\t\thist_field->fn = hist_field_var_ref;\n\t\tgoto out;\n\t}\n\n\tif (flags & HIST_FIELD_FL_HITCOUNT) {\n\t\thist_field->fn = hist_field_counter;\n\t\thist_field->size = sizeof(u64);\n\t\thist_field->type = \"u64\";\n\t\tgoto out;\n\t}\n\n\tif (flags & HIST_FIELD_FL_CONST) {\n\t\thist_field->fn = hist_field_const;\n\t\thist_field->size = sizeof(u64);\n\t\thist_field->type = kstrdup(\"u64\", GFP_KERNEL);\n\t\tif (!hist_field->type)\n\t\t\tgoto free;\n\t\tgoto out;\n\t}\n\n\tif (flags & HIST_FIELD_FL_STACKTRACE) {\n\t\thist_field->fn = hist_field_none;\n\t\tgoto out;\n\t}\n\n\tif (flags & (HIST_FIELD_FL_LOG2 | HIST_FIELD_FL_BUCKET)) {\n\t\tunsigned long fl = flags & ~(HIST_FIELD_FL_LOG2 | HIST_FIELD_FL_BUCKET);\n\t\thist_field->fn = flags & HIST_FIELD_FL_LOG2 ? hist_field_log2 :\n\t\t\thist_field_bucket;\n\t\thist_field->operands[0] = create_hist_field(hist_data, field, fl, NULL);\n\t\thist_field->size = hist_field->operands[0]->size;\n\t\thist_field->type = kstrdup_const(hist_field->operands[0]->type, GFP_KERNEL);\n\t\tif (!hist_field->type)\n\t\t\tgoto free;\n\t\tgoto out;\n\t}\n\n\tif (flags & HIST_FIELD_FL_TIMESTAMP) {\n\t\thist_field->fn = hist_field_timestamp;\n\t\thist_field->size = sizeof(u64);\n\t\thist_field->type = \"u64\";\n\t\tgoto out;\n\t}\n\n\tif (flags & HIST_FIELD_FL_CPU) {\n\t\thist_field->fn = hist_field_cpu;\n\t\thist_field->size = sizeof(int);\n\t\thist_field->type = \"unsigned int\";\n\t\tgoto out;\n\t}\n\n\tif (WARN_ON_ONCE(!field))\n\t\tgoto out;\n\n\t/* Pointers to strings are just pointers and dangerous to dereference */\n\tif (is_string_field(field) &&\n\t    (field->filter_type != FILTER_PTR_STRING)) {\n\t\tflags |= HIST_FIELD_FL_STRING;\n\n\t\thist_field->size = MAX_FILTER_STR_VAL;\n\t\thist_field->type = kstrdup_const(field->type, GFP_KERNEL);\n\t\tif (!hist_field->type)\n\t\t\tgoto free;\n\n\t\tif (field->filter_type == FILTER_STATIC_STRING) {\n\t\t\thist_field->fn = hist_field_string;\n\t\t\thist_field->size = field->size;\n\t\t} else if (field->filter_type == FILTER_DYN_STRING) {\n\t\t\thist_field->fn = hist_field_dynstring;\n\t\t} else if (field->filter_type == FILTER_RDYN_STRING)\n\t\t\thist_field->fn = hist_field_reldynstring;\n\t\telse\n\t\t\thist_field->fn = hist_field_pstring;\n\t} else {\n\t\thist_field->size = field->size;\n\t\thist_field->is_signed = field->is_signed;\n\t\thist_field->type = kstrdup_const(field->type, GFP_KERNEL);\n\t\tif (!hist_field->type)\n\t\t\tgoto free;\n\n\t\thist_field->fn = select_value_fn(field->size,\n\t\t\t\t\t\t field->is_signed);\n\t\tif (!hist_field->fn) {\n\t\t\tdestroy_hist_field(hist_field, 0);\n\t\t\treturn NULL;\n\t\t}\n\t}\n out:\n\thist_field->field = field;\n\thist_field->flags = flags;\n\n\tif (var_name) {\n\t\thist_field->var.name = kstrdup(var_name, GFP_KERNEL);\n\t\tif (!hist_field->var.name)\n\t\t\tgoto free;\n\t}\n\n\treturn hist_field;\n free:\n\tdestroy_hist_field(hist_field, 0);\n\treturn NULL;\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct hist_field *create_hist_field(struct hist_trigger_data *hist_data,\n\t\t\t\t\t    struct ftrace_event_field *field,\n\t\t\t\t\t    unsigned long flags,\n\t\t\t\t\t    char *var_name)\n{\n\tstruct hist_field *hist_field;\n\n\tif (field && is_function_field(field))\n\t\treturn NULL;\n\n\thist_field = kzalloc(sizeof(struct hist_field), GFP_KERNEL);\n\tif (!hist_field)\n\t\treturn NULL;\n\n\thist_field->ref = 1;\n\n\thist_field->hist_data = hist_data;\n\n\tif (flags & HIST_FIELD_FL_EXPR || flags & HIST_FIELD_FL_ALIAS)\n\t\tgoto out; /* caller will populate */\n\n\tif (flags & HIST_FIELD_FL_VAR_REF) {\n\t\thist_field->fn = hist_field_var_ref;\n\t\tgoto out;\n\t}\n\n\tif (flags & HIST_FIELD_FL_HITCOUNT) {\n\t\thist_field->fn = hist_field_counter;\n\t\thist_field->size = sizeof(u64);\n\t\thist_field->type = \"u64\";\n\t\tgoto out;\n\t}\n\n\tif (flags & HIST_FIELD_FL_CONST) {\n\t\thist_field->fn = hist_field_const;\n\t\thist_field->size = sizeof(u64);\n\t\thist_field->type = kstrdup(\"u64\", GFP_KERNEL);\n\t\tif (!hist_field->type)\n\t\t\tgoto free;\n\t\tgoto out;\n\t}\n\n\tif (flags & HIST_FIELD_FL_STACKTRACE) {\n\t\thist_field->fn = hist_field_none;\n\t\tgoto out;\n\t}\n\n\tif (flags & (HIST_FIELD_FL_LOG2 | HIST_FIELD_FL_BUCKET)) {\n\t\tunsigned long fl = flags & ~(HIST_FIELD_FL_LOG2 | HIST_FIELD_FL_BUCKET);\n\t\thist_field->fn = flags & HIST_FIELD_FL_LOG2 ? hist_field_log2 :\n\t\t\thist_field_bucket;\n\t\thist_field->operands[0] = create_hist_field(hist_data, field, fl, NULL);\n\t\thist_field->size = hist_field->operands[0]->size;\n\t\thist_field->type = kstrdup_const(hist_field->operands[0]->type, GFP_KERNEL);\n\t\tif (!hist_field->type)\n\t\t\tgoto free;\n\t\tgoto out;\n\t}\n\n\tif (flags & HIST_FIELD_FL_TIMESTAMP) {\n\t\thist_field->fn = hist_field_timestamp;\n\t\thist_field->size = sizeof(u64);\n\t\thist_field->type = \"u64\";\n\t\tgoto out;\n\t}\n\n\tif (flags & HIST_FIELD_FL_CPU) {\n\t\thist_field->fn = hist_field_cpu;\n\t\thist_field->size = sizeof(int);\n\t\thist_field->type = \"unsigned int\";\n\t\tgoto out;\n\t}\n\n\tif (WARN_ON_ONCE(!field))\n\t\tgoto out;\n\n\t/* Pointers to strings are just pointers and dangerous to dereference */\n\tif (is_string_field(field) &&\n\t    (field->filter_type != FILTER_PTR_STRING)) {\n\t\tflags |= HIST_FIELD_FL_STRING;\n\n\t\thist_field->size = MAX_FILTER_STR_VAL;\n\t\thist_field->type = kstrdup_const(field->type, GFP_KERNEL);\n\t\tif (!hist_field->type)\n\t\t\tgoto free;\n\n\t\tif (field->filter_type == FILTER_STATIC_STRING) {\n\t\t\thist_field->fn = hist_field_string;\n\t\t\thist_field->size = field->size;\n\t\t} else if (field->filter_type == FILTER_DYN_STRING) {\n\t\t\thist_field->fn = hist_field_dynstring;\n\t\t} else if (field->filter_type == FILTER_RDYN_STRING)\n\t\t\thist_field->fn = hist_field_reldynstring;\n\t\telse\n\t\t\thist_field->fn = hist_field_pstring;\n\t} else {\n\t\thist_field->size = field->size;\n\t\thist_field->is_signed = field->is_signed;\n\t\thist_field->type = kstrdup_const(field->type, GFP_KERNEL);\n\t\tif (!hist_field->type)\n\t\t\tgoto free;\n\n\t\thist_field->fn = select_value_fn(field->size,\n\t\t\t\t\t\t field->is_signed);\n\t\tif (!hist_field->fn) {\n\t\t\tdestroy_hist_field(hist_field, 0);\n\t\t\treturn NULL;\n\t\t}\n\t}\n out:\n\thist_field->field = field;\n\thist_field->flags = flags;\n\n\tif (var_name) {\n\t\thist_field->var.name = kstrdup(var_name, GFP_KERNEL);\n\t\tif (!hist_field->var.name)\n\t\t\tgoto free;\n\t}\n\n\treturn hist_field;\n free:\n\tdestroy_hist_field(hist_field, 0);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strrchr",
          "args": [
            "str",
            "')'"
          ],
          "line": 2465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "str",
            "'('"
          ],
          "line": 2457
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct hist_field *parse_expr(struct hist_trigger_data *hist_data,\n\t\t\t\t     struct trace_event_file *file,\n\t\t\t\t     char *str, unsigned long flags,\n\t\t\t\t     char *var_name, unsigned int *n_subexprs);\n\nstatic struct hist_field *parse_unary(struct hist_trigger_data *hist_data,\n\t\t\t\t      struct trace_event_file *file,\n\t\t\t\t      char *str, unsigned long flags,\n\t\t\t\t      char *var_name, unsigned int *n_subexprs)\n{\n\tstruct hist_field *operand1, *expr = NULL;\n\tunsigned long operand_flags;\n\tint ret = 0;\n\tchar *s;\n\n\t/* Unary minus operator, increment n_subexprs */\n\t++*n_subexprs;\n\n\t/* we support only -(xxx) i.e. explicit parens required */\n\n\tif (*n_subexprs > 3) {\n\t\thist_err(file->tr, HIST_ERR_TOO_MANY_SUBEXPR, errpos(str));\n\t\tret = -EINVAL;\n\t\tgoto free;\n\t}\n\n\tstr++; /* skip leading '-' */\n\n\ts = strchr(str, '(');\n\tif (s)\n\t\tstr++;\n\telse {\n\t\tret = -EINVAL;\n\t\tgoto free;\n\t}\n\n\ts = strrchr(str, ')');\n\tif (s) {\n\t\t /* unary minus not supported in sub-expressions */\n\t\tif (*(s+1) != '\\0') {\n\t\t\thist_err(file->tr, HIST_ERR_UNARY_MINUS_SUBEXPR,\n\t\t\t\t errpos(str));\n\t\t\tret = -EINVAL;\n\t\t\tgoto free;\n\t\t}\n\t\t*s = '\\0';\n\t}\n\telse {\n\t\tret = -EINVAL; /* no closing ')' */\n\t\tgoto free;\n\t}\n\n\tflags |= HIST_FIELD_FL_EXPR;\n\texpr = create_hist_field(hist_data, NULL, flags, var_name);\n\tif (!expr) {\n\t\tret = -ENOMEM;\n\t\tgoto free;\n\t}\n\n\toperand_flags = 0;\n\toperand1 = parse_expr(hist_data, file, str, operand_flags, NULL, n_subexprs);\n\tif (IS_ERR(operand1)) {\n\t\tret = PTR_ERR(operand1);\n\t\tgoto free;\n\t}\n\tif (operand1->flags & HIST_FIELD_FL_STRING) {\n\t\t/* String type can not be the operand of unary operator. */\n\t\thist_err(file->tr, HIST_ERR_INVALID_STR_OPERAND, errpos(str));\n\t\tdestroy_hist_field(operand1, 0);\n\t\tret = -EINVAL;\n\t\tgoto free;\n\t}\n\n\texpr->flags |= operand1->flags &\n\t\t(HIST_FIELD_FL_TIMESTAMP | HIST_FIELD_FL_TIMESTAMP_USECS);\n\texpr->fn = hist_field_unary_minus;\n\texpr->operands[0] = operand1;\n\texpr->operator = FIELD_OP_UNARY_MINUS;\n\texpr->name = expr_str(expr, 0);\n\texpr->type = kstrdup_const(operand1->type, GFP_KERNEL);\n\tif (!expr->type) {\n\t\tret = -ENOMEM;\n\t\tgoto free;\n\t}\n\n\treturn expr;\n free:\n\tdestroy_hist_field(expr, 0);\n\treturn ERR_PTR(ret);\n}"
  },
  {
    "function_name": "parse_atom",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
    "lines": "2357-2427",
    "snippet": "static struct hist_field *parse_atom(struct hist_trigger_data *hist_data,\n\t\t\t\t     struct trace_event_file *file, char *str,\n\t\t\t\t     unsigned long *flags, char *var_name)\n{\n\tchar *s, *ref_system = NULL, *ref_event = NULL, *ref_var = str;\n\tstruct ftrace_event_field *field = NULL;\n\tstruct hist_field *hist_field = NULL;\n\tunsigned long buckets = 0;\n\tint ret = 0;\n\n\tif (isdigit(str[0])) {\n\t\thist_field = parse_const(hist_data, str, var_name, flags);\n\t\tif (!hist_field) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\treturn hist_field;\n\t}\n\n\ts = strchr(str, '.');\n\tif (s) {\n\t\ts = strchr(++s, '.');\n\t\tif (s) {\n\t\t\tref_system = strsep(&str, \".\");\n\t\t\tif (!str) {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tref_event = strsep(&str, \".\");\n\t\t\tif (!str) {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tref_var = str;\n\t\t}\n\t}\n\n\ts = local_field_var_ref(hist_data, ref_system, ref_event, ref_var);\n\tif (!s) {\n\t\thist_field = parse_var_ref(hist_data, ref_system,\n\t\t\t\t\t   ref_event, ref_var);\n\t\tif (hist_field) {\n\t\t\tif (var_name) {\n\t\t\t\thist_field = create_alias(hist_data, hist_field, var_name);\n\t\t\t\tif (!hist_field) {\n\t\t\t\t\tret = -ENOMEM;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn hist_field;\n\t\t}\n\t} else\n\t\tstr = s;\n\n\tfield = parse_field(hist_data, file, str, flags, &buckets);\n\tif (IS_ERR(field)) {\n\t\tret = PTR_ERR(field);\n\t\tgoto out;\n\t}\n\n\thist_field = create_hist_field(hist_data, field, *flags, var_name);\n\tif (!hist_field) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\thist_field->buckets = buckets;\n\n\treturn hist_field;\n out:\n\treturn ERR_PTR(ret);\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include \"tracing_map.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "ret"
          ],
          "line": 2426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "create_hist_field",
          "args": [
            "hist_data",
            "field",
            "*flags",
            "var_name"
          ],
          "line": 2417
        },
        "resolved": true,
        "details": {
          "function_name": "create_hist_field",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "1884-2007",
          "snippet": "static struct hist_field *create_hist_field(struct hist_trigger_data *hist_data,\n\t\t\t\t\t    struct ftrace_event_field *field,\n\t\t\t\t\t    unsigned long flags,\n\t\t\t\t\t    char *var_name)\n{\n\tstruct hist_field *hist_field;\n\n\tif (field && is_function_field(field))\n\t\treturn NULL;\n\n\thist_field = kzalloc(sizeof(struct hist_field), GFP_KERNEL);\n\tif (!hist_field)\n\t\treturn NULL;\n\n\thist_field->ref = 1;\n\n\thist_field->hist_data = hist_data;\n\n\tif (flags & HIST_FIELD_FL_EXPR || flags & HIST_FIELD_FL_ALIAS)\n\t\tgoto out; /* caller will populate */\n\n\tif (flags & HIST_FIELD_FL_VAR_REF) {\n\t\thist_field->fn = hist_field_var_ref;\n\t\tgoto out;\n\t}\n\n\tif (flags & HIST_FIELD_FL_HITCOUNT) {\n\t\thist_field->fn = hist_field_counter;\n\t\thist_field->size = sizeof(u64);\n\t\thist_field->type = \"u64\";\n\t\tgoto out;\n\t}\n\n\tif (flags & HIST_FIELD_FL_CONST) {\n\t\thist_field->fn = hist_field_const;\n\t\thist_field->size = sizeof(u64);\n\t\thist_field->type = kstrdup(\"u64\", GFP_KERNEL);\n\t\tif (!hist_field->type)\n\t\t\tgoto free;\n\t\tgoto out;\n\t}\n\n\tif (flags & HIST_FIELD_FL_STACKTRACE) {\n\t\thist_field->fn = hist_field_none;\n\t\tgoto out;\n\t}\n\n\tif (flags & (HIST_FIELD_FL_LOG2 | HIST_FIELD_FL_BUCKET)) {\n\t\tunsigned long fl = flags & ~(HIST_FIELD_FL_LOG2 | HIST_FIELD_FL_BUCKET);\n\t\thist_field->fn = flags & HIST_FIELD_FL_LOG2 ? hist_field_log2 :\n\t\t\thist_field_bucket;\n\t\thist_field->operands[0] = create_hist_field(hist_data, field, fl, NULL);\n\t\thist_field->size = hist_field->operands[0]->size;\n\t\thist_field->type = kstrdup_const(hist_field->operands[0]->type, GFP_KERNEL);\n\t\tif (!hist_field->type)\n\t\t\tgoto free;\n\t\tgoto out;\n\t}\n\n\tif (flags & HIST_FIELD_FL_TIMESTAMP) {\n\t\thist_field->fn = hist_field_timestamp;\n\t\thist_field->size = sizeof(u64);\n\t\thist_field->type = \"u64\";\n\t\tgoto out;\n\t}\n\n\tif (flags & HIST_FIELD_FL_CPU) {\n\t\thist_field->fn = hist_field_cpu;\n\t\thist_field->size = sizeof(int);\n\t\thist_field->type = \"unsigned int\";\n\t\tgoto out;\n\t}\n\n\tif (WARN_ON_ONCE(!field))\n\t\tgoto out;\n\n\t/* Pointers to strings are just pointers and dangerous to dereference */\n\tif (is_string_field(field) &&\n\t    (field->filter_type != FILTER_PTR_STRING)) {\n\t\tflags |= HIST_FIELD_FL_STRING;\n\n\t\thist_field->size = MAX_FILTER_STR_VAL;\n\t\thist_field->type = kstrdup_const(field->type, GFP_KERNEL);\n\t\tif (!hist_field->type)\n\t\t\tgoto free;\n\n\t\tif (field->filter_type == FILTER_STATIC_STRING) {\n\t\t\thist_field->fn = hist_field_string;\n\t\t\thist_field->size = field->size;\n\t\t} else if (field->filter_type == FILTER_DYN_STRING) {\n\t\t\thist_field->fn = hist_field_dynstring;\n\t\t} else if (field->filter_type == FILTER_RDYN_STRING)\n\t\t\thist_field->fn = hist_field_reldynstring;\n\t\telse\n\t\t\thist_field->fn = hist_field_pstring;\n\t} else {\n\t\thist_field->size = field->size;\n\t\thist_field->is_signed = field->is_signed;\n\t\thist_field->type = kstrdup_const(field->type, GFP_KERNEL);\n\t\tif (!hist_field->type)\n\t\t\tgoto free;\n\n\t\thist_field->fn = select_value_fn(field->size,\n\t\t\t\t\t\t field->is_signed);\n\t\tif (!hist_field->fn) {\n\t\t\tdestroy_hist_field(hist_field, 0);\n\t\t\treturn NULL;\n\t\t}\n\t}\n out:\n\thist_field->field = field;\n\thist_field->flags = flags;\n\n\tif (var_name) {\n\t\thist_field->var.name = kstrdup(var_name, GFP_KERNEL);\n\t\tif (!hist_field->var.name)\n\t\t\tgoto free;\n\t}\n\n\treturn hist_field;\n free:\n\tdestroy_hist_field(hist_field, 0);\n\treturn NULL;\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct hist_field *create_hist_field(struct hist_trigger_data *hist_data,\n\t\t\t\t\t    struct ftrace_event_field *field,\n\t\t\t\t\t    unsigned long flags,\n\t\t\t\t\t    char *var_name)\n{\n\tstruct hist_field *hist_field;\n\n\tif (field && is_function_field(field))\n\t\treturn NULL;\n\n\thist_field = kzalloc(sizeof(struct hist_field), GFP_KERNEL);\n\tif (!hist_field)\n\t\treturn NULL;\n\n\thist_field->ref = 1;\n\n\thist_field->hist_data = hist_data;\n\n\tif (flags & HIST_FIELD_FL_EXPR || flags & HIST_FIELD_FL_ALIAS)\n\t\tgoto out; /* caller will populate */\n\n\tif (flags & HIST_FIELD_FL_VAR_REF) {\n\t\thist_field->fn = hist_field_var_ref;\n\t\tgoto out;\n\t}\n\n\tif (flags & HIST_FIELD_FL_HITCOUNT) {\n\t\thist_field->fn = hist_field_counter;\n\t\thist_field->size = sizeof(u64);\n\t\thist_field->type = \"u64\";\n\t\tgoto out;\n\t}\n\n\tif (flags & HIST_FIELD_FL_CONST) {\n\t\thist_field->fn = hist_field_const;\n\t\thist_field->size = sizeof(u64);\n\t\thist_field->type = kstrdup(\"u64\", GFP_KERNEL);\n\t\tif (!hist_field->type)\n\t\t\tgoto free;\n\t\tgoto out;\n\t}\n\n\tif (flags & HIST_FIELD_FL_STACKTRACE) {\n\t\thist_field->fn = hist_field_none;\n\t\tgoto out;\n\t}\n\n\tif (flags & (HIST_FIELD_FL_LOG2 | HIST_FIELD_FL_BUCKET)) {\n\t\tunsigned long fl = flags & ~(HIST_FIELD_FL_LOG2 | HIST_FIELD_FL_BUCKET);\n\t\thist_field->fn = flags & HIST_FIELD_FL_LOG2 ? hist_field_log2 :\n\t\t\thist_field_bucket;\n\t\thist_field->operands[0] = create_hist_field(hist_data, field, fl, NULL);\n\t\thist_field->size = hist_field->operands[0]->size;\n\t\thist_field->type = kstrdup_const(hist_field->operands[0]->type, GFP_KERNEL);\n\t\tif (!hist_field->type)\n\t\t\tgoto free;\n\t\tgoto out;\n\t}\n\n\tif (flags & HIST_FIELD_FL_TIMESTAMP) {\n\t\thist_field->fn = hist_field_timestamp;\n\t\thist_field->size = sizeof(u64);\n\t\thist_field->type = \"u64\";\n\t\tgoto out;\n\t}\n\n\tif (flags & HIST_FIELD_FL_CPU) {\n\t\thist_field->fn = hist_field_cpu;\n\t\thist_field->size = sizeof(int);\n\t\thist_field->type = \"unsigned int\";\n\t\tgoto out;\n\t}\n\n\tif (WARN_ON_ONCE(!field))\n\t\tgoto out;\n\n\t/* Pointers to strings are just pointers and dangerous to dereference */\n\tif (is_string_field(field) &&\n\t    (field->filter_type != FILTER_PTR_STRING)) {\n\t\tflags |= HIST_FIELD_FL_STRING;\n\n\t\thist_field->size = MAX_FILTER_STR_VAL;\n\t\thist_field->type = kstrdup_const(field->type, GFP_KERNEL);\n\t\tif (!hist_field->type)\n\t\t\tgoto free;\n\n\t\tif (field->filter_type == FILTER_STATIC_STRING) {\n\t\t\thist_field->fn = hist_field_string;\n\t\t\thist_field->size = field->size;\n\t\t} else if (field->filter_type == FILTER_DYN_STRING) {\n\t\t\thist_field->fn = hist_field_dynstring;\n\t\t} else if (field->filter_type == FILTER_RDYN_STRING)\n\t\t\thist_field->fn = hist_field_reldynstring;\n\t\telse\n\t\t\thist_field->fn = hist_field_pstring;\n\t} else {\n\t\thist_field->size = field->size;\n\t\thist_field->is_signed = field->is_signed;\n\t\thist_field->type = kstrdup_const(field->type, GFP_KERNEL);\n\t\tif (!hist_field->type)\n\t\t\tgoto free;\n\n\t\thist_field->fn = select_value_fn(field->size,\n\t\t\t\t\t\t field->is_signed);\n\t\tif (!hist_field->fn) {\n\t\t\tdestroy_hist_field(hist_field, 0);\n\t\t\treturn NULL;\n\t\t}\n\t}\n out:\n\thist_field->field = field;\n\thist_field->flags = flags;\n\n\tif (var_name) {\n\t\thist_field->var.name = kstrdup(var_name, GFP_KERNEL);\n\t\tif (!hist_field->var.name)\n\t\t\tgoto free;\n\t}\n\n\treturn hist_field;\n free:\n\tdestroy_hist_field(hist_field, 0);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "field"
          ],
          "line": 2413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "field"
          ],
          "line": 2412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parse_field",
          "args": [
            "hist_data",
            "file",
            "str",
            "flags",
            "&buckets"
          ],
          "line": 2411
        },
        "resolved": true,
        "details": {
          "function_name": "parse_field",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "2224-2308",
          "snippet": "static struct ftrace_event_field *\nparse_field(struct hist_trigger_data *hist_data, struct trace_event_file *file,\n\t    char *field_str, unsigned long *flags, unsigned long *buckets)\n{\n\tstruct ftrace_event_field *field = NULL;\n\tchar *field_name, *modifier, *str;\n\tstruct trace_array *tr = file->tr;\n\n\tmodifier = str = kstrdup(field_str, GFP_KERNEL);\n\tif (!modifier)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tfield_name = strsep(&modifier, \".\");\n\tif (modifier) {\n\t\tif (strcmp(modifier, \"hex\") == 0)\n\t\t\t*flags |= HIST_FIELD_FL_HEX;\n\t\telse if (strcmp(modifier, \"sym\") == 0)\n\t\t\t*flags |= HIST_FIELD_FL_SYM;\n\t\t/*\n\t\t * 'sym-offset' occurrences in the trigger string are modified\n\t\t * to 'symXoffset' to simplify arithmetic expression parsing.\n\t\t */\n\t\telse if (strcmp(modifier, \"symXoffset\") == 0)\n\t\t\t*flags |= HIST_FIELD_FL_SYM_OFFSET;\n\t\telse if ((strcmp(modifier, \"execname\") == 0) &&\n\t\t\t (strcmp(field_name, \"common_pid\") == 0))\n\t\t\t*flags |= HIST_FIELD_FL_EXECNAME;\n\t\telse if (strcmp(modifier, \"syscall\") == 0)\n\t\t\t*flags |= HIST_FIELD_FL_SYSCALL;\n\t\telse if (strcmp(modifier, \"log2\") == 0)\n\t\t\t*flags |= HIST_FIELD_FL_LOG2;\n\t\telse if (strcmp(modifier, \"usecs\") == 0)\n\t\t\t*flags |= HIST_FIELD_FL_TIMESTAMP_USECS;\n\t\telse if (strncmp(modifier, \"bucket\", 6) == 0) {\n\t\t\tint ret;\n\n\t\t\tmodifier += 6;\n\n\t\t\tif (*modifier == 's')\n\t\t\t\tmodifier++;\n\t\t\tif (*modifier != '=')\n\t\t\t\tgoto error;\n\t\t\tmodifier++;\n\t\t\tret = kstrtoul(modifier, 0, buckets);\n\t\t\tif (ret || !(*buckets))\n\t\t\t\tgoto error;\n\t\t\t*flags |= HIST_FIELD_FL_BUCKET;\n\t\t} else {\n error:\n\t\t\thist_err(tr, HIST_ERR_BAD_FIELD_MODIFIER, errpos(modifier));\n\t\t\tfield = ERR_PTR(-EINVAL);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (strcmp(field_name, \"common_timestamp\") == 0) {\n\t\t*flags |= HIST_FIELD_FL_TIMESTAMP;\n\t\thist_data->enable_timestamps = true;\n\t\tif (*flags & HIST_FIELD_FL_TIMESTAMP_USECS)\n\t\t\thist_data->attrs->ts_in_usecs = true;\n\t} else if (strcmp(field_name, \"common_cpu\") == 0)\n\t\t*flags |= HIST_FIELD_FL_CPU;\n\telse {\n\t\tfield = trace_find_event_field(file->event_call, field_name);\n\t\tif (!field || !field->size) {\n\t\t\t/*\n\t\t\t * For backward compatibility, if field_name\n\t\t\t * was \"cpu\", then we treat this the same as\n\t\t\t * common_cpu.\n\t\t\t */\n\t\t\tif (strcmp(field_name, \"cpu\") == 0) {\n\t\t\t\t*flags |= HIST_FIELD_FL_CPU;\n\t\t\t} else {\n\t\t\t\thist_err(tr, HIST_ERR_FIELD_NOT_FOUND,\n\t\t\t\t\t errpos(field_name));\n\t\t\t\tfield = ERR_PTR(-EINVAL);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\n out:\n\tkfree(str);\n\n\treturn field;\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct ftrace_event_field *\nparse_field(struct hist_trigger_data *hist_data, struct trace_event_file *file,\n\t    char *field_str, unsigned long *flags, unsigned long *buckets)\n{\n\tstruct ftrace_event_field *field = NULL;\n\tchar *field_name, *modifier, *str;\n\tstruct trace_array *tr = file->tr;\n\n\tmodifier = str = kstrdup(field_str, GFP_KERNEL);\n\tif (!modifier)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tfield_name = strsep(&modifier, \".\");\n\tif (modifier) {\n\t\tif (strcmp(modifier, \"hex\") == 0)\n\t\t\t*flags |= HIST_FIELD_FL_HEX;\n\t\telse if (strcmp(modifier, \"sym\") == 0)\n\t\t\t*flags |= HIST_FIELD_FL_SYM;\n\t\t/*\n\t\t * 'sym-offset' occurrences in the trigger string are modified\n\t\t * to 'symXoffset' to simplify arithmetic expression parsing.\n\t\t */\n\t\telse if (strcmp(modifier, \"symXoffset\") == 0)\n\t\t\t*flags |= HIST_FIELD_FL_SYM_OFFSET;\n\t\telse if ((strcmp(modifier, \"execname\") == 0) &&\n\t\t\t (strcmp(field_name, \"common_pid\") == 0))\n\t\t\t*flags |= HIST_FIELD_FL_EXECNAME;\n\t\telse if (strcmp(modifier, \"syscall\") == 0)\n\t\t\t*flags |= HIST_FIELD_FL_SYSCALL;\n\t\telse if (strcmp(modifier, \"log2\") == 0)\n\t\t\t*flags |= HIST_FIELD_FL_LOG2;\n\t\telse if (strcmp(modifier, \"usecs\") == 0)\n\t\t\t*flags |= HIST_FIELD_FL_TIMESTAMP_USECS;\n\t\telse if (strncmp(modifier, \"bucket\", 6) == 0) {\n\t\t\tint ret;\n\n\t\t\tmodifier += 6;\n\n\t\t\tif (*modifier == 's')\n\t\t\t\tmodifier++;\n\t\t\tif (*modifier != '=')\n\t\t\t\tgoto error;\n\t\t\tmodifier++;\n\t\t\tret = kstrtoul(modifier, 0, buckets);\n\t\t\tif (ret || !(*buckets))\n\t\t\t\tgoto error;\n\t\t\t*flags |= HIST_FIELD_FL_BUCKET;\n\t\t} else {\n error:\n\t\t\thist_err(tr, HIST_ERR_BAD_FIELD_MODIFIER, errpos(modifier));\n\t\t\tfield = ERR_PTR(-EINVAL);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (strcmp(field_name, \"common_timestamp\") == 0) {\n\t\t*flags |= HIST_FIELD_FL_TIMESTAMP;\n\t\thist_data->enable_timestamps = true;\n\t\tif (*flags & HIST_FIELD_FL_TIMESTAMP_USECS)\n\t\t\thist_data->attrs->ts_in_usecs = true;\n\t} else if (strcmp(field_name, \"common_cpu\") == 0)\n\t\t*flags |= HIST_FIELD_FL_CPU;\n\telse {\n\t\tfield = trace_find_event_field(file->event_call, field_name);\n\t\tif (!field || !field->size) {\n\t\t\t/*\n\t\t\t * For backward compatibility, if field_name\n\t\t\t * was \"cpu\", then we treat this the same as\n\t\t\t * common_cpu.\n\t\t\t */\n\t\t\tif (strcmp(field_name, \"cpu\") == 0) {\n\t\t\t\t*flags |= HIST_FIELD_FL_CPU;\n\t\t\t} else {\n\t\t\t\thist_err(tr, HIST_ERR_FIELD_NOT_FOUND,\n\t\t\t\t\t errpos(field_name));\n\t\t\t\tfield = ERR_PTR(-EINVAL);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\n out:\n\tkfree(str);\n\n\treturn field;\n}"
        }
      },
      {
        "call_info": {
          "callee": "create_alias",
          "args": [
            "hist_data",
            "hist_field",
            "var_name"
          ],
          "line": 2400
        },
        "resolved": true,
        "details": {
          "function_name": "create_alias",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "2310-2332",
          "snippet": "static struct hist_field *create_alias(struct hist_trigger_data *hist_data,\n\t\t\t\t       struct hist_field *var_ref,\n\t\t\t\t       char *var_name)\n{\n\tstruct hist_field *alias = NULL;\n\tunsigned long flags = HIST_FIELD_FL_ALIAS | HIST_FIELD_FL_VAR;\n\n\talias = create_hist_field(hist_data, NULL, flags, var_name);\n\tif (!alias)\n\t\treturn NULL;\n\n\talias->fn = var_ref->fn;\n\talias->operands[0] = var_ref;\n\n\tif (init_var_ref(alias, var_ref, var_ref->system, var_ref->event_name)) {\n\t\tdestroy_hist_field(alias, 0);\n\t\treturn NULL;\n\t}\n\n\talias->var_ref_idx = var_ref->var_ref_idx;\n\n\treturn alias;\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct hist_field *create_alias(struct hist_trigger_data *hist_data,\n\t\t\t\t       struct hist_field *var_ref,\n\t\t\t\t       char *var_name)\n{\n\tstruct hist_field *alias = NULL;\n\tunsigned long flags = HIST_FIELD_FL_ALIAS | HIST_FIELD_FL_VAR;\n\n\talias = create_hist_field(hist_data, NULL, flags, var_name);\n\tif (!alias)\n\t\treturn NULL;\n\n\talias->fn = var_ref->fn;\n\talias->operands[0] = var_ref;\n\n\tif (init_var_ref(alias, var_ref, var_ref->system, var_ref->event_name)) {\n\t\tdestroy_hist_field(alias, 0);\n\t\treturn NULL;\n\t}\n\n\talias->var_ref_idx = var_ref->var_ref_idx;\n\n\treturn alias;\n}"
        }
      },
      {
        "call_info": {
          "callee": "parse_var_ref",
          "args": [
            "hist_data",
            "ref_system",
            "ref_event",
            "ref_var"
          ],
          "line": 2396
        },
        "resolved": true,
        "details": {
          "function_name": "parse_var_ref",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "2201-2222",
          "snippet": "static struct hist_field *parse_var_ref(struct hist_trigger_data *hist_data,\n\t\t\t\t\tchar *system, char *event_name,\n\t\t\t\t\tchar *var_name)\n{\n\tstruct hist_field *var_field = NULL, *ref_field = NULL;\n\tstruct trace_array *tr = hist_data->event_file->tr;\n\n\tif (!is_var_ref(var_name))\n\t\treturn NULL;\n\n\tvar_name++;\n\n\tvar_field = find_event_var(hist_data, system, event_name, var_name);\n\tif (var_field)\n\t\tref_field = create_var_ref(hist_data, var_field,\n\t\t\t\t\t   system, event_name);\n\n\tif (!ref_field)\n\t\thist_err(tr, HIST_ERR_VAR_NOT_FOUND, errpos(var_name));\n\n\treturn ref_field;\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct hist_field *parse_var_ref(struct hist_trigger_data *hist_data,\n\t\t\t\t\tchar *system, char *event_name,\n\t\t\t\t\tchar *var_name)\n{\n\tstruct hist_field *var_field = NULL, *ref_field = NULL;\n\tstruct trace_array *tr = hist_data->event_file->tr;\n\n\tif (!is_var_ref(var_name))\n\t\treturn NULL;\n\n\tvar_name++;\n\n\tvar_field = find_event_var(hist_data, system, event_name, var_name);\n\tif (var_field)\n\t\tref_field = create_var_ref(hist_data, var_field,\n\t\t\t\t\t   system, event_name);\n\n\tif (!ref_field)\n\t\thist_err(tr, HIST_ERR_VAR_NOT_FOUND, errpos(var_name));\n\n\treturn ref_field;\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_field_var_ref",
          "args": [
            "hist_data",
            "ref_system",
            "ref_event",
            "ref_var"
          ],
          "line": 2394
        },
        "resolved": true,
        "details": {
          "function_name": "local_field_var_ref",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "2174-2199",
          "snippet": "static char *local_field_var_ref(struct hist_trigger_data *hist_data,\n\t\t\t\t char *system, char *event_name,\n\t\t\t\t char *var_name)\n{\n\tstruct trace_event_call *call;\n\n\tif (system && event_name) {\n\t\tcall = hist_data->event_file->event_call;\n\n\t\tif (strcmp(system, call->class->system) != 0)\n\t\t\treturn NULL;\n\n\t\tif (strcmp(event_name, trace_event_name(call)) != 0)\n\t\t\treturn NULL;\n\t}\n\n\tif (!!system != !!event_name)\n\t\treturn NULL;\n\n\tif (!is_var_ref(var_name))\n\t\treturn NULL;\n\n\tvar_name++;\n\n\treturn field_name_from_var(hist_data, var_name);\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic char *local_field_var_ref(struct hist_trigger_data *hist_data,\n\t\t\t\t char *system, char *event_name,\n\t\t\t\t char *var_name)\n{\n\tstruct trace_event_call *call;\n\n\tif (system && event_name) {\n\t\tcall = hist_data->event_file->event_call;\n\n\t\tif (strcmp(system, call->class->system) != 0)\n\t\t\treturn NULL;\n\n\t\tif (strcmp(event_name, trace_event_name(call)) != 0)\n\t\t\treturn NULL;\n\t}\n\n\tif (!!system != !!event_name)\n\t\treturn NULL;\n\n\tif (!is_var_ref(var_name))\n\t\treturn NULL;\n\n\tvar_name++;\n\n\treturn field_name_from_var(hist_data, var_name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strsep",
          "args": [
            "&str",
            "\".\""
          ],
          "line": 2385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strsep",
          "args": [
            "&str",
            "\".\""
          ],
          "line": 2380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "++s",
            "'.'"
          ],
          "line": 2378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "str",
            "'.'"
          ],
          "line": 2376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parse_const",
          "args": [
            "hist_data",
            "str",
            "var_name",
            "flags"
          ],
          "line": 2368
        },
        "resolved": true,
        "details": {
          "function_name": "parse_const",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "2334-2355",
          "snippet": "static struct hist_field *parse_const(struct hist_trigger_data *hist_data,\n\t\t\t\t      char *str, char *var_name,\n\t\t\t\t      unsigned long *flags)\n{\n\tstruct trace_array *tr = hist_data->event_file->tr;\n\tstruct hist_field *field = NULL;\n\tu64 constant;\n\n\tif (kstrtoull(str, 0, &constant)) {\n\t\thist_err(tr, HIST_ERR_EXPECT_NUMBER, errpos(str));\n\t\treturn NULL;\n\t}\n\n\t*flags |= HIST_FIELD_FL_CONST;\n\tfield = create_hist_field(hist_data, NULL, *flags, var_name);\n\tif (!field)\n\t\treturn NULL;\n\n\tfield->constant = constant;\n\n\treturn field;\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct hist_field *parse_const(struct hist_trigger_data *hist_data,\n\t\t\t\t      char *str, char *var_name,\n\t\t\t\t      unsigned long *flags)\n{\n\tstruct trace_array *tr = hist_data->event_file->tr;\n\tstruct hist_field *field = NULL;\n\tu64 constant;\n\n\tif (kstrtoull(str, 0, &constant)) {\n\t\thist_err(tr, HIST_ERR_EXPECT_NUMBER, errpos(str));\n\t\treturn NULL;\n\t}\n\n\t*flags |= HIST_FIELD_FL_CONST;\n\tfield = create_hist_field(hist_data, NULL, *flags, var_name);\n\tif (!field)\n\t\treturn NULL;\n\n\tfield->constant = constant;\n\n\treturn field;\n}"
        }
      },
      {
        "call_info": {
          "callee": "isdigit",
          "args": [
            "str[0]"
          ],
          "line": 2367
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct hist_field *parse_atom(struct hist_trigger_data *hist_data,\n\t\t\t\t     struct trace_event_file *file, char *str,\n\t\t\t\t     unsigned long *flags, char *var_name)\n{\n\tchar *s, *ref_system = NULL, *ref_event = NULL, *ref_var = str;\n\tstruct ftrace_event_field *field = NULL;\n\tstruct hist_field *hist_field = NULL;\n\tunsigned long buckets = 0;\n\tint ret = 0;\n\n\tif (isdigit(str[0])) {\n\t\thist_field = parse_const(hist_data, str, var_name, flags);\n\t\tif (!hist_field) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\treturn hist_field;\n\t}\n\n\ts = strchr(str, '.');\n\tif (s) {\n\t\ts = strchr(++s, '.');\n\t\tif (s) {\n\t\t\tref_system = strsep(&str, \".\");\n\t\t\tif (!str) {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tref_event = strsep(&str, \".\");\n\t\t\tif (!str) {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tref_var = str;\n\t\t}\n\t}\n\n\ts = local_field_var_ref(hist_data, ref_system, ref_event, ref_var);\n\tif (!s) {\n\t\thist_field = parse_var_ref(hist_data, ref_system,\n\t\t\t\t\t   ref_event, ref_var);\n\t\tif (hist_field) {\n\t\t\tif (var_name) {\n\t\t\t\thist_field = create_alias(hist_data, hist_field, var_name);\n\t\t\t\tif (!hist_field) {\n\t\t\t\t\tret = -ENOMEM;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn hist_field;\n\t\t}\n\t} else\n\t\tstr = s;\n\n\tfield = parse_field(hist_data, file, str, flags, &buckets);\n\tif (IS_ERR(field)) {\n\t\tret = PTR_ERR(field);\n\t\tgoto out;\n\t}\n\n\thist_field = create_hist_field(hist_data, field, *flags, var_name);\n\tif (!hist_field) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\thist_field->buckets = buckets;\n\n\treturn hist_field;\n out:\n\treturn ERR_PTR(ret);\n}"
  },
  {
    "function_name": "parse_const",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
    "lines": "2334-2355",
    "snippet": "static struct hist_field *parse_const(struct hist_trigger_data *hist_data,\n\t\t\t\t      char *str, char *var_name,\n\t\t\t\t      unsigned long *flags)\n{\n\tstruct trace_array *tr = hist_data->event_file->tr;\n\tstruct hist_field *field = NULL;\n\tu64 constant;\n\n\tif (kstrtoull(str, 0, &constant)) {\n\t\thist_err(tr, HIST_ERR_EXPECT_NUMBER, errpos(str));\n\t\treturn NULL;\n\t}\n\n\t*flags |= HIST_FIELD_FL_CONST;\n\tfield = create_hist_field(hist_data, NULL, *flags, var_name);\n\tif (!field)\n\t\treturn NULL;\n\n\tfield->constant = constant;\n\n\treturn field;\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include \"tracing_map.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "create_hist_field",
          "args": [
            "hist_data",
            "NULL",
            "*flags",
            "var_name"
          ],
          "line": 2348
        },
        "resolved": true,
        "details": {
          "function_name": "create_hist_field",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "1884-2007",
          "snippet": "static struct hist_field *create_hist_field(struct hist_trigger_data *hist_data,\n\t\t\t\t\t    struct ftrace_event_field *field,\n\t\t\t\t\t    unsigned long flags,\n\t\t\t\t\t    char *var_name)\n{\n\tstruct hist_field *hist_field;\n\n\tif (field && is_function_field(field))\n\t\treturn NULL;\n\n\thist_field = kzalloc(sizeof(struct hist_field), GFP_KERNEL);\n\tif (!hist_field)\n\t\treturn NULL;\n\n\thist_field->ref = 1;\n\n\thist_field->hist_data = hist_data;\n\n\tif (flags & HIST_FIELD_FL_EXPR || flags & HIST_FIELD_FL_ALIAS)\n\t\tgoto out; /* caller will populate */\n\n\tif (flags & HIST_FIELD_FL_VAR_REF) {\n\t\thist_field->fn = hist_field_var_ref;\n\t\tgoto out;\n\t}\n\n\tif (flags & HIST_FIELD_FL_HITCOUNT) {\n\t\thist_field->fn = hist_field_counter;\n\t\thist_field->size = sizeof(u64);\n\t\thist_field->type = \"u64\";\n\t\tgoto out;\n\t}\n\n\tif (flags & HIST_FIELD_FL_CONST) {\n\t\thist_field->fn = hist_field_const;\n\t\thist_field->size = sizeof(u64);\n\t\thist_field->type = kstrdup(\"u64\", GFP_KERNEL);\n\t\tif (!hist_field->type)\n\t\t\tgoto free;\n\t\tgoto out;\n\t}\n\n\tif (flags & HIST_FIELD_FL_STACKTRACE) {\n\t\thist_field->fn = hist_field_none;\n\t\tgoto out;\n\t}\n\n\tif (flags & (HIST_FIELD_FL_LOG2 | HIST_FIELD_FL_BUCKET)) {\n\t\tunsigned long fl = flags & ~(HIST_FIELD_FL_LOG2 | HIST_FIELD_FL_BUCKET);\n\t\thist_field->fn = flags & HIST_FIELD_FL_LOG2 ? hist_field_log2 :\n\t\t\thist_field_bucket;\n\t\thist_field->operands[0] = create_hist_field(hist_data, field, fl, NULL);\n\t\thist_field->size = hist_field->operands[0]->size;\n\t\thist_field->type = kstrdup_const(hist_field->operands[0]->type, GFP_KERNEL);\n\t\tif (!hist_field->type)\n\t\t\tgoto free;\n\t\tgoto out;\n\t}\n\n\tif (flags & HIST_FIELD_FL_TIMESTAMP) {\n\t\thist_field->fn = hist_field_timestamp;\n\t\thist_field->size = sizeof(u64);\n\t\thist_field->type = \"u64\";\n\t\tgoto out;\n\t}\n\n\tif (flags & HIST_FIELD_FL_CPU) {\n\t\thist_field->fn = hist_field_cpu;\n\t\thist_field->size = sizeof(int);\n\t\thist_field->type = \"unsigned int\";\n\t\tgoto out;\n\t}\n\n\tif (WARN_ON_ONCE(!field))\n\t\tgoto out;\n\n\t/* Pointers to strings are just pointers and dangerous to dereference */\n\tif (is_string_field(field) &&\n\t    (field->filter_type != FILTER_PTR_STRING)) {\n\t\tflags |= HIST_FIELD_FL_STRING;\n\n\t\thist_field->size = MAX_FILTER_STR_VAL;\n\t\thist_field->type = kstrdup_const(field->type, GFP_KERNEL);\n\t\tif (!hist_field->type)\n\t\t\tgoto free;\n\n\t\tif (field->filter_type == FILTER_STATIC_STRING) {\n\t\t\thist_field->fn = hist_field_string;\n\t\t\thist_field->size = field->size;\n\t\t} else if (field->filter_type == FILTER_DYN_STRING) {\n\t\t\thist_field->fn = hist_field_dynstring;\n\t\t} else if (field->filter_type == FILTER_RDYN_STRING)\n\t\t\thist_field->fn = hist_field_reldynstring;\n\t\telse\n\t\t\thist_field->fn = hist_field_pstring;\n\t} else {\n\t\thist_field->size = field->size;\n\t\thist_field->is_signed = field->is_signed;\n\t\thist_field->type = kstrdup_const(field->type, GFP_KERNEL);\n\t\tif (!hist_field->type)\n\t\t\tgoto free;\n\n\t\thist_field->fn = select_value_fn(field->size,\n\t\t\t\t\t\t field->is_signed);\n\t\tif (!hist_field->fn) {\n\t\t\tdestroy_hist_field(hist_field, 0);\n\t\t\treturn NULL;\n\t\t}\n\t}\n out:\n\thist_field->field = field;\n\thist_field->flags = flags;\n\n\tif (var_name) {\n\t\thist_field->var.name = kstrdup(var_name, GFP_KERNEL);\n\t\tif (!hist_field->var.name)\n\t\t\tgoto free;\n\t}\n\n\treturn hist_field;\n free:\n\tdestroy_hist_field(hist_field, 0);\n\treturn NULL;\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct hist_field *create_hist_field(struct hist_trigger_data *hist_data,\n\t\t\t\t\t    struct ftrace_event_field *field,\n\t\t\t\t\t    unsigned long flags,\n\t\t\t\t\t    char *var_name)\n{\n\tstruct hist_field *hist_field;\n\n\tif (field && is_function_field(field))\n\t\treturn NULL;\n\n\thist_field = kzalloc(sizeof(struct hist_field), GFP_KERNEL);\n\tif (!hist_field)\n\t\treturn NULL;\n\n\thist_field->ref = 1;\n\n\thist_field->hist_data = hist_data;\n\n\tif (flags & HIST_FIELD_FL_EXPR || flags & HIST_FIELD_FL_ALIAS)\n\t\tgoto out; /* caller will populate */\n\n\tif (flags & HIST_FIELD_FL_VAR_REF) {\n\t\thist_field->fn = hist_field_var_ref;\n\t\tgoto out;\n\t}\n\n\tif (flags & HIST_FIELD_FL_HITCOUNT) {\n\t\thist_field->fn = hist_field_counter;\n\t\thist_field->size = sizeof(u64);\n\t\thist_field->type = \"u64\";\n\t\tgoto out;\n\t}\n\n\tif (flags & HIST_FIELD_FL_CONST) {\n\t\thist_field->fn = hist_field_const;\n\t\thist_field->size = sizeof(u64);\n\t\thist_field->type = kstrdup(\"u64\", GFP_KERNEL);\n\t\tif (!hist_field->type)\n\t\t\tgoto free;\n\t\tgoto out;\n\t}\n\n\tif (flags & HIST_FIELD_FL_STACKTRACE) {\n\t\thist_field->fn = hist_field_none;\n\t\tgoto out;\n\t}\n\n\tif (flags & (HIST_FIELD_FL_LOG2 | HIST_FIELD_FL_BUCKET)) {\n\t\tunsigned long fl = flags & ~(HIST_FIELD_FL_LOG2 | HIST_FIELD_FL_BUCKET);\n\t\thist_field->fn = flags & HIST_FIELD_FL_LOG2 ? hist_field_log2 :\n\t\t\thist_field_bucket;\n\t\thist_field->operands[0] = create_hist_field(hist_data, field, fl, NULL);\n\t\thist_field->size = hist_field->operands[0]->size;\n\t\thist_field->type = kstrdup_const(hist_field->operands[0]->type, GFP_KERNEL);\n\t\tif (!hist_field->type)\n\t\t\tgoto free;\n\t\tgoto out;\n\t}\n\n\tif (flags & HIST_FIELD_FL_TIMESTAMP) {\n\t\thist_field->fn = hist_field_timestamp;\n\t\thist_field->size = sizeof(u64);\n\t\thist_field->type = \"u64\";\n\t\tgoto out;\n\t}\n\n\tif (flags & HIST_FIELD_FL_CPU) {\n\t\thist_field->fn = hist_field_cpu;\n\t\thist_field->size = sizeof(int);\n\t\thist_field->type = \"unsigned int\";\n\t\tgoto out;\n\t}\n\n\tif (WARN_ON_ONCE(!field))\n\t\tgoto out;\n\n\t/* Pointers to strings are just pointers and dangerous to dereference */\n\tif (is_string_field(field) &&\n\t    (field->filter_type != FILTER_PTR_STRING)) {\n\t\tflags |= HIST_FIELD_FL_STRING;\n\n\t\thist_field->size = MAX_FILTER_STR_VAL;\n\t\thist_field->type = kstrdup_const(field->type, GFP_KERNEL);\n\t\tif (!hist_field->type)\n\t\t\tgoto free;\n\n\t\tif (field->filter_type == FILTER_STATIC_STRING) {\n\t\t\thist_field->fn = hist_field_string;\n\t\t\thist_field->size = field->size;\n\t\t} else if (field->filter_type == FILTER_DYN_STRING) {\n\t\t\thist_field->fn = hist_field_dynstring;\n\t\t} else if (field->filter_type == FILTER_RDYN_STRING)\n\t\t\thist_field->fn = hist_field_reldynstring;\n\t\telse\n\t\t\thist_field->fn = hist_field_pstring;\n\t} else {\n\t\thist_field->size = field->size;\n\t\thist_field->is_signed = field->is_signed;\n\t\thist_field->type = kstrdup_const(field->type, GFP_KERNEL);\n\t\tif (!hist_field->type)\n\t\t\tgoto free;\n\n\t\thist_field->fn = select_value_fn(field->size,\n\t\t\t\t\t\t field->is_signed);\n\t\tif (!hist_field->fn) {\n\t\t\tdestroy_hist_field(hist_field, 0);\n\t\t\treturn NULL;\n\t\t}\n\t}\n out:\n\thist_field->field = field;\n\thist_field->flags = flags;\n\n\tif (var_name) {\n\t\thist_field->var.name = kstrdup(var_name, GFP_KERNEL);\n\t\tif (!hist_field->var.name)\n\t\t\tgoto free;\n\t}\n\n\treturn hist_field;\n free:\n\tdestroy_hist_field(hist_field, 0);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hist_err",
          "args": [
            "tr",
            "HIST_ERR_EXPECT_NUMBER",
            "errpos(str)"
          ],
          "line": 2343
        },
        "resolved": true,
        "details": {
          "function_name": "hist_err",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "763-767",
          "snippet": "static void hist_err(struct trace_array *tr, u8 err_type, u8 err_pos)\n{\n\ttracing_log_err(tr, last_cmd_loc, last_cmd, err_text,\n\t\t\terr_type, err_pos);\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *err_text[] = { ERRORS };",
            "static char last_cmd[MAX_FILTER_STR_VAL];",
            "static char last_cmd_loc[MAX_FILTER_STR_VAL];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic const char *err_text[] = { ERRORS };\nstatic char last_cmd[MAX_FILTER_STR_VAL];\nstatic char last_cmd_loc[MAX_FILTER_STR_VAL];\n\nstatic void hist_err(struct trace_array *tr, u8 err_type, u8 err_pos)\n{\n\ttracing_log_err(tr, last_cmd_loc, last_cmd, err_text,\n\t\t\terr_type, err_pos);\n}"
        }
      },
      {
        "call_info": {
          "callee": "errpos",
          "args": [
            "str"
          ],
          "line": 2343
        },
        "resolved": true,
        "details": {
          "function_name": "errpos",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "733-736",
          "snippet": "static int errpos(char *str)\n{\n\treturn err_pos(last_cmd, str);\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char last_cmd[MAX_FILTER_STR_VAL];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic char last_cmd[MAX_FILTER_STR_VAL];\n\nstatic int errpos(char *str)\n{\n\treturn err_pos(last_cmd, str);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kstrtoull",
          "args": [
            "str",
            "0",
            "&constant"
          ],
          "line": 2342
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct hist_field *parse_const(struct hist_trigger_data *hist_data,\n\t\t\t\t      char *str, char *var_name,\n\t\t\t\t      unsigned long *flags)\n{\n\tstruct trace_array *tr = hist_data->event_file->tr;\n\tstruct hist_field *field = NULL;\n\tu64 constant;\n\n\tif (kstrtoull(str, 0, &constant)) {\n\t\thist_err(tr, HIST_ERR_EXPECT_NUMBER, errpos(str));\n\t\treturn NULL;\n\t}\n\n\t*flags |= HIST_FIELD_FL_CONST;\n\tfield = create_hist_field(hist_data, NULL, *flags, var_name);\n\tif (!field)\n\t\treturn NULL;\n\n\tfield->constant = constant;\n\n\treturn field;\n}"
  },
  {
    "function_name": "create_alias",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
    "lines": "2310-2332",
    "snippet": "static struct hist_field *create_alias(struct hist_trigger_data *hist_data,\n\t\t\t\t       struct hist_field *var_ref,\n\t\t\t\t       char *var_name)\n{\n\tstruct hist_field *alias = NULL;\n\tunsigned long flags = HIST_FIELD_FL_ALIAS | HIST_FIELD_FL_VAR;\n\n\talias = create_hist_field(hist_data, NULL, flags, var_name);\n\tif (!alias)\n\t\treturn NULL;\n\n\talias->fn = var_ref->fn;\n\talias->operands[0] = var_ref;\n\n\tif (init_var_ref(alias, var_ref, var_ref->system, var_ref->event_name)) {\n\t\tdestroy_hist_field(alias, 0);\n\t\treturn NULL;\n\t}\n\n\talias->var_ref_idx = var_ref->var_ref_idx;\n\n\treturn alias;\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include \"tracing_map.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "destroy_hist_field",
          "args": [
            "alias",
            "0"
          ],
          "line": 2325
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_hist_field",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "1864-1882",
          "snippet": "static void destroy_hist_field(struct hist_field *hist_field,\n\t\t\t       unsigned int level)\n{\n\tunsigned int i;\n\n\tif (level > 3)\n\t\treturn;\n\n\tif (!hist_field)\n\t\treturn;\n\n\tif (hist_field->flags & HIST_FIELD_FL_VAR_REF)\n\t\treturn; /* var refs will be destroyed separately */\n\n\tfor (i = 0; i < HIST_FIELD_OPERANDS_MAX; i++)\n\t\tdestroy_hist_field(hist_field->operands[i], level + 1);\n\n\t__destroy_hist_field(hist_field);\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define HIST_FIELD_OPERANDS_MAX\t2"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\n#define HIST_FIELD_OPERANDS_MAX\t2\n\nstatic void destroy_hist_field(struct hist_field *hist_field,\n\t\t\t       unsigned int level)\n{\n\tunsigned int i;\n\n\tif (level > 3)\n\t\treturn;\n\n\tif (!hist_field)\n\t\treturn;\n\n\tif (hist_field->flags & HIST_FIELD_FL_VAR_REF)\n\t\treturn; /* var refs will be destroyed separately */\n\n\tfor (i = 0; i < HIST_FIELD_OPERANDS_MAX; i++)\n\t\tdestroy_hist_field(hist_field->operands[i], level + 1);\n\n\t__destroy_hist_field(hist_field);\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_var_ref",
          "args": [
            "alias",
            "var_ref",
            "var_ref->system",
            "var_ref->event_name"
          ],
          "line": 2324
        },
        "resolved": true,
        "details": {
          "function_name": "init_var_ref",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "2027-2081",
          "snippet": "static int init_var_ref(struct hist_field *ref_field,\n\t\t\tstruct hist_field *var_field,\n\t\t\tchar *system, char *event_name)\n{\n\tint err = 0;\n\n\tref_field->var.idx = var_field->var.idx;\n\tref_field->var.hist_data = var_field->hist_data;\n\tref_field->size = var_field->size;\n\tref_field->is_signed = var_field->is_signed;\n\tref_field->flags |= var_field->flags &\n\t\t(HIST_FIELD_FL_TIMESTAMP | HIST_FIELD_FL_TIMESTAMP_USECS);\n\n\tif (system) {\n\t\tref_field->system = kstrdup(system, GFP_KERNEL);\n\t\tif (!ref_field->system)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tif (event_name) {\n\t\tref_field->event_name = kstrdup(event_name, GFP_KERNEL);\n\t\tif (!ref_field->event_name) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto free;\n\t\t}\n\t}\n\n\tif (var_field->var.name) {\n\t\tref_field->name = kstrdup(var_field->var.name, GFP_KERNEL);\n\t\tif (!ref_field->name) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto free;\n\t\t}\n\t} else if (var_field->name) {\n\t\tref_field->name = kstrdup(var_field->name, GFP_KERNEL);\n\t\tif (!ref_field->name) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto free;\n\t\t}\n\t}\n\n\tref_field->type = kstrdup_const(var_field->type, GFP_KERNEL);\n\tif (!ref_field->type) {\n\t\terr = -ENOMEM;\n\t\tgoto free;\n\t}\n out:\n\treturn err;\n free:\n\tkfree(ref_field->system);\n\tkfree(ref_field->event_name);\n\tkfree(ref_field->name);\n\n\tgoto out;\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int init_var_ref(struct hist_field *ref_field,\n\t\t\tstruct hist_field *var_field,\n\t\t\tchar *system, char *event_name)\n{\n\tint err = 0;\n\n\tref_field->var.idx = var_field->var.idx;\n\tref_field->var.hist_data = var_field->hist_data;\n\tref_field->size = var_field->size;\n\tref_field->is_signed = var_field->is_signed;\n\tref_field->flags |= var_field->flags &\n\t\t(HIST_FIELD_FL_TIMESTAMP | HIST_FIELD_FL_TIMESTAMP_USECS);\n\n\tif (system) {\n\t\tref_field->system = kstrdup(system, GFP_KERNEL);\n\t\tif (!ref_field->system)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tif (event_name) {\n\t\tref_field->event_name = kstrdup(event_name, GFP_KERNEL);\n\t\tif (!ref_field->event_name) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto free;\n\t\t}\n\t}\n\n\tif (var_field->var.name) {\n\t\tref_field->name = kstrdup(var_field->var.name, GFP_KERNEL);\n\t\tif (!ref_field->name) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto free;\n\t\t}\n\t} else if (var_field->name) {\n\t\tref_field->name = kstrdup(var_field->name, GFP_KERNEL);\n\t\tif (!ref_field->name) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto free;\n\t\t}\n\t}\n\n\tref_field->type = kstrdup_const(var_field->type, GFP_KERNEL);\n\tif (!ref_field->type) {\n\t\terr = -ENOMEM;\n\t\tgoto free;\n\t}\n out:\n\treturn err;\n free:\n\tkfree(ref_field->system);\n\tkfree(ref_field->event_name);\n\tkfree(ref_field->name);\n\n\tgoto out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "create_hist_field",
          "args": [
            "hist_data",
            "NULL",
            "flags",
            "var_name"
          ],
          "line": 2317
        },
        "resolved": true,
        "details": {
          "function_name": "create_hist_field",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "1884-2007",
          "snippet": "static struct hist_field *create_hist_field(struct hist_trigger_data *hist_data,\n\t\t\t\t\t    struct ftrace_event_field *field,\n\t\t\t\t\t    unsigned long flags,\n\t\t\t\t\t    char *var_name)\n{\n\tstruct hist_field *hist_field;\n\n\tif (field && is_function_field(field))\n\t\treturn NULL;\n\n\thist_field = kzalloc(sizeof(struct hist_field), GFP_KERNEL);\n\tif (!hist_field)\n\t\treturn NULL;\n\n\thist_field->ref = 1;\n\n\thist_field->hist_data = hist_data;\n\n\tif (flags & HIST_FIELD_FL_EXPR || flags & HIST_FIELD_FL_ALIAS)\n\t\tgoto out; /* caller will populate */\n\n\tif (flags & HIST_FIELD_FL_VAR_REF) {\n\t\thist_field->fn = hist_field_var_ref;\n\t\tgoto out;\n\t}\n\n\tif (flags & HIST_FIELD_FL_HITCOUNT) {\n\t\thist_field->fn = hist_field_counter;\n\t\thist_field->size = sizeof(u64);\n\t\thist_field->type = \"u64\";\n\t\tgoto out;\n\t}\n\n\tif (flags & HIST_FIELD_FL_CONST) {\n\t\thist_field->fn = hist_field_const;\n\t\thist_field->size = sizeof(u64);\n\t\thist_field->type = kstrdup(\"u64\", GFP_KERNEL);\n\t\tif (!hist_field->type)\n\t\t\tgoto free;\n\t\tgoto out;\n\t}\n\n\tif (flags & HIST_FIELD_FL_STACKTRACE) {\n\t\thist_field->fn = hist_field_none;\n\t\tgoto out;\n\t}\n\n\tif (flags & (HIST_FIELD_FL_LOG2 | HIST_FIELD_FL_BUCKET)) {\n\t\tunsigned long fl = flags & ~(HIST_FIELD_FL_LOG2 | HIST_FIELD_FL_BUCKET);\n\t\thist_field->fn = flags & HIST_FIELD_FL_LOG2 ? hist_field_log2 :\n\t\t\thist_field_bucket;\n\t\thist_field->operands[0] = create_hist_field(hist_data, field, fl, NULL);\n\t\thist_field->size = hist_field->operands[0]->size;\n\t\thist_field->type = kstrdup_const(hist_field->operands[0]->type, GFP_KERNEL);\n\t\tif (!hist_field->type)\n\t\t\tgoto free;\n\t\tgoto out;\n\t}\n\n\tif (flags & HIST_FIELD_FL_TIMESTAMP) {\n\t\thist_field->fn = hist_field_timestamp;\n\t\thist_field->size = sizeof(u64);\n\t\thist_field->type = \"u64\";\n\t\tgoto out;\n\t}\n\n\tif (flags & HIST_FIELD_FL_CPU) {\n\t\thist_field->fn = hist_field_cpu;\n\t\thist_field->size = sizeof(int);\n\t\thist_field->type = \"unsigned int\";\n\t\tgoto out;\n\t}\n\n\tif (WARN_ON_ONCE(!field))\n\t\tgoto out;\n\n\t/* Pointers to strings are just pointers and dangerous to dereference */\n\tif (is_string_field(field) &&\n\t    (field->filter_type != FILTER_PTR_STRING)) {\n\t\tflags |= HIST_FIELD_FL_STRING;\n\n\t\thist_field->size = MAX_FILTER_STR_VAL;\n\t\thist_field->type = kstrdup_const(field->type, GFP_KERNEL);\n\t\tif (!hist_field->type)\n\t\t\tgoto free;\n\n\t\tif (field->filter_type == FILTER_STATIC_STRING) {\n\t\t\thist_field->fn = hist_field_string;\n\t\t\thist_field->size = field->size;\n\t\t} else if (field->filter_type == FILTER_DYN_STRING) {\n\t\t\thist_field->fn = hist_field_dynstring;\n\t\t} else if (field->filter_type == FILTER_RDYN_STRING)\n\t\t\thist_field->fn = hist_field_reldynstring;\n\t\telse\n\t\t\thist_field->fn = hist_field_pstring;\n\t} else {\n\t\thist_field->size = field->size;\n\t\thist_field->is_signed = field->is_signed;\n\t\thist_field->type = kstrdup_const(field->type, GFP_KERNEL);\n\t\tif (!hist_field->type)\n\t\t\tgoto free;\n\n\t\thist_field->fn = select_value_fn(field->size,\n\t\t\t\t\t\t field->is_signed);\n\t\tif (!hist_field->fn) {\n\t\t\tdestroy_hist_field(hist_field, 0);\n\t\t\treturn NULL;\n\t\t}\n\t}\n out:\n\thist_field->field = field;\n\thist_field->flags = flags;\n\n\tif (var_name) {\n\t\thist_field->var.name = kstrdup(var_name, GFP_KERNEL);\n\t\tif (!hist_field->var.name)\n\t\t\tgoto free;\n\t}\n\n\treturn hist_field;\n free:\n\tdestroy_hist_field(hist_field, 0);\n\treturn NULL;\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct hist_field *create_hist_field(struct hist_trigger_data *hist_data,\n\t\t\t\t\t    struct ftrace_event_field *field,\n\t\t\t\t\t    unsigned long flags,\n\t\t\t\t\t    char *var_name)\n{\n\tstruct hist_field *hist_field;\n\n\tif (field && is_function_field(field))\n\t\treturn NULL;\n\n\thist_field = kzalloc(sizeof(struct hist_field), GFP_KERNEL);\n\tif (!hist_field)\n\t\treturn NULL;\n\n\thist_field->ref = 1;\n\n\thist_field->hist_data = hist_data;\n\n\tif (flags & HIST_FIELD_FL_EXPR || flags & HIST_FIELD_FL_ALIAS)\n\t\tgoto out; /* caller will populate */\n\n\tif (flags & HIST_FIELD_FL_VAR_REF) {\n\t\thist_field->fn = hist_field_var_ref;\n\t\tgoto out;\n\t}\n\n\tif (flags & HIST_FIELD_FL_HITCOUNT) {\n\t\thist_field->fn = hist_field_counter;\n\t\thist_field->size = sizeof(u64);\n\t\thist_field->type = \"u64\";\n\t\tgoto out;\n\t}\n\n\tif (flags & HIST_FIELD_FL_CONST) {\n\t\thist_field->fn = hist_field_const;\n\t\thist_field->size = sizeof(u64);\n\t\thist_field->type = kstrdup(\"u64\", GFP_KERNEL);\n\t\tif (!hist_field->type)\n\t\t\tgoto free;\n\t\tgoto out;\n\t}\n\n\tif (flags & HIST_FIELD_FL_STACKTRACE) {\n\t\thist_field->fn = hist_field_none;\n\t\tgoto out;\n\t}\n\n\tif (flags & (HIST_FIELD_FL_LOG2 | HIST_FIELD_FL_BUCKET)) {\n\t\tunsigned long fl = flags & ~(HIST_FIELD_FL_LOG2 | HIST_FIELD_FL_BUCKET);\n\t\thist_field->fn = flags & HIST_FIELD_FL_LOG2 ? hist_field_log2 :\n\t\t\thist_field_bucket;\n\t\thist_field->operands[0] = create_hist_field(hist_data, field, fl, NULL);\n\t\thist_field->size = hist_field->operands[0]->size;\n\t\thist_field->type = kstrdup_const(hist_field->operands[0]->type, GFP_KERNEL);\n\t\tif (!hist_field->type)\n\t\t\tgoto free;\n\t\tgoto out;\n\t}\n\n\tif (flags & HIST_FIELD_FL_TIMESTAMP) {\n\t\thist_field->fn = hist_field_timestamp;\n\t\thist_field->size = sizeof(u64);\n\t\thist_field->type = \"u64\";\n\t\tgoto out;\n\t}\n\n\tif (flags & HIST_FIELD_FL_CPU) {\n\t\thist_field->fn = hist_field_cpu;\n\t\thist_field->size = sizeof(int);\n\t\thist_field->type = \"unsigned int\";\n\t\tgoto out;\n\t}\n\n\tif (WARN_ON_ONCE(!field))\n\t\tgoto out;\n\n\t/* Pointers to strings are just pointers and dangerous to dereference */\n\tif (is_string_field(field) &&\n\t    (field->filter_type != FILTER_PTR_STRING)) {\n\t\tflags |= HIST_FIELD_FL_STRING;\n\n\t\thist_field->size = MAX_FILTER_STR_VAL;\n\t\thist_field->type = kstrdup_const(field->type, GFP_KERNEL);\n\t\tif (!hist_field->type)\n\t\t\tgoto free;\n\n\t\tif (field->filter_type == FILTER_STATIC_STRING) {\n\t\t\thist_field->fn = hist_field_string;\n\t\t\thist_field->size = field->size;\n\t\t} else if (field->filter_type == FILTER_DYN_STRING) {\n\t\t\thist_field->fn = hist_field_dynstring;\n\t\t} else if (field->filter_type == FILTER_RDYN_STRING)\n\t\t\thist_field->fn = hist_field_reldynstring;\n\t\telse\n\t\t\thist_field->fn = hist_field_pstring;\n\t} else {\n\t\thist_field->size = field->size;\n\t\thist_field->is_signed = field->is_signed;\n\t\thist_field->type = kstrdup_const(field->type, GFP_KERNEL);\n\t\tif (!hist_field->type)\n\t\t\tgoto free;\n\n\t\thist_field->fn = select_value_fn(field->size,\n\t\t\t\t\t\t field->is_signed);\n\t\tif (!hist_field->fn) {\n\t\t\tdestroy_hist_field(hist_field, 0);\n\t\t\treturn NULL;\n\t\t}\n\t}\n out:\n\thist_field->field = field;\n\thist_field->flags = flags;\n\n\tif (var_name) {\n\t\thist_field->var.name = kstrdup(var_name, GFP_KERNEL);\n\t\tif (!hist_field->var.name)\n\t\t\tgoto free;\n\t}\n\n\treturn hist_field;\n free:\n\tdestroy_hist_field(hist_field, 0);\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct hist_field *create_alias(struct hist_trigger_data *hist_data,\n\t\t\t\t       struct hist_field *var_ref,\n\t\t\t\t       char *var_name)\n{\n\tstruct hist_field *alias = NULL;\n\tunsigned long flags = HIST_FIELD_FL_ALIAS | HIST_FIELD_FL_VAR;\n\n\talias = create_hist_field(hist_data, NULL, flags, var_name);\n\tif (!alias)\n\t\treturn NULL;\n\n\talias->fn = var_ref->fn;\n\talias->operands[0] = var_ref;\n\n\tif (init_var_ref(alias, var_ref, var_ref->system, var_ref->event_name)) {\n\t\tdestroy_hist_field(alias, 0);\n\t\treturn NULL;\n\t}\n\n\talias->var_ref_idx = var_ref->var_ref_idx;\n\n\treturn alias;\n}"
  },
  {
    "function_name": "parse_field",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
    "lines": "2224-2308",
    "snippet": "static struct ftrace_event_field *\nparse_field(struct hist_trigger_data *hist_data, struct trace_event_file *file,\n\t    char *field_str, unsigned long *flags, unsigned long *buckets)\n{\n\tstruct ftrace_event_field *field = NULL;\n\tchar *field_name, *modifier, *str;\n\tstruct trace_array *tr = file->tr;\n\n\tmodifier = str = kstrdup(field_str, GFP_KERNEL);\n\tif (!modifier)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tfield_name = strsep(&modifier, \".\");\n\tif (modifier) {\n\t\tif (strcmp(modifier, \"hex\") == 0)\n\t\t\t*flags |= HIST_FIELD_FL_HEX;\n\t\telse if (strcmp(modifier, \"sym\") == 0)\n\t\t\t*flags |= HIST_FIELD_FL_SYM;\n\t\t/*\n\t\t * 'sym-offset' occurrences in the trigger string are modified\n\t\t * to 'symXoffset' to simplify arithmetic expression parsing.\n\t\t */\n\t\telse if (strcmp(modifier, \"symXoffset\") == 0)\n\t\t\t*flags |= HIST_FIELD_FL_SYM_OFFSET;\n\t\telse if ((strcmp(modifier, \"execname\") == 0) &&\n\t\t\t (strcmp(field_name, \"common_pid\") == 0))\n\t\t\t*flags |= HIST_FIELD_FL_EXECNAME;\n\t\telse if (strcmp(modifier, \"syscall\") == 0)\n\t\t\t*flags |= HIST_FIELD_FL_SYSCALL;\n\t\telse if (strcmp(modifier, \"log2\") == 0)\n\t\t\t*flags |= HIST_FIELD_FL_LOG2;\n\t\telse if (strcmp(modifier, \"usecs\") == 0)\n\t\t\t*flags |= HIST_FIELD_FL_TIMESTAMP_USECS;\n\t\telse if (strncmp(modifier, \"bucket\", 6) == 0) {\n\t\t\tint ret;\n\n\t\t\tmodifier += 6;\n\n\t\t\tif (*modifier == 's')\n\t\t\t\tmodifier++;\n\t\t\tif (*modifier != '=')\n\t\t\t\tgoto error;\n\t\t\tmodifier++;\n\t\t\tret = kstrtoul(modifier, 0, buckets);\n\t\t\tif (ret || !(*buckets))\n\t\t\t\tgoto error;\n\t\t\t*flags |= HIST_FIELD_FL_BUCKET;\n\t\t} else {\n error:\n\t\t\thist_err(tr, HIST_ERR_BAD_FIELD_MODIFIER, errpos(modifier));\n\t\t\tfield = ERR_PTR(-EINVAL);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (strcmp(field_name, \"common_timestamp\") == 0) {\n\t\t*flags |= HIST_FIELD_FL_TIMESTAMP;\n\t\thist_data->enable_timestamps = true;\n\t\tif (*flags & HIST_FIELD_FL_TIMESTAMP_USECS)\n\t\t\thist_data->attrs->ts_in_usecs = true;\n\t} else if (strcmp(field_name, \"common_cpu\") == 0)\n\t\t*flags |= HIST_FIELD_FL_CPU;\n\telse {\n\t\tfield = trace_find_event_field(file->event_call, field_name);\n\t\tif (!field || !field->size) {\n\t\t\t/*\n\t\t\t * For backward compatibility, if field_name\n\t\t\t * was \"cpu\", then we treat this the same as\n\t\t\t * common_cpu.\n\t\t\t */\n\t\t\tif (strcmp(field_name, \"cpu\") == 0) {\n\t\t\t\t*flags |= HIST_FIELD_FL_CPU;\n\t\t\t} else {\n\t\t\t\thist_err(tr, HIST_ERR_FIELD_NOT_FOUND,\n\t\t\t\t\t errpos(field_name));\n\t\t\t\tfield = ERR_PTR(-EINVAL);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\n out:\n\tkfree(str);\n\n\treturn field;\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include \"tracing_map.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "str"
          ],
          "line": 2305
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EINVAL"
          ],
          "line": 2299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hist_err",
          "args": [
            "tr",
            "HIST_ERR_FIELD_NOT_FOUND",
            "errpos(field_name)"
          ],
          "line": 2297
        },
        "resolved": true,
        "details": {
          "function_name": "hist_err",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "763-767",
          "snippet": "static void hist_err(struct trace_array *tr, u8 err_type, u8 err_pos)\n{\n\ttracing_log_err(tr, last_cmd_loc, last_cmd, err_text,\n\t\t\terr_type, err_pos);\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *err_text[] = { ERRORS };",
            "static char last_cmd[MAX_FILTER_STR_VAL];",
            "static char last_cmd_loc[MAX_FILTER_STR_VAL];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic const char *err_text[] = { ERRORS };\nstatic char last_cmd[MAX_FILTER_STR_VAL];\nstatic char last_cmd_loc[MAX_FILTER_STR_VAL];\n\nstatic void hist_err(struct trace_array *tr, u8 err_type, u8 err_pos)\n{\n\ttracing_log_err(tr, last_cmd_loc, last_cmd, err_text,\n\t\t\terr_type, err_pos);\n}"
        }
      },
      {
        "call_info": {
          "callee": "errpos",
          "args": [
            "field_name"
          ],
          "line": 2298
        },
        "resolved": true,
        "details": {
          "function_name": "errpos",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "733-736",
          "snippet": "static int errpos(char *str)\n{\n\treturn err_pos(last_cmd, str);\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char last_cmd[MAX_FILTER_STR_VAL];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic char last_cmd[MAX_FILTER_STR_VAL];\n\nstatic int errpos(char *str)\n{\n\treturn err_pos(last_cmd, str);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "field_name",
            "\"cpu\""
          ],
          "line": 2294
        },
        "resolved": true,
        "details": {
          "function_name": "sym_strcmp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/report.c",
          "lines": "356-365",
          "snippet": "static int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}",
          "includes": [
            "#include \"encoding.h\"",
            "#include \"kcsan.h\"",
            "#include <linux/stacktrace.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/delay.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"encoding.h\"\n#include \"kcsan.h\"\n#include <linux/stacktrace.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/lockdep.h>\n#include <linux/kernel.h>\n#include <linux/kallsyms.h>\n#include <linux/jiffies.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n\nstatic int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_find_event_field",
          "args": [
            "file->event_call",
            "field_name"
          ],
          "line": 2287
        },
        "resolved": true,
        "details": {
          "function_name": "trace_find_event_field",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
          "lines": "89-105",
          "snippet": "struct ftrace_event_field *\ntrace_find_event_field(struct trace_event_call *call, char *name)\n{\n\tstruct ftrace_event_field *field;\n\tstruct list_head *head;\n\n\thead = trace_get_fields(call);\n\tfield = __find_event_field(head, name);\n\tif (field)\n\t\treturn field;\n\n\tfield = __find_event_field(&ftrace_generic_fields, name);\n\tif (field)\n\t\treturn field;\n\n\treturn __find_event_field(&ftrace_common_fields, name);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/syscall.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(ftrace_generic_fields);",
            "static LIST_HEAD(ftrace_common_fields);",
            "static void __add_event_to_tracers(struct trace_event_call *call);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic LIST_HEAD(ftrace_generic_fields);\nstatic LIST_HEAD(ftrace_common_fields);\nstatic void __add_event_to_tracers(struct trace_event_call *call);\n\nstruct ftrace_event_field *\ntrace_find_event_field(struct trace_event_call *call, char *name)\n{\n\tstruct ftrace_event_field *field;\n\tstruct list_head *head;\n\n\thead = trace_get_fields(call);\n\tfield = __find_event_field(head, name);\n\tif (field)\n\t\treturn field;\n\n\tfield = __find_event_field(&ftrace_generic_fields, name);\n\tif (field)\n\t\treturn field;\n\n\treturn __find_event_field(&ftrace_common_fields, name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EINVAL"
          ],
          "line": 2274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrtoul",
          "args": [
            "modifier",
            "0",
            "buckets"
          ],
          "line": 2267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "modifier",
            "\"bucket\"",
            "6"
          ],
          "line": 2257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strsep",
          "args": [
            "&modifier",
            "\".\""
          ],
          "line": 2236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 2234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "field_str",
            "GFP_KERNEL"
          ],
          "line": 2232
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct ftrace_event_field *\nparse_field(struct hist_trigger_data *hist_data, struct trace_event_file *file,\n\t    char *field_str, unsigned long *flags, unsigned long *buckets)\n{\n\tstruct ftrace_event_field *field = NULL;\n\tchar *field_name, *modifier, *str;\n\tstruct trace_array *tr = file->tr;\n\n\tmodifier = str = kstrdup(field_str, GFP_KERNEL);\n\tif (!modifier)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tfield_name = strsep(&modifier, \".\");\n\tif (modifier) {\n\t\tif (strcmp(modifier, \"hex\") == 0)\n\t\t\t*flags |= HIST_FIELD_FL_HEX;\n\t\telse if (strcmp(modifier, \"sym\") == 0)\n\t\t\t*flags |= HIST_FIELD_FL_SYM;\n\t\t/*\n\t\t * 'sym-offset' occurrences in the trigger string are modified\n\t\t * to 'symXoffset' to simplify arithmetic expression parsing.\n\t\t */\n\t\telse if (strcmp(modifier, \"symXoffset\") == 0)\n\t\t\t*flags |= HIST_FIELD_FL_SYM_OFFSET;\n\t\telse if ((strcmp(modifier, \"execname\") == 0) &&\n\t\t\t (strcmp(field_name, \"common_pid\") == 0))\n\t\t\t*flags |= HIST_FIELD_FL_EXECNAME;\n\t\telse if (strcmp(modifier, \"syscall\") == 0)\n\t\t\t*flags |= HIST_FIELD_FL_SYSCALL;\n\t\telse if (strcmp(modifier, \"log2\") == 0)\n\t\t\t*flags |= HIST_FIELD_FL_LOG2;\n\t\telse if (strcmp(modifier, \"usecs\") == 0)\n\t\t\t*flags |= HIST_FIELD_FL_TIMESTAMP_USECS;\n\t\telse if (strncmp(modifier, \"bucket\", 6) == 0) {\n\t\t\tint ret;\n\n\t\t\tmodifier += 6;\n\n\t\t\tif (*modifier == 's')\n\t\t\t\tmodifier++;\n\t\t\tif (*modifier != '=')\n\t\t\t\tgoto error;\n\t\t\tmodifier++;\n\t\t\tret = kstrtoul(modifier, 0, buckets);\n\t\t\tif (ret || !(*buckets))\n\t\t\t\tgoto error;\n\t\t\t*flags |= HIST_FIELD_FL_BUCKET;\n\t\t} else {\n error:\n\t\t\thist_err(tr, HIST_ERR_BAD_FIELD_MODIFIER, errpos(modifier));\n\t\t\tfield = ERR_PTR(-EINVAL);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (strcmp(field_name, \"common_timestamp\") == 0) {\n\t\t*flags |= HIST_FIELD_FL_TIMESTAMP;\n\t\thist_data->enable_timestamps = true;\n\t\tif (*flags & HIST_FIELD_FL_TIMESTAMP_USECS)\n\t\t\thist_data->attrs->ts_in_usecs = true;\n\t} else if (strcmp(field_name, \"common_cpu\") == 0)\n\t\t*flags |= HIST_FIELD_FL_CPU;\n\telse {\n\t\tfield = trace_find_event_field(file->event_call, field_name);\n\t\tif (!field || !field->size) {\n\t\t\t/*\n\t\t\t * For backward compatibility, if field_name\n\t\t\t * was \"cpu\", then we treat this the same as\n\t\t\t * common_cpu.\n\t\t\t */\n\t\t\tif (strcmp(field_name, \"cpu\") == 0) {\n\t\t\t\t*flags |= HIST_FIELD_FL_CPU;\n\t\t\t} else {\n\t\t\t\thist_err(tr, HIST_ERR_FIELD_NOT_FOUND,\n\t\t\t\t\t errpos(field_name));\n\t\t\t\tfield = ERR_PTR(-EINVAL);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\n out:\n\tkfree(str);\n\n\treturn field;\n}"
  },
  {
    "function_name": "parse_var_ref",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
    "lines": "2201-2222",
    "snippet": "static struct hist_field *parse_var_ref(struct hist_trigger_data *hist_data,\n\t\t\t\t\tchar *system, char *event_name,\n\t\t\t\t\tchar *var_name)\n{\n\tstruct hist_field *var_field = NULL, *ref_field = NULL;\n\tstruct trace_array *tr = hist_data->event_file->tr;\n\n\tif (!is_var_ref(var_name))\n\t\treturn NULL;\n\n\tvar_name++;\n\n\tvar_field = find_event_var(hist_data, system, event_name, var_name);\n\tif (var_field)\n\t\tref_field = create_var_ref(hist_data, var_field,\n\t\t\t\t\t   system, event_name);\n\n\tif (!ref_field)\n\t\thist_err(tr, HIST_ERR_VAR_NOT_FOUND, errpos(var_name));\n\n\treturn ref_field;\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include \"tracing_map.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hist_err",
          "args": [
            "tr",
            "HIST_ERR_VAR_NOT_FOUND",
            "errpos(var_name)"
          ],
          "line": 2219
        },
        "resolved": true,
        "details": {
          "function_name": "hist_err",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "763-767",
          "snippet": "static void hist_err(struct trace_array *tr, u8 err_type, u8 err_pos)\n{\n\ttracing_log_err(tr, last_cmd_loc, last_cmd, err_text,\n\t\t\terr_type, err_pos);\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *err_text[] = { ERRORS };",
            "static char last_cmd[MAX_FILTER_STR_VAL];",
            "static char last_cmd_loc[MAX_FILTER_STR_VAL];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic const char *err_text[] = { ERRORS };\nstatic char last_cmd[MAX_FILTER_STR_VAL];\nstatic char last_cmd_loc[MAX_FILTER_STR_VAL];\n\nstatic void hist_err(struct trace_array *tr, u8 err_type, u8 err_pos)\n{\n\ttracing_log_err(tr, last_cmd_loc, last_cmd, err_text,\n\t\t\terr_type, err_pos);\n}"
        }
      },
      {
        "call_info": {
          "callee": "errpos",
          "args": [
            "var_name"
          ],
          "line": 2219
        },
        "resolved": true,
        "details": {
          "function_name": "errpos",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "733-736",
          "snippet": "static int errpos(char *str)\n{\n\treturn err_pos(last_cmd, str);\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char last_cmd[MAX_FILTER_STR_VAL];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic char last_cmd[MAX_FILTER_STR_VAL];\n\nstatic int errpos(char *str)\n{\n\treturn err_pos(last_cmd, str);\n}"
        }
      },
      {
        "call_info": {
          "callee": "create_var_ref",
          "args": [
            "hist_data",
            "var_field",
            "system",
            "event_name"
          ],
          "line": 2215
        },
        "resolved": true,
        "details": {
          "function_name": "create_var_ref",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "2114-2144",
          "snippet": "static struct hist_field *create_var_ref(struct hist_trigger_data *hist_data,\n\t\t\t\t\t struct hist_field *var_field,\n\t\t\t\t\t char *system, char *event_name)\n{\n\tunsigned long flags = HIST_FIELD_FL_VAR_REF;\n\tstruct hist_field *ref_field;\n\tint i;\n\n\t/* Check if the variable already exists */\n\tfor (i = 0; i < hist_data->n_var_refs; i++) {\n\t\tref_field = hist_data->var_refs[i];\n\t\tif (ref_field->var.idx == var_field->var.idx &&\n\t\t    ref_field->var.hist_data == var_field->hist_data) {\n\t\t\tget_hist_field(ref_field);\n\t\t\treturn ref_field;\n\t\t}\n\t}\n\n\tref_field = create_hist_field(var_field->hist_data, NULL, flags, NULL);\n\tif (ref_field) {\n\t\tif (init_var_ref(ref_field, var_field, system, event_name)) {\n\t\t\tdestroy_hist_field(ref_field, 0);\n\t\t\treturn NULL;\n\t\t}\n\n\t\thist_data->var_refs[hist_data->n_var_refs] = ref_field;\n\t\tref_field->var_ref_idx = hist_data->n_var_refs++;\n\t}\n\n\treturn ref_field;\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct hist_field *create_var_ref(struct hist_trigger_data *hist_data,\n\t\t\t\t\t struct hist_field *var_field,\n\t\t\t\t\t char *system, char *event_name)\n{\n\tunsigned long flags = HIST_FIELD_FL_VAR_REF;\n\tstruct hist_field *ref_field;\n\tint i;\n\n\t/* Check if the variable already exists */\n\tfor (i = 0; i < hist_data->n_var_refs; i++) {\n\t\tref_field = hist_data->var_refs[i];\n\t\tif (ref_field->var.idx == var_field->var.idx &&\n\t\t    ref_field->var.hist_data == var_field->hist_data) {\n\t\t\tget_hist_field(ref_field);\n\t\t\treturn ref_field;\n\t\t}\n\t}\n\n\tref_field = create_hist_field(var_field->hist_data, NULL, flags, NULL);\n\tif (ref_field) {\n\t\tif (init_var_ref(ref_field, var_field, system, event_name)) {\n\t\t\tdestroy_hist_field(ref_field, 0);\n\t\t\treturn NULL;\n\t\t}\n\n\t\thist_data->var_refs[hist_data->n_var_refs] = ref_field;\n\t\tref_field->var_ref_idx = hist_data->n_var_refs++;\n\t}\n\n\treturn ref_field;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_event_var",
          "args": [
            "hist_data",
            "system",
            "event_name",
            "var_name"
          ],
          "line": 2213
        },
        "resolved": true,
        "details": {
          "function_name": "find_event_var",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "1190-1214",
          "snippet": "static struct hist_field *find_event_var(struct hist_trigger_data *hist_data,\n\t\t\t\t\t char *system,\n\t\t\t\t\t char *event_name,\n\t\t\t\t\t char *var_name)\n{\n\tstruct trace_array *tr = hist_data->event_file->tr;\n\tstruct hist_field *hist_field = NULL;\n\tstruct trace_event_file *file;\n\n\tif (!system || !event_name) {\n\t\thist_field = find_match_var(hist_data, var_name);\n\t\tif (IS_ERR(hist_field))\n\t\t\treturn NULL;\n\t\tif (hist_field)\n\t\t\treturn hist_field;\n\t}\n\n\tfile = find_var_file(tr, system, event_name, var_name);\n\tif (!file)\n\t\treturn NULL;\n\n\thist_field = find_file_var(file, var_name);\n\n\treturn hist_field;\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct hist_field *find_event_var(struct hist_trigger_data *hist_data,\n\t\t\t\t\t char *system,\n\t\t\t\t\t char *event_name,\n\t\t\t\t\t char *var_name)\n{\n\tstruct trace_array *tr = hist_data->event_file->tr;\n\tstruct hist_field *hist_field = NULL;\n\tstruct trace_event_file *file;\n\n\tif (!system || !event_name) {\n\t\thist_field = find_match_var(hist_data, var_name);\n\t\tif (IS_ERR(hist_field))\n\t\t\treturn NULL;\n\t\tif (hist_field)\n\t\t\treturn hist_field;\n\t}\n\n\tfile = find_var_file(tr, system, event_name, var_name);\n\tif (!file)\n\t\treturn NULL;\n\n\thist_field = find_file_var(file, var_name);\n\n\treturn hist_field;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_var_ref",
          "args": [
            "var_name"
          ],
          "line": 2208
        },
        "resolved": true,
        "details": {
          "function_name": "is_var_ref",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "2146-2152",
          "snippet": "static bool is_var_ref(char *var_name)\n{\n\tif (!var_name || strlen(var_name) < 2 || var_name[0] != '$')\n\t\treturn false;\n\n\treturn true;\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic bool is_var_ref(char *var_name)\n{\n\tif (!var_name || strlen(var_name) < 2 || var_name[0] != '$')\n\t\treturn false;\n\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct hist_field *parse_var_ref(struct hist_trigger_data *hist_data,\n\t\t\t\t\tchar *system, char *event_name,\n\t\t\t\t\tchar *var_name)\n{\n\tstruct hist_field *var_field = NULL, *ref_field = NULL;\n\tstruct trace_array *tr = hist_data->event_file->tr;\n\n\tif (!is_var_ref(var_name))\n\t\treturn NULL;\n\n\tvar_name++;\n\n\tvar_field = find_event_var(hist_data, system, event_name, var_name);\n\tif (var_field)\n\t\tref_field = create_var_ref(hist_data, var_field,\n\t\t\t\t\t   system, event_name);\n\n\tif (!ref_field)\n\t\thist_err(tr, HIST_ERR_VAR_NOT_FOUND, errpos(var_name));\n\n\treturn ref_field;\n}"
  },
  {
    "function_name": "local_field_var_ref",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
    "lines": "2174-2199",
    "snippet": "static char *local_field_var_ref(struct hist_trigger_data *hist_data,\n\t\t\t\t char *system, char *event_name,\n\t\t\t\t char *var_name)\n{\n\tstruct trace_event_call *call;\n\n\tif (system && event_name) {\n\t\tcall = hist_data->event_file->event_call;\n\n\t\tif (strcmp(system, call->class->system) != 0)\n\t\t\treturn NULL;\n\n\t\tif (strcmp(event_name, trace_event_name(call)) != 0)\n\t\t\treturn NULL;\n\t}\n\n\tif (!!system != !!event_name)\n\t\treturn NULL;\n\n\tif (!is_var_ref(var_name))\n\t\treturn NULL;\n\n\tvar_name++;\n\n\treturn field_name_from_var(hist_data, var_name);\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include \"tracing_map.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "field_name_from_var",
          "args": [
            "hist_data",
            "var_name"
          ],
          "line": 2198
        },
        "resolved": true,
        "details": {
          "function_name": "field_name_from_var",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "2154-2172",
          "snippet": "static char *field_name_from_var(struct hist_trigger_data *hist_data,\n\t\t\t\t char *var_name)\n{\n\tchar *name, *field;\n\tunsigned int i;\n\n\tfor (i = 0; i < hist_data->attrs->var_defs.n_vars; i++) {\n\t\tname = hist_data->attrs->var_defs.name[i];\n\n\t\tif (strcmp(var_name, name) == 0) {\n\t\t\tfield = hist_data->attrs->var_defs.expr[i];\n\t\t\tif (contains_operator(field, NULL) || is_var_ref(field))\n\t\t\t\tcontinue;\n\t\t\treturn field;\n\t\t}\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic char *field_name_from_var(struct hist_trigger_data *hist_data,\n\t\t\t\t char *var_name)\n{\n\tchar *name, *field;\n\tunsigned int i;\n\n\tfor (i = 0; i < hist_data->attrs->var_defs.n_vars; i++) {\n\t\tname = hist_data->attrs->var_defs.name[i];\n\n\t\tif (strcmp(var_name, name) == 0) {\n\t\t\tfield = hist_data->attrs->var_defs.expr[i];\n\t\t\tif (contains_operator(field, NULL) || is_var_ref(field))\n\t\t\t\tcontinue;\n\t\t\treturn field;\n\t\t}\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_var_ref",
          "args": [
            "var_name"
          ],
          "line": 2193
        },
        "resolved": true,
        "details": {
          "function_name": "is_var_ref",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "2146-2152",
          "snippet": "static bool is_var_ref(char *var_name)\n{\n\tif (!var_name || strlen(var_name) < 2 || var_name[0] != '$')\n\t\treturn false;\n\n\treturn true;\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic bool is_var_ref(char *var_name)\n{\n\tif (!var_name || strlen(var_name) < 2 || var_name[0] != '$')\n\t\treturn false;\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "event_name",
            "trace_event_name(call)"
          ],
          "line": 2186
        },
        "resolved": true,
        "details": {
          "function_name": "sym_strcmp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/report.c",
          "lines": "356-365",
          "snippet": "static int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}",
          "includes": [
            "#include \"encoding.h\"",
            "#include \"kcsan.h\"",
            "#include <linux/stacktrace.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/delay.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"encoding.h\"\n#include \"kcsan.h\"\n#include <linux/stacktrace.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/lockdep.h>\n#include <linux/kernel.h>\n#include <linux/kallsyms.h>\n#include <linux/jiffies.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n\nstatic int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_event_name",
          "args": [
            "call"
          ],
          "line": 2186
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic char *local_field_var_ref(struct hist_trigger_data *hist_data,\n\t\t\t\t char *system, char *event_name,\n\t\t\t\t char *var_name)\n{\n\tstruct trace_event_call *call;\n\n\tif (system && event_name) {\n\t\tcall = hist_data->event_file->event_call;\n\n\t\tif (strcmp(system, call->class->system) != 0)\n\t\t\treturn NULL;\n\n\t\tif (strcmp(event_name, trace_event_name(call)) != 0)\n\t\t\treturn NULL;\n\t}\n\n\tif (!!system != !!event_name)\n\t\treturn NULL;\n\n\tif (!is_var_ref(var_name))\n\t\treturn NULL;\n\n\tvar_name++;\n\n\treturn field_name_from_var(hist_data, var_name);\n}"
  },
  {
    "function_name": "field_name_from_var",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
    "lines": "2154-2172",
    "snippet": "static char *field_name_from_var(struct hist_trigger_data *hist_data,\n\t\t\t\t char *var_name)\n{\n\tchar *name, *field;\n\tunsigned int i;\n\n\tfor (i = 0; i < hist_data->attrs->var_defs.n_vars; i++) {\n\t\tname = hist_data->attrs->var_defs.name[i];\n\n\t\tif (strcmp(var_name, name) == 0) {\n\t\t\tfield = hist_data->attrs->var_defs.expr[i];\n\t\t\tif (contains_operator(field, NULL) || is_var_ref(field))\n\t\t\t\tcontinue;\n\t\t\treturn field;\n\t\t}\n\t}\n\n\treturn NULL;\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include \"tracing_map.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "is_var_ref",
          "args": [
            "field"
          ],
          "line": 2165
        },
        "resolved": true,
        "details": {
          "function_name": "is_var_ref",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "2146-2152",
          "snippet": "static bool is_var_ref(char *var_name)\n{\n\tif (!var_name || strlen(var_name) < 2 || var_name[0] != '$')\n\t\treturn false;\n\n\treturn true;\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic bool is_var_ref(char *var_name)\n{\n\tif (!var_name || strlen(var_name) < 2 || var_name[0] != '$')\n\t\treturn false;\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "contains_operator",
          "args": [
            "field",
            "NULL"
          ],
          "line": 2165
        },
        "resolved": true,
        "details": {
          "function_name": "contains_operator",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "1755-1840",
          "snippet": "static int contains_operator(char *str, char **sep)\n{\n\tenum field_op_id field_op = FIELD_OP_NONE;\n\tchar *minus_op, *plus_op, *div_op, *mult_op;\n\n\n\t/*\n\t * Report the last occurrence of the operators first, so that the\n\t * expression is evaluated left to right. This is important since\n\t * subtraction and division are not associative.\n\t *\n\t *\te.g\n\t *\t\t64/8/4/2 is 1, i.e 64/8/4/2 = ((64/8)/4)/2\n\t *\t\t14-7-5-2 is 0, i.e 14-7-5-2 = ((14-7)-5)-2\n\t */\n\n\t/*\n\t * First, find lower precedence addition and subtraction\n\t * since the expression will be evaluated recursively.\n\t */\n\tminus_op = strrchr(str, '-');\n\tif (minus_op) {\n\t\t/*\n\t\t * Unary minus is not supported in sub-expressions. If\n\t\t * present, it is always the next root operator.\n\t\t */\n\t\tif (minus_op == str) {\n\t\t\tfield_op = FIELD_OP_UNARY_MINUS;\n\t\t\tgoto out;\n\t\t}\n\n\t\tfield_op = FIELD_OP_MINUS;\n\t}\n\n\tplus_op = strrchr(str, '+');\n\tif (plus_op || minus_op) {\n\t\t/*\n\t\t * For operators of the same precedence use to rightmost as the\n\t\t * root, so that the expression is evaluated left to right.\n\t\t */\n\t\tif (plus_op > minus_op)\n\t\t\tfield_op = FIELD_OP_PLUS;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Multiplication and division have higher precedence than addition and\n\t * subtraction.\n\t */\n\tdiv_op = strrchr(str, '/');\n\tif (div_op)\n\t\tfield_op = FIELD_OP_DIV;\n\n\tmult_op = strrchr(str, '*');\n\t/*\n\t * For operators of the same precedence use to rightmost as the\n\t * root, so that the expression is evaluated left to right.\n\t */\n\tif (mult_op > div_op)\n\t\tfield_op = FIELD_OP_MULT;\n\nout:\n\tif (sep) {\n\t\tswitch (field_op) {\n\t\tcase FIELD_OP_UNARY_MINUS:\n\t\tcase FIELD_OP_MINUS:\n\t\t\t*sep = minus_op;\n\t\t\tbreak;\n\t\tcase FIELD_OP_PLUS:\n\t\t\t*sep = plus_op;\n\t\t\tbreak;\n\t\tcase FIELD_OP_DIV:\n\t\t\t*sep = div_op;\n\t\t\tbreak;\n\t\tcase FIELD_OP_MULT:\n\t\t\t*sep = mult_op;\n\t\t\tbreak;\n\t\tcase FIELD_OP_NONE:\n\t\tdefault:\n\t\t\t*sep = NULL;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn field_op;\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int contains_operator(char *str, char **sep)\n{\n\tenum field_op_id field_op = FIELD_OP_NONE;\n\tchar *minus_op, *plus_op, *div_op, *mult_op;\n\n\n\t/*\n\t * Report the last occurrence of the operators first, so that the\n\t * expression is evaluated left to right. This is important since\n\t * subtraction and division are not associative.\n\t *\n\t *\te.g\n\t *\t\t64/8/4/2 is 1, i.e 64/8/4/2 = ((64/8)/4)/2\n\t *\t\t14-7-5-2 is 0, i.e 14-7-5-2 = ((14-7)-5)-2\n\t */\n\n\t/*\n\t * First, find lower precedence addition and subtraction\n\t * since the expression will be evaluated recursively.\n\t */\n\tminus_op = strrchr(str, '-');\n\tif (minus_op) {\n\t\t/*\n\t\t * Unary minus is not supported in sub-expressions. If\n\t\t * present, it is always the next root operator.\n\t\t */\n\t\tif (minus_op == str) {\n\t\t\tfield_op = FIELD_OP_UNARY_MINUS;\n\t\t\tgoto out;\n\t\t}\n\n\t\tfield_op = FIELD_OP_MINUS;\n\t}\n\n\tplus_op = strrchr(str, '+');\n\tif (plus_op || minus_op) {\n\t\t/*\n\t\t * For operators of the same precedence use to rightmost as the\n\t\t * root, so that the expression is evaluated left to right.\n\t\t */\n\t\tif (plus_op > minus_op)\n\t\t\tfield_op = FIELD_OP_PLUS;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Multiplication and division have higher precedence than addition and\n\t * subtraction.\n\t */\n\tdiv_op = strrchr(str, '/');\n\tif (div_op)\n\t\tfield_op = FIELD_OP_DIV;\n\n\tmult_op = strrchr(str, '*');\n\t/*\n\t * For operators of the same precedence use to rightmost as the\n\t * root, so that the expression is evaluated left to right.\n\t */\n\tif (mult_op > div_op)\n\t\tfield_op = FIELD_OP_MULT;\n\nout:\n\tif (sep) {\n\t\tswitch (field_op) {\n\t\tcase FIELD_OP_UNARY_MINUS:\n\t\tcase FIELD_OP_MINUS:\n\t\t\t*sep = minus_op;\n\t\t\tbreak;\n\t\tcase FIELD_OP_PLUS:\n\t\t\t*sep = plus_op;\n\t\t\tbreak;\n\t\tcase FIELD_OP_DIV:\n\t\t\t*sep = div_op;\n\t\t\tbreak;\n\t\tcase FIELD_OP_MULT:\n\t\t\t*sep = mult_op;\n\t\t\tbreak;\n\t\tcase FIELD_OP_NONE:\n\t\tdefault:\n\t\t\t*sep = NULL;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn field_op;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "var_name",
            "name"
          ],
          "line": 2163
        },
        "resolved": true,
        "details": {
          "function_name": "sym_strcmp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/report.c",
          "lines": "356-365",
          "snippet": "static int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}",
          "includes": [
            "#include \"encoding.h\"",
            "#include \"kcsan.h\"",
            "#include <linux/stacktrace.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/delay.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"encoding.h\"\n#include \"kcsan.h\"\n#include <linux/stacktrace.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/lockdep.h>\n#include <linux/kernel.h>\n#include <linux/kallsyms.h>\n#include <linux/jiffies.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n\nstatic int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic char *field_name_from_var(struct hist_trigger_data *hist_data,\n\t\t\t\t char *var_name)\n{\n\tchar *name, *field;\n\tunsigned int i;\n\n\tfor (i = 0; i < hist_data->attrs->var_defs.n_vars; i++) {\n\t\tname = hist_data->attrs->var_defs.name[i];\n\n\t\tif (strcmp(var_name, name) == 0) {\n\t\t\tfield = hist_data->attrs->var_defs.expr[i];\n\t\t\tif (contains_operator(field, NULL) || is_var_ref(field))\n\t\t\t\tcontinue;\n\t\t\treturn field;\n\t\t}\n\t}\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "is_var_ref",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
    "lines": "2146-2152",
    "snippet": "static bool is_var_ref(char *var_name)\n{\n\tif (!var_name || strlen(var_name) < 2 || var_name[0] != '$')\n\t\treturn false;\n\n\treturn true;\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include \"tracing_map.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "var_name"
          ],
          "line": 2148
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_eprobe.c",
          "lines": "384-401",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/ftrace.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic bool is_var_ref(char *var_name)\n{\n\tif (!var_name || strlen(var_name) < 2 || var_name[0] != '$')\n\t\treturn false;\n\n\treturn true;\n}"
  },
  {
    "function_name": "create_var_ref",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
    "lines": "2114-2144",
    "snippet": "static struct hist_field *create_var_ref(struct hist_trigger_data *hist_data,\n\t\t\t\t\t struct hist_field *var_field,\n\t\t\t\t\t char *system, char *event_name)\n{\n\tunsigned long flags = HIST_FIELD_FL_VAR_REF;\n\tstruct hist_field *ref_field;\n\tint i;\n\n\t/* Check if the variable already exists */\n\tfor (i = 0; i < hist_data->n_var_refs; i++) {\n\t\tref_field = hist_data->var_refs[i];\n\t\tif (ref_field->var.idx == var_field->var.idx &&\n\t\t    ref_field->var.hist_data == var_field->hist_data) {\n\t\t\tget_hist_field(ref_field);\n\t\t\treturn ref_field;\n\t\t}\n\t}\n\n\tref_field = create_hist_field(var_field->hist_data, NULL, flags, NULL);\n\tif (ref_field) {\n\t\tif (init_var_ref(ref_field, var_field, system, event_name)) {\n\t\t\tdestroy_hist_field(ref_field, 0);\n\t\t\treturn NULL;\n\t\t}\n\n\t\thist_data->var_refs[hist_data->n_var_refs] = ref_field;\n\t\tref_field->var_ref_idx = hist_data->n_var_refs++;\n\t}\n\n\treturn ref_field;\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include \"tracing_map.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "destroy_hist_field",
          "args": [
            "ref_field",
            "0"
          ],
          "line": 2135
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_hist_field",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "1864-1882",
          "snippet": "static void destroy_hist_field(struct hist_field *hist_field,\n\t\t\t       unsigned int level)\n{\n\tunsigned int i;\n\n\tif (level > 3)\n\t\treturn;\n\n\tif (!hist_field)\n\t\treturn;\n\n\tif (hist_field->flags & HIST_FIELD_FL_VAR_REF)\n\t\treturn; /* var refs will be destroyed separately */\n\n\tfor (i = 0; i < HIST_FIELD_OPERANDS_MAX; i++)\n\t\tdestroy_hist_field(hist_field->operands[i], level + 1);\n\n\t__destroy_hist_field(hist_field);\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define HIST_FIELD_OPERANDS_MAX\t2"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\n#define HIST_FIELD_OPERANDS_MAX\t2\n\nstatic void destroy_hist_field(struct hist_field *hist_field,\n\t\t\t       unsigned int level)\n{\n\tunsigned int i;\n\n\tif (level > 3)\n\t\treturn;\n\n\tif (!hist_field)\n\t\treturn;\n\n\tif (hist_field->flags & HIST_FIELD_FL_VAR_REF)\n\t\treturn; /* var refs will be destroyed separately */\n\n\tfor (i = 0; i < HIST_FIELD_OPERANDS_MAX; i++)\n\t\tdestroy_hist_field(hist_field->operands[i], level + 1);\n\n\t__destroy_hist_field(hist_field);\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_var_ref",
          "args": [
            "ref_field",
            "var_field",
            "system",
            "event_name"
          ],
          "line": 2134
        },
        "resolved": true,
        "details": {
          "function_name": "init_var_ref",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "2027-2081",
          "snippet": "static int init_var_ref(struct hist_field *ref_field,\n\t\t\tstruct hist_field *var_field,\n\t\t\tchar *system, char *event_name)\n{\n\tint err = 0;\n\n\tref_field->var.idx = var_field->var.idx;\n\tref_field->var.hist_data = var_field->hist_data;\n\tref_field->size = var_field->size;\n\tref_field->is_signed = var_field->is_signed;\n\tref_field->flags |= var_field->flags &\n\t\t(HIST_FIELD_FL_TIMESTAMP | HIST_FIELD_FL_TIMESTAMP_USECS);\n\n\tif (system) {\n\t\tref_field->system = kstrdup(system, GFP_KERNEL);\n\t\tif (!ref_field->system)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tif (event_name) {\n\t\tref_field->event_name = kstrdup(event_name, GFP_KERNEL);\n\t\tif (!ref_field->event_name) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto free;\n\t\t}\n\t}\n\n\tif (var_field->var.name) {\n\t\tref_field->name = kstrdup(var_field->var.name, GFP_KERNEL);\n\t\tif (!ref_field->name) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto free;\n\t\t}\n\t} else if (var_field->name) {\n\t\tref_field->name = kstrdup(var_field->name, GFP_KERNEL);\n\t\tif (!ref_field->name) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto free;\n\t\t}\n\t}\n\n\tref_field->type = kstrdup_const(var_field->type, GFP_KERNEL);\n\tif (!ref_field->type) {\n\t\terr = -ENOMEM;\n\t\tgoto free;\n\t}\n out:\n\treturn err;\n free:\n\tkfree(ref_field->system);\n\tkfree(ref_field->event_name);\n\tkfree(ref_field->name);\n\n\tgoto out;\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int init_var_ref(struct hist_field *ref_field,\n\t\t\tstruct hist_field *var_field,\n\t\t\tchar *system, char *event_name)\n{\n\tint err = 0;\n\n\tref_field->var.idx = var_field->var.idx;\n\tref_field->var.hist_data = var_field->hist_data;\n\tref_field->size = var_field->size;\n\tref_field->is_signed = var_field->is_signed;\n\tref_field->flags |= var_field->flags &\n\t\t(HIST_FIELD_FL_TIMESTAMP | HIST_FIELD_FL_TIMESTAMP_USECS);\n\n\tif (system) {\n\t\tref_field->system = kstrdup(system, GFP_KERNEL);\n\t\tif (!ref_field->system)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tif (event_name) {\n\t\tref_field->event_name = kstrdup(event_name, GFP_KERNEL);\n\t\tif (!ref_field->event_name) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto free;\n\t\t}\n\t}\n\n\tif (var_field->var.name) {\n\t\tref_field->name = kstrdup(var_field->var.name, GFP_KERNEL);\n\t\tif (!ref_field->name) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto free;\n\t\t}\n\t} else if (var_field->name) {\n\t\tref_field->name = kstrdup(var_field->name, GFP_KERNEL);\n\t\tif (!ref_field->name) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto free;\n\t\t}\n\t}\n\n\tref_field->type = kstrdup_const(var_field->type, GFP_KERNEL);\n\tif (!ref_field->type) {\n\t\terr = -ENOMEM;\n\t\tgoto free;\n\t}\n out:\n\treturn err;\n free:\n\tkfree(ref_field->system);\n\tkfree(ref_field->event_name);\n\tkfree(ref_field->name);\n\n\tgoto out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "create_hist_field",
          "args": [
            "var_field->hist_data",
            "NULL",
            "flags",
            "NULL"
          ],
          "line": 2132
        },
        "resolved": true,
        "details": {
          "function_name": "create_hist_field",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "1884-2007",
          "snippet": "static struct hist_field *create_hist_field(struct hist_trigger_data *hist_data,\n\t\t\t\t\t    struct ftrace_event_field *field,\n\t\t\t\t\t    unsigned long flags,\n\t\t\t\t\t    char *var_name)\n{\n\tstruct hist_field *hist_field;\n\n\tif (field && is_function_field(field))\n\t\treturn NULL;\n\n\thist_field = kzalloc(sizeof(struct hist_field), GFP_KERNEL);\n\tif (!hist_field)\n\t\treturn NULL;\n\n\thist_field->ref = 1;\n\n\thist_field->hist_data = hist_data;\n\n\tif (flags & HIST_FIELD_FL_EXPR || flags & HIST_FIELD_FL_ALIAS)\n\t\tgoto out; /* caller will populate */\n\n\tif (flags & HIST_FIELD_FL_VAR_REF) {\n\t\thist_field->fn = hist_field_var_ref;\n\t\tgoto out;\n\t}\n\n\tif (flags & HIST_FIELD_FL_HITCOUNT) {\n\t\thist_field->fn = hist_field_counter;\n\t\thist_field->size = sizeof(u64);\n\t\thist_field->type = \"u64\";\n\t\tgoto out;\n\t}\n\n\tif (flags & HIST_FIELD_FL_CONST) {\n\t\thist_field->fn = hist_field_const;\n\t\thist_field->size = sizeof(u64);\n\t\thist_field->type = kstrdup(\"u64\", GFP_KERNEL);\n\t\tif (!hist_field->type)\n\t\t\tgoto free;\n\t\tgoto out;\n\t}\n\n\tif (flags & HIST_FIELD_FL_STACKTRACE) {\n\t\thist_field->fn = hist_field_none;\n\t\tgoto out;\n\t}\n\n\tif (flags & (HIST_FIELD_FL_LOG2 | HIST_FIELD_FL_BUCKET)) {\n\t\tunsigned long fl = flags & ~(HIST_FIELD_FL_LOG2 | HIST_FIELD_FL_BUCKET);\n\t\thist_field->fn = flags & HIST_FIELD_FL_LOG2 ? hist_field_log2 :\n\t\t\thist_field_bucket;\n\t\thist_field->operands[0] = create_hist_field(hist_data, field, fl, NULL);\n\t\thist_field->size = hist_field->operands[0]->size;\n\t\thist_field->type = kstrdup_const(hist_field->operands[0]->type, GFP_KERNEL);\n\t\tif (!hist_field->type)\n\t\t\tgoto free;\n\t\tgoto out;\n\t}\n\n\tif (flags & HIST_FIELD_FL_TIMESTAMP) {\n\t\thist_field->fn = hist_field_timestamp;\n\t\thist_field->size = sizeof(u64);\n\t\thist_field->type = \"u64\";\n\t\tgoto out;\n\t}\n\n\tif (flags & HIST_FIELD_FL_CPU) {\n\t\thist_field->fn = hist_field_cpu;\n\t\thist_field->size = sizeof(int);\n\t\thist_field->type = \"unsigned int\";\n\t\tgoto out;\n\t}\n\n\tif (WARN_ON_ONCE(!field))\n\t\tgoto out;\n\n\t/* Pointers to strings are just pointers and dangerous to dereference */\n\tif (is_string_field(field) &&\n\t    (field->filter_type != FILTER_PTR_STRING)) {\n\t\tflags |= HIST_FIELD_FL_STRING;\n\n\t\thist_field->size = MAX_FILTER_STR_VAL;\n\t\thist_field->type = kstrdup_const(field->type, GFP_KERNEL);\n\t\tif (!hist_field->type)\n\t\t\tgoto free;\n\n\t\tif (field->filter_type == FILTER_STATIC_STRING) {\n\t\t\thist_field->fn = hist_field_string;\n\t\t\thist_field->size = field->size;\n\t\t} else if (field->filter_type == FILTER_DYN_STRING) {\n\t\t\thist_field->fn = hist_field_dynstring;\n\t\t} else if (field->filter_type == FILTER_RDYN_STRING)\n\t\t\thist_field->fn = hist_field_reldynstring;\n\t\telse\n\t\t\thist_field->fn = hist_field_pstring;\n\t} else {\n\t\thist_field->size = field->size;\n\t\thist_field->is_signed = field->is_signed;\n\t\thist_field->type = kstrdup_const(field->type, GFP_KERNEL);\n\t\tif (!hist_field->type)\n\t\t\tgoto free;\n\n\t\thist_field->fn = select_value_fn(field->size,\n\t\t\t\t\t\t field->is_signed);\n\t\tif (!hist_field->fn) {\n\t\t\tdestroy_hist_field(hist_field, 0);\n\t\t\treturn NULL;\n\t\t}\n\t}\n out:\n\thist_field->field = field;\n\thist_field->flags = flags;\n\n\tif (var_name) {\n\t\thist_field->var.name = kstrdup(var_name, GFP_KERNEL);\n\t\tif (!hist_field->var.name)\n\t\t\tgoto free;\n\t}\n\n\treturn hist_field;\n free:\n\tdestroy_hist_field(hist_field, 0);\n\treturn NULL;\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct hist_field *create_hist_field(struct hist_trigger_data *hist_data,\n\t\t\t\t\t    struct ftrace_event_field *field,\n\t\t\t\t\t    unsigned long flags,\n\t\t\t\t\t    char *var_name)\n{\n\tstruct hist_field *hist_field;\n\n\tif (field && is_function_field(field))\n\t\treturn NULL;\n\n\thist_field = kzalloc(sizeof(struct hist_field), GFP_KERNEL);\n\tif (!hist_field)\n\t\treturn NULL;\n\n\thist_field->ref = 1;\n\n\thist_field->hist_data = hist_data;\n\n\tif (flags & HIST_FIELD_FL_EXPR || flags & HIST_FIELD_FL_ALIAS)\n\t\tgoto out; /* caller will populate */\n\n\tif (flags & HIST_FIELD_FL_VAR_REF) {\n\t\thist_field->fn = hist_field_var_ref;\n\t\tgoto out;\n\t}\n\n\tif (flags & HIST_FIELD_FL_HITCOUNT) {\n\t\thist_field->fn = hist_field_counter;\n\t\thist_field->size = sizeof(u64);\n\t\thist_field->type = \"u64\";\n\t\tgoto out;\n\t}\n\n\tif (flags & HIST_FIELD_FL_CONST) {\n\t\thist_field->fn = hist_field_const;\n\t\thist_field->size = sizeof(u64);\n\t\thist_field->type = kstrdup(\"u64\", GFP_KERNEL);\n\t\tif (!hist_field->type)\n\t\t\tgoto free;\n\t\tgoto out;\n\t}\n\n\tif (flags & HIST_FIELD_FL_STACKTRACE) {\n\t\thist_field->fn = hist_field_none;\n\t\tgoto out;\n\t}\n\n\tif (flags & (HIST_FIELD_FL_LOG2 | HIST_FIELD_FL_BUCKET)) {\n\t\tunsigned long fl = flags & ~(HIST_FIELD_FL_LOG2 | HIST_FIELD_FL_BUCKET);\n\t\thist_field->fn = flags & HIST_FIELD_FL_LOG2 ? hist_field_log2 :\n\t\t\thist_field_bucket;\n\t\thist_field->operands[0] = create_hist_field(hist_data, field, fl, NULL);\n\t\thist_field->size = hist_field->operands[0]->size;\n\t\thist_field->type = kstrdup_const(hist_field->operands[0]->type, GFP_KERNEL);\n\t\tif (!hist_field->type)\n\t\t\tgoto free;\n\t\tgoto out;\n\t}\n\n\tif (flags & HIST_FIELD_FL_TIMESTAMP) {\n\t\thist_field->fn = hist_field_timestamp;\n\t\thist_field->size = sizeof(u64);\n\t\thist_field->type = \"u64\";\n\t\tgoto out;\n\t}\n\n\tif (flags & HIST_FIELD_FL_CPU) {\n\t\thist_field->fn = hist_field_cpu;\n\t\thist_field->size = sizeof(int);\n\t\thist_field->type = \"unsigned int\";\n\t\tgoto out;\n\t}\n\n\tif (WARN_ON_ONCE(!field))\n\t\tgoto out;\n\n\t/* Pointers to strings are just pointers and dangerous to dereference */\n\tif (is_string_field(field) &&\n\t    (field->filter_type != FILTER_PTR_STRING)) {\n\t\tflags |= HIST_FIELD_FL_STRING;\n\n\t\thist_field->size = MAX_FILTER_STR_VAL;\n\t\thist_field->type = kstrdup_const(field->type, GFP_KERNEL);\n\t\tif (!hist_field->type)\n\t\t\tgoto free;\n\n\t\tif (field->filter_type == FILTER_STATIC_STRING) {\n\t\t\thist_field->fn = hist_field_string;\n\t\t\thist_field->size = field->size;\n\t\t} else if (field->filter_type == FILTER_DYN_STRING) {\n\t\t\thist_field->fn = hist_field_dynstring;\n\t\t} else if (field->filter_type == FILTER_RDYN_STRING)\n\t\t\thist_field->fn = hist_field_reldynstring;\n\t\telse\n\t\t\thist_field->fn = hist_field_pstring;\n\t} else {\n\t\thist_field->size = field->size;\n\t\thist_field->is_signed = field->is_signed;\n\t\thist_field->type = kstrdup_const(field->type, GFP_KERNEL);\n\t\tif (!hist_field->type)\n\t\t\tgoto free;\n\n\t\thist_field->fn = select_value_fn(field->size,\n\t\t\t\t\t\t field->is_signed);\n\t\tif (!hist_field->fn) {\n\t\t\tdestroy_hist_field(hist_field, 0);\n\t\t\treturn NULL;\n\t\t}\n\t}\n out:\n\thist_field->field = field;\n\thist_field->flags = flags;\n\n\tif (var_name) {\n\t\thist_field->var.name = kstrdup(var_name, GFP_KERNEL);\n\t\tif (!hist_field->var.name)\n\t\t\tgoto free;\n\t}\n\n\treturn hist_field;\n free:\n\tdestroy_hist_field(hist_field, 0);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_hist_field",
          "args": [
            "ref_field"
          ],
          "line": 2127
        },
        "resolved": true,
        "details": {
          "function_name": "get_hist_field",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "1842-1845",
          "snippet": "static void get_hist_field(struct hist_field *hist_field)\n{\n\thist_field->ref++;\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void get_hist_field(struct hist_field *hist_field)\n{\n\thist_field->ref++;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct hist_field *create_var_ref(struct hist_trigger_data *hist_data,\n\t\t\t\t\t struct hist_field *var_field,\n\t\t\t\t\t char *system, char *event_name)\n{\n\tunsigned long flags = HIST_FIELD_FL_VAR_REF;\n\tstruct hist_field *ref_field;\n\tint i;\n\n\t/* Check if the variable already exists */\n\tfor (i = 0; i < hist_data->n_var_refs; i++) {\n\t\tref_field = hist_data->var_refs[i];\n\t\tif (ref_field->var.idx == var_field->var.idx &&\n\t\t    ref_field->var.hist_data == var_field->hist_data) {\n\t\t\tget_hist_field(ref_field);\n\t\t\treturn ref_field;\n\t\t}\n\t}\n\n\tref_field = create_hist_field(var_field->hist_data, NULL, flags, NULL);\n\tif (ref_field) {\n\t\tif (init_var_ref(ref_field, var_field, system, event_name)) {\n\t\t\tdestroy_hist_field(ref_field, 0);\n\t\t\treturn NULL;\n\t\t}\n\n\t\thist_data->var_refs[hist_data->n_var_refs] = ref_field;\n\t\tref_field->var_ref_idx = hist_data->n_var_refs++;\n\t}\n\n\treturn ref_field;\n}"
  },
  {
    "function_name": "find_var_ref_idx",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
    "lines": "2083-2097",
    "snippet": "static int find_var_ref_idx(struct hist_trigger_data *hist_data,\n\t\t\t    struct hist_field *var_field)\n{\n\tstruct hist_field *ref_field;\n\tint i;\n\n\tfor (i = 0; i < hist_data->n_var_refs; i++) {\n\t\tref_field = hist_data->var_refs[i];\n\t\tif (ref_field->var.idx == var_field->var.idx &&\n\t\t    ref_field->var.hist_data == var_field->hist_data)\n\t\t\treturn i;\n\t}\n\n\treturn -ENOENT;\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include \"tracing_map.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int find_var_ref_idx(struct hist_trigger_data *hist_data,\n\t\t\t    struct hist_field *var_field)\n{\n\tstruct hist_field *ref_field;\n\tint i;\n\n\tfor (i = 0; i < hist_data->n_var_refs; i++) {\n\t\tref_field = hist_data->var_refs[i];\n\t\tif (ref_field->var.idx == var_field->var.idx &&\n\t\t    ref_field->var.hist_data == var_field->hist_data)\n\t\t\treturn i;\n\t}\n\n\treturn -ENOENT;\n}"
  },
  {
    "function_name": "init_var_ref",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
    "lines": "2027-2081",
    "snippet": "static int init_var_ref(struct hist_field *ref_field,\n\t\t\tstruct hist_field *var_field,\n\t\t\tchar *system, char *event_name)\n{\n\tint err = 0;\n\n\tref_field->var.idx = var_field->var.idx;\n\tref_field->var.hist_data = var_field->hist_data;\n\tref_field->size = var_field->size;\n\tref_field->is_signed = var_field->is_signed;\n\tref_field->flags |= var_field->flags &\n\t\t(HIST_FIELD_FL_TIMESTAMP | HIST_FIELD_FL_TIMESTAMP_USECS);\n\n\tif (system) {\n\t\tref_field->system = kstrdup(system, GFP_KERNEL);\n\t\tif (!ref_field->system)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tif (event_name) {\n\t\tref_field->event_name = kstrdup(event_name, GFP_KERNEL);\n\t\tif (!ref_field->event_name) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto free;\n\t\t}\n\t}\n\n\tif (var_field->var.name) {\n\t\tref_field->name = kstrdup(var_field->var.name, GFP_KERNEL);\n\t\tif (!ref_field->name) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto free;\n\t\t}\n\t} else if (var_field->name) {\n\t\tref_field->name = kstrdup(var_field->name, GFP_KERNEL);\n\t\tif (!ref_field->name) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto free;\n\t\t}\n\t}\n\n\tref_field->type = kstrdup_const(var_field->type, GFP_KERNEL);\n\tif (!ref_field->type) {\n\t\terr = -ENOMEM;\n\t\tgoto free;\n\t}\n out:\n\treturn err;\n free:\n\tkfree(ref_field->system);\n\tkfree(ref_field->event_name);\n\tkfree(ref_field->name);\n\n\tgoto out;\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include \"tracing_map.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ref_field->name"
          ],
          "line": 2078
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kstrdup_const",
          "args": [
            "var_field->type",
            "GFP_KERNEL"
          ],
          "line": 2068
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "var_field->name",
            "GFP_KERNEL"
          ],
          "line": 2061
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "var_field->var.name",
            "GFP_KERNEL"
          ],
          "line": 2055
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "event_name",
            "GFP_KERNEL"
          ],
          "line": 2047
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "system",
            "GFP_KERNEL"
          ],
          "line": 2041
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int init_var_ref(struct hist_field *ref_field,\n\t\t\tstruct hist_field *var_field,\n\t\t\tchar *system, char *event_name)\n{\n\tint err = 0;\n\n\tref_field->var.idx = var_field->var.idx;\n\tref_field->var.hist_data = var_field->hist_data;\n\tref_field->size = var_field->size;\n\tref_field->is_signed = var_field->is_signed;\n\tref_field->flags |= var_field->flags &\n\t\t(HIST_FIELD_FL_TIMESTAMP | HIST_FIELD_FL_TIMESTAMP_USECS);\n\n\tif (system) {\n\t\tref_field->system = kstrdup(system, GFP_KERNEL);\n\t\tif (!ref_field->system)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tif (event_name) {\n\t\tref_field->event_name = kstrdup(event_name, GFP_KERNEL);\n\t\tif (!ref_field->event_name) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto free;\n\t\t}\n\t}\n\n\tif (var_field->var.name) {\n\t\tref_field->name = kstrdup(var_field->var.name, GFP_KERNEL);\n\t\tif (!ref_field->name) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto free;\n\t\t}\n\t} else if (var_field->name) {\n\t\tref_field->name = kstrdup(var_field->name, GFP_KERNEL);\n\t\tif (!ref_field->name) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto free;\n\t\t}\n\t}\n\n\tref_field->type = kstrdup_const(var_field->type, GFP_KERNEL);\n\tif (!ref_field->type) {\n\t\terr = -ENOMEM;\n\t\tgoto free;\n\t}\n out:\n\treturn err;\n free:\n\tkfree(ref_field->system);\n\tkfree(ref_field->event_name);\n\tkfree(ref_field->name);\n\n\tgoto out;\n}"
  },
  {
    "function_name": "destroy_hist_fields",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
    "lines": "2009-2025",
    "snippet": "static void destroy_hist_fields(struct hist_trigger_data *hist_data)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < HIST_FIELDS_MAX; i++) {\n\t\tif (hist_data->fields[i]) {\n\t\t\tdestroy_hist_field(hist_data->fields[i], 0);\n\t\t\thist_data->fields[i] = NULL;\n\t\t}\n\t}\n\n\tfor (i = 0; i < hist_data->n_var_refs; i++) {\n\t\tWARN_ON(!(hist_data->var_refs[i]->flags & HIST_FIELD_FL_VAR_REF));\n\t\t__destroy_hist_field(hist_data->var_refs[i]);\n\t\thist_data->var_refs[i] = NULL;\n\t}\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include \"tracing_map.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define HIST_FIELDS_MAX\t\t(TRACING_MAP_FIELDS_MAX + TRACING_MAP_VARS_MAX)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__destroy_hist_field",
          "args": [
            "hist_data->var_refs[i]"
          ],
          "line": 2022
        },
        "resolved": true,
        "details": {
          "function_name": "__destroy_hist_field",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "1847-1862",
          "snippet": "static void __destroy_hist_field(struct hist_field *hist_field)\n{\n\tif (--hist_field->ref > 1)\n\t\treturn;\n\n\tkfree(hist_field->var.name);\n\tkfree(hist_field->name);\n\n\t/* Can likely be a const */\n\tkfree_const(hist_field->type);\n\n\tkfree(hist_field->system);\n\tkfree(hist_field->event_name);\n\n\tkfree(hist_field);\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void __destroy_hist_field(struct hist_field *hist_field)\n{\n\tif (--hist_field->ref > 1)\n\t\treturn;\n\n\tkfree(hist_field->var.name);\n\tkfree(hist_field->name);\n\n\t/* Can likely be a const */\n\tkfree_const(hist_field->type);\n\n\tkfree(hist_field->system);\n\tkfree(hist_field->event_name);\n\n\tkfree(hist_field);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!(hist_data->var_refs[i]->flags & HIST_FIELD_FL_VAR_REF)"
          ],
          "line": 2021
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "destroy_hist_field",
          "args": [
            "hist_data->fields[i]",
            "0"
          ],
          "line": 2015
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_hist_field",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "1864-1882",
          "snippet": "static void destroy_hist_field(struct hist_field *hist_field,\n\t\t\t       unsigned int level)\n{\n\tunsigned int i;\n\n\tif (level > 3)\n\t\treturn;\n\n\tif (!hist_field)\n\t\treturn;\n\n\tif (hist_field->flags & HIST_FIELD_FL_VAR_REF)\n\t\treturn; /* var refs will be destroyed separately */\n\n\tfor (i = 0; i < HIST_FIELD_OPERANDS_MAX; i++)\n\t\tdestroy_hist_field(hist_field->operands[i], level + 1);\n\n\t__destroy_hist_field(hist_field);\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define HIST_FIELD_OPERANDS_MAX\t2"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\n#define HIST_FIELD_OPERANDS_MAX\t2\n\nstatic void destroy_hist_field(struct hist_field *hist_field,\n\t\t\t       unsigned int level)\n{\n\tunsigned int i;\n\n\tif (level > 3)\n\t\treturn;\n\n\tif (!hist_field)\n\t\treturn;\n\n\tif (hist_field->flags & HIST_FIELD_FL_VAR_REF)\n\t\treturn; /* var refs will be destroyed separately */\n\n\tfor (i = 0; i < HIST_FIELD_OPERANDS_MAX; i++)\n\t\tdestroy_hist_field(hist_field->operands[i], level + 1);\n\n\t__destroy_hist_field(hist_field);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\n#define HIST_FIELDS_MAX\t\t(TRACING_MAP_FIELDS_MAX + TRACING_MAP_VARS_MAX)\n\nstatic void destroy_hist_fields(struct hist_trigger_data *hist_data)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < HIST_FIELDS_MAX; i++) {\n\t\tif (hist_data->fields[i]) {\n\t\t\tdestroy_hist_field(hist_data->fields[i], 0);\n\t\t\thist_data->fields[i] = NULL;\n\t\t}\n\t}\n\n\tfor (i = 0; i < hist_data->n_var_refs; i++) {\n\t\tWARN_ON(!(hist_data->var_refs[i]->flags & HIST_FIELD_FL_VAR_REF));\n\t\t__destroy_hist_field(hist_data->var_refs[i]);\n\t\thist_data->var_refs[i] = NULL;\n\t}\n}"
  },
  {
    "function_name": "create_hist_field",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
    "lines": "1884-2007",
    "snippet": "static struct hist_field *create_hist_field(struct hist_trigger_data *hist_data,\n\t\t\t\t\t    struct ftrace_event_field *field,\n\t\t\t\t\t    unsigned long flags,\n\t\t\t\t\t    char *var_name)\n{\n\tstruct hist_field *hist_field;\n\n\tif (field && is_function_field(field))\n\t\treturn NULL;\n\n\thist_field = kzalloc(sizeof(struct hist_field), GFP_KERNEL);\n\tif (!hist_field)\n\t\treturn NULL;\n\n\thist_field->ref = 1;\n\n\thist_field->hist_data = hist_data;\n\n\tif (flags & HIST_FIELD_FL_EXPR || flags & HIST_FIELD_FL_ALIAS)\n\t\tgoto out; /* caller will populate */\n\n\tif (flags & HIST_FIELD_FL_VAR_REF) {\n\t\thist_field->fn = hist_field_var_ref;\n\t\tgoto out;\n\t}\n\n\tif (flags & HIST_FIELD_FL_HITCOUNT) {\n\t\thist_field->fn = hist_field_counter;\n\t\thist_field->size = sizeof(u64);\n\t\thist_field->type = \"u64\";\n\t\tgoto out;\n\t}\n\n\tif (flags & HIST_FIELD_FL_CONST) {\n\t\thist_field->fn = hist_field_const;\n\t\thist_field->size = sizeof(u64);\n\t\thist_field->type = kstrdup(\"u64\", GFP_KERNEL);\n\t\tif (!hist_field->type)\n\t\t\tgoto free;\n\t\tgoto out;\n\t}\n\n\tif (flags & HIST_FIELD_FL_STACKTRACE) {\n\t\thist_field->fn = hist_field_none;\n\t\tgoto out;\n\t}\n\n\tif (flags & (HIST_FIELD_FL_LOG2 | HIST_FIELD_FL_BUCKET)) {\n\t\tunsigned long fl = flags & ~(HIST_FIELD_FL_LOG2 | HIST_FIELD_FL_BUCKET);\n\t\thist_field->fn = flags & HIST_FIELD_FL_LOG2 ? hist_field_log2 :\n\t\t\thist_field_bucket;\n\t\thist_field->operands[0] = create_hist_field(hist_data, field, fl, NULL);\n\t\thist_field->size = hist_field->operands[0]->size;\n\t\thist_field->type = kstrdup_const(hist_field->operands[0]->type, GFP_KERNEL);\n\t\tif (!hist_field->type)\n\t\t\tgoto free;\n\t\tgoto out;\n\t}\n\n\tif (flags & HIST_FIELD_FL_TIMESTAMP) {\n\t\thist_field->fn = hist_field_timestamp;\n\t\thist_field->size = sizeof(u64);\n\t\thist_field->type = \"u64\";\n\t\tgoto out;\n\t}\n\n\tif (flags & HIST_FIELD_FL_CPU) {\n\t\thist_field->fn = hist_field_cpu;\n\t\thist_field->size = sizeof(int);\n\t\thist_field->type = \"unsigned int\";\n\t\tgoto out;\n\t}\n\n\tif (WARN_ON_ONCE(!field))\n\t\tgoto out;\n\n\t/* Pointers to strings are just pointers and dangerous to dereference */\n\tif (is_string_field(field) &&\n\t    (field->filter_type != FILTER_PTR_STRING)) {\n\t\tflags |= HIST_FIELD_FL_STRING;\n\n\t\thist_field->size = MAX_FILTER_STR_VAL;\n\t\thist_field->type = kstrdup_const(field->type, GFP_KERNEL);\n\t\tif (!hist_field->type)\n\t\t\tgoto free;\n\n\t\tif (field->filter_type == FILTER_STATIC_STRING) {\n\t\t\thist_field->fn = hist_field_string;\n\t\t\thist_field->size = field->size;\n\t\t} else if (field->filter_type == FILTER_DYN_STRING) {\n\t\t\thist_field->fn = hist_field_dynstring;\n\t\t} else if (field->filter_type == FILTER_RDYN_STRING)\n\t\t\thist_field->fn = hist_field_reldynstring;\n\t\telse\n\t\t\thist_field->fn = hist_field_pstring;\n\t} else {\n\t\thist_field->size = field->size;\n\t\thist_field->is_signed = field->is_signed;\n\t\thist_field->type = kstrdup_const(field->type, GFP_KERNEL);\n\t\tif (!hist_field->type)\n\t\t\tgoto free;\n\n\t\thist_field->fn = select_value_fn(field->size,\n\t\t\t\t\t\t field->is_signed);\n\t\tif (!hist_field->fn) {\n\t\t\tdestroy_hist_field(hist_field, 0);\n\t\t\treturn NULL;\n\t\t}\n\t}\n out:\n\thist_field->field = field;\n\thist_field->flags = flags;\n\n\tif (var_name) {\n\t\thist_field->var.name = kstrdup(var_name, GFP_KERNEL);\n\t\tif (!hist_field->var.name)\n\t\t\tgoto free;\n\t}\n\n\treturn hist_field;\n free:\n\tdestroy_hist_field(hist_field, 0);\n\treturn NULL;\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include \"tracing_map.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "destroy_hist_field",
          "args": [
            "hist_field",
            "0"
          ],
          "line": 2005
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_hist_field",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "1864-1882",
          "snippet": "static void destroy_hist_field(struct hist_field *hist_field,\n\t\t\t       unsigned int level)\n{\n\tunsigned int i;\n\n\tif (level > 3)\n\t\treturn;\n\n\tif (!hist_field)\n\t\treturn;\n\n\tif (hist_field->flags & HIST_FIELD_FL_VAR_REF)\n\t\treturn; /* var refs will be destroyed separately */\n\n\tfor (i = 0; i < HIST_FIELD_OPERANDS_MAX; i++)\n\t\tdestroy_hist_field(hist_field->operands[i], level + 1);\n\n\t__destroy_hist_field(hist_field);\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define HIST_FIELD_OPERANDS_MAX\t2"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\n#define HIST_FIELD_OPERANDS_MAX\t2\n\nstatic void destroy_hist_field(struct hist_field *hist_field,\n\t\t\t       unsigned int level)\n{\n\tunsigned int i;\n\n\tif (level > 3)\n\t\treturn;\n\n\tif (!hist_field)\n\t\treturn;\n\n\tif (hist_field->flags & HIST_FIELD_FL_VAR_REF)\n\t\treturn; /* var refs will be destroyed separately */\n\n\tfor (i = 0; i < HIST_FIELD_OPERANDS_MAX; i++)\n\t\tdestroy_hist_field(hist_field->operands[i], level + 1);\n\n\t__destroy_hist_field(hist_field);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "var_name",
            "GFP_KERNEL"
          ],
          "line": 1998
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "select_value_fn",
          "args": [
            "field->size",
            "field->is_signed"
          ],
          "line": 1986
        },
        "resolved": true,
        "details": {
          "function_name": "select_value_fn",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "1318-1350",
          "snippet": "static hist_field_fn_t select_value_fn(int field_size, int field_is_signed)\n{\n\thist_field_fn_t fn = NULL;\n\n\tswitch (field_size) {\n\tcase 8:\n\t\tif (field_is_signed)\n\t\t\tfn = hist_field_s64;\n\t\telse\n\t\t\tfn = hist_field_u64;\n\t\tbreak;\n\tcase 4:\n\t\tif (field_is_signed)\n\t\t\tfn = hist_field_s32;\n\t\telse\n\t\t\tfn = hist_field_u32;\n\t\tbreak;\n\tcase 2:\n\t\tif (field_is_signed)\n\t\t\tfn = hist_field_s16;\n\t\telse\n\t\t\tfn = hist_field_u16;\n\t\tbreak;\n\tcase 1:\n\t\tif (field_is_signed)\n\t\t\tfn = hist_field_s8;\n\t\telse\n\t\t\tfn = hist_field_u8;\n\t\tbreak;\n\t}\n\n\treturn fn;\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic hist_field_fn_t select_value_fn(int field_size, int field_is_signed)\n{\n\thist_field_fn_t fn = NULL;\n\n\tswitch (field_size) {\n\tcase 8:\n\t\tif (field_is_signed)\n\t\t\tfn = hist_field_s64;\n\t\telse\n\t\t\tfn = hist_field_u64;\n\t\tbreak;\n\tcase 4:\n\t\tif (field_is_signed)\n\t\t\tfn = hist_field_s32;\n\t\telse\n\t\t\tfn = hist_field_u32;\n\t\tbreak;\n\tcase 2:\n\t\tif (field_is_signed)\n\t\t\tfn = hist_field_s16;\n\t\telse\n\t\t\tfn = hist_field_u16;\n\t\tbreak;\n\tcase 1:\n\t\tif (field_is_signed)\n\t\t\tfn = hist_field_s8;\n\t\telse\n\t\t\tfn = hist_field_u8;\n\t\tbreak;\n\t}\n\n\treturn fn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kstrdup_const",
          "args": [
            "field->type",
            "GFP_KERNEL"
          ],
          "line": 1982
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrdup_const",
          "args": [
            "field->type",
            "GFP_KERNEL"
          ],
          "line": 1966
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_string_field",
          "args": [
            "field"
          ],
          "line": 1961
        },
        "resolved": true,
        "details": {
          "function_name": "is_string_field",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.h",
          "lines": "1470-1477",
          "snippet": "static inline bool is_string_field(struct ftrace_event_field *field)\n{\n\treturn field->filter_type == FILTER_DYN_STRING ||\n\t       field->filter_type == FILTER_RDYN_STRING ||\n\t       field->filter_type == FILTER_STATIC_STRING ||\n\t       field->filter_type == FILTER_PTR_STRING ||\n\t       field->filter_type == FILTER_COMM;\n}",
          "includes": [
            "#include \"trace_entries.h\"",
            "#include \"trace_entries.h\"",
            "#include <asm/syscall.h>\t/* some archs define it here */",
            "#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */",
            "#include \"pid_list.h\"",
            "#include <linux/once_lite.h>",
            "#include <linux/ctype.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/glob.h>",
            "#include <linux/compiler.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/mmiotrace.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_entries.h\"\n#include \"trace_entries.h\"\n#include <asm/syscall.h>\t/* some archs define it here */\n#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */\n#include \"pid_list.h\"\n#include <linux/once_lite.h>\n#include <linux/ctype.h>\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/glob.h>\n#include <linux/compiler.h>\n#include <linux/trace_events.h>\n#include <linux/trace_seq.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <linux/mmiotrace.h>\n#include <linux/ring_buffer.h>\n#include <linux/clocksource.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n#include <linux/fs.h>\n\nstatic inline bool is_string_field(struct ftrace_event_field *field)\n{\n\treturn field->filter_type == FILTER_DYN_STRING ||\n\t       field->filter_type == FILTER_RDYN_STRING ||\n\t       field->filter_type == FILTER_STATIC_STRING ||\n\t       field->filter_type == FILTER_PTR_STRING ||\n\t       field->filter_type == FILTER_COMM;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!field"
          ],
          "line": 1957
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrdup_const",
          "args": [
            "hist_field->operands[0]->type",
            "GFP_KERNEL"
          ],
          "line": 1937
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "create_hist_field",
          "args": [
            "hist_data",
            "field",
            "fl",
            "NULL"
          ],
          "line": 1935
        },
        "resolved": true,
        "details": {
          "function_name": "create_hist_field",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "1884-2007",
          "snippet": "static struct hist_field *create_hist_field(struct hist_trigger_data *hist_data,\n\t\t\t\t\t    struct ftrace_event_field *field,\n\t\t\t\t\t    unsigned long flags,\n\t\t\t\t\t    char *var_name)\n{\n\tstruct hist_field *hist_field;\n\n\tif (field && is_function_field(field))\n\t\treturn NULL;\n\n\thist_field = kzalloc(sizeof(struct hist_field), GFP_KERNEL);\n\tif (!hist_field)\n\t\treturn NULL;\n\n\thist_field->ref = 1;\n\n\thist_field->hist_data = hist_data;\n\n\tif (flags & HIST_FIELD_FL_EXPR || flags & HIST_FIELD_FL_ALIAS)\n\t\tgoto out; /* caller will populate */\n\n\tif (flags & HIST_FIELD_FL_VAR_REF) {\n\t\thist_field->fn = hist_field_var_ref;\n\t\tgoto out;\n\t}\n\n\tif (flags & HIST_FIELD_FL_HITCOUNT) {\n\t\thist_field->fn = hist_field_counter;\n\t\thist_field->size = sizeof(u64);\n\t\thist_field->type = \"u64\";\n\t\tgoto out;\n\t}\n\n\tif (flags & HIST_FIELD_FL_CONST) {\n\t\thist_field->fn = hist_field_const;\n\t\thist_field->size = sizeof(u64);\n\t\thist_field->type = kstrdup(\"u64\", GFP_KERNEL);\n\t\tif (!hist_field->type)\n\t\t\tgoto free;\n\t\tgoto out;\n\t}\n\n\tif (flags & HIST_FIELD_FL_STACKTRACE) {\n\t\thist_field->fn = hist_field_none;\n\t\tgoto out;\n\t}\n\n\tif (flags & (HIST_FIELD_FL_LOG2 | HIST_FIELD_FL_BUCKET)) {\n\t\tunsigned long fl = flags & ~(HIST_FIELD_FL_LOG2 | HIST_FIELD_FL_BUCKET);\n\t\thist_field->fn = flags & HIST_FIELD_FL_LOG2 ? hist_field_log2 :\n\t\t\thist_field_bucket;\n\t\thist_field->operands[0] = create_hist_field(hist_data, field, fl, NULL);\n\t\thist_field->size = hist_field->operands[0]->size;\n\t\thist_field->type = kstrdup_const(hist_field->operands[0]->type, GFP_KERNEL);\n\t\tif (!hist_field->type)\n\t\t\tgoto free;\n\t\tgoto out;\n\t}\n\n\tif (flags & HIST_FIELD_FL_TIMESTAMP) {\n\t\thist_field->fn = hist_field_timestamp;\n\t\thist_field->size = sizeof(u64);\n\t\thist_field->type = \"u64\";\n\t\tgoto out;\n\t}\n\n\tif (flags & HIST_FIELD_FL_CPU) {\n\t\thist_field->fn = hist_field_cpu;\n\t\thist_field->size = sizeof(int);\n\t\thist_field->type = \"unsigned int\";\n\t\tgoto out;\n\t}\n\n\tif (WARN_ON_ONCE(!field))\n\t\tgoto out;\n\n\t/* Pointers to strings are just pointers and dangerous to dereference */\n\tif (is_string_field(field) &&\n\t    (field->filter_type != FILTER_PTR_STRING)) {\n\t\tflags |= HIST_FIELD_FL_STRING;\n\n\t\thist_field->size = MAX_FILTER_STR_VAL;\n\t\thist_field->type = kstrdup_const(field->type, GFP_KERNEL);\n\t\tif (!hist_field->type)\n\t\t\tgoto free;\n\n\t\tif (field->filter_type == FILTER_STATIC_STRING) {\n\t\t\thist_field->fn = hist_field_string;\n\t\t\thist_field->size = field->size;\n\t\t} else if (field->filter_type == FILTER_DYN_STRING) {\n\t\t\thist_field->fn = hist_field_dynstring;\n\t\t} else if (field->filter_type == FILTER_RDYN_STRING)\n\t\t\thist_field->fn = hist_field_reldynstring;\n\t\telse\n\t\t\thist_field->fn = hist_field_pstring;\n\t} else {\n\t\thist_field->size = field->size;\n\t\thist_field->is_signed = field->is_signed;\n\t\thist_field->type = kstrdup_const(field->type, GFP_KERNEL);\n\t\tif (!hist_field->type)\n\t\t\tgoto free;\n\n\t\thist_field->fn = select_value_fn(field->size,\n\t\t\t\t\t\t field->is_signed);\n\t\tif (!hist_field->fn) {\n\t\t\tdestroy_hist_field(hist_field, 0);\n\t\t\treturn NULL;\n\t\t}\n\t}\n out:\n\thist_field->field = field;\n\thist_field->flags = flags;\n\n\tif (var_name) {\n\t\thist_field->var.name = kstrdup(var_name, GFP_KERNEL);\n\t\tif (!hist_field->var.name)\n\t\t\tgoto free;\n\t}\n\n\treturn hist_field;\n free:\n\tdestroy_hist_field(hist_field, 0);\n\treturn NULL;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "\"u64\"",
            "GFP_KERNEL"
          ],
          "line": 1920
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct hist_field)",
            "GFP_KERNEL"
          ],
          "line": 1894
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_function_field",
          "args": [
            "field"
          ],
          "line": 1891
        },
        "resolved": true,
        "details": {
          "function_name": "is_function_field",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.h",
          "lines": "1479-1482",
          "snippet": "static inline bool is_function_field(struct ftrace_event_field *field)\n{\n\treturn field->filter_type == FILTER_TRACE_FN;\n}",
          "includes": [
            "#include \"trace_entries.h\"",
            "#include \"trace_entries.h\"",
            "#include <asm/syscall.h>\t/* some archs define it here */",
            "#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */",
            "#include \"pid_list.h\"",
            "#include <linux/once_lite.h>",
            "#include <linux/ctype.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/glob.h>",
            "#include <linux/compiler.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/mmiotrace.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_entries.h\"\n#include \"trace_entries.h\"\n#include <asm/syscall.h>\t/* some archs define it here */\n#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */\n#include \"pid_list.h\"\n#include <linux/once_lite.h>\n#include <linux/ctype.h>\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/glob.h>\n#include <linux/compiler.h>\n#include <linux/trace_events.h>\n#include <linux/trace_seq.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <linux/mmiotrace.h>\n#include <linux/ring_buffer.h>\n#include <linux/clocksource.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n#include <linux/fs.h>\n\nstatic inline bool is_function_field(struct ftrace_event_field *field)\n{\n\treturn field->filter_type == FILTER_TRACE_FN;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct hist_field *create_hist_field(struct hist_trigger_data *hist_data,\n\t\t\t\t\t    struct ftrace_event_field *field,\n\t\t\t\t\t    unsigned long flags,\n\t\t\t\t\t    char *var_name)\n{\n\tstruct hist_field *hist_field;\n\n\tif (field && is_function_field(field))\n\t\treturn NULL;\n\n\thist_field = kzalloc(sizeof(struct hist_field), GFP_KERNEL);\n\tif (!hist_field)\n\t\treturn NULL;\n\n\thist_field->ref = 1;\n\n\thist_field->hist_data = hist_data;\n\n\tif (flags & HIST_FIELD_FL_EXPR || flags & HIST_FIELD_FL_ALIAS)\n\t\tgoto out; /* caller will populate */\n\n\tif (flags & HIST_FIELD_FL_VAR_REF) {\n\t\thist_field->fn = hist_field_var_ref;\n\t\tgoto out;\n\t}\n\n\tif (flags & HIST_FIELD_FL_HITCOUNT) {\n\t\thist_field->fn = hist_field_counter;\n\t\thist_field->size = sizeof(u64);\n\t\thist_field->type = \"u64\";\n\t\tgoto out;\n\t}\n\n\tif (flags & HIST_FIELD_FL_CONST) {\n\t\thist_field->fn = hist_field_const;\n\t\thist_field->size = sizeof(u64);\n\t\thist_field->type = kstrdup(\"u64\", GFP_KERNEL);\n\t\tif (!hist_field->type)\n\t\t\tgoto free;\n\t\tgoto out;\n\t}\n\n\tif (flags & HIST_FIELD_FL_STACKTRACE) {\n\t\thist_field->fn = hist_field_none;\n\t\tgoto out;\n\t}\n\n\tif (flags & (HIST_FIELD_FL_LOG2 | HIST_FIELD_FL_BUCKET)) {\n\t\tunsigned long fl = flags & ~(HIST_FIELD_FL_LOG2 | HIST_FIELD_FL_BUCKET);\n\t\thist_field->fn = flags & HIST_FIELD_FL_LOG2 ? hist_field_log2 :\n\t\t\thist_field_bucket;\n\t\thist_field->operands[0] = create_hist_field(hist_data, field, fl, NULL);\n\t\thist_field->size = hist_field->operands[0]->size;\n\t\thist_field->type = kstrdup_const(hist_field->operands[0]->type, GFP_KERNEL);\n\t\tif (!hist_field->type)\n\t\t\tgoto free;\n\t\tgoto out;\n\t}\n\n\tif (flags & HIST_FIELD_FL_TIMESTAMP) {\n\t\thist_field->fn = hist_field_timestamp;\n\t\thist_field->size = sizeof(u64);\n\t\thist_field->type = \"u64\";\n\t\tgoto out;\n\t}\n\n\tif (flags & HIST_FIELD_FL_CPU) {\n\t\thist_field->fn = hist_field_cpu;\n\t\thist_field->size = sizeof(int);\n\t\thist_field->type = \"unsigned int\";\n\t\tgoto out;\n\t}\n\n\tif (WARN_ON_ONCE(!field))\n\t\tgoto out;\n\n\t/* Pointers to strings are just pointers and dangerous to dereference */\n\tif (is_string_field(field) &&\n\t    (field->filter_type != FILTER_PTR_STRING)) {\n\t\tflags |= HIST_FIELD_FL_STRING;\n\n\t\thist_field->size = MAX_FILTER_STR_VAL;\n\t\thist_field->type = kstrdup_const(field->type, GFP_KERNEL);\n\t\tif (!hist_field->type)\n\t\t\tgoto free;\n\n\t\tif (field->filter_type == FILTER_STATIC_STRING) {\n\t\t\thist_field->fn = hist_field_string;\n\t\t\thist_field->size = field->size;\n\t\t} else if (field->filter_type == FILTER_DYN_STRING) {\n\t\t\thist_field->fn = hist_field_dynstring;\n\t\t} else if (field->filter_type == FILTER_RDYN_STRING)\n\t\t\thist_field->fn = hist_field_reldynstring;\n\t\telse\n\t\t\thist_field->fn = hist_field_pstring;\n\t} else {\n\t\thist_field->size = field->size;\n\t\thist_field->is_signed = field->is_signed;\n\t\thist_field->type = kstrdup_const(field->type, GFP_KERNEL);\n\t\tif (!hist_field->type)\n\t\t\tgoto free;\n\n\t\thist_field->fn = select_value_fn(field->size,\n\t\t\t\t\t\t field->is_signed);\n\t\tif (!hist_field->fn) {\n\t\t\tdestroy_hist_field(hist_field, 0);\n\t\t\treturn NULL;\n\t\t}\n\t}\n out:\n\thist_field->field = field;\n\thist_field->flags = flags;\n\n\tif (var_name) {\n\t\thist_field->var.name = kstrdup(var_name, GFP_KERNEL);\n\t\tif (!hist_field->var.name)\n\t\t\tgoto free;\n\t}\n\n\treturn hist_field;\n free:\n\tdestroy_hist_field(hist_field, 0);\n\treturn NULL;\n}"
  },
  {
    "function_name": "destroy_hist_field",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
    "lines": "1864-1882",
    "snippet": "static void destroy_hist_field(struct hist_field *hist_field,\n\t\t\t       unsigned int level)\n{\n\tunsigned int i;\n\n\tif (level > 3)\n\t\treturn;\n\n\tif (!hist_field)\n\t\treturn;\n\n\tif (hist_field->flags & HIST_FIELD_FL_VAR_REF)\n\t\treturn; /* var refs will be destroyed separately */\n\n\tfor (i = 0; i < HIST_FIELD_OPERANDS_MAX; i++)\n\t\tdestroy_hist_field(hist_field->operands[i], level + 1);\n\n\t__destroy_hist_field(hist_field);\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include \"tracing_map.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define HIST_FIELD_OPERANDS_MAX\t2"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__destroy_hist_field",
          "args": [
            "hist_field"
          ],
          "line": 1881
        },
        "resolved": true,
        "details": {
          "function_name": "__destroy_hist_field",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "1847-1862",
          "snippet": "static void __destroy_hist_field(struct hist_field *hist_field)\n{\n\tif (--hist_field->ref > 1)\n\t\treturn;\n\n\tkfree(hist_field->var.name);\n\tkfree(hist_field->name);\n\n\t/* Can likely be a const */\n\tkfree_const(hist_field->type);\n\n\tkfree(hist_field->system);\n\tkfree(hist_field->event_name);\n\n\tkfree(hist_field);\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void __destroy_hist_field(struct hist_field *hist_field)\n{\n\tif (--hist_field->ref > 1)\n\t\treturn;\n\n\tkfree(hist_field->var.name);\n\tkfree(hist_field->name);\n\n\t/* Can likely be a const */\n\tkfree_const(hist_field->type);\n\n\tkfree(hist_field->system);\n\tkfree(hist_field->event_name);\n\n\tkfree(hist_field);\n}"
        }
      },
      {
        "call_info": {
          "callee": "destroy_hist_field",
          "args": [
            "hist_field->operands[i]",
            "level + 1"
          ],
          "line": 1879
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_hist_field",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "1864-1882",
          "snippet": "static void destroy_hist_field(struct hist_field *hist_field,\n\t\t\t       unsigned int level)\n{\n\tunsigned int i;\n\n\tif (level > 3)\n\t\treturn;\n\n\tif (!hist_field)\n\t\treturn;\n\n\tif (hist_field->flags & HIST_FIELD_FL_VAR_REF)\n\t\treturn; /* var refs will be destroyed separately */\n\n\tfor (i = 0; i < HIST_FIELD_OPERANDS_MAX; i++)\n\t\tdestroy_hist_field(hist_field->operands[i], level + 1);\n\n\t__destroy_hist_field(hist_field);\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\n#define HIST_FIELD_OPERANDS_MAX\t2\n\nstatic void destroy_hist_field(struct hist_field *hist_field,\n\t\t\t       unsigned int level)\n{\n\tunsigned int i;\n\n\tif (level > 3)\n\t\treturn;\n\n\tif (!hist_field)\n\t\treturn;\n\n\tif (hist_field->flags & HIST_FIELD_FL_VAR_REF)\n\t\treturn; /* var refs will be destroyed separately */\n\n\tfor (i = 0; i < HIST_FIELD_OPERANDS_MAX; i++)\n\t\tdestroy_hist_field(hist_field->operands[i], level + 1);\n\n\t__destroy_hist_field(hist_field);\n}"
  },
  {
    "function_name": "__destroy_hist_field",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
    "lines": "1847-1862",
    "snippet": "static void __destroy_hist_field(struct hist_field *hist_field)\n{\n\tif (--hist_field->ref > 1)\n\t\treturn;\n\n\tkfree(hist_field->var.name);\n\tkfree(hist_field->name);\n\n\t/* Can likely be a const */\n\tkfree_const(hist_field->type);\n\n\tkfree(hist_field->system);\n\tkfree(hist_field->event_name);\n\n\tkfree(hist_field);\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include \"tracing_map.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "hist_field"
          ],
          "line": 1861
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree_const",
          "args": [
            "hist_field->type"
          ],
          "line": 1856
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void __destroy_hist_field(struct hist_field *hist_field)\n{\n\tif (--hist_field->ref > 1)\n\t\treturn;\n\n\tkfree(hist_field->var.name);\n\tkfree(hist_field->name);\n\n\t/* Can likely be a const */\n\tkfree_const(hist_field->type);\n\n\tkfree(hist_field->system);\n\tkfree(hist_field->event_name);\n\n\tkfree(hist_field);\n}"
  },
  {
    "function_name": "get_hist_field",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
    "lines": "1842-1845",
    "snippet": "static void get_hist_field(struct hist_field *hist_field)\n{\n\thist_field->ref++;\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include \"tracing_map.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void get_hist_field(struct hist_field *hist_field)\n{\n\thist_field->ref++;\n}"
  },
  {
    "function_name": "contains_operator",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
    "lines": "1755-1840",
    "snippet": "static int contains_operator(char *str, char **sep)\n{\n\tenum field_op_id field_op = FIELD_OP_NONE;\n\tchar *minus_op, *plus_op, *div_op, *mult_op;\n\n\n\t/*\n\t * Report the last occurrence of the operators first, so that the\n\t * expression is evaluated left to right. This is important since\n\t * subtraction and division are not associative.\n\t *\n\t *\te.g\n\t *\t\t64/8/4/2 is 1, i.e 64/8/4/2 = ((64/8)/4)/2\n\t *\t\t14-7-5-2 is 0, i.e 14-7-5-2 = ((14-7)-5)-2\n\t */\n\n\t/*\n\t * First, find lower precedence addition and subtraction\n\t * since the expression will be evaluated recursively.\n\t */\n\tminus_op = strrchr(str, '-');\n\tif (minus_op) {\n\t\t/*\n\t\t * Unary minus is not supported in sub-expressions. If\n\t\t * present, it is always the next root operator.\n\t\t */\n\t\tif (minus_op == str) {\n\t\t\tfield_op = FIELD_OP_UNARY_MINUS;\n\t\t\tgoto out;\n\t\t}\n\n\t\tfield_op = FIELD_OP_MINUS;\n\t}\n\n\tplus_op = strrchr(str, '+');\n\tif (plus_op || minus_op) {\n\t\t/*\n\t\t * For operators of the same precedence use to rightmost as the\n\t\t * root, so that the expression is evaluated left to right.\n\t\t */\n\t\tif (plus_op > minus_op)\n\t\t\tfield_op = FIELD_OP_PLUS;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Multiplication and division have higher precedence than addition and\n\t * subtraction.\n\t */\n\tdiv_op = strrchr(str, '/');\n\tif (div_op)\n\t\tfield_op = FIELD_OP_DIV;\n\n\tmult_op = strrchr(str, '*');\n\t/*\n\t * For operators of the same precedence use to rightmost as the\n\t * root, so that the expression is evaluated left to right.\n\t */\n\tif (mult_op > div_op)\n\t\tfield_op = FIELD_OP_MULT;\n\nout:\n\tif (sep) {\n\t\tswitch (field_op) {\n\t\tcase FIELD_OP_UNARY_MINUS:\n\t\tcase FIELD_OP_MINUS:\n\t\t\t*sep = minus_op;\n\t\t\tbreak;\n\t\tcase FIELD_OP_PLUS:\n\t\t\t*sep = plus_op;\n\t\t\tbreak;\n\t\tcase FIELD_OP_DIV:\n\t\t\t*sep = div_op;\n\t\t\tbreak;\n\t\tcase FIELD_OP_MULT:\n\t\t\t*sep = mult_op;\n\t\t\tbreak;\n\t\tcase FIELD_OP_NONE:\n\t\tdefault:\n\t\t\t*sep = NULL;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn field_op;\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include \"tracing_map.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strrchr",
          "args": [
            "str",
            "'*'"
          ],
          "line": 1808
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strrchr",
          "args": [
            "str",
            "'/'"
          ],
          "line": 1804
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strrchr",
          "args": [
            "str",
            "'+'"
          ],
          "line": 1789
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strrchr",
          "args": [
            "str",
            "'-'"
          ],
          "line": 1775
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int contains_operator(char *str, char **sep)\n{\n\tenum field_op_id field_op = FIELD_OP_NONE;\n\tchar *minus_op, *plus_op, *div_op, *mult_op;\n\n\n\t/*\n\t * Report the last occurrence of the operators first, so that the\n\t * expression is evaluated left to right. This is important since\n\t * subtraction and division are not associative.\n\t *\n\t *\te.g\n\t *\t\t64/8/4/2 is 1, i.e 64/8/4/2 = ((64/8)/4)/2\n\t *\t\t14-7-5-2 is 0, i.e 14-7-5-2 = ((14-7)-5)-2\n\t */\n\n\t/*\n\t * First, find lower precedence addition and subtraction\n\t * since the expression will be evaluated recursively.\n\t */\n\tminus_op = strrchr(str, '-');\n\tif (minus_op) {\n\t\t/*\n\t\t * Unary minus is not supported in sub-expressions. If\n\t\t * present, it is always the next root operator.\n\t\t */\n\t\tif (minus_op == str) {\n\t\t\tfield_op = FIELD_OP_UNARY_MINUS;\n\t\t\tgoto out;\n\t\t}\n\n\t\tfield_op = FIELD_OP_MINUS;\n\t}\n\n\tplus_op = strrchr(str, '+');\n\tif (plus_op || minus_op) {\n\t\t/*\n\t\t * For operators of the same precedence use to rightmost as the\n\t\t * root, so that the expression is evaluated left to right.\n\t\t */\n\t\tif (plus_op > minus_op)\n\t\t\tfield_op = FIELD_OP_PLUS;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Multiplication and division have higher precedence than addition and\n\t * subtraction.\n\t */\n\tdiv_op = strrchr(str, '/');\n\tif (div_op)\n\t\tfield_op = FIELD_OP_DIV;\n\n\tmult_op = strrchr(str, '*');\n\t/*\n\t * For operators of the same precedence use to rightmost as the\n\t * root, so that the expression is evaluated left to right.\n\t */\n\tif (mult_op > div_op)\n\t\tfield_op = FIELD_OP_MULT;\n\nout:\n\tif (sep) {\n\t\tswitch (field_op) {\n\t\tcase FIELD_OP_UNARY_MINUS:\n\t\tcase FIELD_OP_MINUS:\n\t\t\t*sep = minus_op;\n\t\t\tbreak;\n\t\tcase FIELD_OP_PLUS:\n\t\t\t*sep = plus_op;\n\t\t\tbreak;\n\t\tcase FIELD_OP_DIV:\n\t\t\t*sep = div_op;\n\t\t\tbreak;\n\t\tcase FIELD_OP_MULT:\n\t\t\t*sep = mult_op;\n\t\t\tbreak;\n\t\tcase FIELD_OP_NONE:\n\t\tdefault:\n\t\t\t*sep = NULL;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn field_op;\n}"
  },
  {
    "function_name": "expr_str",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
    "lines": "1693-1749",
    "snippet": "static char *expr_str(struct hist_field *field, unsigned int level)\n{\n\tchar *expr;\n\n\tif (level > 1)\n\t\treturn NULL;\n\n\texpr = kzalloc(MAX_FILTER_STR_VAL, GFP_KERNEL);\n\tif (!expr)\n\t\treturn NULL;\n\n\tif (!field->operands[0]) {\n\t\texpr_field_str(field, expr);\n\t\treturn expr;\n\t}\n\n\tif (field->operator == FIELD_OP_UNARY_MINUS) {\n\t\tchar *subexpr;\n\n\t\tstrcat(expr, \"-(\");\n\t\tsubexpr = expr_str(field->operands[0], ++level);\n\t\tif (!subexpr) {\n\t\t\tkfree(expr);\n\t\t\treturn NULL;\n\t\t}\n\t\tstrcat(expr, subexpr);\n\t\tstrcat(expr, \")\");\n\n\t\tkfree(subexpr);\n\n\t\treturn expr;\n\t}\n\n\texpr_field_str(field->operands[0], expr);\n\n\tswitch (field->operator) {\n\tcase FIELD_OP_MINUS:\n\t\tstrcat(expr, \"-\");\n\t\tbreak;\n\tcase FIELD_OP_PLUS:\n\t\tstrcat(expr, \"+\");\n\t\tbreak;\n\tcase FIELD_OP_DIV:\n\t\tstrcat(expr, \"/\");\n\t\tbreak;\n\tcase FIELD_OP_MULT:\n\t\tstrcat(expr, \"*\");\n\t\tbreak;\n\tdefault:\n\t\tkfree(expr);\n\t\treturn NULL;\n\t}\n\n\texpr_field_str(field->operands[1], expr);\n\n\treturn expr;\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include \"tracing_map.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "expr_field_str",
          "args": [
            "field->operands[1]",
            "expr"
          ],
          "line": 1746
        },
        "resolved": true,
        "details": {
          "function_name": "expr_field_str",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "1670-1691",
          "snippet": "static void expr_field_str(struct hist_field *field, char *expr)\n{\n\tif (field->flags & HIST_FIELD_FL_VAR_REF)\n\t\tstrcat(expr, \"$\");\n\telse if (field->flags & HIST_FIELD_FL_CONST) {\n\t\tchar str[HIST_CONST_DIGITS_MAX];\n\n\t\tsnprintf(str, HIST_CONST_DIGITS_MAX, \"%llu\", field->constant);\n\t\tstrcat(expr, str);\n\t}\n\n\tstrcat(expr, hist_field_name(field, 0));\n\n\tif (field->flags && !(field->flags & HIST_FIELD_FL_VAR_REF)) {\n\t\tconst char *flags_str = get_hist_field_flags(field);\n\n\t\tif (flags_str) {\n\t\t\tstrcat(expr, \".\");\n\t\t\tstrcat(expr, flags_str);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define HIST_CONST_DIGITS_MAX\t21"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\n#define HIST_CONST_DIGITS_MAX\t21\n\nstatic void expr_field_str(struct hist_field *field, char *expr)\n{\n\tif (field->flags & HIST_FIELD_FL_VAR_REF)\n\t\tstrcat(expr, \"$\");\n\telse if (field->flags & HIST_FIELD_FL_CONST) {\n\t\tchar str[HIST_CONST_DIGITS_MAX];\n\n\t\tsnprintf(str, HIST_CONST_DIGITS_MAX, \"%llu\", field->constant);\n\t\tstrcat(expr, str);\n\t}\n\n\tstrcat(expr, hist_field_name(field, 0));\n\n\tif (field->flags && !(field->flags & HIST_FIELD_FL_VAR_REF)) {\n\t\tconst char *flags_str = get_hist_field_flags(field);\n\n\t\tif (flags_str) {\n\t\t\tstrcat(expr, \".\");\n\t\t\tstrcat(expr, flags_str);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "expr"
          ],
          "line": 1742
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "expr",
            "\"*\""
          ],
          "line": 1739
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "expr",
            "\"/\""
          ],
          "line": 1736
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "expr",
            "\"+\""
          ],
          "line": 1733
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "expr",
            "\"-\""
          ],
          "line": 1730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "expr",
            "\")\""
          ],
          "line": 1719
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "expr",
            "subexpr"
          ],
          "line": 1718
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "expr_str",
          "args": [
            "field->operands[0]",
            "++level"
          ],
          "line": 1713
        },
        "resolved": true,
        "details": {
          "function_name": "expr_str",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "1693-1749",
          "snippet": "static char *expr_str(struct hist_field *field, unsigned int level)\n{\n\tchar *expr;\n\n\tif (level > 1)\n\t\treturn NULL;\n\n\texpr = kzalloc(MAX_FILTER_STR_VAL, GFP_KERNEL);\n\tif (!expr)\n\t\treturn NULL;\n\n\tif (!field->operands[0]) {\n\t\texpr_field_str(field, expr);\n\t\treturn expr;\n\t}\n\n\tif (field->operator == FIELD_OP_UNARY_MINUS) {\n\t\tchar *subexpr;\n\n\t\tstrcat(expr, \"-(\");\n\t\tsubexpr = expr_str(field->operands[0], ++level);\n\t\tif (!subexpr) {\n\t\t\tkfree(expr);\n\t\t\treturn NULL;\n\t\t}\n\t\tstrcat(expr, subexpr);\n\t\tstrcat(expr, \")\");\n\n\t\tkfree(subexpr);\n\n\t\treturn expr;\n\t}\n\n\texpr_field_str(field->operands[0], expr);\n\n\tswitch (field->operator) {\n\tcase FIELD_OP_MINUS:\n\t\tstrcat(expr, \"-\");\n\t\tbreak;\n\tcase FIELD_OP_PLUS:\n\t\tstrcat(expr, \"+\");\n\t\tbreak;\n\tcase FIELD_OP_DIV:\n\t\tstrcat(expr, \"/\");\n\t\tbreak;\n\tcase FIELD_OP_MULT:\n\t\tstrcat(expr, \"*\");\n\t\tbreak;\n\tdefault:\n\t\tkfree(expr);\n\t\treturn NULL;\n\t}\n\n\texpr_field_str(field->operands[1], expr);\n\n\treturn expr;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "expr",
            "\"-(\""
          ],
          "line": 1712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "MAX_FILTER_STR_VAL",
            "GFP_KERNEL"
          ],
          "line": 1700
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic char *expr_str(struct hist_field *field, unsigned int level)\n{\n\tchar *expr;\n\n\tif (level > 1)\n\t\treturn NULL;\n\n\texpr = kzalloc(MAX_FILTER_STR_VAL, GFP_KERNEL);\n\tif (!expr)\n\t\treturn NULL;\n\n\tif (!field->operands[0]) {\n\t\texpr_field_str(field, expr);\n\t\treturn expr;\n\t}\n\n\tif (field->operator == FIELD_OP_UNARY_MINUS) {\n\t\tchar *subexpr;\n\n\t\tstrcat(expr, \"-(\");\n\t\tsubexpr = expr_str(field->operands[0], ++level);\n\t\tif (!subexpr) {\n\t\t\tkfree(expr);\n\t\t\treturn NULL;\n\t\t}\n\t\tstrcat(expr, subexpr);\n\t\tstrcat(expr, \")\");\n\n\t\tkfree(subexpr);\n\n\t\treturn expr;\n\t}\n\n\texpr_field_str(field->operands[0], expr);\n\n\tswitch (field->operator) {\n\tcase FIELD_OP_MINUS:\n\t\tstrcat(expr, \"-\");\n\t\tbreak;\n\tcase FIELD_OP_PLUS:\n\t\tstrcat(expr, \"+\");\n\t\tbreak;\n\tcase FIELD_OP_DIV:\n\t\tstrcat(expr, \"/\");\n\t\tbreak;\n\tcase FIELD_OP_MULT:\n\t\tstrcat(expr, \"*\");\n\t\tbreak;\n\tdefault:\n\t\tkfree(expr);\n\t\treturn NULL;\n\t}\n\n\texpr_field_str(field->operands[1], expr);\n\n\treturn expr;\n}"
  },
  {
    "function_name": "expr_field_str",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
    "lines": "1670-1691",
    "snippet": "static void expr_field_str(struct hist_field *field, char *expr)\n{\n\tif (field->flags & HIST_FIELD_FL_VAR_REF)\n\t\tstrcat(expr, \"$\");\n\telse if (field->flags & HIST_FIELD_FL_CONST) {\n\t\tchar str[HIST_CONST_DIGITS_MAX];\n\n\t\tsnprintf(str, HIST_CONST_DIGITS_MAX, \"%llu\", field->constant);\n\t\tstrcat(expr, str);\n\t}\n\n\tstrcat(expr, hist_field_name(field, 0));\n\n\tif (field->flags && !(field->flags & HIST_FIELD_FL_VAR_REF)) {\n\t\tconst char *flags_str = get_hist_field_flags(field);\n\n\t\tif (flags_str) {\n\t\t\tstrcat(expr, \".\");\n\t\t\tstrcat(expr, flags_str);\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include \"tracing_map.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define HIST_CONST_DIGITS_MAX\t21"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "expr",
            "flags_str"
          ],
          "line": 1688
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "expr",
            "\".\""
          ],
          "line": 1687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_hist_field_flags",
          "args": [
            "field"
          ],
          "line": 1684
        },
        "resolved": true,
        "details": {
          "function_name": "get_hist_field_flags",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "1646-1668",
          "snippet": "static const char *get_hist_field_flags(struct hist_field *hist_field)\n{\n\tconst char *flags_str = NULL;\n\n\tif (hist_field->flags & HIST_FIELD_FL_HEX)\n\t\tflags_str = \"hex\";\n\telse if (hist_field->flags & HIST_FIELD_FL_SYM)\n\t\tflags_str = \"sym\";\n\telse if (hist_field->flags & HIST_FIELD_FL_SYM_OFFSET)\n\t\tflags_str = \"sym-offset\";\n\telse if (hist_field->flags & HIST_FIELD_FL_EXECNAME)\n\t\tflags_str = \"execname\";\n\telse if (hist_field->flags & HIST_FIELD_FL_SYSCALL)\n\t\tflags_str = \"syscall\";\n\telse if (hist_field->flags & HIST_FIELD_FL_LOG2)\n\t\tflags_str = \"log2\";\n\telse if (hist_field->flags & HIST_FIELD_FL_BUCKET)\n\t\tflags_str = \"buckets\";\n\telse if (hist_field->flags & HIST_FIELD_FL_TIMESTAMP_USECS)\n\t\tflags_str = \"usecs\";\n\n\treturn flags_str;\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic const char *get_hist_field_flags(struct hist_field *hist_field)\n{\n\tconst char *flags_str = NULL;\n\n\tif (hist_field->flags & HIST_FIELD_FL_HEX)\n\t\tflags_str = \"hex\";\n\telse if (hist_field->flags & HIST_FIELD_FL_SYM)\n\t\tflags_str = \"sym\";\n\telse if (hist_field->flags & HIST_FIELD_FL_SYM_OFFSET)\n\t\tflags_str = \"sym-offset\";\n\telse if (hist_field->flags & HIST_FIELD_FL_EXECNAME)\n\t\tflags_str = \"execname\";\n\telse if (hist_field->flags & HIST_FIELD_FL_SYSCALL)\n\t\tflags_str = \"syscall\";\n\telse if (hist_field->flags & HIST_FIELD_FL_LOG2)\n\t\tflags_str = \"log2\";\n\telse if (hist_field->flags & HIST_FIELD_FL_BUCKET)\n\t\tflags_str = \"buckets\";\n\telse if (hist_field->flags & HIST_FIELD_FL_TIMESTAMP_USECS)\n\t\tflags_str = \"usecs\";\n\n\treturn flags_str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "expr",
            "hist_field_name(field, 0)"
          ],
          "line": 1681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hist_field_name",
          "args": [
            "field",
            "0"
          ],
          "line": 1681
        },
        "resolved": true,
        "details": {
          "function_name": "hist_field_name",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "1280-1316",
          "snippet": "static const char *hist_field_name(struct hist_field *field,\n\t\t\t\t   unsigned int level)\n{\n\tconst char *field_name = \"\";\n\n\tif (level > 1)\n\t\treturn field_name;\n\n\tif (field->field)\n\t\tfield_name = field->field->name;\n\telse if (field->flags & HIST_FIELD_FL_LOG2 ||\n\t\t field->flags & HIST_FIELD_FL_ALIAS ||\n\t\t field->flags & HIST_FIELD_FL_BUCKET)\n\t\tfield_name = hist_field_name(field->operands[0], ++level);\n\telse if (field->flags & HIST_FIELD_FL_CPU)\n\t\tfield_name = \"common_cpu\";\n\telse if (field->flags & HIST_FIELD_FL_EXPR ||\n\t\t field->flags & HIST_FIELD_FL_VAR_REF) {\n\t\tif (field->system) {\n\t\t\tstatic char full_name[MAX_FILTER_STR_VAL];\n\n\t\t\tstrcat(full_name, field->system);\n\t\t\tstrcat(full_name, \".\");\n\t\t\tstrcat(full_name, field->event_name);\n\t\t\tstrcat(full_name, \".\");\n\t\t\tstrcat(full_name, field->name);\n\t\t\tfield_name = full_name;\n\t\t} else\n\t\t\tfield_name = field->name;\n\t} else if (field->flags & HIST_FIELD_FL_TIMESTAMP)\n\t\tfield_name = \"common_timestamp\";\n\n\tif (field_name == NULL)\n\t\tfield_name = \"\";\n\n\treturn field_name;\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic const char *hist_field_name(struct hist_field *field,\n\t\t\t\t   unsigned int level)\n{\n\tconst char *field_name = \"\";\n\n\tif (level > 1)\n\t\treturn field_name;\n\n\tif (field->field)\n\t\tfield_name = field->field->name;\n\telse if (field->flags & HIST_FIELD_FL_LOG2 ||\n\t\t field->flags & HIST_FIELD_FL_ALIAS ||\n\t\t field->flags & HIST_FIELD_FL_BUCKET)\n\t\tfield_name = hist_field_name(field->operands[0], ++level);\n\telse if (field->flags & HIST_FIELD_FL_CPU)\n\t\tfield_name = \"common_cpu\";\n\telse if (field->flags & HIST_FIELD_FL_EXPR ||\n\t\t field->flags & HIST_FIELD_FL_VAR_REF) {\n\t\tif (field->system) {\n\t\t\tstatic char full_name[MAX_FILTER_STR_VAL];\n\n\t\t\tstrcat(full_name, field->system);\n\t\t\tstrcat(full_name, \".\");\n\t\t\tstrcat(full_name, field->event_name);\n\t\t\tstrcat(full_name, \".\");\n\t\t\tstrcat(full_name, field->name);\n\t\t\tfield_name = full_name;\n\t\t} else\n\t\t\tfield_name = field->name;\n\t} else if (field->flags & HIST_FIELD_FL_TIMESTAMP)\n\t\tfield_name = \"common_timestamp\";\n\n\tif (field_name == NULL)\n\t\tfield_name = \"\";\n\n\treturn field_name;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "expr",
            "str"
          ],
          "line": 1678
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "str",
            "HIST_CONST_DIGITS_MAX",
            "\"%llu\"",
            "field->constant"
          ],
          "line": 1677
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "expr",
            "\"$\""
          ],
          "line": 1673
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\n#define HIST_CONST_DIGITS_MAX\t21\n\nstatic void expr_field_str(struct hist_field *field, char *expr)\n{\n\tif (field->flags & HIST_FIELD_FL_VAR_REF)\n\t\tstrcat(expr, \"$\");\n\telse if (field->flags & HIST_FIELD_FL_CONST) {\n\t\tchar str[HIST_CONST_DIGITS_MAX];\n\n\t\tsnprintf(str, HIST_CONST_DIGITS_MAX, \"%llu\", field->constant);\n\t\tstrcat(expr, str);\n\t}\n\n\tstrcat(expr, hist_field_name(field, 0));\n\n\tif (field->flags && !(field->flags & HIST_FIELD_FL_VAR_REF)) {\n\t\tconst char *flags_str = get_hist_field_flags(field);\n\n\t\tif (flags_str) {\n\t\t\tstrcat(expr, \".\");\n\t\t\tstrcat(expr, flags_str);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "get_hist_field_flags",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
    "lines": "1646-1668",
    "snippet": "static const char *get_hist_field_flags(struct hist_field *hist_field)\n{\n\tconst char *flags_str = NULL;\n\n\tif (hist_field->flags & HIST_FIELD_FL_HEX)\n\t\tflags_str = \"hex\";\n\telse if (hist_field->flags & HIST_FIELD_FL_SYM)\n\t\tflags_str = \"sym\";\n\telse if (hist_field->flags & HIST_FIELD_FL_SYM_OFFSET)\n\t\tflags_str = \"sym-offset\";\n\telse if (hist_field->flags & HIST_FIELD_FL_EXECNAME)\n\t\tflags_str = \"execname\";\n\telse if (hist_field->flags & HIST_FIELD_FL_SYSCALL)\n\t\tflags_str = \"syscall\";\n\telse if (hist_field->flags & HIST_FIELD_FL_LOG2)\n\t\tflags_str = \"log2\";\n\telse if (hist_field->flags & HIST_FIELD_FL_BUCKET)\n\t\tflags_str = \"buckets\";\n\telse if (hist_field->flags & HIST_FIELD_FL_TIMESTAMP_USECS)\n\t\tflags_str = \"usecs\";\n\n\treturn flags_str;\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include \"tracing_map.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic const char *get_hist_field_flags(struct hist_field *hist_field)\n{\n\tconst char *flags_str = NULL;\n\n\tif (hist_field->flags & HIST_FIELD_FL_HEX)\n\t\tflags_str = \"hex\";\n\telse if (hist_field->flags & HIST_FIELD_FL_SYM)\n\t\tflags_str = \"sym\";\n\telse if (hist_field->flags & HIST_FIELD_FL_SYM_OFFSET)\n\t\tflags_str = \"sym-offset\";\n\telse if (hist_field->flags & HIST_FIELD_FL_EXECNAME)\n\t\tflags_str = \"execname\";\n\telse if (hist_field->flags & HIST_FIELD_FL_SYSCALL)\n\t\tflags_str = \"syscall\";\n\telse if (hist_field->flags & HIST_FIELD_FL_LOG2)\n\t\tflags_str = \"log2\";\n\telse if (hist_field->flags & HIST_FIELD_FL_BUCKET)\n\t\tflags_str = \"buckets\";\n\telse if (hist_field->flags & HIST_FIELD_FL_TIMESTAMP_USECS)\n\t\tflags_str = \"usecs\";\n\n\treturn flags_str;\n}"
  },
  {
    "function_name": "hist_trigger_elt_data_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
    "lines": "1632-1638",
    "snippet": "static void hist_trigger_elt_data_init(struct tracing_map_elt *elt)\n{\n\tstruct hist_elt_data *elt_data = elt->private_data;\n\n\tif (elt_data->comm)\n\t\tsave_comm(elt_data->comm, current);\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include \"tracing_map.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "save_comm",
          "args": [
            "elt_data->comm",
            "current"
          ],
          "line": 1637
        },
        "resolved": true,
        "details": {
          "function_name": "save_comm",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "1541-1554",
          "snippet": "static inline void save_comm(char *comm, struct task_struct *task)\n{\n\tif (!task->pid) {\n\t\tstrcpy(comm, \"<idle>\");\n\t\treturn;\n\t}\n\n\tif (WARN_ON_ONCE(task->pid < 0)) {\n\t\tstrcpy(comm, \"<XXX>\");\n\t\treturn;\n\t}\n\n\tstrncpy(comm, task->comm, TASK_COMM_LEN);\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic inline void save_comm(char *comm, struct task_struct *task)\n{\n\tif (!task->pid) {\n\t\tstrcpy(comm, \"<idle>\");\n\t\treturn;\n\t}\n\n\tif (WARN_ON_ONCE(task->pid < 0)) {\n\t\tstrcpy(comm, \"<XXX>\");\n\t\treturn;\n\t}\n\n\tstrncpy(comm, task->comm, TASK_COMM_LEN);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void hist_trigger_elt_data_init(struct tracing_map_elt *elt)\n{\n\tstruct hist_elt_data *elt_data = elt->private_data;\n\n\tif (elt_data->comm)\n\t\tsave_comm(elt_data->comm, current);\n}"
  },
  {
    "function_name": "hist_trigger_elt_data_alloc",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
    "lines": "1576-1630",
    "snippet": "static int hist_trigger_elt_data_alloc(struct tracing_map_elt *elt)\n{\n\tstruct hist_trigger_data *hist_data = elt->map->private_data;\n\tunsigned int size = TASK_COMM_LEN;\n\tstruct hist_elt_data *elt_data;\n\tstruct hist_field *hist_field;\n\tunsigned int i, n_str;\n\n\telt_data = kzalloc(sizeof(*elt_data), GFP_KERNEL);\n\tif (!elt_data)\n\t\treturn -ENOMEM;\n\n\tfor_each_hist_field(i, hist_data) {\n\t\thist_field = hist_data->fields[i];\n\n\t\tif (hist_field->flags & HIST_FIELD_FL_EXECNAME) {\n\t\t\telt_data->comm = kzalloc(size, GFP_KERNEL);\n\t\t\tif (!elt_data->comm) {\n\t\t\t\tkfree(elt_data);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tn_str = hist_data->n_field_var_str + hist_data->n_save_var_str +\n\t\thist_data->n_var_str;\n\tif (n_str > SYNTH_FIELDS_MAX) {\n\t\thist_elt_data_free(elt_data);\n\t\treturn -EINVAL;\n\t}\n\n\tBUILD_BUG_ON(STR_VAR_LEN_MAX & (sizeof(u64) - 1));\n\n\tsize = STR_VAR_LEN_MAX;\n\n\telt_data->field_var_str = kcalloc(n_str, sizeof(char *), GFP_KERNEL);\n\tif (!elt_data->field_var_str) {\n\t\thist_elt_data_free(elt_data);\n\t\treturn -EINVAL;\n\t}\n\telt_data->n_field_var_str = n_str;\n\n\tfor (i = 0; i < n_str; i++) {\n\t\telt_data->field_var_str[i] = kzalloc(size, GFP_KERNEL);\n\t\tif (!elt_data->field_var_str[i]) {\n\t\t\thist_elt_data_free(elt_data);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\telt->private_data = elt_data;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include \"tracing_map.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hist_elt_data_free",
          "args": [
            "elt_data"
          ],
          "line": 1622
        },
        "resolved": true,
        "details": {
          "function_name": "hist_elt_data_free",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "1556-1567",
          "snippet": "static void hist_elt_data_free(struct hist_elt_data *elt_data)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < elt_data->n_field_var_str; i++)\n\t\tkfree(elt_data->field_var_str[i]);\n\n\tkfree(elt_data->field_var_str);\n\n\tkfree(elt_data->comm);\n\tkfree(elt_data);\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void hist_elt_data_free(struct hist_elt_data *elt_data)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < elt_data->n_field_var_str; i++)\n\t\tkfree(elt_data->field_var_str[i]);\n\n\tkfree(elt_data->field_var_str);\n\n\tkfree(elt_data->comm);\n\tkfree(elt_data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "size",
            "GFP_KERNEL"
          ],
          "line": 1620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kcalloc",
          "args": [
            "n_str",
            "sizeof(char *)",
            "GFP_KERNEL"
          ],
          "line": 1612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "STR_VAR_LEN_MAX & (sizeof(u64) - 1)"
          ],
          "line": 1608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "elt_data"
          ],
          "line": 1594
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "size",
            "GFP_KERNEL"
          ],
          "line": 1592
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_hist_field",
          "args": [
            "i",
            "hist_data"
          ],
          "line": 1588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*elt_data)",
            "GFP_KERNEL"
          ],
          "line": 1584
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int hist_trigger_elt_data_alloc(struct tracing_map_elt *elt)\n{\n\tstruct hist_trigger_data *hist_data = elt->map->private_data;\n\tunsigned int size = TASK_COMM_LEN;\n\tstruct hist_elt_data *elt_data;\n\tstruct hist_field *hist_field;\n\tunsigned int i, n_str;\n\n\telt_data = kzalloc(sizeof(*elt_data), GFP_KERNEL);\n\tif (!elt_data)\n\t\treturn -ENOMEM;\n\n\tfor_each_hist_field(i, hist_data) {\n\t\thist_field = hist_data->fields[i];\n\n\t\tif (hist_field->flags & HIST_FIELD_FL_EXECNAME) {\n\t\t\telt_data->comm = kzalloc(size, GFP_KERNEL);\n\t\t\tif (!elt_data->comm) {\n\t\t\t\tkfree(elt_data);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tn_str = hist_data->n_field_var_str + hist_data->n_save_var_str +\n\t\thist_data->n_var_str;\n\tif (n_str > SYNTH_FIELDS_MAX) {\n\t\thist_elt_data_free(elt_data);\n\t\treturn -EINVAL;\n\t}\n\n\tBUILD_BUG_ON(STR_VAR_LEN_MAX & (sizeof(u64) - 1));\n\n\tsize = STR_VAR_LEN_MAX;\n\n\telt_data->field_var_str = kcalloc(n_str, sizeof(char *), GFP_KERNEL);\n\tif (!elt_data->field_var_str) {\n\t\thist_elt_data_free(elt_data);\n\t\treturn -EINVAL;\n\t}\n\telt_data->n_field_var_str = n_str;\n\n\tfor (i = 0; i < n_str; i++) {\n\t\telt_data->field_var_str[i] = kzalloc(size, GFP_KERNEL);\n\t\tif (!elt_data->field_var_str[i]) {\n\t\t\thist_elt_data_free(elt_data);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\telt->private_data = elt_data;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "hist_trigger_elt_data_free",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
    "lines": "1569-1574",
    "snippet": "static void hist_trigger_elt_data_free(struct tracing_map_elt *elt)\n{\n\tstruct hist_elt_data *elt_data = elt->private_data;\n\n\thist_elt_data_free(elt_data);\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include \"tracing_map.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hist_elt_data_free",
          "args": [
            "elt_data"
          ],
          "line": 1573
        },
        "resolved": true,
        "details": {
          "function_name": "hist_elt_data_free",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "1556-1567",
          "snippet": "static void hist_elt_data_free(struct hist_elt_data *elt_data)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < elt_data->n_field_var_str; i++)\n\t\tkfree(elt_data->field_var_str[i]);\n\n\tkfree(elt_data->field_var_str);\n\n\tkfree(elt_data->comm);\n\tkfree(elt_data);\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void hist_elt_data_free(struct hist_elt_data *elt_data)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < elt_data->n_field_var_str; i++)\n\t\tkfree(elt_data->field_var_str[i]);\n\n\tkfree(elt_data->field_var_str);\n\n\tkfree(elt_data->comm);\n\tkfree(elt_data);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void hist_trigger_elt_data_free(struct tracing_map_elt *elt)\n{\n\tstruct hist_elt_data *elt_data = elt->private_data;\n\n\thist_elt_data_free(elt_data);\n}"
  },
  {
    "function_name": "hist_elt_data_free",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
    "lines": "1556-1567",
    "snippet": "static void hist_elt_data_free(struct hist_elt_data *elt_data)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < elt_data->n_field_var_str; i++)\n\t\tkfree(elt_data->field_var_str[i]);\n\n\tkfree(elt_data->field_var_str);\n\n\tkfree(elt_data->comm);\n\tkfree(elt_data);\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include \"tracing_map.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "elt_data"
          ],
          "line": 1566
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void hist_elt_data_free(struct hist_elt_data *elt_data)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < elt_data->n_field_var_str; i++)\n\t\tkfree(elt_data->field_var_str[i]);\n\n\tkfree(elt_data->field_var_str);\n\n\tkfree(elt_data->comm);\n\tkfree(elt_data);\n}"
  },
  {
    "function_name": "save_comm",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
    "lines": "1541-1554",
    "snippet": "static inline void save_comm(char *comm, struct task_struct *task)\n{\n\tif (!task->pid) {\n\t\tstrcpy(comm, \"<idle>\");\n\t\treturn;\n\t}\n\n\tif (WARN_ON_ONCE(task->pid < 0)) {\n\t\tstrcpy(comm, \"<XXX>\");\n\t\treturn;\n\t}\n\n\tstrncpy(comm, task->comm, TASK_COMM_LEN);\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include \"tracing_map.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "comm",
            "task->comm",
            "TASK_COMM_LEN"
          ],
          "line": 1553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "comm",
            "\"<XXX>\""
          ],
          "line": 1549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "task->pid < 0"
          ],
          "line": 1548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "comm",
            "\"<idle>\""
          ],
          "line": 1544
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic inline void save_comm(char *comm, struct task_struct *task)\n{\n\tif (!task->pid) {\n\t\tstrcpy(comm, \"<idle>\");\n\t\treturn;\n\t}\n\n\tif (WARN_ON_ONCE(task->pid < 0)) {\n\t\tstrcpy(comm, \"<XXX>\");\n\t\treturn;\n\t}\n\n\tstrncpy(comm, task->comm, TASK_COMM_LEN);\n}"
  },
  {
    "function_name": "parse_hist_trigger_attrs",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
    "lines": "1483-1539",
    "snippet": "static struct hist_trigger_attrs *\nparse_hist_trigger_attrs(struct trace_array *tr, char *trigger_str)\n{\n\tstruct hist_trigger_attrs *attrs;\n\tint ret = 0;\n\n\tattrs = kzalloc(sizeof(*attrs), GFP_KERNEL);\n\tif (!attrs)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\twhile (trigger_str) {\n\t\tchar *str = strsep(&trigger_str, \":\");\n\t\tchar *rhs;\n\n\t\trhs = strchr(str, '=');\n\t\tif (rhs) {\n\t\t\tif (!strlen(++rhs)) {\n\t\t\t\tret = -EINVAL;\n\t\t\t\thist_err(tr, HIST_ERR_EMPTY_ASSIGNMENT, errpos(str));\n\t\t\t\tgoto free;\n\t\t\t}\n\t\t\tret = parse_assignment(tr, str, attrs);\n\t\t\tif (ret)\n\t\t\t\tgoto free;\n\t\t} else if (strcmp(str, \"pause\") == 0)\n\t\t\tattrs->pause = true;\n\t\telse if ((strcmp(str, \"cont\") == 0) ||\n\t\t\t (strcmp(str, \"continue\") == 0))\n\t\t\tattrs->cont = true;\n\t\telse if (strcmp(str, \"clear\") == 0)\n\t\t\tattrs->clear = true;\n\t\telse {\n\t\t\tret = parse_action(str, attrs);\n\t\t\tif (ret)\n\t\t\t\tgoto free;\n\t\t}\n\t}\n\n\tif (!attrs->keys_str) {\n\t\tret = -EINVAL;\n\t\tgoto free;\n\t}\n\n\tif (!attrs->clock) {\n\t\tattrs->clock = kstrdup(\"global\", GFP_KERNEL);\n\t\tif (!attrs->clock) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto free;\n\t\t}\n\t}\n\n\treturn attrs;\n free:\n\tdestroy_hist_trigger_attrs(attrs);\n\n\treturn ERR_PTR(ret);\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include \"tracing_map.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "ret"
          ],
          "line": 1538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "destroy_hist_trigger_attrs",
          "args": [
            "attrs"
          ],
          "line": 1536
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_hist_trigger_attrs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "1371-1390",
          "snippet": "static void destroy_hist_trigger_attrs(struct hist_trigger_attrs *attrs)\n{\n\tunsigned int i;\n\n\tif (!attrs)\n\t\treturn;\n\n\tfor (i = 0; i < attrs->n_assignments; i++)\n\t\tkfree(attrs->assignment_str[i]);\n\n\tfor (i = 0; i < attrs->n_actions; i++)\n\t\tkfree(attrs->action_str[i]);\n\n\tkfree(attrs->name);\n\tkfree(attrs->sort_key_str);\n\tkfree(attrs->keys_str);\n\tkfree(attrs->vals_str);\n\tkfree(attrs->clock);\n\tkfree(attrs);\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void destroy_hist_trigger_attrs(struct hist_trigger_attrs *attrs)\n{\n\tunsigned int i;\n\n\tif (!attrs)\n\t\treturn;\n\n\tfor (i = 0; i < attrs->n_assignments; i++)\n\t\tkfree(attrs->assignment_str[i]);\n\n\tfor (i = 0; i < attrs->n_actions; i++)\n\t\tkfree(attrs->action_str[i]);\n\n\tkfree(attrs->name);\n\tkfree(attrs->sort_key_str);\n\tkfree(attrs->keys_str);\n\tkfree(attrs->vals_str);\n\tkfree(attrs->clock);\n\tkfree(attrs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "\"global\"",
            "GFP_KERNEL"
          ],
          "line": 1527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parse_action",
          "args": [
            "str",
            "attrs"
          ],
          "line": 1515
        },
        "resolved": true,
        "details": {
          "function_name": "parse_action",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "1392-1411",
          "snippet": "static int parse_action(char *str, struct hist_trigger_attrs *attrs)\n{\n\tint ret = -EINVAL;\n\n\tif (attrs->n_actions >= HIST_ACTIONS_MAX)\n\t\treturn ret;\n\n\tif ((str_has_prefix(str, \"onmatch(\")) ||\n\t    (str_has_prefix(str, \"onmax(\")) ||\n\t    (str_has_prefix(str, \"onchange(\"))) {\n\t\tattrs->action_str[attrs->n_actions] = kstrdup(str, GFP_KERNEL);\n\t\tif (!attrs->action_str[attrs->n_actions]) {\n\t\t\tret = -ENOMEM;\n\t\t\treturn ret;\n\t\t}\n\t\tattrs->n_actions++;\n\t\tret = 0;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define HIST_ACTIONS_MAX\t8"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\n#define HIST_ACTIONS_MAX\t8\n\nstatic int parse_action(char *str, struct hist_trigger_attrs *attrs)\n{\n\tint ret = -EINVAL;\n\n\tif (attrs->n_actions >= HIST_ACTIONS_MAX)\n\t\treturn ret;\n\n\tif ((str_has_prefix(str, \"onmatch(\")) ||\n\t    (str_has_prefix(str, \"onmax(\")) ||\n\t    (str_has_prefix(str, \"onchange(\"))) {\n\t\tattrs->action_str[attrs->n_actions] = kstrdup(str, GFP_KERNEL);\n\t\tif (!attrs->action_str[attrs->n_actions]) {\n\t\t\tret = -ENOMEM;\n\t\t\treturn ret;\n\t\t}\n\t\tattrs->n_actions++;\n\t\tret = 0;\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "str",
            "\"clear\""
          ],
          "line": 1512
        },
        "resolved": true,
        "details": {
          "function_name": "sym_strcmp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/report.c",
          "lines": "356-365",
          "snippet": "static int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}",
          "includes": [
            "#include \"encoding.h\"",
            "#include \"kcsan.h\"",
            "#include <linux/stacktrace.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/delay.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"encoding.h\"\n#include \"kcsan.h\"\n#include <linux/stacktrace.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/lockdep.h>\n#include <linux/kernel.h>\n#include <linux/kallsyms.h>\n#include <linux/jiffies.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n\nstatic int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}"
        }
      },
      {
        "call_info": {
          "callee": "parse_assignment",
          "args": [
            "tr",
            "str",
            "attrs"
          ],
          "line": 1504
        },
        "resolved": true,
        "details": {
          "function_name": "parse_assignment",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "1413-1481",
          "snippet": "static int parse_assignment(struct trace_array *tr,\n\t\t\t    char *str, struct hist_trigger_attrs *attrs)\n{\n\tint len, ret = 0;\n\n\tif ((len = str_has_prefix(str, \"key=\")) ||\n\t    (len = str_has_prefix(str, \"keys=\"))) {\n\t\tattrs->keys_str = kstrdup(str + len, GFP_KERNEL);\n\t\tif (!attrs->keys_str) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t} else if ((len = str_has_prefix(str, \"val=\")) ||\n\t\t   (len = str_has_prefix(str, \"vals=\")) ||\n\t\t   (len = str_has_prefix(str, \"values=\"))) {\n\t\tattrs->vals_str = kstrdup(str + len, GFP_KERNEL);\n\t\tif (!attrs->vals_str) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t} else if ((len = str_has_prefix(str, \"sort=\"))) {\n\t\tattrs->sort_key_str = kstrdup(str + len, GFP_KERNEL);\n\t\tif (!attrs->sort_key_str) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t} else if (str_has_prefix(str, \"name=\")) {\n\t\tattrs->name = kstrdup(str, GFP_KERNEL);\n\t\tif (!attrs->name) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t} else if ((len = str_has_prefix(str, \"clock=\"))) {\n\t\tstr += len;\n\n\t\tstr = strstrip(str);\n\t\tattrs->clock = kstrdup(str, GFP_KERNEL);\n\t\tif (!attrs->clock) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t} else if ((len = str_has_prefix(str, \"size=\"))) {\n\t\tint map_bits = parse_map_size(str + len);\n\n\t\tif (map_bits < 0) {\n\t\t\tret = map_bits;\n\t\t\tgoto out;\n\t\t}\n\t\tattrs->map_bits = map_bits;\n\t} else {\n\t\tchar *assignment;\n\n\t\tif (attrs->n_assignments == TRACING_MAP_VARS_MAX) {\n\t\t\thist_err(tr, HIST_ERR_TOO_MANY_VARS, errpos(str));\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tassignment = kstrdup(str, GFP_KERNEL);\n\t\tif (!assignment) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\tattrs->assignment_str[attrs->n_assignments++] = assignment;\n\t}\n out:\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int parse_assignment(struct trace_array *tr,\n\t\t\t    char *str, struct hist_trigger_attrs *attrs)\n{\n\tint len, ret = 0;\n\n\tif ((len = str_has_prefix(str, \"key=\")) ||\n\t    (len = str_has_prefix(str, \"keys=\"))) {\n\t\tattrs->keys_str = kstrdup(str + len, GFP_KERNEL);\n\t\tif (!attrs->keys_str) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t} else if ((len = str_has_prefix(str, \"val=\")) ||\n\t\t   (len = str_has_prefix(str, \"vals=\")) ||\n\t\t   (len = str_has_prefix(str, \"values=\"))) {\n\t\tattrs->vals_str = kstrdup(str + len, GFP_KERNEL);\n\t\tif (!attrs->vals_str) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t} else if ((len = str_has_prefix(str, \"sort=\"))) {\n\t\tattrs->sort_key_str = kstrdup(str + len, GFP_KERNEL);\n\t\tif (!attrs->sort_key_str) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t} else if (str_has_prefix(str, \"name=\")) {\n\t\tattrs->name = kstrdup(str, GFP_KERNEL);\n\t\tif (!attrs->name) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t} else if ((len = str_has_prefix(str, \"clock=\"))) {\n\t\tstr += len;\n\n\t\tstr = strstrip(str);\n\t\tattrs->clock = kstrdup(str, GFP_KERNEL);\n\t\tif (!attrs->clock) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t} else if ((len = str_has_prefix(str, \"size=\"))) {\n\t\tint map_bits = parse_map_size(str + len);\n\n\t\tif (map_bits < 0) {\n\t\t\tret = map_bits;\n\t\t\tgoto out;\n\t\t}\n\t\tattrs->map_bits = map_bits;\n\t} else {\n\t\tchar *assignment;\n\n\t\tif (attrs->n_assignments == TRACING_MAP_VARS_MAX) {\n\t\t\thist_err(tr, HIST_ERR_TOO_MANY_VARS, errpos(str));\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tassignment = kstrdup(str, GFP_KERNEL);\n\t\tif (!assignment) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\tattrs->assignment_str[attrs->n_assignments++] = assignment;\n\t}\n out:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hist_err",
          "args": [
            "tr",
            "HIST_ERR_EMPTY_ASSIGNMENT",
            "errpos(str)"
          ],
          "line": 1501
        },
        "resolved": true,
        "details": {
          "function_name": "hist_err",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "763-767",
          "snippet": "static void hist_err(struct trace_array *tr, u8 err_type, u8 err_pos)\n{\n\ttracing_log_err(tr, last_cmd_loc, last_cmd, err_text,\n\t\t\terr_type, err_pos);\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *err_text[] = { ERRORS };",
            "static char last_cmd[MAX_FILTER_STR_VAL];",
            "static char last_cmd_loc[MAX_FILTER_STR_VAL];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic const char *err_text[] = { ERRORS };\nstatic char last_cmd[MAX_FILTER_STR_VAL];\nstatic char last_cmd_loc[MAX_FILTER_STR_VAL];\n\nstatic void hist_err(struct trace_array *tr, u8 err_type, u8 err_pos)\n{\n\ttracing_log_err(tr, last_cmd_loc, last_cmd, err_text,\n\t\t\terr_type, err_pos);\n}"
        }
      },
      {
        "call_info": {
          "callee": "errpos",
          "args": [
            "str"
          ],
          "line": 1501
        },
        "resolved": true,
        "details": {
          "function_name": "errpos",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "733-736",
          "snippet": "static int errpos(char *str)\n{\n\treturn err_pos(last_cmd, str);\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char last_cmd[MAX_FILTER_STR_VAL];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic char last_cmd[MAX_FILTER_STR_VAL];\n\nstatic int errpos(char *str)\n{\n\treturn err_pos(last_cmd, str);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "++rhs"
          ],
          "line": 1499
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_eprobe.c",
          "lines": "384-401",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/ftrace.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "str",
            "'='"
          ],
          "line": 1497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strsep",
          "args": [
            "&trigger_str",
            "\":\""
          ],
          "line": 1494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 1491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*attrs)",
            "GFP_KERNEL"
          ],
          "line": 1489
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct hist_trigger_attrs *\nparse_hist_trigger_attrs(struct trace_array *tr, char *trigger_str)\n{\n\tstruct hist_trigger_attrs *attrs;\n\tint ret = 0;\n\n\tattrs = kzalloc(sizeof(*attrs), GFP_KERNEL);\n\tif (!attrs)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\twhile (trigger_str) {\n\t\tchar *str = strsep(&trigger_str, \":\");\n\t\tchar *rhs;\n\n\t\trhs = strchr(str, '=');\n\t\tif (rhs) {\n\t\t\tif (!strlen(++rhs)) {\n\t\t\t\tret = -EINVAL;\n\t\t\t\thist_err(tr, HIST_ERR_EMPTY_ASSIGNMENT, errpos(str));\n\t\t\t\tgoto free;\n\t\t\t}\n\t\t\tret = parse_assignment(tr, str, attrs);\n\t\t\tif (ret)\n\t\t\t\tgoto free;\n\t\t} else if (strcmp(str, \"pause\") == 0)\n\t\t\tattrs->pause = true;\n\t\telse if ((strcmp(str, \"cont\") == 0) ||\n\t\t\t (strcmp(str, \"continue\") == 0))\n\t\t\tattrs->cont = true;\n\t\telse if (strcmp(str, \"clear\") == 0)\n\t\t\tattrs->clear = true;\n\t\telse {\n\t\t\tret = parse_action(str, attrs);\n\t\t\tif (ret)\n\t\t\t\tgoto free;\n\t\t}\n\t}\n\n\tif (!attrs->keys_str) {\n\t\tret = -EINVAL;\n\t\tgoto free;\n\t}\n\n\tif (!attrs->clock) {\n\t\tattrs->clock = kstrdup(\"global\", GFP_KERNEL);\n\t\tif (!attrs->clock) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto free;\n\t\t}\n\t}\n\n\treturn attrs;\n free:\n\tdestroy_hist_trigger_attrs(attrs);\n\n\treturn ERR_PTR(ret);\n}"
  },
  {
    "function_name": "parse_assignment",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
    "lines": "1413-1481",
    "snippet": "static int parse_assignment(struct trace_array *tr,\n\t\t\t    char *str, struct hist_trigger_attrs *attrs)\n{\n\tint len, ret = 0;\n\n\tif ((len = str_has_prefix(str, \"key=\")) ||\n\t    (len = str_has_prefix(str, \"keys=\"))) {\n\t\tattrs->keys_str = kstrdup(str + len, GFP_KERNEL);\n\t\tif (!attrs->keys_str) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t} else if ((len = str_has_prefix(str, \"val=\")) ||\n\t\t   (len = str_has_prefix(str, \"vals=\")) ||\n\t\t   (len = str_has_prefix(str, \"values=\"))) {\n\t\tattrs->vals_str = kstrdup(str + len, GFP_KERNEL);\n\t\tif (!attrs->vals_str) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t} else if ((len = str_has_prefix(str, \"sort=\"))) {\n\t\tattrs->sort_key_str = kstrdup(str + len, GFP_KERNEL);\n\t\tif (!attrs->sort_key_str) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t} else if (str_has_prefix(str, \"name=\")) {\n\t\tattrs->name = kstrdup(str, GFP_KERNEL);\n\t\tif (!attrs->name) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t} else if ((len = str_has_prefix(str, \"clock=\"))) {\n\t\tstr += len;\n\n\t\tstr = strstrip(str);\n\t\tattrs->clock = kstrdup(str, GFP_KERNEL);\n\t\tif (!attrs->clock) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t} else if ((len = str_has_prefix(str, \"size=\"))) {\n\t\tint map_bits = parse_map_size(str + len);\n\n\t\tif (map_bits < 0) {\n\t\t\tret = map_bits;\n\t\t\tgoto out;\n\t\t}\n\t\tattrs->map_bits = map_bits;\n\t} else {\n\t\tchar *assignment;\n\n\t\tif (attrs->n_assignments == TRACING_MAP_VARS_MAX) {\n\t\t\thist_err(tr, HIST_ERR_TOO_MANY_VARS, errpos(str));\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tassignment = kstrdup(str, GFP_KERNEL);\n\t\tif (!assignment) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\tattrs->assignment_str[attrs->n_assignments++] = assignment;\n\t}\n out:\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include \"tracing_map.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "str",
            "GFP_KERNEL"
          ],
          "line": 1471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hist_err",
          "args": [
            "tr",
            "HIST_ERR_TOO_MANY_VARS",
            "errpos(str)"
          ],
          "line": 1466
        },
        "resolved": true,
        "details": {
          "function_name": "hist_err",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "763-767",
          "snippet": "static void hist_err(struct trace_array *tr, u8 err_type, u8 err_pos)\n{\n\ttracing_log_err(tr, last_cmd_loc, last_cmd, err_text,\n\t\t\terr_type, err_pos);\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *err_text[] = { ERRORS };",
            "static char last_cmd[MAX_FILTER_STR_VAL];",
            "static char last_cmd_loc[MAX_FILTER_STR_VAL];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic const char *err_text[] = { ERRORS };\nstatic char last_cmd[MAX_FILTER_STR_VAL];\nstatic char last_cmd_loc[MAX_FILTER_STR_VAL];\n\nstatic void hist_err(struct trace_array *tr, u8 err_type, u8 err_pos)\n{\n\ttracing_log_err(tr, last_cmd_loc, last_cmd, err_text,\n\t\t\terr_type, err_pos);\n}"
        }
      },
      {
        "call_info": {
          "callee": "errpos",
          "args": [
            "str"
          ],
          "line": 1466
        },
        "resolved": true,
        "details": {
          "function_name": "errpos",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "733-736",
          "snippet": "static int errpos(char *str)\n{\n\treturn err_pos(last_cmd, str);\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char last_cmd[MAX_FILTER_STR_VAL];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic char last_cmd[MAX_FILTER_STR_VAL];\n\nstatic int errpos(char *str)\n{\n\treturn err_pos(last_cmd, str);\n}"
        }
      },
      {
        "call_info": {
          "callee": "parse_map_size",
          "args": [
            "str + len"
          ],
          "line": 1455
        },
        "resolved": true,
        "details": {
          "function_name": "parse_map_size",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "1352-1369",
          "snippet": "static int parse_map_size(char *str)\n{\n\tunsigned long size, map_bits;\n\tint ret;\n\n\tret = kstrtoul(str, 0, &size);\n\tif (ret)\n\t\tgoto out;\n\n\tmap_bits = ilog2(roundup_pow_of_two(size));\n\tif (map_bits < TRACING_MAP_BITS_MIN ||\n\t    map_bits > TRACING_MAP_BITS_MAX)\n\t\tret = -EINVAL;\n\telse\n\t\tret = map_bits;\n out:\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int parse_map_size(char *str)\n{\n\tunsigned long size, map_bits;\n\tint ret;\n\n\tret = kstrtoul(str, 0, &size);\n\tif (ret)\n\t\tgoto out;\n\n\tmap_bits = ilog2(roundup_pow_of_two(size));\n\tif (map_bits < TRACING_MAP_BITS_MIN ||\n\t    map_bits > TRACING_MAP_BITS_MAX)\n\t\tret = -EINVAL;\n\telse\n\t\tret = map_bits;\n out:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "str_has_prefix",
          "args": [
            "str",
            "\"size=\""
          ],
          "line": 1454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "str",
            "GFP_KERNEL"
          ],
          "line": 1449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstrip",
          "args": [
            "str"
          ],
          "line": 1448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "str_has_prefix",
          "args": [
            "str",
            "\"clock=\""
          ],
          "line": 1445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "str",
            "GFP_KERNEL"
          ],
          "line": 1440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "str_has_prefix",
          "args": [
            "str",
            "\"name=\""
          ],
          "line": 1439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "str + len",
            "GFP_KERNEL"
          ],
          "line": 1434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "str_has_prefix",
          "args": [
            "str",
            "\"sort=\""
          ],
          "line": 1433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "str + len",
            "GFP_KERNEL"
          ],
          "line": 1428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "str_has_prefix",
          "args": [
            "str",
            "\"values=\""
          ],
          "line": 1427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "str_has_prefix",
          "args": [
            "str",
            "\"vals=\""
          ],
          "line": 1426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "str_has_prefix",
          "args": [
            "str",
            "\"val=\""
          ],
          "line": 1425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "str + len",
            "GFP_KERNEL"
          ],
          "line": 1420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "str_has_prefix",
          "args": [
            "str",
            "\"keys=\""
          ],
          "line": 1419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "str_has_prefix",
          "args": [
            "str",
            "\"key=\""
          ],
          "line": 1418
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int parse_assignment(struct trace_array *tr,\n\t\t\t    char *str, struct hist_trigger_attrs *attrs)\n{\n\tint len, ret = 0;\n\n\tif ((len = str_has_prefix(str, \"key=\")) ||\n\t    (len = str_has_prefix(str, \"keys=\"))) {\n\t\tattrs->keys_str = kstrdup(str + len, GFP_KERNEL);\n\t\tif (!attrs->keys_str) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t} else if ((len = str_has_prefix(str, \"val=\")) ||\n\t\t   (len = str_has_prefix(str, \"vals=\")) ||\n\t\t   (len = str_has_prefix(str, \"values=\"))) {\n\t\tattrs->vals_str = kstrdup(str + len, GFP_KERNEL);\n\t\tif (!attrs->vals_str) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t} else if ((len = str_has_prefix(str, \"sort=\"))) {\n\t\tattrs->sort_key_str = kstrdup(str + len, GFP_KERNEL);\n\t\tif (!attrs->sort_key_str) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t} else if (str_has_prefix(str, \"name=\")) {\n\t\tattrs->name = kstrdup(str, GFP_KERNEL);\n\t\tif (!attrs->name) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t} else if ((len = str_has_prefix(str, \"clock=\"))) {\n\t\tstr += len;\n\n\t\tstr = strstrip(str);\n\t\tattrs->clock = kstrdup(str, GFP_KERNEL);\n\t\tif (!attrs->clock) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t} else if ((len = str_has_prefix(str, \"size=\"))) {\n\t\tint map_bits = parse_map_size(str + len);\n\n\t\tif (map_bits < 0) {\n\t\t\tret = map_bits;\n\t\t\tgoto out;\n\t\t}\n\t\tattrs->map_bits = map_bits;\n\t} else {\n\t\tchar *assignment;\n\n\t\tif (attrs->n_assignments == TRACING_MAP_VARS_MAX) {\n\t\t\thist_err(tr, HIST_ERR_TOO_MANY_VARS, errpos(str));\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tassignment = kstrdup(str, GFP_KERNEL);\n\t\tif (!assignment) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\tattrs->assignment_str[attrs->n_assignments++] = assignment;\n\t}\n out:\n\treturn ret;\n}"
  },
  {
    "function_name": "parse_action",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
    "lines": "1392-1411",
    "snippet": "static int parse_action(char *str, struct hist_trigger_attrs *attrs)\n{\n\tint ret = -EINVAL;\n\n\tif (attrs->n_actions >= HIST_ACTIONS_MAX)\n\t\treturn ret;\n\n\tif ((str_has_prefix(str, \"onmatch(\")) ||\n\t    (str_has_prefix(str, \"onmax(\")) ||\n\t    (str_has_prefix(str, \"onchange(\"))) {\n\t\tattrs->action_str[attrs->n_actions] = kstrdup(str, GFP_KERNEL);\n\t\tif (!attrs->action_str[attrs->n_actions]) {\n\t\t\tret = -ENOMEM;\n\t\t\treturn ret;\n\t\t}\n\t\tattrs->n_actions++;\n\t\tret = 0;\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include \"tracing_map.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define HIST_ACTIONS_MAX\t8"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "str",
            "GFP_KERNEL"
          ],
          "line": 1402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "str_has_prefix",
          "args": [
            "str",
            "\"onchange(\""
          ],
          "line": 1401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "str_has_prefix",
          "args": [
            "str",
            "\"onmax(\""
          ],
          "line": 1400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "str_has_prefix",
          "args": [
            "str",
            "\"onmatch(\""
          ],
          "line": 1399
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\n#define HIST_ACTIONS_MAX\t8\n\nstatic int parse_action(char *str, struct hist_trigger_attrs *attrs)\n{\n\tint ret = -EINVAL;\n\n\tif (attrs->n_actions >= HIST_ACTIONS_MAX)\n\t\treturn ret;\n\n\tif ((str_has_prefix(str, \"onmatch(\")) ||\n\t    (str_has_prefix(str, \"onmax(\")) ||\n\t    (str_has_prefix(str, \"onchange(\"))) {\n\t\tattrs->action_str[attrs->n_actions] = kstrdup(str, GFP_KERNEL);\n\t\tif (!attrs->action_str[attrs->n_actions]) {\n\t\t\tret = -ENOMEM;\n\t\t\treturn ret;\n\t\t}\n\t\tattrs->n_actions++;\n\t\tret = 0;\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "destroy_hist_trigger_attrs",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
    "lines": "1371-1390",
    "snippet": "static void destroy_hist_trigger_attrs(struct hist_trigger_attrs *attrs)\n{\n\tunsigned int i;\n\n\tif (!attrs)\n\t\treturn;\n\n\tfor (i = 0; i < attrs->n_assignments; i++)\n\t\tkfree(attrs->assignment_str[i]);\n\n\tfor (i = 0; i < attrs->n_actions; i++)\n\t\tkfree(attrs->action_str[i]);\n\n\tkfree(attrs->name);\n\tkfree(attrs->sort_key_str);\n\tkfree(attrs->keys_str);\n\tkfree(attrs->vals_str);\n\tkfree(attrs->clock);\n\tkfree(attrs);\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include \"tracing_map.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "attrs"
          ],
          "line": 1389
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void destroy_hist_trigger_attrs(struct hist_trigger_attrs *attrs)\n{\n\tunsigned int i;\n\n\tif (!attrs)\n\t\treturn;\n\n\tfor (i = 0; i < attrs->n_assignments; i++)\n\t\tkfree(attrs->assignment_str[i]);\n\n\tfor (i = 0; i < attrs->n_actions; i++)\n\t\tkfree(attrs->action_str[i]);\n\n\tkfree(attrs->name);\n\tkfree(attrs->sort_key_str);\n\tkfree(attrs->keys_str);\n\tkfree(attrs->vals_str);\n\tkfree(attrs->clock);\n\tkfree(attrs);\n}"
  },
  {
    "function_name": "parse_map_size",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
    "lines": "1352-1369",
    "snippet": "static int parse_map_size(char *str)\n{\n\tunsigned long size, map_bits;\n\tint ret;\n\n\tret = kstrtoul(str, 0, &size);\n\tif (ret)\n\t\tgoto out;\n\n\tmap_bits = ilog2(roundup_pow_of_two(size));\n\tif (map_bits < TRACING_MAP_BITS_MIN ||\n\t    map_bits > TRACING_MAP_BITS_MAX)\n\t\tret = -EINVAL;\n\telse\n\t\tret = map_bits;\n out:\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include \"tracing_map.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ilog2",
          "args": [
            "roundup_pow_of_two(size)"
          ],
          "line": 1361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "roundup_pow_of_two",
          "args": [
            "size"
          ],
          "line": 1361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrtoul",
          "args": [
            "str",
            "0",
            "&size"
          ],
          "line": 1357
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int parse_map_size(char *str)\n{\n\tunsigned long size, map_bits;\n\tint ret;\n\n\tret = kstrtoul(str, 0, &size);\n\tif (ret)\n\t\tgoto out;\n\n\tmap_bits = ilog2(roundup_pow_of_two(size));\n\tif (map_bits < TRACING_MAP_BITS_MIN ||\n\t    map_bits > TRACING_MAP_BITS_MAX)\n\t\tret = -EINVAL;\n\telse\n\t\tret = map_bits;\n out:\n\treturn ret;\n}"
  },
  {
    "function_name": "select_value_fn",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
    "lines": "1318-1350",
    "snippet": "static hist_field_fn_t select_value_fn(int field_size, int field_is_signed)\n{\n\thist_field_fn_t fn = NULL;\n\n\tswitch (field_size) {\n\tcase 8:\n\t\tif (field_is_signed)\n\t\t\tfn = hist_field_s64;\n\t\telse\n\t\t\tfn = hist_field_u64;\n\t\tbreak;\n\tcase 4:\n\t\tif (field_is_signed)\n\t\t\tfn = hist_field_s32;\n\t\telse\n\t\t\tfn = hist_field_u32;\n\t\tbreak;\n\tcase 2:\n\t\tif (field_is_signed)\n\t\t\tfn = hist_field_s16;\n\t\telse\n\t\t\tfn = hist_field_u16;\n\t\tbreak;\n\tcase 1:\n\t\tif (field_is_signed)\n\t\t\tfn = hist_field_s8;\n\t\telse\n\t\t\tfn = hist_field_u8;\n\t\tbreak;\n\t}\n\n\treturn fn;\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include \"tracing_map.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic hist_field_fn_t select_value_fn(int field_size, int field_is_signed)\n{\n\thist_field_fn_t fn = NULL;\n\n\tswitch (field_size) {\n\tcase 8:\n\t\tif (field_is_signed)\n\t\t\tfn = hist_field_s64;\n\t\telse\n\t\t\tfn = hist_field_u64;\n\t\tbreak;\n\tcase 4:\n\t\tif (field_is_signed)\n\t\t\tfn = hist_field_s32;\n\t\telse\n\t\t\tfn = hist_field_u32;\n\t\tbreak;\n\tcase 2:\n\t\tif (field_is_signed)\n\t\t\tfn = hist_field_s16;\n\t\telse\n\t\t\tfn = hist_field_u16;\n\t\tbreak;\n\tcase 1:\n\t\tif (field_is_signed)\n\t\t\tfn = hist_field_s8;\n\t\telse\n\t\t\tfn = hist_field_u8;\n\t\tbreak;\n\t}\n\n\treturn fn;\n}"
  },
  {
    "function_name": "hist_field_name",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
    "lines": "1280-1316",
    "snippet": "static const char *hist_field_name(struct hist_field *field,\n\t\t\t\t   unsigned int level)\n{\n\tconst char *field_name = \"\";\n\n\tif (level > 1)\n\t\treturn field_name;\n\n\tif (field->field)\n\t\tfield_name = field->field->name;\n\telse if (field->flags & HIST_FIELD_FL_LOG2 ||\n\t\t field->flags & HIST_FIELD_FL_ALIAS ||\n\t\t field->flags & HIST_FIELD_FL_BUCKET)\n\t\tfield_name = hist_field_name(field->operands[0], ++level);\n\telse if (field->flags & HIST_FIELD_FL_CPU)\n\t\tfield_name = \"common_cpu\";\n\telse if (field->flags & HIST_FIELD_FL_EXPR ||\n\t\t field->flags & HIST_FIELD_FL_VAR_REF) {\n\t\tif (field->system) {\n\t\t\tstatic char full_name[MAX_FILTER_STR_VAL];\n\n\t\t\tstrcat(full_name, field->system);\n\t\t\tstrcat(full_name, \".\");\n\t\t\tstrcat(full_name, field->event_name);\n\t\t\tstrcat(full_name, \".\");\n\t\t\tstrcat(full_name, field->name);\n\t\t\tfield_name = full_name;\n\t\t} else\n\t\t\tfield_name = field->name;\n\t} else if (field->flags & HIST_FIELD_FL_TIMESTAMP)\n\t\tfield_name = \"common_timestamp\";\n\n\tif (field_name == NULL)\n\t\tfield_name = \"\";\n\n\treturn field_name;\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include \"tracing_map.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "full_name",
            "field->name"
          ],
          "line": 1305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "full_name",
            "\".\""
          ],
          "line": 1304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "full_name",
            "field->event_name"
          ],
          "line": 1303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "full_name",
            "\".\""
          ],
          "line": 1302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "full_name",
            "field->system"
          ],
          "line": 1301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hist_field_name",
          "args": [
            "field->operands[0]",
            "++level"
          ],
          "line": 1293
        },
        "resolved": true,
        "details": {
          "function_name": "hist_field_name",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "1280-1316",
          "snippet": "static const char *hist_field_name(struct hist_field *field,\n\t\t\t\t   unsigned int level)\n{\n\tconst char *field_name = \"\";\n\n\tif (level > 1)\n\t\treturn field_name;\n\n\tif (field->field)\n\t\tfield_name = field->field->name;\n\telse if (field->flags & HIST_FIELD_FL_LOG2 ||\n\t\t field->flags & HIST_FIELD_FL_ALIAS ||\n\t\t field->flags & HIST_FIELD_FL_BUCKET)\n\t\tfield_name = hist_field_name(field->operands[0], ++level);\n\telse if (field->flags & HIST_FIELD_FL_CPU)\n\t\tfield_name = \"common_cpu\";\n\telse if (field->flags & HIST_FIELD_FL_EXPR ||\n\t\t field->flags & HIST_FIELD_FL_VAR_REF) {\n\t\tif (field->system) {\n\t\t\tstatic char full_name[MAX_FILTER_STR_VAL];\n\n\t\t\tstrcat(full_name, field->system);\n\t\t\tstrcat(full_name, \".\");\n\t\t\tstrcat(full_name, field->event_name);\n\t\t\tstrcat(full_name, \".\");\n\t\t\tstrcat(full_name, field->name);\n\t\t\tfield_name = full_name;\n\t\t} else\n\t\t\tfield_name = field->name;\n\t} else if (field->flags & HIST_FIELD_FL_TIMESTAMP)\n\t\tfield_name = \"common_timestamp\";\n\n\tif (field_name == NULL)\n\t\tfield_name = \"\";\n\n\treturn field_name;\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic const char *hist_field_name(struct hist_field *field,\n\t\t\t\t   unsigned int level)\n{\n\tconst char *field_name = \"\";\n\n\tif (level > 1)\n\t\treturn field_name;\n\n\tif (field->field)\n\t\tfield_name = field->field->name;\n\telse if (field->flags & HIST_FIELD_FL_LOG2 ||\n\t\t field->flags & HIST_FIELD_FL_ALIAS ||\n\t\t field->flags & HIST_FIELD_FL_BUCKET)\n\t\tfield_name = hist_field_name(field->operands[0], ++level);\n\telse if (field->flags & HIST_FIELD_FL_CPU)\n\t\tfield_name = \"common_cpu\";\n\telse if (field->flags & HIST_FIELD_FL_EXPR ||\n\t\t field->flags & HIST_FIELD_FL_VAR_REF) {\n\t\tif (field->system) {\n\t\t\tstatic char full_name[MAX_FILTER_STR_VAL];\n\n\t\t\tstrcat(full_name, field->system);\n\t\t\tstrcat(full_name, \".\");\n\t\t\tstrcat(full_name, field->event_name);\n\t\t\tstrcat(full_name, \".\");\n\t\t\tstrcat(full_name, field->name);\n\t\t\tfield_name = full_name;\n\t\t} else\n\t\t\tfield_name = field->name;\n\t} else if (field->flags & HIST_FIELD_FL_TIMESTAMP)\n\t\tfield_name = \"common_timestamp\";\n\n\tif (field_name == NULL)\n\t\tfield_name = \"\";\n\n\treturn field_name;\n}"
  },
  {
    "function_name": "resolve_var_refs",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
    "lines": "1234-1278",
    "snippet": "static bool resolve_var_refs(struct hist_trigger_data *hist_data, void *key,\n\t\t\t     u64 *var_ref_vals, bool self)\n{\n\tstruct hist_trigger_data *var_data;\n\tstruct tracing_map_elt *var_elt;\n\tstruct hist_field *hist_field;\n\tunsigned int i, var_idx;\n\tbool resolved = true;\n\tu64 var_val = 0;\n\n\tfor (i = 0; i < hist_data->n_var_refs; i++) {\n\t\thist_field = hist_data->var_refs[i];\n\t\tvar_idx = hist_field->var.idx;\n\t\tvar_data = hist_field->var.hist_data;\n\n\t\tif (var_data == NULL) {\n\t\t\tresolved = false;\n\t\t\tbreak;\n\t\t}\n\n\t\tif ((self && var_data != hist_data) ||\n\t\t    (!self && var_data == hist_data))\n\t\t\tcontinue;\n\n\t\tvar_elt = tracing_map_lookup(var_data->map, key);\n\t\tif (!var_elt) {\n\t\t\tresolved = false;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!tracing_map_var_set(var_elt, var_idx)) {\n\t\t\tresolved = false;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (self || !hist_field->read_once)\n\t\t\tvar_val = tracing_map_read_var(var_elt, var_idx);\n\t\telse\n\t\t\tvar_val = tracing_map_read_var_once(var_elt, var_idx);\n\n\t\tvar_ref_vals[i] = var_val;\n\t}\n\n\treturn resolved;\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include \"tracing_map.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tracing_map_read_var_once",
          "args": [
            "var_elt",
            "var_idx"
          ],
          "line": 1272
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_map_read_var_once",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/tracing_map.c",
          "lines": "122-126",
          "snippet": "u64 tracing_map_read_var_once(struct tracing_map_elt *elt, unsigned int i)\n{\n\telt->var_set[i] = false;\n\treturn (u64)atomic64_read(&elt->vars[i]);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/kmemleak.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/jhash.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/kmemleak.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <linux/vmalloc.h>\n\nu64 tracing_map_read_var_once(struct tracing_map_elt *elt, unsigned int i)\n{\n\telt->var_set[i] = false;\n\treturn (u64)atomic64_read(&elt->vars[i]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracing_map_var_set",
          "args": [
            "var_elt",
            "var_idx"
          ],
          "line": 1264
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_map_var_set",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/tracing_map.c",
          "lines": "86-89",
          "snippet": "bool tracing_map_var_set(struct tracing_map_elt *elt, unsigned int i)\n{\n\treturn elt->var_set[i];\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/kmemleak.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/jhash.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/kmemleak.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <linux/vmalloc.h>\n\nbool tracing_map_var_set(struct tracing_map_elt *elt, unsigned int i)\n{\n\treturn elt->var_set[i];\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracing_map_lookup",
          "args": [
            "var_data->map",
            "key"
          ],
          "line": 1258
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_map_lookup",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/tracing_map.c",
          "lines": "656-659",
          "snippet": "struct tracing_map_elt *tracing_map_lookup(struct tracing_map *map, void *key)\n{\n\treturn __tracing_map_insert(map, key, true);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/kmemleak.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/jhash.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/kmemleak.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <linux/vmalloc.h>\n\nstruct tracing_map_elt *tracing_map_lookup(struct tracing_map *map, void *key)\n{\n\treturn __tracing_map_insert(map, key, true);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic bool resolve_var_refs(struct hist_trigger_data *hist_data, void *key,\n\t\t\t     u64 *var_ref_vals, bool self)\n{\n\tstruct hist_trigger_data *var_data;\n\tstruct tracing_map_elt *var_elt;\n\tstruct hist_field *hist_field;\n\tunsigned int i, var_idx;\n\tbool resolved = true;\n\tu64 var_val = 0;\n\n\tfor (i = 0; i < hist_data->n_var_refs; i++) {\n\t\thist_field = hist_data->var_refs[i];\n\t\tvar_idx = hist_field->var.idx;\n\t\tvar_data = hist_field->var.hist_data;\n\n\t\tif (var_data == NULL) {\n\t\t\tresolved = false;\n\t\t\tbreak;\n\t\t}\n\n\t\tif ((self && var_data != hist_data) ||\n\t\t    (!self && var_data == hist_data))\n\t\t\tcontinue;\n\n\t\tvar_elt = tracing_map_lookup(var_data->map, key);\n\t\tif (!var_elt) {\n\t\t\tresolved = false;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!tracing_map_var_set(var_elt, var_idx)) {\n\t\t\tresolved = false;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (self || !hist_field->read_once)\n\t\t\tvar_val = tracing_map_read_var(var_elt, var_idx);\n\t\telse\n\t\t\tvar_val = tracing_map_read_var_once(var_elt, var_idx);\n\n\t\tvar_ref_vals[i] = var_val;\n\t}\n\n\treturn resolved;\n}"
  },
  {
    "function_name": "hist_field_var_ref",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
    "lines": "1216-1232",
    "snippet": "static u64 hist_field_var_ref(struct hist_field *hist_field,\n\t\t\t      struct tracing_map_elt *elt,\n\t\t\t      struct trace_buffer *buffer,\n\t\t\t      struct ring_buffer_event *rbe,\n\t\t\t      void *event)\n{\n\tstruct hist_elt_data *elt_data;\n\tu64 var_val = 0;\n\n\tif (WARN_ON_ONCE(!elt))\n\t\treturn var_val;\n\n\telt_data = elt->private_data;\n\tvar_val = elt_data->var_ref_vals[hist_field->var_ref_idx];\n\n\treturn var_val;\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include \"tracing_map.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!elt"
          ],
          "line": 1225
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic u64 hist_field_var_ref(struct hist_field *hist_field,\n\t\t\t      struct tracing_map_elt *elt,\n\t\t\t      struct trace_buffer *buffer,\n\t\t\t      struct ring_buffer_event *rbe,\n\t\t\t      void *event)\n{\n\tstruct hist_elt_data *elt_data;\n\tu64 var_val = 0;\n\n\tif (WARN_ON_ONCE(!elt))\n\t\treturn var_val;\n\n\telt_data = elt->private_data;\n\tvar_val = elt_data->var_ref_vals[hist_field->var_ref_idx];\n\n\treturn var_val;\n}"
  },
  {
    "function_name": "find_event_var",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
    "lines": "1190-1214",
    "snippet": "static struct hist_field *find_event_var(struct hist_trigger_data *hist_data,\n\t\t\t\t\t char *system,\n\t\t\t\t\t char *event_name,\n\t\t\t\t\t char *var_name)\n{\n\tstruct trace_array *tr = hist_data->event_file->tr;\n\tstruct hist_field *hist_field = NULL;\n\tstruct trace_event_file *file;\n\n\tif (!system || !event_name) {\n\t\thist_field = find_match_var(hist_data, var_name);\n\t\tif (IS_ERR(hist_field))\n\t\t\treturn NULL;\n\t\tif (hist_field)\n\t\t\treturn hist_field;\n\t}\n\n\tfile = find_var_file(tr, system, event_name, var_name);\n\tif (!file)\n\t\treturn NULL;\n\n\thist_field = find_file_var(file, var_name);\n\n\treturn hist_field;\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include \"tracing_map.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "find_file_var",
          "args": [
            "file",
            "var_name"
          ],
          "line": 1211
        },
        "resolved": true,
        "details": {
          "function_name": "find_file_var",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "1136-1155",
          "snippet": "static struct hist_field *find_file_var(struct trace_event_file *file,\n\t\t\t\t\tconst char *var_name)\n{\n\tstruct hist_trigger_data *test_data;\n\tstruct event_trigger_data *test;\n\tstruct hist_field *hist_field;\n\n\tlockdep_assert_held(&event_mutex);\n\n\tlist_for_each_entry(test, &file->triggers, list) {\n\t\tif (test->cmd_ops->trigger_type == ETT_EVENT_HIST) {\n\t\t\ttest_data = test->private_data;\n\t\t\thist_field = find_var_field(test_data, var_name);\n\t\t\tif (hist_field)\n\t\t\t\treturn hist_field;\n\t\t}\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct hist_field *find_file_var(struct trace_event_file *file,\n\t\t\t\t\tconst char *var_name)\n{\n\tstruct hist_trigger_data *test_data;\n\tstruct event_trigger_data *test;\n\tstruct hist_field *hist_field;\n\n\tlockdep_assert_held(&event_mutex);\n\n\tlist_for_each_entry(test, &file->triggers, list) {\n\t\tif (test->cmd_ops->trigger_type == ETT_EVENT_HIST) {\n\t\t\ttest_data = test->private_data;\n\t\t\thist_field = find_var_field(test_data, var_name);\n\t\t\tif (hist_field)\n\t\t\t\treturn hist_field;\n\t\t}\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_var_file",
          "args": [
            "tr",
            "system",
            "event_name",
            "var_name"
          ],
          "line": 1207
        },
        "resolved": true,
        "details": {
          "function_name": "find_var_file",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "1105-1134",
          "snippet": "static struct trace_event_file *find_var_file(struct trace_array *tr,\n\t\t\t\t\t      char *system,\n\t\t\t\t\t      char *event_name,\n\t\t\t\t\t      char *var_name)\n{\n\tstruct hist_trigger_data *var_hist_data;\n\tstruct hist_var_data *var_data;\n\tstruct trace_event_file *file, *found = NULL;\n\n\tif (system)\n\t\treturn find_event_file(tr, system, event_name);\n\n\tlist_for_each_entry(var_data, &tr->hist_vars, list) {\n\t\tvar_hist_data = var_data->hist_data;\n\t\tfile = var_hist_data->event_file;\n\t\tif (file == found)\n\t\t\tcontinue;\n\n\t\tif (find_var_field(var_hist_data, var_name)) {\n\t\t\tif (found) {\n\t\t\t\thist_err(tr, HIST_ERR_VAR_NOT_UNIQUE, errpos(var_name));\n\t\t\t\treturn NULL;\n\t\t\t}\n\n\t\t\tfound = file;\n\t\t}\n\t}\n\n\treturn found;\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct trace_event_file *find_var_file(struct trace_array *tr,\n\t\t\t\t\t      char *system,\n\t\t\t\t\t      char *event_name,\n\t\t\t\t\t      char *var_name)\n{\n\tstruct hist_trigger_data *var_hist_data;\n\tstruct hist_var_data *var_data;\n\tstruct trace_event_file *file, *found = NULL;\n\n\tif (system)\n\t\treturn find_event_file(tr, system, event_name);\n\n\tlist_for_each_entry(var_data, &tr->hist_vars, list) {\n\t\tvar_hist_data = var_data->hist_data;\n\t\tfile = var_hist_data->event_file;\n\t\tif (file == found)\n\t\t\tcontinue;\n\n\t\tif (find_var_field(var_hist_data, var_name)) {\n\t\t\tif (found) {\n\t\t\t\thist_err(tr, HIST_ERR_VAR_NOT_UNIQUE, errpos(var_name));\n\t\t\t\treturn NULL;\n\t\t\t}\n\n\t\t\tfound = file;\n\t\t}\n\t}\n\n\treturn found;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "hist_field"
          ],
          "line": 1201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_match_var",
          "args": [
            "hist_data",
            "var_name"
          ],
          "line": 1200
        },
        "resolved": true,
        "details": {
          "function_name": "find_match_var",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "1157-1188",
          "snippet": "static struct hist_field *\nfind_match_var(struct hist_trigger_data *hist_data, char *var_name)\n{\n\tstruct trace_array *tr = hist_data->event_file->tr;\n\tstruct hist_field *hist_field, *found = NULL;\n\tstruct trace_event_file *file;\n\tunsigned int i;\n\n\tfor (i = 0; i < hist_data->n_actions; i++) {\n\t\tstruct action_data *data = hist_data->actions[i];\n\n\t\tif (data->handler == HANDLER_ONMATCH) {\n\t\t\tchar *system = data->match_data.event_system;\n\t\t\tchar *event_name = data->match_data.event;\n\n\t\t\tfile = find_var_file(tr, system, event_name, var_name);\n\t\t\tif (!file)\n\t\t\t\tcontinue;\n\t\t\thist_field = find_file_var(file, var_name);\n\t\t\tif (hist_field) {\n\t\t\t\tif (found) {\n\t\t\t\t\thist_err(tr, HIST_ERR_VAR_NOT_UNIQUE,\n\t\t\t\t\t\t errpos(var_name));\n\t\t\t\t\treturn ERR_PTR(-EINVAL);\n\t\t\t\t}\n\n\t\t\t\tfound = hist_field;\n\t\t\t}\n\t\t}\n\t}\n\treturn found;\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);\n\nstatic struct hist_field *\nfind_match_var(struct hist_trigger_data *hist_data, char *var_name)\n{\n\tstruct trace_array *tr = hist_data->event_file->tr;\n\tstruct hist_field *hist_field, *found = NULL;\n\tstruct trace_event_file *file;\n\tunsigned int i;\n\n\tfor (i = 0; i < hist_data->n_actions; i++) {\n\t\tstruct action_data *data = hist_data->actions[i];\n\n\t\tif (data->handler == HANDLER_ONMATCH) {\n\t\t\tchar *system = data->match_data.event_system;\n\t\t\tchar *event_name = data->match_data.event;\n\n\t\t\tfile = find_var_file(tr, system, event_name, var_name);\n\t\t\tif (!file)\n\t\t\t\tcontinue;\n\t\t\thist_field = find_file_var(file, var_name);\n\t\t\tif (hist_field) {\n\t\t\t\tif (found) {\n\t\t\t\t\thist_err(tr, HIST_ERR_VAR_NOT_UNIQUE,\n\t\t\t\t\t\t errpos(var_name));\n\t\t\t\t\treturn ERR_PTR(-EINVAL);\n\t\t\t\t}\n\n\t\t\t\tfound = hist_field;\n\t\t\t}\n\t\t}\n\t}\n\treturn found;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct hist_field *find_event_var(struct hist_trigger_data *hist_data,\n\t\t\t\t\t char *system,\n\t\t\t\t\t char *event_name,\n\t\t\t\t\t char *var_name)\n{\n\tstruct trace_array *tr = hist_data->event_file->tr;\n\tstruct hist_field *hist_field = NULL;\n\tstruct trace_event_file *file;\n\n\tif (!system || !event_name) {\n\t\thist_field = find_match_var(hist_data, var_name);\n\t\tif (IS_ERR(hist_field))\n\t\t\treturn NULL;\n\t\tif (hist_field)\n\t\t\treturn hist_field;\n\t}\n\n\tfile = find_var_file(tr, system, event_name, var_name);\n\tif (!file)\n\t\treturn NULL;\n\n\thist_field = find_file_var(file, var_name);\n\n\treturn hist_field;\n}"
  },
  {
    "function_name": "find_match_var",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
    "lines": "1157-1188",
    "snippet": "static struct hist_field *\nfind_match_var(struct hist_trigger_data *hist_data, char *var_name)\n{\n\tstruct trace_array *tr = hist_data->event_file->tr;\n\tstruct hist_field *hist_field, *found = NULL;\n\tstruct trace_event_file *file;\n\tunsigned int i;\n\n\tfor (i = 0; i < hist_data->n_actions; i++) {\n\t\tstruct action_data *data = hist_data->actions[i];\n\n\t\tif (data->handler == HANDLER_ONMATCH) {\n\t\t\tchar *system = data->match_data.event_system;\n\t\t\tchar *event_name = data->match_data.event;\n\n\t\t\tfile = find_var_file(tr, system, event_name, var_name);\n\t\t\tif (!file)\n\t\t\t\tcontinue;\n\t\t\thist_field = find_file_var(file, var_name);\n\t\t\tif (hist_field) {\n\t\t\t\tif (found) {\n\t\t\t\t\thist_err(tr, HIST_ERR_VAR_NOT_UNIQUE,\n\t\t\t\t\t\t errpos(var_name));\n\t\t\t\t\treturn ERR_PTR(-EINVAL);\n\t\t\t\t}\n\n\t\t\t\tfound = hist_field;\n\t\t\t}\n\t\t}\n\t}\n\treturn found;\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include \"tracing_map.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EINVAL"
          ],
          "line": 1180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hist_err",
          "args": [
            "tr",
            "HIST_ERR_VAR_NOT_UNIQUE",
            "errpos(var_name)"
          ],
          "line": 1178
        },
        "resolved": true,
        "details": {
          "function_name": "hist_err",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "763-767",
          "snippet": "static void hist_err(struct trace_array *tr, u8 err_type, u8 err_pos)\n{\n\ttracing_log_err(tr, last_cmd_loc, last_cmd, err_text,\n\t\t\terr_type, err_pos);\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *err_text[] = { ERRORS };",
            "static char last_cmd[MAX_FILTER_STR_VAL];",
            "static char last_cmd_loc[MAX_FILTER_STR_VAL];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic const char *err_text[] = { ERRORS };\nstatic char last_cmd[MAX_FILTER_STR_VAL];\nstatic char last_cmd_loc[MAX_FILTER_STR_VAL];\n\nstatic void hist_err(struct trace_array *tr, u8 err_type, u8 err_pos)\n{\n\ttracing_log_err(tr, last_cmd_loc, last_cmd, err_text,\n\t\t\terr_type, err_pos);\n}"
        }
      },
      {
        "call_info": {
          "callee": "errpos",
          "args": [
            "var_name"
          ],
          "line": 1179
        },
        "resolved": true,
        "details": {
          "function_name": "errpos",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "733-736",
          "snippet": "static int errpos(char *str)\n{\n\treturn err_pos(last_cmd, str);\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char last_cmd[MAX_FILTER_STR_VAL];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic char last_cmd[MAX_FILTER_STR_VAL];\n\nstatic int errpos(char *str)\n{\n\treturn err_pos(last_cmd, str);\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_file_var",
          "args": [
            "file",
            "var_name"
          ],
          "line": 1175
        },
        "resolved": true,
        "details": {
          "function_name": "find_file_var",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "1136-1155",
          "snippet": "static struct hist_field *find_file_var(struct trace_event_file *file,\n\t\t\t\t\tconst char *var_name)\n{\n\tstruct hist_trigger_data *test_data;\n\tstruct event_trigger_data *test;\n\tstruct hist_field *hist_field;\n\n\tlockdep_assert_held(&event_mutex);\n\n\tlist_for_each_entry(test, &file->triggers, list) {\n\t\tif (test->cmd_ops->trigger_type == ETT_EVENT_HIST) {\n\t\t\ttest_data = test->private_data;\n\t\t\thist_field = find_var_field(test_data, var_name);\n\t\t\tif (hist_field)\n\t\t\t\treturn hist_field;\n\t\t}\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct hist_field *find_file_var(struct trace_event_file *file,\n\t\t\t\t\tconst char *var_name)\n{\n\tstruct hist_trigger_data *test_data;\n\tstruct event_trigger_data *test;\n\tstruct hist_field *hist_field;\n\n\tlockdep_assert_held(&event_mutex);\n\n\tlist_for_each_entry(test, &file->triggers, list) {\n\t\tif (test->cmd_ops->trigger_type == ETT_EVENT_HIST) {\n\t\t\ttest_data = test->private_data;\n\t\t\thist_field = find_var_field(test_data, var_name);\n\t\t\tif (hist_field)\n\t\t\t\treturn hist_field;\n\t\t}\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_var_file",
          "args": [
            "tr",
            "system",
            "event_name",
            "var_name"
          ],
          "line": 1172
        },
        "resolved": true,
        "details": {
          "function_name": "find_var_file",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "1105-1134",
          "snippet": "static struct trace_event_file *find_var_file(struct trace_array *tr,\n\t\t\t\t\t      char *system,\n\t\t\t\t\t      char *event_name,\n\t\t\t\t\t      char *var_name)\n{\n\tstruct hist_trigger_data *var_hist_data;\n\tstruct hist_var_data *var_data;\n\tstruct trace_event_file *file, *found = NULL;\n\n\tif (system)\n\t\treturn find_event_file(tr, system, event_name);\n\n\tlist_for_each_entry(var_data, &tr->hist_vars, list) {\n\t\tvar_hist_data = var_data->hist_data;\n\t\tfile = var_hist_data->event_file;\n\t\tif (file == found)\n\t\t\tcontinue;\n\n\t\tif (find_var_field(var_hist_data, var_name)) {\n\t\t\tif (found) {\n\t\t\t\thist_err(tr, HIST_ERR_VAR_NOT_UNIQUE, errpos(var_name));\n\t\t\t\treturn NULL;\n\t\t\t}\n\n\t\t\tfound = file;\n\t\t}\n\t}\n\n\treturn found;\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct trace_event_file *find_var_file(struct trace_array *tr,\n\t\t\t\t\t      char *system,\n\t\t\t\t\t      char *event_name,\n\t\t\t\t\t      char *var_name)\n{\n\tstruct hist_trigger_data *var_hist_data;\n\tstruct hist_var_data *var_data;\n\tstruct trace_event_file *file, *found = NULL;\n\n\tif (system)\n\t\treturn find_event_file(tr, system, event_name);\n\n\tlist_for_each_entry(var_data, &tr->hist_vars, list) {\n\t\tvar_hist_data = var_data->hist_data;\n\t\tfile = var_hist_data->event_file;\n\t\tif (file == found)\n\t\t\tcontinue;\n\n\t\tif (find_var_field(var_hist_data, var_name)) {\n\t\t\tif (found) {\n\t\t\t\thist_err(tr, HIST_ERR_VAR_NOT_UNIQUE, errpos(var_name));\n\t\t\t\treturn NULL;\n\t\t\t}\n\n\t\t\tfound = file;\n\t\t}\n\t}\n\n\treturn found;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);\n\nstatic struct hist_field *\nfind_match_var(struct hist_trigger_data *hist_data, char *var_name)\n{\n\tstruct trace_array *tr = hist_data->event_file->tr;\n\tstruct hist_field *hist_field, *found = NULL;\n\tstruct trace_event_file *file;\n\tunsigned int i;\n\n\tfor (i = 0; i < hist_data->n_actions; i++) {\n\t\tstruct action_data *data = hist_data->actions[i];\n\n\t\tif (data->handler == HANDLER_ONMATCH) {\n\t\t\tchar *system = data->match_data.event_system;\n\t\t\tchar *event_name = data->match_data.event;\n\n\t\t\tfile = find_var_file(tr, system, event_name, var_name);\n\t\t\tif (!file)\n\t\t\t\tcontinue;\n\t\t\thist_field = find_file_var(file, var_name);\n\t\t\tif (hist_field) {\n\t\t\t\tif (found) {\n\t\t\t\t\thist_err(tr, HIST_ERR_VAR_NOT_UNIQUE,\n\t\t\t\t\t\t errpos(var_name));\n\t\t\t\t\treturn ERR_PTR(-EINVAL);\n\t\t\t\t}\n\n\t\t\t\tfound = hist_field;\n\t\t\t}\n\t\t}\n\t}\n\treturn found;\n}"
  },
  {
    "function_name": "find_file_var",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
    "lines": "1136-1155",
    "snippet": "static struct hist_field *find_file_var(struct trace_event_file *file,\n\t\t\t\t\tconst char *var_name)\n{\n\tstruct hist_trigger_data *test_data;\n\tstruct event_trigger_data *test;\n\tstruct hist_field *hist_field;\n\n\tlockdep_assert_held(&event_mutex);\n\n\tlist_for_each_entry(test, &file->triggers, list) {\n\t\tif (test->cmd_ops->trigger_type == ETT_EVENT_HIST) {\n\t\t\ttest_data = test->private_data;\n\t\t\thist_field = find_var_field(test_data, var_name);\n\t\t\tif (hist_field)\n\t\t\t\treturn hist_field;\n\t\t}\n\t}\n\n\treturn NULL;\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include \"tracing_map.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "find_var_field",
          "args": [
            "test_data",
            "var_name"
          ],
          "line": 1148
        },
        "resolved": true,
        "details": {
          "function_name": "find_var_field",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "1061-1077",
          "snippet": "static struct hist_field *find_var_field(struct hist_trigger_data *hist_data,\n\t\t\t\t\t const char *var_name)\n{\n\tstruct hist_field *hist_field, *found = NULL;\n\tint i;\n\n\tfor_each_hist_field(i, hist_data) {\n\t\thist_field = hist_data->fields[i];\n\t\tif (hist_field && hist_field->flags & HIST_FIELD_FL_VAR &&\n\t\t    strcmp(hist_field->var.name, var_name) == 0) {\n\t\t\tfound = hist_field;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn found;\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct hist_field *find_var_field(struct hist_trigger_data *hist_data,\n\t\t\t\t\t const char *var_name)\n{\n\tstruct hist_field *hist_field, *found = NULL;\n\tint i;\n\n\tfor_each_hist_field(i, hist_data) {\n\t\thist_field = hist_data->fields[i];\n\t\tif (hist_field && hist_field->flags & HIST_FIELD_FL_VAR &&\n\t\t    strcmp(hist_field->var.name, var_name) == 0) {\n\t\t\tfound = hist_field;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn found;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "test",
            "&file->triggers",
            "list"
          ],
          "line": 1145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&event_mutex"
          ],
          "line": 1143
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct hist_field *find_file_var(struct trace_event_file *file,\n\t\t\t\t\tconst char *var_name)\n{\n\tstruct hist_trigger_data *test_data;\n\tstruct event_trigger_data *test;\n\tstruct hist_field *hist_field;\n\n\tlockdep_assert_held(&event_mutex);\n\n\tlist_for_each_entry(test, &file->triggers, list) {\n\t\tif (test->cmd_ops->trigger_type == ETT_EVENT_HIST) {\n\t\t\ttest_data = test->private_data;\n\t\t\thist_field = find_var_field(test_data, var_name);\n\t\t\tif (hist_field)\n\t\t\t\treturn hist_field;\n\t\t}\n\t}\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "find_var_file",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
    "lines": "1105-1134",
    "snippet": "static struct trace_event_file *find_var_file(struct trace_array *tr,\n\t\t\t\t\t      char *system,\n\t\t\t\t\t      char *event_name,\n\t\t\t\t\t      char *var_name)\n{\n\tstruct hist_trigger_data *var_hist_data;\n\tstruct hist_var_data *var_data;\n\tstruct trace_event_file *file, *found = NULL;\n\n\tif (system)\n\t\treturn find_event_file(tr, system, event_name);\n\n\tlist_for_each_entry(var_data, &tr->hist_vars, list) {\n\t\tvar_hist_data = var_data->hist_data;\n\t\tfile = var_hist_data->event_file;\n\t\tif (file == found)\n\t\t\tcontinue;\n\n\t\tif (find_var_field(var_hist_data, var_name)) {\n\t\t\tif (found) {\n\t\t\t\thist_err(tr, HIST_ERR_VAR_NOT_UNIQUE, errpos(var_name));\n\t\t\t\treturn NULL;\n\t\t\t}\n\n\t\t\tfound = file;\n\t\t}\n\t}\n\n\treturn found;\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include \"tracing_map.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hist_err",
          "args": [
            "tr",
            "HIST_ERR_VAR_NOT_UNIQUE",
            "errpos(var_name)"
          ],
          "line": 1125
        },
        "resolved": true,
        "details": {
          "function_name": "hist_err",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "763-767",
          "snippet": "static void hist_err(struct trace_array *tr, u8 err_type, u8 err_pos)\n{\n\ttracing_log_err(tr, last_cmd_loc, last_cmd, err_text,\n\t\t\terr_type, err_pos);\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *err_text[] = { ERRORS };",
            "static char last_cmd[MAX_FILTER_STR_VAL];",
            "static char last_cmd_loc[MAX_FILTER_STR_VAL];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic const char *err_text[] = { ERRORS };\nstatic char last_cmd[MAX_FILTER_STR_VAL];\nstatic char last_cmd_loc[MAX_FILTER_STR_VAL];\n\nstatic void hist_err(struct trace_array *tr, u8 err_type, u8 err_pos)\n{\n\ttracing_log_err(tr, last_cmd_loc, last_cmd, err_text,\n\t\t\terr_type, err_pos);\n}"
        }
      },
      {
        "call_info": {
          "callee": "errpos",
          "args": [
            "var_name"
          ],
          "line": 1125
        },
        "resolved": true,
        "details": {
          "function_name": "errpos",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "733-736",
          "snippet": "static int errpos(char *str)\n{\n\treturn err_pos(last_cmd, str);\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char last_cmd[MAX_FILTER_STR_VAL];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic char last_cmd[MAX_FILTER_STR_VAL];\n\nstatic int errpos(char *str)\n{\n\treturn err_pos(last_cmd, str);\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_var_field",
          "args": [
            "var_hist_data",
            "var_name"
          ],
          "line": 1123
        },
        "resolved": true,
        "details": {
          "function_name": "find_var_field",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "1061-1077",
          "snippet": "static struct hist_field *find_var_field(struct hist_trigger_data *hist_data,\n\t\t\t\t\t const char *var_name)\n{\n\tstruct hist_field *hist_field, *found = NULL;\n\tint i;\n\n\tfor_each_hist_field(i, hist_data) {\n\t\thist_field = hist_data->fields[i];\n\t\tif (hist_field && hist_field->flags & HIST_FIELD_FL_VAR &&\n\t\t    strcmp(hist_field->var.name, var_name) == 0) {\n\t\t\tfound = hist_field;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn found;\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct hist_field *find_var_field(struct hist_trigger_data *hist_data,\n\t\t\t\t\t const char *var_name)\n{\n\tstruct hist_field *hist_field, *found = NULL;\n\tint i;\n\n\tfor_each_hist_field(i, hist_data) {\n\t\thist_field = hist_data->fields[i];\n\t\tif (hist_field && hist_field->flags & HIST_FIELD_FL_VAR &&\n\t\t    strcmp(hist_field->var.name, var_name) == 0) {\n\t\t\tfound = hist_field;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn found;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "var_data",
            "&tr->hist_vars",
            "list"
          ],
          "line": 1117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_event_file",
          "args": [
            "tr",
            "system",
            "event_name"
          ],
          "line": 1115
        },
        "resolved": true,
        "details": {
          "function_name": "find_event_file",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
          "lines": "2943-2954",
          "snippet": "struct trace_event_file *\nfind_event_file(struct trace_array *tr, const char *system, const char *event)\n{\n\tstruct trace_event_file *file;\n\n\tfile = __find_event_file(tr, system, event);\n\tif (!file || !file->event_call->class->reg ||\n\t    file->event_call->flags & TRACE_EVENT_FL_IGNORE_ENABLE)\n\t\treturn NULL;\n\n\treturn file;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/syscall.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_npid_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_release(struct inode *inode, struct file *file);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_npid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\n\nstruct trace_event_file *\nfind_event_file(struct trace_array *tr, const char *system, const char *event)\n{\n\tstruct trace_event_file *file;\n\n\tfile = __find_event_file(tr, system, event);\n\tif (!file || !file->event_call->class->reg ||\n\t    file->event_call->flags & TRACE_EVENT_FL_IGNORE_ENABLE)\n\t\treturn NULL;\n\n\treturn file;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct trace_event_file *find_var_file(struct trace_array *tr,\n\t\t\t\t\t      char *system,\n\t\t\t\t\t      char *event_name,\n\t\t\t\t\t      char *var_name)\n{\n\tstruct hist_trigger_data *var_hist_data;\n\tstruct hist_var_data *var_data;\n\tstruct trace_event_file *file, *found = NULL;\n\n\tif (system)\n\t\treturn find_event_file(tr, system, event_name);\n\n\tlist_for_each_entry(var_data, &tr->hist_vars, list) {\n\t\tvar_hist_data = var_data->hist_data;\n\t\tfile = var_hist_data->event_file;\n\t\tif (file == found)\n\t\t\tcontinue;\n\n\t\tif (find_var_field(var_hist_data, var_name)) {\n\t\t\tif (found) {\n\t\t\t\thist_err(tr, HIST_ERR_VAR_NOT_UNIQUE, errpos(var_name));\n\t\t\t\treturn NULL;\n\t\t\t}\n\n\t\t\tfound = file;\n\t\t}\n\t}\n\n\treturn found;\n}"
  },
  {
    "function_name": "find_var",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
    "lines": "1079-1103",
    "snippet": "static struct hist_field *find_var(struct hist_trigger_data *hist_data,\n\t\t\t\t   struct trace_event_file *file,\n\t\t\t\t   const char *var_name)\n{\n\tstruct hist_trigger_data *test_data;\n\tstruct event_trigger_data *test;\n\tstruct hist_field *hist_field;\n\n\tlockdep_assert_held(&event_mutex);\n\n\thist_field = find_var_field(hist_data, var_name);\n\tif (hist_field)\n\t\treturn hist_field;\n\n\tlist_for_each_entry(test, &file->triggers, list) {\n\t\tif (test->cmd_ops->trigger_type == ETT_EVENT_HIST) {\n\t\t\ttest_data = test->private_data;\n\t\t\thist_field = find_var_field(test_data, var_name);\n\t\t\tif (hist_field)\n\t\t\t\treturn hist_field;\n\t\t}\n\t}\n\n\treturn NULL;\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include \"tracing_map.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "find_var_field",
          "args": [
            "test_data",
            "var_name"
          ],
          "line": 1096
        },
        "resolved": true,
        "details": {
          "function_name": "find_var_field",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "1061-1077",
          "snippet": "static struct hist_field *find_var_field(struct hist_trigger_data *hist_data,\n\t\t\t\t\t const char *var_name)\n{\n\tstruct hist_field *hist_field, *found = NULL;\n\tint i;\n\n\tfor_each_hist_field(i, hist_data) {\n\t\thist_field = hist_data->fields[i];\n\t\tif (hist_field && hist_field->flags & HIST_FIELD_FL_VAR &&\n\t\t    strcmp(hist_field->var.name, var_name) == 0) {\n\t\t\tfound = hist_field;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn found;\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct hist_field *find_var_field(struct hist_trigger_data *hist_data,\n\t\t\t\t\t const char *var_name)\n{\n\tstruct hist_field *hist_field, *found = NULL;\n\tint i;\n\n\tfor_each_hist_field(i, hist_data) {\n\t\thist_field = hist_data->fields[i];\n\t\tif (hist_field && hist_field->flags & HIST_FIELD_FL_VAR &&\n\t\t    strcmp(hist_field->var.name, var_name) == 0) {\n\t\t\tfound = hist_field;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn found;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "test",
            "&file->triggers",
            "list"
          ],
          "line": 1093
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&event_mutex"
          ],
          "line": 1087
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct hist_field *find_var(struct hist_trigger_data *hist_data,\n\t\t\t\t   struct trace_event_file *file,\n\t\t\t\t   const char *var_name)\n{\n\tstruct hist_trigger_data *test_data;\n\tstruct event_trigger_data *test;\n\tstruct hist_field *hist_field;\n\n\tlockdep_assert_held(&event_mutex);\n\n\thist_field = find_var_field(hist_data, var_name);\n\tif (hist_field)\n\t\treturn hist_field;\n\n\tlist_for_each_entry(test, &file->triggers, list) {\n\t\tif (test->cmd_ops->trigger_type == ETT_EVENT_HIST) {\n\t\t\ttest_data = test->private_data;\n\t\t\thist_field = find_var_field(test_data, var_name);\n\t\t\tif (hist_field)\n\t\t\t\treturn hist_field;\n\t\t}\n\t}\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "find_var_field",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
    "lines": "1061-1077",
    "snippet": "static struct hist_field *find_var_field(struct hist_trigger_data *hist_data,\n\t\t\t\t\t const char *var_name)\n{\n\tstruct hist_field *hist_field, *found = NULL;\n\tint i;\n\n\tfor_each_hist_field(i, hist_data) {\n\t\thist_field = hist_data->fields[i];\n\t\tif (hist_field && hist_field->flags & HIST_FIELD_FL_VAR &&\n\t\t    strcmp(hist_field->var.name, var_name) == 0) {\n\t\t\tfound = hist_field;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn found;\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include \"tracing_map.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "hist_field->var.name",
            "var_name"
          ],
          "line": 1070
        },
        "resolved": true,
        "details": {
          "function_name": "sym_strcmp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/report.c",
          "lines": "356-365",
          "snippet": "static int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}",
          "includes": [
            "#include \"encoding.h\"",
            "#include \"kcsan.h\"",
            "#include <linux/stacktrace.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/delay.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"encoding.h\"\n#include \"kcsan.h\"\n#include <linux/stacktrace.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/lockdep.h>\n#include <linux/kernel.h>\n#include <linux/kallsyms.h>\n#include <linux/jiffies.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n\nstatic int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_hist_field",
          "args": [
            "i",
            "hist_data"
          ],
          "line": 1067
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct hist_field *find_var_field(struct hist_trigger_data *hist_data,\n\t\t\t\t\t const char *var_name)\n{\n\tstruct hist_field *hist_field, *found = NULL;\n\tint i;\n\n\tfor_each_hist_field(i, hist_data) {\n\t\thist_field = hist_data->fields[i];\n\t\tif (hist_field && hist_field->flags & HIST_FIELD_FL_VAR &&\n\t\t    strcmp(hist_field->var.name, var_name) == 0) {\n\t\t\tfound = hist_field;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn found;\n}"
  },
  {
    "function_name": "remove_hist_vars",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
    "lines": "1042-1059",
    "snippet": "static void remove_hist_vars(struct hist_trigger_data *hist_data)\n{\n\tstruct trace_array *tr = hist_data->event_file->tr;\n\tstruct hist_var_data *var_data;\n\n\tvar_data = find_hist_vars(hist_data);\n\tif (!var_data)\n\t\treturn;\n\n\tif (WARN_ON(check_var_refs(hist_data)))\n\t\treturn;\n\n\tlist_del(&var_data->list);\n\n\tkfree(var_data);\n\n\ttrace_array_put(tr);\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include \"tracing_map.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_array_put",
          "args": [
            "tr"
          ],
          "line": 1058
        },
        "resolved": true,
        "details": {
          "function_name": "trace_array_put",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "474-482",
          "snippet": "void trace_array_put(struct trace_array *this_tr)\n{\n\tif (!this_tr)\n\t\treturn;\n\n\tmutex_lock(&trace_types_lock);\n\t__trace_array_put(this_tr);\n\tmutex_unlock(&trace_types_lock);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nvoid trace_array_put(struct trace_array *this_tr)\n{\n\tif (!this_tr)\n\t\treturn;\n\n\tmutex_lock(&trace_types_lock);\n\t__trace_array_put(this_tr);\n\tmutex_unlock(&trace_types_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "var_data"
          ],
          "line": 1056
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&var_data->list"
          ],
          "line": 1054
        },
        "resolved": true,
        "details": {
          "function_name": "list_del_leaf_cfs_rq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/fair.c",
          "lines": "475-477",
          "snippet": "static inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool sched_idle_cfs_rq(struct cfs_rq *cfs_rq);",
            "static void check_enqueue_throttle(struct cfs_rq *cfs_rq);",
            "static __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);",
            "static bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic bool sched_idle_cfs_rq(struct cfs_rq *cfs_rq);\nstatic void check_enqueue_throttle(struct cfs_rq *cfs_rq);\nstatic __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);\nstatic bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);\n\nstatic inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "check_var_refs(hist_data)"
          ],
          "line": 1051
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_var_refs",
          "args": [
            "hist_data"
          ],
          "line": 1051
        },
        "resolved": true,
        "details": {
          "function_name": "check_var_refs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "944-961",
          "snippet": "static bool check_var_refs(struct hist_trigger_data *hist_data)\n{\n\tstruct hist_field *field;\n\tbool found = false;\n\tint i;\n\n\tfor_each_hist_field(i, hist_data) {\n\t\tfield = hist_data->fields[i];\n\t\tif (field && field->flags & HIST_FIELD_FL_VAR) {\n\t\t\tif (find_any_var_ref(hist_data, field->var.idx)) {\n\t\t\t\tfound = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn found;\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic bool check_var_refs(struct hist_trigger_data *hist_data)\n{\n\tstruct hist_field *field;\n\tbool found = false;\n\tint i;\n\n\tfor_each_hist_field(i, hist_data) {\n\t\tfield = hist_data->fields[i];\n\t\tif (field && field->flags & HIST_FIELD_FL_VAR) {\n\t\t\tif (find_any_var_ref(hist_data, field->var.idx)) {\n\t\t\t\tfound = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn found;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_hist_vars",
          "args": [
            "hist_data"
          ],
          "line": 1047
        },
        "resolved": true,
        "details": {
          "function_name": "find_hist_vars",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "963-976",
          "snippet": "static struct hist_var_data *find_hist_vars(struct hist_trigger_data *hist_data)\n{\n\tstruct trace_array *tr = hist_data->event_file->tr;\n\tstruct hist_var_data *var_data, *found = NULL;\n\n\tlist_for_each_entry(var_data, &tr->hist_vars, list) {\n\t\tif (var_data->hist_data == hist_data) {\n\t\t\tfound = var_data;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn found;\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct hist_var_data *find_hist_vars(struct hist_trigger_data *hist_data)\n{\n\tstruct trace_array *tr = hist_data->event_file->tr;\n\tstruct hist_var_data *var_data, *found = NULL;\n\n\tlist_for_each_entry(var_data, &tr->hist_vars, list) {\n\t\tif (var_data->hist_data == hist_data) {\n\t\t\tfound = var_data;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn found;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void remove_hist_vars(struct hist_trigger_data *hist_data)\n{\n\tstruct trace_array *tr = hist_data->event_file->tr;\n\tstruct hist_var_data *var_data;\n\n\tvar_data = find_hist_vars(hist_data);\n\tif (!var_data)\n\t\treturn;\n\n\tif (WARN_ON(check_var_refs(hist_data)))\n\t\treturn;\n\n\tlist_del(&var_data->list);\n\n\tkfree(var_data);\n\n\ttrace_array_put(tr);\n}"
  },
  {
    "function_name": "save_hist_vars",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
    "lines": "1018-1040",
    "snippet": "static int save_hist_vars(struct hist_trigger_data *hist_data)\n{\n\tstruct trace_array *tr = hist_data->event_file->tr;\n\tstruct hist_var_data *var_data;\n\n\tvar_data = find_hist_vars(hist_data);\n\tif (var_data)\n\t\treturn 0;\n\n\tif (tracing_check_open_get_tr(tr))\n\t\treturn -ENODEV;\n\n\tvar_data = kzalloc(sizeof(*var_data), GFP_KERNEL);\n\tif (!var_data) {\n\t\ttrace_array_put(tr);\n\t\treturn -ENOMEM;\n\t}\n\n\tvar_data->hist_data = hist_data;\n\tlist_add(&var_data->list, &tr->hist_vars);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include \"tracing_map.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&var_data->list",
            "&tr->hist_vars"
          ],
          "line": 1037
        },
        "resolved": true,
        "details": {
          "function_name": "cmp_filterlist_addrs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/debugfs.c",
          "lines": "95-101",
          "snippet": "static int cmp_filterlist_addrs(const void *rhs, const void *lhs)\n{\n\tconst unsigned long a = *(const unsigned long *)rhs;\n\tconst unsigned long b = *(const unsigned long *)lhs;\n\n\treturn a < b ? -1 : a == b ? 0 : 1;\n}",
          "includes": [
            "#include \"kcsan.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/bug.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kcsan.h\"\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/debugfs.h>\n#include <linux/bug.h>\n#include <linux/bsearch.h>\n#include <linux/atomic.h>\n\nstatic int cmp_filterlist_addrs(const void *rhs, const void *lhs)\n{\n\tconst unsigned long a = *(const unsigned long *)rhs;\n\tconst unsigned long b = *(const unsigned long *)lhs;\n\n\treturn a < b ? -1 : a == b ? 0 : 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_array_put",
          "args": [
            "tr"
          ],
          "line": 1032
        },
        "resolved": true,
        "details": {
          "function_name": "trace_array_put",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "474-482",
          "snippet": "void trace_array_put(struct trace_array *this_tr)\n{\n\tif (!this_tr)\n\t\treturn;\n\n\tmutex_lock(&trace_types_lock);\n\t__trace_array_put(this_tr);\n\tmutex_unlock(&trace_types_lock);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nvoid trace_array_put(struct trace_array *this_tr)\n{\n\tif (!this_tr)\n\t\treturn;\n\n\tmutex_lock(&trace_types_lock);\n\t__trace_array_put(this_tr);\n\tmutex_unlock(&trace_types_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*var_data)",
            "GFP_KERNEL"
          ],
          "line": 1030
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tracing_check_open_get_tr",
          "args": [
            "tr"
          ],
          "line": 1027
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_check_open_get_tr",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "485-500",
          "snippet": "int tracing_check_open_get_tr(struct trace_array *tr)\n{\n\tint ret;\n\n\tret = security_locked_down(LOCKDOWN_TRACEFS);\n\tif (ret)\n\t\treturn ret;\n\n\tif (tracing_disabled)\n\t\treturn -ENODEV;\n\n\tif (tr && trace_array_get(tr) < 0)\n\t\treturn -ENODEV;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int tracing_disabled = 1;",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic int tracing_disabled = 1;\nstatic __always_inline struct;\n\nint tracing_check_open_get_tr(struct trace_array *tr)\n{\n\tint ret;\n\n\tret = security_locked_down(LOCKDOWN_TRACEFS);\n\tif (ret)\n\t\treturn ret;\n\n\tif (tracing_disabled)\n\t\treturn -ENODEV;\n\n\tif (tr && trace_array_get(tr) < 0)\n\t\treturn -ENODEV;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_hist_vars",
          "args": [
            "hist_data"
          ],
          "line": 1023
        },
        "resolved": true,
        "details": {
          "function_name": "find_hist_vars",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "963-976",
          "snippet": "static struct hist_var_data *find_hist_vars(struct hist_trigger_data *hist_data)\n{\n\tstruct trace_array *tr = hist_data->event_file->tr;\n\tstruct hist_var_data *var_data, *found = NULL;\n\n\tlist_for_each_entry(var_data, &tr->hist_vars, list) {\n\t\tif (var_data->hist_data == hist_data) {\n\t\t\tfound = var_data;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn found;\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct hist_var_data *find_hist_vars(struct hist_trigger_data *hist_data)\n{\n\tstruct trace_array *tr = hist_data->event_file->tr;\n\tstruct hist_var_data *var_data, *found = NULL;\n\n\tlist_for_each_entry(var_data, &tr->hist_vars, list) {\n\t\tif (var_data->hist_data == hist_data) {\n\t\t\tfound = var_data;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn found;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int save_hist_vars(struct hist_trigger_data *hist_data)\n{\n\tstruct trace_array *tr = hist_data->event_file->tr;\n\tstruct hist_var_data *var_data;\n\n\tvar_data = find_hist_vars(hist_data);\n\tif (var_data)\n\t\treturn 0;\n\n\tif (tracing_check_open_get_tr(tr))\n\t\treturn -ENODEV;\n\n\tvar_data = kzalloc(sizeof(*var_data), GFP_KERNEL);\n\tif (!var_data) {\n\t\ttrace_array_put(tr);\n\t\treturn -ENOMEM;\n\t}\n\n\tvar_data->hist_data = hist_data;\n\tlist_add(&var_data->list, &tr->hist_vars);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "has_hist_vars",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
    "lines": "1004-1016",
    "snippet": "static bool has_hist_vars(struct hist_trigger_data *hist_data)\n{\n\tstruct hist_field *hist_field;\n\tint i;\n\n\tfor_each_hist_field(i, hist_data) {\n\t\thist_field = hist_data->fields[i];\n\t\tif (field_has_hist_vars(hist_field, 0))\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include \"tracing_map.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "field_has_hist_vars",
          "args": [
            "hist_field",
            "0"
          ],
          "line": 1011
        },
        "resolved": true,
        "details": {
          "function_name": "field_has_hist_vars",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "978-1002",
          "snippet": "static bool field_has_hist_vars(struct hist_field *hist_field,\n\t\t\t\tunsigned int level)\n{\n\tint i;\n\n\tif (level > 3)\n\t\treturn false;\n\n\tif (!hist_field)\n\t\treturn false;\n\n\tif (hist_field->flags & HIST_FIELD_FL_VAR ||\n\t    hist_field->flags & HIST_FIELD_FL_VAR_REF)\n\t\treturn true;\n\n\tfor (i = 0; i < HIST_FIELD_OPERANDS_MAX; i++) {\n\t\tstruct hist_field *operand;\n\n\t\toperand = hist_field->operands[i];\n\t\tif (field_has_hist_vars(operand, level + 1))\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define HIST_FIELD_OPERANDS_MAX\t2"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\n#define HIST_FIELD_OPERANDS_MAX\t2\n\nstatic bool field_has_hist_vars(struct hist_field *hist_field,\n\t\t\t\tunsigned int level)\n{\n\tint i;\n\n\tif (level > 3)\n\t\treturn false;\n\n\tif (!hist_field)\n\t\treturn false;\n\n\tif (hist_field->flags & HIST_FIELD_FL_VAR ||\n\t    hist_field->flags & HIST_FIELD_FL_VAR_REF)\n\t\treturn true;\n\n\tfor (i = 0; i < HIST_FIELD_OPERANDS_MAX; i++) {\n\t\tstruct hist_field *operand;\n\n\t\toperand = hist_field->operands[i];\n\t\tif (field_has_hist_vars(operand, level + 1))\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_hist_field",
          "args": [
            "i",
            "hist_data"
          ],
          "line": 1009
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic bool has_hist_vars(struct hist_trigger_data *hist_data)\n{\n\tstruct hist_field *hist_field;\n\tint i;\n\n\tfor_each_hist_field(i, hist_data) {\n\t\thist_field = hist_data->fields[i];\n\t\tif (field_has_hist_vars(hist_field, 0))\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}"
  },
  {
    "function_name": "field_has_hist_vars",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
    "lines": "978-1002",
    "snippet": "static bool field_has_hist_vars(struct hist_field *hist_field,\n\t\t\t\tunsigned int level)\n{\n\tint i;\n\n\tif (level > 3)\n\t\treturn false;\n\n\tif (!hist_field)\n\t\treturn false;\n\n\tif (hist_field->flags & HIST_FIELD_FL_VAR ||\n\t    hist_field->flags & HIST_FIELD_FL_VAR_REF)\n\t\treturn true;\n\n\tfor (i = 0; i < HIST_FIELD_OPERANDS_MAX; i++) {\n\t\tstruct hist_field *operand;\n\n\t\toperand = hist_field->operands[i];\n\t\tif (field_has_hist_vars(operand, level + 1))\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include \"tracing_map.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define HIST_FIELD_OPERANDS_MAX\t2"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "field_has_hist_vars",
          "args": [
            "operand",
            "level + 1"
          ],
          "line": 997
        },
        "resolved": true,
        "details": {
          "function_name": "field_has_hist_vars",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "978-1002",
          "snippet": "static bool field_has_hist_vars(struct hist_field *hist_field,\n\t\t\t\tunsigned int level)\n{\n\tint i;\n\n\tif (level > 3)\n\t\treturn false;\n\n\tif (!hist_field)\n\t\treturn false;\n\n\tif (hist_field->flags & HIST_FIELD_FL_VAR ||\n\t    hist_field->flags & HIST_FIELD_FL_VAR_REF)\n\t\treturn true;\n\n\tfor (i = 0; i < HIST_FIELD_OPERANDS_MAX; i++) {\n\t\tstruct hist_field *operand;\n\n\t\toperand = hist_field->operands[i];\n\t\tif (field_has_hist_vars(operand, level + 1))\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\n#define HIST_FIELD_OPERANDS_MAX\t2\n\nstatic bool field_has_hist_vars(struct hist_field *hist_field,\n\t\t\t\tunsigned int level)\n{\n\tint i;\n\n\tif (level > 3)\n\t\treturn false;\n\n\tif (!hist_field)\n\t\treturn false;\n\n\tif (hist_field->flags & HIST_FIELD_FL_VAR ||\n\t    hist_field->flags & HIST_FIELD_FL_VAR_REF)\n\t\treturn true;\n\n\tfor (i = 0; i < HIST_FIELD_OPERANDS_MAX; i++) {\n\t\tstruct hist_field *operand;\n\n\t\toperand = hist_field->operands[i];\n\t\tif (field_has_hist_vars(operand, level + 1))\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}"
  },
  {
    "function_name": "find_hist_vars",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
    "lines": "963-976",
    "snippet": "static struct hist_var_data *find_hist_vars(struct hist_trigger_data *hist_data)\n{\n\tstruct trace_array *tr = hist_data->event_file->tr;\n\tstruct hist_var_data *var_data, *found = NULL;\n\n\tlist_for_each_entry(var_data, &tr->hist_vars, list) {\n\t\tif (var_data->hist_data == hist_data) {\n\t\t\tfound = var_data;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn found;\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include \"tracing_map.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "var_data",
            "&tr->hist_vars",
            "list"
          ],
          "line": 968
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct hist_var_data *find_hist_vars(struct hist_trigger_data *hist_data)\n{\n\tstruct trace_array *tr = hist_data->event_file->tr;\n\tstruct hist_var_data *var_data, *found = NULL;\n\n\tlist_for_each_entry(var_data, &tr->hist_vars, list) {\n\t\tif (var_data->hist_data == hist_data) {\n\t\t\tfound = var_data;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn found;\n}"
  },
  {
    "function_name": "check_var_refs",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
    "lines": "944-961",
    "snippet": "static bool check_var_refs(struct hist_trigger_data *hist_data)\n{\n\tstruct hist_field *field;\n\tbool found = false;\n\tint i;\n\n\tfor_each_hist_field(i, hist_data) {\n\t\tfield = hist_data->fields[i];\n\t\tif (field && field->flags & HIST_FIELD_FL_VAR) {\n\t\t\tif (find_any_var_ref(hist_data, field->var.idx)) {\n\t\t\t\tfound = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn found;\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include \"tracing_map.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "find_any_var_ref",
          "args": [
            "hist_data",
            "field->var.idx"
          ],
          "line": 953
        },
        "resolved": true,
        "details": {
          "function_name": "find_any_var_ref",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "913-929",
          "snippet": "static struct hist_field *find_any_var_ref(struct hist_trigger_data *hist_data,\n\t\t\t\t\t   unsigned int var_idx)\n{\n\tstruct trace_array *tr = hist_data->event_file->tr;\n\tstruct hist_field *found = NULL;\n\tstruct hist_var_data *var_data;\n\n\tlist_for_each_entry(var_data, &tr->hist_vars, list) {\n\t\tif (var_data->hist_data == hist_data)\n\t\t\tcontinue;\n\t\tfound = find_var_ref(var_data->hist_data, hist_data, var_idx);\n\t\tif (found)\n\t\t\tbreak;\n\t}\n\n\treturn found;\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct hist_field *find_any_var_ref(struct hist_trigger_data *hist_data,\n\t\t\t\t\t   unsigned int var_idx)\n{\n\tstruct trace_array *tr = hist_data->event_file->tr;\n\tstruct hist_field *found = NULL;\n\tstruct hist_var_data *var_data;\n\n\tlist_for_each_entry(var_data, &tr->hist_vars, list) {\n\t\tif (var_data->hist_data == hist_data)\n\t\t\tcontinue;\n\t\tfound = find_var_ref(var_data->hist_data, hist_data, var_idx);\n\t\tif (found)\n\t\t\tbreak;\n\t}\n\n\treturn found;\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_hist_field",
          "args": [
            "i",
            "hist_data"
          ],
          "line": 950
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic bool check_var_refs(struct hist_trigger_data *hist_data)\n{\n\tstruct hist_field *field;\n\tbool found = false;\n\tint i;\n\n\tfor_each_hist_field(i, hist_data) {\n\t\tfield = hist_data->fields[i];\n\t\tif (field && field->flags & HIST_FIELD_FL_VAR) {\n\t\t\tif (find_any_var_ref(hist_data, field->var.idx)) {\n\t\t\t\tfound = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn found;\n}"
  },
  {
    "function_name": "find_any_var_ref",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
    "lines": "913-929",
    "snippet": "static struct hist_field *find_any_var_ref(struct hist_trigger_data *hist_data,\n\t\t\t\t\t   unsigned int var_idx)\n{\n\tstruct trace_array *tr = hist_data->event_file->tr;\n\tstruct hist_field *found = NULL;\n\tstruct hist_var_data *var_data;\n\n\tlist_for_each_entry(var_data, &tr->hist_vars, list) {\n\t\tif (var_data->hist_data == hist_data)\n\t\t\tcontinue;\n\t\tfound = find_var_ref(var_data->hist_data, hist_data, var_idx);\n\t\tif (found)\n\t\t\tbreak;\n\t}\n\n\treturn found;\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include \"tracing_map.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "find_var_ref",
          "args": [
            "var_data->hist_data",
            "hist_data",
            "var_idx"
          ],
          "line": 923
        },
        "resolved": true,
        "details": {
          "function_name": "find_var_ref",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "883-897",
          "snippet": "static struct hist_field *find_var_ref(struct hist_trigger_data *hist_data,\n\t\t\t\t       struct hist_trigger_data *var_data,\n\t\t\t\t       unsigned int var_idx)\n{\n\tstruct hist_field *hist_field;\n\tunsigned int i;\n\n\tfor (i = 0; i < hist_data->n_var_refs; i++) {\n\t\thist_field = hist_data->var_refs[i];\n\t\tif (check_field_for_var_ref(hist_field, var_data, var_idx))\n\t\t\treturn hist_field;\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct hist_field *find_var_ref(struct hist_trigger_data *hist_data,\n\t\t\t\t       struct hist_trigger_data *var_data,\n\t\t\t\t       unsigned int var_idx)\n{\n\tstruct hist_field *hist_field;\n\tunsigned int i;\n\n\tfor (i = 0; i < hist_data->n_var_refs; i++) {\n\t\thist_field = hist_data->var_refs[i];\n\t\tif (check_field_for_var_ref(hist_field, var_data, var_idx))\n\t\t\treturn hist_field;\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "var_data",
            "&tr->hist_vars",
            "list"
          ],
          "line": 920
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct hist_field *find_any_var_ref(struct hist_trigger_data *hist_data,\n\t\t\t\t\t   unsigned int var_idx)\n{\n\tstruct trace_array *tr = hist_data->event_file->tr;\n\tstruct hist_field *found = NULL;\n\tstruct hist_var_data *var_data;\n\n\tlist_for_each_entry(var_data, &tr->hist_vars, list) {\n\t\tif (var_data->hist_data == hist_data)\n\t\t\tcontinue;\n\t\tfound = find_var_ref(var_data->hist_data, hist_data, var_idx);\n\t\tif (found)\n\t\t\tbreak;\n\t}\n\n\treturn found;\n}"
  },
  {
    "function_name": "find_var_ref",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
    "lines": "883-897",
    "snippet": "static struct hist_field *find_var_ref(struct hist_trigger_data *hist_data,\n\t\t\t\t       struct hist_trigger_data *var_data,\n\t\t\t\t       unsigned int var_idx)\n{\n\tstruct hist_field *hist_field;\n\tunsigned int i;\n\n\tfor (i = 0; i < hist_data->n_var_refs; i++) {\n\t\thist_field = hist_data->var_refs[i];\n\t\tif (check_field_for_var_ref(hist_field, var_data, var_idx))\n\t\t\treturn hist_field;\n\t}\n\n\treturn NULL;\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include \"tracing_map.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "check_field_for_var_ref",
          "args": [
            "hist_field",
            "var_data",
            "var_idx"
          ],
          "line": 892
        },
        "resolved": true,
        "details": {
          "function_name": "check_field_for_var_ref",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "857-869",
          "snippet": "static struct hist_field *\ncheck_field_for_var_ref(struct hist_field *hist_field,\n\t\t\tstruct hist_trigger_data *var_data,\n\t\t\tunsigned int var_idx)\n{\n\tWARN_ON(!(hist_field && hist_field->flags & HIST_FIELD_FL_VAR_REF));\n\n\tif (hist_field && hist_field->var.idx == var_idx &&\n\t    hist_field->var.hist_data == var_data)\n\t\treturn hist_field;\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct hist_field *\ncheck_field_for_var_ref(struct hist_field *hist_field,\n\t\t\tstruct hist_trigger_data *var_data,\n\t\t\tunsigned int var_idx)\n{\n\tWARN_ON(!(hist_field && hist_field->flags & HIST_FIELD_FL_VAR_REF));\n\n\tif (hist_field && hist_field->var.idx == var_idx &&\n\t    hist_field->var.hist_data == var_data)\n\t\treturn hist_field;\n\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct hist_field *find_var_ref(struct hist_trigger_data *hist_data,\n\t\t\t\t       struct hist_trigger_data *var_data,\n\t\t\t\t       unsigned int var_idx)\n{\n\tstruct hist_field *hist_field;\n\tunsigned int i;\n\n\tfor (i = 0; i < hist_data->n_var_refs; i++) {\n\t\thist_field = hist_data->var_refs[i];\n\t\tif (check_field_for_var_ref(hist_field, var_data, var_idx))\n\t\t\treturn hist_field;\n\t}\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "check_field_for_var_ref",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
    "lines": "857-869",
    "snippet": "static struct hist_field *\ncheck_field_for_var_ref(struct hist_field *hist_field,\n\t\t\tstruct hist_trigger_data *var_data,\n\t\t\tunsigned int var_idx)\n{\n\tWARN_ON(!(hist_field && hist_field->flags & HIST_FIELD_FL_VAR_REF));\n\n\tif (hist_field && hist_field->var.idx == var_idx &&\n\t    hist_field->var.hist_data == var_data)\n\t\treturn hist_field;\n\n\treturn NULL;\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include \"tracing_map.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!(hist_field && hist_field->flags & HIST_FIELD_FL_VAR_REF)"
          ],
          "line": 862
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct hist_field *\ncheck_field_for_var_ref(struct hist_field *hist_field,\n\t\t\tstruct hist_trigger_data *var_data,\n\t\t\tunsigned int var_idx)\n{\n\tWARN_ON(!(hist_field && hist_field->flags & HIST_FIELD_FL_VAR_REF));\n\n\tif (hist_field && hist_field->var.idx == var_idx &&\n\t    hist_field->var.hist_data == var_data)\n\t\treturn hist_field;\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "hist_field_cpu",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
    "lines": "835-844",
    "snippet": "static u64 hist_field_cpu(struct hist_field *hist_field,\n\t\t\t  struct tracing_map_elt *elt,\n\t\t\t  struct trace_buffer *buffer,\n\t\t\t  struct ring_buffer_event *rbe,\n\t\t\t  void *event)\n{\n\tint cpu = smp_processor_id();\n\n\treturn cpu;\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include \"tracing_map.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 841
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic u64 hist_field_cpu(struct hist_field *hist_field,\n\t\t\t  struct tracing_map_elt *elt,\n\t\t\t  struct trace_buffer *buffer,\n\t\t\t  struct ring_buffer_event *rbe,\n\t\t\t  void *event)\n{\n\tint cpu = smp_processor_id();\n\n\treturn cpu;\n}"
  },
  {
    "function_name": "hist_field_timestamp",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
    "lines": "818-833",
    "snippet": "static u64 hist_field_timestamp(struct hist_field *hist_field,\n\t\t\t\tstruct tracing_map_elt *elt,\n\t\t\t\tstruct trace_buffer *buffer,\n\t\t\t\tstruct ring_buffer_event *rbe,\n\t\t\t\tvoid *event)\n{\n\tstruct hist_trigger_data *hist_data = hist_field->hist_data;\n\tstruct trace_array *tr = hist_data->event_file->tr;\n\n\tu64 ts = ring_buffer_event_time_stamp(buffer, rbe);\n\n\tif (hist_data->attrs->ts_in_usecs && trace_clock_in_ns(tr))\n\t\tts = ns2usecs(ts);\n\n\treturn ts;\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include \"tracing_map.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ns2usecs",
          "args": [
            "ts"
          ],
          "line": 830
        },
        "resolved": true,
        "details": {
          "function_name": "ns2usecs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "268-273",
          "snippet": "unsigned long long ns2usecs(u64 nsec)\n{\n\tnsec += 500;\n\tdo_div(nsec, 1000);\n\treturn nsec;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nunsigned long long ns2usecs(u64 nsec)\n{\n\tnsec += 500;\n\tdo_div(nsec, 1000);\n\treturn nsec;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_clock_in_ns",
          "args": [
            "tr"
          ],
          "line": 829
        },
        "resolved": true,
        "details": {
          "function_name": "trace_clock_in_ns",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "1532-1538",
          "snippet": "bool trace_clock_in_ns(struct trace_array *tr)\n{\n\tif (trace_clocks[tr->clock_id].in_ns)\n\t\treturn true;\n\n\treturn false;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct",
            "static struct {\n\tu64 (*func)(void);\n\tconst char *name;\n\tint in_ns;\t\t/* is this clock in nanoseconds? */\n} trace_clocks[] = {\n\t{ trace_clock_local,\t\t\"local\",\t1 },\n\t{ trace_clock_global,\t\t\"global\",\t1 },\n\t{ trace_clock_counter,\t\t\"counter\",\t0 },\n\t{ trace_clock_jiffies,\t\t\"uptime\",\t0 },\n\t{ trace_clock,\t\t\t\"perf\",\t\t1 },\n\t{ ktime_get_mono_fast_ns,\t\"mono\",\t\t1 },\n\t{ ktime_get_raw_fast_ns,\t\"mono_raw\",\t1 },\n\t{ ktime_get_boot_fast_ns,\t\"boot\",\t\t1 },\n\tARCH_TRACE_CLOCKS\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\nstatic struct {\n\tu64 (*func)(void);\n\tconst char *name;\n\tint in_ns;\t\t/* is this clock in nanoseconds? */\n} trace_clocks[] = {\n\t{ trace_clock_local,\t\t\"local\",\t1 },\n\t{ trace_clock_global,\t\t\"global\",\t1 },\n\t{ trace_clock_counter,\t\t\"counter\",\t0 },\n\t{ trace_clock_jiffies,\t\t\"uptime\",\t0 },\n\t{ trace_clock,\t\t\t\"perf\",\t\t1 },\n\t{ ktime_get_mono_fast_ns,\t\"mono\",\t\t1 },\n\t{ ktime_get_raw_fast_ns,\t\"mono_raw\",\t1 },\n\t{ ktime_get_boot_fast_ns,\t\"boot\",\t\t1 },\n\tARCH_TRACE_CLOCKS\n};\n\nbool trace_clock_in_ns(struct trace_array *tr)\n{\n\tif (trace_clocks[tr->clock_id].in_ns)\n\t\treturn true;\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ring_buffer_event_time_stamp",
          "args": [
            "buffer",
            "rbe"
          ],
          "line": 827
        },
        "resolved": true,
        "details": {
          "function_name": "ring_buffer_event_time_stamp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ring_buffer.c",
          "lines": "806-836",
          "snippet": "u64 ring_buffer_event_time_stamp(struct trace_buffer *buffer,\n\t\t\t\t struct ring_buffer_event *event)\n{\n\tstruct ring_buffer_per_cpu *cpu_buffer = buffer->buffers[smp_processor_id()];\n\tunsigned int nest;\n\tu64 ts;\n\n\t/* If the event includes an absolute time, then just use that */\n\tif (event->type_len == RINGBUF_TYPE_TIME_STAMP)\n\t\treturn rb_event_time_stamp(event);\n\n\tnest = local_read(&cpu_buffer->committing);\n\tverify_event(cpu_buffer, event);\n\tif (WARN_ON_ONCE(!nest))\n\t\tgoto fail;\n\n\t/* Read the current saved nesting level time stamp */\n\tif (likely(--nest < MAX_NEST))\n\t\treturn cpu_buffer->event_stamp[nest];\n\n\t/* Shouldn't happen, warn if it does */\n\tWARN_ONCE(1, \"nest (%d) greater than max\", nest);\n\n fail:\n\t/* Can only fail on 32 bit */\n\tif (!rb_time_read(&cpu_buffer->write_stamp, &ts))\n\t\t/* Screw it, just read the current time */\n\t\tts = rb_time_stamp(cpu_buffer->buffer);\n\n\treturn ts;\n}",
          "includes": [
            "#include <asm/local64.h>",
            "#include <asm/local.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/list.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/delay.h>",
            "#include <linux/mutex.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>\t/* for self test */",
            "#include <linux/hardirq.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/security.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_recursion.h>"
          ],
          "macros_used": [
            "#define MAX_NEST\t5"
          ],
          "globals_used": [
            "static inline u64 rb_time_stamp(struct trace_buffer *buffer);",
            "static void rb_reset_cpu(struct ring_buffer_per_cpu *cpu_buffer);",
            "static __always_inline struct",
            "static inline void rb_end_commit(struct ring_buffer_per_cpu *cpu_buffer);",
            "static noinline struct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/local64.h>\n#include <asm/local.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/mutex.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\t/* for self test */\n#include <linux/hardirq.h>\n#include <linux/uaccess.h>\n#include <linux/security.h>\n#include <linux/irq_work.h>\n#include <linux/spinlock.h>\n#include <linux/trace_seq.h>\n#include <linux/sched/clock.h>\n#include <linux/trace_clock.h>\n#include <linux/ring_buffer.h>\n#include <linux/trace_events.h>\n#include <linux/trace_recursion.h>\n\n#define MAX_NEST\t5\n\nstatic inline u64 rb_time_stamp(struct trace_buffer *buffer);\nstatic void rb_reset_cpu(struct ring_buffer_per_cpu *cpu_buffer);\nstatic __always_inline struct;\nstatic inline void rb_end_commit(struct ring_buffer_per_cpu *cpu_buffer);\nstatic noinline struct;\nstatic __always_inline struct;\n\nu64 ring_buffer_event_time_stamp(struct trace_buffer *buffer,\n\t\t\t\t struct ring_buffer_event *event)\n{\n\tstruct ring_buffer_per_cpu *cpu_buffer = buffer->buffers[smp_processor_id()];\n\tunsigned int nest;\n\tu64 ts;\n\n\t/* If the event includes an absolute time, then just use that */\n\tif (event->type_len == RINGBUF_TYPE_TIME_STAMP)\n\t\treturn rb_event_time_stamp(event);\n\n\tnest = local_read(&cpu_buffer->committing);\n\tverify_event(cpu_buffer, event);\n\tif (WARN_ON_ONCE(!nest))\n\t\tgoto fail;\n\n\t/* Read the current saved nesting level time stamp */\n\tif (likely(--nest < MAX_NEST))\n\t\treturn cpu_buffer->event_stamp[nest];\n\n\t/* Shouldn't happen, warn if it does */\n\tWARN_ONCE(1, \"nest (%d) greater than max\", nest);\n\n fail:\n\t/* Can only fail on 32 bit */\n\tif (!rb_time_read(&cpu_buffer->write_stamp, &ts))\n\t\t/* Screw it, just read the current time */\n\t\tts = rb_time_stamp(cpu_buffer->buffer);\n\n\treturn ts;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic u64 hist_field_timestamp(struct hist_field *hist_field,\n\t\t\t\tstruct tracing_map_elt *elt,\n\t\t\t\tstruct trace_buffer *buffer,\n\t\t\t\tstruct ring_buffer_event *rbe,\n\t\t\t\tvoid *event)\n{\n\tstruct hist_trigger_data *hist_data = hist_field->hist_data;\n\tstruct trace_array *tr = hist_data->event_file->tr;\n\n\tu64 ts = ring_buffer_event_time_stamp(buffer, rbe);\n\n\tif (hist_data->attrs->ts_in_usecs && trace_clock_in_ns(tr))\n\t\tts = ns2usecs(ts);\n\n\treturn ts;\n}"
  },
  {
    "function_name": "action_trace",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
    "lines": "802-811",
    "snippet": "static void action_trace(struct hist_trigger_data *hist_data,\n\t\t\t struct tracing_map_elt *elt,\n\t\t\t struct trace_buffer *buffer, void *rec,\n\t\t\t struct ring_buffer_event *rbe, void *key,\n\t\t\t struct action_data *data, u64 *var_ref_vals)\n{\n\tstruct synth_event *event = data->synth_event;\n\n\ttrace_synth(event, var_ref_vals, data->var_ref_idx);\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include \"tracing_map.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_synth",
          "args": [
            "event",
            "var_ref_vals",
            "data->var_ref_idx"
          ],
          "line": 810
        },
        "resolved": true,
        "details": {
          "function_name": "trace_synth",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "778-800",
          "snippet": "static inline void trace_synth(struct synth_event *event, u64 *var_ref_vals,\n\t\t\t       unsigned int *var_ref_idx)\n{\n\tstruct tracepoint *tp = event->tp;\n\n\tif (unlikely(atomic_read(&tp->key.enabled) > 0)) {\n\t\tstruct tracepoint_func *probe_func_ptr;\n\t\tsynth_probe_func_t probe_func;\n\t\tvoid *__data;\n\n\t\tif (!(cpu_online(raw_smp_processor_id())))\n\t\t\treturn;\n\n\t\tprobe_func_ptr = rcu_dereference_sched((tp)->funcs);\n\t\tif (probe_func_ptr) {\n\t\t\tdo {\n\t\t\t\tprobe_func = probe_func_ptr->func;\n\t\t\t\t__data = probe_func_ptr->data;\n\t\t\t\tprobe_func(__data, var_ref_vals, var_ref_idx);\n\t\t\t} while ((++probe_func_ptr)->func);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);\n\nstatic inline void trace_synth(struct synth_event *event, u64 *var_ref_vals,\n\t\t\t       unsigned int *var_ref_idx)\n{\n\tstruct tracepoint *tp = event->tp;\n\n\tif (unlikely(atomic_read(&tp->key.enabled) > 0)) {\n\t\tstruct tracepoint_func *probe_func_ptr;\n\t\tsynth_probe_func_t probe_func;\n\t\tvoid *__data;\n\n\t\tif (!(cpu_online(raw_smp_processor_id())))\n\t\t\treturn;\n\n\t\tprobe_func_ptr = rcu_dereference_sched((tp)->funcs);\n\t\tif (probe_func_ptr) {\n\t\t\tdo {\n\t\t\t\tprobe_func = probe_func_ptr->func;\n\t\t\t\t__data = probe_func_ptr->data;\n\t\t\t\tprobe_func(__data, var_ref_vals, var_ref_idx);\n\t\t\t} while ((++probe_func_ptr)->func);\n\t\t}\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);\n\nstatic void action_trace(struct hist_trigger_data *hist_data,\n\t\t\t struct tracing_map_elt *elt,\n\t\t\t struct trace_buffer *buffer, void *rec,\n\t\t\t struct ring_buffer_event *rbe, void *key,\n\t\t\t struct action_data *data, u64 *var_ref_vals)\n{\n\tstruct synth_event *event = data->synth_event;\n\n\ttrace_synth(event, var_ref_vals, data->var_ref_idx);\n}"
  },
  {
    "function_name": "trace_synth",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
    "lines": "778-800",
    "snippet": "static inline void trace_synth(struct synth_event *event, u64 *var_ref_vals,\n\t\t\t       unsigned int *var_ref_idx)\n{\n\tstruct tracepoint *tp = event->tp;\n\n\tif (unlikely(atomic_read(&tp->key.enabled) > 0)) {\n\t\tstruct tracepoint_func *probe_func_ptr;\n\t\tsynth_probe_func_t probe_func;\n\t\tvoid *__data;\n\n\t\tif (!(cpu_online(raw_smp_processor_id())))\n\t\t\treturn;\n\n\t\tprobe_func_ptr = rcu_dereference_sched((tp)->funcs);\n\t\tif (probe_func_ptr) {\n\t\t\tdo {\n\t\t\t\tprobe_func = probe_func_ptr->func;\n\t\t\t\t__data = probe_func_ptr->data;\n\t\t\t\tprobe_func(__data, var_ref_vals, var_ref_idx);\n\t\t\t} while ((++probe_func_ptr)->func);\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include \"tracing_map.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "probe_func",
          "args": [
            "__data",
            "var_ref_vals",
            "var_ref_idx"
          ],
          "line": 796
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_ftrace_function_probe_func",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "4684-4811",
          "snippet": "int\nunregister_ftrace_function_probe_func(char *glob, struct trace_array *tr,\n\t\t\t\t      struct ftrace_probe_ops *probe_ops)\n{\n\tstruct ftrace_ops_hash old_hash_ops;\n\tstruct ftrace_func_entry *entry;\n\tstruct ftrace_func_probe *probe;\n\tstruct ftrace_glob func_g;\n\tstruct ftrace_hash **orig_hash;\n\tstruct ftrace_hash *old_hash;\n\tstruct ftrace_hash *hash = NULL;\n\tstruct hlist_node *tmp;\n\tstruct hlist_head hhd;\n\tchar str[KSYM_SYMBOL_LEN];\n\tint count = 0;\n\tint i, ret = -ENODEV;\n\tint size;\n\n\tif (!glob || !strlen(glob) || !strcmp(glob, \"*\"))\n\t\tfunc_g.search = NULL;\n\telse {\n\t\tint not;\n\n\t\tfunc_g.type = filter_parse_regex(glob, strlen(glob),\n\t\t\t\t\t\t &func_g.search, &not);\n\t\tfunc_g.len = strlen(func_g.search);\n\n\t\t/* we do not support '!' for function probes */\n\t\tif (WARN_ON(not))\n\t\t\treturn -EINVAL;\n\t}\n\n\tmutex_lock(&ftrace_lock);\n\t/* Check if the probe_ops is already registered */\n\tlist_for_each_entry(probe, &tr->func_probes, list) {\n\t\tif (probe->probe_ops == probe_ops)\n\t\t\tbreak;\n\t}\n\tif (&probe->list == &tr->func_probes)\n\t\tgoto err_unlock_ftrace;\n\n\tret = -EINVAL;\n\tif (!(probe->ops.flags & FTRACE_OPS_FL_INITIALIZED))\n\t\tgoto err_unlock_ftrace;\n\n\tacquire_probe_locked(probe);\n\n\tmutex_unlock(&ftrace_lock);\n\n\tmutex_lock(&probe->ops.func_hash->regex_lock);\n\n\torig_hash = &probe->ops.func_hash->filter_hash;\n\told_hash = *orig_hash;\n\n\tif (ftrace_hash_empty(old_hash))\n\t\tgoto out_unlock;\n\n\told_hash_ops.filter_hash = old_hash;\n\t/* Probes only have filters */\n\told_hash_ops.notrace_hash = NULL;\n\n\tret = -ENOMEM;\n\thash = alloc_and_copy_ftrace_hash(FTRACE_HASH_DEFAULT_BITS, old_hash);\n\tif (!hash)\n\t\tgoto out_unlock;\n\n\tINIT_HLIST_HEAD(&hhd);\n\n\tsize = 1 << hash->size_bits;\n\tfor (i = 0; i < size; i++) {\n\t\thlist_for_each_entry_safe(entry, tmp, &hash->buckets[i], hlist) {\n\n\t\t\tif (func_g.search) {\n\t\t\t\tkallsyms_lookup(entry->ip, NULL, NULL,\n\t\t\t\t\t\tNULL, str);\n\t\t\t\tif (!ftrace_match(str, &func_g))\n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tcount++;\n\t\t\tremove_hash_entry(hash, entry);\n\t\t\thlist_add_head(&entry->hlist, &hhd);\n\t\t}\n\t}\n\n\t/* Nothing found? */\n\tif (!count) {\n\t\tret = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\tmutex_lock(&ftrace_lock);\n\n\tWARN_ON(probe->ref < count);\n\n\tprobe->ref -= count;\n\n\tif (ftrace_hash_empty(hash))\n\t\tftrace_shutdown(&probe->ops, 0);\n\n\tret = ftrace_hash_move_and_update_ops(&probe->ops, orig_hash,\n\t\t\t\t\t      hash, 1);\n\n\t/* still need to update the function call sites */\n\tif (ftrace_enabled && !ftrace_hash_empty(hash))\n\t\tftrace_run_modify_code(&probe->ops, FTRACE_UPDATE_CALLS,\n\t\t\t\t       &old_hash_ops);\n\tsynchronize_rcu();\n\n\thlist_for_each_entry_safe(entry, tmp, &hhd, hlist) {\n\t\thlist_del(&entry->hlist);\n\t\tif (probe_ops->free)\n\t\t\tprobe_ops->free(probe_ops, tr, entry->ip, probe->data);\n\t\tkfree(entry);\n\t}\n\tmutex_unlock(&ftrace_lock);\n\n out_unlock:\n\tmutex_unlock(&probe->ops.func_hash->regex_lock);\n\tfree_ftrace_hash(hash);\n\n\trelease_probe(probe);\n\n\treturn ret;\n\n err_unlock_ftrace:\n\tmutex_unlock(&ftrace_lock);\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [
            "#define FTRACE_HASH_DEFAULT_BITS 10"
          ],
          "globals_used": [
            "int ftrace_enabled",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\n#define FTRACE_HASH_DEFAULT_BITS 10\n\nint ftrace_enabled;\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nint\nunregister_ftrace_function_probe_func(char *glob, struct trace_array *tr,\n\t\t\t\t      struct ftrace_probe_ops *probe_ops)\n{\n\tstruct ftrace_ops_hash old_hash_ops;\n\tstruct ftrace_func_entry *entry;\n\tstruct ftrace_func_probe *probe;\n\tstruct ftrace_glob func_g;\n\tstruct ftrace_hash **orig_hash;\n\tstruct ftrace_hash *old_hash;\n\tstruct ftrace_hash *hash = NULL;\n\tstruct hlist_node *tmp;\n\tstruct hlist_head hhd;\n\tchar str[KSYM_SYMBOL_LEN];\n\tint count = 0;\n\tint i, ret = -ENODEV;\n\tint size;\n\n\tif (!glob || !strlen(glob) || !strcmp(glob, \"*\"))\n\t\tfunc_g.search = NULL;\n\telse {\n\t\tint not;\n\n\t\tfunc_g.type = filter_parse_regex(glob, strlen(glob),\n\t\t\t\t\t\t &func_g.search, &not);\n\t\tfunc_g.len = strlen(func_g.search);\n\n\t\t/* we do not support '!' for function probes */\n\t\tif (WARN_ON(not))\n\t\t\treturn -EINVAL;\n\t}\n\n\tmutex_lock(&ftrace_lock);\n\t/* Check if the probe_ops is already registered */\n\tlist_for_each_entry(probe, &tr->func_probes, list) {\n\t\tif (probe->probe_ops == probe_ops)\n\t\t\tbreak;\n\t}\n\tif (&probe->list == &tr->func_probes)\n\t\tgoto err_unlock_ftrace;\n\n\tret = -EINVAL;\n\tif (!(probe->ops.flags & FTRACE_OPS_FL_INITIALIZED))\n\t\tgoto err_unlock_ftrace;\n\n\tacquire_probe_locked(probe);\n\n\tmutex_unlock(&ftrace_lock);\n\n\tmutex_lock(&probe->ops.func_hash->regex_lock);\n\n\torig_hash = &probe->ops.func_hash->filter_hash;\n\told_hash = *orig_hash;\n\n\tif (ftrace_hash_empty(old_hash))\n\t\tgoto out_unlock;\n\n\told_hash_ops.filter_hash = old_hash;\n\t/* Probes only have filters */\n\told_hash_ops.notrace_hash = NULL;\n\n\tret = -ENOMEM;\n\thash = alloc_and_copy_ftrace_hash(FTRACE_HASH_DEFAULT_BITS, old_hash);\n\tif (!hash)\n\t\tgoto out_unlock;\n\n\tINIT_HLIST_HEAD(&hhd);\n\n\tsize = 1 << hash->size_bits;\n\tfor (i = 0; i < size; i++) {\n\t\thlist_for_each_entry_safe(entry, tmp, &hash->buckets[i], hlist) {\n\n\t\t\tif (func_g.search) {\n\t\t\t\tkallsyms_lookup(entry->ip, NULL, NULL,\n\t\t\t\t\t\tNULL, str);\n\t\t\t\tif (!ftrace_match(str, &func_g))\n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tcount++;\n\t\t\tremove_hash_entry(hash, entry);\n\t\t\thlist_add_head(&entry->hlist, &hhd);\n\t\t}\n\t}\n\n\t/* Nothing found? */\n\tif (!count) {\n\t\tret = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\tmutex_lock(&ftrace_lock);\n\n\tWARN_ON(probe->ref < count);\n\n\tprobe->ref -= count;\n\n\tif (ftrace_hash_empty(hash))\n\t\tftrace_shutdown(&probe->ops, 0);\n\n\tret = ftrace_hash_move_and_update_ops(&probe->ops, orig_hash,\n\t\t\t\t\t      hash, 1);\n\n\t/* still need to update the function call sites */\n\tif (ftrace_enabled && !ftrace_hash_empty(hash))\n\t\tftrace_run_modify_code(&probe->ops, FTRACE_UPDATE_CALLS,\n\t\t\t\t       &old_hash_ops);\n\tsynchronize_rcu();\n\n\thlist_for_each_entry_safe(entry, tmp, &hhd, hlist) {\n\t\thlist_del(&entry->hlist);\n\t\tif (probe_ops->free)\n\t\t\tprobe_ops->free(probe_ops, tr, entry->ip, probe->data);\n\t\tkfree(entry);\n\t}\n\tmutex_unlock(&ftrace_lock);\n\n out_unlock:\n\tmutex_unlock(&probe->ops.func_hash->regex_lock);\n\tfree_ftrace_hash(hash);\n\n\trelease_probe(probe);\n\n\treturn ret;\n\n err_unlock_ftrace:\n\tmutex_unlock(&ftrace_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_dereference_sched",
          "args": [
            "(tp)->funcs"
          ],
          "line": 791
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_online",
          "args": [
            "raw_smp_processor_id()"
          ],
          "line": 788
        },
        "resolved": true,
        "details": {
          "function_name": "init_cpu_online",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "2616-2619",
          "snippet": "void init_cpu_online(const struct cpumask *src)\n{\n\tcpumask_copy(&__cpu_online_mask, src);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct cpumask __cpu_online_mask"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstruct cpumask __cpu_online_mask;\n\nvoid init_cpu_online(const struct cpumask *src)\n{\n\tcpumask_copy(&__cpu_online_mask, src);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_smp_processor_id",
          "args": [],
          "line": 788
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "atomic_read(&tp->key.enabled) > 0"
          ],
          "line": 783
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&tp->key.enabled"
          ],
          "line": 783
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);\n\nstatic inline void trace_synth(struct synth_event *event, u64 *var_ref_vals,\n\t\t\t       unsigned int *var_ref_idx)\n{\n\tstruct tracepoint *tp = event->tp;\n\n\tif (unlikely(atomic_read(&tp->key.enabled) > 0)) {\n\t\tstruct tracepoint_func *probe_func_ptr;\n\t\tsynth_probe_func_t probe_func;\n\t\tvoid *__data;\n\n\t\tif (!(cpu_online(raw_smp_processor_id())))\n\t\t\treturn;\n\n\t\tprobe_func_ptr = rcu_dereference_sched((tp)->funcs);\n\t\tif (probe_func_ptr) {\n\t\t\tdo {\n\t\t\t\tprobe_func = probe_func_ptr->func;\n\t\t\t\t__data = probe_func_ptr->data;\n\t\t\t\tprobe_func(__data, var_ref_vals, var_ref_idx);\n\t\t\t} while ((++probe_func_ptr)->func);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "hist_err_clear",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
    "lines": "769-773",
    "snippet": "static void hist_err_clear(void)\n{\n\tlast_cmd[0] = '\\0';\n\tlast_cmd_loc[0] = '\\0';\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include \"tracing_map.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static char last_cmd[MAX_FILTER_STR_VAL];",
      "static char last_cmd_loc[MAX_FILTER_STR_VAL];"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic char last_cmd[MAX_FILTER_STR_VAL];\nstatic char last_cmd_loc[MAX_FILTER_STR_VAL];\n\nstatic void hist_err_clear(void)\n{\n\tlast_cmd[0] = '\\0';\n\tlast_cmd_loc[0] = '\\0';\n}"
  },
  {
    "function_name": "hist_err",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
    "lines": "763-767",
    "snippet": "static void hist_err(struct trace_array *tr, u8 err_type, u8 err_pos)\n{\n\ttracing_log_err(tr, last_cmd_loc, last_cmd, err_text,\n\t\t\terr_type, err_pos);\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include \"tracing_map.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const char *err_text[] = { ERRORS };",
      "static char last_cmd[MAX_FILTER_STR_VAL];",
      "static char last_cmd_loc[MAX_FILTER_STR_VAL];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tracing_log_err",
          "args": [
            "tr",
            "last_cmd_loc",
            "last_cmd",
            "err_text",
            "err_type",
            "err_pos"
          ],
          "line": 765
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_log_err",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "7807-7833",
          "snippet": "void tracing_log_err(struct trace_array *tr,\n\t\t     const char *loc, const char *cmd,\n\t\t     const char **errs, u8 type, u8 pos)\n{\n\tstruct tracing_log_err *err;\n\n\tif (!tr)\n\t\ttr = &global_trace;\n\n\tmutex_lock(&tracing_err_log_lock);\n\terr = get_tracing_log_err(tr);\n\tif (PTR_ERR(err) == -ENOMEM) {\n\t\tmutex_unlock(&tracing_err_log_lock);\n\t\treturn;\n\t}\n\n\tsnprintf(err->loc, TRACING_LOG_LOC_MAX, \"%s: error: \", loc);\n\tsnprintf(err->cmd, MAX_FILTER_STR_VAL,\"\\n\" CMD_PREFIX \"%s\\n\", cmd);\n\n\terr->info.errs = errs;\n\terr->info.type = type;\n\terr->info.pos = pos;\n\terr->info.ts = local_clock();\n\n\tlist_add_tail(&err->list, &tr->err_log);\n\tmutex_unlock(&tracing_err_log_lock);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [
            "#define CMD_PREFIX \"  Command: \"",
            "#define TRACING_LOG_LOC_MAX\t128"
          ],
          "globals_used": [
            "static struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};",
            "static __always_inline struct",
            "static DEFINE_MUTEX(tracing_err_log_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\n#define CMD_PREFIX \"  Command: \"\n#define TRACING_LOG_LOC_MAX\t128\n\nstatic struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};\nstatic __always_inline struct;\nstatic DEFINE_MUTEX(tracing_err_log_lock);\n\nvoid tracing_log_err(struct trace_array *tr,\n\t\t     const char *loc, const char *cmd,\n\t\t     const char **errs, u8 type, u8 pos)\n{\n\tstruct tracing_log_err *err;\n\n\tif (!tr)\n\t\ttr = &global_trace;\n\n\tmutex_lock(&tracing_err_log_lock);\n\terr = get_tracing_log_err(tr);\n\tif (PTR_ERR(err) == -ENOMEM) {\n\t\tmutex_unlock(&tracing_err_log_lock);\n\t\treturn;\n\t}\n\n\tsnprintf(err->loc, TRACING_LOG_LOC_MAX, \"%s: error: \", loc);\n\tsnprintf(err->cmd, MAX_FILTER_STR_VAL,\"\\n\" CMD_PREFIX \"%s\\n\", cmd);\n\n\terr->info.errs = errs;\n\terr->info.type = type;\n\terr->info.pos = pos;\n\terr->info.ts = local_clock();\n\n\tlist_add_tail(&err->list, &tr->err_log);\n\tmutex_unlock(&tracing_err_log_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic const char *err_text[] = { ERRORS };\nstatic char last_cmd[MAX_FILTER_STR_VAL];\nstatic char last_cmd_loc[MAX_FILTER_STR_VAL];\n\nstatic void hist_err(struct trace_array *tr, u8 err_type, u8 err_pos)\n{\n\ttracing_log_err(tr, last_cmd_loc, last_cmd, err_text,\n\t\t\terr_type, err_pos);\n}"
  },
  {
    "function_name": "last_cmd_set",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
    "lines": "738-761",
    "snippet": "static void last_cmd_set(struct trace_event_file *file, char *str)\n{\n\tconst char *system = NULL, *name = NULL;\n\tstruct trace_event_call *call;\n\n\tif (!str)\n\t\treturn;\n\n\tstrcpy(last_cmd, \"hist:\");\n\tstrncat(last_cmd, str, MAX_FILTER_STR_VAL - 1 - sizeof(\"hist:\"));\n\n\tif (file) {\n\t\tcall = file->event_call;\n\t\tsystem = call->class->system;\n\t\tif (system) {\n\t\t\tname = trace_event_name(call);\n\t\t\tif (!name)\n\t\t\t\tsystem = NULL;\n\t\t}\n\t}\n\n\tif (system)\n\t\tsnprintf(last_cmd_loc, MAX_FILTER_STR_VAL, \"hist:%s:%s\", system, name);\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include \"tracing_map.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static char last_cmd[MAX_FILTER_STR_VAL];",
      "static char last_cmd_loc[MAX_FILTER_STR_VAL];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "last_cmd_loc",
            "MAX_FILTER_STR_VAL",
            "\"hist:%s:%s\"",
            "system",
            "name"
          ],
          "line": 760
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_event_name",
          "args": [
            "call"
          ],
          "line": 753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncat",
          "args": [
            "last_cmd",
            "str",
            "MAX_FILTER_STR_VAL - 1 - sizeof(\"hist:\")"
          ],
          "line": 747
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "last_cmd",
            "\"hist:\""
          ],
          "line": 746
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic char last_cmd[MAX_FILTER_STR_VAL];\nstatic char last_cmd_loc[MAX_FILTER_STR_VAL];\n\nstatic void last_cmd_set(struct trace_event_file *file, char *str)\n{\n\tconst char *system = NULL, *name = NULL;\n\tstruct trace_event_call *call;\n\n\tif (!str)\n\t\treturn;\n\n\tstrcpy(last_cmd, \"hist:\");\n\tstrncat(last_cmd, str, MAX_FILTER_STR_VAL - 1 - sizeof(\"hist:\"));\n\n\tif (file) {\n\t\tcall = file->event_call;\n\t\tsystem = call->class->system;\n\t\tif (system) {\n\t\t\tname = trace_event_name(call);\n\t\t\tif (!name)\n\t\t\t\tsystem = NULL;\n\t\t}\n\t}\n\n\tif (system)\n\t\tsnprintf(last_cmd_loc, MAX_FILTER_STR_VAL, \"hist:%s:%s\", system, name);\n}"
  },
  {
    "function_name": "errpos",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
    "lines": "733-736",
    "snippet": "static int errpos(char *str)\n{\n\treturn err_pos(last_cmd, str);\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include \"tracing_map.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static char last_cmd[MAX_FILTER_STR_VAL];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "err_pos",
          "args": [
            "last_cmd",
            "str"
          ],
          "line": 735
        },
        "resolved": true,
        "details": {
          "function_name": "err_pos",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "7766-7778",
          "snippet": "unsigned int err_pos(char *cmd, const char *str)\n{\n\tchar *found;\n\n\tif (WARN_ON(!strlen(cmd)))\n\t\treturn 0;\n\n\tfound = strstr(cmd, str);\n\tif (found)\n\t\treturn found - cmd;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nunsigned int err_pos(char *cmd, const char *str)\n{\n\tchar *found;\n\n\tif (WARN_ON(!strlen(cmd)))\n\t\treturn 0;\n\n\tfound = strstr(cmd, str);\n\tif (found)\n\t\treturn found - cmd;\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic char last_cmd[MAX_FILTER_STR_VAL];\n\nstatic int errpos(char *str)\n{\n\treturn err_pos(last_cmd, str);\n}"
  },
  {
    "function_name": "track_data_alloc",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
    "lines": "693-728",
    "snippet": "static struct track_data *track_data_alloc(unsigned int key_len,\n\t\t\t\t\t   struct action_data *action_data,\n\t\t\t\t\t   struct hist_trigger_data *hist_data)\n{\n\tstruct track_data *data = kzalloc(sizeof(*data), GFP_KERNEL);\n\tstruct hist_elt_data *elt_data;\n\n\tif (!data)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tdata->key = kzalloc(key_len, GFP_KERNEL);\n\tif (!data->key) {\n\t\ttrack_data_free(data);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tdata->key_len = key_len;\n\tdata->action_data = action_data;\n\tdata->hist_data = hist_data;\n\n\telt_data = kzalloc(sizeof(*elt_data), GFP_KERNEL);\n\tif (!elt_data) {\n\t\ttrack_data_free(data);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tdata->elt.private_data = elt_data;\n\n\telt_data->comm = kzalloc(TASK_COMM_LEN, GFP_KERNEL);\n\tif (!elt_data->comm) {\n\t\ttrack_data_free(data);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\treturn data;\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include \"tracing_map.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "track_data_free",
          "args": [
            "data"
          ],
          "line": 723
        },
        "resolved": true,
        "details": {
          "function_name": "track_data_free",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "675-691",
          "snippet": "static void track_data_free(struct track_data *track_data)\n{\n\tstruct hist_elt_data *elt_data;\n\n\tif (!track_data)\n\t\treturn;\n\n\tkfree(track_data->key);\n\n\telt_data = track_data->elt.private_data;\n\tif (elt_data) {\n\t\tkfree(elt_data->comm);\n\t\tkfree(elt_data);\n\t}\n\n\tkfree(track_data);\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void track_data_free(struct track_data *track_data)\n{\n\tstruct hist_elt_data *elt_data;\n\n\tif (!track_data)\n\t\treturn;\n\n\tkfree(track_data->key);\n\n\telt_data = track_data->elt.private_data;\n\tif (elt_data) {\n\t\tkfree(elt_data->comm);\n\t\tkfree(elt_data);\n\t}\n\n\tkfree(track_data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "TASK_COMM_LEN",
            "GFP_KERNEL"
          ],
          "line": 721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 716
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*elt_data)",
            "GFP_KERNEL"
          ],
          "line": 713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "key_len",
            "GFP_KERNEL"
          ],
          "line": 703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 701
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*data)",
            "GFP_KERNEL"
          ],
          "line": 697
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);\n\nstatic struct track_data *track_data_alloc(unsigned int key_len,\n\t\t\t\t\t   struct action_data *action_data,\n\t\t\t\t\t   struct hist_trigger_data *hist_data)\n{\n\tstruct track_data *data = kzalloc(sizeof(*data), GFP_KERNEL);\n\tstruct hist_elt_data *elt_data;\n\n\tif (!data)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tdata->key = kzalloc(key_len, GFP_KERNEL);\n\tif (!data->key) {\n\t\ttrack_data_free(data);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tdata->key_len = key_len;\n\tdata->action_data = action_data;\n\tdata->hist_data = hist_data;\n\n\telt_data = kzalloc(sizeof(*elt_data), GFP_KERNEL);\n\tif (!elt_data) {\n\t\ttrack_data_free(data);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tdata->elt.private_data = elt_data;\n\n\telt_data->comm = kzalloc(TASK_COMM_LEN, GFP_KERNEL);\n\tif (!elt_data->comm) {\n\t\ttrack_data_free(data);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\treturn data;\n}"
  },
  {
    "function_name": "track_data_free",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
    "lines": "675-691",
    "snippet": "static void track_data_free(struct track_data *track_data)\n{\n\tstruct hist_elt_data *elt_data;\n\n\tif (!track_data)\n\t\treturn;\n\n\tkfree(track_data->key);\n\n\telt_data = track_data->elt.private_data;\n\tif (elt_data) {\n\t\tkfree(elt_data->comm);\n\t\tkfree(elt_data);\n\t}\n\n\tkfree(track_data);\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include \"tracing_map.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "track_data"
          ],
          "line": 690
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void track_data_free(struct track_data *track_data)\n{\n\tstruct hist_elt_data *elt_data;\n\n\tif (!track_data)\n\t\treturn;\n\n\tkfree(track_data->key);\n\n\telt_data = track_data->elt.private_data;\n\tif (elt_data) {\n\t\tkfree(elt_data->comm);\n\t\tkfree(elt_data);\n\t}\n\n\tkfree(track_data);\n}"
  },
  {
    "function_name": "hist_field_get_div_fn",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
    "lines": "660-673",
    "snippet": "static hist_field_fn_t hist_field_get_div_fn(struct hist_field *divisor)\n{\n\tu64 div = divisor->constant;\n\n\tif (!(div & (div - 1)))\n\t\treturn div_by_power_of_two;\n\n\t/* If the divisor is too large, do a regular division */\n\tif (div > (1 << HIST_DIV_SHIFT))\n\t\treturn div_by_not_power_of_two;\n\n\tdivisor->div_multiplier = div64_u64((u64)(1 << HIST_DIV_SHIFT), div);\n\treturn div_by_mult_and_shift;\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include \"tracing_map.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define HIST_DIV_SHIFT\t\t20  /* For optimizing division by constants */"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "div64_u64",
          "args": [
            "(u64)(1 << HIST_DIV_SHIFT)",
            "div"
          ],
          "line": 671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "1 << HIST_DIV_SHIFT"
          ],
          "line": 671
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\n#define HIST_DIV_SHIFT\t\t20  /* For optimizing division by constants */\n\nstatic hist_field_fn_t hist_field_get_div_fn(struct hist_field *divisor)\n{\n\tu64 div = divisor->constant;\n\n\tif (!(div & (div - 1)))\n\t\treturn div_by_power_of_two;\n\n\t/* If the divisor is too large, do a regular division */\n\tif (div > (1 << HIST_DIV_SHIFT))\n\t\treturn div_by_not_power_of_two;\n\n\tdivisor->div_multiplier = div64_u64((u64)(1 << HIST_DIV_SHIFT), div);\n\treturn div_by_mult_and_shift;\n}"
  },
  {
    "function_name": "hist_field_unary_minus",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
    "lines": "409-421",
    "snippet": "static u64 hist_field_unary_minus(struct hist_field *hist_field,\n\t\t\t\t  struct tracing_map_elt *elt,\n\t\t\t\t  struct trace_buffer *buffer,\n\t\t\t\t  struct ring_buffer_event *rbe,\n\t\t\t\t  void *event)\n{\n\tstruct hist_field *operand = hist_field->operands[0];\n\n\ts64 sval = (s64)operand->fn(operand, elt, buffer, rbe, event);\n\tu64 val = (u64)-sval;\n\n\treturn val;\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include \"tracing_map.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "operand->fn",
          "args": [
            "operand",
            "elt",
            "buffer",
            "rbe",
            "event"
          ],
          "line": 417
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic u64 hist_field_unary_minus(struct hist_field *hist_field,\n\t\t\t\t  struct tracing_map_elt *elt,\n\t\t\t\t  struct trace_buffer *buffer,\n\t\t\t\t  struct ring_buffer_event *rbe,\n\t\t\t\t  void *event)\n{\n\tstruct hist_field *operand = hist_field->operands[0];\n\n\ts64 sval = (s64)operand->fn(operand, elt, buffer, rbe, event);\n\tu64 val = (u64)-sval;\n\n\treturn val;\n}"
  },
  {
    "function_name": "hist_field_mult",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
    "lines": "394-407",
    "snippet": "static u64 hist_field_mult(struct hist_field *hist_field,\n\t\t\t   struct tracing_map_elt *elt,\n\t\t\t   struct trace_buffer *buffer,\n\t\t\t   struct ring_buffer_event *rbe,\n\t\t\t   void *event)\n{\n\tstruct hist_field *operand1 = hist_field->operands[0];\n\tstruct hist_field *operand2 = hist_field->operands[1];\n\n\tu64 val1 = operand1->fn(operand1, elt, buffer, rbe, event);\n\tu64 val2 = operand2->fn(operand2, elt, buffer, rbe, event);\n\n\treturn val1 * val2;\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include \"tracing_map.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "operand2->fn",
          "args": [
            "operand2",
            "elt",
            "buffer",
            "rbe",
            "event"
          ],
          "line": 404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "operand1->fn",
          "args": [
            "operand1",
            "elt",
            "buffer",
            "rbe",
            "event"
          ],
          "line": 403
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic u64 hist_field_mult(struct hist_field *hist_field,\n\t\t\t   struct tracing_map_elt *elt,\n\t\t\t   struct trace_buffer *buffer,\n\t\t\t   struct ring_buffer_event *rbe,\n\t\t\t   void *event)\n{\n\tstruct hist_field *operand1 = hist_field->operands[0];\n\tstruct hist_field *operand2 = hist_field->operands[1];\n\n\tu64 val1 = operand1->fn(operand1, elt, buffer, rbe, event);\n\tu64 val2 = operand2->fn(operand2, elt, buffer, rbe, event);\n\n\treturn val1 * val2;\n}"
  },
  {
    "function_name": "div_by_mult_and_shift",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
    "lines": "360-392",
    "snippet": "static u64 div_by_mult_and_shift(struct hist_field *hist_field,\n\t\t\t\tstruct tracing_map_elt *elt,\n\t\t\t\tstruct trace_buffer *buffer,\n\t\t\t\tstruct ring_buffer_event *rbe,\n\t\t\t\tvoid *event)\n{\n\tstruct hist_field *operand1 = hist_field->operands[0];\n\tstruct hist_field *operand2 = hist_field->operands[1];\n\n\tu64 val1 = operand1->fn(operand1, elt, buffer, rbe, event);\n\n\t/*\n\t * If the divisor is a constant, do a multiplication and shift instead.\n\t *\n\t * Choose Z = some power of 2. If Y <= Z, then:\n\t *     X / Y = (X * (Z / Y)) / Z\n\t *\n\t * (Z / Y) is a constant (mult) which is calculated at parse time, so:\n\t *     X / Y = (X * mult) / Z\n\t *\n\t * The division by Z can be replaced by a shift since Z is a power of 2:\n\t *     X / Y = (X * mult) >> HIST_DIV_SHIFT\n\t *\n\t * As long, as X < Z the results will not be off by more than 1.\n\t */\n\tif (val1 < (1 << HIST_DIV_SHIFT)) {\n\t\tu64 mult = operand2->div_multiplier;\n\n\t\treturn (val1 * mult + ((1 << HIST_DIV_SHIFT) - 1)) >> HIST_DIV_SHIFT;\n\t}\n\n\treturn div64_u64(val1, operand2->constant);\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include \"tracing_map.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define HIST_DIV_SHIFT\t\t20  /* For optimizing division by constants */"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "div64_u64",
          "args": [
            "val1",
            "operand2->constant"
          ],
          "line": 391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "operand1->fn",
          "args": [
            "operand1",
            "elt",
            "buffer",
            "rbe",
            "event"
          ],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\n#define HIST_DIV_SHIFT\t\t20  /* For optimizing division by constants */\n\nstatic u64 div_by_mult_and_shift(struct hist_field *hist_field,\n\t\t\t\tstruct tracing_map_elt *elt,\n\t\t\t\tstruct trace_buffer *buffer,\n\t\t\t\tstruct ring_buffer_event *rbe,\n\t\t\t\tvoid *event)\n{\n\tstruct hist_field *operand1 = hist_field->operands[0];\n\tstruct hist_field *operand2 = hist_field->operands[1];\n\n\tu64 val1 = operand1->fn(operand1, elt, buffer, rbe, event);\n\n\t/*\n\t * If the divisor is a constant, do a multiplication and shift instead.\n\t *\n\t * Choose Z = some power of 2. If Y <= Z, then:\n\t *     X / Y = (X * (Z / Y)) / Z\n\t *\n\t * (Z / Y) is a constant (mult) which is calculated at parse time, so:\n\t *     X / Y = (X * mult) / Z\n\t *\n\t * The division by Z can be replaced by a shift since Z is a power of 2:\n\t *     X / Y = (X * mult) >> HIST_DIV_SHIFT\n\t *\n\t * As long, as X < Z the results will not be off by more than 1.\n\t */\n\tif (val1 < (1 << HIST_DIV_SHIFT)) {\n\t\tu64 mult = operand2->div_multiplier;\n\n\t\treturn (val1 * mult + ((1 << HIST_DIV_SHIFT) - 1)) >> HIST_DIV_SHIFT;\n\t}\n\n\treturn div64_u64(val1, operand2->constant);\n}"
  },
  {
    "function_name": "div_by_not_power_of_two",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
    "lines": "346-358",
    "snippet": "static u64 div_by_not_power_of_two(struct hist_field *hist_field,\n\t\t\t\tstruct tracing_map_elt *elt,\n\t\t\t\tstruct trace_buffer *buffer,\n\t\t\t\tstruct ring_buffer_event *rbe,\n\t\t\t\tvoid *event)\n{\n\tstruct hist_field *operand1 = hist_field->operands[0];\n\tstruct hist_field *operand2 = hist_field->operands[1];\n\n\tu64 val1 = operand1->fn(operand1, elt, buffer, rbe, event);\n\n\treturn div64_u64(val1, operand2->constant);\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include \"tracing_map.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "div64_u64",
          "args": [
            "val1",
            "operand2->constant"
          ],
          "line": 357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "operand1->fn",
          "args": [
            "operand1",
            "elt",
            "buffer",
            "rbe",
            "event"
          ],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic u64 div_by_not_power_of_two(struct hist_field *hist_field,\n\t\t\t\tstruct tracing_map_elt *elt,\n\t\t\t\tstruct trace_buffer *buffer,\n\t\t\t\tstruct ring_buffer_event *rbe,\n\t\t\t\tvoid *event)\n{\n\tstruct hist_field *operand1 = hist_field->operands[0];\n\tstruct hist_field *operand2 = hist_field->operands[1];\n\n\tu64 val1 = operand1->fn(operand1, elt, buffer, rbe, event);\n\n\treturn div64_u64(val1, operand2->constant);\n}"
  },
  {
    "function_name": "div_by_power_of_two",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
    "lines": "332-344",
    "snippet": "static u64 div_by_power_of_two(struct hist_field *hist_field,\n\t\t\t\tstruct tracing_map_elt *elt,\n\t\t\t\tstruct trace_buffer *buffer,\n\t\t\t\tstruct ring_buffer_event *rbe,\n\t\t\t\tvoid *event)\n{\n\tstruct hist_field *operand1 = hist_field->operands[0];\n\tstruct hist_field *operand2 = hist_field->operands[1];\n\n\tu64 val1 = operand1->fn(operand1, elt, buffer, rbe, event);\n\n\treturn val1 >> __ffs64(operand2->constant);\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include \"tracing_map.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__ffs64",
          "args": [
            "operand2->constant"
          ],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "operand1->fn",
          "args": [
            "operand1",
            "elt",
            "buffer",
            "rbe",
            "event"
          ],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic u64 div_by_power_of_two(struct hist_field *hist_field,\n\t\t\t\tstruct tracing_map_elt *elt,\n\t\t\t\tstruct trace_buffer *buffer,\n\t\t\t\tstruct ring_buffer_event *rbe,\n\t\t\t\tvoid *event)\n{\n\tstruct hist_field *operand1 = hist_field->operands[0];\n\tstruct hist_field *operand2 = hist_field->operands[1];\n\n\tu64 val1 = operand1->fn(operand1, elt, buffer, rbe, event);\n\n\treturn val1 >> __ffs64(operand2->constant);\n}"
  },
  {
    "function_name": "hist_field_div",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
    "lines": "309-330",
    "snippet": "static u64 hist_field_div(struct hist_field *hist_field,\n\t\t\t   struct tracing_map_elt *elt,\n\t\t\t   struct trace_buffer *buffer,\n\t\t\t   struct ring_buffer_event *rbe,\n\t\t\t   void *event)\n{\n\tstruct hist_field *operand1 = hist_field->operands[0];\n\tstruct hist_field *operand2 = hist_field->operands[1];\n\n\tu64 val1 = operand1->fn(operand1, elt, buffer, rbe, event);\n\tu64 val2 = operand2->fn(operand2, elt, buffer, rbe, event);\n\n\t/* Return -1 for the undefined case */\n\tif (!val2)\n\t\treturn -1;\n\n\t/* Use shift if the divisor is a power of 2 */\n\tif (!(val2 & (val2 - 1)))\n\t\treturn val1 >> __ffs64(val2);\n\n\treturn div64_u64(val1, val2);\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include \"tracing_map.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "div64_u64",
          "args": [
            "val1",
            "val2"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__ffs64",
          "args": [
            "val2"
          ],
          "line": 327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "operand2->fn",
          "args": [
            "operand2",
            "elt",
            "buffer",
            "rbe",
            "event"
          ],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "operand1->fn",
          "args": [
            "operand1",
            "elt",
            "buffer",
            "rbe",
            "event"
          ],
          "line": 318
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic u64 hist_field_div(struct hist_field *hist_field,\n\t\t\t   struct tracing_map_elt *elt,\n\t\t\t   struct trace_buffer *buffer,\n\t\t\t   struct ring_buffer_event *rbe,\n\t\t\t   void *event)\n{\n\tstruct hist_field *operand1 = hist_field->operands[0];\n\tstruct hist_field *operand2 = hist_field->operands[1];\n\n\tu64 val1 = operand1->fn(operand1, elt, buffer, rbe, event);\n\tu64 val2 = operand2->fn(operand2, elt, buffer, rbe, event);\n\n\t/* Return -1 for the undefined case */\n\tif (!val2)\n\t\treturn -1;\n\n\t/* Use shift if the divisor is a power of 2 */\n\tif (!(val2 & (val2 - 1)))\n\t\treturn val1 >> __ffs64(val2);\n\n\treturn div64_u64(val1, val2);\n}"
  },
  {
    "function_name": "hist_field_minus",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
    "lines": "294-307",
    "snippet": "static u64 hist_field_minus(struct hist_field *hist_field,\n\t\t\t    struct tracing_map_elt *elt,\n\t\t\t    struct trace_buffer *buffer,\n\t\t\t    struct ring_buffer_event *rbe,\n\t\t\t    void *event)\n{\n\tstruct hist_field *operand1 = hist_field->operands[0];\n\tstruct hist_field *operand2 = hist_field->operands[1];\n\n\tu64 val1 = operand1->fn(operand1, elt, buffer, rbe, event);\n\tu64 val2 = operand2->fn(operand2, elt, buffer, rbe, event);\n\n\treturn val1 - val2;\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include \"tracing_map.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "operand2->fn",
          "args": [
            "operand2",
            "elt",
            "buffer",
            "rbe",
            "event"
          ],
          "line": 304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "operand1->fn",
          "args": [
            "operand1",
            "elt",
            "buffer",
            "rbe",
            "event"
          ],
          "line": 303
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic u64 hist_field_minus(struct hist_field *hist_field,\n\t\t\t    struct tracing_map_elt *elt,\n\t\t\t    struct trace_buffer *buffer,\n\t\t\t    struct ring_buffer_event *rbe,\n\t\t\t    void *event)\n{\n\tstruct hist_field *operand1 = hist_field->operands[0];\n\tstruct hist_field *operand2 = hist_field->operands[1];\n\n\tu64 val1 = operand1->fn(operand1, elt, buffer, rbe, event);\n\tu64 val2 = operand2->fn(operand2, elt, buffer, rbe, event);\n\n\treturn val1 - val2;\n}"
  },
  {
    "function_name": "hist_field_plus",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
    "lines": "279-292",
    "snippet": "static u64 hist_field_plus(struct hist_field *hist_field,\n\t\t\t   struct tracing_map_elt *elt,\n\t\t\t   struct trace_buffer *buffer,\n\t\t\t   struct ring_buffer_event *rbe,\n\t\t\t   void *event)\n{\n\tstruct hist_field *operand1 = hist_field->operands[0];\n\tstruct hist_field *operand2 = hist_field->operands[1];\n\n\tu64 val1 = operand1->fn(operand1, elt, buffer, rbe, event);\n\tu64 val2 = operand2->fn(operand2, elt, buffer, rbe, event);\n\n\treturn val1 + val2;\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include \"tracing_map.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "operand2->fn",
          "args": [
            "operand2",
            "elt",
            "buffer",
            "rbe",
            "event"
          ],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "operand1->fn",
          "args": [
            "operand1",
            "elt",
            "buffer",
            "rbe",
            "event"
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic u64 hist_field_plus(struct hist_field *hist_field,\n\t\t\t   struct tracing_map_elt *elt,\n\t\t\t   struct trace_buffer *buffer,\n\t\t\t   struct ring_buffer_event *rbe,\n\t\t\t   void *event)\n{\n\tstruct hist_field *operand1 = hist_field->operands[0];\n\tstruct hist_field *operand2 = hist_field->operands[1];\n\n\tu64 val1 = operand1->fn(operand1, elt, buffer, rbe, event);\n\tu64 val2 = operand2->fn(operand2, elt, buffer, rbe, event);\n\n\treturn val1 + val2;\n}"
  },
  {
    "function_name": "hist_field_bucket",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
    "lines": "258-277",
    "snippet": "static u64 hist_field_bucket(struct hist_field *hist_field,\n\t\t\t     struct tracing_map_elt *elt,\n\t\t\t     struct trace_buffer *buffer,\n\t\t\t     struct ring_buffer_event *rbe,\n\t\t\t     void *event)\n{\n\tstruct hist_field *operand = hist_field->operands[0];\n\tunsigned long buckets = hist_field->buckets;\n\n\tu64 val = operand->fn(operand, elt, buffer, rbe, event);\n\n\tif (WARN_ON_ONCE(!buckets))\n\t\treturn val;\n\n\tif (val >= LONG_MAX)\n\t\tval = div64_ul(val, buckets);\n\telse\n\t\tval = (u64)((unsigned long)val / buckets);\n\treturn val * buckets;\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include \"tracing_map.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "",
          "args": [
            "(unsigned long)val / buckets"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "div64_ul",
          "args": [
            "val",
            "buckets"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!buckets"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "operand->fn",
          "args": [
            "operand",
            "elt",
            "buffer",
            "rbe",
            "event"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic u64 hist_field_bucket(struct hist_field *hist_field,\n\t\t\t     struct tracing_map_elt *elt,\n\t\t\t     struct trace_buffer *buffer,\n\t\t\t     struct ring_buffer_event *rbe,\n\t\t\t     void *event)\n{\n\tstruct hist_field *operand = hist_field->operands[0];\n\tunsigned long buckets = hist_field->buckets;\n\n\tu64 val = operand->fn(operand, elt, buffer, rbe, event);\n\n\tif (WARN_ON_ONCE(!buckets))\n\t\treturn val;\n\n\tif (val >= LONG_MAX)\n\t\tval = div64_ul(val, buckets);\n\telse\n\t\tval = (u64)((unsigned long)val / buckets);\n\treturn val * buckets;\n}"
  },
  {
    "function_name": "hist_field_log2",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
    "lines": "245-256",
    "snippet": "static u64 hist_field_log2(struct hist_field *hist_field,\n\t\t\t   struct tracing_map_elt *elt,\n\t\t\t   struct trace_buffer *buffer,\n\t\t\t   struct ring_buffer_event *rbe,\n\t\t\t   void *event)\n{\n\tstruct hist_field *operand = hist_field->operands[0];\n\n\tu64 val = operand->fn(operand, elt, buffer, rbe, event);\n\n\treturn (u64) ilog2(roundup_pow_of_two(val));\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include \"tracing_map.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ilog2",
          "args": [
            "roundup_pow_of_two(val)"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "roundup_pow_of_two",
          "args": [
            "val"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "operand->fn",
          "args": [
            "operand",
            "elt",
            "buffer",
            "rbe",
            "event"
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic u64 hist_field_log2(struct hist_field *hist_field,\n\t\t\t   struct tracing_map_elt *elt,\n\t\t\t   struct trace_buffer *buffer,\n\t\t\t   struct ring_buffer_event *rbe,\n\t\t\t   void *event)\n{\n\tstruct hist_field *operand = hist_field->operands[0];\n\n\tu64 val = operand->fn(operand, elt, buffer, rbe, event);\n\n\treturn (u64) ilog2(roundup_pow_of_two(val));\n}"
  },
  {
    "function_name": "hist_field_pstring",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
    "lines": "234-243",
    "snippet": "static u64 hist_field_pstring(struct hist_field *hist_field,\n\t\t\t      struct tracing_map_elt *elt,\n\t\t\t      struct trace_buffer *buffer,\n\t\t\t      struct ring_buffer_event *rbe,\n\t\t\t      void *event)\n{\n\tchar **addr = (char **)(event + hist_field->field->offset);\n\n\treturn (u64)(unsigned long)*addr;\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include \"tracing_map.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic u64 hist_field_pstring(struct hist_field *hist_field,\n\t\t\t      struct tracing_map_elt *elt,\n\t\t\t      struct trace_buffer *buffer,\n\t\t\t      struct ring_buffer_event *rbe,\n\t\t\t      void *event)\n{\n\tchar **addr = (char **)(event + hist_field->field->offset);\n\n\treturn (u64)(unsigned long)*addr;\n}"
  },
  {
    "function_name": "hist_field_reldynstring",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
    "lines": "220-232",
    "snippet": "static u64 hist_field_reldynstring(struct hist_field *hist_field,\n\t\t\t\t   struct tracing_map_elt *elt,\n\t\t\t\t   struct trace_buffer *buffer,\n\t\t\t\t   struct ring_buffer_event *rbe,\n\t\t\t\t   void *event)\n{\n\tu32 *item = event + hist_field->field->offset;\n\tu32 str_item = *item;\n\tint str_loc = str_item & 0xffff;\n\tchar *addr = (char *)&item[1] + str_loc;\n\n\treturn (u64)(unsigned long)addr;\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include \"tracing_map.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic u64 hist_field_reldynstring(struct hist_field *hist_field,\n\t\t\t\t   struct tracing_map_elt *elt,\n\t\t\t\t   struct trace_buffer *buffer,\n\t\t\t\t   struct ring_buffer_event *rbe,\n\t\t\t\t   void *event)\n{\n\tu32 *item = event + hist_field->field->offset;\n\tu32 str_item = *item;\n\tint str_loc = str_item & 0xffff;\n\tchar *addr = (char *)&item[1] + str_loc;\n\n\treturn (u64)(unsigned long)addr;\n}"
  },
  {
    "function_name": "hist_field_dynstring",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
    "lines": "207-218",
    "snippet": "static u64 hist_field_dynstring(struct hist_field *hist_field,\n\t\t\t\tstruct tracing_map_elt *elt,\n\t\t\t\tstruct trace_buffer *buffer,\n\t\t\t\tstruct ring_buffer_event *rbe,\n\t\t\t\tvoid *event)\n{\n\tu32 str_item = *(u32 *)(event + hist_field->field->offset);\n\tint str_loc = str_item & 0xffff;\n\tchar *addr = (char *)(event + str_loc);\n\n\treturn (u64)(unsigned long)addr;\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include \"tracing_map.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic u64 hist_field_dynstring(struct hist_field *hist_field,\n\t\t\t\tstruct tracing_map_elt *elt,\n\t\t\t\tstruct trace_buffer *buffer,\n\t\t\t\tstruct ring_buffer_event *rbe,\n\t\t\t\tvoid *event)\n{\n\tu32 str_item = *(u32 *)(event + hist_field->field->offset);\n\tint str_loc = str_item & 0xffff;\n\tchar *addr = (char *)(event + str_loc);\n\n\treturn (u64)(unsigned long)addr;\n}"
  },
  {
    "function_name": "hist_field_string",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
    "lines": "196-205",
    "snippet": "static u64 hist_field_string(struct hist_field *hist_field,\n\t\t\t     struct tracing_map_elt *elt,\n\t\t\t     struct trace_buffer *buffer,\n\t\t\t     struct ring_buffer_event *rbe,\n\t\t\t     void *event)\n{\n\tchar *addr = (char *)(event + hist_field->field->offset);\n\n\treturn (u64)(unsigned long)addr;\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include \"tracing_map.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic u64 hist_field_string(struct hist_field *hist_field,\n\t\t\t     struct tracing_map_elt *elt,\n\t\t\t     struct trace_buffer *buffer,\n\t\t\t     struct ring_buffer_event *rbe,\n\t\t\t     void *event)\n{\n\tchar *addr = (char *)(event + hist_field->field->offset);\n\n\treturn (u64)(unsigned long)addr;\n}"
  },
  {
    "function_name": "hist_field_counter",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
    "lines": "187-194",
    "snippet": "static u64 hist_field_counter(struct hist_field *field,\n\t\t\t      struct tracing_map_elt *elt,\n\t\t\t      struct trace_buffer *buffer,\n\t\t\t      struct ring_buffer_event *rbe,\n\t\t\t      void *event)\n{\n\treturn 1;\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include \"tracing_map.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic u64 hist_field_counter(struct hist_field *field,\n\t\t\t      struct tracing_map_elt *elt,\n\t\t\t      struct trace_buffer *buffer,\n\t\t\t      struct ring_buffer_event *rbe,\n\t\t\t      void *event)\n{\n\treturn 1;\n}"
  },
  {
    "function_name": "hist_field_const",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
    "lines": "178-185",
    "snippet": "static u64 hist_field_const(struct hist_field *field,\n\t\t\t   struct tracing_map_elt *elt,\n\t\t\t   struct trace_buffer *buffer,\n\t\t\t   struct ring_buffer_event *rbe,\n\t\t\t   void *event)\n{\n\treturn field->constant;\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include \"tracing_map.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic u64 hist_field_const(struct hist_field *field,\n\t\t\t   struct tracing_map_elt *elt,\n\t\t\t   struct trace_buffer *buffer,\n\t\t\t   struct ring_buffer_event *rbe,\n\t\t\t   void *event)\n{\n\treturn field->constant;\n}"
  },
  {
    "function_name": "hist_field_none",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
    "lines": "169-176",
    "snippet": "static u64 hist_field_none(struct hist_field *field,\n\t\t\t   struct tracing_map_elt *elt,\n\t\t\t   struct trace_buffer *buffer,\n\t\t\t   struct ring_buffer_event *rbe,\n\t\t\t   void *event)\n{\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include \"tracing_map.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic u64 hist_field_none(struct hist_field *field,\n\t\t\t   struct tracing_map_elt *elt,\n\t\t\t   struct trace_buffer *buffer,\n\t\t\t   struct ring_buffer_event *rbe,\n\t\t\t   void *event)\n{\n\treturn 0;\n}"
  }
]