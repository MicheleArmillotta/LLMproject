[
  {
    "function_name": "task_storage_map_free",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_task_storage.c",
    "lines": "299-306",
    "snippet": "static void task_storage_map_free(struct bpf_map *map)\n{\n\tstruct bpf_local_storage_map *smap;\n\n\tsmap = (struct bpf_local_storage_map *)map;\n\tbpf_local_storage_cache_idx_free(&task_cache, smap->cache_idx);\n\tbpf_local_storage_map_free(smap, &bpf_task_storage_busy);\n}",
    "includes": [
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/btf_ids.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/filter.h>",
      "#include <linux/bpf_local_storage.h>",
      "#include <linux/bpf.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/types.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/rculist.h>",
      "#include <linux/sched.h>",
      "#include <linux/pid.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(int, bpf_task_storage_busy);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bpf_local_storage_map_free",
          "args": [
            "smap",
            "&bpf_task_storage_busy"
          ],
          "line": 305
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_local_storage_map_free",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_local_storage.c",
          "lines": "501-561",
          "snippet": "void bpf_local_storage_map_free(struct bpf_local_storage_map *smap,\n\t\t\t\tint __percpu *busy_counter)\n{\n\tstruct bpf_local_storage_elem *selem;\n\tstruct bpf_local_storage_map_bucket *b;\n\tunsigned int i;\n\n\t/* Note that this map might be concurrently cloned from\n\t * bpf_sk_storage_clone. Wait for any existing bpf_sk_storage_clone\n\t * RCU read section to finish before proceeding. New RCU\n\t * read sections should be prevented via bpf_map_inc_not_zero.\n\t */\n\tsynchronize_rcu();\n\n\t/* bpf prog and the userspace can no longer access this map\n\t * now.  No new selem (of this map) can be added\n\t * to the owner->storage or to the map bucket's list.\n\t *\n\t * The elem of this map can be cleaned up here\n\t * or when the storage is freed e.g.\n\t * by bpf_sk_storage_free() during __sk_destruct().\n\t */\n\tfor (i = 0; i < (1U << smap->bucket_log); i++) {\n\t\tb = &smap->buckets[i];\n\n\t\trcu_read_lock();\n\t\t/* No one is adding to b->list now */\n\t\twhile ((selem = hlist_entry_safe(\n\t\t\t\trcu_dereference_raw(hlist_first_rcu(&b->list)),\n\t\t\t\tstruct bpf_local_storage_elem, map_node))) {\n\t\t\tif (busy_counter) {\n\t\t\t\tmigrate_disable();\n\t\t\t\t__this_cpu_inc(*busy_counter);\n\t\t\t}\n\t\t\tbpf_selem_unlink(selem);\n\t\t\tif (busy_counter) {\n\t\t\t\t__this_cpu_dec(*busy_counter);\n\t\t\t\tmigrate_enable();\n\t\t\t}\n\t\t\tcond_resched_rcu();\n\t\t}\n\t\trcu_read_unlock();\n\t}\n\n\t/* While freeing the storage we may still need to access the map.\n\t *\n\t * e.g. when bpf_sk_storage_free() has unlinked selem from the map\n\t * which then made the above while((selem = ...)) loop\n\t * exit immediately.\n\t *\n\t * However, while freeing the storage one still needs to access the\n\t * smap->elem_size to do the uncharging in\n\t * bpf_selem_unlink_storage_nolock().\n\t *\n\t * Hence, wait another rcu grace period for the storage to be freed.\n\t */\n\tsynchronize_rcu();\n\n\tkvfree(smap->buckets);\n\tkfree(smap);\n}",
          "includes": [
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/rcupdate.h>",
            "#include <uapi/linux/btf.h>",
            "#include <uapi/linux/sock_diag.h>",
            "#include <net/sock.h>",
            "#include <linux/bpf_local_storage.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/bpf.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/rculist.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcupdate_wait.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/rcupdate.h>\n#include <uapi/linux/btf.h>\n#include <uapi/linux/sock_diag.h>\n#include <net/sock.h>\n#include <linux/bpf_local_storage.h>\n#include <linux/btf_ids.h>\n#include <linux/bpf.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/rculist.h>\n\nvoid bpf_local_storage_map_free(struct bpf_local_storage_map *smap,\n\t\t\t\tint __percpu *busy_counter)\n{\n\tstruct bpf_local_storage_elem *selem;\n\tstruct bpf_local_storage_map_bucket *b;\n\tunsigned int i;\n\n\t/* Note that this map might be concurrently cloned from\n\t * bpf_sk_storage_clone. Wait for any existing bpf_sk_storage_clone\n\t * RCU read section to finish before proceeding. New RCU\n\t * read sections should be prevented via bpf_map_inc_not_zero.\n\t */\n\tsynchronize_rcu();\n\n\t/* bpf prog and the userspace can no longer access this map\n\t * now.  No new selem (of this map) can be added\n\t * to the owner->storage or to the map bucket's list.\n\t *\n\t * The elem of this map can be cleaned up here\n\t * or when the storage is freed e.g.\n\t * by bpf_sk_storage_free() during __sk_destruct().\n\t */\n\tfor (i = 0; i < (1U << smap->bucket_log); i++) {\n\t\tb = &smap->buckets[i];\n\n\t\trcu_read_lock();\n\t\t/* No one is adding to b->list now */\n\t\twhile ((selem = hlist_entry_safe(\n\t\t\t\trcu_dereference_raw(hlist_first_rcu(&b->list)),\n\t\t\t\tstruct bpf_local_storage_elem, map_node))) {\n\t\t\tif (busy_counter) {\n\t\t\t\tmigrate_disable();\n\t\t\t\t__this_cpu_inc(*busy_counter);\n\t\t\t}\n\t\t\tbpf_selem_unlink(selem);\n\t\t\tif (busy_counter) {\n\t\t\t\t__this_cpu_dec(*busy_counter);\n\t\t\t\tmigrate_enable();\n\t\t\t}\n\t\t\tcond_resched_rcu();\n\t\t}\n\t\trcu_read_unlock();\n\t}\n\n\t/* While freeing the storage we may still need to access the map.\n\t *\n\t * e.g. when bpf_sk_storage_free() has unlinked selem from the map\n\t * which then made the above while((selem = ...)) loop\n\t * exit immediately.\n\t *\n\t * However, while freeing the storage one still needs to access the\n\t * smap->elem_size to do the uncharging in\n\t * bpf_selem_unlink_storage_nolock().\n\t *\n\t * Hence, wait another rcu grace period for the storage to be freed.\n\t */\n\tsynchronize_rcu();\n\n\tkvfree(smap->buckets);\n\tkfree(smap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_local_storage_cache_idx_free",
          "args": [
            "&task_cache",
            "smap->cache_idx"
          ],
          "line": 304
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_local_storage_cache_idx_free",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_local_storage.c",
          "lines": "493-499",
          "snippet": "void bpf_local_storage_cache_idx_free(struct bpf_local_storage_cache *cache,\n\t\t\t\t      u16 idx)\n{\n\tspin_lock(&cache->idx_lock);\n\tcache->idx_usage_counts[idx]--;\n\tspin_unlock(&cache->idx_lock);\n}",
          "includes": [
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/rcupdate.h>",
            "#include <uapi/linux/btf.h>",
            "#include <uapi/linux/sock_diag.h>",
            "#include <net/sock.h>",
            "#include <linux/bpf_local_storage.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/bpf.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/rculist.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcupdate_wait.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/rcupdate.h>\n#include <uapi/linux/btf.h>\n#include <uapi/linux/sock_diag.h>\n#include <net/sock.h>\n#include <linux/bpf_local_storage.h>\n#include <linux/btf_ids.h>\n#include <linux/bpf.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/rculist.h>\n\nvoid bpf_local_storage_cache_idx_free(struct bpf_local_storage_cache *cache,\n\t\t\t\t      u16 idx)\n{\n\tspin_lock(&cache->idx_lock);\n\tcache->idx_usage_counts[idx]--;\n\tspin_unlock(&cache->idx_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/rcupdate_trace.h>\n#include <linux/fdtable.h>\n#include <linux/btf_ids.h>\n#include <uapi/linux/btf.h>\n#include <linux/filter.h>\n#include <linux/bpf_local_storage.h>\n#include <linux/bpf.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/rculist.h>\n#include <linux/sched.h>\n#include <linux/pid.h>\n\nstatic DEFINE_PER_CPU(int, bpf_task_storage_busy);\n\nstatic void task_storage_map_free(struct bpf_map *map)\n{\n\tstruct bpf_local_storage_map *smap;\n\n\tsmap = (struct bpf_local_storage_map *)map;\n\tbpf_local_storage_cache_idx_free(&task_cache, smap->cache_idx);\n\tbpf_local_storage_map_free(smap, &bpf_task_storage_busy);\n}"
  },
  {
    "function_name": "task_storage_map_alloc",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_task_storage.c",
    "lines": "287-297",
    "snippet": "static struct bpf_map *task_storage_map_alloc(union bpf_attr *attr)\n{\n\tstruct bpf_local_storage_map *smap;\n\n\tsmap = bpf_local_storage_map_alloc(attr);\n\tif (IS_ERR(smap))\n\t\treturn ERR_CAST(smap);\n\n\tsmap->cache_idx = bpf_local_storage_cache_idx_get(&task_cache);\n\treturn &smap->map;\n}",
    "includes": [
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/btf_ids.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/filter.h>",
      "#include <linux/bpf_local_storage.h>",
      "#include <linux/bpf.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/types.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/rculist.h>",
      "#include <linux/sched.h>",
      "#include <linux/pid.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bpf_local_storage_cache_idx_get",
          "args": [
            "&task_cache"
          ],
          "line": 295
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_local_storage_cache_idx_get",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_local_storage.c",
          "lines": "469-491",
          "snippet": "u16 bpf_local_storage_cache_idx_get(struct bpf_local_storage_cache *cache)\n{\n\tu64 min_usage = U64_MAX;\n\tu16 i, res = 0;\n\n\tspin_lock(&cache->idx_lock);\n\n\tfor (i = 0; i < BPF_LOCAL_STORAGE_CACHE_SIZE; i++) {\n\t\tif (cache->idx_usage_counts[i] < min_usage) {\n\t\t\tmin_usage = cache->idx_usage_counts[i];\n\t\t\tres = i;\n\n\t\t\t/* Found a free cache_idx */\n\t\t\tif (!min_usage)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tcache->idx_usage_counts[res]++;\n\n\tspin_unlock(&cache->idx_lock);\n\n\treturn res;\n}",
          "includes": [
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/rcupdate.h>",
            "#include <uapi/linux/btf.h>",
            "#include <uapi/linux/sock_diag.h>",
            "#include <net/sock.h>",
            "#include <linux/bpf_local_storage.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/bpf.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/rculist.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcupdate_wait.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/rcupdate.h>\n#include <uapi/linux/btf.h>\n#include <uapi/linux/sock_diag.h>\n#include <net/sock.h>\n#include <linux/bpf_local_storage.h>\n#include <linux/btf_ids.h>\n#include <linux/bpf.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/rculist.h>\n\nu16 bpf_local_storage_cache_idx_get(struct bpf_local_storage_cache *cache)\n{\n\tu64 min_usage = U64_MAX;\n\tu16 i, res = 0;\n\n\tspin_lock(&cache->idx_lock);\n\n\tfor (i = 0; i < BPF_LOCAL_STORAGE_CACHE_SIZE; i++) {\n\t\tif (cache->idx_usage_counts[i] < min_usage) {\n\t\t\tmin_usage = cache->idx_usage_counts[i];\n\t\t\tres = i;\n\n\t\t\t/* Found a free cache_idx */\n\t\t\tif (!min_usage)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tcache->idx_usage_counts[res]++;\n\n\tspin_unlock(&cache->idx_lock);\n\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_CAST",
          "args": [
            "smap"
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "smap"
          ],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_local_storage_map_alloc",
          "args": [
            "attr"
          ],
          "line": 291
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_local_storage_map_alloc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_local_storage.c",
          "lines": "582-614",
          "snippet": "struct bpf_local_storage_map *bpf_local_storage_map_alloc(union bpf_attr *attr)\n{\n\tstruct bpf_local_storage_map *smap;\n\tunsigned int i;\n\tu32 nbuckets;\n\n\tsmap = kzalloc(sizeof(*smap), GFP_USER | __GFP_NOWARN | __GFP_ACCOUNT);\n\tif (!smap)\n\t\treturn ERR_PTR(-ENOMEM);\n\tbpf_map_init_from_attr(&smap->map, attr);\n\n\tnbuckets = roundup_pow_of_two(num_possible_cpus());\n\t/* Use at least 2 buckets, select_bucket() is undefined behavior with 1 bucket */\n\tnbuckets = max_t(u32, 2, nbuckets);\n\tsmap->bucket_log = ilog2(nbuckets);\n\n\tsmap->buckets = kvcalloc(sizeof(*smap->buckets), nbuckets,\n\t\t\t\t GFP_USER | __GFP_NOWARN | __GFP_ACCOUNT);\n\tif (!smap->buckets) {\n\t\tkfree(smap);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tfor (i = 0; i < nbuckets; i++) {\n\t\tINIT_HLIST_HEAD(&smap->buckets[i].list);\n\t\traw_spin_lock_init(&smap->buckets[i].lock);\n\t}\n\n\tsmap->elem_size =\n\t\tsizeof(struct bpf_local_storage_elem) + attr->value_size;\n\n\treturn smap;\n}",
          "includes": [
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/rcupdate.h>",
            "#include <uapi/linux/btf.h>",
            "#include <uapi/linux/sock_diag.h>",
            "#include <net/sock.h>",
            "#include <linux/bpf_local_storage.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/bpf.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/rculist.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcupdate_wait.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/rcupdate.h>\n#include <uapi/linux/btf.h>\n#include <uapi/linux/sock_diag.h>\n#include <net/sock.h>\n#include <linux/bpf_local_storage.h>\n#include <linux/btf_ids.h>\n#include <linux/bpf.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/rculist.h>\n\nstruct bpf_local_storage_map *bpf_local_storage_map_alloc(union bpf_attr *attr)\n{\n\tstruct bpf_local_storage_map *smap;\n\tunsigned int i;\n\tu32 nbuckets;\n\n\tsmap = kzalloc(sizeof(*smap), GFP_USER | __GFP_NOWARN | __GFP_ACCOUNT);\n\tif (!smap)\n\t\treturn ERR_PTR(-ENOMEM);\n\tbpf_map_init_from_attr(&smap->map, attr);\n\n\tnbuckets = roundup_pow_of_two(num_possible_cpus());\n\t/* Use at least 2 buckets, select_bucket() is undefined behavior with 1 bucket */\n\tnbuckets = max_t(u32, 2, nbuckets);\n\tsmap->bucket_log = ilog2(nbuckets);\n\n\tsmap->buckets = kvcalloc(sizeof(*smap->buckets), nbuckets,\n\t\t\t\t GFP_USER | __GFP_NOWARN | __GFP_ACCOUNT);\n\tif (!smap->buckets) {\n\t\tkfree(smap);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tfor (i = 0; i < nbuckets; i++) {\n\t\tINIT_HLIST_HEAD(&smap->buckets[i].list);\n\t\traw_spin_lock_init(&smap->buckets[i].lock);\n\t}\n\n\tsmap->elem_size =\n\t\tsizeof(struct bpf_local_storage_elem) + attr->value_size;\n\n\treturn smap;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/rcupdate_trace.h>\n#include <linux/fdtable.h>\n#include <linux/btf_ids.h>\n#include <uapi/linux/btf.h>\n#include <linux/filter.h>\n#include <linux/bpf_local_storage.h>\n#include <linux/bpf.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/rculist.h>\n#include <linux/sched.h>\n#include <linux/pid.h>\n\nstatic struct bpf_map *task_storage_map_alloc(union bpf_attr *attr)\n{\n\tstruct bpf_local_storage_map *smap;\n\n\tsmap = bpf_local_storage_map_alloc(attr);\n\tif (IS_ERR(smap))\n\t\treturn ERR_CAST(smap);\n\n\tsmap->cache_idx = bpf_local_storage_cache_idx_get(&task_cache);\n\treturn &smap->map;\n}"
  },
  {
    "function_name": "notsupp_get_next_key",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_task_storage.c",
    "lines": "282-285",
    "snippet": "static int notsupp_get_next_key(struct bpf_map *map, void *key, void *next_key)\n{\n\treturn -ENOTSUPP;\n}",
    "includes": [
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/btf_ids.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/filter.h>",
      "#include <linux/bpf_local_storage.h>",
      "#include <linux/bpf.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/types.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/rculist.h>",
      "#include <linux/sched.h>",
      "#include <linux/pid.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/rcupdate_trace.h>\n#include <linux/fdtable.h>\n#include <linux/btf_ids.h>\n#include <uapi/linux/btf.h>\n#include <linux/filter.h>\n#include <linux/bpf_local_storage.h>\n#include <linux/bpf.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/rculist.h>\n#include <linux/sched.h>\n#include <linux/pid.h>\n\nstatic int notsupp_get_next_key(struct bpf_map *map, void *key, void *next_key)\n{\n\treturn -ENOTSUPP;\n}"
  },
  {
    "function_name": "bpf_pid_task_storage_delete_elem",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_task_storage.c",
    "lines": "199-227",
    "snippet": "static int bpf_pid_task_storage_delete_elem(struct bpf_map *map, void *key)\n{\n\tstruct task_struct *task;\n\tunsigned int f_flags;\n\tstruct pid *pid;\n\tint fd, err;\n\n\tfd = *(int *)key;\n\tpid = pidfd_get_pid(fd, &f_flags);\n\tif (IS_ERR(pid))\n\t\treturn PTR_ERR(pid);\n\n\t/* We should be in an RCU read side critical section, it should be safe\n\t * to call pid_task.\n\t */\n\tWARN_ON_ONCE(!rcu_read_lock_held());\n\ttask = pid_task(pid, PIDTYPE_PID);\n\tif (!task) {\n\t\terr = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tbpf_task_storage_lock();\n\terr = task_storage_delete(task, map);\n\tbpf_task_storage_unlock();\nout:\n\tput_pid(pid);\n\treturn err;\n}",
    "includes": [
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/btf_ids.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/filter.h>",
      "#include <linux/bpf_local_storage.h>",
      "#include <linux/bpf.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/types.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/rculist.h>",
      "#include <linux/sched.h>",
      "#include <linux/pid.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_pid",
          "args": [
            "pid"
          ],
          "line": 225
        },
        "resolved": true,
        "details": {
          "function_name": "delayed_put_pid",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/pid.c",
          "lines": "120-124",
          "snippet": "static void delayed_put_pid(struct rcu_head *rhp)\n{\n\tstruct pid *pid = container_of(rhp, struct pid, rcu);\n\tput_pid(pid);\n}",
          "includes": [
            "#include <uapi/linux/pidfd.h>",
            "#include <net/sock.h>",
            "#include <linux/idr.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/refcount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/init_task.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/memblock.h>",
            "#include <linux/rculist.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/pidfd.h>\n#include <net/sock.h>\n#include <linux/idr.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/anon_inodes.h>\n#include <linux/refcount.h>\n#include <linux/proc_ns.h>\n#include <linux/syscalls.h>\n#include <linux/init_task.h>\n#include <linux/pid_namespace.h>\n#include <linux/memblock.h>\n#include <linux/rculist.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\nstatic void delayed_put_pid(struct rcu_head *rhp)\n{\n\tstruct pid *pid = container_of(rhp, struct pid, rcu);\n\tput_pid(pid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_task_storage_unlock",
          "args": [],
          "line": 223
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_task_storage_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_task_storage.c",
          "lines": "32-36",
          "snippet": "static void bpf_task_storage_unlock(void)\n{\n\t__this_cpu_dec(bpf_task_storage_busy);\n\tmigrate_enable();\n}",
          "includes": [
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/btf_ids.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf_local_storage.h>",
            "#include <linux/bpf.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/rculist.h>",
            "#include <linux/sched.h>",
            "#include <linux/pid.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(int, bpf_task_storage_busy);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcupdate_trace.h>\n#include <linux/fdtable.h>\n#include <linux/btf_ids.h>\n#include <uapi/linux/btf.h>\n#include <linux/filter.h>\n#include <linux/bpf_local_storage.h>\n#include <linux/bpf.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/rculist.h>\n#include <linux/sched.h>\n#include <linux/pid.h>\n\nstatic DEFINE_PER_CPU(int, bpf_task_storage_busy);\n\nstatic void bpf_task_storage_unlock(void)\n{\n\t__this_cpu_dec(bpf_task_storage_busy);\n\tmigrate_enable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_storage_delete",
          "args": [
            "task",
            "map"
          ],
          "line": 222
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_pid_task_storage_delete_elem",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_task_storage.c",
          "lines": "199-227",
          "snippet": "static int bpf_pid_task_storage_delete_elem(struct bpf_map *map, void *key)\n{\n\tstruct task_struct *task;\n\tunsigned int f_flags;\n\tstruct pid *pid;\n\tint fd, err;\n\n\tfd = *(int *)key;\n\tpid = pidfd_get_pid(fd, &f_flags);\n\tif (IS_ERR(pid))\n\t\treturn PTR_ERR(pid);\n\n\t/* We should be in an RCU read side critical section, it should be safe\n\t * to call pid_task.\n\t */\n\tWARN_ON_ONCE(!rcu_read_lock_held());\n\ttask = pid_task(pid, PIDTYPE_PID);\n\tif (!task) {\n\t\terr = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tbpf_task_storage_lock();\n\terr = task_storage_delete(task, map);\n\tbpf_task_storage_unlock();\nout:\n\tput_pid(pid);\n\treturn err;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "bpf_task_storage_lock",
          "args": [],
          "line": 221
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_task_storage_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_task_storage.c",
          "lines": "26-30",
          "snippet": "static void bpf_task_storage_lock(void)\n{\n\tmigrate_disable();\n\t__this_cpu_inc(bpf_task_storage_busy);\n}",
          "includes": [
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/btf_ids.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf_local_storage.h>",
            "#include <linux/bpf.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/rculist.h>",
            "#include <linux/sched.h>",
            "#include <linux/pid.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(int, bpf_task_storage_busy);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcupdate_trace.h>\n#include <linux/fdtable.h>\n#include <linux/btf_ids.h>\n#include <uapi/linux/btf.h>\n#include <linux/filter.h>\n#include <linux/bpf_local_storage.h>\n#include <linux/bpf.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/rculist.h>\n#include <linux/sched.h>\n#include <linux/pid.h>\n\nstatic DEFINE_PER_CPU(int, bpf_task_storage_busy);\n\nstatic void bpf_task_storage_lock(void)\n{\n\tmigrate_disable();\n\t__this_cpu_inc(bpf_task_storage_busy);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!rcu_read_lock_held()"
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock_held",
          "args": [],
          "line": 214
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "305-312",
          "snippet": "int rcu_read_lock_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\treturn lock_is_held(&rcu_lock_map);\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\treturn lock_is_held(&rcu_lock_map);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "pid"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "pid"
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pidfd_get_pid",
          "args": [
            "fd",
            "&f_flags"
          ],
          "line": 207
        },
        "resolved": true,
        "details": {
          "function_name": "pidfd_get_pid",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/pid.c",
          "lines": "523-540",
          "snippet": "struct pid *pidfd_get_pid(unsigned int fd, unsigned int *flags)\n{\n\tstruct fd f;\n\tstruct pid *pid;\n\n\tf = fdget(fd);\n\tif (!f.file)\n\t\treturn ERR_PTR(-EBADF);\n\n\tpid = pidfd_pid(f.file);\n\tif (!IS_ERR(pid)) {\n\t\tget_pid(pid);\n\t\t*flags = f.file->f_flags;\n\t}\n\n\tfdput(f);\n\treturn pid;\n}",
          "includes": [
            "#include <uapi/linux/pidfd.h>",
            "#include <net/sock.h>",
            "#include <linux/idr.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/refcount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/init_task.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/memblock.h>",
            "#include <linux/rculist.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/pidfd.h>\n#include <net/sock.h>\n#include <linux/idr.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/anon_inodes.h>\n#include <linux/refcount.h>\n#include <linux/proc_ns.h>\n#include <linux/syscalls.h>\n#include <linux/init_task.h>\n#include <linux/pid_namespace.h>\n#include <linux/memblock.h>\n#include <linux/rculist.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\nstruct pid *pidfd_get_pid(unsigned int fd, unsigned int *flags)\n{\n\tstruct fd f;\n\tstruct pid *pid;\n\n\tf = fdget(fd);\n\tif (!f.file)\n\t\treturn ERR_PTR(-EBADF);\n\n\tpid = pidfd_pid(f.file);\n\tif (!IS_ERR(pid)) {\n\t\tget_pid(pid);\n\t\t*flags = f.file->f_flags;\n\t}\n\n\tfdput(f);\n\treturn pid;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/rcupdate_trace.h>\n#include <linux/fdtable.h>\n#include <linux/btf_ids.h>\n#include <uapi/linux/btf.h>\n#include <linux/filter.h>\n#include <linux/bpf_local_storage.h>\n#include <linux/bpf.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/rculist.h>\n#include <linux/sched.h>\n#include <linux/pid.h>\n\nstatic int bpf_pid_task_storage_delete_elem(struct bpf_map *map, void *key)\n{\n\tstruct task_struct *task;\n\tunsigned int f_flags;\n\tstruct pid *pid;\n\tint fd, err;\n\n\tfd = *(int *)key;\n\tpid = pidfd_get_pid(fd, &f_flags);\n\tif (IS_ERR(pid))\n\t\treturn PTR_ERR(pid);\n\n\t/* We should be in an RCU read side critical section, it should be safe\n\t * to call pid_task.\n\t */\n\tWARN_ON_ONCE(!rcu_read_lock_held());\n\ttask = pid_task(pid, PIDTYPE_PID);\n\tif (!task) {\n\t\terr = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tbpf_task_storage_lock();\n\terr = task_storage_delete(task, map);\n\tbpf_task_storage_unlock();\nout:\n\tput_pid(pid);\n\treturn err;\n}"
  },
  {
    "function_name": "task_storage_delete",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_task_storage.c",
    "lines": "186-197",
    "snippet": "static int task_storage_delete(struct task_struct *task, struct bpf_map *map)\n{\n\tstruct bpf_local_storage_data *sdata;\n\n\tsdata = task_storage_lookup(task, map, false);\n\tif (!sdata)\n\t\treturn -ENOENT;\n\n\tbpf_selem_unlink(SELEM(sdata));\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/btf_ids.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/filter.h>",
      "#include <linux/bpf_local_storage.h>",
      "#include <linux/bpf.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/types.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/rculist.h>",
      "#include <linux/sched.h>",
      "#include <linux/pid.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bpf_selem_unlink",
          "args": [
            "SELEM(sdata)"
          ],
          "line": 194
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_selem_unlink",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_local_storage.c",
          "lines": "217-225",
          "snippet": "void bpf_selem_unlink(struct bpf_local_storage_elem *selem)\n{\n\t/* Always unlink from map before unlinking from local_storage\n\t * because selem will be freed after successfully unlinked from\n\t * the local_storage.\n\t */\n\tbpf_selem_unlink_map(selem);\n\t__bpf_selem_unlink_storage(selem);\n}",
          "includes": [
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/rcupdate.h>",
            "#include <uapi/linux/btf.h>",
            "#include <uapi/linux/sock_diag.h>",
            "#include <net/sock.h>",
            "#include <linux/bpf_local_storage.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/bpf.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/rculist.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcupdate_wait.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/rcupdate.h>\n#include <uapi/linux/btf.h>\n#include <uapi/linux/sock_diag.h>\n#include <net/sock.h>\n#include <linux/bpf_local_storage.h>\n#include <linux/btf_ids.h>\n#include <linux/bpf.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/rculist.h>\n\nvoid bpf_selem_unlink(struct bpf_local_storage_elem *selem)\n{\n\t/* Always unlink from map before unlinking from local_storage\n\t * because selem will be freed after successfully unlinked from\n\t * the local_storage.\n\t */\n\tbpf_selem_unlink_map(selem);\n\t__bpf_selem_unlink_storage(selem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SELEM",
          "args": [
            "sdata"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_storage_lookup",
          "args": [
            "task",
            "map",
            "false"
          ],
          "line": 190
        },
        "resolved": true,
        "details": {
          "function_name": "task_storage_lookup",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_task_storage.c",
          "lines": "56-70",
          "snippet": "static struct bpf_local_storage_data *\ntask_storage_lookup(struct task_struct *task, struct bpf_map *map,\n\t\t    bool cacheit_lockit)\n{\n\tstruct bpf_local_storage *task_storage;\n\tstruct bpf_local_storage_map *smap;\n\n\ttask_storage =\n\t\trcu_dereference_check(task->bpf_storage, bpf_rcu_lock_held());\n\tif (!task_storage)\n\t\treturn NULL;\n\n\tsmap = (struct bpf_local_storage_map *)map;\n\treturn bpf_local_storage_lookup(task_storage, smap, cacheit_lockit);\n}",
          "includes": [
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/btf_ids.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf_local_storage.h>",
            "#include <linux/bpf.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/rculist.h>",
            "#include <linux/sched.h>",
            "#include <linux/pid.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcupdate_trace.h>\n#include <linux/fdtable.h>\n#include <linux/btf_ids.h>\n#include <uapi/linux/btf.h>\n#include <linux/filter.h>\n#include <linux/bpf_local_storage.h>\n#include <linux/bpf.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/rculist.h>\n#include <linux/sched.h>\n#include <linux/pid.h>\n\nstatic struct bpf_local_storage_data *\ntask_storage_lookup(struct task_struct *task, struct bpf_map *map,\n\t\t    bool cacheit_lockit)\n{\n\tstruct bpf_local_storage *task_storage;\n\tstruct bpf_local_storage_map *smap;\n\n\ttask_storage =\n\t\trcu_dereference_check(task->bpf_storage, bpf_rcu_lock_held());\n\tif (!task_storage)\n\t\treturn NULL;\n\n\tsmap = (struct bpf_local_storage_map *)map;\n\treturn bpf_local_storage_lookup(task_storage, smap, cacheit_lockit);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/rcupdate_trace.h>\n#include <linux/fdtable.h>\n#include <linux/btf_ids.h>\n#include <uapi/linux/btf.h>\n#include <linux/filter.h>\n#include <linux/bpf_local_storage.h>\n#include <linux/bpf.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/rculist.h>\n#include <linux/sched.h>\n#include <linux/pid.h>\n\nstatic int task_storage_delete(struct task_struct *task, struct bpf_map *map)\n{\n\tstruct bpf_local_storage_data *sdata;\n\n\tsdata = task_storage_lookup(task, map, false);\n\tif (!sdata)\n\t\treturn -ENOENT;\n\n\tbpf_selem_unlink(SELEM(sdata));\n\n\treturn 0;\n}"
  },
  {
    "function_name": "bpf_pid_task_storage_update_elem",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_task_storage.c",
    "lines": "151-184",
    "snippet": "static int bpf_pid_task_storage_update_elem(struct bpf_map *map, void *key,\n\t\t\t\t\t    void *value, u64 map_flags)\n{\n\tstruct bpf_local_storage_data *sdata;\n\tstruct task_struct *task;\n\tunsigned int f_flags;\n\tstruct pid *pid;\n\tint fd, err;\n\n\tfd = *(int *)key;\n\tpid = pidfd_get_pid(fd, &f_flags);\n\tif (IS_ERR(pid))\n\t\treturn PTR_ERR(pid);\n\n\t/* We should be in an RCU read side critical section, it should be safe\n\t * to call pid_task.\n\t */\n\tWARN_ON_ONCE(!rcu_read_lock_held());\n\ttask = pid_task(pid, PIDTYPE_PID);\n\tif (!task) {\n\t\terr = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tbpf_task_storage_lock();\n\tsdata = bpf_local_storage_update(\n\t\ttask, (struct bpf_local_storage_map *)map, value, map_flags);\n\tbpf_task_storage_unlock();\n\n\terr = PTR_ERR_OR_ZERO(sdata);\nout:\n\tput_pid(pid);\n\treturn err;\n}",
    "includes": [
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/btf_ids.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/filter.h>",
      "#include <linux/bpf_local_storage.h>",
      "#include <linux/bpf.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/types.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/rculist.h>",
      "#include <linux/sched.h>",
      "#include <linux/pid.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_pid",
          "args": [
            "pid"
          ],
          "line": 182
        },
        "resolved": true,
        "details": {
          "function_name": "delayed_put_pid",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/pid.c",
          "lines": "120-124",
          "snippet": "static void delayed_put_pid(struct rcu_head *rhp)\n{\n\tstruct pid *pid = container_of(rhp, struct pid, rcu);\n\tput_pid(pid);\n}",
          "includes": [
            "#include <uapi/linux/pidfd.h>",
            "#include <net/sock.h>",
            "#include <linux/idr.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/refcount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/init_task.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/memblock.h>",
            "#include <linux/rculist.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/pidfd.h>\n#include <net/sock.h>\n#include <linux/idr.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/anon_inodes.h>\n#include <linux/refcount.h>\n#include <linux/proc_ns.h>\n#include <linux/syscalls.h>\n#include <linux/init_task.h>\n#include <linux/pid_namespace.h>\n#include <linux/memblock.h>\n#include <linux/rculist.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\nstatic void delayed_put_pid(struct rcu_head *rhp)\n{\n\tstruct pid *pid = container_of(rhp, struct pid, rcu);\n\tput_pid(pid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR_OR_ZERO",
          "args": [
            "sdata"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_task_storage_unlock",
          "args": [],
          "line": 178
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_task_storage_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_task_storage.c",
          "lines": "32-36",
          "snippet": "static void bpf_task_storage_unlock(void)\n{\n\t__this_cpu_dec(bpf_task_storage_busy);\n\tmigrate_enable();\n}",
          "includes": [
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/btf_ids.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf_local_storage.h>",
            "#include <linux/bpf.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/rculist.h>",
            "#include <linux/sched.h>",
            "#include <linux/pid.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(int, bpf_task_storage_busy);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcupdate_trace.h>\n#include <linux/fdtable.h>\n#include <linux/btf_ids.h>\n#include <uapi/linux/btf.h>\n#include <linux/filter.h>\n#include <linux/bpf_local_storage.h>\n#include <linux/bpf.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/rculist.h>\n#include <linux/sched.h>\n#include <linux/pid.h>\n\nstatic DEFINE_PER_CPU(int, bpf_task_storage_busy);\n\nstatic void bpf_task_storage_unlock(void)\n{\n\t__this_cpu_dec(bpf_task_storage_busy);\n\tmigrate_enable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_local_storage_update",
          "args": [
            "task",
            "(struct bpf_local_storage_map *)map",
            "value",
            "map_flags"
          ],
          "line": 176
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_local_storage_update",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_local_storage.c",
          "lines": "351-467",
          "snippet": "struct bpf_local_storage_data *\nbpf_local_storage_update(void *owner, struct bpf_local_storage_map *smap,\n\t\t\t void *value, u64 map_flags)\n{\n\tstruct bpf_local_storage_data *old_sdata = NULL;\n\tstruct bpf_local_storage_elem *selem;\n\tstruct bpf_local_storage *local_storage;\n\tunsigned long flags;\n\tint err;\n\n\t/* BPF_EXIST and BPF_NOEXIST cannot be both set */\n\tif (unlikely((map_flags & ~BPF_F_LOCK) > BPF_EXIST) ||\n\t    /* BPF_F_LOCK can only be used in a value with spin_lock */\n\t    unlikely((map_flags & BPF_F_LOCK) &&\n\t\t     !map_value_has_spin_lock(&smap->map)))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tlocal_storage = rcu_dereference_check(*owner_storage(smap, owner),\n\t\t\t\t\t      bpf_rcu_lock_held());\n\tif (!local_storage || hlist_empty(&local_storage->list)) {\n\t\t/* Very first elem for the owner */\n\t\terr = check_flags(NULL, map_flags);\n\t\tif (err)\n\t\t\treturn ERR_PTR(err);\n\n\t\tselem = bpf_selem_alloc(smap, owner, value, true);\n\t\tif (!selem)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\n\t\terr = bpf_local_storage_alloc(owner, smap, selem);\n\t\tif (err) {\n\t\t\tkfree(selem);\n\t\t\tmem_uncharge(smap, owner, smap->elem_size);\n\t\t\treturn ERR_PTR(err);\n\t\t}\n\n\t\treturn SDATA(selem);\n\t}\n\n\tif ((map_flags & BPF_F_LOCK) && !(map_flags & BPF_NOEXIST)) {\n\t\t/* Hoping to find an old_sdata to do inline update\n\t\t * such that it can avoid taking the local_storage->lock\n\t\t * and changing the lists.\n\t\t */\n\t\told_sdata =\n\t\t\tbpf_local_storage_lookup(local_storage, smap, false);\n\t\terr = check_flags(old_sdata, map_flags);\n\t\tif (err)\n\t\t\treturn ERR_PTR(err);\n\t\tif (old_sdata && selem_linked_to_storage(SELEM(old_sdata))) {\n\t\t\tcopy_map_value_locked(&smap->map, old_sdata->data,\n\t\t\t\t\t      value, false);\n\t\t\treturn old_sdata;\n\t\t}\n\t}\n\n\traw_spin_lock_irqsave(&local_storage->lock, flags);\n\n\t/* Recheck local_storage->list under local_storage->lock */\n\tif (unlikely(hlist_empty(&local_storage->list))) {\n\t\t/* A parallel del is happening and local_storage is going\n\t\t * away.  It has just been checked before, so very\n\t\t * unlikely.  Return instead of retry to keep things\n\t\t * simple.\n\t\t */\n\t\terr = -EAGAIN;\n\t\tgoto unlock_err;\n\t}\n\n\told_sdata = bpf_local_storage_lookup(local_storage, smap, false);\n\terr = check_flags(old_sdata, map_flags);\n\tif (err)\n\t\tgoto unlock_err;\n\n\tif (old_sdata && (map_flags & BPF_F_LOCK)) {\n\t\tcopy_map_value_locked(&smap->map, old_sdata->data, value,\n\t\t\t\t      false);\n\t\tselem = SELEM(old_sdata);\n\t\tgoto unlock;\n\t}\n\n\t/* local_storage->lock is held.  Hence, we are sure\n\t * we can unlink and uncharge the old_sdata successfully\n\t * later.  Hence, instead of charging the new selem now\n\t * and then uncharge the old selem later (which may cause\n\t * a potential but unnecessary charge failure),  avoid taking\n\t * a charge at all here (the \"!old_sdata\" check) and the\n\t * old_sdata will not be uncharged later during\n\t * bpf_selem_unlink_storage_nolock().\n\t */\n\tselem = bpf_selem_alloc(smap, owner, value, !old_sdata);\n\tif (!selem) {\n\t\terr = -ENOMEM;\n\t\tgoto unlock_err;\n\t}\n\n\t/* First, link the new selem to the map */\n\tbpf_selem_link_map(smap, selem);\n\n\t/* Second, link (and publish) the new selem to local_storage */\n\tbpf_selem_link_storage_nolock(local_storage, selem);\n\n\t/* Third, remove old selem, SELEM(old_sdata) */\n\tif (old_sdata) {\n\t\tbpf_selem_unlink_map(SELEM(old_sdata));\n\t\tbpf_selem_unlink_storage_nolock(local_storage, SELEM(old_sdata),\n\t\t\t\t\t\tfalse);\n\t}\n\nunlock:\n\traw_spin_unlock_irqrestore(&local_storage->lock, flags);\n\treturn SDATA(selem);\n\nunlock_err:\n\traw_spin_unlock_irqrestore(&local_storage->lock, flags);\n\treturn ERR_PTR(err);\n}",
          "includes": [
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/rcupdate.h>",
            "#include <uapi/linux/btf.h>",
            "#include <uapi/linux/sock_diag.h>",
            "#include <net/sock.h>",
            "#include <linux/bpf_local_storage.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/bpf.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/rculist.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcupdate_wait.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/rcupdate.h>\n#include <uapi/linux/btf.h>\n#include <uapi/linux/sock_diag.h>\n#include <net/sock.h>\n#include <linux/bpf_local_storage.h>\n#include <linux/btf_ids.h>\n#include <linux/bpf.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/rculist.h>\n\nstruct bpf_local_storage_data *\nbpf_local_storage_update(void *owner, struct bpf_local_storage_map *smap,\n\t\t\t void *value, u64 map_flags)\n{\n\tstruct bpf_local_storage_data *old_sdata = NULL;\n\tstruct bpf_local_storage_elem *selem;\n\tstruct bpf_local_storage *local_storage;\n\tunsigned long flags;\n\tint err;\n\n\t/* BPF_EXIST and BPF_NOEXIST cannot be both set */\n\tif (unlikely((map_flags & ~BPF_F_LOCK) > BPF_EXIST) ||\n\t    /* BPF_F_LOCK can only be used in a value with spin_lock */\n\t    unlikely((map_flags & BPF_F_LOCK) &&\n\t\t     !map_value_has_spin_lock(&smap->map)))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tlocal_storage = rcu_dereference_check(*owner_storage(smap, owner),\n\t\t\t\t\t      bpf_rcu_lock_held());\n\tif (!local_storage || hlist_empty(&local_storage->list)) {\n\t\t/* Very first elem for the owner */\n\t\terr = check_flags(NULL, map_flags);\n\t\tif (err)\n\t\t\treturn ERR_PTR(err);\n\n\t\tselem = bpf_selem_alloc(smap, owner, value, true);\n\t\tif (!selem)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\n\t\terr = bpf_local_storage_alloc(owner, smap, selem);\n\t\tif (err) {\n\t\t\tkfree(selem);\n\t\t\tmem_uncharge(smap, owner, smap->elem_size);\n\t\t\treturn ERR_PTR(err);\n\t\t}\n\n\t\treturn SDATA(selem);\n\t}\n\n\tif ((map_flags & BPF_F_LOCK) && !(map_flags & BPF_NOEXIST)) {\n\t\t/* Hoping to find an old_sdata to do inline update\n\t\t * such that it can avoid taking the local_storage->lock\n\t\t * and changing the lists.\n\t\t */\n\t\told_sdata =\n\t\t\tbpf_local_storage_lookup(local_storage, smap, false);\n\t\terr = check_flags(old_sdata, map_flags);\n\t\tif (err)\n\t\t\treturn ERR_PTR(err);\n\t\tif (old_sdata && selem_linked_to_storage(SELEM(old_sdata))) {\n\t\t\tcopy_map_value_locked(&smap->map, old_sdata->data,\n\t\t\t\t\t      value, false);\n\t\t\treturn old_sdata;\n\t\t}\n\t}\n\n\traw_spin_lock_irqsave(&local_storage->lock, flags);\n\n\t/* Recheck local_storage->list under local_storage->lock */\n\tif (unlikely(hlist_empty(&local_storage->list))) {\n\t\t/* A parallel del is happening and local_storage is going\n\t\t * away.  It has just been checked before, so very\n\t\t * unlikely.  Return instead of retry to keep things\n\t\t * simple.\n\t\t */\n\t\terr = -EAGAIN;\n\t\tgoto unlock_err;\n\t}\n\n\told_sdata = bpf_local_storage_lookup(local_storage, smap, false);\n\terr = check_flags(old_sdata, map_flags);\n\tif (err)\n\t\tgoto unlock_err;\n\n\tif (old_sdata && (map_flags & BPF_F_LOCK)) {\n\t\tcopy_map_value_locked(&smap->map, old_sdata->data, value,\n\t\t\t\t      false);\n\t\tselem = SELEM(old_sdata);\n\t\tgoto unlock;\n\t}\n\n\t/* local_storage->lock is held.  Hence, we are sure\n\t * we can unlink and uncharge the old_sdata successfully\n\t * later.  Hence, instead of charging the new selem now\n\t * and then uncharge the old selem later (which may cause\n\t * a potential but unnecessary charge failure),  avoid taking\n\t * a charge at all here (the \"!old_sdata\" check) and the\n\t * old_sdata will not be uncharged later during\n\t * bpf_selem_unlink_storage_nolock().\n\t */\n\tselem = bpf_selem_alloc(smap, owner, value, !old_sdata);\n\tif (!selem) {\n\t\terr = -ENOMEM;\n\t\tgoto unlock_err;\n\t}\n\n\t/* First, link the new selem to the map */\n\tbpf_selem_link_map(smap, selem);\n\n\t/* Second, link (and publish) the new selem to local_storage */\n\tbpf_selem_link_storage_nolock(local_storage, selem);\n\n\t/* Third, remove old selem, SELEM(old_sdata) */\n\tif (old_sdata) {\n\t\tbpf_selem_unlink_map(SELEM(old_sdata));\n\t\tbpf_selem_unlink_storage_nolock(local_storage, SELEM(old_sdata),\n\t\t\t\t\t\tfalse);\n\t}\n\nunlock:\n\traw_spin_unlock_irqrestore(&local_storage->lock, flags);\n\treturn SDATA(selem);\n\nunlock_err:\n\traw_spin_unlock_irqrestore(&local_storage->lock, flags);\n\treturn ERR_PTR(err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_task_storage_lock",
          "args": [],
          "line": 175
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_task_storage_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_task_storage.c",
          "lines": "26-30",
          "snippet": "static void bpf_task_storage_lock(void)\n{\n\tmigrate_disable();\n\t__this_cpu_inc(bpf_task_storage_busy);\n}",
          "includes": [
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/btf_ids.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf_local_storage.h>",
            "#include <linux/bpf.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/rculist.h>",
            "#include <linux/sched.h>",
            "#include <linux/pid.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(int, bpf_task_storage_busy);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcupdate_trace.h>\n#include <linux/fdtable.h>\n#include <linux/btf_ids.h>\n#include <uapi/linux/btf.h>\n#include <linux/filter.h>\n#include <linux/bpf_local_storage.h>\n#include <linux/bpf.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/rculist.h>\n#include <linux/sched.h>\n#include <linux/pid.h>\n\nstatic DEFINE_PER_CPU(int, bpf_task_storage_busy);\n\nstatic void bpf_task_storage_lock(void)\n{\n\tmigrate_disable();\n\t__this_cpu_inc(bpf_task_storage_busy);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pid_task",
          "args": [
            "pid",
            "PIDTYPE_PID"
          ],
          "line": 169
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_pid_task_storage_delete_elem",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_task_storage.c",
          "lines": "199-227",
          "snippet": "static int bpf_pid_task_storage_delete_elem(struct bpf_map *map, void *key)\n{\n\tstruct task_struct *task;\n\tunsigned int f_flags;\n\tstruct pid *pid;\n\tint fd, err;\n\n\tfd = *(int *)key;\n\tpid = pidfd_get_pid(fd, &f_flags);\n\tif (IS_ERR(pid))\n\t\treturn PTR_ERR(pid);\n\n\t/* We should be in an RCU read side critical section, it should be safe\n\t * to call pid_task.\n\t */\n\tWARN_ON_ONCE(!rcu_read_lock_held());\n\ttask = pid_task(pid, PIDTYPE_PID);\n\tif (!task) {\n\t\terr = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tbpf_task_storage_lock();\n\terr = task_storage_delete(task, map);\n\tbpf_task_storage_unlock();\nout:\n\tput_pid(pid);\n\treturn err;\n}",
          "includes": [
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/btf_ids.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf_local_storage.h>",
            "#include <linux/bpf.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/rculist.h>",
            "#include <linux/sched.h>",
            "#include <linux/pid.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcupdate_trace.h>\n#include <linux/fdtable.h>\n#include <linux/btf_ids.h>\n#include <uapi/linux/btf.h>\n#include <linux/filter.h>\n#include <linux/bpf_local_storage.h>\n#include <linux/bpf.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/rculist.h>\n#include <linux/sched.h>\n#include <linux/pid.h>\n\nstatic int bpf_pid_task_storage_delete_elem(struct bpf_map *map, void *key)\n{\n\tstruct task_struct *task;\n\tunsigned int f_flags;\n\tstruct pid *pid;\n\tint fd, err;\n\n\tfd = *(int *)key;\n\tpid = pidfd_get_pid(fd, &f_flags);\n\tif (IS_ERR(pid))\n\t\treturn PTR_ERR(pid);\n\n\t/* We should be in an RCU read side critical section, it should be safe\n\t * to call pid_task.\n\t */\n\tWARN_ON_ONCE(!rcu_read_lock_held());\n\ttask = pid_task(pid, PIDTYPE_PID);\n\tif (!task) {\n\t\terr = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tbpf_task_storage_lock();\n\terr = task_storage_delete(task, map);\n\tbpf_task_storage_unlock();\nout:\n\tput_pid(pid);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!rcu_read_lock_held()"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock_held",
          "args": [],
          "line": 168
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "305-312",
          "snippet": "int rcu_read_lock_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\treturn lock_is_held(&rcu_lock_map);\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\treturn lock_is_held(&rcu_lock_map);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "pid"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "pid"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pidfd_get_pid",
          "args": [
            "fd",
            "&f_flags"
          ],
          "line": 161
        },
        "resolved": true,
        "details": {
          "function_name": "pidfd_get_pid",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/pid.c",
          "lines": "523-540",
          "snippet": "struct pid *pidfd_get_pid(unsigned int fd, unsigned int *flags)\n{\n\tstruct fd f;\n\tstruct pid *pid;\n\n\tf = fdget(fd);\n\tif (!f.file)\n\t\treturn ERR_PTR(-EBADF);\n\n\tpid = pidfd_pid(f.file);\n\tif (!IS_ERR(pid)) {\n\t\tget_pid(pid);\n\t\t*flags = f.file->f_flags;\n\t}\n\n\tfdput(f);\n\treturn pid;\n}",
          "includes": [
            "#include <uapi/linux/pidfd.h>",
            "#include <net/sock.h>",
            "#include <linux/idr.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/refcount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/init_task.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/memblock.h>",
            "#include <linux/rculist.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/pidfd.h>\n#include <net/sock.h>\n#include <linux/idr.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/anon_inodes.h>\n#include <linux/refcount.h>\n#include <linux/proc_ns.h>\n#include <linux/syscalls.h>\n#include <linux/init_task.h>\n#include <linux/pid_namespace.h>\n#include <linux/memblock.h>\n#include <linux/rculist.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\nstruct pid *pidfd_get_pid(unsigned int fd, unsigned int *flags)\n{\n\tstruct fd f;\n\tstruct pid *pid;\n\n\tf = fdget(fd);\n\tif (!f.file)\n\t\treturn ERR_PTR(-EBADF);\n\n\tpid = pidfd_pid(f.file);\n\tif (!IS_ERR(pid)) {\n\t\tget_pid(pid);\n\t\t*flags = f.file->f_flags;\n\t}\n\n\tfdput(f);\n\treturn pid;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/rcupdate_trace.h>\n#include <linux/fdtable.h>\n#include <linux/btf_ids.h>\n#include <uapi/linux/btf.h>\n#include <linux/filter.h>\n#include <linux/bpf_local_storage.h>\n#include <linux/bpf.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/rculist.h>\n#include <linux/sched.h>\n#include <linux/pid.h>\n\nstatic int bpf_pid_task_storage_update_elem(struct bpf_map *map, void *key,\n\t\t\t\t\t    void *value, u64 map_flags)\n{\n\tstruct bpf_local_storage_data *sdata;\n\tstruct task_struct *task;\n\tunsigned int f_flags;\n\tstruct pid *pid;\n\tint fd, err;\n\n\tfd = *(int *)key;\n\tpid = pidfd_get_pid(fd, &f_flags);\n\tif (IS_ERR(pid))\n\t\treturn PTR_ERR(pid);\n\n\t/* We should be in an RCU read side critical section, it should be safe\n\t * to call pid_task.\n\t */\n\tWARN_ON_ONCE(!rcu_read_lock_held());\n\ttask = pid_task(pid, PIDTYPE_PID);\n\tif (!task) {\n\t\terr = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tbpf_task_storage_lock();\n\tsdata = bpf_local_storage_update(\n\t\ttask, (struct bpf_local_storage_map *)map, value, map_flags);\n\tbpf_task_storage_unlock();\n\n\terr = PTR_ERR_OR_ZERO(sdata);\nout:\n\tput_pid(pid);\n\treturn err;\n}"
  },
  {
    "function_name": "bpf_pid_task_storage_lookup_elem",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_task_storage.c",
    "lines": "118-149",
    "snippet": "static void *bpf_pid_task_storage_lookup_elem(struct bpf_map *map, void *key)\n{\n\tstruct bpf_local_storage_data *sdata;\n\tstruct task_struct *task;\n\tunsigned int f_flags;\n\tstruct pid *pid;\n\tint fd, err;\n\n\tfd = *(int *)key;\n\tpid = pidfd_get_pid(fd, &f_flags);\n\tif (IS_ERR(pid))\n\t\treturn ERR_CAST(pid);\n\n\t/* We should be in an RCU read side critical section, it should be safe\n\t * to call pid_task.\n\t */\n\tWARN_ON_ONCE(!rcu_read_lock_held());\n\ttask = pid_task(pid, PIDTYPE_PID);\n\tif (!task) {\n\t\terr = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tbpf_task_storage_lock();\n\tsdata = task_storage_lookup(task, map, true);\n\tbpf_task_storage_unlock();\n\tput_pid(pid);\n\treturn sdata ? sdata->data : NULL;\nout:\n\tput_pid(pid);\n\treturn ERR_PTR(err);\n}",
    "includes": [
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/btf_ids.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/filter.h>",
      "#include <linux/bpf_local_storage.h>",
      "#include <linux/bpf.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/types.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/rculist.h>",
      "#include <linux/sched.h>",
      "#include <linux/pid.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "err"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_pid",
          "args": [
            "pid"
          ],
          "line": 147
        },
        "resolved": true,
        "details": {
          "function_name": "delayed_put_pid",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/pid.c",
          "lines": "120-124",
          "snippet": "static void delayed_put_pid(struct rcu_head *rhp)\n{\n\tstruct pid *pid = container_of(rhp, struct pid, rcu);\n\tput_pid(pid);\n}",
          "includes": [
            "#include <uapi/linux/pidfd.h>",
            "#include <net/sock.h>",
            "#include <linux/idr.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/refcount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/init_task.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/memblock.h>",
            "#include <linux/rculist.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/pidfd.h>\n#include <net/sock.h>\n#include <linux/idr.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/anon_inodes.h>\n#include <linux/refcount.h>\n#include <linux/proc_ns.h>\n#include <linux/syscalls.h>\n#include <linux/init_task.h>\n#include <linux/pid_namespace.h>\n#include <linux/memblock.h>\n#include <linux/rculist.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\nstatic void delayed_put_pid(struct rcu_head *rhp)\n{\n\tstruct pid *pid = container_of(rhp, struct pid, rcu);\n\tput_pid(pid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_task_storage_unlock",
          "args": [],
          "line": 143
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_task_storage_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_task_storage.c",
          "lines": "32-36",
          "snippet": "static void bpf_task_storage_unlock(void)\n{\n\t__this_cpu_dec(bpf_task_storage_busy);\n\tmigrate_enable();\n}",
          "includes": [
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/btf_ids.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf_local_storage.h>",
            "#include <linux/bpf.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/rculist.h>",
            "#include <linux/sched.h>",
            "#include <linux/pid.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(int, bpf_task_storage_busy);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcupdate_trace.h>\n#include <linux/fdtable.h>\n#include <linux/btf_ids.h>\n#include <uapi/linux/btf.h>\n#include <linux/filter.h>\n#include <linux/bpf_local_storage.h>\n#include <linux/bpf.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/rculist.h>\n#include <linux/sched.h>\n#include <linux/pid.h>\n\nstatic DEFINE_PER_CPU(int, bpf_task_storage_busy);\n\nstatic void bpf_task_storage_unlock(void)\n{\n\t__this_cpu_dec(bpf_task_storage_busy);\n\tmigrate_enable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_storage_lookup",
          "args": [
            "task",
            "map",
            "true"
          ],
          "line": 142
        },
        "resolved": true,
        "details": {
          "function_name": "task_storage_lookup",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_task_storage.c",
          "lines": "56-70",
          "snippet": "static struct bpf_local_storage_data *\ntask_storage_lookup(struct task_struct *task, struct bpf_map *map,\n\t\t    bool cacheit_lockit)\n{\n\tstruct bpf_local_storage *task_storage;\n\tstruct bpf_local_storage_map *smap;\n\n\ttask_storage =\n\t\trcu_dereference_check(task->bpf_storage, bpf_rcu_lock_held());\n\tif (!task_storage)\n\t\treturn NULL;\n\n\tsmap = (struct bpf_local_storage_map *)map;\n\treturn bpf_local_storage_lookup(task_storage, smap, cacheit_lockit);\n}",
          "includes": [
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/btf_ids.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf_local_storage.h>",
            "#include <linux/bpf.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/rculist.h>",
            "#include <linux/sched.h>",
            "#include <linux/pid.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcupdate_trace.h>\n#include <linux/fdtable.h>\n#include <linux/btf_ids.h>\n#include <uapi/linux/btf.h>\n#include <linux/filter.h>\n#include <linux/bpf_local_storage.h>\n#include <linux/bpf.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/rculist.h>\n#include <linux/sched.h>\n#include <linux/pid.h>\n\nstatic struct bpf_local_storage_data *\ntask_storage_lookup(struct task_struct *task, struct bpf_map *map,\n\t\t    bool cacheit_lockit)\n{\n\tstruct bpf_local_storage *task_storage;\n\tstruct bpf_local_storage_map *smap;\n\n\ttask_storage =\n\t\trcu_dereference_check(task->bpf_storage, bpf_rcu_lock_held());\n\tif (!task_storage)\n\t\treturn NULL;\n\n\tsmap = (struct bpf_local_storage_map *)map;\n\treturn bpf_local_storage_lookup(task_storage, smap, cacheit_lockit);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_task_storage_lock",
          "args": [],
          "line": 141
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_task_storage_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_task_storage.c",
          "lines": "26-30",
          "snippet": "static void bpf_task_storage_lock(void)\n{\n\tmigrate_disable();\n\t__this_cpu_inc(bpf_task_storage_busy);\n}",
          "includes": [
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/btf_ids.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf_local_storage.h>",
            "#include <linux/bpf.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/rculist.h>",
            "#include <linux/sched.h>",
            "#include <linux/pid.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(int, bpf_task_storage_busy);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcupdate_trace.h>\n#include <linux/fdtable.h>\n#include <linux/btf_ids.h>\n#include <uapi/linux/btf.h>\n#include <linux/filter.h>\n#include <linux/bpf_local_storage.h>\n#include <linux/bpf.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/rculist.h>\n#include <linux/sched.h>\n#include <linux/pid.h>\n\nstatic DEFINE_PER_CPU(int, bpf_task_storage_busy);\n\nstatic void bpf_task_storage_lock(void)\n{\n\tmigrate_disable();\n\t__this_cpu_inc(bpf_task_storage_busy);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pid_task",
          "args": [
            "pid",
            "PIDTYPE_PID"
          ],
          "line": 135
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_pid_task_storage_delete_elem",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_task_storage.c",
          "lines": "199-227",
          "snippet": "static int bpf_pid_task_storage_delete_elem(struct bpf_map *map, void *key)\n{\n\tstruct task_struct *task;\n\tunsigned int f_flags;\n\tstruct pid *pid;\n\tint fd, err;\n\n\tfd = *(int *)key;\n\tpid = pidfd_get_pid(fd, &f_flags);\n\tif (IS_ERR(pid))\n\t\treturn PTR_ERR(pid);\n\n\t/* We should be in an RCU read side critical section, it should be safe\n\t * to call pid_task.\n\t */\n\tWARN_ON_ONCE(!rcu_read_lock_held());\n\ttask = pid_task(pid, PIDTYPE_PID);\n\tif (!task) {\n\t\terr = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tbpf_task_storage_lock();\n\terr = task_storage_delete(task, map);\n\tbpf_task_storage_unlock();\nout:\n\tput_pid(pid);\n\treturn err;\n}",
          "includes": [
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/btf_ids.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf_local_storage.h>",
            "#include <linux/bpf.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/rculist.h>",
            "#include <linux/sched.h>",
            "#include <linux/pid.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcupdate_trace.h>\n#include <linux/fdtable.h>\n#include <linux/btf_ids.h>\n#include <uapi/linux/btf.h>\n#include <linux/filter.h>\n#include <linux/bpf_local_storage.h>\n#include <linux/bpf.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/rculist.h>\n#include <linux/sched.h>\n#include <linux/pid.h>\n\nstatic int bpf_pid_task_storage_delete_elem(struct bpf_map *map, void *key)\n{\n\tstruct task_struct *task;\n\tunsigned int f_flags;\n\tstruct pid *pid;\n\tint fd, err;\n\n\tfd = *(int *)key;\n\tpid = pidfd_get_pid(fd, &f_flags);\n\tif (IS_ERR(pid))\n\t\treturn PTR_ERR(pid);\n\n\t/* We should be in an RCU read side critical section, it should be safe\n\t * to call pid_task.\n\t */\n\tWARN_ON_ONCE(!rcu_read_lock_held());\n\ttask = pid_task(pid, PIDTYPE_PID);\n\tif (!task) {\n\t\terr = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tbpf_task_storage_lock();\n\terr = task_storage_delete(task, map);\n\tbpf_task_storage_unlock();\nout:\n\tput_pid(pid);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!rcu_read_lock_held()"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock_held",
          "args": [],
          "line": 134
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "305-312",
          "snippet": "int rcu_read_lock_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\treturn lock_is_held(&rcu_lock_map);\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\treturn lock_is_held(&rcu_lock_map);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_CAST",
          "args": [
            "pid"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "pid"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pidfd_get_pid",
          "args": [
            "fd",
            "&f_flags"
          ],
          "line": 127
        },
        "resolved": true,
        "details": {
          "function_name": "pidfd_get_pid",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/pid.c",
          "lines": "523-540",
          "snippet": "struct pid *pidfd_get_pid(unsigned int fd, unsigned int *flags)\n{\n\tstruct fd f;\n\tstruct pid *pid;\n\n\tf = fdget(fd);\n\tif (!f.file)\n\t\treturn ERR_PTR(-EBADF);\n\n\tpid = pidfd_pid(f.file);\n\tif (!IS_ERR(pid)) {\n\t\tget_pid(pid);\n\t\t*flags = f.file->f_flags;\n\t}\n\n\tfdput(f);\n\treturn pid;\n}",
          "includes": [
            "#include <uapi/linux/pidfd.h>",
            "#include <net/sock.h>",
            "#include <linux/idr.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/refcount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/init_task.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/memblock.h>",
            "#include <linux/rculist.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/pidfd.h>\n#include <net/sock.h>\n#include <linux/idr.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/anon_inodes.h>\n#include <linux/refcount.h>\n#include <linux/proc_ns.h>\n#include <linux/syscalls.h>\n#include <linux/init_task.h>\n#include <linux/pid_namespace.h>\n#include <linux/memblock.h>\n#include <linux/rculist.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\nstruct pid *pidfd_get_pid(unsigned int fd, unsigned int *flags)\n{\n\tstruct fd f;\n\tstruct pid *pid;\n\n\tf = fdget(fd);\n\tif (!f.file)\n\t\treturn ERR_PTR(-EBADF);\n\n\tpid = pidfd_pid(f.file);\n\tif (!IS_ERR(pid)) {\n\t\tget_pid(pid);\n\t\t*flags = f.file->f_flags;\n\t}\n\n\tfdput(f);\n\treturn pid;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/rcupdate_trace.h>\n#include <linux/fdtable.h>\n#include <linux/btf_ids.h>\n#include <uapi/linux/btf.h>\n#include <linux/filter.h>\n#include <linux/bpf_local_storage.h>\n#include <linux/bpf.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/rculist.h>\n#include <linux/sched.h>\n#include <linux/pid.h>\n\nstatic void *bpf_pid_task_storage_lookup_elem(struct bpf_map *map, void *key)\n{\n\tstruct bpf_local_storage_data *sdata;\n\tstruct task_struct *task;\n\tunsigned int f_flags;\n\tstruct pid *pid;\n\tint fd, err;\n\n\tfd = *(int *)key;\n\tpid = pidfd_get_pid(fd, &f_flags);\n\tif (IS_ERR(pid))\n\t\treturn ERR_CAST(pid);\n\n\t/* We should be in an RCU read side critical section, it should be safe\n\t * to call pid_task.\n\t */\n\tWARN_ON_ONCE(!rcu_read_lock_held());\n\ttask = pid_task(pid, PIDTYPE_PID);\n\tif (!task) {\n\t\terr = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tbpf_task_storage_lock();\n\tsdata = task_storage_lookup(task, map, true);\n\tbpf_task_storage_unlock();\n\tput_pid(pid);\n\treturn sdata ? sdata->data : NULL;\nout:\n\tput_pid(pid);\n\treturn ERR_PTR(err);\n}"
  },
  {
    "function_name": "bpf_task_storage_free",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_task_storage.c",
    "lines": "72-116",
    "snippet": "void bpf_task_storage_free(struct task_struct *task)\n{\n\tstruct bpf_local_storage_elem *selem;\n\tstruct bpf_local_storage *local_storage;\n\tbool free_task_storage = false;\n\tstruct hlist_node *n;\n\tunsigned long flags;\n\n\trcu_read_lock();\n\n\tlocal_storage = rcu_dereference(task->bpf_storage);\n\tif (!local_storage) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Neither the bpf_prog nor the bpf-map's syscall\n\t * could be modifying the local_storage->list now.\n\t * Thus, no elem can be added-to or deleted-from the\n\t * local_storage->list by the bpf_prog or by the bpf-map's syscall.\n\t *\n\t * It is racing with bpf_local_storage_map_free() alone\n\t * when unlinking elem from the local_storage->list and\n\t * the map's bucket->list.\n\t */\n\tbpf_task_storage_lock();\n\traw_spin_lock_irqsave(&local_storage->lock, flags);\n\thlist_for_each_entry_safe(selem, n, &local_storage->list, snode) {\n\t\t/* Always unlink from map before unlinking from\n\t\t * local_storage.\n\t\t */\n\t\tbpf_selem_unlink_map(selem);\n\t\tfree_task_storage = bpf_selem_unlink_storage_nolock(\n\t\t\tlocal_storage, selem, false);\n\t}\n\traw_spin_unlock_irqrestore(&local_storage->lock, flags);\n\tbpf_task_storage_unlock();\n\trcu_read_unlock();\n\n\t/* free_task_storage should always be true as long as\n\t * local_storage->list was non-empty.\n\t */\n\tif (free_task_storage)\n\t\tkfree_rcu(local_storage, rcu);\n}",
    "includes": [
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/btf_ids.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/filter.h>",
      "#include <linux/bpf_local_storage.h>",
      "#include <linux/bpf.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/types.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/rculist.h>",
      "#include <linux/sched.h>",
      "#include <linux/pid.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree_rcu",
          "args": [
            "local_storage",
            "rcu"
          ],
          "line": 115
        },
        "resolved": true,
        "details": {
          "function_name": "kfree_rcu_shrink_scan",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "3649-3670",
          "snippet": "static unsigned long\nkfree_rcu_shrink_scan(struct shrinker *shrink, struct shrink_control *sc)\n{\n\tint cpu, freed = 0;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tint count;\n\t\tstruct kfree_rcu_cpu *krcp = per_cpu_ptr(&krc, cpu);\n\n\t\tcount = krcp->count;\n\t\tcount += drain_page_cache(krcp);\n\t\tkfree_rcu_monitor(&krcp->monitor_work.work);\n\n\t\tsc->nr_to_scan -= count;\n\t\tfreed += count;\n\n\t\tif (sc->nr_to_scan <= 0)\n\t\t\tbreak;\n\t}\n\n\treturn freed == 0 ? SHRINK_STOP : freed;\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void sync_sched_exp_online_cleanup(int cpu);",
            "static DEFINE_PER_CPU(struct kfree_rcu_cpu, krc) = {\n\t.lock = __RAW_SPIN_LOCK_UNLOCKED(krc.lock),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic void sync_sched_exp_online_cleanup(int cpu);\nstatic DEFINE_PER_CPU(struct kfree_rcu_cpu, krc) = {\n\t.lock = __RAW_SPIN_LOCK_UNLOCKED(krc.lock),\n};\n\nstatic unsigned long\nkfree_rcu_shrink_scan(struct shrinker *shrink, struct shrink_control *sc)\n{\n\tint cpu, freed = 0;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tint count;\n\t\tstruct kfree_rcu_cpu *krcp = per_cpu_ptr(&krc, cpu);\n\n\t\tcount = krcp->count;\n\t\tcount += drain_page_cache(krcp);\n\t\tkfree_rcu_monitor(&krcp->monitor_work.work);\n\n\t\tsc->nr_to_scan -= count;\n\t\tfreed += count;\n\n\t\tif (sc->nr_to_scan <= 0)\n\t\t\tbreak;\n\t}\n\n\treturn freed == 0 ? SHRINK_STOP : freed;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 109
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_unlock_strict",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "815-824",
          "snippet": "void rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nvoid rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_task_storage_unlock",
          "args": [],
          "line": 108
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_task_storage_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_task_storage.c",
          "lines": "32-36",
          "snippet": "static void bpf_task_storage_unlock(void)\n{\n\t__this_cpu_dec(bpf_task_storage_busy);\n\tmigrate_enable();\n}",
          "includes": [
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/btf_ids.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf_local_storage.h>",
            "#include <linux/bpf.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/rculist.h>",
            "#include <linux/sched.h>",
            "#include <linux/pid.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(int, bpf_task_storage_busy);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcupdate_trace.h>\n#include <linux/fdtable.h>\n#include <linux/btf_ids.h>\n#include <uapi/linux/btf.h>\n#include <linux/filter.h>\n#include <linux/bpf_local_storage.h>\n#include <linux/bpf.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/rculist.h>\n#include <linux/sched.h>\n#include <linux/pid.h>\n\nstatic DEFINE_PER_CPU(int, bpf_task_storage_busy);\n\nstatic void bpf_task_storage_unlock(void)\n{\n\t__this_cpu_dec(bpf_task_storage_busy);\n\tmigrate_enable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore",
          "args": [
            "&local_storage->lock",
            "flags"
          ],
          "line": 107
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "192-195",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_selem_unlink_storage_nolock",
          "args": [
            "local_storage",
            "selem",
            "false"
          ],
          "line": 104
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_selem_unlink_storage_nolock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_local_storage.c",
          "lines": "107-155",
          "snippet": "bool bpf_selem_unlink_storage_nolock(struct bpf_local_storage *local_storage,\n\t\t\t\t     struct bpf_local_storage_elem *selem,\n\t\t\t\t     bool uncharge_mem)\n{\n\tstruct bpf_local_storage_map *smap;\n\tbool free_local_storage;\n\tvoid *owner;\n\n\tsmap = rcu_dereference_check(SDATA(selem)->smap, bpf_rcu_lock_held());\n\towner = local_storage->owner;\n\n\t/* All uncharging on the owner must be done first.\n\t * The owner may be freed once the last selem is unlinked\n\t * from local_storage.\n\t */\n\tif (uncharge_mem)\n\t\tmem_uncharge(smap, owner, smap->elem_size);\n\n\tfree_local_storage = hlist_is_singular_node(&selem->snode,\n\t\t\t\t\t\t    &local_storage->list);\n\tif (free_local_storage) {\n\t\tmem_uncharge(smap, owner, sizeof(struct bpf_local_storage));\n\t\tlocal_storage->owner = NULL;\n\n\t\t/* After this RCU_INIT, owner may be freed and cannot be used */\n\t\tRCU_INIT_POINTER(*owner_storage(smap, owner), NULL);\n\n\t\t/* local_storage is not freed now.  local_storage->lock is\n\t\t * still held and raw_spin_unlock_bh(&local_storage->lock)\n\t\t * will be done by the caller.\n\t\t *\n\t\t * Although the unlock will be done under\n\t\t * rcu_read_lock(),  it is more intutivie to\n\t\t * read if the freeing of the storage is done\n\t\t * after the raw_spin_unlock_bh(&local_storage->lock).\n\t\t *\n\t\t * Hence, a \"bool free_local_storage\" is returned\n\t\t * to the caller which then calls then frees the storage after\n\t\t * all the RCU grace periods have expired.\n\t\t */\n\t}\n\thlist_del_init_rcu(&selem->snode);\n\tif (rcu_access_pointer(local_storage->cache[smap->cache_idx]) ==\n\t    SDATA(selem))\n\t\tRCU_INIT_POINTER(local_storage->cache[smap->cache_idx], NULL);\n\n\tcall_rcu_tasks_trace(&selem->rcu, bpf_selem_free_rcu);\n\treturn free_local_storage;\n}",
          "includes": [
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/rcupdate.h>",
            "#include <uapi/linux/btf.h>",
            "#include <uapi/linux/sock_diag.h>",
            "#include <net/sock.h>",
            "#include <linux/bpf_local_storage.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/bpf.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/rculist.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcupdate_wait.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/rcupdate.h>\n#include <uapi/linux/btf.h>\n#include <uapi/linux/sock_diag.h>\n#include <net/sock.h>\n#include <linux/bpf_local_storage.h>\n#include <linux/btf_ids.h>\n#include <linux/bpf.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/rculist.h>\n\nbool bpf_selem_unlink_storage_nolock(struct bpf_local_storage *local_storage,\n\t\t\t\t     struct bpf_local_storage_elem *selem,\n\t\t\t\t     bool uncharge_mem)\n{\n\tstruct bpf_local_storage_map *smap;\n\tbool free_local_storage;\n\tvoid *owner;\n\n\tsmap = rcu_dereference_check(SDATA(selem)->smap, bpf_rcu_lock_held());\n\towner = local_storage->owner;\n\n\t/* All uncharging on the owner must be done first.\n\t * The owner may be freed once the last selem is unlinked\n\t * from local_storage.\n\t */\n\tif (uncharge_mem)\n\t\tmem_uncharge(smap, owner, smap->elem_size);\n\n\tfree_local_storage = hlist_is_singular_node(&selem->snode,\n\t\t\t\t\t\t    &local_storage->list);\n\tif (free_local_storage) {\n\t\tmem_uncharge(smap, owner, sizeof(struct bpf_local_storage));\n\t\tlocal_storage->owner = NULL;\n\n\t\t/* After this RCU_INIT, owner may be freed and cannot be used */\n\t\tRCU_INIT_POINTER(*owner_storage(smap, owner), NULL);\n\n\t\t/* local_storage is not freed now.  local_storage->lock is\n\t\t * still held and raw_spin_unlock_bh(&local_storage->lock)\n\t\t * will be done by the caller.\n\t\t *\n\t\t * Although the unlock will be done under\n\t\t * rcu_read_lock(),  it is more intutivie to\n\t\t * read if the freeing of the storage is done\n\t\t * after the raw_spin_unlock_bh(&local_storage->lock).\n\t\t *\n\t\t * Hence, a \"bool free_local_storage\" is returned\n\t\t * to the caller which then calls then frees the storage after\n\t\t * all the RCU grace periods have expired.\n\t\t */\n\t}\n\thlist_del_init_rcu(&selem->snode);\n\tif (rcu_access_pointer(local_storage->cache[smap->cache_idx]) ==\n\t    SDATA(selem))\n\t\tRCU_INIT_POINTER(local_storage->cache[smap->cache_idx], NULL);\n\n\tcall_rcu_tasks_trace(&selem->rcu, bpf_selem_free_rcu);\n\treturn free_local_storage;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_selem_unlink_map",
          "args": [
            "selem"
          ],
          "line": 103
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_selem_unlink_map",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_local_storage.c",
          "lines": "187-203",
          "snippet": "void bpf_selem_unlink_map(struct bpf_local_storage_elem *selem)\n{\n\tstruct bpf_local_storage_map *smap;\n\tstruct bpf_local_storage_map_bucket *b;\n\tunsigned long flags;\n\n\tif (unlikely(!selem_linked_to_map(selem)))\n\t\t/* selem has already be unlinked from smap */\n\t\treturn;\n\n\tsmap = rcu_dereference_check(SDATA(selem)->smap, bpf_rcu_lock_held());\n\tb = select_bucket(smap, selem);\n\traw_spin_lock_irqsave(&b->lock, flags);\n\tif (likely(selem_linked_to_map(selem)))\n\t\thlist_del_init_rcu(&selem->map_node);\n\traw_spin_unlock_irqrestore(&b->lock, flags);\n}",
          "includes": [
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/rcupdate.h>",
            "#include <uapi/linux/btf.h>",
            "#include <uapi/linux/sock_diag.h>",
            "#include <net/sock.h>",
            "#include <linux/bpf_local_storage.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/bpf.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/rculist.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcupdate_wait.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/rcupdate.h>\n#include <uapi/linux/btf.h>\n#include <uapi/linux/sock_diag.h>\n#include <net/sock.h>\n#include <linux/bpf_local_storage.h>\n#include <linux/btf_ids.h>\n#include <linux/bpf.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/rculist.h>\n\nvoid bpf_selem_unlink_map(struct bpf_local_storage_elem *selem)\n{\n\tstruct bpf_local_storage_map *smap;\n\tstruct bpf_local_storage_map_bucket *b;\n\tunsigned long flags;\n\n\tif (unlikely(!selem_linked_to_map(selem)))\n\t\t/* selem has already be unlinked from smap */\n\t\treturn;\n\n\tsmap = rcu_dereference_check(SDATA(selem)->smap, bpf_rcu_lock_held());\n\tb = select_bucket(smap, selem);\n\traw_spin_lock_irqsave(&b->lock, flags);\n\tif (likely(selem_linked_to_map(selem)))\n\t\thlist_del_init_rcu(&selem->map_node);\n\traw_spin_unlock_irqrestore(&b->lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_for_each_entry_safe",
          "args": [
            "selem",
            "n",
            "&local_storage->list",
            "snode"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave",
          "args": [
            "&local_storage->lock",
            "flags"
          ],
          "line": 98
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "383-393",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_task_storage_lock",
          "args": [],
          "line": 97
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_task_storage_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_task_storage.c",
          "lines": "26-30",
          "snippet": "static void bpf_task_storage_lock(void)\n{\n\tmigrate_disable();\n\t__this_cpu_inc(bpf_task_storage_busy);\n}",
          "includes": [
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/btf_ids.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf_local_storage.h>",
            "#include <linux/bpf.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/rculist.h>",
            "#include <linux/sched.h>",
            "#include <linux/pid.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(int, bpf_task_storage_busy);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcupdate_trace.h>\n#include <linux/fdtable.h>\n#include <linux/btf_ids.h>\n#include <uapi/linux/btf.h>\n#include <linux/filter.h>\n#include <linux/bpf_local_storage.h>\n#include <linux/bpf.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/rculist.h>\n#include <linux/sched.h>\n#include <linux/pid.h>\n\nstatic DEFINE_PER_CPU(int, bpf_task_storage_busy);\n\nstatic void bpf_task_storage_lock(void)\n{\n\tmigrate_disable();\n\t__this_cpu_inc(bpf_task_storage_busy);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_dereference",
          "args": [
            "task->bpf_storage"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 80
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_any_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "340-351",
          "snippet": "int rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/rcupdate_trace.h>\n#include <linux/fdtable.h>\n#include <linux/btf_ids.h>\n#include <uapi/linux/btf.h>\n#include <linux/filter.h>\n#include <linux/bpf_local_storage.h>\n#include <linux/bpf.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/rculist.h>\n#include <linux/sched.h>\n#include <linux/pid.h>\n\nvoid bpf_task_storage_free(struct task_struct *task)\n{\n\tstruct bpf_local_storage_elem *selem;\n\tstruct bpf_local_storage *local_storage;\n\tbool free_task_storage = false;\n\tstruct hlist_node *n;\n\tunsigned long flags;\n\n\trcu_read_lock();\n\n\tlocal_storage = rcu_dereference(task->bpf_storage);\n\tif (!local_storage) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Neither the bpf_prog nor the bpf-map's syscall\n\t * could be modifying the local_storage->list now.\n\t * Thus, no elem can be added-to or deleted-from the\n\t * local_storage->list by the bpf_prog or by the bpf-map's syscall.\n\t *\n\t * It is racing with bpf_local_storage_map_free() alone\n\t * when unlinking elem from the local_storage->list and\n\t * the map's bucket->list.\n\t */\n\tbpf_task_storage_lock();\n\traw_spin_lock_irqsave(&local_storage->lock, flags);\n\thlist_for_each_entry_safe(selem, n, &local_storage->list, snode) {\n\t\t/* Always unlink from map before unlinking from\n\t\t * local_storage.\n\t\t */\n\t\tbpf_selem_unlink_map(selem);\n\t\tfree_task_storage = bpf_selem_unlink_storage_nolock(\n\t\t\tlocal_storage, selem, false);\n\t}\n\traw_spin_unlock_irqrestore(&local_storage->lock, flags);\n\tbpf_task_storage_unlock();\n\trcu_read_unlock();\n\n\t/* free_task_storage should always be true as long as\n\t * local_storage->list was non-empty.\n\t */\n\tif (free_task_storage)\n\t\tkfree_rcu(local_storage, rcu);\n}"
  },
  {
    "function_name": "task_storage_lookup",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_task_storage.c",
    "lines": "56-70",
    "snippet": "static struct bpf_local_storage_data *\ntask_storage_lookup(struct task_struct *task, struct bpf_map *map,\n\t\t    bool cacheit_lockit)\n{\n\tstruct bpf_local_storage *task_storage;\n\tstruct bpf_local_storage_map *smap;\n\n\ttask_storage =\n\t\trcu_dereference_check(task->bpf_storage, bpf_rcu_lock_held());\n\tif (!task_storage)\n\t\treturn NULL;\n\n\tsmap = (struct bpf_local_storage_map *)map;\n\treturn bpf_local_storage_lookup(task_storage, smap, cacheit_lockit);\n}",
    "includes": [
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/btf_ids.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/filter.h>",
      "#include <linux/bpf_local_storage.h>",
      "#include <linux/bpf.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/types.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/rculist.h>",
      "#include <linux/sched.h>",
      "#include <linux/pid.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bpf_local_storage_lookup",
          "args": [
            "task_storage",
            "smap",
            "cacheit_lockit"
          ],
          "line": 69
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_local_storage_lookup",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_local_storage.c",
          "lines": "227-267",
          "snippet": "struct bpf_local_storage_data *\nbpf_local_storage_lookup(struct bpf_local_storage *local_storage,\n\t\t\t struct bpf_local_storage_map *smap,\n\t\t\t bool cacheit_lockit)\n{\n\tstruct bpf_local_storage_data *sdata;\n\tstruct bpf_local_storage_elem *selem;\n\n\t/* Fast path (cache hit) */\n\tsdata = rcu_dereference_check(local_storage->cache[smap->cache_idx],\n\t\t\t\t      bpf_rcu_lock_held());\n\tif (sdata && rcu_access_pointer(sdata->smap) == smap)\n\t\treturn sdata;\n\n\t/* Slow path (cache miss) */\n\thlist_for_each_entry_rcu(selem, &local_storage->list, snode,\n\t\t\t\t  rcu_read_lock_trace_held())\n\t\tif (rcu_access_pointer(SDATA(selem)->smap) == smap)\n\t\t\tbreak;\n\n\tif (!selem)\n\t\treturn NULL;\n\n\tsdata = SDATA(selem);\n\tif (cacheit_lockit) {\n\t\tunsigned long flags;\n\n\t\t/* spinlock is needed to avoid racing with the\n\t\t * parallel delete.  Otherwise, publishing an already\n\t\t * deleted sdata to the cache will become a use-after-free\n\t\t * problem in the next bpf_local_storage_lookup().\n\t\t */\n\t\traw_spin_lock_irqsave(&local_storage->lock, flags);\n\t\tif (selem_linked_to_storage(selem))\n\t\t\trcu_assign_pointer(local_storage->cache[smap->cache_idx],\n\t\t\t\t\t   sdata);\n\t\traw_spin_unlock_irqrestore(&local_storage->lock, flags);\n\t}\n\n\treturn sdata;\n}",
          "includes": [
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/rcupdate.h>",
            "#include <uapi/linux/btf.h>",
            "#include <uapi/linux/sock_diag.h>",
            "#include <net/sock.h>",
            "#include <linux/bpf_local_storage.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/bpf.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/rculist.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcupdate_wait.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/rcupdate.h>\n#include <uapi/linux/btf.h>\n#include <uapi/linux/sock_diag.h>\n#include <net/sock.h>\n#include <linux/bpf_local_storage.h>\n#include <linux/btf_ids.h>\n#include <linux/bpf.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/rculist.h>\n\nstruct bpf_local_storage_data *\nbpf_local_storage_lookup(struct bpf_local_storage *local_storage,\n\t\t\t struct bpf_local_storage_map *smap,\n\t\t\t bool cacheit_lockit)\n{\n\tstruct bpf_local_storage_data *sdata;\n\tstruct bpf_local_storage_elem *selem;\n\n\t/* Fast path (cache hit) */\n\tsdata = rcu_dereference_check(local_storage->cache[smap->cache_idx],\n\t\t\t\t      bpf_rcu_lock_held());\n\tif (sdata && rcu_access_pointer(sdata->smap) == smap)\n\t\treturn sdata;\n\n\t/* Slow path (cache miss) */\n\thlist_for_each_entry_rcu(selem, &local_storage->list, snode,\n\t\t\t\t  rcu_read_lock_trace_held())\n\t\tif (rcu_access_pointer(SDATA(selem)->smap) == smap)\n\t\t\tbreak;\n\n\tif (!selem)\n\t\treturn NULL;\n\n\tsdata = SDATA(selem);\n\tif (cacheit_lockit) {\n\t\tunsigned long flags;\n\n\t\t/* spinlock is needed to avoid racing with the\n\t\t * parallel delete.  Otherwise, publishing an already\n\t\t * deleted sdata to the cache will become a use-after-free\n\t\t * problem in the next bpf_local_storage_lookup().\n\t\t */\n\t\traw_spin_lock_irqsave(&local_storage->lock, flags);\n\t\tif (selem_linked_to_storage(selem))\n\t\t\trcu_assign_pointer(local_storage->cache[smap->cache_idx],\n\t\t\t\t\t   sdata);\n\t\traw_spin_unlock_irqrestore(&local_storage->lock, flags);\n\t}\n\n\treturn sdata;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_dereference_check",
          "args": [
            "task->bpf_storage",
            "bpf_rcu_lock_held()"
          ],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_rcu_lock_held",
          "args": [],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/rcupdate_trace.h>\n#include <linux/fdtable.h>\n#include <linux/btf_ids.h>\n#include <uapi/linux/btf.h>\n#include <linux/filter.h>\n#include <linux/bpf_local_storage.h>\n#include <linux/bpf.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/rculist.h>\n#include <linux/sched.h>\n#include <linux/pid.h>\n\nstatic struct bpf_local_storage_data *\ntask_storage_lookup(struct task_struct *task, struct bpf_map *map,\n\t\t    bool cacheit_lockit)\n{\n\tstruct bpf_local_storage *task_storage;\n\tstruct bpf_local_storage_map *smap;\n\n\ttask_storage =\n\t\trcu_dereference_check(task->bpf_storage, bpf_rcu_lock_held());\n\tif (!task_storage)\n\t\treturn NULL;\n\n\tsmap = (struct bpf_local_storage_map *)map;\n\treturn bpf_local_storage_lookup(task_storage, smap, cacheit_lockit);\n}"
  },
  {
    "function_name": "task_storage_ptr",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_task_storage.c",
    "lines": "49-54",
    "snippet": "static struct bpf_local_storage __rcu **task_storage_ptr(void *owner)\n{\n\tstruct task_struct *task = owner;\n\n\treturn &task->bpf_storage;\n}",
    "includes": [
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/btf_ids.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/filter.h>",
      "#include <linux/bpf_local_storage.h>",
      "#include <linux/bpf.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/types.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/rculist.h>",
      "#include <linux/sched.h>",
      "#include <linux/pid.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/rcupdate_trace.h>\n#include <linux/fdtable.h>\n#include <linux/btf_ids.h>\n#include <uapi/linux/btf.h>\n#include <linux/filter.h>\n#include <linux/bpf_local_storage.h>\n#include <linux/bpf.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/rculist.h>\n#include <linux/sched.h>\n#include <linux/pid.h>\n\nstatic struct bpf_local_storage __rcu **task_storage_ptr(void *owner)\n{\n\tstruct task_struct *task = owner;\n\n\treturn &task->bpf_storage;\n}"
  },
  {
    "function_name": "bpf_task_storage_trylock",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_task_storage.c",
    "lines": "38-47",
    "snippet": "static bool bpf_task_storage_trylock(void)\n{\n\tmigrate_disable();\n\tif (unlikely(__this_cpu_inc_return(bpf_task_storage_busy) != 1)) {\n\t\t__this_cpu_dec(bpf_task_storage_busy);\n\t\tmigrate_enable();\n\t\treturn false;\n\t}\n\treturn true;\n}",
    "includes": [
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/btf_ids.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/filter.h>",
      "#include <linux/bpf_local_storage.h>",
      "#include <linux/bpf.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/types.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/rculist.h>",
      "#include <linux/sched.h>",
      "#include <linux/pid.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(int, bpf_task_storage_busy);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "migrate_enable",
          "args": [],
          "line": 43
        },
        "resolved": true,
        "details": {
          "function_name": "migrate_enable",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "2178-2206",
          "snippet": "void migrate_enable(void)\n{\n\tstruct task_struct *p = current;\n\n\tif (p->migration_disabled > 1) {\n\t\tp->migration_disabled--;\n\t\treturn;\n\t}\n\n\tif (WARN_ON_ONCE(!p->migration_disabled))\n\t\treturn;\n\n\t/*\n\t * Ensure stop_task runs either before or after this, and that\n\t * __set_cpus_allowed_ptr(SCA_MIGRATE_ENABLE) doesn't schedule().\n\t */\n\tpreempt_disable();\n\tif (p->cpus_ptr != &p->cpus_mask)\n\t\t__set_cpus_allowed_ptr(p, &p->cpus_mask, SCA_MIGRATE_ENABLE);\n\t/*\n\t * Mustn't clear migration_disabled() until cpus_ptr points back at the\n\t * regular cpus_mask, otherwise things that race (eg.\n\t * select_fallback_rq) get confused.\n\t */\n\tbarrier();\n\tp->migration_disabled = 0;\n\tthis_rq()->nr_pinned--;\n\tpreempt_enable();\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\nvoid migrate_enable(void)\n{\n\tstruct task_struct *p = current;\n\n\tif (p->migration_disabled > 1) {\n\t\tp->migration_disabled--;\n\t\treturn;\n\t}\n\n\tif (WARN_ON_ONCE(!p->migration_disabled))\n\t\treturn;\n\n\t/*\n\t * Ensure stop_task runs either before or after this, and that\n\t * __set_cpus_allowed_ptr(SCA_MIGRATE_ENABLE) doesn't schedule().\n\t */\n\tpreempt_disable();\n\tif (p->cpus_ptr != &p->cpus_mask)\n\t\t__set_cpus_allowed_ptr(p, &p->cpus_mask, SCA_MIGRATE_ENABLE);\n\t/*\n\t * Mustn't clear migration_disabled() until cpus_ptr points back at the\n\t * regular cpus_mask, otherwise things that race (eg.\n\t * select_fallback_rq) get confused.\n\t */\n\tbarrier();\n\tp->migration_disabled = 0;\n\tthis_rq()->nr_pinned--;\n\tpreempt_enable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "__this_cpu_dec",
          "args": [
            "bpf_task_storage_busy"
          ],
          "line": 42
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "__this_cpu_inc_return(bpf_task_storage_busy) != 1"
          ],
          "line": 41
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__this_cpu_inc_return",
          "args": [
            "bpf_task_storage_busy"
          ],
          "line": 41
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "migrate_disable",
          "args": [],
          "line": 40
        },
        "resolved": true,
        "details": {
          "function_name": "migrate_disable",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "2162-2175",
          "snippet": "void migrate_disable(void)\n{\n\tstruct task_struct *p = current;\n\n\tif (p->migration_disabled) {\n\t\tp->migration_disabled++;\n\t\treturn;\n\t}\n\n\tpreempt_disable();\n\tthis_rq()->nr_pinned++;\n\tp->migration_disabled = 1;\n\tpreempt_enable();\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\nvoid migrate_disable(void)\n{\n\tstruct task_struct *p = current;\n\n\tif (p->migration_disabled) {\n\t\tp->migration_disabled++;\n\t\treturn;\n\t}\n\n\tpreempt_disable();\n\tthis_rq()->nr_pinned++;\n\tp->migration_disabled = 1;\n\tpreempt_enable();\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/rcupdate_trace.h>\n#include <linux/fdtable.h>\n#include <linux/btf_ids.h>\n#include <uapi/linux/btf.h>\n#include <linux/filter.h>\n#include <linux/bpf_local_storage.h>\n#include <linux/bpf.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/rculist.h>\n#include <linux/sched.h>\n#include <linux/pid.h>\n\nstatic DEFINE_PER_CPU(int, bpf_task_storage_busy);\n\nstatic bool bpf_task_storage_trylock(void)\n{\n\tmigrate_disable();\n\tif (unlikely(__this_cpu_inc_return(bpf_task_storage_busy) != 1)) {\n\t\t__this_cpu_dec(bpf_task_storage_busy);\n\t\tmigrate_enable();\n\t\treturn false;\n\t}\n\treturn true;\n}"
  },
  {
    "function_name": "bpf_task_storage_unlock",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_task_storage.c",
    "lines": "32-36",
    "snippet": "static void bpf_task_storage_unlock(void)\n{\n\t__this_cpu_dec(bpf_task_storage_busy);\n\tmigrate_enable();\n}",
    "includes": [
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/btf_ids.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/filter.h>",
      "#include <linux/bpf_local_storage.h>",
      "#include <linux/bpf.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/types.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/rculist.h>",
      "#include <linux/sched.h>",
      "#include <linux/pid.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(int, bpf_task_storage_busy);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "migrate_enable",
          "args": [],
          "line": 35
        },
        "resolved": true,
        "details": {
          "function_name": "migrate_enable",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "2178-2206",
          "snippet": "void migrate_enable(void)\n{\n\tstruct task_struct *p = current;\n\n\tif (p->migration_disabled > 1) {\n\t\tp->migration_disabled--;\n\t\treturn;\n\t}\n\n\tif (WARN_ON_ONCE(!p->migration_disabled))\n\t\treturn;\n\n\t/*\n\t * Ensure stop_task runs either before or after this, and that\n\t * __set_cpus_allowed_ptr(SCA_MIGRATE_ENABLE) doesn't schedule().\n\t */\n\tpreempt_disable();\n\tif (p->cpus_ptr != &p->cpus_mask)\n\t\t__set_cpus_allowed_ptr(p, &p->cpus_mask, SCA_MIGRATE_ENABLE);\n\t/*\n\t * Mustn't clear migration_disabled() until cpus_ptr points back at the\n\t * regular cpus_mask, otherwise things that race (eg.\n\t * select_fallback_rq) get confused.\n\t */\n\tbarrier();\n\tp->migration_disabled = 0;\n\tthis_rq()->nr_pinned--;\n\tpreempt_enable();\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\nvoid migrate_enable(void)\n{\n\tstruct task_struct *p = current;\n\n\tif (p->migration_disabled > 1) {\n\t\tp->migration_disabled--;\n\t\treturn;\n\t}\n\n\tif (WARN_ON_ONCE(!p->migration_disabled))\n\t\treturn;\n\n\t/*\n\t * Ensure stop_task runs either before or after this, and that\n\t * __set_cpus_allowed_ptr(SCA_MIGRATE_ENABLE) doesn't schedule().\n\t */\n\tpreempt_disable();\n\tif (p->cpus_ptr != &p->cpus_mask)\n\t\t__set_cpus_allowed_ptr(p, &p->cpus_mask, SCA_MIGRATE_ENABLE);\n\t/*\n\t * Mustn't clear migration_disabled() until cpus_ptr points back at the\n\t * regular cpus_mask, otherwise things that race (eg.\n\t * select_fallback_rq) get confused.\n\t */\n\tbarrier();\n\tp->migration_disabled = 0;\n\tthis_rq()->nr_pinned--;\n\tpreempt_enable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "__this_cpu_dec",
          "args": [
            "bpf_task_storage_busy"
          ],
          "line": 34
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/rcupdate_trace.h>\n#include <linux/fdtable.h>\n#include <linux/btf_ids.h>\n#include <uapi/linux/btf.h>\n#include <linux/filter.h>\n#include <linux/bpf_local_storage.h>\n#include <linux/bpf.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/rculist.h>\n#include <linux/sched.h>\n#include <linux/pid.h>\n\nstatic DEFINE_PER_CPU(int, bpf_task_storage_busy);\n\nstatic void bpf_task_storage_unlock(void)\n{\n\t__this_cpu_dec(bpf_task_storage_busy);\n\tmigrate_enable();\n}"
  },
  {
    "function_name": "bpf_task_storage_lock",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_task_storage.c",
    "lines": "26-30",
    "snippet": "static void bpf_task_storage_lock(void)\n{\n\tmigrate_disable();\n\t__this_cpu_inc(bpf_task_storage_busy);\n}",
    "includes": [
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/btf_ids.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/filter.h>",
      "#include <linux/bpf_local_storage.h>",
      "#include <linux/bpf.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/types.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/rculist.h>",
      "#include <linux/sched.h>",
      "#include <linux/pid.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(int, bpf_task_storage_busy);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__this_cpu_inc",
          "args": [
            "bpf_task_storage_busy"
          ],
          "line": 29
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "migrate_disable",
          "args": [],
          "line": 28
        },
        "resolved": true,
        "details": {
          "function_name": "migrate_disable",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "2162-2175",
          "snippet": "void migrate_disable(void)\n{\n\tstruct task_struct *p = current;\n\n\tif (p->migration_disabled) {\n\t\tp->migration_disabled++;\n\t\treturn;\n\t}\n\n\tpreempt_disable();\n\tthis_rq()->nr_pinned++;\n\tp->migration_disabled = 1;\n\tpreempt_enable();\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\nvoid migrate_disable(void)\n{\n\tstruct task_struct *p = current;\n\n\tif (p->migration_disabled) {\n\t\tp->migration_disabled++;\n\t\treturn;\n\t}\n\n\tpreempt_disable();\n\tthis_rq()->nr_pinned++;\n\tp->migration_disabled = 1;\n\tpreempt_enable();\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/rcupdate_trace.h>\n#include <linux/fdtable.h>\n#include <linux/btf_ids.h>\n#include <uapi/linux/btf.h>\n#include <linux/filter.h>\n#include <linux/bpf_local_storage.h>\n#include <linux/bpf.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/rculist.h>\n#include <linux/sched.h>\n#include <linux/pid.h>\n\nstatic DEFINE_PER_CPU(int, bpf_task_storage_busy);\n\nstatic void bpf_task_storage_lock(void)\n{\n\tmigrate_disable();\n\t__this_cpu_inc(bpf_task_storage_busy);\n}"
  }
]