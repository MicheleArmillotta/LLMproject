[
  {
    "function_name": "gcov_fs_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/gcov/fs.c",
    "lines": "864-881",
    "snippet": "static __init int gcov_fs_init(void)\n{\n\tinit_node(&root_node, NULL, NULL, NULL);\n\t/*\n\t * /sys/kernel/debug/gcov will be parent for the reset control file\n\t * and all profiling files.\n\t */\n\troot_node.dentry = debugfs_create_dir(\"gcov\", NULL);\n\t/*\n\t * Create reset file which resets all profiling counts when written\n\t * to.\n\t */\n\tdebugfs_create_file(\"reset\", 0600, root_node.dentry, NULL,\n\t\t\t    &gcov_reset_fops);\n\t/* Replay previous events to get our fs hierarchy up-to-date. */\n\tgcov_enable_events();\n\treturn 0;\n}",
    "includes": [
      "#include \"gcov.h\"",
      "#include <linux/mm.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/string.h>",
      "#include <linux/list.h>",
      "#include <linux/fs.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct gcov_node root_node;",
      "static const struct file_operations gcov_reset_fops = {\n\t.write\t= reset_write,\n\t.read\t= reset_read,\n\t.llseek = noop_llseek,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "gcov_enable_events",
          "args": [],
          "line": 879
        },
        "resolved": true,
        "details": {
          "function_name": "gcov_enable_events",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/gcov/base.c",
          "lines": "36-50",
          "snippet": "void gcov_enable_events(void)\n{\n\tstruct gcov_info *info = NULL;\n\n\tmutex_lock(&gcov_lock);\n\tgcov_events_enabled = 1;\n\n\t/* Perform event callback for previously registered entries. */\n\twhile ((info = gcov_info_next(info))) {\n\t\tgcov_event(GCOV_ADD, info);\n\t\tcond_resched();\n\t}\n\n\tmutex_unlock(&gcov_lock);\n}",
          "includes": [
            "#include \"gcov.h\"",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int gcov_events_enabled;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"gcov.h\"\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nint gcov_events_enabled;\n\nvoid gcov_enable_events(void)\n{\n\tstruct gcov_info *info = NULL;\n\n\tmutex_lock(&gcov_lock);\n\tgcov_events_enabled = 1;\n\n\t/* Perform event callback for previously registered entries. */\n\twhile ((info = gcov_info_next(info))) {\n\t\tgcov_event(GCOV_ADD, info);\n\t\tcond_resched();\n\t}\n\n\tmutex_unlock(&gcov_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "debugfs_create_file",
          "args": [
            "\"reset\"",
            "0600",
            "root_node.dentry",
            "NULL",
            "&gcov_reset_fops"
          ],
          "line": 876
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debugfs_create_dir",
          "args": [
            "\"gcov\"",
            "NULL"
          ],
          "line": 871
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_node",
          "args": [
            "&root_node",
            "NULL",
            "NULL",
            "NULL"
          ],
          "line": 866
        },
        "resolved": true,
        "details": {
          "function_name": "init_node",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/gcov/fs.c",
          "lines": "520-533",
          "snippet": "static void init_node(struct gcov_node *node, struct gcov_info *info,\n\t\t      const char *name, struct gcov_node *parent)\n{\n\tINIT_LIST_HEAD(&node->list);\n\tINIT_LIST_HEAD(&node->children);\n\tINIT_LIST_HEAD(&node->all);\n\tif (node->loaded_info) {\n\t\tnode->loaded_info[0] = info;\n\t\tnode->num_loaded = 1;\n\t}\n\tnode->parent = parent;\n\tif (name)\n\t\tstrcpy(node->name, name);\n}",
          "includes": [
            "#include \"gcov.h\"",
            "#include <linux/mm.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void remove_node(struct gcov_node *node);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"gcov.h\"\n#include <linux/mm.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic void remove_node(struct gcov_node *node);\n\nstatic void init_node(struct gcov_node *node, struct gcov_info *info,\n\t\t      const char *name, struct gcov_node *parent)\n{\n\tINIT_LIST_HEAD(&node->list);\n\tINIT_LIST_HEAD(&node->children);\n\tINIT_LIST_HEAD(&node->all);\n\tif (node->loaded_info) {\n\t\tnode->loaded_info[0] = info;\n\t\tnode->num_loaded = 1;\n\t}\n\tnode->parent = parent;\n\tif (name)\n\t\tstrcpy(node->name, name);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"gcov.h\"\n#include <linux/mm.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic struct gcov_node root_node;\nstatic const struct file_operations gcov_reset_fops = {\n\t.write\t= reset_write,\n\t.read\t= reset_read,\n\t.llseek = noop_llseek,\n};\n\nstatic __init int gcov_fs_init(void)\n{\n\tinit_node(&root_node, NULL, NULL, NULL);\n\t/*\n\t * /sys/kernel/debug/gcov will be parent for the reset control file\n\t * and all profiling files.\n\t */\n\troot_node.dentry = debugfs_create_dir(\"gcov\", NULL);\n\t/*\n\t * Create reset file which resets all profiling counts when written\n\t * to.\n\t */\n\tdebugfs_create_file(\"reset\", 0600, root_node.dentry, NULL,\n\t\t\t    &gcov_reset_fops);\n\t/* Replay previous events to get our fs hierarchy up-to-date. */\n\tgcov_enable_events();\n\treturn 0;\n}"
  },
  {
    "function_name": "gcov_event",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/gcov/fs.c",
    "lines": "838-861",
    "snippet": "void gcov_event(enum gcov_action action, struct gcov_info *info)\n{\n\tstruct gcov_node *node;\n\n\tmutex_lock(&node_lock);\n\tnode = get_node_by_name(gcov_info_filename(info));\n\tswitch (action) {\n\tcase GCOV_ADD:\n\t\tif (node)\n\t\t\tadd_info(node, info);\n\t\telse\n\t\t\tadd_node(info);\n\t\tbreak;\n\tcase GCOV_REMOVE:\n\t\tif (node)\n\t\t\tremove_info(node, info);\n\t\telse {\n\t\t\tpr_warn(\"could not remove '%s' (not found)\\n\",\n\t\t\t\tgcov_info_filename(info));\n\t\t}\n\t\tbreak;\n\t}\n\tmutex_unlock(&node_lock);\n}",
    "includes": [
      "#include \"gcov.h\"",
      "#include <linux/mm.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/string.h>",
      "#include <linux/list.h>",
      "#include <linux/fs.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(node_lock);",
      "static void remove_node(struct gcov_node *node);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&node_lock"
          ],
          "line": 860
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"could not remove '%s' (not found)\\n\"",
            "gcov_info_filename(info)"
          ],
          "line": 855
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gcov_info_filename",
          "args": [
            "info"
          ],
          "line": 856
        },
        "resolved": true,
        "details": {
          "function_name": "gcov_info_filename",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/gcov/gcc_4_7.c",
          "lines": "100-103",
          "snippet": "const char *gcov_info_filename(struct gcov_info *info)\n{\n\treturn info->filename;\n}",
          "includes": [
            "#include \"gcov.h\"",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"gcov.h\"\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n\nconst char *gcov_info_filename(struct gcov_info *info)\n{\n\treturn info->filename;\n}"
        }
      },
      {
        "call_info": {
          "callee": "remove_info",
          "args": [
            "node",
            "info"
          ],
          "line": 853
        },
        "resolved": true,
        "details": {
          "function_name": "remove_info",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/gcov/fs.c",
          "lines": "809-832",
          "snippet": "static void remove_info(struct gcov_node *node, struct gcov_info *info)\n{\n\tint i;\n\n\ti = get_info_index(node, info);\n\tif (i < 0) {\n\t\tpr_warn(\"could not remove '%s' (not found)\\n\",\n\t\t\tgcov_info_filename(info));\n\t\treturn;\n\t}\n\tif (gcov_persist)\n\t\tsave_info(node, info);\n\t/* Shrink array. */\n\tnode->loaded_info[i] = node->loaded_info[node->num_loaded - 1];\n\tnode->num_loaded--;\n\tif (node->num_loaded > 0)\n\t\treturn;\n\t/* Last loaded data set was removed. */\n\tkfree(node->loaded_info);\n\tnode->loaded_info = NULL;\n\tnode->num_loaded = 0;\n\tif (!node->unloaded_info)\n\t\tremove_node(node);\n}",
          "includes": [
            "#include \"gcov.h\"",
            "#include <linux/mm.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int gcov_persist = 1;",
            "static void remove_node(struct gcov_node *node);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"gcov.h\"\n#include <linux/mm.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic int gcov_persist = 1;\nstatic void remove_node(struct gcov_node *node);\n\nstatic void remove_info(struct gcov_node *node, struct gcov_info *info)\n{\n\tint i;\n\n\ti = get_info_index(node, info);\n\tif (i < 0) {\n\t\tpr_warn(\"could not remove '%s' (not found)\\n\",\n\t\t\tgcov_info_filename(info));\n\t\treturn;\n\t}\n\tif (gcov_persist)\n\t\tsave_info(node, info);\n\t/* Shrink array. */\n\tnode->loaded_info[i] = node->loaded_info[node->num_loaded - 1];\n\tnode->num_loaded--;\n\tif (node->num_loaded > 0)\n\t\treturn;\n\t/* Last loaded data set was removed. */\n\tkfree(node->loaded_info);\n\tnode->loaded_info = NULL;\n\tnode->num_loaded = 0;\n\tif (!node->unloaded_info)\n\t\tremove_node(node);\n}"
        }
      },
      {
        "call_info": {
          "callee": "add_node",
          "args": [
            "info"
          ],
          "line": 849
        },
        "resolved": true,
        "details": {
          "function_name": "add_node",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/gcov/fs.c",
          "lines": "674-718",
          "snippet": "static void add_node(struct gcov_info *info)\n{\n\tchar *filename;\n\tchar *curr;\n\tchar *next;\n\tstruct gcov_node *parent;\n\tstruct gcov_node *node;\n\n\tfilename = kstrdup(gcov_info_filename(info), GFP_KERNEL);\n\tif (!filename)\n\t\treturn;\n\tparent = &root_node;\n\t/* Create directory nodes along the path. */\n\tfor (curr = filename; (next = strchr(curr, '/')); curr = next + 1) {\n\t\tif (curr == next)\n\t\t\tcontinue;\n\t\t*next = 0;\n\t\tif (strcmp(curr, \".\") == 0)\n\t\t\tcontinue;\n\t\tif (strcmp(curr, \"..\") == 0) {\n\t\t\tif (!parent->parent)\n\t\t\t\tgoto err_remove;\n\t\t\tparent = parent->parent;\n\t\t\tcontinue;\n\t\t}\n\t\tnode = get_child_by_name(parent, curr);\n\t\tif (!node) {\n\t\t\tnode = new_node(parent, NULL, curr);\n\t\t\tif (!node)\n\t\t\t\tgoto err_remove;\n\t\t}\n\t\tparent = node;\n\t}\n\t/* Create file node. */\n\tnode = new_node(parent, info, curr);\n\tif (!node)\n\t\tgoto err_remove;\nout:\n\tkfree(filename);\n\treturn;\n\nerr_remove:\n\tremove_node(parent);\n\tgoto out;\n}",
          "includes": [
            "#include \"gcov.h\"",
            "#include <linux/mm.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct gcov_node root_node;",
            "static void remove_node(struct gcov_node *node);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"gcov.h\"\n#include <linux/mm.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic struct gcov_node root_node;\nstatic void remove_node(struct gcov_node *node);\n\nstatic void add_node(struct gcov_info *info)\n{\n\tchar *filename;\n\tchar *curr;\n\tchar *next;\n\tstruct gcov_node *parent;\n\tstruct gcov_node *node;\n\n\tfilename = kstrdup(gcov_info_filename(info), GFP_KERNEL);\n\tif (!filename)\n\t\treturn;\n\tparent = &root_node;\n\t/* Create directory nodes along the path. */\n\tfor (curr = filename; (next = strchr(curr, '/')); curr = next + 1) {\n\t\tif (curr == next)\n\t\t\tcontinue;\n\t\t*next = 0;\n\t\tif (strcmp(curr, \".\") == 0)\n\t\t\tcontinue;\n\t\tif (strcmp(curr, \"..\") == 0) {\n\t\t\tif (!parent->parent)\n\t\t\t\tgoto err_remove;\n\t\t\tparent = parent->parent;\n\t\t\tcontinue;\n\t\t}\n\t\tnode = get_child_by_name(parent, curr);\n\t\tif (!node) {\n\t\t\tnode = new_node(parent, NULL, curr);\n\t\t\tif (!node)\n\t\t\t\tgoto err_remove;\n\t\t}\n\t\tparent = node;\n\t}\n\t/* Create file node. */\n\tnode = new_node(parent, info, curr);\n\tif (!node)\n\t\tgoto err_remove;\nout:\n\tkfree(filename);\n\treturn;\n\nerr_remove:\n\tremove_node(parent);\n\tgoto out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "add_info",
          "args": [
            "node",
            "info"
          ],
          "line": 847
        },
        "resolved": true,
        "details": {
          "function_name": "add_info",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/gcov/fs.c",
          "lines": "724-772",
          "snippet": "static void add_info(struct gcov_node *node, struct gcov_info *info)\n{\n\tstruct gcov_info **loaded_info;\n\tint num = node->num_loaded;\n\n\t/*\n\t * Prepare new array. This is done first to simplify cleanup in\n\t * case the new data set is incompatible, the node only contains\n\t * unloaded data sets and there's not enough memory for the array.\n\t */\n\tloaded_info = kcalloc(num + 1, sizeof(struct gcov_info *), GFP_KERNEL);\n\tif (!loaded_info) {\n\t\tpr_warn(\"could not add '%s' (out of memory)\\n\",\n\t\t\tgcov_info_filename(info));\n\t\treturn;\n\t}\n\tmemcpy(loaded_info, node->loaded_info,\n\t       num * sizeof(struct gcov_info *));\n\tloaded_info[num] = info;\n\t/* Check if the new data set is compatible. */\n\tif (num == 0) {\n\t\t/*\n\t\t * A module was unloaded, modified and reloaded. The new\n\t\t * data set replaces the copy of the last one.\n\t\t */\n\t\tif (!gcov_info_is_compatible(node->unloaded_info, info)) {\n\t\t\tpr_warn(\"discarding saved data for %s \"\n\t\t\t\t\"(incompatible version)\\n\",\n\t\t\t\tgcov_info_filename(info));\n\t\t\tgcov_info_free(node->unloaded_info);\n\t\t\tnode->unloaded_info = NULL;\n\t\t}\n\t} else {\n\t\t/*\n\t\t * Two different versions of the same object file are loaded.\n\t\t * The initial one takes precedence.\n\t\t */\n\t\tif (!gcov_info_is_compatible(node->loaded_info[0], info)) {\n\t\t\tpr_warn(\"could not add '%s' (incompatible \"\n\t\t\t\t\"version)\\n\", gcov_info_filename(info));\n\t\t\tkfree(loaded_info);\n\t\t\treturn;\n\t\t}\n\t}\n\t/* Overwrite previous array. */\n\tkfree(node->loaded_info);\n\tnode->loaded_info = loaded_info;\n\tnode->num_loaded = num + 1;\n}",
          "includes": [
            "#include \"gcov.h\"",
            "#include <linux/mm.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void remove_node(struct gcov_node *node);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"gcov.h\"\n#include <linux/mm.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic void remove_node(struct gcov_node *node);\n\nstatic void add_info(struct gcov_node *node, struct gcov_info *info)\n{\n\tstruct gcov_info **loaded_info;\n\tint num = node->num_loaded;\n\n\t/*\n\t * Prepare new array. This is done first to simplify cleanup in\n\t * case the new data set is incompatible, the node only contains\n\t * unloaded data sets and there's not enough memory for the array.\n\t */\n\tloaded_info = kcalloc(num + 1, sizeof(struct gcov_info *), GFP_KERNEL);\n\tif (!loaded_info) {\n\t\tpr_warn(\"could not add '%s' (out of memory)\\n\",\n\t\t\tgcov_info_filename(info));\n\t\treturn;\n\t}\n\tmemcpy(loaded_info, node->loaded_info,\n\t       num * sizeof(struct gcov_info *));\n\tloaded_info[num] = info;\n\t/* Check if the new data set is compatible. */\n\tif (num == 0) {\n\t\t/*\n\t\t * A module was unloaded, modified and reloaded. The new\n\t\t * data set replaces the copy of the last one.\n\t\t */\n\t\tif (!gcov_info_is_compatible(node->unloaded_info, info)) {\n\t\t\tpr_warn(\"discarding saved data for %s \"\n\t\t\t\t\"(incompatible version)\\n\",\n\t\t\t\tgcov_info_filename(info));\n\t\t\tgcov_info_free(node->unloaded_info);\n\t\t\tnode->unloaded_info = NULL;\n\t\t}\n\t} else {\n\t\t/*\n\t\t * Two different versions of the same object file are loaded.\n\t\t * The initial one takes precedence.\n\t\t */\n\t\tif (!gcov_info_is_compatible(node->loaded_info[0], info)) {\n\t\t\tpr_warn(\"could not add '%s' (incompatible \"\n\t\t\t\t\"version)\\n\", gcov_info_filename(info));\n\t\t\tkfree(loaded_info);\n\t\t\treturn;\n\t\t}\n\t}\n\t/* Overwrite previous array. */\n\tkfree(node->loaded_info);\n\tnode->loaded_info = loaded_info;\n\tnode->num_loaded = num + 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_node_by_name",
          "args": [
            "gcov_info_filename(info)"
          ],
          "line": 843
        },
        "resolved": true,
        "details": {
          "function_name": "get_node_by_name",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/gcov/fs.c",
          "lines": "348-360",
          "snippet": "static struct gcov_node *get_node_by_name(const char *name)\n{\n\tstruct gcov_node *node;\n\tstruct gcov_info *info;\n\n\tlist_for_each_entry(node, &all_head, all) {\n\t\tinfo = get_node_info(node);\n\t\tif (info && (strcmp(gcov_info_filename(info), name) == 0))\n\t\t\treturn node;\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"gcov.h\"",
            "#include <linux/mm.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(all_head);",
            "static void remove_node(struct gcov_node *node);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"gcov.h\"\n#include <linux/mm.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic LIST_HEAD(all_head);\nstatic void remove_node(struct gcov_node *node);\n\nstatic struct gcov_node *get_node_by_name(const char *name)\n{\n\tstruct gcov_node *node;\n\tstruct gcov_info *info;\n\n\tlist_for_each_entry(node, &all_head, all) {\n\t\tinfo = get_node_info(node);\n\t\tif (info && (strcmp(gcov_info_filename(info), name) == 0))\n\t\t\treturn node;\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&node_lock"
          ],
          "line": 842
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"gcov.h\"\n#include <linux/mm.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic DEFINE_MUTEX(node_lock);\nstatic void remove_node(struct gcov_node *node);\n\nvoid gcov_event(enum gcov_action action, struct gcov_info *info)\n{\n\tstruct gcov_node *node;\n\n\tmutex_lock(&node_lock);\n\tnode = get_node_by_name(gcov_info_filename(info));\n\tswitch (action) {\n\tcase GCOV_ADD:\n\t\tif (node)\n\t\t\tadd_info(node, info);\n\t\telse\n\t\t\tadd_node(info);\n\t\tbreak;\n\tcase GCOV_REMOVE:\n\t\tif (node)\n\t\t\tremove_info(node, info);\n\t\telse {\n\t\t\tpr_warn(\"could not remove '%s' (not found)\\n\",\n\t\t\t\tgcov_info_filename(info));\n\t\t}\n\t\tbreak;\n\t}\n\tmutex_unlock(&node_lock);\n}"
  },
  {
    "function_name": "remove_info",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/gcov/fs.c",
    "lines": "809-832",
    "snippet": "static void remove_info(struct gcov_node *node, struct gcov_info *info)\n{\n\tint i;\n\n\ti = get_info_index(node, info);\n\tif (i < 0) {\n\t\tpr_warn(\"could not remove '%s' (not found)\\n\",\n\t\t\tgcov_info_filename(info));\n\t\treturn;\n\t}\n\tif (gcov_persist)\n\t\tsave_info(node, info);\n\t/* Shrink array. */\n\tnode->loaded_info[i] = node->loaded_info[node->num_loaded - 1];\n\tnode->num_loaded--;\n\tif (node->num_loaded > 0)\n\t\treturn;\n\t/* Last loaded data set was removed. */\n\tkfree(node->loaded_info);\n\tnode->loaded_info = NULL;\n\tnode->num_loaded = 0;\n\tif (!node->unloaded_info)\n\t\tremove_node(node);\n}",
    "includes": [
      "#include \"gcov.h\"",
      "#include <linux/mm.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/string.h>",
      "#include <linux/list.h>",
      "#include <linux/fs.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int gcov_persist = 1;",
      "static void remove_node(struct gcov_node *node);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "remove_node",
          "args": [
            "node"
          ],
          "line": 831
        },
        "resolved": true,
        "details": {
          "function_name": "remove_node",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/gcov/fs.c",
          "lines": "603-612",
          "snippet": "static void remove_node(struct gcov_node *node)\n{\n\tstruct gcov_node *parent;\n\n\twhile ((node != &root_node) && list_empty(&node->children)) {\n\t\tparent = node->parent;\n\t\trelease_node(node);\n\t\tnode = parent;\n\t}\n}",
          "includes": [
            "#include \"gcov.h\"",
            "#include <linux/mm.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct gcov_node root_node;",
            "static void remove_node(struct gcov_node *node);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"gcov.h\"\n#include <linux/mm.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic struct gcov_node root_node;\nstatic void remove_node(struct gcov_node *node);\n\nstatic void remove_node(struct gcov_node *node)\n{\n\tstruct gcov_node *parent;\n\n\twhile ((node != &root_node) && list_empty(&node->children)) {\n\t\tparent = node->parent;\n\t\trelease_node(node);\n\t\tnode = parent;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "node->loaded_info"
          ],
          "line": 827
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "save_info",
          "args": [
            "node",
            "info"
          ],
          "line": 820
        },
        "resolved": true,
        "details": {
          "function_name": "save_info",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/gcov/fs.c",
          "lines": "791-803",
          "snippet": "static void save_info(struct gcov_node *node, struct gcov_info *info)\n{\n\tif (node->unloaded_info)\n\t\tgcov_info_add(node->unloaded_info, info);\n\telse {\n\t\tnode->unloaded_info = gcov_info_dup(info);\n\t\tif (!node->unloaded_info) {\n\t\t\tpr_warn(\"could not save data for '%s' \"\n\t\t\t\t\"(out of memory)\\n\",\n\t\t\t\tgcov_info_filename(info));\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"gcov.h\"",
            "#include <linux/mm.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void remove_node(struct gcov_node *node);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"gcov.h\"\n#include <linux/mm.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic void remove_node(struct gcov_node *node);\n\nstatic void save_info(struct gcov_node *node, struct gcov_info *info)\n{\n\tif (node->unloaded_info)\n\t\tgcov_info_add(node->unloaded_info, info);\n\telse {\n\t\tnode->unloaded_info = gcov_info_dup(info);\n\t\tif (!node->unloaded_info) {\n\t\t\tpr_warn(\"could not save data for '%s' \"\n\t\t\t\t\"(out of memory)\\n\",\n\t\t\t\tgcov_info_filename(info));\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"could not remove '%s' (not found)\\n\"",
            "gcov_info_filename(info)"
          ],
          "line": 815
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gcov_info_filename",
          "args": [
            "info"
          ],
          "line": 816
        },
        "resolved": true,
        "details": {
          "function_name": "gcov_info_filename",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/gcov/gcc_4_7.c",
          "lines": "100-103",
          "snippet": "const char *gcov_info_filename(struct gcov_info *info)\n{\n\treturn info->filename;\n}",
          "includes": [
            "#include \"gcov.h\"",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"gcov.h\"\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n\nconst char *gcov_info_filename(struct gcov_info *info)\n{\n\treturn info->filename;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_info_index",
          "args": [
            "node",
            "info"
          ],
          "line": 813
        },
        "resolved": true,
        "details": {
          "function_name": "get_info_index",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/gcov/fs.c",
          "lines": "777-786",
          "snippet": "static int get_info_index(struct gcov_node *node, struct gcov_info *info)\n{\n\tint i;\n\n\tfor (i = 0; i < node->num_loaded; i++) {\n\t\tif (node->loaded_info[i] == info)\n\t\t\treturn i;\n\t}\n\treturn -ENOENT;\n}",
          "includes": [
            "#include \"gcov.h\"",
            "#include <linux/mm.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void remove_node(struct gcov_node *node);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"gcov.h\"\n#include <linux/mm.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic void remove_node(struct gcov_node *node);\n\nstatic int get_info_index(struct gcov_node *node, struct gcov_info *info)\n{\n\tint i;\n\n\tfor (i = 0; i < node->num_loaded; i++) {\n\t\tif (node->loaded_info[i] == info)\n\t\t\treturn i;\n\t}\n\treturn -ENOENT;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"gcov.h\"\n#include <linux/mm.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic int gcov_persist = 1;\nstatic void remove_node(struct gcov_node *node);\n\nstatic void remove_info(struct gcov_node *node, struct gcov_info *info)\n{\n\tint i;\n\n\ti = get_info_index(node, info);\n\tif (i < 0) {\n\t\tpr_warn(\"could not remove '%s' (not found)\\n\",\n\t\t\tgcov_info_filename(info));\n\t\treturn;\n\t}\n\tif (gcov_persist)\n\t\tsave_info(node, info);\n\t/* Shrink array. */\n\tnode->loaded_info[i] = node->loaded_info[node->num_loaded - 1];\n\tnode->num_loaded--;\n\tif (node->num_loaded > 0)\n\t\treturn;\n\t/* Last loaded data set was removed. */\n\tkfree(node->loaded_info);\n\tnode->loaded_info = NULL;\n\tnode->num_loaded = 0;\n\tif (!node->unloaded_info)\n\t\tremove_node(node);\n}"
  },
  {
    "function_name": "save_info",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/gcov/fs.c",
    "lines": "791-803",
    "snippet": "static void save_info(struct gcov_node *node, struct gcov_info *info)\n{\n\tif (node->unloaded_info)\n\t\tgcov_info_add(node->unloaded_info, info);\n\telse {\n\t\tnode->unloaded_info = gcov_info_dup(info);\n\t\tif (!node->unloaded_info) {\n\t\t\tpr_warn(\"could not save data for '%s' \"\n\t\t\t\t\"(out of memory)\\n\",\n\t\t\t\tgcov_info_filename(info));\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"gcov.h\"",
      "#include <linux/mm.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/string.h>",
      "#include <linux/list.h>",
      "#include <linux/fs.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void remove_node(struct gcov_node *node);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"could not save data for '%s' \"\n\t\t\t\t\"(out of memory)\\n\"",
            "gcov_info_filename(info)"
          ],
          "line": 798
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gcov_info_filename",
          "args": [
            "info"
          ],
          "line": 800
        },
        "resolved": true,
        "details": {
          "function_name": "gcov_info_filename",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/gcov/gcc_4_7.c",
          "lines": "100-103",
          "snippet": "const char *gcov_info_filename(struct gcov_info *info)\n{\n\treturn info->filename;\n}",
          "includes": [
            "#include \"gcov.h\"",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"gcov.h\"\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n\nconst char *gcov_info_filename(struct gcov_info *info)\n{\n\treturn info->filename;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gcov_info_dup",
          "args": [
            "info"
          ],
          "line": 796
        },
        "resolved": true,
        "details": {
          "function_name": "gcov_info_dup",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/gcov/gcc_4_7.c",
          "lines": "266-329",
          "snippet": "struct gcov_info *gcov_info_dup(struct gcov_info *info)\n{\n\tstruct gcov_info *dup;\n\tstruct gcov_ctr_info *dci_ptr; /* dst counter info */\n\tstruct gcov_ctr_info *sci_ptr; /* src counter info */\n\tunsigned int active;\n\tunsigned int fi_idx; /* function info idx */\n\tunsigned int ct_idx; /* counter type idx */\n\tsize_t fi_size; /* function info size */\n\tsize_t cv_size; /* counter values size */\n\n\tdup = kmemdup(info, sizeof(*dup), GFP_KERNEL);\n\tif (!dup)\n\t\treturn NULL;\n\n\tdup->next = NULL;\n\tdup->filename = NULL;\n\tdup->functions = NULL;\n\n\tdup->filename = kstrdup(info->filename, GFP_KERNEL);\n\tif (!dup->filename)\n\t\tgoto err_free;\n\n\tdup->functions = kcalloc(info->n_functions,\n\t\t\t\t sizeof(struct gcov_fn_info *), GFP_KERNEL);\n\tif (!dup->functions)\n\t\tgoto err_free;\n\n\tactive = num_counter_active(info);\n\tfi_size = sizeof(struct gcov_fn_info);\n\tfi_size += sizeof(struct gcov_ctr_info) * active;\n\n\tfor (fi_idx = 0; fi_idx < info->n_functions; fi_idx++) {\n\t\tdup->functions[fi_idx] = kzalloc(fi_size, GFP_KERNEL);\n\t\tif (!dup->functions[fi_idx])\n\t\t\tgoto err_free;\n\n\t\t*(dup->functions[fi_idx]) = *(info->functions[fi_idx]);\n\n\t\tsci_ptr = info->functions[fi_idx]->ctrs;\n\t\tdci_ptr = dup->functions[fi_idx]->ctrs;\n\n\t\tfor (ct_idx = 0; ct_idx < active; ct_idx++) {\n\n\t\t\tcv_size = sizeof(gcov_type) * sci_ptr->num;\n\n\t\t\tdci_ptr->values = kvmalloc(cv_size, GFP_KERNEL);\n\n\t\t\tif (!dci_ptr->values)\n\t\t\t\tgoto err_free;\n\n\t\t\tdci_ptr->num = sci_ptr->num;\n\t\t\tmemcpy(dci_ptr->values, sci_ptr->values, cv_size);\n\n\t\t\tsci_ptr++;\n\t\t\tdci_ptr++;\n\t\t}\n\t}\n\n\treturn dup;\nerr_free:\n\tgcov_info_free(dup);\n\treturn NULL;\n}",
          "includes": [
            "#include \"gcov.h\"",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"gcov.h\"\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n\nstruct gcov_info *gcov_info_dup(struct gcov_info *info)\n{\n\tstruct gcov_info *dup;\n\tstruct gcov_ctr_info *dci_ptr; /* dst counter info */\n\tstruct gcov_ctr_info *sci_ptr; /* src counter info */\n\tunsigned int active;\n\tunsigned int fi_idx; /* function info idx */\n\tunsigned int ct_idx; /* counter type idx */\n\tsize_t fi_size; /* function info size */\n\tsize_t cv_size; /* counter values size */\n\n\tdup = kmemdup(info, sizeof(*dup), GFP_KERNEL);\n\tif (!dup)\n\t\treturn NULL;\n\n\tdup->next = NULL;\n\tdup->filename = NULL;\n\tdup->functions = NULL;\n\n\tdup->filename = kstrdup(info->filename, GFP_KERNEL);\n\tif (!dup->filename)\n\t\tgoto err_free;\n\n\tdup->functions = kcalloc(info->n_functions,\n\t\t\t\t sizeof(struct gcov_fn_info *), GFP_KERNEL);\n\tif (!dup->functions)\n\t\tgoto err_free;\n\n\tactive = num_counter_active(info);\n\tfi_size = sizeof(struct gcov_fn_info);\n\tfi_size += sizeof(struct gcov_ctr_info) * active;\n\n\tfor (fi_idx = 0; fi_idx < info->n_functions; fi_idx++) {\n\t\tdup->functions[fi_idx] = kzalloc(fi_size, GFP_KERNEL);\n\t\tif (!dup->functions[fi_idx])\n\t\t\tgoto err_free;\n\n\t\t*(dup->functions[fi_idx]) = *(info->functions[fi_idx]);\n\n\t\tsci_ptr = info->functions[fi_idx]->ctrs;\n\t\tdci_ptr = dup->functions[fi_idx]->ctrs;\n\n\t\tfor (ct_idx = 0; ct_idx < active; ct_idx++) {\n\n\t\t\tcv_size = sizeof(gcov_type) * sci_ptr->num;\n\n\t\t\tdci_ptr->values = kvmalloc(cv_size, GFP_KERNEL);\n\n\t\t\tif (!dci_ptr->values)\n\t\t\t\tgoto err_free;\n\n\t\t\tdci_ptr->num = sci_ptr->num;\n\t\t\tmemcpy(dci_ptr->values, sci_ptr->values, cv_size);\n\n\t\t\tsci_ptr++;\n\t\t\tdci_ptr++;\n\t\t}\n\t}\n\n\treturn dup;\nerr_free:\n\tgcov_info_free(dup);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gcov_info_add",
          "args": [
            "node->unloaded_info",
            "info"
          ],
          "line": 794
        },
        "resolved": true,
        "details": {
          "function_name": "gcov_info_add",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/gcov/gcc_4_7.c",
          "lines": "234-258",
          "snippet": "void gcov_info_add(struct gcov_info *dst, struct gcov_info *src)\n{\n\tstruct gcov_ctr_info *dci_ptr;\n\tstruct gcov_ctr_info *sci_ptr;\n\tunsigned int fi_idx;\n\tunsigned int ct_idx;\n\tunsigned int val_idx;\n\n\tfor (fi_idx = 0; fi_idx < src->n_functions; fi_idx++) {\n\t\tdci_ptr = dst->functions[fi_idx]->ctrs;\n\t\tsci_ptr = src->functions[fi_idx]->ctrs;\n\n\t\tfor (ct_idx = 0; ct_idx < GCOV_COUNTERS; ct_idx++) {\n\t\t\tif (!counter_active(src, ct_idx))\n\t\t\t\tcontinue;\n\n\t\t\tfor (val_idx = 0; val_idx < sci_ptr->num; val_idx++)\n\t\t\t\tdci_ptr->values[val_idx] +=\n\t\t\t\t\tsci_ptr->values[val_idx];\n\n\t\t\tdci_ptr++;\n\t\t\tsci_ptr++;\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"gcov.h\"",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [
            "#define GCOV_COUNTERS\t\t\t9",
            "#define GCOV_COUNTERS\t\t\t10",
            "#define GCOV_COUNTERS\t\t\t9",
            "#define GCOV_COUNTERS\t\t\t8"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"gcov.h\"\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n\n#define GCOV_COUNTERS\t\t\t9\n#define GCOV_COUNTERS\t\t\t10\n#define GCOV_COUNTERS\t\t\t9\n#define GCOV_COUNTERS\t\t\t8\n\nvoid gcov_info_add(struct gcov_info *dst, struct gcov_info *src)\n{\n\tstruct gcov_ctr_info *dci_ptr;\n\tstruct gcov_ctr_info *sci_ptr;\n\tunsigned int fi_idx;\n\tunsigned int ct_idx;\n\tunsigned int val_idx;\n\n\tfor (fi_idx = 0; fi_idx < src->n_functions; fi_idx++) {\n\t\tdci_ptr = dst->functions[fi_idx]->ctrs;\n\t\tsci_ptr = src->functions[fi_idx]->ctrs;\n\n\t\tfor (ct_idx = 0; ct_idx < GCOV_COUNTERS; ct_idx++) {\n\t\t\tif (!counter_active(src, ct_idx))\n\t\t\t\tcontinue;\n\n\t\t\tfor (val_idx = 0; val_idx < sci_ptr->num; val_idx++)\n\t\t\t\tdci_ptr->values[val_idx] +=\n\t\t\t\t\tsci_ptr->values[val_idx];\n\n\t\t\tdci_ptr++;\n\t\t\tsci_ptr++;\n\t\t}\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"gcov.h\"\n#include <linux/mm.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic void remove_node(struct gcov_node *node);\n\nstatic void save_info(struct gcov_node *node, struct gcov_info *info)\n{\n\tif (node->unloaded_info)\n\t\tgcov_info_add(node->unloaded_info, info);\n\telse {\n\t\tnode->unloaded_info = gcov_info_dup(info);\n\t\tif (!node->unloaded_info) {\n\t\t\tpr_warn(\"could not save data for '%s' \"\n\t\t\t\t\"(out of memory)\\n\",\n\t\t\t\tgcov_info_filename(info));\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "get_info_index",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/gcov/fs.c",
    "lines": "777-786",
    "snippet": "static int get_info_index(struct gcov_node *node, struct gcov_info *info)\n{\n\tint i;\n\n\tfor (i = 0; i < node->num_loaded; i++) {\n\t\tif (node->loaded_info[i] == info)\n\t\t\treturn i;\n\t}\n\treturn -ENOENT;\n}",
    "includes": [
      "#include \"gcov.h\"",
      "#include <linux/mm.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/string.h>",
      "#include <linux/list.h>",
      "#include <linux/fs.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void remove_node(struct gcov_node *node);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"gcov.h\"\n#include <linux/mm.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic void remove_node(struct gcov_node *node);\n\nstatic int get_info_index(struct gcov_node *node, struct gcov_info *info)\n{\n\tint i;\n\n\tfor (i = 0; i < node->num_loaded; i++) {\n\t\tif (node->loaded_info[i] == info)\n\t\t\treturn i;\n\t}\n\treturn -ENOENT;\n}"
  },
  {
    "function_name": "add_info",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/gcov/fs.c",
    "lines": "724-772",
    "snippet": "static void add_info(struct gcov_node *node, struct gcov_info *info)\n{\n\tstruct gcov_info **loaded_info;\n\tint num = node->num_loaded;\n\n\t/*\n\t * Prepare new array. This is done first to simplify cleanup in\n\t * case the new data set is incompatible, the node only contains\n\t * unloaded data sets and there's not enough memory for the array.\n\t */\n\tloaded_info = kcalloc(num + 1, sizeof(struct gcov_info *), GFP_KERNEL);\n\tif (!loaded_info) {\n\t\tpr_warn(\"could not add '%s' (out of memory)\\n\",\n\t\t\tgcov_info_filename(info));\n\t\treturn;\n\t}\n\tmemcpy(loaded_info, node->loaded_info,\n\t       num * sizeof(struct gcov_info *));\n\tloaded_info[num] = info;\n\t/* Check if the new data set is compatible. */\n\tif (num == 0) {\n\t\t/*\n\t\t * A module was unloaded, modified and reloaded. The new\n\t\t * data set replaces the copy of the last one.\n\t\t */\n\t\tif (!gcov_info_is_compatible(node->unloaded_info, info)) {\n\t\t\tpr_warn(\"discarding saved data for %s \"\n\t\t\t\t\"(incompatible version)\\n\",\n\t\t\t\tgcov_info_filename(info));\n\t\t\tgcov_info_free(node->unloaded_info);\n\t\t\tnode->unloaded_info = NULL;\n\t\t}\n\t} else {\n\t\t/*\n\t\t * Two different versions of the same object file are loaded.\n\t\t * The initial one takes precedence.\n\t\t */\n\t\tif (!gcov_info_is_compatible(node->loaded_info[0], info)) {\n\t\t\tpr_warn(\"could not add '%s' (incompatible \"\n\t\t\t\t\"version)\\n\", gcov_info_filename(info));\n\t\t\tkfree(loaded_info);\n\t\t\treturn;\n\t\t}\n\t}\n\t/* Overwrite previous array. */\n\tkfree(node->loaded_info);\n\tnode->loaded_info = loaded_info;\n\tnode->num_loaded = num + 1;\n}",
    "includes": [
      "#include \"gcov.h\"",
      "#include <linux/mm.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/string.h>",
      "#include <linux/list.h>",
      "#include <linux/fs.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void remove_node(struct gcov_node *node);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "node->loaded_info"
          ],
          "line": 769
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"could not add '%s' (incompatible \"\n\t\t\t\t\"version)\\n\"",
            "gcov_info_filename(info)"
          ],
          "line": 762
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gcov_info_filename",
          "args": [
            "info"
          ],
          "line": 763
        },
        "resolved": true,
        "details": {
          "function_name": "gcov_info_filename",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/gcov/gcc_4_7.c",
          "lines": "100-103",
          "snippet": "const char *gcov_info_filename(struct gcov_info *info)\n{\n\treturn info->filename;\n}",
          "includes": [
            "#include \"gcov.h\"",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"gcov.h\"\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n\nconst char *gcov_info_filename(struct gcov_info *info)\n{\n\treturn info->filename;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gcov_info_is_compatible",
          "args": [
            "node->loaded_info[0]",
            "info"
          ],
          "line": 761
        },
        "resolved": true,
        "details": {
          "function_name": "gcov_info_is_compatible",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/gcov/gcc_4_7.c",
          "lines": "222-225",
          "snippet": "int gcov_info_is_compatible(struct gcov_info *info1, struct gcov_info *info2)\n{\n\treturn (info1->stamp == info2->stamp);\n}",
          "includes": [
            "#include \"gcov.h\"",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"gcov.h\"\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n\nint gcov_info_is_compatible(struct gcov_info *info1, struct gcov_info *info2)\n{\n\treturn (info1->stamp == info2->stamp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gcov_info_free",
          "args": [
            "node->unloaded_info"
          ],
          "line": 753
        },
        "resolved": true,
        "details": {
          "function_name": "gcov_info_free",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/gcov/gcc_4_7.c",
          "lines": "335-363",
          "snippet": "void gcov_info_free(struct gcov_info *info)\n{\n\tunsigned int active;\n\tunsigned int fi_idx;\n\tunsigned int ct_idx;\n\tstruct gcov_ctr_info *ci_ptr;\n\n\tif (!info->functions)\n\t\tgoto free_info;\n\n\tactive = num_counter_active(info);\n\n\tfor (fi_idx = 0; fi_idx < info->n_functions; fi_idx++) {\n\t\tif (!info->functions[fi_idx])\n\t\t\tcontinue;\n\n\t\tci_ptr = info->functions[fi_idx]->ctrs;\n\n\t\tfor (ct_idx = 0; ct_idx < active; ct_idx++, ci_ptr++)\n\t\t\tkvfree(ci_ptr->values);\n\n\t\tkfree(info->functions[fi_idx]);\n\t}\n\nfree_info:\n\tkfree(info->functions);\n\tkfree(info->filename);\n\tkfree(info);\n}",
          "includes": [
            "#include \"gcov.h\"",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"gcov.h\"\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n\nvoid gcov_info_free(struct gcov_info *info)\n{\n\tunsigned int active;\n\tunsigned int fi_idx;\n\tunsigned int ct_idx;\n\tstruct gcov_ctr_info *ci_ptr;\n\n\tif (!info->functions)\n\t\tgoto free_info;\n\n\tactive = num_counter_active(info);\n\n\tfor (fi_idx = 0; fi_idx < info->n_functions; fi_idx++) {\n\t\tif (!info->functions[fi_idx])\n\t\t\tcontinue;\n\n\t\tci_ptr = info->functions[fi_idx]->ctrs;\n\n\t\tfor (ct_idx = 0; ct_idx < active; ct_idx++, ci_ptr++)\n\t\t\tkvfree(ci_ptr->values);\n\n\t\tkfree(info->functions[fi_idx]);\n\t}\n\nfree_info:\n\tkfree(info->functions);\n\tkfree(info->filename);\n\tkfree(info);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"discarding saved data for %s \"\n\t\t\t\t\"(incompatible version)\\n\"",
            "gcov_info_filename(info)"
          ],
          "line": 750
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "loaded_info",
            "node->loaded_info",
            "num * sizeof(struct gcov_info *)"
          ],
          "line": 740
        },
        "resolved": true,
        "details": {
          "function_name": "memcpy_skip",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/internal.h",
          "lines": "180-184",
          "snippet": "static inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/refcount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/refcount.h>\n#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n\nstatic inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"could not add '%s' (out of memory)\\n\"",
            "gcov_info_filename(info)"
          ],
          "line": 736
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kcalloc",
          "args": [
            "num + 1",
            "sizeof(struct gcov_info *)",
            "GFP_KERNEL"
          ],
          "line": 734
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"gcov.h\"\n#include <linux/mm.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic void remove_node(struct gcov_node *node);\n\nstatic void add_info(struct gcov_node *node, struct gcov_info *info)\n{\n\tstruct gcov_info **loaded_info;\n\tint num = node->num_loaded;\n\n\t/*\n\t * Prepare new array. This is done first to simplify cleanup in\n\t * case the new data set is incompatible, the node only contains\n\t * unloaded data sets and there's not enough memory for the array.\n\t */\n\tloaded_info = kcalloc(num + 1, sizeof(struct gcov_info *), GFP_KERNEL);\n\tif (!loaded_info) {\n\t\tpr_warn(\"could not add '%s' (out of memory)\\n\",\n\t\t\tgcov_info_filename(info));\n\t\treturn;\n\t}\n\tmemcpy(loaded_info, node->loaded_info,\n\t       num * sizeof(struct gcov_info *));\n\tloaded_info[num] = info;\n\t/* Check if the new data set is compatible. */\n\tif (num == 0) {\n\t\t/*\n\t\t * A module was unloaded, modified and reloaded. The new\n\t\t * data set replaces the copy of the last one.\n\t\t */\n\t\tif (!gcov_info_is_compatible(node->unloaded_info, info)) {\n\t\t\tpr_warn(\"discarding saved data for %s \"\n\t\t\t\t\"(incompatible version)\\n\",\n\t\t\t\tgcov_info_filename(info));\n\t\t\tgcov_info_free(node->unloaded_info);\n\t\t\tnode->unloaded_info = NULL;\n\t\t}\n\t} else {\n\t\t/*\n\t\t * Two different versions of the same object file are loaded.\n\t\t * The initial one takes precedence.\n\t\t */\n\t\tif (!gcov_info_is_compatible(node->loaded_info[0], info)) {\n\t\t\tpr_warn(\"could not add '%s' (incompatible \"\n\t\t\t\t\"version)\\n\", gcov_info_filename(info));\n\t\t\tkfree(loaded_info);\n\t\t\treturn;\n\t\t}\n\t}\n\t/* Overwrite previous array. */\n\tkfree(node->loaded_info);\n\tnode->loaded_info = loaded_info;\n\tnode->num_loaded = num + 1;\n}"
  },
  {
    "function_name": "add_node",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/gcov/fs.c",
    "lines": "674-718",
    "snippet": "static void add_node(struct gcov_info *info)\n{\n\tchar *filename;\n\tchar *curr;\n\tchar *next;\n\tstruct gcov_node *parent;\n\tstruct gcov_node *node;\n\n\tfilename = kstrdup(gcov_info_filename(info), GFP_KERNEL);\n\tif (!filename)\n\t\treturn;\n\tparent = &root_node;\n\t/* Create directory nodes along the path. */\n\tfor (curr = filename; (next = strchr(curr, '/')); curr = next + 1) {\n\t\tif (curr == next)\n\t\t\tcontinue;\n\t\t*next = 0;\n\t\tif (strcmp(curr, \".\") == 0)\n\t\t\tcontinue;\n\t\tif (strcmp(curr, \"..\") == 0) {\n\t\t\tif (!parent->parent)\n\t\t\t\tgoto err_remove;\n\t\t\tparent = parent->parent;\n\t\t\tcontinue;\n\t\t}\n\t\tnode = get_child_by_name(parent, curr);\n\t\tif (!node) {\n\t\t\tnode = new_node(parent, NULL, curr);\n\t\t\tif (!node)\n\t\t\t\tgoto err_remove;\n\t\t}\n\t\tparent = node;\n\t}\n\t/* Create file node. */\n\tnode = new_node(parent, info, curr);\n\tif (!node)\n\t\tgoto err_remove;\nout:\n\tkfree(filename);\n\treturn;\n\nerr_remove:\n\tremove_node(parent);\n\tgoto out;\n}",
    "includes": [
      "#include \"gcov.h\"",
      "#include <linux/mm.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/string.h>",
      "#include <linux/list.h>",
      "#include <linux/fs.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct gcov_node root_node;",
      "static void remove_node(struct gcov_node *node);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "remove_node",
          "args": [
            "parent"
          ],
          "line": 716
        },
        "resolved": true,
        "details": {
          "function_name": "remove_node",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/gcov/fs.c",
          "lines": "603-612",
          "snippet": "static void remove_node(struct gcov_node *node)\n{\n\tstruct gcov_node *parent;\n\n\twhile ((node != &root_node) && list_empty(&node->children)) {\n\t\tparent = node->parent;\n\t\trelease_node(node);\n\t\tnode = parent;\n\t}\n}",
          "includes": [
            "#include \"gcov.h\"",
            "#include <linux/mm.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct gcov_node root_node;",
            "static void remove_node(struct gcov_node *node);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"gcov.h\"\n#include <linux/mm.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic struct gcov_node root_node;\nstatic void remove_node(struct gcov_node *node);\n\nstatic void remove_node(struct gcov_node *node)\n{\n\tstruct gcov_node *parent;\n\n\twhile ((node != &root_node) && list_empty(&node->children)) {\n\t\tparent = node->parent;\n\t\trelease_node(node);\n\t\tnode = parent;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "filename"
          ],
          "line": 712
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "new_node",
          "args": [
            "parent",
            "info",
            "curr"
          ],
          "line": 708
        },
        "resolved": true,
        "details": {
          "function_name": "new_node",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/gcov/fs.c",
          "lines": "539-571",
          "snippet": "static struct gcov_node *new_node(struct gcov_node *parent,\n\t\t\t\t  struct gcov_info *info, const char *name)\n{\n\tstruct gcov_node *node;\n\n\tnode = kzalloc(sizeof(struct gcov_node) + strlen(name) + 1, GFP_KERNEL);\n\tif (!node)\n\t\tgoto err_nomem;\n\tif (info) {\n\t\tnode->loaded_info = kcalloc(1, sizeof(struct gcov_info *),\n\t\t\t\t\t   GFP_KERNEL);\n\t\tif (!node->loaded_info)\n\t\t\tgoto err_nomem;\n\t}\n\tinit_node(node, info, name, parent);\n\t/* Differentiate between gcov data file nodes and directory nodes. */\n\tif (info) {\n\t\tnode->dentry = debugfs_create_file(deskew(node->name), 0600,\n\t\t\t\t\tparent->dentry, node, &gcov_data_fops);\n\t} else\n\t\tnode->dentry = debugfs_create_dir(node->name, parent->dentry);\n\tif (info)\n\t\tadd_links(node, parent->dentry);\n\tlist_add(&node->list, &parent->children);\n\tlist_add(&node->all, &all_head);\n\n\treturn node;\n\nerr_nomem:\n\tkfree(node);\n\tpr_warn(\"out of memory\\n\");\n\treturn NULL;\n}",
          "includes": [
            "#include \"gcov.h\"",
            "#include <linux/mm.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(all_head);",
            "static void remove_node(struct gcov_node *node);",
            "static const struct file_operations gcov_data_fops = {\n\t.open\t\t= gcov_seq_open,\n\t.release\t= gcov_seq_release,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= seq_lseek,\n\t.write\t\t= gcov_seq_write,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"gcov.h\"\n#include <linux/mm.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic LIST_HEAD(all_head);\nstatic void remove_node(struct gcov_node *node);\nstatic const struct file_operations gcov_data_fops = {\n\t.open\t\t= gcov_seq_open,\n\t.release\t= gcov_seq_release,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= seq_lseek,\n\t.write\t\t= gcov_seq_write,\n};\n\nstatic struct gcov_node *new_node(struct gcov_node *parent,\n\t\t\t\t  struct gcov_info *info, const char *name)\n{\n\tstruct gcov_node *node;\n\n\tnode = kzalloc(sizeof(struct gcov_node) + strlen(name) + 1, GFP_KERNEL);\n\tif (!node)\n\t\tgoto err_nomem;\n\tif (info) {\n\t\tnode->loaded_info = kcalloc(1, sizeof(struct gcov_info *),\n\t\t\t\t\t   GFP_KERNEL);\n\t\tif (!node->loaded_info)\n\t\t\tgoto err_nomem;\n\t}\n\tinit_node(node, info, name, parent);\n\t/* Differentiate between gcov data file nodes and directory nodes. */\n\tif (info) {\n\t\tnode->dentry = debugfs_create_file(deskew(node->name), 0600,\n\t\t\t\t\tparent->dentry, node, &gcov_data_fops);\n\t} else\n\t\tnode->dentry = debugfs_create_dir(node->name, parent->dentry);\n\tif (info)\n\t\tadd_links(node, parent->dentry);\n\tlist_add(&node->list, &parent->children);\n\tlist_add(&node->all, &all_head);\n\n\treturn node;\n\nerr_nomem:\n\tkfree(node);\n\tpr_warn(\"out of memory\\n\");\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_child_by_name",
          "args": [
            "parent",
            "curr"
          ],
          "line": 699
        },
        "resolved": true,
        "details": {
          "function_name": "get_child_by_name",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/gcov/fs.c",
          "lines": "618-629",
          "snippet": "static struct gcov_node *get_child_by_name(struct gcov_node *parent,\n\t\t\t\t\t   const char *name)\n{\n\tstruct gcov_node *node;\n\n\tlist_for_each_entry(node, &parent->children, list) {\n\t\tif (strcmp(node->name, name) == 0)\n\t\t\treturn node;\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"gcov.h\"",
            "#include <linux/mm.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void remove_node(struct gcov_node *node);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"gcov.h\"\n#include <linux/mm.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic void remove_node(struct gcov_node *node);\n\nstatic struct gcov_node *get_child_by_name(struct gcov_node *parent,\n\t\t\t\t\t   const char *name)\n{\n\tstruct gcov_node *node;\n\n\tlist_for_each_entry(node, &parent->children, list) {\n\t\tif (strcmp(node->name, name) == 0)\n\t\t\treturn node;\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "curr",
            "\"..\""
          ],
          "line": 693
        },
        "resolved": true,
        "details": {
          "function_name": "sym_strcmp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/report.c",
          "lines": "356-365",
          "snippet": "static int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}",
          "includes": [
            "#include \"encoding.h\"",
            "#include \"kcsan.h\"",
            "#include <linux/stacktrace.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/delay.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"encoding.h\"\n#include \"kcsan.h\"\n#include <linux/stacktrace.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/lockdep.h>\n#include <linux/kernel.h>\n#include <linux/kallsyms.h>\n#include <linux/jiffies.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n\nstatic int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}"
        }
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "curr",
            "'/'"
          ],
          "line": 687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "gcov_info_filename(info)",
            "GFP_KERNEL"
          ],
          "line": 682
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gcov_info_filename",
          "args": [
            "info"
          ],
          "line": 682
        },
        "resolved": true,
        "details": {
          "function_name": "gcov_info_filename",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/gcov/gcc_4_7.c",
          "lines": "100-103",
          "snippet": "const char *gcov_info_filename(struct gcov_info *info)\n{\n\treturn info->filename;\n}",
          "includes": [
            "#include \"gcov.h\"",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"gcov.h\"\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n\nconst char *gcov_info_filename(struct gcov_info *info)\n{\n\treturn info->filename;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"gcov.h\"\n#include <linux/mm.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic struct gcov_node root_node;\nstatic void remove_node(struct gcov_node *node);\n\nstatic void add_node(struct gcov_info *info)\n{\n\tchar *filename;\n\tchar *curr;\n\tchar *next;\n\tstruct gcov_node *parent;\n\tstruct gcov_node *node;\n\n\tfilename = kstrdup(gcov_info_filename(info), GFP_KERNEL);\n\tif (!filename)\n\t\treturn;\n\tparent = &root_node;\n\t/* Create directory nodes along the path. */\n\tfor (curr = filename; (next = strchr(curr, '/')); curr = next + 1) {\n\t\tif (curr == next)\n\t\t\tcontinue;\n\t\t*next = 0;\n\t\tif (strcmp(curr, \".\") == 0)\n\t\t\tcontinue;\n\t\tif (strcmp(curr, \"..\") == 0) {\n\t\t\tif (!parent->parent)\n\t\t\t\tgoto err_remove;\n\t\t\tparent = parent->parent;\n\t\t\tcontinue;\n\t\t}\n\t\tnode = get_child_by_name(parent, curr);\n\t\tif (!node) {\n\t\t\tnode = new_node(parent, NULL, curr);\n\t\t\tif (!node)\n\t\t\t\tgoto err_remove;\n\t\t}\n\t\tparent = node;\n\t}\n\t/* Create file node. */\n\tnode = new_node(parent, info, curr);\n\tif (!node)\n\t\tgoto err_remove;\nout:\n\tkfree(filename);\n\treturn;\n\nerr_remove:\n\tremove_node(parent);\n\tgoto out;\n}"
  },
  {
    "function_name": "reset_read",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/gcov/fs.c",
    "lines": "657-662",
    "snippet": "static ssize_t reset_read(struct file *file, char __user *addr, size_t len,\n\t\t\t  loff_t *pos)\n{\n\t/* Allow read operation so that a recursive copy won't fail. */\n\treturn 0;\n}",
    "includes": [
      "#include \"gcov.h\"",
      "#include <linux/mm.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/string.h>",
      "#include <linux/list.h>",
      "#include <linux/fs.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"gcov.h\"\n#include <linux/mm.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic ssize_t reset_read(struct file *file, char __user *addr, size_t len,\n\t\t\t  loff_t *pos)\n{\n\t/* Allow read operation so that a recursive copy won't fail. */\n\treturn 0;\n}"
  },
  {
    "function_name": "reset_write",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/gcov/fs.c",
    "lines": "635-654",
    "snippet": "static ssize_t reset_write(struct file *file, const char __user *addr,\n\t\t\t   size_t len, loff_t *pos)\n{\n\tstruct gcov_node *node;\n\n\tmutex_lock(&node_lock);\nrestart:\n\tlist_for_each_entry(node, &all_head, all) {\n\t\tif (node->num_loaded > 0)\n\t\t\treset_node(node);\n\t\telse if (list_empty(&node->children)) {\n\t\t\tremove_node(node);\n\t\t\t/* Several nodes may have gone - restart loop. */\n\t\t\tgoto restart;\n\t\t}\n\t}\n\tmutex_unlock(&node_lock);\n\n\treturn len;\n}",
    "includes": [
      "#include \"gcov.h\"",
      "#include <linux/mm.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/string.h>",
      "#include <linux/list.h>",
      "#include <linux/fs.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(all_head);",
      "static DEFINE_MUTEX(node_lock);",
      "static void remove_node(struct gcov_node *node);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&node_lock"
          ],
          "line": 651
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "remove_node",
          "args": [
            "node"
          ],
          "line": 646
        },
        "resolved": true,
        "details": {
          "function_name": "remove_node",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/gcov/fs.c",
          "lines": "603-612",
          "snippet": "static void remove_node(struct gcov_node *node)\n{\n\tstruct gcov_node *parent;\n\n\twhile ((node != &root_node) && list_empty(&node->children)) {\n\t\tparent = node->parent;\n\t\trelease_node(node);\n\t\tnode = parent;\n\t}\n}",
          "includes": [
            "#include \"gcov.h\"",
            "#include <linux/mm.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct gcov_node root_node;",
            "static void remove_node(struct gcov_node *node);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"gcov.h\"\n#include <linux/mm.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic struct gcov_node root_node;\nstatic void remove_node(struct gcov_node *node);\n\nstatic void remove_node(struct gcov_node *node)\n{\n\tstruct gcov_node *parent;\n\n\twhile ((node != &root_node) && list_empty(&node->children)) {\n\t\tparent = node->parent;\n\t\trelease_node(node);\n\t\tnode = parent;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&node->children"
          ],
          "line": 645
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "41-44",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "long rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nlong rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "reset_node",
          "args": [
            "node"
          ],
          "line": 644
        },
        "resolved": true,
        "details": {
          "function_name": "reset_node",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/gcov/fs.c",
          "lines": "365-373",
          "snippet": "static void reset_node(struct gcov_node *node)\n{\n\tint i;\n\n\tif (node->unloaded_info)\n\t\tgcov_info_reset(node->unloaded_info);\n\tfor (i = 0; i < node->num_loaded; i++)\n\t\tgcov_info_reset(node->loaded_info[i]);\n}",
          "includes": [
            "#include \"gcov.h\"",
            "#include <linux/mm.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void remove_node(struct gcov_node *node);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"gcov.h\"\n#include <linux/mm.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic void remove_node(struct gcov_node *node);\n\nstatic void reset_node(struct gcov_node *node)\n{\n\tint i;\n\n\tif (node->unloaded_info)\n\t\tgcov_info_reset(node->unloaded_info);\n\tfor (i = 0; i < node->num_loaded; i++)\n\t\tgcov_info_reset(node->loaded_info[i]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "node",
            "&all_head",
            "all"
          ],
          "line": 642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&node_lock"
          ],
          "line": 640
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"gcov.h\"\n#include <linux/mm.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic LIST_HEAD(all_head);\nstatic DEFINE_MUTEX(node_lock);\nstatic void remove_node(struct gcov_node *node);\n\nstatic ssize_t reset_write(struct file *file, const char __user *addr,\n\t\t\t   size_t len, loff_t *pos)\n{\n\tstruct gcov_node *node;\n\n\tmutex_lock(&node_lock);\nrestart:\n\tlist_for_each_entry(node, &all_head, all) {\n\t\tif (node->num_loaded > 0)\n\t\t\treset_node(node);\n\t\telse if (list_empty(&node->children)) {\n\t\t\tremove_node(node);\n\t\t\t/* Several nodes may have gone - restart loop. */\n\t\t\tgoto restart;\n\t\t}\n\t}\n\tmutex_unlock(&node_lock);\n\n\treturn len;\n}"
  },
  {
    "function_name": "get_child_by_name",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/gcov/fs.c",
    "lines": "618-629",
    "snippet": "static struct gcov_node *get_child_by_name(struct gcov_node *parent,\n\t\t\t\t\t   const char *name)\n{\n\tstruct gcov_node *node;\n\n\tlist_for_each_entry(node, &parent->children, list) {\n\t\tif (strcmp(node->name, name) == 0)\n\t\t\treturn node;\n\t}\n\n\treturn NULL;\n}",
    "includes": [
      "#include \"gcov.h\"",
      "#include <linux/mm.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/string.h>",
      "#include <linux/list.h>",
      "#include <linux/fs.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void remove_node(struct gcov_node *node);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "node->name",
            "name"
          ],
          "line": 624
        },
        "resolved": true,
        "details": {
          "function_name": "sym_strcmp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/report.c",
          "lines": "356-365",
          "snippet": "static int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}",
          "includes": [
            "#include \"encoding.h\"",
            "#include \"kcsan.h\"",
            "#include <linux/stacktrace.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/delay.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"encoding.h\"\n#include \"kcsan.h\"\n#include <linux/stacktrace.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/lockdep.h>\n#include <linux/kernel.h>\n#include <linux/kallsyms.h>\n#include <linux/jiffies.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n\nstatic int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "node",
            "&parent->children",
            "list"
          ],
          "line": 623
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"gcov.h\"\n#include <linux/mm.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic void remove_node(struct gcov_node *node);\n\nstatic struct gcov_node *get_child_by_name(struct gcov_node *parent,\n\t\t\t\t\t   const char *name)\n{\n\tstruct gcov_node *node;\n\n\tlist_for_each_entry(node, &parent->children, list) {\n\t\tif (strcmp(node->name, name) == 0)\n\t\t\treturn node;\n\t}\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "remove_node",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/gcov/fs.c",
    "lines": "603-612",
    "snippet": "static void remove_node(struct gcov_node *node)\n{\n\tstruct gcov_node *parent;\n\n\twhile ((node != &root_node) && list_empty(&node->children)) {\n\t\tparent = node->parent;\n\t\trelease_node(node);\n\t\tnode = parent;\n\t}\n}",
    "includes": [
      "#include \"gcov.h\"",
      "#include <linux/mm.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/string.h>",
      "#include <linux/list.h>",
      "#include <linux/fs.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct gcov_node root_node;",
      "static void remove_node(struct gcov_node *node);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "release_node",
          "args": [
            "node"
          ],
          "line": 609
        },
        "resolved": true,
        "details": {
          "function_name": "release_node",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/gcov/fs.c",
          "lines": "590-600",
          "snippet": "static void release_node(struct gcov_node *node)\n{\n\tlist_del(&node->list);\n\tlist_del(&node->all);\n\tdebugfs_remove(node->dentry);\n\tremove_links(node);\n\tkfree(node->loaded_info);\n\tif (node->unloaded_info)\n\t\tgcov_info_free(node->unloaded_info);\n\tkfree(node);\n}",
          "includes": [
            "#include \"gcov.h\"",
            "#include <linux/mm.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void remove_node(struct gcov_node *node);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"gcov.h\"\n#include <linux/mm.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic void remove_node(struct gcov_node *node);\n\nstatic void release_node(struct gcov_node *node)\n{\n\tlist_del(&node->list);\n\tlist_del(&node->all);\n\tdebugfs_remove(node->dentry);\n\tremove_links(node);\n\tkfree(node->loaded_info);\n\tif (node->unloaded_info)\n\t\tgcov_info_free(node->unloaded_info);\n\tkfree(node);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&node->children"
          ],
          "line": 607
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "41-44",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "long rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nlong rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"gcov.h\"\n#include <linux/mm.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic struct gcov_node root_node;\nstatic void remove_node(struct gcov_node *node);\n\nstatic void remove_node(struct gcov_node *node)\n{\n\tstruct gcov_node *parent;\n\n\twhile ((node != &root_node) && list_empty(&node->children)) {\n\t\tparent = node->parent;\n\t\trelease_node(node);\n\t\tnode = parent;\n\t}\n}"
  },
  {
    "function_name": "release_node",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/gcov/fs.c",
    "lines": "590-600",
    "snippet": "static void release_node(struct gcov_node *node)\n{\n\tlist_del(&node->list);\n\tlist_del(&node->all);\n\tdebugfs_remove(node->dentry);\n\tremove_links(node);\n\tkfree(node->loaded_info);\n\tif (node->unloaded_info)\n\t\tgcov_info_free(node->unloaded_info);\n\tkfree(node);\n}",
    "includes": [
      "#include \"gcov.h\"",
      "#include <linux/mm.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/string.h>",
      "#include <linux/list.h>",
      "#include <linux/fs.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void remove_node(struct gcov_node *node);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "node"
          ],
          "line": 599
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gcov_info_free",
          "args": [
            "node->unloaded_info"
          ],
          "line": 598
        },
        "resolved": true,
        "details": {
          "function_name": "gcov_info_free",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/gcov/gcc_4_7.c",
          "lines": "335-363",
          "snippet": "void gcov_info_free(struct gcov_info *info)\n{\n\tunsigned int active;\n\tunsigned int fi_idx;\n\tunsigned int ct_idx;\n\tstruct gcov_ctr_info *ci_ptr;\n\n\tif (!info->functions)\n\t\tgoto free_info;\n\n\tactive = num_counter_active(info);\n\n\tfor (fi_idx = 0; fi_idx < info->n_functions; fi_idx++) {\n\t\tif (!info->functions[fi_idx])\n\t\t\tcontinue;\n\n\t\tci_ptr = info->functions[fi_idx]->ctrs;\n\n\t\tfor (ct_idx = 0; ct_idx < active; ct_idx++, ci_ptr++)\n\t\t\tkvfree(ci_ptr->values);\n\n\t\tkfree(info->functions[fi_idx]);\n\t}\n\nfree_info:\n\tkfree(info->functions);\n\tkfree(info->filename);\n\tkfree(info);\n}",
          "includes": [
            "#include \"gcov.h\"",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"gcov.h\"\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n\nvoid gcov_info_free(struct gcov_info *info)\n{\n\tunsigned int active;\n\tunsigned int fi_idx;\n\tunsigned int ct_idx;\n\tstruct gcov_ctr_info *ci_ptr;\n\n\tif (!info->functions)\n\t\tgoto free_info;\n\n\tactive = num_counter_active(info);\n\n\tfor (fi_idx = 0; fi_idx < info->n_functions; fi_idx++) {\n\t\tif (!info->functions[fi_idx])\n\t\t\tcontinue;\n\n\t\tci_ptr = info->functions[fi_idx]->ctrs;\n\n\t\tfor (ct_idx = 0; ct_idx < active; ct_idx++, ci_ptr++)\n\t\t\tkvfree(ci_ptr->values);\n\n\t\tkfree(info->functions[fi_idx]);\n\t}\n\nfree_info:\n\tkfree(info->functions);\n\tkfree(info->filename);\n\tkfree(info);\n}"
        }
      },
      {
        "call_info": {
          "callee": "remove_links",
          "args": [
            "node"
          ],
          "line": 595
        },
        "resolved": true,
        "details": {
          "function_name": "remove_links",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/gcov/fs.c",
          "lines": "574-584",
          "snippet": "static void remove_links(struct gcov_node *node)\n{\n\tint i;\n\n\tif (!node->links)\n\t\treturn;\n\tfor (i = 0; gcov_link[i].ext; i++)\n\t\tdebugfs_remove(node->links[i]);\n\tkfree(node->links);\n\tnode->links = NULL;\n}",
          "includes": [
            "#include \"gcov.h\"",
            "#include <linux/mm.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void remove_node(struct gcov_node *node);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"gcov.h\"\n#include <linux/mm.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic void remove_node(struct gcov_node *node);\n\nstatic void remove_links(struct gcov_node *node)\n{\n\tint i;\n\n\tif (!node->links)\n\t\treturn;\n\tfor (i = 0; gcov_link[i].ext; i++)\n\t\tdebugfs_remove(node->links[i]);\n\tkfree(node->links);\n\tnode->links = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "debugfs_remove",
          "args": [
            "node->dentry"
          ],
          "line": 594
        },
        "resolved": true,
        "details": {
          "function_name": "fei_debugfs_remove_attr",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/fail_function.c",
          "lines": "164-170",
          "snippet": "static void fei_debugfs_remove_attr(struct fei_attr *attr)\n{\n\tstruct dentry *dir;\n\n\tdir = debugfs_lookup(attr->kp.symbol_name, fei_debugfs_dir);\n\tdebugfs_remove_recursive(dir);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/error-injection.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct dentry *fei_debugfs_dir;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/kprobes.h>\n#include <linux/kallsyms.h>\n#include <linux/fault-inject.h>\n#include <linux/debugfs.h>\n#include <linux/error-injection.h>\n\nstatic struct dentry *fei_debugfs_dir;\n\nstatic void fei_debugfs_remove_attr(struct fei_attr *attr)\n{\n\tstruct dentry *dir;\n\n\tdir = debugfs_lookup(attr->kp.symbol_name, fei_debugfs_dir);\n\tdebugfs_remove_recursive(dir);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&node->all"
          ],
          "line": 593
        },
        "resolved": true,
        "details": {
          "function_name": "list_del_leaf_cfs_rq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/fair.c",
          "lines": "475-477",
          "snippet": "static inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool sched_idle_cfs_rq(struct cfs_rq *cfs_rq);",
            "static void check_enqueue_throttle(struct cfs_rq *cfs_rq);",
            "static __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);",
            "static bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic bool sched_idle_cfs_rq(struct cfs_rq *cfs_rq);\nstatic void check_enqueue_throttle(struct cfs_rq *cfs_rq);\nstatic __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);\nstatic bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);\n\nstatic inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"gcov.h\"\n#include <linux/mm.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic void remove_node(struct gcov_node *node);\n\nstatic void release_node(struct gcov_node *node)\n{\n\tlist_del(&node->list);\n\tlist_del(&node->all);\n\tdebugfs_remove(node->dentry);\n\tremove_links(node);\n\tkfree(node->loaded_info);\n\tif (node->unloaded_info)\n\t\tgcov_info_free(node->unloaded_info);\n\tkfree(node);\n}"
  },
  {
    "function_name": "remove_links",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/gcov/fs.c",
    "lines": "574-584",
    "snippet": "static void remove_links(struct gcov_node *node)\n{\n\tint i;\n\n\tif (!node->links)\n\t\treturn;\n\tfor (i = 0; gcov_link[i].ext; i++)\n\t\tdebugfs_remove(node->links[i]);\n\tkfree(node->links);\n\tnode->links = NULL;\n}",
    "includes": [
      "#include \"gcov.h\"",
      "#include <linux/mm.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/string.h>",
      "#include <linux/list.h>",
      "#include <linux/fs.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void remove_node(struct gcov_node *node);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "node->links"
          ],
          "line": 582
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "debugfs_remove",
          "args": [
            "node->links[i]"
          ],
          "line": 581
        },
        "resolved": true,
        "details": {
          "function_name": "fei_debugfs_remove_attr",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/fail_function.c",
          "lines": "164-170",
          "snippet": "static void fei_debugfs_remove_attr(struct fei_attr *attr)\n{\n\tstruct dentry *dir;\n\n\tdir = debugfs_lookup(attr->kp.symbol_name, fei_debugfs_dir);\n\tdebugfs_remove_recursive(dir);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/error-injection.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct dentry *fei_debugfs_dir;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/kprobes.h>\n#include <linux/kallsyms.h>\n#include <linux/fault-inject.h>\n#include <linux/debugfs.h>\n#include <linux/error-injection.h>\n\nstatic struct dentry *fei_debugfs_dir;\n\nstatic void fei_debugfs_remove_attr(struct fei_attr *attr)\n{\n\tstruct dentry *dir;\n\n\tdir = debugfs_lookup(attr->kp.symbol_name, fei_debugfs_dir);\n\tdebugfs_remove_recursive(dir);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"gcov.h\"\n#include <linux/mm.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic void remove_node(struct gcov_node *node);\n\nstatic void remove_links(struct gcov_node *node)\n{\n\tint i;\n\n\tif (!node->links)\n\t\treturn;\n\tfor (i = 0; gcov_link[i].ext; i++)\n\t\tdebugfs_remove(node->links[i]);\n\tkfree(node->links);\n\tnode->links = NULL;\n}"
  },
  {
    "function_name": "new_node",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/gcov/fs.c",
    "lines": "539-571",
    "snippet": "static struct gcov_node *new_node(struct gcov_node *parent,\n\t\t\t\t  struct gcov_info *info, const char *name)\n{\n\tstruct gcov_node *node;\n\n\tnode = kzalloc(sizeof(struct gcov_node) + strlen(name) + 1, GFP_KERNEL);\n\tif (!node)\n\t\tgoto err_nomem;\n\tif (info) {\n\t\tnode->loaded_info = kcalloc(1, sizeof(struct gcov_info *),\n\t\t\t\t\t   GFP_KERNEL);\n\t\tif (!node->loaded_info)\n\t\t\tgoto err_nomem;\n\t}\n\tinit_node(node, info, name, parent);\n\t/* Differentiate between gcov data file nodes and directory nodes. */\n\tif (info) {\n\t\tnode->dentry = debugfs_create_file(deskew(node->name), 0600,\n\t\t\t\t\tparent->dentry, node, &gcov_data_fops);\n\t} else\n\t\tnode->dentry = debugfs_create_dir(node->name, parent->dentry);\n\tif (info)\n\t\tadd_links(node, parent->dentry);\n\tlist_add(&node->list, &parent->children);\n\tlist_add(&node->all, &all_head);\n\n\treturn node;\n\nerr_nomem:\n\tkfree(node);\n\tpr_warn(\"out of memory\\n\");\n\treturn NULL;\n}",
    "includes": [
      "#include \"gcov.h\"",
      "#include <linux/mm.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/string.h>",
      "#include <linux/list.h>",
      "#include <linux/fs.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(all_head);",
      "static void remove_node(struct gcov_node *node);",
      "static const struct file_operations gcov_data_fops = {\n\t.open\t\t= gcov_seq_open,\n\t.release\t= gcov_seq_release,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= seq_lseek,\n\t.write\t\t= gcov_seq_write,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"out of memory\\n\""
          ],
          "line": 569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "node"
          ],
          "line": 568
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&node->all",
            "&all_head"
          ],
          "line": 563
        },
        "resolved": true,
        "details": {
          "function_name": "cmp_filterlist_addrs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/debugfs.c",
          "lines": "95-101",
          "snippet": "static int cmp_filterlist_addrs(const void *rhs, const void *lhs)\n{\n\tconst unsigned long a = *(const unsigned long *)rhs;\n\tconst unsigned long b = *(const unsigned long *)lhs;\n\n\treturn a < b ? -1 : a == b ? 0 : 1;\n}",
          "includes": [
            "#include \"kcsan.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/bug.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kcsan.h\"\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/debugfs.h>\n#include <linux/bug.h>\n#include <linux/bsearch.h>\n#include <linux/atomic.h>\n\nstatic int cmp_filterlist_addrs(const void *rhs, const void *lhs)\n{\n\tconst unsigned long a = *(const unsigned long *)rhs;\n\tconst unsigned long b = *(const unsigned long *)lhs;\n\n\treturn a < b ? -1 : a == b ? 0 : 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "add_links",
          "args": [
            "node",
            "parent->dentry"
          ],
          "line": 561
        },
        "resolved": true,
        "details": {
          "function_name": "add_links",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/gcov/fs.c",
          "lines": "476-509",
          "snippet": "static void add_links(struct gcov_node *node, struct dentry *parent)\n{\n\tconst char *basename;\n\tchar *target;\n\tint num;\n\tint i;\n\n\tfor (num = 0; gcov_link[num].ext; num++)\n\t\t/* Nothing. */;\n\tnode->links = kcalloc(num, sizeof(struct dentry *), GFP_KERNEL);\n\tif (!node->links)\n\t\treturn;\n\tfor (i = 0; i < num; i++) {\n\t\ttarget = get_link_target(\n\t\t\t\tgcov_info_filename(get_node_info(node)),\n\t\t\t\t&gcov_link[i]);\n\t\tif (!target)\n\t\t\tgoto out_err;\n\t\tbasename = kbasename(target);\n\t\tif (basename == target)\n\t\t\tgoto out_err;\n\t\tnode->links[i] = debugfs_create_symlink(deskew(basename),\n\t\t\t\t\t\t\tparent,\ttarget);\n\t\tkfree(target);\n\t}\n\n\treturn;\nout_err:\n\tkfree(target);\n\twhile (i-- > 0)\n\t\tdebugfs_remove(node->links[i]);\n\tkfree(node->links);\n\tnode->links = NULL;\n}",
          "includes": [
            "#include \"gcov.h\"",
            "#include <linux/mm.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void remove_node(struct gcov_node *node);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"gcov.h\"\n#include <linux/mm.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic void remove_node(struct gcov_node *node);\n\nstatic void add_links(struct gcov_node *node, struct dentry *parent)\n{\n\tconst char *basename;\n\tchar *target;\n\tint num;\n\tint i;\n\n\tfor (num = 0; gcov_link[num].ext; num++)\n\t\t/* Nothing. */;\n\tnode->links = kcalloc(num, sizeof(struct dentry *), GFP_KERNEL);\n\tif (!node->links)\n\t\treturn;\n\tfor (i = 0; i < num; i++) {\n\t\ttarget = get_link_target(\n\t\t\t\tgcov_info_filename(get_node_info(node)),\n\t\t\t\t&gcov_link[i]);\n\t\tif (!target)\n\t\t\tgoto out_err;\n\t\tbasename = kbasename(target);\n\t\tif (basename == target)\n\t\t\tgoto out_err;\n\t\tnode->links[i] = debugfs_create_symlink(deskew(basename),\n\t\t\t\t\t\t\tparent,\ttarget);\n\t\tkfree(target);\n\t}\n\n\treturn;\nout_err:\n\tkfree(target);\n\twhile (i-- > 0)\n\t\tdebugfs_remove(node->links[i]);\n\tkfree(node->links);\n\tnode->links = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "debugfs_create_dir",
          "args": [
            "node->name",
            "parent->dentry"
          ],
          "line": 559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debugfs_create_file",
          "args": [
            "deskew(node->name)",
            "0600",
            "parent->dentry",
            "node",
            "&gcov_data_fops"
          ],
          "line": 556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "deskew",
          "args": [
            "node->name"
          ],
          "line": 556
        },
        "resolved": true,
        "details": {
          "function_name": "deskew",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/gcov/fs.c",
          "lines": "465-470",
          "snippet": "static const char *deskew(const char *basename)\n{\n\tif (strncmp(basename, SKEW_PREFIX, sizeof(SKEW_PREFIX) - 1) == 0)\n\t\treturn basename + sizeof(SKEW_PREFIX) - 1;\n\treturn basename;\n}",
          "includes": [
            "#include \"gcov.h\"",
            "#include <linux/mm.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [
            "#define SKEW_PREFIX\t\".tmp_\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"gcov.h\"\n#include <linux/mm.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\n#define SKEW_PREFIX\t\".tmp_\"\n\nstatic const char *deskew(const char *basename)\n{\n\tif (strncmp(basename, SKEW_PREFIX, sizeof(SKEW_PREFIX) - 1) == 0)\n\t\treturn basename + sizeof(SKEW_PREFIX) - 1;\n\treturn basename;\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_node",
          "args": [
            "node",
            "info",
            "name",
            "parent"
          ],
          "line": 553
        },
        "resolved": true,
        "details": {
          "function_name": "init_node",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/gcov/fs.c",
          "lines": "520-533",
          "snippet": "static void init_node(struct gcov_node *node, struct gcov_info *info,\n\t\t      const char *name, struct gcov_node *parent)\n{\n\tINIT_LIST_HEAD(&node->list);\n\tINIT_LIST_HEAD(&node->children);\n\tINIT_LIST_HEAD(&node->all);\n\tif (node->loaded_info) {\n\t\tnode->loaded_info[0] = info;\n\t\tnode->num_loaded = 1;\n\t}\n\tnode->parent = parent;\n\tif (name)\n\t\tstrcpy(node->name, name);\n}",
          "includes": [
            "#include \"gcov.h\"",
            "#include <linux/mm.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void remove_node(struct gcov_node *node);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"gcov.h\"\n#include <linux/mm.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic void remove_node(struct gcov_node *node);\n\nstatic void init_node(struct gcov_node *node, struct gcov_info *info,\n\t\t      const char *name, struct gcov_node *parent)\n{\n\tINIT_LIST_HEAD(&node->list);\n\tINIT_LIST_HEAD(&node->children);\n\tINIT_LIST_HEAD(&node->all);\n\tif (node->loaded_info) {\n\t\tnode->loaded_info[0] = info;\n\t\tnode->num_loaded = 1;\n\t}\n\tnode->parent = parent;\n\tif (name)\n\t\tstrcpy(node->name, name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kcalloc",
          "args": [
            "1",
            "sizeof(struct gcov_info *)",
            "GFP_KERNEL"
          ],
          "line": 548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct gcov_node) + strlen(name) + 1",
            "GFP_KERNEL"
          ],
          "line": 544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "name"
          ],
          "line": 544
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_eprobe.c",
          "lines": "384-401",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/ftrace.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"gcov.h\"\n#include <linux/mm.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic LIST_HEAD(all_head);\nstatic void remove_node(struct gcov_node *node);\nstatic const struct file_operations gcov_data_fops = {\n\t.open\t\t= gcov_seq_open,\n\t.release\t= gcov_seq_release,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= seq_lseek,\n\t.write\t\t= gcov_seq_write,\n};\n\nstatic struct gcov_node *new_node(struct gcov_node *parent,\n\t\t\t\t  struct gcov_info *info, const char *name)\n{\n\tstruct gcov_node *node;\n\n\tnode = kzalloc(sizeof(struct gcov_node) + strlen(name) + 1, GFP_KERNEL);\n\tif (!node)\n\t\tgoto err_nomem;\n\tif (info) {\n\t\tnode->loaded_info = kcalloc(1, sizeof(struct gcov_info *),\n\t\t\t\t\t   GFP_KERNEL);\n\t\tif (!node->loaded_info)\n\t\t\tgoto err_nomem;\n\t}\n\tinit_node(node, info, name, parent);\n\t/* Differentiate between gcov data file nodes and directory nodes. */\n\tif (info) {\n\t\tnode->dentry = debugfs_create_file(deskew(node->name), 0600,\n\t\t\t\t\tparent->dentry, node, &gcov_data_fops);\n\t} else\n\t\tnode->dentry = debugfs_create_dir(node->name, parent->dentry);\n\tif (info)\n\t\tadd_links(node, parent->dentry);\n\tlist_add(&node->list, &parent->children);\n\tlist_add(&node->all, &all_head);\n\n\treturn node;\n\nerr_nomem:\n\tkfree(node);\n\tpr_warn(\"out of memory\\n\");\n\treturn NULL;\n}"
  },
  {
    "function_name": "init_node",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/gcov/fs.c",
    "lines": "520-533",
    "snippet": "static void init_node(struct gcov_node *node, struct gcov_info *info,\n\t\t      const char *name, struct gcov_node *parent)\n{\n\tINIT_LIST_HEAD(&node->list);\n\tINIT_LIST_HEAD(&node->children);\n\tINIT_LIST_HEAD(&node->all);\n\tif (node->loaded_info) {\n\t\tnode->loaded_info[0] = info;\n\t\tnode->num_loaded = 1;\n\t}\n\tnode->parent = parent;\n\tif (name)\n\t\tstrcpy(node->name, name);\n}",
    "includes": [
      "#include \"gcov.h\"",
      "#include <linux/mm.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/string.h>",
      "#include <linux/list.h>",
      "#include <linux/fs.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void remove_node(struct gcov_node *node);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "node->name",
            "name"
          ],
          "line": 532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&node->all"
          ],
          "line": 525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&node->children"
          ],
          "line": 524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&node->list"
          ],
          "line": 523
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"gcov.h\"\n#include <linux/mm.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic void remove_node(struct gcov_node *node);\n\nstatic void init_node(struct gcov_node *node, struct gcov_info *info,\n\t\t      const char *name, struct gcov_node *parent)\n{\n\tINIT_LIST_HEAD(&node->list);\n\tINIT_LIST_HEAD(&node->children);\n\tINIT_LIST_HEAD(&node->all);\n\tif (node->loaded_info) {\n\t\tnode->loaded_info[0] = info;\n\t\tnode->num_loaded = 1;\n\t}\n\tnode->parent = parent;\n\tif (name)\n\t\tstrcpy(node->name, name);\n}"
  },
  {
    "function_name": "add_links",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/gcov/fs.c",
    "lines": "476-509",
    "snippet": "static void add_links(struct gcov_node *node, struct dentry *parent)\n{\n\tconst char *basename;\n\tchar *target;\n\tint num;\n\tint i;\n\n\tfor (num = 0; gcov_link[num].ext; num++)\n\t\t/* Nothing. */;\n\tnode->links = kcalloc(num, sizeof(struct dentry *), GFP_KERNEL);\n\tif (!node->links)\n\t\treturn;\n\tfor (i = 0; i < num; i++) {\n\t\ttarget = get_link_target(\n\t\t\t\tgcov_info_filename(get_node_info(node)),\n\t\t\t\t&gcov_link[i]);\n\t\tif (!target)\n\t\t\tgoto out_err;\n\t\tbasename = kbasename(target);\n\t\tif (basename == target)\n\t\t\tgoto out_err;\n\t\tnode->links[i] = debugfs_create_symlink(deskew(basename),\n\t\t\t\t\t\t\tparent,\ttarget);\n\t\tkfree(target);\n\t}\n\n\treturn;\nout_err:\n\tkfree(target);\n\twhile (i-- > 0)\n\t\tdebugfs_remove(node->links[i]);\n\tkfree(node->links);\n\tnode->links = NULL;\n}",
    "includes": [
      "#include \"gcov.h\"",
      "#include <linux/mm.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/string.h>",
      "#include <linux/list.h>",
      "#include <linux/fs.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void remove_node(struct gcov_node *node);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "node->links"
          ],
          "line": 507
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "debugfs_remove",
          "args": [
            "node->links[i]"
          ],
          "line": 506
        },
        "resolved": true,
        "details": {
          "function_name": "fei_debugfs_remove_attr",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/fail_function.c",
          "lines": "164-170",
          "snippet": "static void fei_debugfs_remove_attr(struct fei_attr *attr)\n{\n\tstruct dentry *dir;\n\n\tdir = debugfs_lookup(attr->kp.symbol_name, fei_debugfs_dir);\n\tdebugfs_remove_recursive(dir);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/error-injection.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct dentry *fei_debugfs_dir;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/kprobes.h>\n#include <linux/kallsyms.h>\n#include <linux/fault-inject.h>\n#include <linux/debugfs.h>\n#include <linux/error-injection.h>\n\nstatic struct dentry *fei_debugfs_dir;\n\nstatic void fei_debugfs_remove_attr(struct fei_attr *attr)\n{\n\tstruct dentry *dir;\n\n\tdir = debugfs_lookup(attr->kp.symbol_name, fei_debugfs_dir);\n\tdebugfs_remove_recursive(dir);\n}"
        }
      },
      {
        "call_info": {
          "callee": "debugfs_create_symlink",
          "args": [
            "deskew(basename)",
            "parent",
            "target"
          ],
          "line": 497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "deskew",
          "args": [
            "basename"
          ],
          "line": 497
        },
        "resolved": true,
        "details": {
          "function_name": "deskew",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/gcov/fs.c",
          "lines": "465-470",
          "snippet": "static const char *deskew(const char *basename)\n{\n\tif (strncmp(basename, SKEW_PREFIX, sizeof(SKEW_PREFIX) - 1) == 0)\n\t\treturn basename + sizeof(SKEW_PREFIX) - 1;\n\treturn basename;\n}",
          "includes": [
            "#include \"gcov.h\"",
            "#include <linux/mm.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [
            "#define SKEW_PREFIX\t\".tmp_\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"gcov.h\"\n#include <linux/mm.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\n#define SKEW_PREFIX\t\".tmp_\"\n\nstatic const char *deskew(const char *basename)\n{\n\tif (strncmp(basename, SKEW_PREFIX, sizeof(SKEW_PREFIX) - 1) == 0)\n\t\treturn basename + sizeof(SKEW_PREFIX) - 1;\n\treturn basename;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kbasename",
          "args": [
            "target"
          ],
          "line": 494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_link_target",
          "args": [
            "gcov_info_filename(get_node_info(node))",
            "&gcov_link[i]"
          ],
          "line": 489
        },
        "resolved": true,
        "details": {
          "function_name": "get_link_target",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/gcov/fs.c",
          "lines": "440-457",
          "snippet": "static char *get_link_target(const char *filename, const struct gcov_link *ext)\n{\n\tconst char *rel;\n\tchar *result;\n\n\tif (strncmp(filename, objtree, strlen(objtree)) == 0) {\n\t\trel = filename + strlen(objtree) + 1;\n\t\tif (ext->dir == SRC_TREE)\n\t\t\tresult = link_target(srctree, rel, ext->ext);\n\t\telse\n\t\t\tresult = link_target(objtree, rel, ext->ext);\n\t} else {\n\t\t/* External compilation. */\n\t\tresult = link_target(NULL, filename, ext->ext);\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include \"gcov.h\"",
            "#include <linux/mm.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char objtree[] = OBJTREE;",
            "static const char srctree[] = SRCTREE;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"gcov.h\"\n#include <linux/mm.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic const char objtree[] = OBJTREE;\nstatic const char srctree[] = SRCTREE;\n\nstatic char *get_link_target(const char *filename, const struct gcov_link *ext)\n{\n\tconst char *rel;\n\tchar *result;\n\n\tif (strncmp(filename, objtree, strlen(objtree)) == 0) {\n\t\trel = filename + strlen(objtree) + 1;\n\t\tif (ext->dir == SRC_TREE)\n\t\t\tresult = link_target(srctree, rel, ext->ext);\n\t\telse\n\t\t\tresult = link_target(objtree, rel, ext->ext);\n\t} else {\n\t\t/* External compilation. */\n\t\tresult = link_target(NULL, filename, ext->ext);\n\t}\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gcov_info_filename",
          "args": [
            "get_node_info(node)"
          ],
          "line": 490
        },
        "resolved": true,
        "details": {
          "function_name": "gcov_info_filename",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/gcov/gcc_4_7.c",
          "lines": "100-103",
          "snippet": "const char *gcov_info_filename(struct gcov_info *info)\n{\n\treturn info->filename;\n}",
          "includes": [
            "#include \"gcov.h\"",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"gcov.h\"\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n\nconst char *gcov_info_filename(struct gcov_info *info)\n{\n\treturn info->filename;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_node_info",
          "args": [
            "node"
          ],
          "line": 490
        },
        "resolved": true,
        "details": {
          "function_name": "get_node_info",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/gcov/fs.c",
          "lines": "255-261",
          "snippet": "static struct gcov_info *get_node_info(struct gcov_node *node)\n{\n\tif (node->num_loaded > 0)\n\t\treturn node->loaded_info[0];\n\n\treturn node->unloaded_info;\n}",
          "includes": [
            "#include \"gcov.h\"",
            "#include <linux/mm.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void remove_node(struct gcov_node *node);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"gcov.h\"\n#include <linux/mm.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic void remove_node(struct gcov_node *node);\n\nstatic struct gcov_info *get_node_info(struct gcov_node *node)\n{\n\tif (node->num_loaded > 0)\n\t\treturn node->loaded_info[0];\n\n\treturn node->unloaded_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kcalloc",
          "args": [
            "num",
            "sizeof(struct dentry *)",
            "GFP_KERNEL"
          ],
          "line": 485
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"gcov.h\"\n#include <linux/mm.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic void remove_node(struct gcov_node *node);\n\nstatic void add_links(struct gcov_node *node, struct dentry *parent)\n{\n\tconst char *basename;\n\tchar *target;\n\tint num;\n\tint i;\n\n\tfor (num = 0; gcov_link[num].ext; num++)\n\t\t/* Nothing. */;\n\tnode->links = kcalloc(num, sizeof(struct dentry *), GFP_KERNEL);\n\tif (!node->links)\n\t\treturn;\n\tfor (i = 0; i < num; i++) {\n\t\ttarget = get_link_target(\n\t\t\t\tgcov_info_filename(get_node_info(node)),\n\t\t\t\t&gcov_link[i]);\n\t\tif (!target)\n\t\t\tgoto out_err;\n\t\tbasename = kbasename(target);\n\t\tif (basename == target)\n\t\t\tgoto out_err;\n\t\tnode->links[i] = debugfs_create_symlink(deskew(basename),\n\t\t\t\t\t\t\tparent,\ttarget);\n\t\tkfree(target);\n\t}\n\n\treturn;\nout_err:\n\tkfree(target);\n\twhile (i-- > 0)\n\t\tdebugfs_remove(node->links[i]);\n\tkfree(node->links);\n\tnode->links = NULL;\n}"
  },
  {
    "function_name": "deskew",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/gcov/fs.c",
    "lines": "465-470",
    "snippet": "static const char *deskew(const char *basename)\n{\n\tif (strncmp(basename, SKEW_PREFIX, sizeof(SKEW_PREFIX) - 1) == 0)\n\t\treturn basename + sizeof(SKEW_PREFIX) - 1;\n\treturn basename;\n}",
    "includes": [
      "#include \"gcov.h\"",
      "#include <linux/mm.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/string.h>",
      "#include <linux/list.h>",
      "#include <linux/fs.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [
      "#define SKEW_PREFIX\t\".tmp_\""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "basename",
            "SKEW_PREFIX",
            "sizeof(SKEW_PREFIX) - 1"
          ],
          "line": 467
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"gcov.h\"\n#include <linux/mm.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\n#define SKEW_PREFIX\t\".tmp_\"\n\nstatic const char *deskew(const char *basename)\n{\n\tif (strncmp(basename, SKEW_PREFIX, sizeof(SKEW_PREFIX) - 1) == 0)\n\t\treturn basename + sizeof(SKEW_PREFIX) - 1;\n\treturn basename;\n}"
  },
  {
    "function_name": "get_link_target",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/gcov/fs.c",
    "lines": "440-457",
    "snippet": "static char *get_link_target(const char *filename, const struct gcov_link *ext)\n{\n\tconst char *rel;\n\tchar *result;\n\n\tif (strncmp(filename, objtree, strlen(objtree)) == 0) {\n\t\trel = filename + strlen(objtree) + 1;\n\t\tif (ext->dir == SRC_TREE)\n\t\t\tresult = link_target(srctree, rel, ext->ext);\n\t\telse\n\t\t\tresult = link_target(objtree, rel, ext->ext);\n\t} else {\n\t\t/* External compilation. */\n\t\tresult = link_target(NULL, filename, ext->ext);\n\t}\n\n\treturn result;\n}",
    "includes": [
      "#include \"gcov.h\"",
      "#include <linux/mm.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/string.h>",
      "#include <linux/list.h>",
      "#include <linux/fs.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const char objtree[] = OBJTREE;",
      "static const char srctree[] = SRCTREE;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "link_target",
          "args": [
            "NULL",
            "filename",
            "ext->ext"
          ],
          "line": 453
        },
        "resolved": true,
        "details": {
          "function_name": "link_target",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/gcov/fs.c",
          "lines": "413-432",
          "snippet": "static char *link_target(const char *dir, const char *path, const char *ext)\n{\n\tchar *target;\n\tchar *old_ext;\n\tchar *copy;\n\n\tcopy = kstrdup(path, GFP_KERNEL);\n\tif (!copy)\n\t\treturn NULL;\n\told_ext = strrchr(copy, '.');\n\tif (old_ext)\n\t\t*old_ext = '\\0';\n\tif (dir)\n\t\ttarget = kasprintf(GFP_KERNEL, \"%s/%s.%s\", dir, copy, ext);\n\telse\n\t\ttarget = kasprintf(GFP_KERNEL, \"%s.%s\", copy, ext);\n\tkfree(copy);\n\n\treturn target;\n}",
          "includes": [
            "#include \"gcov.h\"",
            "#include <linux/mm.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"gcov.h\"\n#include <linux/mm.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic char *link_target(const char *dir, const char *path, const char *ext)\n{\n\tchar *target;\n\tchar *old_ext;\n\tchar *copy;\n\n\tcopy = kstrdup(path, GFP_KERNEL);\n\tif (!copy)\n\t\treturn NULL;\n\told_ext = strrchr(copy, '.');\n\tif (old_ext)\n\t\t*old_ext = '\\0';\n\tif (dir)\n\t\ttarget = kasprintf(GFP_KERNEL, \"%s/%s.%s\", dir, copy, ext);\n\telse\n\t\ttarget = kasprintf(GFP_KERNEL, \"%s.%s\", copy, ext);\n\tkfree(copy);\n\n\treturn target;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "objtree"
          ],
          "line": 446
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_eprobe.c",
          "lines": "384-401",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/ftrace.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "filename",
            "objtree",
            "strlen(objtree)"
          ],
          "line": 445
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"gcov.h\"\n#include <linux/mm.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic const char objtree[] = OBJTREE;\nstatic const char srctree[] = SRCTREE;\n\nstatic char *get_link_target(const char *filename, const struct gcov_link *ext)\n{\n\tconst char *rel;\n\tchar *result;\n\n\tif (strncmp(filename, objtree, strlen(objtree)) == 0) {\n\t\trel = filename + strlen(objtree) + 1;\n\t\tif (ext->dir == SRC_TREE)\n\t\t\tresult = link_target(srctree, rel, ext->ext);\n\t\telse\n\t\t\tresult = link_target(objtree, rel, ext->ext);\n\t} else {\n\t\t/* External compilation. */\n\t\tresult = link_target(NULL, filename, ext->ext);\n\t}\n\n\treturn result;\n}"
  },
  {
    "function_name": "link_target",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/gcov/fs.c",
    "lines": "413-432",
    "snippet": "static char *link_target(const char *dir, const char *path, const char *ext)\n{\n\tchar *target;\n\tchar *old_ext;\n\tchar *copy;\n\n\tcopy = kstrdup(path, GFP_KERNEL);\n\tif (!copy)\n\t\treturn NULL;\n\told_ext = strrchr(copy, '.');\n\tif (old_ext)\n\t\t*old_ext = '\\0';\n\tif (dir)\n\t\ttarget = kasprintf(GFP_KERNEL, \"%s/%s.%s\", dir, copy, ext);\n\telse\n\t\ttarget = kasprintf(GFP_KERNEL, \"%s.%s\", copy, ext);\n\tkfree(copy);\n\n\treturn target;\n}",
    "includes": [
      "#include \"gcov.h\"",
      "#include <linux/mm.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/string.h>",
      "#include <linux/list.h>",
      "#include <linux/fs.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "copy"
          ],
          "line": 429
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kasprintf",
          "args": [
            "GFP_KERNEL",
            "\"%s.%s\"",
            "copy",
            "ext"
          ],
          "line": 428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kasprintf",
          "args": [
            "GFP_KERNEL",
            "\"%s/%s.%s\"",
            "dir",
            "copy",
            "ext"
          ],
          "line": 426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strrchr",
          "args": [
            "copy",
            "'.'"
          ],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "path",
            "GFP_KERNEL"
          ],
          "line": 419
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"gcov.h\"\n#include <linux/mm.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic char *link_target(const char *dir, const char *path, const char *ext)\n{\n\tchar *target;\n\tchar *old_ext;\n\tchar *copy;\n\n\tcopy = kstrdup(path, GFP_KERNEL);\n\tif (!copy)\n\t\treturn NULL;\n\told_ext = strrchr(copy, '.');\n\tif (old_ext)\n\t\t*old_ext = '\\0';\n\tif (dir)\n\t\ttarget = kasprintf(GFP_KERNEL, \"%s/%s.%s\", dir, copy, ext);\n\telse\n\t\ttarget = kasprintf(GFP_KERNEL, \"%s.%s\", copy, ext);\n\tkfree(copy);\n\n\treturn target;\n}"
  },
  {
    "function_name": "gcov_seq_write",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/gcov/fs.c",
    "lines": "382-405",
    "snippet": "static ssize_t gcov_seq_write(struct file *file, const char __user *addr,\n\t\t\t      size_t len, loff_t *pos)\n{\n\tstruct seq_file *seq;\n\tstruct gcov_info *info;\n\tstruct gcov_node *node;\n\n\tseq = file->private_data;\n\tinfo = gcov_iter_get_info(seq->private);\n\tmutex_lock(&node_lock);\n\tnode = get_node_by_name(gcov_info_filename(info));\n\tif (node) {\n\t\t/* Reset counts or remove node for unloaded modules. */\n\t\tif (node->num_loaded == 0)\n\t\t\tremove_node(node);\n\t\telse\n\t\t\treset_node(node);\n\t}\n\t/* Reset counts for open file. */\n\tgcov_info_reset(info);\n\tmutex_unlock(&node_lock);\n\n\treturn len;\n}",
    "includes": [
      "#include \"gcov.h\"",
      "#include <linux/mm.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/string.h>",
      "#include <linux/list.h>",
      "#include <linux/fs.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(node_lock);",
      "static void remove_node(struct gcov_node *node);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&node_lock"
          ],
          "line": 402
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gcov_info_reset",
          "args": [
            "info"
          ],
          "line": 401
        },
        "resolved": true,
        "details": {
          "function_name": "gcov_info_reset",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/gcov/gcc_4_7.c",
          "lines": "195-213",
          "snippet": "void gcov_info_reset(struct gcov_info *info)\n{\n\tstruct gcov_ctr_info *ci_ptr;\n\tunsigned int fi_idx;\n\tunsigned int ct_idx;\n\n\tfor (fi_idx = 0; fi_idx < info->n_functions; fi_idx++) {\n\t\tci_ptr = info->functions[fi_idx]->ctrs;\n\n\t\tfor (ct_idx = 0; ct_idx < GCOV_COUNTERS; ct_idx++) {\n\t\t\tif (!counter_active(info, ct_idx))\n\t\t\t\tcontinue;\n\n\t\t\tmemset(ci_ptr->values, 0,\n\t\t\t\t\tsizeof(gcov_type) * ci_ptr->num);\n\t\t\tci_ptr++;\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"gcov.h\"",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [
            "#define GCOV_COUNTERS\t\t\t9",
            "#define GCOV_COUNTERS\t\t\t10",
            "#define GCOV_COUNTERS\t\t\t9",
            "#define GCOV_COUNTERS\t\t\t8"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"gcov.h\"\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n\n#define GCOV_COUNTERS\t\t\t9\n#define GCOV_COUNTERS\t\t\t10\n#define GCOV_COUNTERS\t\t\t9\n#define GCOV_COUNTERS\t\t\t8\n\nvoid gcov_info_reset(struct gcov_info *info)\n{\n\tstruct gcov_ctr_info *ci_ptr;\n\tunsigned int fi_idx;\n\tunsigned int ct_idx;\n\n\tfor (fi_idx = 0; fi_idx < info->n_functions; fi_idx++) {\n\t\tci_ptr = info->functions[fi_idx]->ctrs;\n\n\t\tfor (ct_idx = 0; ct_idx < GCOV_COUNTERS; ct_idx++) {\n\t\t\tif (!counter_active(info, ct_idx))\n\t\t\t\tcontinue;\n\n\t\t\tmemset(ci_ptr->values, 0,\n\t\t\t\t\tsizeof(gcov_type) * ci_ptr->num);\n\t\t\tci_ptr++;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "reset_node",
          "args": [
            "node"
          ],
          "line": 398
        },
        "resolved": true,
        "details": {
          "function_name": "reset_node",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/gcov/fs.c",
          "lines": "365-373",
          "snippet": "static void reset_node(struct gcov_node *node)\n{\n\tint i;\n\n\tif (node->unloaded_info)\n\t\tgcov_info_reset(node->unloaded_info);\n\tfor (i = 0; i < node->num_loaded; i++)\n\t\tgcov_info_reset(node->loaded_info[i]);\n}",
          "includes": [
            "#include \"gcov.h\"",
            "#include <linux/mm.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void remove_node(struct gcov_node *node);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"gcov.h\"\n#include <linux/mm.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic void remove_node(struct gcov_node *node);\n\nstatic void reset_node(struct gcov_node *node)\n{\n\tint i;\n\n\tif (node->unloaded_info)\n\t\tgcov_info_reset(node->unloaded_info);\n\tfor (i = 0; i < node->num_loaded; i++)\n\t\tgcov_info_reset(node->loaded_info[i]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "remove_node",
          "args": [
            "node"
          ],
          "line": 396
        },
        "resolved": true,
        "details": {
          "function_name": "remove_node",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/gcov/fs.c",
          "lines": "603-612",
          "snippet": "static void remove_node(struct gcov_node *node)\n{\n\tstruct gcov_node *parent;\n\n\twhile ((node != &root_node) && list_empty(&node->children)) {\n\t\tparent = node->parent;\n\t\trelease_node(node);\n\t\tnode = parent;\n\t}\n}",
          "includes": [
            "#include \"gcov.h\"",
            "#include <linux/mm.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct gcov_node root_node;",
            "static void remove_node(struct gcov_node *node);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"gcov.h\"\n#include <linux/mm.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic struct gcov_node root_node;\nstatic void remove_node(struct gcov_node *node);\n\nstatic void remove_node(struct gcov_node *node)\n{\n\tstruct gcov_node *parent;\n\n\twhile ((node != &root_node) && list_empty(&node->children)) {\n\t\tparent = node->parent;\n\t\trelease_node(node);\n\t\tnode = parent;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_node_by_name",
          "args": [
            "gcov_info_filename(info)"
          ],
          "line": 392
        },
        "resolved": true,
        "details": {
          "function_name": "get_node_by_name",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/gcov/fs.c",
          "lines": "348-360",
          "snippet": "static struct gcov_node *get_node_by_name(const char *name)\n{\n\tstruct gcov_node *node;\n\tstruct gcov_info *info;\n\n\tlist_for_each_entry(node, &all_head, all) {\n\t\tinfo = get_node_info(node);\n\t\tif (info && (strcmp(gcov_info_filename(info), name) == 0))\n\t\t\treturn node;\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"gcov.h\"",
            "#include <linux/mm.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(all_head);",
            "static void remove_node(struct gcov_node *node);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"gcov.h\"\n#include <linux/mm.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic LIST_HEAD(all_head);\nstatic void remove_node(struct gcov_node *node);\n\nstatic struct gcov_node *get_node_by_name(const char *name)\n{\n\tstruct gcov_node *node;\n\tstruct gcov_info *info;\n\n\tlist_for_each_entry(node, &all_head, all) {\n\t\tinfo = get_node_info(node);\n\t\tif (info && (strcmp(gcov_info_filename(info), name) == 0))\n\t\t\treturn node;\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gcov_info_filename",
          "args": [
            "info"
          ],
          "line": 392
        },
        "resolved": true,
        "details": {
          "function_name": "gcov_info_filename",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/gcov/gcc_4_7.c",
          "lines": "100-103",
          "snippet": "const char *gcov_info_filename(struct gcov_info *info)\n{\n\treturn info->filename;\n}",
          "includes": [
            "#include \"gcov.h\"",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"gcov.h\"\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n\nconst char *gcov_info_filename(struct gcov_info *info)\n{\n\treturn info->filename;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&node_lock"
          ],
          "line": 391
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gcov_iter_get_info",
          "args": [
            "seq->private"
          ],
          "line": 390
        },
        "resolved": true,
        "details": {
          "function_name": "gcov_iter_get_info",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/gcov/fs.c",
          "lines": "144-147",
          "snippet": "static struct gcov_info *gcov_iter_get_info(struct gcov_iterator *iter)\n{\n\treturn iter->info;\n}",
          "includes": [
            "#include \"gcov.h\"",
            "#include <linux/mm.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"gcov.h\"\n#include <linux/mm.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic struct gcov_info *gcov_iter_get_info(struct gcov_iterator *iter)\n{\n\treturn iter->info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"gcov.h\"\n#include <linux/mm.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic DEFINE_MUTEX(node_lock);\nstatic void remove_node(struct gcov_node *node);\n\nstatic ssize_t gcov_seq_write(struct file *file, const char __user *addr,\n\t\t\t      size_t len, loff_t *pos)\n{\n\tstruct seq_file *seq;\n\tstruct gcov_info *info;\n\tstruct gcov_node *node;\n\n\tseq = file->private_data;\n\tinfo = gcov_iter_get_info(seq->private);\n\tmutex_lock(&node_lock);\n\tnode = get_node_by_name(gcov_info_filename(info));\n\tif (node) {\n\t\t/* Reset counts or remove node for unloaded modules. */\n\t\tif (node->num_loaded == 0)\n\t\t\tremove_node(node);\n\t\telse\n\t\t\treset_node(node);\n\t}\n\t/* Reset counts for open file. */\n\tgcov_info_reset(info);\n\tmutex_unlock(&node_lock);\n\n\treturn len;\n}"
  },
  {
    "function_name": "reset_node",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/gcov/fs.c",
    "lines": "365-373",
    "snippet": "static void reset_node(struct gcov_node *node)\n{\n\tint i;\n\n\tif (node->unloaded_info)\n\t\tgcov_info_reset(node->unloaded_info);\n\tfor (i = 0; i < node->num_loaded; i++)\n\t\tgcov_info_reset(node->loaded_info[i]);\n}",
    "includes": [
      "#include \"gcov.h\"",
      "#include <linux/mm.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/string.h>",
      "#include <linux/list.h>",
      "#include <linux/fs.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void remove_node(struct gcov_node *node);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "gcov_info_reset",
          "args": [
            "node->loaded_info[i]"
          ],
          "line": 372
        },
        "resolved": true,
        "details": {
          "function_name": "gcov_info_reset",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/gcov/gcc_4_7.c",
          "lines": "195-213",
          "snippet": "void gcov_info_reset(struct gcov_info *info)\n{\n\tstruct gcov_ctr_info *ci_ptr;\n\tunsigned int fi_idx;\n\tunsigned int ct_idx;\n\n\tfor (fi_idx = 0; fi_idx < info->n_functions; fi_idx++) {\n\t\tci_ptr = info->functions[fi_idx]->ctrs;\n\n\t\tfor (ct_idx = 0; ct_idx < GCOV_COUNTERS; ct_idx++) {\n\t\t\tif (!counter_active(info, ct_idx))\n\t\t\t\tcontinue;\n\n\t\t\tmemset(ci_ptr->values, 0,\n\t\t\t\t\tsizeof(gcov_type) * ci_ptr->num);\n\t\t\tci_ptr++;\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"gcov.h\"",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [
            "#define GCOV_COUNTERS\t\t\t9",
            "#define GCOV_COUNTERS\t\t\t10",
            "#define GCOV_COUNTERS\t\t\t9",
            "#define GCOV_COUNTERS\t\t\t8"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"gcov.h\"\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n\n#define GCOV_COUNTERS\t\t\t9\n#define GCOV_COUNTERS\t\t\t10\n#define GCOV_COUNTERS\t\t\t9\n#define GCOV_COUNTERS\t\t\t8\n\nvoid gcov_info_reset(struct gcov_info *info)\n{\n\tstruct gcov_ctr_info *ci_ptr;\n\tunsigned int fi_idx;\n\tunsigned int ct_idx;\n\n\tfor (fi_idx = 0; fi_idx < info->n_functions; fi_idx++) {\n\t\tci_ptr = info->functions[fi_idx]->ctrs;\n\n\t\tfor (ct_idx = 0; ct_idx < GCOV_COUNTERS; ct_idx++) {\n\t\t\tif (!counter_active(info, ct_idx))\n\t\t\t\tcontinue;\n\n\t\t\tmemset(ci_ptr->values, 0,\n\t\t\t\t\tsizeof(gcov_type) * ci_ptr->num);\n\t\t\tci_ptr++;\n\t\t}\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"gcov.h\"\n#include <linux/mm.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic void remove_node(struct gcov_node *node);\n\nstatic void reset_node(struct gcov_node *node)\n{\n\tint i;\n\n\tif (node->unloaded_info)\n\t\tgcov_info_reset(node->unloaded_info);\n\tfor (i = 0; i < node->num_loaded; i++)\n\t\tgcov_info_reset(node->loaded_info[i]);\n}"
  },
  {
    "function_name": "get_node_by_name",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/gcov/fs.c",
    "lines": "348-360",
    "snippet": "static struct gcov_node *get_node_by_name(const char *name)\n{\n\tstruct gcov_node *node;\n\tstruct gcov_info *info;\n\n\tlist_for_each_entry(node, &all_head, all) {\n\t\tinfo = get_node_info(node);\n\t\tif (info && (strcmp(gcov_info_filename(info), name) == 0))\n\t\t\treturn node;\n\t}\n\n\treturn NULL;\n}",
    "includes": [
      "#include \"gcov.h\"",
      "#include <linux/mm.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/string.h>",
      "#include <linux/list.h>",
      "#include <linux/fs.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(all_head);",
      "static void remove_node(struct gcov_node *node);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "gcov_info_filename(info)",
            "name"
          ],
          "line": 355
        },
        "resolved": true,
        "details": {
          "function_name": "sym_strcmp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/report.c",
          "lines": "356-365",
          "snippet": "static int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}",
          "includes": [
            "#include \"encoding.h\"",
            "#include \"kcsan.h\"",
            "#include <linux/stacktrace.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/delay.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"encoding.h\"\n#include \"kcsan.h\"\n#include <linux/stacktrace.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/lockdep.h>\n#include <linux/kernel.h>\n#include <linux/kallsyms.h>\n#include <linux/jiffies.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n\nstatic int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}"
        }
      },
      {
        "call_info": {
          "callee": "gcov_info_filename",
          "args": [
            "info"
          ],
          "line": 355
        },
        "resolved": true,
        "details": {
          "function_name": "gcov_info_filename",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/gcov/gcc_4_7.c",
          "lines": "100-103",
          "snippet": "const char *gcov_info_filename(struct gcov_info *info)\n{\n\treturn info->filename;\n}",
          "includes": [
            "#include \"gcov.h\"",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"gcov.h\"\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n\nconst char *gcov_info_filename(struct gcov_info *info)\n{\n\treturn info->filename;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_node_info",
          "args": [
            "node"
          ],
          "line": 354
        },
        "resolved": true,
        "details": {
          "function_name": "get_node_info",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/gcov/fs.c",
          "lines": "255-261",
          "snippet": "static struct gcov_info *get_node_info(struct gcov_node *node)\n{\n\tif (node->num_loaded > 0)\n\t\treturn node->loaded_info[0];\n\n\treturn node->unloaded_info;\n}",
          "includes": [
            "#include \"gcov.h\"",
            "#include <linux/mm.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void remove_node(struct gcov_node *node);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"gcov.h\"\n#include <linux/mm.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic void remove_node(struct gcov_node *node);\n\nstatic struct gcov_info *get_node_info(struct gcov_node *node)\n{\n\tif (node->num_loaded > 0)\n\t\treturn node->loaded_info[0];\n\n\treturn node->unloaded_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "node",
            "&all_head",
            "all"
          ],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"gcov.h\"\n#include <linux/mm.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic LIST_HEAD(all_head);\nstatic void remove_node(struct gcov_node *node);\n\nstatic struct gcov_node *get_node_by_name(const char *name)\n{\n\tstruct gcov_node *node;\n\tstruct gcov_info *info;\n\n\tlist_for_each_entry(node, &all_head, all) {\n\t\tinfo = get_node_info(node);\n\t\tif (info && (strcmp(gcov_info_filename(info), name) == 0))\n\t\t\treturn node;\n\t}\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "gcov_seq_release",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/gcov/fs.c",
    "lines": "328-342",
    "snippet": "static int gcov_seq_release(struct inode *inode, struct file *file)\n{\n\tstruct gcov_iterator *iter;\n\tstruct gcov_info *info;\n\tstruct seq_file *seq;\n\n\tseq = file->private_data;\n\titer = seq->private;\n\tinfo = gcov_iter_get_info(iter);\n\tgcov_iter_free(iter);\n\tgcov_info_free(info);\n\tseq_release(inode, file);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"gcov.h\"",
      "#include <linux/mm.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/string.h>",
      "#include <linux/list.h>",
      "#include <linux/fs.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_release",
          "args": [
            "inode",
            "file"
          ],
          "line": 339
        },
        "resolved": true,
        "details": {
          "function_name": "gcov_seq_release",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/gcov/fs.c",
          "lines": "328-342",
          "snippet": "static int gcov_seq_release(struct inode *inode, struct file *file)\n{\n\tstruct gcov_iterator *iter;\n\tstruct gcov_info *info;\n\tstruct seq_file *seq;\n\n\tseq = file->private_data;\n\titer = seq->private;\n\tinfo = gcov_iter_get_info(iter);\n\tgcov_iter_free(iter);\n\tgcov_info_free(info);\n\tseq_release(inode, file);\n\n\treturn 0;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "gcov_info_free",
          "args": [
            "info"
          ],
          "line": 338
        },
        "resolved": true,
        "details": {
          "function_name": "gcov_info_free",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/gcov/gcc_4_7.c",
          "lines": "335-363",
          "snippet": "void gcov_info_free(struct gcov_info *info)\n{\n\tunsigned int active;\n\tunsigned int fi_idx;\n\tunsigned int ct_idx;\n\tstruct gcov_ctr_info *ci_ptr;\n\n\tif (!info->functions)\n\t\tgoto free_info;\n\n\tactive = num_counter_active(info);\n\n\tfor (fi_idx = 0; fi_idx < info->n_functions; fi_idx++) {\n\t\tif (!info->functions[fi_idx])\n\t\t\tcontinue;\n\n\t\tci_ptr = info->functions[fi_idx]->ctrs;\n\n\t\tfor (ct_idx = 0; ct_idx < active; ct_idx++, ci_ptr++)\n\t\t\tkvfree(ci_ptr->values);\n\n\t\tkfree(info->functions[fi_idx]);\n\t}\n\nfree_info:\n\tkfree(info->functions);\n\tkfree(info->filename);\n\tkfree(info);\n}",
          "includes": [
            "#include \"gcov.h\"",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"gcov.h\"\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n\nvoid gcov_info_free(struct gcov_info *info)\n{\n\tunsigned int active;\n\tunsigned int fi_idx;\n\tunsigned int ct_idx;\n\tstruct gcov_ctr_info *ci_ptr;\n\n\tif (!info->functions)\n\t\tgoto free_info;\n\n\tactive = num_counter_active(info);\n\n\tfor (fi_idx = 0; fi_idx < info->n_functions; fi_idx++) {\n\t\tif (!info->functions[fi_idx])\n\t\t\tcontinue;\n\n\t\tci_ptr = info->functions[fi_idx]->ctrs;\n\n\t\tfor (ct_idx = 0; ct_idx < active; ct_idx++, ci_ptr++)\n\t\t\tkvfree(ci_ptr->values);\n\n\t\tkfree(info->functions[fi_idx]);\n\t}\n\nfree_info:\n\tkfree(info->functions);\n\tkfree(info->filename);\n\tkfree(info);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gcov_iter_free",
          "args": [
            "iter"
          ],
          "line": 337
        },
        "resolved": true,
        "details": {
          "function_name": "gcov_iter_free",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/gcov/fs.c",
          "lines": "135-138",
          "snippet": "static void gcov_iter_free(struct gcov_iterator *iter)\n{\n\tkvfree(iter);\n}",
          "includes": [
            "#include \"gcov.h\"",
            "#include <linux/mm.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"gcov.h\"\n#include <linux/mm.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic void gcov_iter_free(struct gcov_iterator *iter)\n{\n\tkvfree(iter);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gcov_iter_get_info",
          "args": [
            "iter"
          ],
          "line": 336
        },
        "resolved": true,
        "details": {
          "function_name": "gcov_iter_get_info",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/gcov/fs.c",
          "lines": "144-147",
          "snippet": "static struct gcov_info *gcov_iter_get_info(struct gcov_iterator *iter)\n{\n\treturn iter->info;\n}",
          "includes": [
            "#include \"gcov.h\"",
            "#include <linux/mm.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"gcov.h\"\n#include <linux/mm.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic struct gcov_info *gcov_iter_get_info(struct gcov_iterator *iter)\n{\n\treturn iter->info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"gcov.h\"\n#include <linux/mm.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic int gcov_seq_release(struct inode *inode, struct file *file)\n{\n\tstruct gcov_iterator *iter;\n\tstruct gcov_info *info;\n\tstruct seq_file *seq;\n\n\tseq = file->private_data;\n\titer = seq->private;\n\tinfo = gcov_iter_get_info(iter);\n\tgcov_iter_free(iter);\n\tgcov_info_free(info);\n\tseq_release(inode, file);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "gcov_seq_open",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/gcov/fs.c",
    "lines": "288-322",
    "snippet": "static int gcov_seq_open(struct inode *inode, struct file *file)\n{\n\tstruct gcov_node *node = inode->i_private;\n\tstruct gcov_iterator *iter;\n\tstruct seq_file *seq;\n\tstruct gcov_info *info;\n\tint rc = -ENOMEM;\n\n\tmutex_lock(&node_lock);\n\t/*\n\t * Read from a profiling data copy to minimize reference tracking\n\t * complexity and concurrent access and to keep accumulating multiple\n\t * profiling data sets associated with one node simple.\n\t */\n\tinfo = get_accumulated_info(node);\n\tif (!info)\n\t\tgoto out_unlock;\n\titer = gcov_iter_new(info);\n\tif (!iter)\n\t\tgoto err_free_info;\n\trc = seq_open(file, &gcov_seq_ops);\n\tif (rc)\n\t\tgoto err_free_iter_info;\n\tseq = file->private_data;\n\tseq->private = iter;\nout_unlock:\n\tmutex_unlock(&node_lock);\n\treturn rc;\n\nerr_free_iter_info:\n\tgcov_iter_free(iter);\nerr_free_info:\n\tgcov_info_free(info);\n\tgoto out_unlock;\n}",
    "includes": [
      "#include \"gcov.h\"",
      "#include <linux/mm.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/string.h>",
      "#include <linux/list.h>",
      "#include <linux/fs.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(node_lock);",
      "static const struct seq_operations gcov_seq_ops = {\n\t.start\t= gcov_seq_start,\n\t.next\t= gcov_seq_next,\n\t.show\t= gcov_seq_show,\n\t.stop\t= gcov_seq_stop,\n};",
      "static void remove_node(struct gcov_node *node);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "gcov_info_free",
          "args": [
            "info"
          ],
          "line": 320
        },
        "resolved": true,
        "details": {
          "function_name": "gcov_info_free",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/gcov/gcc_4_7.c",
          "lines": "335-363",
          "snippet": "void gcov_info_free(struct gcov_info *info)\n{\n\tunsigned int active;\n\tunsigned int fi_idx;\n\tunsigned int ct_idx;\n\tstruct gcov_ctr_info *ci_ptr;\n\n\tif (!info->functions)\n\t\tgoto free_info;\n\n\tactive = num_counter_active(info);\n\n\tfor (fi_idx = 0; fi_idx < info->n_functions; fi_idx++) {\n\t\tif (!info->functions[fi_idx])\n\t\t\tcontinue;\n\n\t\tci_ptr = info->functions[fi_idx]->ctrs;\n\n\t\tfor (ct_idx = 0; ct_idx < active; ct_idx++, ci_ptr++)\n\t\t\tkvfree(ci_ptr->values);\n\n\t\tkfree(info->functions[fi_idx]);\n\t}\n\nfree_info:\n\tkfree(info->functions);\n\tkfree(info->filename);\n\tkfree(info);\n}",
          "includes": [
            "#include \"gcov.h\"",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"gcov.h\"\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n\nvoid gcov_info_free(struct gcov_info *info)\n{\n\tunsigned int active;\n\tunsigned int fi_idx;\n\tunsigned int ct_idx;\n\tstruct gcov_ctr_info *ci_ptr;\n\n\tif (!info->functions)\n\t\tgoto free_info;\n\n\tactive = num_counter_active(info);\n\n\tfor (fi_idx = 0; fi_idx < info->n_functions; fi_idx++) {\n\t\tif (!info->functions[fi_idx])\n\t\t\tcontinue;\n\n\t\tci_ptr = info->functions[fi_idx]->ctrs;\n\n\t\tfor (ct_idx = 0; ct_idx < active; ct_idx++, ci_ptr++)\n\t\t\tkvfree(ci_ptr->values);\n\n\t\tkfree(info->functions[fi_idx]);\n\t}\n\nfree_info:\n\tkfree(info->functions);\n\tkfree(info->filename);\n\tkfree(info);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gcov_iter_free",
          "args": [
            "iter"
          ],
          "line": 318
        },
        "resolved": true,
        "details": {
          "function_name": "gcov_iter_free",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/gcov/fs.c",
          "lines": "135-138",
          "snippet": "static void gcov_iter_free(struct gcov_iterator *iter)\n{\n\tkvfree(iter);\n}",
          "includes": [
            "#include \"gcov.h\"",
            "#include <linux/mm.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"gcov.h\"\n#include <linux/mm.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic void gcov_iter_free(struct gcov_iterator *iter)\n{\n\tkvfree(iter);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&node_lock"
          ],
          "line": 314
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_open",
          "args": [
            "file",
            "&gcov_seq_ops"
          ],
          "line": 308
        },
        "resolved": true,
        "details": {
          "function_name": "gcov_seq_open",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/gcov/fs.c",
          "lines": "288-322",
          "snippet": "static int gcov_seq_open(struct inode *inode, struct file *file)\n{\n\tstruct gcov_node *node = inode->i_private;\n\tstruct gcov_iterator *iter;\n\tstruct seq_file *seq;\n\tstruct gcov_info *info;\n\tint rc = -ENOMEM;\n\n\tmutex_lock(&node_lock);\n\t/*\n\t * Read from a profiling data copy to minimize reference tracking\n\t * complexity and concurrent access and to keep accumulating multiple\n\t * profiling data sets associated with one node simple.\n\t */\n\tinfo = get_accumulated_info(node);\n\tif (!info)\n\t\tgoto out_unlock;\n\titer = gcov_iter_new(info);\n\tif (!iter)\n\t\tgoto err_free_info;\n\trc = seq_open(file, &gcov_seq_ops);\n\tif (rc)\n\t\tgoto err_free_iter_info;\n\tseq = file->private_data;\n\tseq->private = iter;\nout_unlock:\n\tmutex_unlock(&node_lock);\n\treturn rc;\n\nerr_free_iter_info:\n\tgcov_iter_free(iter);\nerr_free_info:\n\tgcov_info_free(info);\n\tgoto out_unlock;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "gcov_iter_new",
          "args": [
            "info"
          ],
          "line": 305
        },
        "resolved": true,
        "details": {
          "function_name": "gcov_iter_new",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/gcov/fs.c",
          "lines": "111-128",
          "snippet": "static struct gcov_iterator *gcov_iter_new(struct gcov_info *info)\n{\n\tstruct gcov_iterator *iter;\n\tsize_t size;\n\n\t/* Dry-run to get the actual buffer size. */\n\tsize = convert_to_gcda(NULL, info);\n\n\titer = kvmalloc(struct_size(iter, buffer, size), GFP_KERNEL);\n\tif (!iter)\n\t\treturn NULL;\n\n\titer->info = info;\n\titer->size = size;\n\tconvert_to_gcda(iter->buffer, info);\n\n\treturn iter;\n}",
          "includes": [
            "#include \"gcov.h\"",
            "#include <linux/mm.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"gcov.h\"\n#include <linux/mm.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic struct gcov_iterator *gcov_iter_new(struct gcov_info *info)\n{\n\tstruct gcov_iterator *iter;\n\tsize_t size;\n\n\t/* Dry-run to get the actual buffer size. */\n\tsize = convert_to_gcda(NULL, info);\n\n\titer = kvmalloc(struct_size(iter, buffer, size), GFP_KERNEL);\n\tif (!iter)\n\t\treturn NULL;\n\n\titer->info = info;\n\titer->size = size;\n\tconvert_to_gcda(iter->buffer, info);\n\n\treturn iter;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_accumulated_info",
          "args": [
            "node"
          ],
          "line": 302
        },
        "resolved": true,
        "details": {
          "function_name": "get_accumulated_info",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/gcov/fs.c",
          "lines": "267-282",
          "snippet": "static struct gcov_info *get_accumulated_info(struct gcov_node *node)\n{\n\tstruct gcov_info *info;\n\tint i = 0;\n\n\tif (node->unloaded_info)\n\t\tinfo = gcov_info_dup(node->unloaded_info);\n\telse\n\t\tinfo = gcov_info_dup(node->loaded_info[i++]);\n\tif (!info)\n\t\treturn NULL;\n\tfor (; i < node->num_loaded; i++)\n\t\tgcov_info_add(info, node->loaded_info[i]);\n\n\treturn info;\n}",
          "includes": [
            "#include \"gcov.h\"",
            "#include <linux/mm.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void remove_node(struct gcov_node *node);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"gcov.h\"\n#include <linux/mm.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic void remove_node(struct gcov_node *node);\n\nstatic struct gcov_info *get_accumulated_info(struct gcov_node *node)\n{\n\tstruct gcov_info *info;\n\tint i = 0;\n\n\tif (node->unloaded_info)\n\t\tinfo = gcov_info_dup(node->unloaded_info);\n\telse\n\t\tinfo = gcov_info_dup(node->loaded_info[i++]);\n\tif (!info)\n\t\treturn NULL;\n\tfor (; i < node->num_loaded; i++)\n\t\tgcov_info_add(info, node->loaded_info[i]);\n\n\treturn info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&node_lock"
          ],
          "line": 296
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"gcov.h\"\n#include <linux/mm.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic DEFINE_MUTEX(node_lock);\nstatic const struct seq_operations gcov_seq_ops = {\n\t.start\t= gcov_seq_start,\n\t.next\t= gcov_seq_next,\n\t.show\t= gcov_seq_show,\n\t.stop\t= gcov_seq_stop,\n};\nstatic void remove_node(struct gcov_node *node);\n\nstatic int gcov_seq_open(struct inode *inode, struct file *file)\n{\n\tstruct gcov_node *node = inode->i_private;\n\tstruct gcov_iterator *iter;\n\tstruct seq_file *seq;\n\tstruct gcov_info *info;\n\tint rc = -ENOMEM;\n\n\tmutex_lock(&node_lock);\n\t/*\n\t * Read from a profiling data copy to minimize reference tracking\n\t * complexity and concurrent access and to keep accumulating multiple\n\t * profiling data sets associated with one node simple.\n\t */\n\tinfo = get_accumulated_info(node);\n\tif (!info)\n\t\tgoto out_unlock;\n\titer = gcov_iter_new(info);\n\tif (!iter)\n\t\tgoto err_free_info;\n\trc = seq_open(file, &gcov_seq_ops);\n\tif (rc)\n\t\tgoto err_free_iter_info;\n\tseq = file->private_data;\n\tseq->private = iter;\nout_unlock:\n\tmutex_unlock(&node_lock);\n\treturn rc;\n\nerr_free_iter_info:\n\tgcov_iter_free(iter);\nerr_free_info:\n\tgcov_info_free(info);\n\tgoto out_unlock;\n}"
  },
  {
    "function_name": "get_accumulated_info",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/gcov/fs.c",
    "lines": "267-282",
    "snippet": "static struct gcov_info *get_accumulated_info(struct gcov_node *node)\n{\n\tstruct gcov_info *info;\n\tint i = 0;\n\n\tif (node->unloaded_info)\n\t\tinfo = gcov_info_dup(node->unloaded_info);\n\telse\n\t\tinfo = gcov_info_dup(node->loaded_info[i++]);\n\tif (!info)\n\t\treturn NULL;\n\tfor (; i < node->num_loaded; i++)\n\t\tgcov_info_add(info, node->loaded_info[i]);\n\n\treturn info;\n}",
    "includes": [
      "#include \"gcov.h\"",
      "#include <linux/mm.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/string.h>",
      "#include <linux/list.h>",
      "#include <linux/fs.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void remove_node(struct gcov_node *node);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "gcov_info_add",
          "args": [
            "info",
            "node->loaded_info[i]"
          ],
          "line": 279
        },
        "resolved": true,
        "details": {
          "function_name": "gcov_info_add",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/gcov/gcc_4_7.c",
          "lines": "234-258",
          "snippet": "void gcov_info_add(struct gcov_info *dst, struct gcov_info *src)\n{\n\tstruct gcov_ctr_info *dci_ptr;\n\tstruct gcov_ctr_info *sci_ptr;\n\tunsigned int fi_idx;\n\tunsigned int ct_idx;\n\tunsigned int val_idx;\n\n\tfor (fi_idx = 0; fi_idx < src->n_functions; fi_idx++) {\n\t\tdci_ptr = dst->functions[fi_idx]->ctrs;\n\t\tsci_ptr = src->functions[fi_idx]->ctrs;\n\n\t\tfor (ct_idx = 0; ct_idx < GCOV_COUNTERS; ct_idx++) {\n\t\t\tif (!counter_active(src, ct_idx))\n\t\t\t\tcontinue;\n\n\t\t\tfor (val_idx = 0; val_idx < sci_ptr->num; val_idx++)\n\t\t\t\tdci_ptr->values[val_idx] +=\n\t\t\t\t\tsci_ptr->values[val_idx];\n\n\t\t\tdci_ptr++;\n\t\t\tsci_ptr++;\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"gcov.h\"",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [
            "#define GCOV_COUNTERS\t\t\t9",
            "#define GCOV_COUNTERS\t\t\t10",
            "#define GCOV_COUNTERS\t\t\t9",
            "#define GCOV_COUNTERS\t\t\t8"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"gcov.h\"\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n\n#define GCOV_COUNTERS\t\t\t9\n#define GCOV_COUNTERS\t\t\t10\n#define GCOV_COUNTERS\t\t\t9\n#define GCOV_COUNTERS\t\t\t8\n\nvoid gcov_info_add(struct gcov_info *dst, struct gcov_info *src)\n{\n\tstruct gcov_ctr_info *dci_ptr;\n\tstruct gcov_ctr_info *sci_ptr;\n\tunsigned int fi_idx;\n\tunsigned int ct_idx;\n\tunsigned int val_idx;\n\n\tfor (fi_idx = 0; fi_idx < src->n_functions; fi_idx++) {\n\t\tdci_ptr = dst->functions[fi_idx]->ctrs;\n\t\tsci_ptr = src->functions[fi_idx]->ctrs;\n\n\t\tfor (ct_idx = 0; ct_idx < GCOV_COUNTERS; ct_idx++) {\n\t\t\tif (!counter_active(src, ct_idx))\n\t\t\t\tcontinue;\n\n\t\t\tfor (val_idx = 0; val_idx < sci_ptr->num; val_idx++)\n\t\t\t\tdci_ptr->values[val_idx] +=\n\t\t\t\t\tsci_ptr->values[val_idx];\n\n\t\t\tdci_ptr++;\n\t\t\tsci_ptr++;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "gcov_info_dup",
          "args": [
            "node->loaded_info[i++]"
          ],
          "line": 275
        },
        "resolved": true,
        "details": {
          "function_name": "gcov_info_dup",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/gcov/gcc_4_7.c",
          "lines": "266-329",
          "snippet": "struct gcov_info *gcov_info_dup(struct gcov_info *info)\n{\n\tstruct gcov_info *dup;\n\tstruct gcov_ctr_info *dci_ptr; /* dst counter info */\n\tstruct gcov_ctr_info *sci_ptr; /* src counter info */\n\tunsigned int active;\n\tunsigned int fi_idx; /* function info idx */\n\tunsigned int ct_idx; /* counter type idx */\n\tsize_t fi_size; /* function info size */\n\tsize_t cv_size; /* counter values size */\n\n\tdup = kmemdup(info, sizeof(*dup), GFP_KERNEL);\n\tif (!dup)\n\t\treturn NULL;\n\n\tdup->next = NULL;\n\tdup->filename = NULL;\n\tdup->functions = NULL;\n\n\tdup->filename = kstrdup(info->filename, GFP_KERNEL);\n\tif (!dup->filename)\n\t\tgoto err_free;\n\n\tdup->functions = kcalloc(info->n_functions,\n\t\t\t\t sizeof(struct gcov_fn_info *), GFP_KERNEL);\n\tif (!dup->functions)\n\t\tgoto err_free;\n\n\tactive = num_counter_active(info);\n\tfi_size = sizeof(struct gcov_fn_info);\n\tfi_size += sizeof(struct gcov_ctr_info) * active;\n\n\tfor (fi_idx = 0; fi_idx < info->n_functions; fi_idx++) {\n\t\tdup->functions[fi_idx] = kzalloc(fi_size, GFP_KERNEL);\n\t\tif (!dup->functions[fi_idx])\n\t\t\tgoto err_free;\n\n\t\t*(dup->functions[fi_idx]) = *(info->functions[fi_idx]);\n\n\t\tsci_ptr = info->functions[fi_idx]->ctrs;\n\t\tdci_ptr = dup->functions[fi_idx]->ctrs;\n\n\t\tfor (ct_idx = 0; ct_idx < active; ct_idx++) {\n\n\t\t\tcv_size = sizeof(gcov_type) * sci_ptr->num;\n\n\t\t\tdci_ptr->values = kvmalloc(cv_size, GFP_KERNEL);\n\n\t\t\tif (!dci_ptr->values)\n\t\t\t\tgoto err_free;\n\n\t\t\tdci_ptr->num = sci_ptr->num;\n\t\t\tmemcpy(dci_ptr->values, sci_ptr->values, cv_size);\n\n\t\t\tsci_ptr++;\n\t\t\tdci_ptr++;\n\t\t}\n\t}\n\n\treturn dup;\nerr_free:\n\tgcov_info_free(dup);\n\treturn NULL;\n}",
          "includes": [
            "#include \"gcov.h\"",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"gcov.h\"\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n\nstruct gcov_info *gcov_info_dup(struct gcov_info *info)\n{\n\tstruct gcov_info *dup;\n\tstruct gcov_ctr_info *dci_ptr; /* dst counter info */\n\tstruct gcov_ctr_info *sci_ptr; /* src counter info */\n\tunsigned int active;\n\tunsigned int fi_idx; /* function info idx */\n\tunsigned int ct_idx; /* counter type idx */\n\tsize_t fi_size; /* function info size */\n\tsize_t cv_size; /* counter values size */\n\n\tdup = kmemdup(info, sizeof(*dup), GFP_KERNEL);\n\tif (!dup)\n\t\treturn NULL;\n\n\tdup->next = NULL;\n\tdup->filename = NULL;\n\tdup->functions = NULL;\n\n\tdup->filename = kstrdup(info->filename, GFP_KERNEL);\n\tif (!dup->filename)\n\t\tgoto err_free;\n\n\tdup->functions = kcalloc(info->n_functions,\n\t\t\t\t sizeof(struct gcov_fn_info *), GFP_KERNEL);\n\tif (!dup->functions)\n\t\tgoto err_free;\n\n\tactive = num_counter_active(info);\n\tfi_size = sizeof(struct gcov_fn_info);\n\tfi_size += sizeof(struct gcov_ctr_info) * active;\n\n\tfor (fi_idx = 0; fi_idx < info->n_functions; fi_idx++) {\n\t\tdup->functions[fi_idx] = kzalloc(fi_size, GFP_KERNEL);\n\t\tif (!dup->functions[fi_idx])\n\t\t\tgoto err_free;\n\n\t\t*(dup->functions[fi_idx]) = *(info->functions[fi_idx]);\n\n\t\tsci_ptr = info->functions[fi_idx]->ctrs;\n\t\tdci_ptr = dup->functions[fi_idx]->ctrs;\n\n\t\tfor (ct_idx = 0; ct_idx < active; ct_idx++) {\n\n\t\t\tcv_size = sizeof(gcov_type) * sci_ptr->num;\n\n\t\t\tdci_ptr->values = kvmalloc(cv_size, GFP_KERNEL);\n\n\t\t\tif (!dci_ptr->values)\n\t\t\t\tgoto err_free;\n\n\t\t\tdci_ptr->num = sci_ptr->num;\n\t\t\tmemcpy(dci_ptr->values, sci_ptr->values, cv_size);\n\n\t\t\tsci_ptr++;\n\t\t\tdci_ptr++;\n\t\t}\n\t}\n\n\treturn dup;\nerr_free:\n\tgcov_info_free(dup);\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"gcov.h\"\n#include <linux/mm.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic void remove_node(struct gcov_node *node);\n\nstatic struct gcov_info *get_accumulated_info(struct gcov_node *node)\n{\n\tstruct gcov_info *info;\n\tint i = 0;\n\n\tif (node->unloaded_info)\n\t\tinfo = gcov_info_dup(node->unloaded_info);\n\telse\n\t\tinfo = gcov_info_dup(node->loaded_info[i++]);\n\tif (!info)\n\t\treturn NULL;\n\tfor (; i < node->num_loaded; i++)\n\t\tgcov_info_add(info, node->loaded_info[i]);\n\n\treturn info;\n}"
  },
  {
    "function_name": "get_node_info",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/gcov/fs.c",
    "lines": "255-261",
    "snippet": "static struct gcov_info *get_node_info(struct gcov_node *node)\n{\n\tif (node->num_loaded > 0)\n\t\treturn node->loaded_info[0];\n\n\treturn node->unloaded_info;\n}",
    "includes": [
      "#include \"gcov.h\"",
      "#include <linux/mm.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/string.h>",
      "#include <linux/list.h>",
      "#include <linux/fs.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void remove_node(struct gcov_node *node);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"gcov.h\"\n#include <linux/mm.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic void remove_node(struct gcov_node *node);\n\nstatic struct gcov_info *get_node_info(struct gcov_node *node)\n{\n\tif (node->num_loaded > 0)\n\t\treturn node->loaded_info[0];\n\n\treturn node->unloaded_info;\n}"
  },
  {
    "function_name": "gcov_seq_stop",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/gcov/fs.c",
    "lines": "238-241",
    "snippet": "static void gcov_seq_stop(struct seq_file *seq, void *data)\n{\n\t/* Unused. */\n}",
    "includes": [
      "#include \"gcov.h\"",
      "#include <linux/mm.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/string.h>",
      "#include <linux/list.h>",
      "#include <linux/fs.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"gcov.h\"\n#include <linux/mm.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic void gcov_seq_stop(struct seq_file *seq, void *data)\n{\n\t/* Unused. */\n}"
  },
  {
    "function_name": "gcov_seq_show",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/gcov/fs.c",
    "lines": "229-236",
    "snippet": "static int gcov_seq_show(struct seq_file *seq, void *data)\n{\n\tstruct gcov_iterator *iter = data;\n\n\tif (gcov_iter_write(iter, seq))\n\t\treturn -EINVAL;\n\treturn 0;\n}",
    "includes": [
      "#include \"gcov.h\"",
      "#include <linux/mm.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/string.h>",
      "#include <linux/list.h>",
      "#include <linux/fs.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gcov_iter_write",
          "args": [
            "iter",
            "seq"
          ],
          "line": 233
        },
        "resolved": true,
        "details": {
          "function_name": "gcov_iter_write",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/gcov/fs.c",
          "lines": "182-196",
          "snippet": "static int gcov_iter_write(struct gcov_iterator *iter, struct seq_file *seq)\n{\n\tsize_t len;\n\n\tif (iter->pos >= iter->size)\n\t\treturn -EINVAL;\n\n\tlen = ITER_STRIDE;\n\tif (iter->pos + len > iter->size)\n\t\tlen = iter->size - iter->pos;\n\n\tseq_write(seq, iter->buffer + iter->pos, len);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"gcov.h\"",
            "#include <linux/mm.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [
            "#define ITER_STRIDE\tPAGE_SIZE"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"gcov.h\"\n#include <linux/mm.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\n#define ITER_STRIDE\tPAGE_SIZE\n\nstatic int gcov_iter_write(struct gcov_iterator *iter, struct seq_file *seq)\n{\n\tsize_t len;\n\n\tif (iter->pos >= iter->size)\n\t\treturn -EINVAL;\n\n\tlen = ITER_STRIDE;\n\tif (iter->pos + len > iter->size)\n\t\tlen = iter->size - iter->pos;\n\n\tseq_write(seq, iter->buffer + iter->pos, len);\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"gcov.h\"\n#include <linux/mm.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic int gcov_seq_show(struct seq_file *seq, void *data)\n{\n\tstruct gcov_iterator *iter = data;\n\n\tif (gcov_iter_write(iter, seq))\n\t\treturn -EINVAL;\n\treturn 0;\n}"
  },
  {
    "function_name": "gcov_seq_next",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/gcov/fs.c",
    "lines": "217-226",
    "snippet": "static void *gcov_seq_next(struct seq_file *seq, void *data, loff_t *pos)\n{\n\tstruct gcov_iterator *iter = data;\n\n\t(*pos)++;\n\tif (gcov_iter_next(iter))\n\t\treturn NULL;\n\n\treturn iter;\n}",
    "includes": [
      "#include \"gcov.h\"",
      "#include <linux/mm.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/string.h>",
      "#include <linux/list.h>",
      "#include <linux/fs.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gcov_iter_next",
          "args": [
            "iter"
          ],
          "line": 222
        },
        "resolved": true,
        "details": {
          "function_name": "gcov_iter_next",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/gcov/fs.c",
          "lines": "164-173",
          "snippet": "static int gcov_iter_next(struct gcov_iterator *iter)\n{\n\tif (iter->pos < iter->size)\n\t\titer->pos += ITER_STRIDE;\n\n\tif (iter->pos >= iter->size)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"gcov.h\"",
            "#include <linux/mm.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [
            "#define ITER_STRIDE\tPAGE_SIZE"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"gcov.h\"\n#include <linux/mm.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\n#define ITER_STRIDE\tPAGE_SIZE\n\nstatic int gcov_iter_next(struct gcov_iterator *iter)\n{\n\tif (iter->pos < iter->size)\n\t\titer->pos += ITER_STRIDE;\n\n\tif (iter->pos >= iter->size)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"gcov.h\"\n#include <linux/mm.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic void *gcov_seq_next(struct seq_file *seq, void *data, loff_t *pos)\n{\n\tstruct gcov_iterator *iter = data;\n\n\t(*pos)++;\n\tif (gcov_iter_next(iter))\n\t\treturn NULL;\n\n\treturn iter;\n}"
  },
  {
    "function_name": "gcov_seq_start",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/gcov/fs.c",
    "lines": "204-214",
    "snippet": "static void *gcov_seq_start(struct seq_file *seq, loff_t *pos)\n{\n\tloff_t i;\n\n\tgcov_iter_start(seq->private);\n\tfor (i = 0; i < *pos; i++) {\n\t\tif (gcov_iter_next(seq->private))\n\t\t\treturn NULL;\n\t}\n\treturn seq->private;\n}",
    "includes": [
      "#include \"gcov.h\"",
      "#include <linux/mm.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/string.h>",
      "#include <linux/list.h>",
      "#include <linux/fs.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gcov_iter_next",
          "args": [
            "seq->private"
          ],
          "line": 210
        },
        "resolved": true,
        "details": {
          "function_name": "gcov_iter_next",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/gcov/fs.c",
          "lines": "164-173",
          "snippet": "static int gcov_iter_next(struct gcov_iterator *iter)\n{\n\tif (iter->pos < iter->size)\n\t\titer->pos += ITER_STRIDE;\n\n\tif (iter->pos >= iter->size)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"gcov.h\"",
            "#include <linux/mm.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [
            "#define ITER_STRIDE\tPAGE_SIZE"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"gcov.h\"\n#include <linux/mm.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\n#define ITER_STRIDE\tPAGE_SIZE\n\nstatic int gcov_iter_next(struct gcov_iterator *iter)\n{\n\tif (iter->pos < iter->size)\n\t\titer->pos += ITER_STRIDE;\n\n\tif (iter->pos >= iter->size)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gcov_iter_start",
          "args": [
            "seq->private"
          ],
          "line": 208
        },
        "resolved": true,
        "details": {
          "function_name": "gcov_iter_start",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/gcov/fs.c",
          "lines": "153-156",
          "snippet": "static void gcov_iter_start(struct gcov_iterator *iter)\n{\n\titer->pos = 0;\n}",
          "includes": [
            "#include \"gcov.h\"",
            "#include <linux/mm.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"gcov.h\"\n#include <linux/mm.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic void gcov_iter_start(struct gcov_iterator *iter)\n{\n\titer->pos = 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"gcov.h\"\n#include <linux/mm.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic void *gcov_seq_start(struct seq_file *seq, loff_t *pos)\n{\n\tloff_t i;\n\n\tgcov_iter_start(seq->private);\n\tfor (i = 0; i < *pos; i++) {\n\t\tif (gcov_iter_next(seq->private))\n\t\t\treturn NULL;\n\t}\n\treturn seq->private;\n}"
  },
  {
    "function_name": "gcov_iter_write",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/gcov/fs.c",
    "lines": "182-196",
    "snippet": "static int gcov_iter_write(struct gcov_iterator *iter, struct seq_file *seq)\n{\n\tsize_t len;\n\n\tif (iter->pos >= iter->size)\n\t\treturn -EINVAL;\n\n\tlen = ITER_STRIDE;\n\tif (iter->pos + len > iter->size)\n\t\tlen = iter->size - iter->pos;\n\n\tseq_write(seq, iter->buffer + iter->pos, len);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"gcov.h\"",
      "#include <linux/mm.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/string.h>",
      "#include <linux/list.h>",
      "#include <linux/fs.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [
      "#define ITER_STRIDE\tPAGE_SIZE"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_write",
          "args": [
            "seq",
            "iter->buffer + iter->pos",
            "len"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"gcov.h\"\n#include <linux/mm.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\n#define ITER_STRIDE\tPAGE_SIZE\n\nstatic int gcov_iter_write(struct gcov_iterator *iter, struct seq_file *seq)\n{\n\tsize_t len;\n\n\tif (iter->pos >= iter->size)\n\t\treturn -EINVAL;\n\n\tlen = ITER_STRIDE;\n\tif (iter->pos + len > iter->size)\n\t\tlen = iter->size - iter->pos;\n\n\tseq_write(seq, iter->buffer + iter->pos, len);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "gcov_iter_next",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/gcov/fs.c",
    "lines": "164-173",
    "snippet": "static int gcov_iter_next(struct gcov_iterator *iter)\n{\n\tif (iter->pos < iter->size)\n\t\titer->pos += ITER_STRIDE;\n\n\tif (iter->pos >= iter->size)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"gcov.h\"",
      "#include <linux/mm.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/string.h>",
      "#include <linux/list.h>",
      "#include <linux/fs.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [
      "#define ITER_STRIDE\tPAGE_SIZE"
    ],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"gcov.h\"\n#include <linux/mm.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\n#define ITER_STRIDE\tPAGE_SIZE\n\nstatic int gcov_iter_next(struct gcov_iterator *iter)\n{\n\tif (iter->pos < iter->size)\n\t\titer->pos += ITER_STRIDE;\n\n\tif (iter->pos >= iter->size)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "gcov_iter_start",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/gcov/fs.c",
    "lines": "153-156",
    "snippet": "static void gcov_iter_start(struct gcov_iterator *iter)\n{\n\titer->pos = 0;\n}",
    "includes": [
      "#include \"gcov.h\"",
      "#include <linux/mm.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/string.h>",
      "#include <linux/list.h>",
      "#include <linux/fs.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"gcov.h\"\n#include <linux/mm.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic void gcov_iter_start(struct gcov_iterator *iter)\n{\n\titer->pos = 0;\n}"
  },
  {
    "function_name": "gcov_iter_get_info",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/gcov/fs.c",
    "lines": "144-147",
    "snippet": "static struct gcov_info *gcov_iter_get_info(struct gcov_iterator *iter)\n{\n\treturn iter->info;\n}",
    "includes": [
      "#include \"gcov.h\"",
      "#include <linux/mm.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/string.h>",
      "#include <linux/list.h>",
      "#include <linux/fs.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"gcov.h\"\n#include <linux/mm.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic struct gcov_info *gcov_iter_get_info(struct gcov_iterator *iter)\n{\n\treturn iter->info;\n}"
  },
  {
    "function_name": "gcov_iter_free",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/gcov/fs.c",
    "lines": "135-138",
    "snippet": "static void gcov_iter_free(struct gcov_iterator *iter)\n{\n\tkvfree(iter);\n}",
    "includes": [
      "#include \"gcov.h\"",
      "#include <linux/mm.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/string.h>",
      "#include <linux/list.h>",
      "#include <linux/fs.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvfree",
          "args": [
            "iter"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"gcov.h\"\n#include <linux/mm.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic void gcov_iter_free(struct gcov_iterator *iter)\n{\n\tkvfree(iter);\n}"
  },
  {
    "function_name": "gcov_iter_new",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/gcov/fs.c",
    "lines": "111-128",
    "snippet": "static struct gcov_iterator *gcov_iter_new(struct gcov_info *info)\n{\n\tstruct gcov_iterator *iter;\n\tsize_t size;\n\n\t/* Dry-run to get the actual buffer size. */\n\tsize = convert_to_gcda(NULL, info);\n\n\titer = kvmalloc(struct_size(iter, buffer, size), GFP_KERNEL);\n\tif (!iter)\n\t\treturn NULL;\n\n\titer->info = info;\n\titer->size = size;\n\tconvert_to_gcda(iter->buffer, info);\n\n\treturn iter;\n}",
    "includes": [
      "#include \"gcov.h\"",
      "#include <linux/mm.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/string.h>",
      "#include <linux/list.h>",
      "#include <linux/fs.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "convert_to_gcda",
          "args": [
            "iter->buffer",
            "info"
          ],
          "line": 125
        },
        "resolved": true,
        "details": {
          "function_name": "convert_to_gcda",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/gcov/gcc_4_7.c",
          "lines": "372-417",
          "snippet": "size_t convert_to_gcda(char *buffer, struct gcov_info *info)\n{\n\tstruct gcov_fn_info *fi_ptr;\n\tstruct gcov_ctr_info *ci_ptr;\n\tunsigned int fi_idx;\n\tunsigned int ct_idx;\n\tunsigned int cv_idx;\n\tsize_t pos = 0;\n\n\t/* File header. */\n\tpos += store_gcov_u32(buffer, pos, GCOV_DATA_MAGIC);\n\tpos += store_gcov_u32(buffer, pos, info->version);\n\tpos += store_gcov_u32(buffer, pos, info->stamp);\n\n\tfor (fi_idx = 0; fi_idx < info->n_functions; fi_idx++) {\n\t\tfi_ptr = info->functions[fi_idx];\n\n\t\t/* Function record. */\n\t\tpos += store_gcov_u32(buffer, pos, GCOV_TAG_FUNCTION);\n\t\tpos += store_gcov_u32(buffer, pos, GCOV_TAG_FUNCTION_LENGTH);\n\t\tpos += store_gcov_u32(buffer, pos, fi_ptr->ident);\n\t\tpos += store_gcov_u32(buffer, pos, fi_ptr->lineno_checksum);\n\t\tpos += store_gcov_u32(buffer, pos, fi_ptr->cfg_checksum);\n\n\t\tci_ptr = fi_ptr->ctrs;\n\n\t\tfor (ct_idx = 0; ct_idx < GCOV_COUNTERS; ct_idx++) {\n\t\t\tif (!counter_active(info, ct_idx))\n\t\t\t\tcontinue;\n\n\t\t\t/* Counter record. */\n\t\t\tpos += store_gcov_u32(buffer, pos,\n\t\t\t\t\t      GCOV_TAG_FOR_COUNTER(ct_idx));\n\t\t\tpos += store_gcov_u32(buffer, pos, ci_ptr->num * 2);\n\n\t\t\tfor (cv_idx = 0; cv_idx < ci_ptr->num; cv_idx++) {\n\t\t\t\tpos += store_gcov_u64(buffer, pos,\n\t\t\t\t\t\t      ci_ptr->values[cv_idx]);\n\t\t\t}\n\n\t\t\tci_ptr++;\n\t\t}\n\t}\n\n\treturn pos;\n}",
          "includes": [
            "#include \"gcov.h\"",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [
            "#define GCOV_TAG_FUNCTION_LENGTH\t3",
            "#define GCOV_COUNTERS\t\t\t9",
            "#define GCOV_COUNTERS\t\t\t10",
            "#define GCOV_COUNTERS\t\t\t9",
            "#define GCOV_COUNTERS\t\t\t8"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"gcov.h\"\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n\n#define GCOV_TAG_FUNCTION_LENGTH\t3\n#define GCOV_COUNTERS\t\t\t9\n#define GCOV_COUNTERS\t\t\t10\n#define GCOV_COUNTERS\t\t\t9\n#define GCOV_COUNTERS\t\t\t8\n\nsize_t convert_to_gcda(char *buffer, struct gcov_info *info)\n{\n\tstruct gcov_fn_info *fi_ptr;\n\tstruct gcov_ctr_info *ci_ptr;\n\tunsigned int fi_idx;\n\tunsigned int ct_idx;\n\tunsigned int cv_idx;\n\tsize_t pos = 0;\n\n\t/* File header. */\n\tpos += store_gcov_u32(buffer, pos, GCOV_DATA_MAGIC);\n\tpos += store_gcov_u32(buffer, pos, info->version);\n\tpos += store_gcov_u32(buffer, pos, info->stamp);\n\n\tfor (fi_idx = 0; fi_idx < info->n_functions; fi_idx++) {\n\t\tfi_ptr = info->functions[fi_idx];\n\n\t\t/* Function record. */\n\t\tpos += store_gcov_u32(buffer, pos, GCOV_TAG_FUNCTION);\n\t\tpos += store_gcov_u32(buffer, pos, GCOV_TAG_FUNCTION_LENGTH);\n\t\tpos += store_gcov_u32(buffer, pos, fi_ptr->ident);\n\t\tpos += store_gcov_u32(buffer, pos, fi_ptr->lineno_checksum);\n\t\tpos += store_gcov_u32(buffer, pos, fi_ptr->cfg_checksum);\n\n\t\tci_ptr = fi_ptr->ctrs;\n\n\t\tfor (ct_idx = 0; ct_idx < GCOV_COUNTERS; ct_idx++) {\n\t\t\tif (!counter_active(info, ct_idx))\n\t\t\t\tcontinue;\n\n\t\t\t/* Counter record. */\n\t\t\tpos += store_gcov_u32(buffer, pos,\n\t\t\t\t\t      GCOV_TAG_FOR_COUNTER(ct_idx));\n\t\t\tpos += store_gcov_u32(buffer, pos, ci_ptr->num * 2);\n\n\t\t\tfor (cv_idx = 0; cv_idx < ci_ptr->num; cv_idx++) {\n\t\t\t\tpos += store_gcov_u64(buffer, pos,\n\t\t\t\t\t\t      ci_ptr->values[cv_idx]);\n\t\t\t}\n\n\t\t\tci_ptr++;\n\t\t}\n\t}\n\n\treturn pos;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvmalloc",
          "args": [
            "struct_size(iter, buffer, size)",
            "GFP_KERNEL"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "struct_size",
          "args": [
            "iter",
            "buffer",
            "size"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"gcov.h\"\n#include <linux/mm.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic struct gcov_iterator *gcov_iter_new(struct gcov_info *info)\n{\n\tstruct gcov_iterator *iter;\n\tsize_t size;\n\n\t/* Dry-run to get the actual buffer size. */\n\tsize = convert_to_gcda(NULL, info);\n\n\titer = kvmalloc(struct_size(iter, buffer, size), GFP_KERNEL);\n\tif (!iter)\n\t\treturn NULL;\n\n\titer->info = info;\n\titer->size = size;\n\tconvert_to_gcda(iter->buffer, info);\n\n\treturn iter;\n}"
  },
  {
    "function_name": "gcov_persist_setup",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/gcov/fs.c",
    "lines": "74-86",
    "snippet": "static int __init gcov_persist_setup(char *str)\n{\n\tunsigned long val;\n\n\tif (kstrtoul(str, 0, &val)) {\n\t\tpr_warn(\"invalid gcov_persist parameter '%s'\\n\", str);\n\t\treturn 0;\n\t}\n\tgcov_persist = val;\n\tpr_info(\"setting gcov_persist to %d\\n\", gcov_persist);\n\n\treturn 1;\n}",
    "includes": [
      "#include \"gcov.h\"",
      "#include <linux/mm.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/string.h>",
      "#include <linux/list.h>",
      "#include <linux/fs.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int gcov_persist = 1;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"setting gcov_persist to %d\\n\"",
            "gcov_persist"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"invalid gcov_persist parameter '%s'\\n\"",
            "str"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrtoul",
          "args": [
            "str",
            "0",
            "&val"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"gcov.h\"\n#include <linux/mm.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic int gcov_persist = 1;\n\nstatic int __init gcov_persist_setup(char *str)\n{\n\tunsigned long val;\n\n\tif (kstrtoul(str, 0, &val)) {\n\t\tpr_warn(\"invalid gcov_persist parameter '%s'\\n\", str);\n\t\treturn 0;\n\t}\n\tgcov_persist = val;\n\tpr_info(\"setting gcov_persist to %d\\n\", gcov_persist);\n\n\treturn 1;\n}"
  }
]