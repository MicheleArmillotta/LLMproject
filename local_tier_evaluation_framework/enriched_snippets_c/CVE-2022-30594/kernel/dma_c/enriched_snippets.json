[
  {
    "function_name": "proc_dma_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma.c",
    "lines": "138-142",
    "snippet": "static int __init proc_dma_init(void)\n{\n\tproc_create_single(\"dma\", 0, NULL, proc_dma_show);\n\treturn 0;\n}",
    "includes": [
      "#include <asm/dma.h>",
      "#include <linux/init.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "proc_create_single",
          "args": [
            "\"dma\"",
            "0",
            "NULL",
            "proc_dma_show"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/dma.h>\n#include <linux/init.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic int __init proc_dma_init(void)\n{\n\tproc_create_single(\"dma\", 0, NULL, proc_dma_show);\n\treturn 0;\n}"
  },
  {
    "function_name": "proc_dma_show",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma.c",
    "lines": "131-135",
    "snippet": "static int proc_dma_show(struct seq_file *m, void *v)\n{\n\tseq_puts(m, \"No DMA\\n\");\n\treturn 0;\n}",
    "includes": [
      "#include <asm/dma.h>",
      "#include <linux/init.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "m",
            "\"No DMA\\n\""
          ],
          "line": 133
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_puts",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "205-220",
          "snippet": "void trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/dma.h>\n#include <linux/init.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic int proc_dma_show(struct seq_file *m, void *v)\n{\n\tseq_puts(m, \"No DMA\\n\");\n\treturn 0;\n}"
  },
  {
    "function_name": "proc_dma_show",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma.c",
    "lines": "118-129",
    "snippet": "static int proc_dma_show(struct seq_file *m, void *v)\n{\n\tint i;\n\n\tfor (i = 0 ; i < MAX_DMA_CHANNELS ; i++) {\n\t\tif (dma_chan_busy[i].lock) {\n\t\t\tseq_printf(m, \"%2d: %s\\n\", i,\n\t\t\t\t   dma_chan_busy[i].device_id);\n\t\t}\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <asm/dma.h>",
      "#include <linux/init.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"%2d: %s\\n\"",
            "i",
            "dma_chan_busy[i].device_id"
          ],
          "line": 124
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "81-100",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/dma.h>\n#include <linux/init.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic int proc_dma_show(struct seq_file *m, void *v)\n{\n\tint i;\n\n\tfor (i = 0 ; i < MAX_DMA_CHANNELS ; i++) {\n\t\tif (dma_chan_busy[i].lock) {\n\t\t\tseq_printf(m, \"%2d: %s\\n\", i,\n\t\t\t\t   dma_chan_busy[i].device_id);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "free_dma",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma.c",
    "lines": "109-111",
    "snippet": "void free_dma(unsigned int dmanr)\n{\n}",
    "includes": [
      "#include <asm/dma.h>",
      "#include <linux/init.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/dma.h>\n#include <linux/init.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nvoid free_dma(unsigned int dmanr)\n{\n}"
  },
  {
    "function_name": "request_dma",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma.c",
    "lines": "104-107",
    "snippet": "int request_dma(unsigned int dmanr, const char *device_id)\n{\n\treturn -EINVAL;\n}",
    "includes": [
      "#include <asm/dma.h>",
      "#include <linux/init.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/dma.h>\n#include <linux/init.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nint request_dma(unsigned int dmanr, const char *device_id)\n{\n\treturn -EINVAL;\n}"
  },
  {
    "function_name": "free_dma",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma.c",
    "lines": "88-100",
    "snippet": "void free_dma(unsigned int dmanr)\n{\n\tif (dmanr >= MAX_DMA_CHANNELS) {\n\t\tprintk(KERN_WARNING \"Trying to free DMA%d\\n\", dmanr);\n\t\treturn;\n\t}\n\n\tif (xchg(&dma_chan_busy[dmanr].lock, 0) == 0) {\n\t\tprintk(KERN_WARNING \"Trying to free free DMA%d\\n\", dmanr);\n\t\treturn;\n\t}\n\n}",
    "includes": [
      "#include <asm/dma.h>",
      "#include <linux/init.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_WARNING \"Trying to free free DMA%d\\n\"",
            "dmanr"
          ],
          "line": 96
        },
        "resolved": true,
        "details": {
          "function_name": "__warn_printk",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/panic.c",
          "lines": "623-632",
          "snippet": "void __warn_printk(const char *fmt, ...)\n{\n\tva_list args;\n\n\tpr_warn(CUT_HERE);\n\n\tva_start(args, fmt);\n\tvprintk(fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <trace/events/error_report.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bug.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/init.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/kexec.h>",
            "#include <linux/delay.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/vt_kern.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <trace/events/error_report.h>\n#include <linux/debugfs.h>\n#include <linux/ratelimit.h>\n#include <linux/bug.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/init.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/panic_notifier.h>\n#include <linux/kexec.h>\n#include <linux/delay.h>\n#include <linux/reboot.h>\n#include <linux/ftrace.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/vt_kern.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kgdb.h>\n#include <linux/interrupt.h>\n#include <linux/sched/debug.h>\n#include <linux/debug_locks.h>\n\nvoid __warn_printk(const char *fmt, ...)\n{\n\tva_list args;\n\n\tpr_warn(CUT_HERE);\n\n\tva_start(args, fmt);\n\tvprintk(fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xchg",
          "args": [
            "&dma_chan_busy[dmanr].lock",
            "0"
          ],
          "line": 95
        },
        "resolved": true,
        "details": {
          "function_name": "xchg_tail",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/qspinlock.c",
          "lines": "220-238",
          "snippet": "static __always_inline u32 xchg_tail(struct qspinlock *lock, u32 tail)\n{\n\tu32 old, new, val = atomic_read(&lock->val);\n\n\tfor (;;) {\n\t\tnew = (val & _Q_LOCKED_PENDING_MASK) | tail;\n\t\t/*\n\t\t * We can use relaxed semantics since the caller ensures that\n\t\t * the MCS node is properly initialized before updating the\n\t\t * tail.\n\t\t */\n\t\told = atomic_cmpxchg_relaxed(&lock->val, val, new);\n\t\tif (old == val)\n\t\t\tbreak;\n\n\t\tval = old;\n\t}\n\treturn old;\n}",
          "includes": [
            "#include \"qspinlock.c\"",
            "#include \"qspinlock_paravirt.h\"",
            "#include \"mcs_spinlock.h\"",
            "#include \"qspinlock_stat.h\"",
            "#include <asm/qspinlock.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/percpu.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/bug.h>",
            "#include <linux/smp.h>"
          ],
          "macros_used": [
            "#define _Q_LOCKED_PENDING_MASK (_Q_LOCKED_MASK | _Q_PENDING_MASK)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qspinlock.c\"\n#include \"qspinlock_paravirt.h\"\n#include \"mcs_spinlock.h\"\n#include \"qspinlock_stat.h\"\n#include <asm/qspinlock.h>\n#include <asm/byteorder.h>\n#include <linux/prefetch.h>\n#include <linux/mutex.h>\n#include <linux/hardirq.h>\n#include <linux/percpu.h>\n#include <linux/cpumask.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n\n#define _Q_LOCKED_PENDING_MASK (_Q_LOCKED_MASK | _Q_PENDING_MASK)\n\nstatic __always_inline u32 xchg_tail(struct qspinlock *lock, u32 tail)\n{\n\tu32 old, new, val = atomic_read(&lock->val);\n\n\tfor (;;) {\n\t\tnew = (val & _Q_LOCKED_PENDING_MASK) | tail;\n\t\t/*\n\t\t * We can use relaxed semantics since the caller ensures that\n\t\t * the MCS node is properly initialized before updating the\n\t\t * tail.\n\t\t */\n\t\told = atomic_cmpxchg_relaxed(&lock->val, val, new);\n\t\tif (old == val)\n\t\t\tbreak;\n\n\t\tval = old;\n\t}\n\treturn old;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/dma.h>\n#include <linux/init.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nvoid free_dma(unsigned int dmanr)\n{\n\tif (dmanr >= MAX_DMA_CHANNELS) {\n\t\tprintk(KERN_WARNING \"Trying to free DMA%d\\n\", dmanr);\n\t\treturn;\n\t}\n\n\tif (xchg(&dma_chan_busy[dmanr].lock, 0) == 0) {\n\t\tprintk(KERN_WARNING \"Trying to free free DMA%d\\n\", dmanr);\n\t\treturn;\n\t}\n\n}"
  },
  {
    "function_name": "request_dma",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma.c",
    "lines": "70-82",
    "snippet": "int request_dma(unsigned int dmanr, const char * device_id)\n{\n\tif (dmanr >= MAX_DMA_CHANNELS)\n\t\treturn -EINVAL;\n\n\tif (xchg(&dma_chan_busy[dmanr].lock, 1) != 0)\n\t\treturn -EBUSY;\n\n\tdma_chan_busy[dmanr].device_id = device_id;\n\n\t/* old flag was 0, now contains 1 to indicate busy */\n\treturn 0;\n}",
    "includes": [
      "#include <asm/dma.h>",
      "#include <linux/init.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xchg",
          "args": [
            "&dma_chan_busy[dmanr].lock",
            "1"
          ],
          "line": 75
        },
        "resolved": true,
        "details": {
          "function_name": "xchg_tail",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/qspinlock.c",
          "lines": "220-238",
          "snippet": "static __always_inline u32 xchg_tail(struct qspinlock *lock, u32 tail)\n{\n\tu32 old, new, val = atomic_read(&lock->val);\n\n\tfor (;;) {\n\t\tnew = (val & _Q_LOCKED_PENDING_MASK) | tail;\n\t\t/*\n\t\t * We can use relaxed semantics since the caller ensures that\n\t\t * the MCS node is properly initialized before updating the\n\t\t * tail.\n\t\t */\n\t\told = atomic_cmpxchg_relaxed(&lock->val, val, new);\n\t\tif (old == val)\n\t\t\tbreak;\n\n\t\tval = old;\n\t}\n\treturn old;\n}",
          "includes": [
            "#include \"qspinlock.c\"",
            "#include \"qspinlock_paravirt.h\"",
            "#include \"mcs_spinlock.h\"",
            "#include \"qspinlock_stat.h\"",
            "#include <asm/qspinlock.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/percpu.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/bug.h>",
            "#include <linux/smp.h>"
          ],
          "macros_used": [
            "#define _Q_LOCKED_PENDING_MASK (_Q_LOCKED_MASK | _Q_PENDING_MASK)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qspinlock.c\"\n#include \"qspinlock_paravirt.h\"\n#include \"mcs_spinlock.h\"\n#include \"qspinlock_stat.h\"\n#include <asm/qspinlock.h>\n#include <asm/byteorder.h>\n#include <linux/prefetch.h>\n#include <linux/mutex.h>\n#include <linux/hardirq.h>\n#include <linux/percpu.h>\n#include <linux/cpumask.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n\n#define _Q_LOCKED_PENDING_MASK (_Q_LOCKED_MASK | _Q_PENDING_MASK)\n\nstatic __always_inline u32 xchg_tail(struct qspinlock *lock, u32 tail)\n{\n\tu32 old, new, val = atomic_read(&lock->val);\n\n\tfor (;;) {\n\t\tnew = (val & _Q_LOCKED_PENDING_MASK) | tail;\n\t\t/*\n\t\t * We can use relaxed semantics since the caller ensures that\n\t\t * the MCS node is properly initialized before updating the\n\t\t * tail.\n\t\t */\n\t\told = atomic_cmpxchg_relaxed(&lock->val, val, new);\n\t\tif (old == val)\n\t\t\tbreak;\n\n\t\tval = old;\n\t}\n\treturn old;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/dma.h>\n#include <linux/init.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nint request_dma(unsigned int dmanr, const char * device_id)\n{\n\tif (dmanr >= MAX_DMA_CHANNELS)\n\t\treturn -EINVAL;\n\n\tif (xchg(&dma_chan_busy[dmanr].lock, 1) != 0)\n\t\treturn -EBUSY;\n\n\tdma_chan_busy[dmanr].device_id = device_id;\n\n\t/* old flag was 0, now contains 1 to indicate busy */\n\treturn 0;\n}"
  }
]