[
  {
    "function_name": "get_compat_sigset",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/compat.c",
    "lines": "249-270",
    "snippet": "int\nget_compat_sigset(sigset_t *set, const compat_sigset_t __user *compat)\n{\n#ifdef __BIG_ENDIAN\n\tcompat_sigset_t v;\n\tif (copy_from_user(&v, compat, sizeof(compat_sigset_t)))\n\t\treturn -EFAULT;\n\tswitch (_NSIG_WORDS) {\n\tcase 4: set->sig[3] = v.sig[6] | (((long)v.sig[7]) << 32 );\n\t\tfallthrough;\n\tcase 3: set->sig[2] = v.sig[4] | (((long)v.sig[5]) << 32 );\n\t\tfallthrough;\n\tcase 2: set->sig[1] = v.sig[2] | (((long)v.sig[3]) << 32 );\n\t\tfallthrough;\n\tcase 1: set->sig[0] = v.sig[0] | (((long)v.sig[1]) << 32 );\n\t}\n#else\n\tif (copy_from_user(set, compat, sizeof(compat_sigset_t)))\n\t\treturn -EFAULT;\n#endif\n\treturn 0;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/gfp.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/times.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/migrate.h>",
      "#include <linux/export.h>",
      "#include <linux/security.h>",
      "#include <linux/unistd.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sched.h>\t/* for MAX_SCHEDULE_TIMEOUT */",
      "#include <linux/signal.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <linux/compat.h>",
      "#include <linux/linkage.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "set",
            "compat",
            "sizeof(compat_sigset_t)"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "&v",
            "compat",
            "sizeof(compat_sigset_t)"
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/gfp.h>\n#include <linux/ptrace.h>\n#include <linux/times.h>\n#include <linux/posix-timers.h>\n#include <linux/migrate.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/unistd.h>\n#include <linux/syscalls.h>\n#include <linux/sched.h>\t/* for MAX_SCHEDULE_TIMEOUT */\n#include <linux/signal.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n\nint\nget_compat_sigset(sigset_t *set, const compat_sigset_t __user *compat)\n{\n#ifdef __BIG_ENDIAN\n\tcompat_sigset_t v;\n\tif (copy_from_user(&v, compat, sizeof(compat_sigset_t)))\n\t\treturn -EFAULT;\n\tswitch (_NSIG_WORDS) {\n\tcase 4: set->sig[3] = v.sig[6] | (((long)v.sig[7]) << 32 );\n\t\tfallthrough;\n\tcase 3: set->sig[2] = v.sig[4] | (((long)v.sig[5]) << 32 );\n\t\tfallthrough;\n\tcase 2: set->sig[1] = v.sig[2] | (((long)v.sig[3]) << 32 );\n\t\tfallthrough;\n\tcase 1: set->sig[0] = v.sig[0] | (((long)v.sig[1]) << 32 );\n\t}\n#else\n\tif (copy_from_user(set, compat, sizeof(compat_sigset_t)))\n\t\treturn -EFAULT;\n#endif\n\treturn 0;\n}"
  },
  {
    "function_name": "compat_put_bitmap",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/compat.c",
    "lines": "222-247",
    "snippet": "long compat_put_bitmap(compat_ulong_t __user *umask, unsigned long *mask,\n\t\t       unsigned long bitmap_size)\n{\n\tunsigned long nr_compat_longs;\n\n\t/* align bitmap up to nearest compat_long_t boundary */\n\tbitmap_size = ALIGN(bitmap_size, BITS_PER_COMPAT_LONG);\n\tnr_compat_longs = BITS_TO_COMPAT_LONGS(bitmap_size);\n\n\tif (!user_write_access_begin(umask, bitmap_size / 8))\n\t\treturn -EFAULT;\n\n\twhile (nr_compat_longs > 1) {\n\t\tunsigned long m = *mask++;\n\t\tunsafe_put_user((compat_ulong_t)m, umask++, Efault);\n\t\tunsafe_put_user(m >> BITS_PER_COMPAT_LONG, umask++, Efault);\n\t\tnr_compat_longs -= 2;\n\t}\n\tif (nr_compat_longs)\n\t\tunsafe_put_user((compat_ulong_t)*mask, umask++, Efault);\n\tuser_write_access_end();\n\treturn 0;\nEfault:\n\tuser_write_access_end();\n\treturn -EFAULT;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/gfp.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/times.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/migrate.h>",
      "#include <linux/export.h>",
      "#include <linux/security.h>",
      "#include <linux/unistd.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sched.h>\t/* for MAX_SCHEDULE_TIMEOUT */",
      "#include <linux/signal.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <linux/compat.h>",
      "#include <linux/linkage.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "user_write_access_end",
          "args": [],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "user_write_access_end",
          "args": [],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unsafe_put_user",
          "args": [
            "(compat_ulong_t)*mask",
            "umask++",
            "Efault"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unsafe_put_user",
          "args": [
            "m >> BITS_PER_COMPAT_LONG",
            "umask++",
            "Efault"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unsafe_put_user",
          "args": [
            "(compat_ulong_t)m",
            "umask++",
            "Efault"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "user_write_access_begin",
          "args": [
            "umask",
            "bitmap_size / 8"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BITS_TO_COMPAT_LONGS",
          "args": [
            "bitmap_size"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ALIGN",
          "args": [
            "bitmap_size",
            "BITS_PER_COMPAT_LONG"
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/gfp.h>\n#include <linux/ptrace.h>\n#include <linux/times.h>\n#include <linux/posix-timers.h>\n#include <linux/migrate.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/unistd.h>\n#include <linux/syscalls.h>\n#include <linux/sched.h>\t/* for MAX_SCHEDULE_TIMEOUT */\n#include <linux/signal.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n\nlong compat_put_bitmap(compat_ulong_t __user *umask, unsigned long *mask,\n\t\t       unsigned long bitmap_size)\n{\n\tunsigned long nr_compat_longs;\n\n\t/* align bitmap up to nearest compat_long_t boundary */\n\tbitmap_size = ALIGN(bitmap_size, BITS_PER_COMPAT_LONG);\n\tnr_compat_longs = BITS_TO_COMPAT_LONGS(bitmap_size);\n\n\tif (!user_write_access_begin(umask, bitmap_size / 8))\n\t\treturn -EFAULT;\n\n\twhile (nr_compat_longs > 1) {\n\t\tunsigned long m = *mask++;\n\t\tunsafe_put_user((compat_ulong_t)m, umask++, Efault);\n\t\tunsafe_put_user(m >> BITS_PER_COMPAT_LONG, umask++, Efault);\n\t\tnr_compat_longs -= 2;\n\t}\n\tif (nr_compat_longs)\n\t\tunsafe_put_user((compat_ulong_t)*mask, umask++, Efault);\n\tuser_write_access_end();\n\treturn 0;\nEfault:\n\tuser_write_access_end();\n\treturn -EFAULT;\n}"
  },
  {
    "function_name": "compat_get_bitmap",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/compat.c",
    "lines": "193-220",
    "snippet": "long compat_get_bitmap(unsigned long *mask, const compat_ulong_t __user *umask,\n\t\t       unsigned long bitmap_size)\n{\n\tunsigned long nr_compat_longs;\n\n\t/* align bitmap up to nearest compat_long_t boundary */\n\tbitmap_size = ALIGN(bitmap_size, BITS_PER_COMPAT_LONG);\n\tnr_compat_longs = BITS_TO_COMPAT_LONGS(bitmap_size);\n\n\tif (!user_read_access_begin(umask, bitmap_size / 8))\n\t\treturn -EFAULT;\n\n\twhile (nr_compat_longs > 1) {\n\t\tcompat_ulong_t l1, l2;\n\t\tunsafe_get_user(l1, umask++, Efault);\n\t\tunsafe_get_user(l2, umask++, Efault);\n\t\t*mask++ = ((unsigned long)l2 << BITS_PER_COMPAT_LONG) | l1;\n\t\tnr_compat_longs -= 2;\n\t}\n\tif (nr_compat_longs)\n\t\tunsafe_get_user(*mask, umask++, Efault);\n\tuser_read_access_end();\n\treturn 0;\n\nEfault:\n\tuser_read_access_end();\n\treturn -EFAULT;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/gfp.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/times.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/migrate.h>",
      "#include <linux/export.h>",
      "#include <linux/security.h>",
      "#include <linux/unistd.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sched.h>\t/* for MAX_SCHEDULE_TIMEOUT */",
      "#include <linux/signal.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <linux/compat.h>",
      "#include <linux/linkage.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "user_read_access_end",
          "args": [],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "user_read_access_end",
          "args": [],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unsafe_get_user",
          "args": [
            "*mask",
            "umask++",
            "Efault"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unsafe_get_user",
          "args": [
            "l2",
            "umask++",
            "Efault"
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unsafe_get_user",
          "args": [
            "l1",
            "umask++",
            "Efault"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "user_read_access_begin",
          "args": [
            "umask",
            "bitmap_size / 8"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BITS_TO_COMPAT_LONGS",
          "args": [
            "bitmap_size"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ALIGN",
          "args": [
            "bitmap_size",
            "BITS_PER_COMPAT_LONG"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/gfp.h>\n#include <linux/ptrace.h>\n#include <linux/times.h>\n#include <linux/posix-timers.h>\n#include <linux/migrate.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/unistd.h>\n#include <linux/syscalls.h>\n#include <linux/sched.h>\t/* for MAX_SCHEDULE_TIMEOUT */\n#include <linux/signal.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n\nlong compat_get_bitmap(unsigned long *mask, const compat_ulong_t __user *umask,\n\t\t       unsigned long bitmap_size)\n{\n\tunsigned long nr_compat_longs;\n\n\t/* align bitmap up to nearest compat_long_t boundary */\n\tbitmap_size = ALIGN(bitmap_size, BITS_PER_COMPAT_LONG);\n\tnr_compat_longs = BITS_TO_COMPAT_LONGS(bitmap_size);\n\n\tif (!user_read_access_begin(umask, bitmap_size / 8))\n\t\treturn -EFAULT;\n\n\twhile (nr_compat_longs > 1) {\n\t\tcompat_ulong_t l1, l2;\n\t\tunsafe_get_user(l1, umask++, Efault);\n\t\tunsafe_get_user(l2, umask++, Efault);\n\t\t*mask++ = ((unsigned long)l2 << BITS_PER_COMPAT_LONG) | l1;\n\t\tnr_compat_longs -= 2;\n\t}\n\tif (nr_compat_longs)\n\t\tunsafe_get_user(*mask, umask++, Efault);\n\tuser_read_access_end();\n\treturn 0;\n\nEfault:\n\tuser_read_access_end();\n\treturn -EFAULT;\n}"
  },
  {
    "function_name": "get_compat_sigevent",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/compat.c",
    "lines": "179-191",
    "snippet": "int get_compat_sigevent(struct sigevent *event,\n\t\tconst struct compat_sigevent __user *u_event)\n{\n\tmemset(event, 0, sizeof(*event));\n\treturn (!access_ok(u_event, sizeof(*u_event)) ||\n\t\t__get_user(event->sigev_value.sival_int,\n\t\t\t&u_event->sigev_value.sival_int) ||\n\t\t__get_user(event->sigev_signo, &u_event->sigev_signo) ||\n\t\t__get_user(event->sigev_notify, &u_event->sigev_notify) ||\n\t\t__get_user(event->sigev_notify_thread_id,\n\t\t\t&u_event->sigev_notify_thread_id))\n\t\t? -EFAULT : 0;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/gfp.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/times.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/migrate.h>",
      "#include <linux/export.h>",
      "#include <linux/security.h>",
      "#include <linux/unistd.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sched.h>\t/* for MAX_SCHEDULE_TIMEOUT */",
      "#include <linux/signal.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <linux/compat.h>",
      "#include <linux/linkage.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__get_user",
          "args": [
            "event->sigev_notify_thread_id",
            "&u_event->sigev_notify_thread_id"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_user",
          "args": [
            "event->sigev_notify",
            "&u_event->sigev_notify"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_user",
          "args": [
            "event->sigev_signo",
            "&u_event->sigev_signo"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_user",
          "args": [
            "event->sigev_value.sival_int",
            "&u_event->sigev_value.sival_int"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "access_ok",
          "args": [
            "u_event",
            "sizeof(*u_event)"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "event",
            "0",
            "sizeof(*event)"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/gfp.h>\n#include <linux/ptrace.h>\n#include <linux/times.h>\n#include <linux/posix-timers.h>\n#include <linux/migrate.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/unistd.h>\n#include <linux/syscalls.h>\n#include <linux/sched.h>\t/* for MAX_SCHEDULE_TIMEOUT */\n#include <linux/signal.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n\nint get_compat_sigevent(struct sigevent *event,\n\t\tconst struct compat_sigevent __user *u_event)\n{\n\tmemset(event, 0, sizeof(*event));\n\treturn (!access_ok(u_event, sizeof(*u_event)) ||\n\t\t__get_user(event->sigev_value.sival_int,\n\t\t\t&u_event->sigev_value.sival_int) ||\n\t\t__get_user(event->sigev_signo, &u_event->sigev_signo) ||\n\t\t__get_user(event->sigev_notify, &u_event->sigev_notify) ||\n\t\t__get_user(event->sigev_notify_thread_id,\n\t\t\t&u_event->sigev_notify_thread_id))\n\t\t? -EFAULT : 0;\n}"
  },
  {
    "function_name": "compat_get_user_cpu_mask",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/compat.c",
    "lines": "110-122",
    "snippet": "static int compat_get_user_cpu_mask(compat_ulong_t __user *user_mask_ptr,\n\t\t\t\t    unsigned len, struct cpumask *new_mask)\n{\n\tunsigned long *k;\n\n\tif (len < cpumask_size())\n\t\tmemset(new_mask, 0, cpumask_size());\n\telse if (len > cpumask_size())\n\t\tlen = cpumask_size();\n\n\tk = cpumask_bits(new_mask);\n\treturn compat_get_bitmap(k, user_mask_ptr, len * 8);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/gfp.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/times.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/migrate.h>",
      "#include <linux/export.h>",
      "#include <linux/security.h>",
      "#include <linux/unistd.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sched.h>\t/* for MAX_SCHEDULE_TIMEOUT */",
      "#include <linux/signal.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <linux/compat.h>",
      "#include <linux/linkage.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "compat_get_bitmap",
          "args": [
            "k",
            "user_mask_ptr",
            "len * 8"
          ],
          "line": 121
        },
        "resolved": true,
        "details": {
          "function_name": "compat_get_bitmap",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/compat.c",
          "lines": "193-220",
          "snippet": "long compat_get_bitmap(unsigned long *mask, const compat_ulong_t __user *umask,\n\t\t       unsigned long bitmap_size)\n{\n\tunsigned long nr_compat_longs;\n\n\t/* align bitmap up to nearest compat_long_t boundary */\n\tbitmap_size = ALIGN(bitmap_size, BITS_PER_COMPAT_LONG);\n\tnr_compat_longs = BITS_TO_COMPAT_LONGS(bitmap_size);\n\n\tif (!user_read_access_begin(umask, bitmap_size / 8))\n\t\treturn -EFAULT;\n\n\twhile (nr_compat_longs > 1) {\n\t\tcompat_ulong_t l1, l2;\n\t\tunsafe_get_user(l1, umask++, Efault);\n\t\tunsafe_get_user(l2, umask++, Efault);\n\t\t*mask++ = ((unsigned long)l2 << BITS_PER_COMPAT_LONG) | l1;\n\t\tnr_compat_longs -= 2;\n\t}\n\tif (nr_compat_longs)\n\t\tunsafe_get_user(*mask, umask++, Efault);\n\tuser_read_access_end();\n\treturn 0;\n\nEfault:\n\tuser_read_access_end();\n\treturn -EFAULT;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/gfp.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/times.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/migrate.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/unistd.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched.h>\t/* for MAX_SCHEDULE_TIMEOUT */",
            "#include <linux/signal.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/gfp.h>\n#include <linux/ptrace.h>\n#include <linux/times.h>\n#include <linux/posix-timers.h>\n#include <linux/migrate.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/unistd.h>\n#include <linux/syscalls.h>\n#include <linux/sched.h>\t/* for MAX_SCHEDULE_TIMEOUT */\n#include <linux/signal.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n\nlong compat_get_bitmap(unsigned long *mask, const compat_ulong_t __user *umask,\n\t\t       unsigned long bitmap_size)\n{\n\tunsigned long nr_compat_longs;\n\n\t/* align bitmap up to nearest compat_long_t boundary */\n\tbitmap_size = ALIGN(bitmap_size, BITS_PER_COMPAT_LONG);\n\tnr_compat_longs = BITS_TO_COMPAT_LONGS(bitmap_size);\n\n\tif (!user_read_access_begin(umask, bitmap_size / 8))\n\t\treturn -EFAULT;\n\n\twhile (nr_compat_longs > 1) {\n\t\tcompat_ulong_t l1, l2;\n\t\tunsafe_get_user(l1, umask++, Efault);\n\t\tunsafe_get_user(l2, umask++, Efault);\n\t\t*mask++ = ((unsigned long)l2 << BITS_PER_COMPAT_LONG) | l1;\n\t\tnr_compat_longs -= 2;\n\t}\n\tif (nr_compat_longs)\n\t\tunsafe_get_user(*mask, umask++, Efault);\n\tuser_read_access_end();\n\treturn 0;\n\nEfault:\n\tuser_read_access_end();\n\treturn -EFAULT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_bits",
          "args": [
            "new_mask"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_size",
          "args": [],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_size",
          "args": [],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "new_mask",
            "0",
            "cpumask_size()"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_size",
          "args": [],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_size",
          "args": [],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/gfp.h>\n#include <linux/ptrace.h>\n#include <linux/times.h>\n#include <linux/posix-timers.h>\n#include <linux/migrate.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/unistd.h>\n#include <linux/syscalls.h>\n#include <linux/sched.h>\t/* for MAX_SCHEDULE_TIMEOUT */\n#include <linux/signal.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n\nstatic int compat_get_user_cpu_mask(compat_ulong_t __user *user_mask_ptr,\n\t\t\t\t    unsigned len, struct cpumask *new_mask)\n{\n\tunsigned long *k;\n\n\tif (len < cpumask_size())\n\t\tmemset(new_mask, 0, cpumask_size());\n\telse if (len > cpumask_size())\n\t\tlen = cpumask_size();\n\n\tk = cpumask_bits(new_mask);\n\treturn compat_get_bitmap(k, user_mask_ptr, len * 8);\n}"
  },
  {
    "function_name": "put_compat_rusage",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/compat.c",
    "lines": "83-108",
    "snippet": "int put_compat_rusage(const struct rusage *r, struct compat_rusage __user *ru)\n{\n\tstruct compat_rusage r32;\n\tmemset(&r32, 0, sizeof(r32));\n\tr32.ru_utime.tv_sec = r->ru_utime.tv_sec;\n\tr32.ru_utime.tv_usec = r->ru_utime.tv_usec;\n\tr32.ru_stime.tv_sec = r->ru_stime.tv_sec;\n\tr32.ru_stime.tv_usec = r->ru_stime.tv_usec;\n\tr32.ru_maxrss = r->ru_maxrss;\n\tr32.ru_ixrss = r->ru_ixrss;\n\tr32.ru_idrss = r->ru_idrss;\n\tr32.ru_isrss = r->ru_isrss;\n\tr32.ru_minflt = r->ru_minflt;\n\tr32.ru_majflt = r->ru_majflt;\n\tr32.ru_nswap = r->ru_nswap;\n\tr32.ru_inblock = r->ru_inblock;\n\tr32.ru_oublock = r->ru_oublock;\n\tr32.ru_msgsnd = r->ru_msgsnd;\n\tr32.ru_msgrcv = r->ru_msgrcv;\n\tr32.ru_nsignals = r->ru_nsignals;\n\tr32.ru_nvcsw = r->ru_nvcsw;\n\tr32.ru_nivcsw = r->ru_nivcsw;\n\tif (copy_to_user(ru, &r32, sizeof(r32)))\n\t\treturn -EFAULT;\n\treturn 0;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/gfp.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/times.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/migrate.h>",
      "#include <linux/export.h>",
      "#include <linux/security.h>",
      "#include <linux/unistd.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sched.h>\t/* for MAX_SCHEDULE_TIMEOUT */",
      "#include <linux/signal.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <linux/compat.h>",
      "#include <linux/linkage.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "ru",
            "&r32",
            "sizeof(r32)"
          ],
          "line": 105
        },
        "resolved": true,
        "details": {
          "function_name": "sched_attr_copy_to_user",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "7847-7876",
          "snippet": "static int\nsched_attr_copy_to_user(struct sched_attr __user *uattr,\n\t\t\tstruct sched_attr *kattr,\n\t\t\tunsigned int usize)\n{\n\tunsigned int ksize = sizeof(*kattr);\n\n\tif (!access_ok(uattr, usize))\n\t\treturn -EFAULT;\n\n\t/*\n\t * sched_getattr() ABI forwards and backwards compatibility:\n\t *\n\t * If usize == ksize then we just copy everything to user-space and all is good.\n\t *\n\t * If usize < ksize then we only copy as much as user-space has space for,\n\t * this keeps ABI compatibility as well. We skip the rest.\n\t *\n\t * If usize > ksize then user-space is using a newer version of the ABI,\n\t * which part the kernel doesn't know about. Just ignore it - tooling can\n\t * detect the kernel's knowledge of attributes from the attr->size value\n\t * which is set to ksize in this case.\n\t */\n\tkattr->size = min(usize, ksize);\n\n\tif (copy_to_user(uattr, kattr, kattr->size))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\nstatic int\nsched_attr_copy_to_user(struct sched_attr __user *uattr,\n\t\t\tstruct sched_attr *kattr,\n\t\t\tunsigned int usize)\n{\n\tunsigned int ksize = sizeof(*kattr);\n\n\tif (!access_ok(uattr, usize))\n\t\treturn -EFAULT;\n\n\t/*\n\t * sched_getattr() ABI forwards and backwards compatibility:\n\t *\n\t * If usize == ksize then we just copy everything to user-space and all is good.\n\t *\n\t * If usize < ksize then we only copy as much as user-space has space for,\n\t * this keeps ABI compatibility as well. We skip the rest.\n\t *\n\t * If usize > ksize then user-space is using a newer version of the ABI,\n\t * which part the kernel doesn't know about. Just ignore it - tooling can\n\t * detect the kernel's knowledge of attributes from the attr->size value\n\t * which is set to ksize in this case.\n\t */\n\tkattr->size = min(usize, ksize);\n\n\tif (copy_to_user(uattr, kattr, kattr->size))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&r32",
            "0",
            "sizeof(r32)"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/gfp.h>\n#include <linux/ptrace.h>\n#include <linux/times.h>\n#include <linux/posix-timers.h>\n#include <linux/migrate.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/unistd.h>\n#include <linux/syscalls.h>\n#include <linux/sched.h>\t/* for MAX_SCHEDULE_TIMEOUT */\n#include <linux/signal.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n\nint put_compat_rusage(const struct rusage *r, struct compat_rusage __user *ru)\n{\n\tstruct compat_rusage r32;\n\tmemset(&r32, 0, sizeof(r32));\n\tr32.ru_utime.tv_sec = r->ru_utime.tv_sec;\n\tr32.ru_utime.tv_usec = r->ru_utime.tv_usec;\n\tr32.ru_stime.tv_sec = r->ru_stime.tv_sec;\n\tr32.ru_stime.tv_usec = r->ru_stime.tv_usec;\n\tr32.ru_maxrss = r->ru_maxrss;\n\tr32.ru_ixrss = r->ru_ixrss;\n\tr32.ru_idrss = r->ru_idrss;\n\tr32.ru_isrss = r->ru_isrss;\n\tr32.ru_minflt = r->ru_minflt;\n\tr32.ru_majflt = r->ru_majflt;\n\tr32.ru_nswap = r->ru_nswap;\n\tr32.ru_inblock = r->ru_inblock;\n\tr32.ru_oublock = r->ru_oublock;\n\tr32.ru_msgsnd = r->ru_msgsnd;\n\tr32.ru_msgrcv = r->ru_msgrcv;\n\tr32.ru_nsignals = r->ru_nsignals;\n\tr32.ru_nvcsw = r->ru_nvcsw;\n\tr32.ru_nivcsw = r->ru_nivcsw;\n\tif (copy_to_user(ru, &r32, sizeof(r32)))\n\t\treturn -EFAULT;\n\treturn 0;\n}"
  },
  {
    "function_name": "compat_sig_setmask",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/compat.c",
    "lines": "35-38",
    "snippet": "static inline void compat_sig_setmask(sigset_t *blocked, compat_sigset_word set)\n{\n\tmemcpy(blocked->sig, &set, sizeof(set));\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/gfp.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/times.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/migrate.h>",
      "#include <linux/export.h>",
      "#include <linux/security.h>",
      "#include <linux/unistd.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sched.h>\t/* for MAX_SCHEDULE_TIMEOUT */",
      "#include <linux/signal.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <linux/compat.h>",
      "#include <linux/linkage.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "blocked->sig",
            "&set",
            "sizeof(set)"
          ],
          "line": 37
        },
        "resolved": true,
        "details": {
          "function_name": "memcpy_skip",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/internal.h",
          "lines": "180-184",
          "snippet": "static inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/refcount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/refcount.h>\n#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n\nstatic inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/gfp.h>\n#include <linux/ptrace.h>\n#include <linux/times.h>\n#include <linux/posix-timers.h>\n#include <linux/migrate.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/unistd.h>\n#include <linux/syscalls.h>\n#include <linux/sched.h>\t/* for MAX_SCHEDULE_TIMEOUT */\n#include <linux/signal.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n\nstatic inline void compat_sig_setmask(sigset_t *blocked, compat_sigset_word set)\n{\n\tmemcpy(blocked->sig, &set, sizeof(set));\n}"
  },
  {
    "function_name": "sigprocmask",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/compat.c",
    "lines": "40-79",
    "snippet": "SYSCALL_DEFINE3(sigprocmask, int, how,\n\t\t       compat_old_sigset_t __user *, nset,\n\t\t       compat_old_sigset_t __user *, oset)\n{\n\told_sigset_t old_set, new_set;\n\tsigset_t new_blocked;\n\n\told_set = current->blocked.sig[0];\n\n\tif (nset) {\n\t\tif (get_user(new_set, nset))\n\t\t\treturn -EFAULT;\n\t\tnew_set &= ~(sigmask(SIGKILL) | sigmask(SIGSTOP));\n\n\t\tnew_blocked = current->blocked;\n\n\t\tswitch (how) {\n\t\tcase SIG_BLOCK:\n\t\t\tsigaddsetmask(&new_blocked, new_set);\n\t\t\tbreak;\n\t\tcase SIG_UNBLOCK:\n\t\t\tsigdelsetmask(&new_blocked, new_set);\n\t\t\tbreak;\n\t\tcase SIG_SETMASK:\n\t\t\tcompat_sig_setmask(&new_blocked, new_set);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tset_current_blocked(&new_blocked);\n\t}\n\n\tif (oset) {\n\t\tif (put_user(old_set, oset))\n\t\t\treturn -EFAULT;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/gfp.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/times.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/migrate.h>",
      "#include <linux/export.h>",
      "#include <linux/security.h>",
      "#include <linux/unistd.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sched.h>\t/* for MAX_SCHEDULE_TIMEOUT */",
      "#include <linux/signal.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <linux/compat.h>",
      "#include <linux/linkage.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/gfp.h>\n#include <linux/ptrace.h>\n#include <linux/times.h>\n#include <linux/posix-timers.h>\n#include <linux/migrate.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/unistd.h>\n#include <linux/syscalls.h>\n#include <linux/sched.h>\t/* for MAX_SCHEDULE_TIMEOUT */\n#include <linux/signal.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n\nSYSCALL_DEFINE3(sigprocmask, int, how,\n\t\t       compat_old_sigset_t __user *, nset,\n\t\t       compat_old_sigset_t __user *, oset)\n{\n\told_sigset_t old_set, new_set;\n\tsigset_t new_blocked;\n\n\told_set = current->blocked.sig[0];\n\n\tif (nset) {\n\t\tif (get_user(new_set, nset))\n\t\t\treturn -EFAULT;\n\t\tnew_set &= ~(sigmask(SIGKILL) | sigmask(SIGSTOP));\n\n\t\tnew_blocked = current->blocked;\n\n\t\tswitch (how) {\n\t\tcase SIG_BLOCK:\n\t\t\tsigaddsetmask(&new_blocked, new_set);\n\t\t\tbreak;\n\t\tcase SIG_UNBLOCK:\n\t\t\tsigdelsetmask(&new_blocked, new_set);\n\t\t\tbreak;\n\t\tcase SIG_SETMASK:\n\t\t\tcompat_sig_setmask(&new_blocked, new_set);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tset_current_blocked(&new_blocked);\n\t}\n\n\tif (oset) {\n\t\tif (put_user(old_set, oset))\n\t\t\treturn -EFAULT;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "sched_setaffinity",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/compat.c",
    "lines": "124-142",
    "snippet": "SYSCALL_DEFINE3(sched_setaffinity, compat_pid_t, pid,\n\t\t       unsigned int, len,\n\t\t       compat_ulong_t __user *, user_mask_ptr)\n{\n\tcpumask_var_t new_mask;\n\tint retval;\n\n\tif (!alloc_cpumask_var(&new_mask, GFP_KERNEL))\n\t\treturn -ENOMEM;\n\n\tretval = compat_get_user_cpu_mask(user_mask_ptr, len, new_mask);\n\tif (retval)\n\t\tgoto out;\n\n\tretval = sched_setaffinity(pid, new_mask);\nout:\n\tfree_cpumask_var(new_mask);\n\treturn retval;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/gfp.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/times.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/migrate.h>",
      "#include <linux/export.h>",
      "#include <linux/security.h>",
      "#include <linux/unistd.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sched.h>\t/* for MAX_SCHEDULE_TIMEOUT */",
      "#include <linux/signal.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <linux/compat.h>",
      "#include <linux/linkage.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/gfp.h>\n#include <linux/ptrace.h>\n#include <linux/times.h>\n#include <linux/posix-timers.h>\n#include <linux/migrate.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/unistd.h>\n#include <linux/syscalls.h>\n#include <linux/sched.h>\t/* for MAX_SCHEDULE_TIMEOUT */\n#include <linux/signal.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n\nSYSCALL_DEFINE3(sched_setaffinity, compat_pid_t, pid,\n\t\t       unsigned int, len,\n\t\t       compat_ulong_t __user *, user_mask_ptr)\n{\n\tcpumask_var_t new_mask;\n\tint retval;\n\n\tif (!alloc_cpumask_var(&new_mask, GFP_KERNEL))\n\t\treturn -ENOMEM;\n\n\tretval = compat_get_user_cpu_mask(user_mask_ptr, len, new_mask);\n\tif (retval)\n\t\tgoto out;\n\n\tretval = sched_setaffinity(pid, new_mask);\nout:\n\tfree_cpumask_var(new_mask);\n\treturn retval;\n}"
  },
  {
    "function_name": "sched_getaffinity",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/compat.c",
    "lines": "144-170",
    "snippet": "SYSCALL_DEFINE3(sched_getaffinity, compat_pid_t,  pid, unsigned int, len,\n\t\t       compat_ulong_t __user *, user_mask_ptr)\n{\n\tint ret;\n\tcpumask_var_t mask;\n\n\tif ((len * BITS_PER_BYTE) < nr_cpu_ids)\n\t\treturn -EINVAL;\n\tif (len & (sizeof(compat_ulong_t)-1))\n\t\treturn -EINVAL;\n\n\tif (!alloc_cpumask_var(&mask, GFP_KERNEL))\n\t\treturn -ENOMEM;\n\n\tret = sched_getaffinity(pid, mask);\n\tif (ret == 0) {\n\t\tunsigned int retlen = min(len, cpumask_size());\n\n\t\tif (compat_put_bitmap(user_mask_ptr, cpumask_bits(mask), retlen * 8))\n\t\t\tret = -EFAULT;\n\t\telse\n\t\t\tret = retlen;\n\t}\n\tfree_cpumask_var(mask);\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/gfp.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/times.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/migrate.h>",
      "#include <linux/export.h>",
      "#include <linux/security.h>",
      "#include <linux/unistd.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sched.h>\t/* for MAX_SCHEDULE_TIMEOUT */",
      "#include <linux/signal.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <linux/compat.h>",
      "#include <linux/linkage.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/gfp.h>\n#include <linux/ptrace.h>\n#include <linux/times.h>\n#include <linux/posix-timers.h>\n#include <linux/migrate.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/unistd.h>\n#include <linux/syscalls.h>\n#include <linux/sched.h>\t/* for MAX_SCHEDULE_TIMEOUT */\n#include <linux/signal.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n\nSYSCALL_DEFINE3(sched_getaffinity, compat_pid_t,  pid, unsigned int, len,\n\t\t       compat_ulong_t __user *, user_mask_ptr)\n{\n\tint ret;\n\tcpumask_var_t mask;\n\n\tif ((len * BITS_PER_BYTE) < nr_cpu_ids)\n\t\treturn -EINVAL;\n\tif (len & (sizeof(compat_ulong_t)-1))\n\t\treturn -EINVAL;\n\n\tif (!alloc_cpumask_var(&mask, GFP_KERNEL))\n\t\treturn -ENOMEM;\n\n\tret = sched_getaffinity(pid, mask);\n\tif (ret == 0) {\n\t\tunsigned int retlen = min(len, cpumask_size());\n\n\t\tif (compat_put_bitmap(user_mask_ptr, cpumask_bits(mask), retlen * 8))\n\t\t\tret = -EFAULT;\n\t\telse\n\t\t\tret = retlen;\n\t}\n\tfree_cpumask_var(mask);\n\n\treturn ret;\n}"
  }
]