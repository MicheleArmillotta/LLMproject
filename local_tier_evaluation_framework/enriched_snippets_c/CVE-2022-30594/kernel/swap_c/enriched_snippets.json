[
  {
    "function_name": "swsusp_header_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/swap.c",
    "lines": "1612-1618",
    "snippet": "static int __init swsusp_header_init(void)\n{\n\tswsusp_header = (struct swsusp_header*) __get_free_page(GFP_KERNEL);\n\tif (!swsusp_header)\n\t\tpanic(\"Could not allocate memory for swsusp_header\\n\");\n\treturn 0;\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/ktime.h>",
      "#include <linux/crc32.h>",
      "#include <linux/kthread.h>",
      "#include <linux/atomic.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/lzo.h>",
      "#include <linux/slab.h>",
      "#include <linux/pm.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include <linux/device.h>",
      "#include <linux/genhd.h>",
      "#include <linux/bitops.h>",
      "#include <linux/delay.h>",
      "#include <linux/file.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct swsusp_header *swsusp_header;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"Could not allocate memory for swsusp_header\\n\""
          ],
          "line": 1616
        },
        "resolved": true,
        "details": {
          "function_name": "hardlockup_panic_setup",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/watchdog.c",
          "lines": "74-85",
          "snippet": "static int __init hardlockup_panic_setup(char *str)\n{\n\tif (!strncmp(str, \"panic\", 5))\n\t\thardlockup_panic = 1;\n\telse if (!strncmp(str, \"nopanic\", 7))\n\t\thardlockup_panic = 0;\n\telse if (!strncmp(str, \"0\", 1))\n\t\tnmi_watchdog_user_enabled = 0;\n\telse if (!strncmp(str, \"1\", 1))\n\t\tnmi_watchdog_user_enabled = 1;\n\treturn 1;\n}",
          "includes": [
            "#include <linux/kvm_para.h>",
            "#include <asm/irq_regs.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/tick.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/nmi.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nstatic int __init hardlockup_panic_setup(char *str)\n{\n\tif (!strncmp(str, \"panic\", 5))\n\t\thardlockup_panic = 1;\n\telse if (!strncmp(str, \"nopanic\", 7))\n\t\thardlockup_panic = 0;\n\telse if (!strncmp(str, \"0\", 1))\n\t\tnmi_watchdog_user_enabled = 0;\n\telse if (!strncmp(str, \"1\", 1))\n\t\tnmi_watchdog_user_enabled = 1;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__get_free_page",
          "args": [
            "GFP_KERNEL"
          ],
          "line": 1614
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/ktime.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/atomic.h>\n#include <linux/cpumask.h>\n#include <linux/vmalloc.h>\n#include <linux/lzo.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/device.h>\n#include <linux/genhd.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\nstatic struct swsusp_header *swsusp_header;\n\nstatic int __init swsusp_header_init(void)\n{\n\tswsusp_header = (struct swsusp_header*) __get_free_page(GFP_KERNEL);\n\tif (!swsusp_header)\n\t\tpanic(\"Could not allocate memory for swsusp_header\\n\");\n\treturn 0;\n}"
  },
  {
    "function_name": "swsusp_unmark",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/swap.c",
    "lines": "1587-1609",
    "snippet": "int swsusp_unmark(void)\n{\n\tint error;\n\n\thib_submit_io(REQ_OP_READ, 0, swsusp_resume_block,\n\t\t      swsusp_header, NULL);\n\tif (!memcmp(HIBERNATE_SIG,swsusp_header->sig, 10)) {\n\t\tmemcpy(swsusp_header->sig,swsusp_header->orig_sig, 10);\n\t\terror = hib_submit_io(REQ_OP_WRITE, REQ_SYNC,\n\t\t\t\t\tswsusp_resume_block,\n\t\t\t\t\tswsusp_header, NULL);\n\t} else {\n\t\tpr_err(\"Cannot find swsusp signature!\\n\");\n\t\terror = -ENODEV;\n\t}\n\n\t/*\n\t * We just returned from suspend, we don't need the image any more.\n\t */\n\tfree_all_swap_pages(root_swap);\n\n\treturn error;\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/ktime.h>",
      "#include <linux/crc32.h>",
      "#include <linux/kthread.h>",
      "#include <linux/atomic.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/lzo.h>",
      "#include <linux/slab.h>",
      "#include <linux/pm.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include <linux/device.h>",
      "#include <linux/genhd.h>",
      "#include <linux/bitops.h>",
      "#include <linux/delay.h>",
      "#include <linux/file.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define HIBERNATE_SIG\t\"S1SUSPEND\""
    ],
    "globals_used": [
      "static struct swsusp_header *swsusp_header;",
      "static unsigned short root_swap = 0xffff;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_all_swap_pages",
          "args": [
            "root_swap"
          ],
          "line": 1606
        },
        "resolved": true,
        "details": {
          "function_name": "free_all_swap_pages",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/swap.c",
          "lines": "199-214",
          "snippet": "void free_all_swap_pages(int swap)\n{\n\tstruct rb_node *node;\n\n\twhile ((node = swsusp_extents.rb_node)) {\n\t\tstruct swsusp_extent *ext;\n\t\tunsigned long offset;\n\n\t\text = rb_entry(node, struct swsusp_extent, node);\n\t\trb_erase(node, &swsusp_extents);\n\t\tfor (offset = ext->start; offset <= ext->end; offset++)\n\t\t\tswap_free(swp_entry(swap, offset));\n\n\t\tkfree(ext);\n\t}\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/ktime.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/atomic.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/lzo.h>",
            "#include <linux/slab.h>",
            "#include <linux/pm.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/device.h>",
            "#include <linux/genhd.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/file.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct rb_root swsusp_extents = RB_ROOT;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/ktime.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/atomic.h>\n#include <linux/cpumask.h>\n#include <linux/vmalloc.h>\n#include <linux/lzo.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/device.h>\n#include <linux/genhd.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\nstatic struct rb_root swsusp_extents = RB_ROOT;\n\nvoid free_all_swap_pages(int swap)\n{\n\tstruct rb_node *node;\n\n\twhile ((node = swsusp_extents.rb_node)) {\n\t\tstruct swsusp_extent *ext;\n\t\tunsigned long offset;\n\n\t\text = rb_entry(node, struct swsusp_extent, node);\n\t\trb_erase(node, &swsusp_extents);\n\t\tfor (offset = ext->start; offset <= ext->end; offset++)\n\t\t\tswap_free(swp_entry(swap, offset));\n\n\t\tkfree(ext);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Cannot find swsusp signature!\\n\""
          ],
          "line": 1599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hib_submit_io",
          "args": [
            "REQ_OP_WRITE",
            "REQ_SYNC",
            "swsusp_resume_block",
            "swsusp_header",
            "NULL"
          ],
          "line": 1595
        },
        "resolved": true,
        "details": {
          "function_name": "hib_submit_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/swap.c",
          "lines": "273-303",
          "snippet": "static int hib_submit_io(int op, int op_flags, pgoff_t page_off, void *addr,\n\t\tstruct hib_bio_batch *hb)\n{\n\tstruct page *page = virt_to_page(addr);\n\tstruct bio *bio;\n\tint error = 0;\n\n\tbio = bio_alloc(GFP_NOIO | __GFP_HIGH, 1);\n\tbio->bi_iter.bi_sector = page_off * (PAGE_SIZE >> 9);\n\tbio_set_dev(bio, hib_resume_bdev);\n\tbio_set_op_attrs(bio, op, op_flags);\n\n\tif (bio_add_page(bio, page, PAGE_SIZE, 0) < PAGE_SIZE) {\n\t\tpr_err(\"Adding page to bio failed at %llu\\n\",\n\t\t       (unsigned long long)bio->bi_iter.bi_sector);\n\t\tbio_put(bio);\n\t\treturn -EFAULT;\n\t}\n\n\tif (hb) {\n\t\tbio->bi_end_io = hib_end_io;\n\t\tbio->bi_private = hb;\n\t\tatomic_inc(&hb->count);\n\t\tsubmit_bio(bio);\n\t} else {\n\t\terror = submit_bio_wait(bio);\n\t\tbio_put(bio);\n\t}\n\n\treturn error;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/ktime.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/atomic.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/lzo.h>",
            "#include <linux/slab.h>",
            "#include <linux/pm.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/device.h>",
            "#include <linux/genhd.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/file.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct block_device *hib_resume_bdev;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/ktime.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/atomic.h>\n#include <linux/cpumask.h>\n#include <linux/vmalloc.h>\n#include <linux/lzo.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/device.h>\n#include <linux/genhd.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\nstatic struct block_device *hib_resume_bdev;\n\nstatic int hib_submit_io(int op, int op_flags, pgoff_t page_off, void *addr,\n\t\tstruct hib_bio_batch *hb)\n{\n\tstruct page *page = virt_to_page(addr);\n\tstruct bio *bio;\n\tint error = 0;\n\n\tbio = bio_alloc(GFP_NOIO | __GFP_HIGH, 1);\n\tbio->bi_iter.bi_sector = page_off * (PAGE_SIZE >> 9);\n\tbio_set_dev(bio, hib_resume_bdev);\n\tbio_set_op_attrs(bio, op, op_flags);\n\n\tif (bio_add_page(bio, page, PAGE_SIZE, 0) < PAGE_SIZE) {\n\t\tpr_err(\"Adding page to bio failed at %llu\\n\",\n\t\t       (unsigned long long)bio->bi_iter.bi_sector);\n\t\tbio_put(bio);\n\t\treturn -EFAULT;\n\t}\n\n\tif (hb) {\n\t\tbio->bi_end_io = hib_end_io;\n\t\tbio->bi_private = hb;\n\t\tatomic_inc(&hb->count);\n\t\tsubmit_bio(bio);\n\t} else {\n\t\terror = submit_bio_wait(bio);\n\t\tbio_put(bio);\n\t}\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "swsusp_header->sig",
            "swsusp_header->orig_sig",
            "10"
          ],
          "line": 1594
        },
        "resolved": true,
        "details": {
          "function_name": "memcpy_skip",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/internal.h",
          "lines": "180-184",
          "snippet": "static inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/refcount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/refcount.h>\n#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n\nstatic inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "HIBERNATE_SIG",
            "swsusp_header->sig",
            "10"
          ],
          "line": 1593
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/ktime.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/atomic.h>\n#include <linux/cpumask.h>\n#include <linux/vmalloc.h>\n#include <linux/lzo.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/device.h>\n#include <linux/genhd.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\n#define HIBERNATE_SIG\t\"S1SUSPEND\"\n\nstatic struct swsusp_header *swsusp_header;\nstatic unsigned short root_swap = 0xffff;\n\nint swsusp_unmark(void)\n{\n\tint error;\n\n\thib_submit_io(REQ_OP_READ, 0, swsusp_resume_block,\n\t\t      swsusp_header, NULL);\n\tif (!memcmp(HIBERNATE_SIG,swsusp_header->sig, 10)) {\n\t\tmemcpy(swsusp_header->sig,swsusp_header->orig_sig, 10);\n\t\terror = hib_submit_io(REQ_OP_WRITE, REQ_SYNC,\n\t\t\t\t\tswsusp_resume_block,\n\t\t\t\t\tswsusp_header, NULL);\n\t} else {\n\t\tpr_err(\"Cannot find swsusp signature!\\n\");\n\t\terror = -ENODEV;\n\t}\n\n\t/*\n\t * We just returned from suspend, we don't need the image any more.\n\t */\n\tfree_all_swap_pages(root_swap);\n\n\treturn error;\n}"
  },
  {
    "function_name": "swsusp_close",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/swap.c",
    "lines": "1572-1580",
    "snippet": "void swsusp_close(fmode_t mode)\n{\n\tif (IS_ERR(hib_resume_bdev)) {\n\t\tpr_debug(\"Image device not initialised\\n\");\n\t\treturn;\n\t}\n\n\tblkdev_put(hib_resume_bdev, mode);\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/ktime.h>",
      "#include <linux/crc32.h>",
      "#include <linux/kthread.h>",
      "#include <linux/atomic.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/lzo.h>",
      "#include <linux/slab.h>",
      "#include <linux/pm.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include <linux/device.h>",
      "#include <linux/genhd.h>",
      "#include <linux/bitops.h>",
      "#include <linux/delay.h>",
      "#include <linux/file.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct block_device *hib_resume_bdev;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "blkdev_put",
          "args": [
            "hib_resume_bdev",
            "mode"
          ],
          "line": 1579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"Image device not initialised\\n\""
          ],
          "line": 1575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "hib_resume_bdev"
          ],
          "line": 1574
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/ktime.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/atomic.h>\n#include <linux/cpumask.h>\n#include <linux/vmalloc.h>\n#include <linux/lzo.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/device.h>\n#include <linux/genhd.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\nstatic struct block_device *hib_resume_bdev;\n\nvoid swsusp_close(fmode_t mode)\n{\n\tif (IS_ERR(hib_resume_bdev)) {\n\t\tpr_debug(\"Image device not initialised\\n\");\n\t\treturn;\n\t}\n\n\tblkdev_put(hib_resume_bdev, mode);\n}"
  },
  {
    "function_name": "swsusp_check",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/swap.c",
    "lines": "1521-1566",
    "snippet": "int swsusp_check(void)\n{\n\tint error;\n\tvoid *holder;\n\n\thib_resume_bdev = blkdev_get_by_dev(swsusp_resume_device,\n\t\t\t\t\t    FMODE_READ | FMODE_EXCL, &holder);\n\tif (!IS_ERR(hib_resume_bdev)) {\n\t\tset_blocksize(hib_resume_bdev, PAGE_SIZE);\n\t\tclear_page(swsusp_header);\n\t\terror = hib_submit_io(REQ_OP_READ, 0,\n\t\t\t\t\tswsusp_resume_block,\n\t\t\t\t\tswsusp_header, NULL);\n\t\tif (error)\n\t\t\tgoto put;\n\n\t\tif (!memcmp(HIBERNATE_SIG, swsusp_header->sig, 10)) {\n\t\t\tmemcpy(swsusp_header->sig, swsusp_header->orig_sig, 10);\n\t\t\t/* Reset swap signature now */\n\t\t\terror = hib_submit_io(REQ_OP_WRITE, REQ_SYNC,\n\t\t\t\t\t\tswsusp_resume_block,\n\t\t\t\t\t\tswsusp_header, NULL);\n\t\t} else {\n\t\t\terror = -EINVAL;\n\t\t}\n\t\tif (!error && swsusp_header->flags & SF_HW_SIG &&\n\t\t    swsusp_header->hw_sig != swsusp_hardware_signature) {\n\t\t\tpr_info(\"Suspend image hardware signature mismatch (%08x now %08x); aborting resume.\\n\",\n\t\t\t\tswsusp_header->hw_sig, swsusp_hardware_signature);\n\t\t\terror = -EINVAL;\n\t\t}\n\nput:\n\t\tif (error)\n\t\t\tblkdev_put(hib_resume_bdev, FMODE_READ | FMODE_EXCL);\n\t\telse\n\t\t\tpr_debug(\"Image signature found, resuming\\n\");\n\t} else {\n\t\terror = PTR_ERR(hib_resume_bdev);\n\t}\n\n\tif (error)\n\t\tpr_debug(\"Image not found (code %d)\\n\", error);\n\n\treturn error;\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/ktime.h>",
      "#include <linux/crc32.h>",
      "#include <linux/kthread.h>",
      "#include <linux/atomic.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/lzo.h>",
      "#include <linux/slab.h>",
      "#include <linux/pm.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include <linux/device.h>",
      "#include <linux/genhd.h>",
      "#include <linux/bitops.h>",
      "#include <linux/delay.h>",
      "#include <linux/file.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define HIBERNATE_SIG\t\"S1SUSPEND\""
    ],
    "globals_used": [
      "u32 swsusp_hardware_signature;",
      "static struct swsusp_header *swsusp_header;",
      "static struct block_device *hib_resume_bdev;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"Image not found (code %d)\\n\"",
            "error"
          ],
          "line": 1563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "hib_resume_bdev"
          ],
          "line": 1559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"Image signature found, resuming\\n\""
          ],
          "line": 1557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blkdev_put",
          "args": [
            "hib_resume_bdev",
            "FMODE_READ | FMODE_EXCL"
          ],
          "line": 1555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Suspend image hardware signature mismatch (%08x now %08x); aborting resume.\\n\"",
            "swsusp_header->hw_sig",
            "swsusp_hardware_signature"
          ],
          "line": 1548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hib_submit_io",
          "args": [
            "REQ_OP_WRITE",
            "REQ_SYNC",
            "swsusp_resume_block",
            "swsusp_header",
            "NULL"
          ],
          "line": 1540
        },
        "resolved": true,
        "details": {
          "function_name": "hib_submit_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/swap.c",
          "lines": "273-303",
          "snippet": "static int hib_submit_io(int op, int op_flags, pgoff_t page_off, void *addr,\n\t\tstruct hib_bio_batch *hb)\n{\n\tstruct page *page = virt_to_page(addr);\n\tstruct bio *bio;\n\tint error = 0;\n\n\tbio = bio_alloc(GFP_NOIO | __GFP_HIGH, 1);\n\tbio->bi_iter.bi_sector = page_off * (PAGE_SIZE >> 9);\n\tbio_set_dev(bio, hib_resume_bdev);\n\tbio_set_op_attrs(bio, op, op_flags);\n\n\tif (bio_add_page(bio, page, PAGE_SIZE, 0) < PAGE_SIZE) {\n\t\tpr_err(\"Adding page to bio failed at %llu\\n\",\n\t\t       (unsigned long long)bio->bi_iter.bi_sector);\n\t\tbio_put(bio);\n\t\treturn -EFAULT;\n\t}\n\n\tif (hb) {\n\t\tbio->bi_end_io = hib_end_io;\n\t\tbio->bi_private = hb;\n\t\tatomic_inc(&hb->count);\n\t\tsubmit_bio(bio);\n\t} else {\n\t\terror = submit_bio_wait(bio);\n\t\tbio_put(bio);\n\t}\n\n\treturn error;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/ktime.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/atomic.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/lzo.h>",
            "#include <linux/slab.h>",
            "#include <linux/pm.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/device.h>",
            "#include <linux/genhd.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/file.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct block_device *hib_resume_bdev;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/ktime.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/atomic.h>\n#include <linux/cpumask.h>\n#include <linux/vmalloc.h>\n#include <linux/lzo.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/device.h>\n#include <linux/genhd.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\nstatic struct block_device *hib_resume_bdev;\n\nstatic int hib_submit_io(int op, int op_flags, pgoff_t page_off, void *addr,\n\t\tstruct hib_bio_batch *hb)\n{\n\tstruct page *page = virt_to_page(addr);\n\tstruct bio *bio;\n\tint error = 0;\n\n\tbio = bio_alloc(GFP_NOIO | __GFP_HIGH, 1);\n\tbio->bi_iter.bi_sector = page_off * (PAGE_SIZE >> 9);\n\tbio_set_dev(bio, hib_resume_bdev);\n\tbio_set_op_attrs(bio, op, op_flags);\n\n\tif (bio_add_page(bio, page, PAGE_SIZE, 0) < PAGE_SIZE) {\n\t\tpr_err(\"Adding page to bio failed at %llu\\n\",\n\t\t       (unsigned long long)bio->bi_iter.bi_sector);\n\t\tbio_put(bio);\n\t\treturn -EFAULT;\n\t}\n\n\tif (hb) {\n\t\tbio->bi_end_io = hib_end_io;\n\t\tbio->bi_private = hb;\n\t\tatomic_inc(&hb->count);\n\t\tsubmit_bio(bio);\n\t} else {\n\t\terror = submit_bio_wait(bio);\n\t\tbio_put(bio);\n\t}\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "swsusp_header->sig",
            "swsusp_header->orig_sig",
            "10"
          ],
          "line": 1538
        },
        "resolved": true,
        "details": {
          "function_name": "memcpy_skip",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/internal.h",
          "lines": "180-184",
          "snippet": "static inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/refcount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/refcount.h>\n#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n\nstatic inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "HIBERNATE_SIG",
            "swsusp_header->sig",
            "10"
          ],
          "line": 1537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_page",
          "args": [
            "swsusp_header"
          ],
          "line": 1530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_blocksize",
          "args": [
            "hib_resume_bdev",
            "PAGE_SIZE"
          ],
          "line": 1529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "hib_resume_bdev"
          ],
          "line": 1528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blkdev_get_by_dev",
          "args": [
            "swsusp_resume_device",
            "FMODE_READ | FMODE_EXCL",
            "&holder"
          ],
          "line": 1526
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/ktime.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/atomic.h>\n#include <linux/cpumask.h>\n#include <linux/vmalloc.h>\n#include <linux/lzo.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/device.h>\n#include <linux/genhd.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\n#define HIBERNATE_SIG\t\"S1SUSPEND\"\n\nu32 swsusp_hardware_signature;\nstatic struct swsusp_header *swsusp_header;\nstatic struct block_device *hib_resume_bdev;\n\nint swsusp_check(void)\n{\n\tint error;\n\tvoid *holder;\n\n\thib_resume_bdev = blkdev_get_by_dev(swsusp_resume_device,\n\t\t\t\t\t    FMODE_READ | FMODE_EXCL, &holder);\n\tif (!IS_ERR(hib_resume_bdev)) {\n\t\tset_blocksize(hib_resume_bdev, PAGE_SIZE);\n\t\tclear_page(swsusp_header);\n\t\terror = hib_submit_io(REQ_OP_READ, 0,\n\t\t\t\t\tswsusp_resume_block,\n\t\t\t\t\tswsusp_header, NULL);\n\t\tif (error)\n\t\t\tgoto put;\n\n\t\tif (!memcmp(HIBERNATE_SIG, swsusp_header->sig, 10)) {\n\t\t\tmemcpy(swsusp_header->sig, swsusp_header->orig_sig, 10);\n\t\t\t/* Reset swap signature now */\n\t\t\terror = hib_submit_io(REQ_OP_WRITE, REQ_SYNC,\n\t\t\t\t\t\tswsusp_resume_block,\n\t\t\t\t\t\tswsusp_header, NULL);\n\t\t} else {\n\t\t\terror = -EINVAL;\n\t\t}\n\t\tif (!error && swsusp_header->flags & SF_HW_SIG &&\n\t\t    swsusp_header->hw_sig != swsusp_hardware_signature) {\n\t\t\tpr_info(\"Suspend image hardware signature mismatch (%08x now %08x); aborting resume.\\n\",\n\t\t\t\tswsusp_header->hw_sig, swsusp_hardware_signature);\n\t\t\terror = -EINVAL;\n\t\t}\n\nput:\n\t\tif (error)\n\t\t\tblkdev_put(hib_resume_bdev, FMODE_READ | FMODE_EXCL);\n\t\telse\n\t\t\tpr_debug(\"Image signature found, resuming\\n\");\n\t} else {\n\t\terror = PTR_ERR(hib_resume_bdev);\n\t}\n\n\tif (error)\n\t\tpr_debug(\"Image not found (code %d)\\n\", error);\n\n\treturn error;\n}"
  },
  {
    "function_name": "swsusp_read",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/swap.c",
    "lines": "1486-1515",
    "snippet": "int swsusp_read(unsigned int *flags_p)\n{\n\tint error;\n\tstruct swap_map_handle handle;\n\tstruct snapshot_handle snapshot;\n\tstruct swsusp_info *header;\n\n\tmemset(&snapshot, 0, sizeof(struct snapshot_handle));\n\terror = snapshot_write_next(&snapshot);\n\tif (error < (int)PAGE_SIZE)\n\t\treturn error < 0 ? error : -EFAULT;\n\theader = (struct swsusp_info *)data_of(snapshot);\n\terror = get_swap_reader(&handle, flags_p);\n\tif (error)\n\t\tgoto end;\n\tif (!error)\n\t\terror = swap_read_page(&handle, header, NULL);\n\tif (!error) {\n\t\terror = (*flags_p & SF_NOCOMPRESS_MODE) ?\n\t\t\tload_image(&handle, &snapshot, header->pages - 1) :\n\t\t\tload_image_lzo(&handle, &snapshot, header->pages - 1);\n\t}\n\tswap_reader_finish(&handle);\nend:\n\tif (!error)\n\t\tpr_debug(\"Image successfully loaded\\n\");\n\telse\n\t\tpr_debug(\"Error %d resuming\\n\", error);\n\treturn error;\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/ktime.h>",
      "#include <linux/crc32.h>",
      "#include <linux/kthread.h>",
      "#include <linux/atomic.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/lzo.h>",
      "#include <linux/slab.h>",
      "#include <linux/pm.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include <linux/device.h>",
      "#include <linux/genhd.h>",
      "#include <linux/bitops.h>",
      "#include <linux/delay.h>",
      "#include <linux/file.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"Error %d resuming\\n\"",
            "error"
          ],
          "line": 1513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"Image successfully loaded\\n\""
          ],
          "line": 1511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swap_reader_finish",
          "args": [
            "&handle"
          ],
          "line": 1508
        },
        "resolved": true,
        "details": {
          "function_name": "swap_reader_finish",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/swap.c",
          "lines": "1049-1054",
          "snippet": "static int swap_reader_finish(struct swap_map_handle *handle)\n{\n\trelease_swap_reader(handle);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/ktime.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/atomic.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/lzo.h>",
            "#include <linux/slab.h>",
            "#include <linux/pm.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/device.h>",
            "#include <linux/genhd.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/file.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/ktime.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/atomic.h>\n#include <linux/cpumask.h>\n#include <linux/vmalloc.h>\n#include <linux/lzo.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/device.h>\n#include <linux/genhd.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\nstatic int swap_reader_finish(struct swap_map_handle *handle)\n{\n\trelease_swap_reader(handle);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "load_image_lzo",
          "args": [
            "&handle",
            "&snapshot",
            "header->pages - 1"
          ],
          "line": 1506
        },
        "resolved": true,
        "details": {
          "function_name": "load_image_lzo",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/swap.c",
          "lines": "1168-1478",
          "snippet": "static int load_image_lzo(struct swap_map_handle *handle,\n                          struct snapshot_handle *snapshot,\n                          unsigned int nr_to_read)\n{\n\tunsigned int m;\n\tint ret = 0;\n\tint eof = 0;\n\tstruct hib_bio_batch hb;\n\tktime_t start;\n\tktime_t stop;\n\tunsigned nr_pages;\n\tsize_t off;\n\tunsigned i, thr, run_threads, nr_threads;\n\tunsigned ring = 0, pg = 0, ring_size = 0,\n\t         have = 0, want, need, asked = 0;\n\tunsigned long read_pages = 0;\n\tunsigned char **page = NULL;\n\tstruct dec_data *data = NULL;\n\tstruct crc_data *crc = NULL;\n\n\thib_init_batch(&hb);\n\n\t/*\n\t * We'll limit the number of threads for decompression to limit memory\n\t * footprint.\n\t */\n\tnr_threads = num_online_cpus() - 1;\n\tnr_threads = clamp_val(nr_threads, 1, LZO_THREADS);\n\n\tpage = vmalloc(array_size(LZO_MAX_RD_PAGES, sizeof(*page)));\n\tif (!page) {\n\t\tpr_err(\"Failed to allocate LZO page\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto out_clean;\n\t}\n\n\tdata = vzalloc(array_size(nr_threads, sizeof(*data)));\n\tif (!data) {\n\t\tpr_err(\"Failed to allocate LZO data\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto out_clean;\n\t}\n\n\tcrc = kzalloc(sizeof(*crc), GFP_KERNEL);\n\tif (!crc) {\n\t\tpr_err(\"Failed to allocate crc\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto out_clean;\n\t}\n\n\tclean_pages_on_decompress = true;\n\n\t/*\n\t * Start the decompression threads.\n\t */\n\tfor (thr = 0; thr < nr_threads; thr++) {\n\t\tinit_waitqueue_head(&data[thr].go);\n\t\tinit_waitqueue_head(&data[thr].done);\n\n\t\tdata[thr].thr = kthread_run(lzo_decompress_threadfn,\n\t\t                            &data[thr],\n\t\t                            \"image_decompress/%u\", thr);\n\t\tif (IS_ERR(data[thr].thr)) {\n\t\t\tdata[thr].thr = NULL;\n\t\t\tpr_err(\"Cannot start decompression threads\\n\");\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out_clean;\n\t\t}\n\t}\n\n\t/*\n\t * Start the CRC32 thread.\n\t */\n\tinit_waitqueue_head(&crc->go);\n\tinit_waitqueue_head(&crc->done);\n\n\thandle->crc32 = 0;\n\tcrc->crc32 = &handle->crc32;\n\tfor (thr = 0; thr < nr_threads; thr++) {\n\t\tcrc->unc[thr] = data[thr].unc;\n\t\tcrc->unc_len[thr] = &data[thr].unc_len;\n\t}\n\n\tcrc->thr = kthread_run(crc32_threadfn, crc, \"image_crc32\");\n\tif (IS_ERR(crc->thr)) {\n\t\tcrc->thr = NULL;\n\t\tpr_err(\"Cannot start CRC32 thread\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto out_clean;\n\t}\n\n\t/*\n\t * Set the number of pages for read buffering.\n\t * This is complete guesswork, because we'll only know the real\n\t * picture once prepare_image() is called, which is much later on\n\t * during the image load phase. We'll assume the worst case and\n\t * say that none of the image pages are from high memory.\n\t */\n\tif (low_free_pages() > snapshot_get_image_size())\n\t\tread_pages = (low_free_pages() - snapshot_get_image_size()) / 2;\n\tread_pages = clamp_val(read_pages, LZO_MIN_RD_PAGES, LZO_MAX_RD_PAGES);\n\n\tfor (i = 0; i < read_pages; i++) {\n\t\tpage[i] = (void *)__get_free_page(i < LZO_CMP_PAGES ?\n\t\t\t\t\t\t  GFP_NOIO | __GFP_HIGH :\n\t\t\t\t\t\t  GFP_NOIO | __GFP_NOWARN |\n\t\t\t\t\t\t  __GFP_NORETRY);\n\n\t\tif (!page[i]) {\n\t\t\tif (i < LZO_CMP_PAGES) {\n\t\t\t\tring_size = i;\n\t\t\t\tpr_err(\"Failed to allocate LZO pages\\n\");\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto out_clean;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\twant = ring_size = i;\n\n\tpr_info(\"Using %u thread(s) for decompression\\n\", nr_threads);\n\tpr_info(\"Loading and decompressing image data (%u pages)...\\n\",\n\t\tnr_to_read);\n\tm = nr_to_read / 10;\n\tif (!m)\n\t\tm = 1;\n\tnr_pages = 0;\n\tstart = ktime_get();\n\n\tret = snapshot_write_next(snapshot);\n\tif (ret <= 0)\n\t\tgoto out_finish;\n\n\tfor(;;) {\n\t\tfor (i = 0; !eof && i < want; i++) {\n\t\t\tret = swap_read_page(handle, page[ring], &hb);\n\t\t\tif (ret) {\n\t\t\t\t/*\n\t\t\t\t * On real read error, finish. On end of data,\n\t\t\t\t * set EOF flag and just exit the read loop.\n\t\t\t\t */\n\t\t\t\tif (handle->cur &&\n\t\t\t\t    handle->cur->entries[handle->k]) {\n\t\t\t\t\tgoto out_finish;\n\t\t\t\t} else {\n\t\t\t\t\teof = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (++ring >= ring_size)\n\t\t\t\tring = 0;\n\t\t}\n\t\tasked += i;\n\t\twant -= i;\n\n\t\t/*\n\t\t * We are out of data, wait for some more.\n\t\t */\n\t\tif (!have) {\n\t\t\tif (!asked)\n\t\t\t\tbreak;\n\n\t\t\tret = hib_wait_io(&hb);\n\t\t\tif (ret)\n\t\t\t\tgoto out_finish;\n\t\t\thave += asked;\n\t\t\tasked = 0;\n\t\t\tif (eof)\n\t\t\t\teof = 2;\n\t\t}\n\n\t\tif (crc->run_threads) {\n\t\t\twait_event(crc->done, atomic_read(&crc->stop));\n\t\t\tatomic_set(&crc->stop, 0);\n\t\t\tcrc->run_threads = 0;\n\t\t}\n\n\t\tfor (thr = 0; have && thr < nr_threads; thr++) {\n\t\t\tdata[thr].cmp_len = *(size_t *)page[pg];\n\t\t\tif (unlikely(!data[thr].cmp_len ||\n\t\t\t             data[thr].cmp_len >\n\t\t\t             lzo1x_worst_compress(LZO_UNC_SIZE))) {\n\t\t\t\tpr_err(\"Invalid LZO compressed length\\n\");\n\t\t\t\tret = -1;\n\t\t\t\tgoto out_finish;\n\t\t\t}\n\n\t\t\tneed = DIV_ROUND_UP(data[thr].cmp_len + LZO_HEADER,\n\t\t\t                    PAGE_SIZE);\n\t\t\tif (need > have) {\n\t\t\t\tif (eof > 1) {\n\t\t\t\t\tret = -1;\n\t\t\t\t\tgoto out_finish;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tfor (off = 0;\n\t\t\t     off < LZO_HEADER + data[thr].cmp_len;\n\t\t\t     off += PAGE_SIZE) {\n\t\t\t\tmemcpy(data[thr].cmp + off,\n\t\t\t\t       page[pg], PAGE_SIZE);\n\t\t\t\thave--;\n\t\t\t\twant++;\n\t\t\t\tif (++pg >= ring_size)\n\t\t\t\t\tpg = 0;\n\t\t\t}\n\n\t\t\tatomic_set(&data[thr].ready, 1);\n\t\t\twake_up(&data[thr].go);\n\t\t}\n\n\t\t/*\n\t\t * Wait for more data while we are decompressing.\n\t\t */\n\t\tif (have < LZO_CMP_PAGES && asked) {\n\t\t\tret = hib_wait_io(&hb);\n\t\t\tif (ret)\n\t\t\t\tgoto out_finish;\n\t\t\thave += asked;\n\t\t\tasked = 0;\n\t\t\tif (eof)\n\t\t\t\teof = 2;\n\t\t}\n\n\t\tfor (run_threads = thr, thr = 0; thr < run_threads; thr++) {\n\t\t\twait_event(data[thr].done,\n\t\t\t           atomic_read(&data[thr].stop));\n\t\t\tatomic_set(&data[thr].stop, 0);\n\n\t\t\tret = data[thr].ret;\n\n\t\t\tif (ret < 0) {\n\t\t\t\tpr_err(\"LZO decompression failed\\n\");\n\t\t\t\tgoto out_finish;\n\t\t\t}\n\n\t\t\tif (unlikely(!data[thr].unc_len ||\n\t\t\t             data[thr].unc_len > LZO_UNC_SIZE ||\n\t\t\t             data[thr].unc_len & (PAGE_SIZE - 1))) {\n\t\t\t\tpr_err(\"Invalid LZO uncompressed length\\n\");\n\t\t\t\tret = -1;\n\t\t\t\tgoto out_finish;\n\t\t\t}\n\n\t\t\tfor (off = 0;\n\t\t\t     off < data[thr].unc_len; off += PAGE_SIZE) {\n\t\t\t\tmemcpy(data_of(*snapshot),\n\t\t\t\t       data[thr].unc + off, PAGE_SIZE);\n\n\t\t\t\tif (!(nr_pages % m))\n\t\t\t\t\tpr_info(\"Image loading progress: %3d%%\\n\",\n\t\t\t\t\t\tnr_pages / m * 10);\n\t\t\t\tnr_pages++;\n\n\t\t\t\tret = snapshot_write_next(snapshot);\n\t\t\t\tif (ret <= 0) {\n\t\t\t\t\tcrc->run_threads = thr + 1;\n\t\t\t\t\tatomic_set(&crc->ready, 1);\n\t\t\t\t\twake_up(&crc->go);\n\t\t\t\t\tgoto out_finish;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcrc->run_threads = thr;\n\t\tatomic_set(&crc->ready, 1);\n\t\twake_up(&crc->go);\n\t}\n\nout_finish:\n\tif (crc->run_threads) {\n\t\twait_event(crc->done, atomic_read(&crc->stop));\n\t\tatomic_set(&crc->stop, 0);\n\t}\n\tstop = ktime_get();\n\tif (!ret) {\n\t\tpr_info(\"Image loading done\\n\");\n\t\tsnapshot_write_finalize(snapshot);\n\t\tif (!snapshot_image_loaded(snapshot))\n\t\t\tret = -ENODATA;\n\t\tif (!ret) {\n\t\t\tif (swsusp_header->flags & SF_CRC32_MODE) {\n\t\t\t\tif(handle->crc32 != swsusp_header->crc32) {\n\t\t\t\t\tpr_err(\"Invalid image CRC32!\\n\");\n\t\t\t\t\tret = -ENODATA;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tswsusp_show_speed(start, stop, nr_to_read, \"Read\");\nout_clean:\n\thib_finish_batch(&hb);\n\tfor (i = 0; i < ring_size; i++)\n\t\tfree_page((unsigned long)page[i]);\n\tif (crc) {\n\t\tif (crc->thr)\n\t\t\tkthread_stop(crc->thr);\n\t\tkfree(crc);\n\t}\n\tif (data) {\n\t\tfor (thr = 0; thr < nr_threads; thr++)\n\t\t\tif (data[thr].thr)\n\t\t\t\tkthread_stop(data[thr].thr);\n\t\tvfree(data);\n\t}\n\tvfree(page);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/ktime.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/atomic.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/lzo.h>",
            "#include <linux/slab.h>",
            "#include <linux/pm.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/device.h>",
            "#include <linux/genhd.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/file.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define LZO_MAX_RD_PAGES\t8192",
            "#define LZO_MIN_RD_PAGES\t1024",
            "#define LZO_THREADS\t3",
            "#define LZO_CMP_PAGES\tDIV_ROUND_UP(lzo1x_worst_compress(LZO_UNC_SIZE) + \\\n\t\t\t             LZO_HEADER, PAGE_SIZE)",
            "#define LZO_UNC_SIZE\t(LZO_UNC_PAGES * PAGE_SIZE)",
            "#define LZO_HEADER\tsizeof(size_t)"
          ],
          "globals_used": [
            "static bool clean_pages_on_decompress;",
            "static struct swsusp_header *swsusp_header;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/ktime.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/atomic.h>\n#include <linux/cpumask.h>\n#include <linux/vmalloc.h>\n#include <linux/lzo.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/device.h>\n#include <linux/genhd.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\n#define LZO_MAX_RD_PAGES\t8192\n#define LZO_MIN_RD_PAGES\t1024\n#define LZO_THREADS\t3\n#define LZO_CMP_PAGES\tDIV_ROUND_UP(lzo1x_worst_compress(LZO_UNC_SIZE) + \\\n\t\t\t             LZO_HEADER, PAGE_SIZE)\n#define LZO_UNC_SIZE\t(LZO_UNC_PAGES * PAGE_SIZE)\n#define LZO_HEADER\tsizeof(size_t)\n\nstatic bool clean_pages_on_decompress;\nstatic struct swsusp_header *swsusp_header;\n\nstatic int load_image_lzo(struct swap_map_handle *handle,\n                          struct snapshot_handle *snapshot,\n                          unsigned int nr_to_read)\n{\n\tunsigned int m;\n\tint ret = 0;\n\tint eof = 0;\n\tstruct hib_bio_batch hb;\n\tktime_t start;\n\tktime_t stop;\n\tunsigned nr_pages;\n\tsize_t off;\n\tunsigned i, thr, run_threads, nr_threads;\n\tunsigned ring = 0, pg = 0, ring_size = 0,\n\t         have = 0, want, need, asked = 0;\n\tunsigned long read_pages = 0;\n\tunsigned char **page = NULL;\n\tstruct dec_data *data = NULL;\n\tstruct crc_data *crc = NULL;\n\n\thib_init_batch(&hb);\n\n\t/*\n\t * We'll limit the number of threads for decompression to limit memory\n\t * footprint.\n\t */\n\tnr_threads = num_online_cpus() - 1;\n\tnr_threads = clamp_val(nr_threads, 1, LZO_THREADS);\n\n\tpage = vmalloc(array_size(LZO_MAX_RD_PAGES, sizeof(*page)));\n\tif (!page) {\n\t\tpr_err(\"Failed to allocate LZO page\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto out_clean;\n\t}\n\n\tdata = vzalloc(array_size(nr_threads, sizeof(*data)));\n\tif (!data) {\n\t\tpr_err(\"Failed to allocate LZO data\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto out_clean;\n\t}\n\n\tcrc = kzalloc(sizeof(*crc), GFP_KERNEL);\n\tif (!crc) {\n\t\tpr_err(\"Failed to allocate crc\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto out_clean;\n\t}\n\n\tclean_pages_on_decompress = true;\n\n\t/*\n\t * Start the decompression threads.\n\t */\n\tfor (thr = 0; thr < nr_threads; thr++) {\n\t\tinit_waitqueue_head(&data[thr].go);\n\t\tinit_waitqueue_head(&data[thr].done);\n\n\t\tdata[thr].thr = kthread_run(lzo_decompress_threadfn,\n\t\t                            &data[thr],\n\t\t                            \"image_decompress/%u\", thr);\n\t\tif (IS_ERR(data[thr].thr)) {\n\t\t\tdata[thr].thr = NULL;\n\t\t\tpr_err(\"Cannot start decompression threads\\n\");\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out_clean;\n\t\t}\n\t}\n\n\t/*\n\t * Start the CRC32 thread.\n\t */\n\tinit_waitqueue_head(&crc->go);\n\tinit_waitqueue_head(&crc->done);\n\n\thandle->crc32 = 0;\n\tcrc->crc32 = &handle->crc32;\n\tfor (thr = 0; thr < nr_threads; thr++) {\n\t\tcrc->unc[thr] = data[thr].unc;\n\t\tcrc->unc_len[thr] = &data[thr].unc_len;\n\t}\n\n\tcrc->thr = kthread_run(crc32_threadfn, crc, \"image_crc32\");\n\tif (IS_ERR(crc->thr)) {\n\t\tcrc->thr = NULL;\n\t\tpr_err(\"Cannot start CRC32 thread\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto out_clean;\n\t}\n\n\t/*\n\t * Set the number of pages for read buffering.\n\t * This is complete guesswork, because we'll only know the real\n\t * picture once prepare_image() is called, which is much later on\n\t * during the image load phase. We'll assume the worst case and\n\t * say that none of the image pages are from high memory.\n\t */\n\tif (low_free_pages() > snapshot_get_image_size())\n\t\tread_pages = (low_free_pages() - snapshot_get_image_size()) / 2;\n\tread_pages = clamp_val(read_pages, LZO_MIN_RD_PAGES, LZO_MAX_RD_PAGES);\n\n\tfor (i = 0; i < read_pages; i++) {\n\t\tpage[i] = (void *)__get_free_page(i < LZO_CMP_PAGES ?\n\t\t\t\t\t\t  GFP_NOIO | __GFP_HIGH :\n\t\t\t\t\t\t  GFP_NOIO | __GFP_NOWARN |\n\t\t\t\t\t\t  __GFP_NORETRY);\n\n\t\tif (!page[i]) {\n\t\t\tif (i < LZO_CMP_PAGES) {\n\t\t\t\tring_size = i;\n\t\t\t\tpr_err(\"Failed to allocate LZO pages\\n\");\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto out_clean;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\twant = ring_size = i;\n\n\tpr_info(\"Using %u thread(s) for decompression\\n\", nr_threads);\n\tpr_info(\"Loading and decompressing image data (%u pages)...\\n\",\n\t\tnr_to_read);\n\tm = nr_to_read / 10;\n\tif (!m)\n\t\tm = 1;\n\tnr_pages = 0;\n\tstart = ktime_get();\n\n\tret = snapshot_write_next(snapshot);\n\tif (ret <= 0)\n\t\tgoto out_finish;\n\n\tfor(;;) {\n\t\tfor (i = 0; !eof && i < want; i++) {\n\t\t\tret = swap_read_page(handle, page[ring], &hb);\n\t\t\tif (ret) {\n\t\t\t\t/*\n\t\t\t\t * On real read error, finish. On end of data,\n\t\t\t\t * set EOF flag and just exit the read loop.\n\t\t\t\t */\n\t\t\t\tif (handle->cur &&\n\t\t\t\t    handle->cur->entries[handle->k]) {\n\t\t\t\t\tgoto out_finish;\n\t\t\t\t} else {\n\t\t\t\t\teof = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (++ring >= ring_size)\n\t\t\t\tring = 0;\n\t\t}\n\t\tasked += i;\n\t\twant -= i;\n\n\t\t/*\n\t\t * We are out of data, wait for some more.\n\t\t */\n\t\tif (!have) {\n\t\t\tif (!asked)\n\t\t\t\tbreak;\n\n\t\t\tret = hib_wait_io(&hb);\n\t\t\tif (ret)\n\t\t\t\tgoto out_finish;\n\t\t\thave += asked;\n\t\t\tasked = 0;\n\t\t\tif (eof)\n\t\t\t\teof = 2;\n\t\t}\n\n\t\tif (crc->run_threads) {\n\t\t\twait_event(crc->done, atomic_read(&crc->stop));\n\t\t\tatomic_set(&crc->stop, 0);\n\t\t\tcrc->run_threads = 0;\n\t\t}\n\n\t\tfor (thr = 0; have && thr < nr_threads; thr++) {\n\t\t\tdata[thr].cmp_len = *(size_t *)page[pg];\n\t\t\tif (unlikely(!data[thr].cmp_len ||\n\t\t\t             data[thr].cmp_len >\n\t\t\t             lzo1x_worst_compress(LZO_UNC_SIZE))) {\n\t\t\t\tpr_err(\"Invalid LZO compressed length\\n\");\n\t\t\t\tret = -1;\n\t\t\t\tgoto out_finish;\n\t\t\t}\n\n\t\t\tneed = DIV_ROUND_UP(data[thr].cmp_len + LZO_HEADER,\n\t\t\t                    PAGE_SIZE);\n\t\t\tif (need > have) {\n\t\t\t\tif (eof > 1) {\n\t\t\t\t\tret = -1;\n\t\t\t\t\tgoto out_finish;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tfor (off = 0;\n\t\t\t     off < LZO_HEADER + data[thr].cmp_len;\n\t\t\t     off += PAGE_SIZE) {\n\t\t\t\tmemcpy(data[thr].cmp + off,\n\t\t\t\t       page[pg], PAGE_SIZE);\n\t\t\t\thave--;\n\t\t\t\twant++;\n\t\t\t\tif (++pg >= ring_size)\n\t\t\t\t\tpg = 0;\n\t\t\t}\n\n\t\t\tatomic_set(&data[thr].ready, 1);\n\t\t\twake_up(&data[thr].go);\n\t\t}\n\n\t\t/*\n\t\t * Wait for more data while we are decompressing.\n\t\t */\n\t\tif (have < LZO_CMP_PAGES && asked) {\n\t\t\tret = hib_wait_io(&hb);\n\t\t\tif (ret)\n\t\t\t\tgoto out_finish;\n\t\t\thave += asked;\n\t\t\tasked = 0;\n\t\t\tif (eof)\n\t\t\t\teof = 2;\n\t\t}\n\n\t\tfor (run_threads = thr, thr = 0; thr < run_threads; thr++) {\n\t\t\twait_event(data[thr].done,\n\t\t\t           atomic_read(&data[thr].stop));\n\t\t\tatomic_set(&data[thr].stop, 0);\n\n\t\t\tret = data[thr].ret;\n\n\t\t\tif (ret < 0) {\n\t\t\t\tpr_err(\"LZO decompression failed\\n\");\n\t\t\t\tgoto out_finish;\n\t\t\t}\n\n\t\t\tif (unlikely(!data[thr].unc_len ||\n\t\t\t             data[thr].unc_len > LZO_UNC_SIZE ||\n\t\t\t             data[thr].unc_len & (PAGE_SIZE - 1))) {\n\t\t\t\tpr_err(\"Invalid LZO uncompressed length\\n\");\n\t\t\t\tret = -1;\n\t\t\t\tgoto out_finish;\n\t\t\t}\n\n\t\t\tfor (off = 0;\n\t\t\t     off < data[thr].unc_len; off += PAGE_SIZE) {\n\t\t\t\tmemcpy(data_of(*snapshot),\n\t\t\t\t       data[thr].unc + off, PAGE_SIZE);\n\n\t\t\t\tif (!(nr_pages % m))\n\t\t\t\t\tpr_info(\"Image loading progress: %3d%%\\n\",\n\t\t\t\t\t\tnr_pages / m * 10);\n\t\t\t\tnr_pages++;\n\n\t\t\t\tret = snapshot_write_next(snapshot);\n\t\t\t\tif (ret <= 0) {\n\t\t\t\t\tcrc->run_threads = thr + 1;\n\t\t\t\t\tatomic_set(&crc->ready, 1);\n\t\t\t\t\twake_up(&crc->go);\n\t\t\t\t\tgoto out_finish;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcrc->run_threads = thr;\n\t\tatomic_set(&crc->ready, 1);\n\t\twake_up(&crc->go);\n\t}\n\nout_finish:\n\tif (crc->run_threads) {\n\t\twait_event(crc->done, atomic_read(&crc->stop));\n\t\tatomic_set(&crc->stop, 0);\n\t}\n\tstop = ktime_get();\n\tif (!ret) {\n\t\tpr_info(\"Image loading done\\n\");\n\t\tsnapshot_write_finalize(snapshot);\n\t\tif (!snapshot_image_loaded(snapshot))\n\t\t\tret = -ENODATA;\n\t\tif (!ret) {\n\t\t\tif (swsusp_header->flags & SF_CRC32_MODE) {\n\t\t\t\tif(handle->crc32 != swsusp_header->crc32) {\n\t\t\t\t\tpr_err(\"Invalid image CRC32!\\n\");\n\t\t\t\t\tret = -ENODATA;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tswsusp_show_speed(start, stop, nr_to_read, \"Read\");\nout_clean:\n\thib_finish_batch(&hb);\n\tfor (i = 0; i < ring_size; i++)\n\t\tfree_page((unsigned long)page[i]);\n\tif (crc) {\n\t\tif (crc->thr)\n\t\t\tkthread_stop(crc->thr);\n\t\tkfree(crc);\n\t}\n\tif (data) {\n\t\tfor (thr = 0; thr < nr_threads; thr++)\n\t\t\tif (data[thr].thr)\n\t\t\t\tkthread_stop(data[thr].thr);\n\t\tvfree(data);\n\t}\n\tvfree(page);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "swap_read_page",
          "args": [
            "&handle",
            "header",
            "NULL"
          ],
          "line": 1502
        },
        "resolved": true,
        "details": {
          "function_name": "swap_read_page",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/swap.c",
          "lines": "1020-1047",
          "snippet": "static int swap_read_page(struct swap_map_handle *handle, void *buf,\n\t\tstruct hib_bio_batch *hb)\n{\n\tsector_t offset;\n\tint error;\n\tstruct swap_map_page_list *tmp;\n\n\tif (!handle->cur)\n\t\treturn -EINVAL;\n\toffset = handle->cur->entries[handle->k];\n\tif (!offset)\n\t\treturn -EFAULT;\n\terror = hib_submit_io(REQ_OP_READ, 0, offset, buf, hb);\n\tif (error)\n\t\treturn error;\n\tif (++handle->k >= MAP_PAGE_ENTRIES) {\n\t\thandle->k = 0;\n\t\tfree_page((unsigned long)handle->maps->map);\n\t\ttmp = handle->maps;\n\t\thandle->maps = handle->maps->next;\n\t\tkfree(tmp);\n\t\tif (!handle->maps)\n\t\t\trelease_swap_reader(handle);\n\t\telse\n\t\t\thandle->cur = handle->maps->map;\n\t}\n\treturn error;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/ktime.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/atomic.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/lzo.h>",
            "#include <linux/slab.h>",
            "#include <linux/pm.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/device.h>",
            "#include <linux/genhd.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/file.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define MAP_PAGE_ENTRIES\t(PAGE_SIZE / sizeof(sector_t) - 1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/ktime.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/atomic.h>\n#include <linux/cpumask.h>\n#include <linux/vmalloc.h>\n#include <linux/lzo.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/device.h>\n#include <linux/genhd.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\n#define MAP_PAGE_ENTRIES\t(PAGE_SIZE / sizeof(sector_t) - 1)\n\nstatic int swap_read_page(struct swap_map_handle *handle, void *buf,\n\t\tstruct hib_bio_batch *hb)\n{\n\tsector_t offset;\n\tint error;\n\tstruct swap_map_page_list *tmp;\n\n\tif (!handle->cur)\n\t\treturn -EINVAL;\n\toffset = handle->cur->entries[handle->k];\n\tif (!offset)\n\t\treturn -EFAULT;\n\terror = hib_submit_io(REQ_OP_READ, 0, offset, buf, hb);\n\tif (error)\n\t\treturn error;\n\tif (++handle->k >= MAP_PAGE_ENTRIES) {\n\t\thandle->k = 0;\n\t\tfree_page((unsigned long)handle->maps->map);\n\t\ttmp = handle->maps;\n\t\thandle->maps = handle->maps->next;\n\t\tkfree(tmp);\n\t\tif (!handle->maps)\n\t\t\trelease_swap_reader(handle);\n\t\telse\n\t\t\thandle->cur = handle->maps->map;\n\t}\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_swap_reader",
          "args": [
            "&handle",
            "flags_p"
          ],
          "line": 1498
        },
        "resolved": true,
        "details": {
          "function_name": "get_swap_reader",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/swap.c",
          "lines": "974-1018",
          "snippet": "static int get_swap_reader(struct swap_map_handle *handle,\n\t\tunsigned int *flags_p)\n{\n\tint error;\n\tstruct swap_map_page_list *tmp, *last;\n\tsector_t offset;\n\n\t*flags_p = swsusp_header->flags;\n\n\tif (!swsusp_header->image) /* how can this happen? */\n\t\treturn -EINVAL;\n\n\thandle->cur = NULL;\n\tlast = handle->maps = NULL;\n\toffset = swsusp_header->image;\n\twhile (offset) {\n\t\ttmp = kzalloc(sizeof(*handle->maps), GFP_KERNEL);\n\t\tif (!tmp) {\n\t\t\trelease_swap_reader(handle);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tif (!handle->maps)\n\t\t\thandle->maps = tmp;\n\t\tif (last)\n\t\t\tlast->next = tmp;\n\t\tlast = tmp;\n\n\t\ttmp->map = (struct swap_map_page *)\n\t\t\t   __get_free_page(GFP_NOIO | __GFP_HIGH);\n\t\tif (!tmp->map) {\n\t\t\trelease_swap_reader(handle);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\terror = hib_submit_io(REQ_OP_READ, 0, offset, tmp->map, NULL);\n\t\tif (error) {\n\t\t\trelease_swap_reader(handle);\n\t\t\treturn error;\n\t\t}\n\t\toffset = tmp->map->next_swap;\n\t}\n\thandle->k = 0;\n\thandle->cur = handle->maps->map;\n\treturn 0;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/ktime.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/atomic.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/lzo.h>",
            "#include <linux/slab.h>",
            "#include <linux/pm.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/device.h>",
            "#include <linux/genhd.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/file.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct swsusp_header *swsusp_header;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/ktime.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/atomic.h>\n#include <linux/cpumask.h>\n#include <linux/vmalloc.h>\n#include <linux/lzo.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/device.h>\n#include <linux/genhd.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\nstatic struct swsusp_header *swsusp_header;\n\nstatic int get_swap_reader(struct swap_map_handle *handle,\n\t\tunsigned int *flags_p)\n{\n\tint error;\n\tstruct swap_map_page_list *tmp, *last;\n\tsector_t offset;\n\n\t*flags_p = swsusp_header->flags;\n\n\tif (!swsusp_header->image) /* how can this happen? */\n\t\treturn -EINVAL;\n\n\thandle->cur = NULL;\n\tlast = handle->maps = NULL;\n\toffset = swsusp_header->image;\n\twhile (offset) {\n\t\ttmp = kzalloc(sizeof(*handle->maps), GFP_KERNEL);\n\t\tif (!tmp) {\n\t\t\trelease_swap_reader(handle);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tif (!handle->maps)\n\t\t\thandle->maps = tmp;\n\t\tif (last)\n\t\t\tlast->next = tmp;\n\t\tlast = tmp;\n\n\t\ttmp->map = (struct swap_map_page *)\n\t\t\t   __get_free_page(GFP_NOIO | __GFP_HIGH);\n\t\tif (!tmp->map) {\n\t\t\trelease_swap_reader(handle);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\terror = hib_submit_io(REQ_OP_READ, 0, offset, tmp->map, NULL);\n\t\tif (error) {\n\t\t\trelease_swap_reader(handle);\n\t\t\treturn error;\n\t\t}\n\t\toffset = tmp->map->next_swap;\n\t}\n\thandle->k = 0;\n\thandle->cur = handle->maps->map;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "data_of",
          "args": [
            "snapshot"
          ],
          "line": 1497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snapshot_write_next",
          "args": [
            "&snapshot"
          ],
          "line": 1494
        },
        "resolved": true,
        "details": {
          "function_name": "snapshot_write_next",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/snapshot.c",
          "lines": "2628-2689",
          "snippet": "int snapshot_write_next(struct snapshot_handle *handle)\n{\n\tstatic struct chain_allocator ca;\n\tint error = 0;\n\n\t/* Check if we have already loaded the entire image */\n\tif (handle->cur > 1 && handle->cur > nr_meta_pages + nr_copy_pages)\n\t\treturn 0;\n\n\thandle->sync_read = 1;\n\n\tif (!handle->cur) {\n\t\tif (!buffer)\n\t\t\t/* This makes the buffer be freed by swsusp_free() */\n\t\t\tbuffer = get_image_page(GFP_ATOMIC, PG_ANY);\n\n\t\tif (!buffer)\n\t\t\treturn -ENOMEM;\n\n\t\thandle->buffer = buffer;\n\t} else if (handle->cur == 1) {\n\t\terror = load_header(buffer);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\tsafe_pages_list = NULL;\n\n\t\terror = memory_bm_create(&copy_bm, GFP_ATOMIC, PG_ANY);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\thibernate_restore_protection_begin();\n\t} else if (handle->cur <= nr_meta_pages + 1) {\n\t\terror = unpack_orig_pfns(buffer, &copy_bm);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\tif (handle->cur == nr_meta_pages + 1) {\n\t\t\terror = prepare_image(&orig_bm, &copy_bm);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\n\t\t\tchain_init(&ca, GFP_ATOMIC, PG_SAFE);\n\t\t\tmemory_bm_position_reset(&orig_bm);\n\t\t\trestore_pblist = NULL;\n\t\t\thandle->buffer = get_buffer(&orig_bm, &ca);\n\t\t\thandle->sync_read = 0;\n\t\t\tif (IS_ERR(handle->buffer))\n\t\t\t\treturn PTR_ERR(handle->buffer);\n\t\t}\n\t} else {\n\t\tcopy_last_highmem_page();\n\t\thibernate_restore_protect_page(handle->buffer);\n\t\thandle->buffer = get_buffer(&orig_bm, &ca);\n\t\tif (IS_ERR(handle->buffer))\n\t\t\treturn PTR_ERR(handle->buffer);\n\t\tif (handle->buffer != buffer)\n\t\t\thandle->sync_read = 0;\n\t}\n\thandle->cur++;\n\treturn PAGE_SIZE;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [
            "#define PG_SAFE\t\t1",
            "#define PG_ANY\t\t0"
          ],
          "globals_used": [
            "struct pbe *restore_pblist;",
            "static struct linked_page *safe_pages_list;",
            "static void *buffer;",
            "static unsigned int nr_copy_pages;",
            "static unsigned int nr_meta_pages;",
            "static struct memory_bitmap orig_bm;",
            "static struct memory_bitmap copy_bm;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\n#define PG_SAFE\t\t1\n#define PG_ANY\t\t0\n\nstruct pbe *restore_pblist;\nstatic struct linked_page *safe_pages_list;\nstatic void *buffer;\nstatic unsigned int nr_copy_pages;\nstatic unsigned int nr_meta_pages;\nstatic struct memory_bitmap orig_bm;\nstatic struct memory_bitmap copy_bm;\n\nint snapshot_write_next(struct snapshot_handle *handle)\n{\n\tstatic struct chain_allocator ca;\n\tint error = 0;\n\n\t/* Check if we have already loaded the entire image */\n\tif (handle->cur > 1 && handle->cur > nr_meta_pages + nr_copy_pages)\n\t\treturn 0;\n\n\thandle->sync_read = 1;\n\n\tif (!handle->cur) {\n\t\tif (!buffer)\n\t\t\t/* This makes the buffer be freed by swsusp_free() */\n\t\t\tbuffer = get_image_page(GFP_ATOMIC, PG_ANY);\n\n\t\tif (!buffer)\n\t\t\treturn -ENOMEM;\n\n\t\thandle->buffer = buffer;\n\t} else if (handle->cur == 1) {\n\t\terror = load_header(buffer);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\tsafe_pages_list = NULL;\n\n\t\terror = memory_bm_create(&copy_bm, GFP_ATOMIC, PG_ANY);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\thibernate_restore_protection_begin();\n\t} else if (handle->cur <= nr_meta_pages + 1) {\n\t\terror = unpack_orig_pfns(buffer, &copy_bm);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\tif (handle->cur == nr_meta_pages + 1) {\n\t\t\terror = prepare_image(&orig_bm, &copy_bm);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\n\t\t\tchain_init(&ca, GFP_ATOMIC, PG_SAFE);\n\t\t\tmemory_bm_position_reset(&orig_bm);\n\t\t\trestore_pblist = NULL;\n\t\t\thandle->buffer = get_buffer(&orig_bm, &ca);\n\t\t\thandle->sync_read = 0;\n\t\t\tif (IS_ERR(handle->buffer))\n\t\t\t\treturn PTR_ERR(handle->buffer);\n\t\t}\n\t} else {\n\t\tcopy_last_highmem_page();\n\t\thibernate_restore_protect_page(handle->buffer);\n\t\thandle->buffer = get_buffer(&orig_bm, &ca);\n\t\tif (IS_ERR(handle->buffer))\n\t\t\treturn PTR_ERR(handle->buffer);\n\t\tif (handle->buffer != buffer)\n\t\t\thandle->sync_read = 0;\n\t}\n\thandle->cur++;\n\treturn PAGE_SIZE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&snapshot",
            "0",
            "sizeof(struct snapshot_handle)"
          ],
          "line": 1493
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/ktime.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/atomic.h>\n#include <linux/cpumask.h>\n#include <linux/vmalloc.h>\n#include <linux/lzo.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/device.h>\n#include <linux/genhd.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\nint swsusp_read(unsigned int *flags_p)\n{\n\tint error;\n\tstruct swap_map_handle handle;\n\tstruct snapshot_handle snapshot;\n\tstruct swsusp_info *header;\n\n\tmemset(&snapshot, 0, sizeof(struct snapshot_handle));\n\terror = snapshot_write_next(&snapshot);\n\tif (error < (int)PAGE_SIZE)\n\t\treturn error < 0 ? error : -EFAULT;\n\theader = (struct swsusp_info *)data_of(snapshot);\n\terror = get_swap_reader(&handle, flags_p);\n\tif (error)\n\t\tgoto end;\n\tif (!error)\n\t\terror = swap_read_page(&handle, header, NULL);\n\tif (!error) {\n\t\terror = (*flags_p & SF_NOCOMPRESS_MODE) ?\n\t\t\tload_image(&handle, &snapshot, header->pages - 1) :\n\t\t\tload_image_lzo(&handle, &snapshot, header->pages - 1);\n\t}\n\tswap_reader_finish(&handle);\nend:\n\tif (!error)\n\t\tpr_debug(\"Image successfully loaded\\n\");\n\telse\n\t\tpr_debug(\"Error %d resuming\\n\", error);\n\treturn error;\n}"
  },
  {
    "function_name": "load_image_lzo",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/swap.c",
    "lines": "1168-1478",
    "snippet": "static int load_image_lzo(struct swap_map_handle *handle,\n                          struct snapshot_handle *snapshot,\n                          unsigned int nr_to_read)\n{\n\tunsigned int m;\n\tint ret = 0;\n\tint eof = 0;\n\tstruct hib_bio_batch hb;\n\tktime_t start;\n\tktime_t stop;\n\tunsigned nr_pages;\n\tsize_t off;\n\tunsigned i, thr, run_threads, nr_threads;\n\tunsigned ring = 0, pg = 0, ring_size = 0,\n\t         have = 0, want, need, asked = 0;\n\tunsigned long read_pages = 0;\n\tunsigned char **page = NULL;\n\tstruct dec_data *data = NULL;\n\tstruct crc_data *crc = NULL;\n\n\thib_init_batch(&hb);\n\n\t/*\n\t * We'll limit the number of threads for decompression to limit memory\n\t * footprint.\n\t */\n\tnr_threads = num_online_cpus() - 1;\n\tnr_threads = clamp_val(nr_threads, 1, LZO_THREADS);\n\n\tpage = vmalloc(array_size(LZO_MAX_RD_PAGES, sizeof(*page)));\n\tif (!page) {\n\t\tpr_err(\"Failed to allocate LZO page\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto out_clean;\n\t}\n\n\tdata = vzalloc(array_size(nr_threads, sizeof(*data)));\n\tif (!data) {\n\t\tpr_err(\"Failed to allocate LZO data\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto out_clean;\n\t}\n\n\tcrc = kzalloc(sizeof(*crc), GFP_KERNEL);\n\tif (!crc) {\n\t\tpr_err(\"Failed to allocate crc\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto out_clean;\n\t}\n\n\tclean_pages_on_decompress = true;\n\n\t/*\n\t * Start the decompression threads.\n\t */\n\tfor (thr = 0; thr < nr_threads; thr++) {\n\t\tinit_waitqueue_head(&data[thr].go);\n\t\tinit_waitqueue_head(&data[thr].done);\n\n\t\tdata[thr].thr = kthread_run(lzo_decompress_threadfn,\n\t\t                            &data[thr],\n\t\t                            \"image_decompress/%u\", thr);\n\t\tif (IS_ERR(data[thr].thr)) {\n\t\t\tdata[thr].thr = NULL;\n\t\t\tpr_err(\"Cannot start decompression threads\\n\");\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out_clean;\n\t\t}\n\t}\n\n\t/*\n\t * Start the CRC32 thread.\n\t */\n\tinit_waitqueue_head(&crc->go);\n\tinit_waitqueue_head(&crc->done);\n\n\thandle->crc32 = 0;\n\tcrc->crc32 = &handle->crc32;\n\tfor (thr = 0; thr < nr_threads; thr++) {\n\t\tcrc->unc[thr] = data[thr].unc;\n\t\tcrc->unc_len[thr] = &data[thr].unc_len;\n\t}\n\n\tcrc->thr = kthread_run(crc32_threadfn, crc, \"image_crc32\");\n\tif (IS_ERR(crc->thr)) {\n\t\tcrc->thr = NULL;\n\t\tpr_err(\"Cannot start CRC32 thread\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto out_clean;\n\t}\n\n\t/*\n\t * Set the number of pages for read buffering.\n\t * This is complete guesswork, because we'll only know the real\n\t * picture once prepare_image() is called, which is much later on\n\t * during the image load phase. We'll assume the worst case and\n\t * say that none of the image pages are from high memory.\n\t */\n\tif (low_free_pages() > snapshot_get_image_size())\n\t\tread_pages = (low_free_pages() - snapshot_get_image_size()) / 2;\n\tread_pages = clamp_val(read_pages, LZO_MIN_RD_PAGES, LZO_MAX_RD_PAGES);\n\n\tfor (i = 0; i < read_pages; i++) {\n\t\tpage[i] = (void *)__get_free_page(i < LZO_CMP_PAGES ?\n\t\t\t\t\t\t  GFP_NOIO | __GFP_HIGH :\n\t\t\t\t\t\t  GFP_NOIO | __GFP_NOWARN |\n\t\t\t\t\t\t  __GFP_NORETRY);\n\n\t\tif (!page[i]) {\n\t\t\tif (i < LZO_CMP_PAGES) {\n\t\t\t\tring_size = i;\n\t\t\t\tpr_err(\"Failed to allocate LZO pages\\n\");\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto out_clean;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\twant = ring_size = i;\n\n\tpr_info(\"Using %u thread(s) for decompression\\n\", nr_threads);\n\tpr_info(\"Loading and decompressing image data (%u pages)...\\n\",\n\t\tnr_to_read);\n\tm = nr_to_read / 10;\n\tif (!m)\n\t\tm = 1;\n\tnr_pages = 0;\n\tstart = ktime_get();\n\n\tret = snapshot_write_next(snapshot);\n\tif (ret <= 0)\n\t\tgoto out_finish;\n\n\tfor(;;) {\n\t\tfor (i = 0; !eof && i < want; i++) {\n\t\t\tret = swap_read_page(handle, page[ring], &hb);\n\t\t\tif (ret) {\n\t\t\t\t/*\n\t\t\t\t * On real read error, finish. On end of data,\n\t\t\t\t * set EOF flag and just exit the read loop.\n\t\t\t\t */\n\t\t\t\tif (handle->cur &&\n\t\t\t\t    handle->cur->entries[handle->k]) {\n\t\t\t\t\tgoto out_finish;\n\t\t\t\t} else {\n\t\t\t\t\teof = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (++ring >= ring_size)\n\t\t\t\tring = 0;\n\t\t}\n\t\tasked += i;\n\t\twant -= i;\n\n\t\t/*\n\t\t * We are out of data, wait for some more.\n\t\t */\n\t\tif (!have) {\n\t\t\tif (!asked)\n\t\t\t\tbreak;\n\n\t\t\tret = hib_wait_io(&hb);\n\t\t\tif (ret)\n\t\t\t\tgoto out_finish;\n\t\t\thave += asked;\n\t\t\tasked = 0;\n\t\t\tif (eof)\n\t\t\t\teof = 2;\n\t\t}\n\n\t\tif (crc->run_threads) {\n\t\t\twait_event(crc->done, atomic_read(&crc->stop));\n\t\t\tatomic_set(&crc->stop, 0);\n\t\t\tcrc->run_threads = 0;\n\t\t}\n\n\t\tfor (thr = 0; have && thr < nr_threads; thr++) {\n\t\t\tdata[thr].cmp_len = *(size_t *)page[pg];\n\t\t\tif (unlikely(!data[thr].cmp_len ||\n\t\t\t             data[thr].cmp_len >\n\t\t\t             lzo1x_worst_compress(LZO_UNC_SIZE))) {\n\t\t\t\tpr_err(\"Invalid LZO compressed length\\n\");\n\t\t\t\tret = -1;\n\t\t\t\tgoto out_finish;\n\t\t\t}\n\n\t\t\tneed = DIV_ROUND_UP(data[thr].cmp_len + LZO_HEADER,\n\t\t\t                    PAGE_SIZE);\n\t\t\tif (need > have) {\n\t\t\t\tif (eof > 1) {\n\t\t\t\t\tret = -1;\n\t\t\t\t\tgoto out_finish;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tfor (off = 0;\n\t\t\t     off < LZO_HEADER + data[thr].cmp_len;\n\t\t\t     off += PAGE_SIZE) {\n\t\t\t\tmemcpy(data[thr].cmp + off,\n\t\t\t\t       page[pg], PAGE_SIZE);\n\t\t\t\thave--;\n\t\t\t\twant++;\n\t\t\t\tif (++pg >= ring_size)\n\t\t\t\t\tpg = 0;\n\t\t\t}\n\n\t\t\tatomic_set(&data[thr].ready, 1);\n\t\t\twake_up(&data[thr].go);\n\t\t}\n\n\t\t/*\n\t\t * Wait for more data while we are decompressing.\n\t\t */\n\t\tif (have < LZO_CMP_PAGES && asked) {\n\t\t\tret = hib_wait_io(&hb);\n\t\t\tif (ret)\n\t\t\t\tgoto out_finish;\n\t\t\thave += asked;\n\t\t\tasked = 0;\n\t\t\tif (eof)\n\t\t\t\teof = 2;\n\t\t}\n\n\t\tfor (run_threads = thr, thr = 0; thr < run_threads; thr++) {\n\t\t\twait_event(data[thr].done,\n\t\t\t           atomic_read(&data[thr].stop));\n\t\t\tatomic_set(&data[thr].stop, 0);\n\n\t\t\tret = data[thr].ret;\n\n\t\t\tif (ret < 0) {\n\t\t\t\tpr_err(\"LZO decompression failed\\n\");\n\t\t\t\tgoto out_finish;\n\t\t\t}\n\n\t\t\tif (unlikely(!data[thr].unc_len ||\n\t\t\t             data[thr].unc_len > LZO_UNC_SIZE ||\n\t\t\t             data[thr].unc_len & (PAGE_SIZE - 1))) {\n\t\t\t\tpr_err(\"Invalid LZO uncompressed length\\n\");\n\t\t\t\tret = -1;\n\t\t\t\tgoto out_finish;\n\t\t\t}\n\n\t\t\tfor (off = 0;\n\t\t\t     off < data[thr].unc_len; off += PAGE_SIZE) {\n\t\t\t\tmemcpy(data_of(*snapshot),\n\t\t\t\t       data[thr].unc + off, PAGE_SIZE);\n\n\t\t\t\tif (!(nr_pages % m))\n\t\t\t\t\tpr_info(\"Image loading progress: %3d%%\\n\",\n\t\t\t\t\t\tnr_pages / m * 10);\n\t\t\t\tnr_pages++;\n\n\t\t\t\tret = snapshot_write_next(snapshot);\n\t\t\t\tif (ret <= 0) {\n\t\t\t\t\tcrc->run_threads = thr + 1;\n\t\t\t\t\tatomic_set(&crc->ready, 1);\n\t\t\t\t\twake_up(&crc->go);\n\t\t\t\t\tgoto out_finish;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcrc->run_threads = thr;\n\t\tatomic_set(&crc->ready, 1);\n\t\twake_up(&crc->go);\n\t}\n\nout_finish:\n\tif (crc->run_threads) {\n\t\twait_event(crc->done, atomic_read(&crc->stop));\n\t\tatomic_set(&crc->stop, 0);\n\t}\n\tstop = ktime_get();\n\tif (!ret) {\n\t\tpr_info(\"Image loading done\\n\");\n\t\tsnapshot_write_finalize(snapshot);\n\t\tif (!snapshot_image_loaded(snapshot))\n\t\t\tret = -ENODATA;\n\t\tif (!ret) {\n\t\t\tif (swsusp_header->flags & SF_CRC32_MODE) {\n\t\t\t\tif(handle->crc32 != swsusp_header->crc32) {\n\t\t\t\t\tpr_err(\"Invalid image CRC32!\\n\");\n\t\t\t\t\tret = -ENODATA;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tswsusp_show_speed(start, stop, nr_to_read, \"Read\");\nout_clean:\n\thib_finish_batch(&hb);\n\tfor (i = 0; i < ring_size; i++)\n\t\tfree_page((unsigned long)page[i]);\n\tif (crc) {\n\t\tif (crc->thr)\n\t\t\tkthread_stop(crc->thr);\n\t\tkfree(crc);\n\t}\n\tif (data) {\n\t\tfor (thr = 0; thr < nr_threads; thr++)\n\t\t\tif (data[thr].thr)\n\t\t\t\tkthread_stop(data[thr].thr);\n\t\tvfree(data);\n\t}\n\tvfree(page);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/ktime.h>",
      "#include <linux/crc32.h>",
      "#include <linux/kthread.h>",
      "#include <linux/atomic.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/lzo.h>",
      "#include <linux/slab.h>",
      "#include <linux/pm.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include <linux/device.h>",
      "#include <linux/genhd.h>",
      "#include <linux/bitops.h>",
      "#include <linux/delay.h>",
      "#include <linux/file.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define LZO_MAX_RD_PAGES\t8192",
      "#define LZO_MIN_RD_PAGES\t1024",
      "#define LZO_THREADS\t3",
      "#define LZO_CMP_PAGES\tDIV_ROUND_UP(lzo1x_worst_compress(LZO_UNC_SIZE) + \\\n\t\t\t             LZO_HEADER, PAGE_SIZE)",
      "#define LZO_UNC_SIZE\t(LZO_UNC_PAGES * PAGE_SIZE)",
      "#define LZO_HEADER\tsizeof(size_t)"
    ],
    "globals_used": [
      "static bool clean_pages_on_decompress;",
      "static struct swsusp_header *swsusp_header;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vfree",
          "args": [
            "page"
          ],
          "line": 1475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vfree",
          "args": [
            "data"
          ],
          "line": 1473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kthread_stop",
          "args": [
            "data[thr].thr"
          ],
          "line": 1472
        },
        "resolved": true,
        "details": {
          "function_name": "kthread_stop",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
          "lines": "697-715",
          "snippet": "int kthread_stop(struct task_struct *k)\n{\n\tstruct kthread *kthread;\n\tint ret;\n\n\ttrace_sched_kthread_stop(k);\n\n\tget_task_struct(k);\n\tkthread = to_kthread(k);\n\tset_bit(KTHREAD_SHOULD_STOP, &kthread->flags);\n\tkthread_unpark(k);\n\twake_up_process(k);\n\twait_for_completion(&kthread->exited);\n\tret = kthread->result;\n\tput_task_struct(k);\n\n\ttrace_sched_kthread_stop_ret(ret);\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/numa.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mm.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nint kthread_stop(struct task_struct *k)\n{\n\tstruct kthread *kthread;\n\tint ret;\n\n\ttrace_sched_kthread_stop(k);\n\n\tget_task_struct(k);\n\tkthread = to_kthread(k);\n\tset_bit(KTHREAD_SHOULD_STOP, &kthread->flags);\n\tkthread_unpark(k);\n\twake_up_process(k);\n\twait_for_completion(&kthread->exited);\n\tret = kthread->result;\n\tput_task_struct(k);\n\n\ttrace_sched_kthread_stop_ret(ret);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "crc"
          ],
          "line": 1467
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_page",
          "args": [
            "(unsigned long)page[i]"
          ],
          "line": 1463
        },
        "resolved": true,
        "details": {
          "function_name": "clear_or_poison_free_page",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/snapshot.c",
          "lines": "1181-1187",
          "snippet": "static void clear_or_poison_free_page(struct page *page)\n{\n\tif (page_poisoning_enabled_static())\n\t\t__kernel_poison_pages(page, 1);\n\telse if (want_init_on_free())\n\t\tclear_highpage(page);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int swsusp_page_is_free(struct page *);",
            "static void swsusp_set_page_forbidden(struct page *);",
            "static void swsusp_unset_page_forbidden(struct page *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\nstatic int swsusp_page_is_free(struct page *);\nstatic void swsusp_set_page_forbidden(struct page *);\nstatic void swsusp_unset_page_forbidden(struct page *);\n\nstatic void clear_or_poison_free_page(struct page *page)\n{\n\tif (page_poisoning_enabled_static())\n\t\t__kernel_poison_pages(page, 1);\n\telse if (want_init_on_free())\n\t\tclear_highpage(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hib_finish_batch",
          "args": [
            "&hb"
          ],
          "line": 1461
        },
        "resolved": true,
        "details": {
          "function_name": "hib_finish_batch",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/swap.c",
          "lines": "243-246",
          "snippet": "static void hib_finish_batch(struct hib_bio_batch *hb)\n{\n\tblk_finish_plug(&hb->plug);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/ktime.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/atomic.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/lzo.h>",
            "#include <linux/slab.h>",
            "#include <linux/pm.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/device.h>",
            "#include <linux/genhd.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/file.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/ktime.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/atomic.h>\n#include <linux/cpumask.h>\n#include <linux/vmalloc.h>\n#include <linux/lzo.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/device.h>\n#include <linux/genhd.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\nstatic void hib_finish_batch(struct hib_bio_batch *hb)\n{\n\tblk_finish_plug(&hb->plug);\n}"
        }
      },
      {
        "call_info": {
          "callee": "swsusp_show_speed",
          "args": [
            "start",
            "stop",
            "nr_to_read",
            "\"Read\""
          ],
          "line": 1459
        },
        "resolved": true,
        "details": {
          "function_name": "swsusp_show_speed",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/hibernate.c",
          "lines": "254-273",
          "snippet": "void swsusp_show_speed(ktime_t start, ktime_t stop,\n\t\t      unsigned nr_pages, char *msg)\n{\n\tktime_t diff;\n\tu64 elapsed_centisecs64;\n\tunsigned int centisecs;\n\tunsigned int k;\n\tunsigned int kps;\n\n\tdiff = ktime_sub(stop, start);\n\telapsed_centisecs64 = ktime_divns(diff, 10*NSEC_PER_MSEC);\n\tcentisecs = elapsed_centisecs64;\n\tif (centisecs == 0)\n\t\tcentisecs = 1;\t/* avoid div-by-zero */\n\tk = nr_pages * (PAGE_SIZE / 1024);\n\tkps = (k * 100) / centisecs;\n\tpr_info(\"%s %u kbytes in %u.%02u seconds (%u.%02u MB/s)\\n\",\n\t\tmsg, k, centisecs / 100, centisecs % 100, kps / 1000,\n\t\t(kps % 1000) / 10);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <trace/events/power.h>",
            "#include <linux/secretmem.h>",
            "#include <linux/security.h>",
            "#include <linux/ktime.h>",
            "#include <linux/genhd.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/gfp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cpu.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/pm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/delay.h>",
            "#include <linux/async.h>",
            "#include <linux/device.h>",
            "#include <linux/string.h>",
            "#include <linux/reboot.h>",
            "#include <linux/suspend.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <trace/events/power.h>\n#include <linux/secretmem.h>\n#include <linux/security.h>\n#include <linux/ktime.h>\n#include <linux/genhd.h>\n#include <linux/ctype.h>\n#include <linux/syscore_ops.h>\n#include <linux/gfp.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/pm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/delay.h>\n#include <linux/async.h>\n#include <linux/device.h>\n#include <linux/string.h>\n#include <linux/reboot.h>\n#include <linux/suspend.h>\n#include <linux/export.h>\n\nvoid swsusp_show_speed(ktime_t start, ktime_t stop,\n\t\t      unsigned nr_pages, char *msg)\n{\n\tktime_t diff;\n\tu64 elapsed_centisecs64;\n\tunsigned int centisecs;\n\tunsigned int k;\n\tunsigned int kps;\n\n\tdiff = ktime_sub(stop, start);\n\telapsed_centisecs64 = ktime_divns(diff, 10*NSEC_PER_MSEC);\n\tcentisecs = elapsed_centisecs64;\n\tif (centisecs == 0)\n\t\tcentisecs = 1;\t/* avoid div-by-zero */\n\tk = nr_pages * (PAGE_SIZE / 1024);\n\tkps = (k * 100) / centisecs;\n\tpr_info(\"%s %u kbytes in %u.%02u seconds (%u.%02u MB/s)\\n\",\n\t\tmsg, k, centisecs / 100, centisecs % 100, kps / 1000,\n\t\t(kps % 1000) / 10);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Invalid image CRC32!\\n\""
          ],
          "line": 1453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snapshot_image_loaded",
          "args": [
            "snapshot"
          ],
          "line": 1448
        },
        "resolved": true,
        "details": {
          "function_name": "snapshot_image_loaded",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/snapshot.c",
          "lines": "2710-2714",
          "snippet": "int snapshot_image_loaded(struct snapshot_handle *handle)\n{\n\treturn !(!nr_copy_pages || !last_highmem_page_copied() ||\n\t\t\thandle->cur <= nr_meta_pages + nr_copy_pages);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned int nr_copy_pages;",
            "static unsigned int nr_meta_pages;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\nstatic unsigned int nr_copy_pages;\nstatic unsigned int nr_meta_pages;\n\nint snapshot_image_loaded(struct snapshot_handle *handle)\n{\n\treturn !(!nr_copy_pages || !last_highmem_page_copied() ||\n\t\t\thandle->cur <= nr_meta_pages + nr_copy_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "snapshot_write_finalize",
          "args": [
            "snapshot"
          ],
          "line": 1447
        },
        "resolved": true,
        "details": {
          "function_name": "snapshot_write_finalize",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/snapshot.c",
          "lines": "2699-2708",
          "snippet": "void snapshot_write_finalize(struct snapshot_handle *handle)\n{\n\tcopy_last_highmem_page();\n\thibernate_restore_protect_page(handle->buffer);\n\t/* Do that only if we have loaded the image entirely */\n\tif (handle->cur > 1 && handle->cur > nr_meta_pages + nr_copy_pages) {\n\t\tmemory_bm_recycle(&orig_bm);\n\t\tfree_highmem_data();\n\t}\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void *buffer;",
            "static unsigned int nr_copy_pages;",
            "static unsigned int nr_meta_pages;",
            "static struct memory_bitmap orig_bm;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\nstatic void *buffer;\nstatic unsigned int nr_copy_pages;\nstatic unsigned int nr_meta_pages;\nstatic struct memory_bitmap orig_bm;\n\nvoid snapshot_write_finalize(struct snapshot_handle *handle)\n{\n\tcopy_last_highmem_page();\n\thibernate_restore_protect_page(handle->buffer);\n\t/* Do that only if we have loaded the image entirely */\n\tif (handle->cur > 1 && handle->cur > nr_meta_pages + nr_copy_pages) {\n\t\tmemory_bm_recycle(&orig_bm);\n\t\tfree_highmem_data();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Image loading done\\n\""
          ],
          "line": 1446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_get",
          "args": [],
          "line": 1444
        },
        "resolved": true,
        "details": {
          "function_name": "__ktime_get_real_seconds",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
          "lines": "1025-1030",
          "snippet": "noinstr time64_t __ktime_get_real_seconds(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\n\treturn tk->xtime_sec;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nnoinstr time64_t __ktime_get_real_seconds(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\n\treturn tk->xtime_sec;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&crc->stop",
            "0"
          ],
          "line": 1442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_event",
          "args": [
            "crc->done",
            "atomic_read(&crc->stop)"
          ],
          "line": 1441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&crc->stop"
          ],
          "line": 1441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wake_up",
          "args": [
            "&crc->go"
          ],
          "line": 1436
        },
        "resolved": true,
        "details": {
          "function_name": "wake_up_worker",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "847-853",
          "snippet": "static void wake_up_worker(struct worker_pool *pool)\n{\n\tstruct worker *worker = first_idle_worker(pool);\n\n\tif (likely(worker))\n\t\twake_up_process(worker->task);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
            "static void show_one_worker_pool(struct worker_pool *pool);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nstatic void wake_up_worker(struct worker_pool *pool)\n{\n\tstruct worker *worker = first_idle_worker(pool);\n\n\tif (likely(worker))\n\t\twake_up_process(worker->task);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&crc->ready",
            "1"
          ],
          "line": 1435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&crc->ready",
            "1"
          ],
          "line": 1427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snapshot_write_next",
          "args": [
            "snapshot"
          ],
          "line": 1424
        },
        "resolved": true,
        "details": {
          "function_name": "snapshot_write_next",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/snapshot.c",
          "lines": "2628-2689",
          "snippet": "int snapshot_write_next(struct snapshot_handle *handle)\n{\n\tstatic struct chain_allocator ca;\n\tint error = 0;\n\n\t/* Check if we have already loaded the entire image */\n\tif (handle->cur > 1 && handle->cur > nr_meta_pages + nr_copy_pages)\n\t\treturn 0;\n\n\thandle->sync_read = 1;\n\n\tif (!handle->cur) {\n\t\tif (!buffer)\n\t\t\t/* This makes the buffer be freed by swsusp_free() */\n\t\t\tbuffer = get_image_page(GFP_ATOMIC, PG_ANY);\n\n\t\tif (!buffer)\n\t\t\treturn -ENOMEM;\n\n\t\thandle->buffer = buffer;\n\t} else if (handle->cur == 1) {\n\t\terror = load_header(buffer);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\tsafe_pages_list = NULL;\n\n\t\terror = memory_bm_create(&copy_bm, GFP_ATOMIC, PG_ANY);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\thibernate_restore_protection_begin();\n\t} else if (handle->cur <= nr_meta_pages + 1) {\n\t\terror = unpack_orig_pfns(buffer, &copy_bm);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\tif (handle->cur == nr_meta_pages + 1) {\n\t\t\terror = prepare_image(&orig_bm, &copy_bm);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\n\t\t\tchain_init(&ca, GFP_ATOMIC, PG_SAFE);\n\t\t\tmemory_bm_position_reset(&orig_bm);\n\t\t\trestore_pblist = NULL;\n\t\t\thandle->buffer = get_buffer(&orig_bm, &ca);\n\t\t\thandle->sync_read = 0;\n\t\t\tif (IS_ERR(handle->buffer))\n\t\t\t\treturn PTR_ERR(handle->buffer);\n\t\t}\n\t} else {\n\t\tcopy_last_highmem_page();\n\t\thibernate_restore_protect_page(handle->buffer);\n\t\thandle->buffer = get_buffer(&orig_bm, &ca);\n\t\tif (IS_ERR(handle->buffer))\n\t\t\treturn PTR_ERR(handle->buffer);\n\t\tif (handle->buffer != buffer)\n\t\t\thandle->sync_read = 0;\n\t}\n\thandle->cur++;\n\treturn PAGE_SIZE;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [
            "#define PG_SAFE\t\t1",
            "#define PG_ANY\t\t0"
          ],
          "globals_used": [
            "struct pbe *restore_pblist;",
            "static struct linked_page *safe_pages_list;",
            "static void *buffer;",
            "static unsigned int nr_copy_pages;",
            "static unsigned int nr_meta_pages;",
            "static struct memory_bitmap orig_bm;",
            "static struct memory_bitmap copy_bm;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\n#define PG_SAFE\t\t1\n#define PG_ANY\t\t0\n\nstruct pbe *restore_pblist;\nstatic struct linked_page *safe_pages_list;\nstatic void *buffer;\nstatic unsigned int nr_copy_pages;\nstatic unsigned int nr_meta_pages;\nstatic struct memory_bitmap orig_bm;\nstatic struct memory_bitmap copy_bm;\n\nint snapshot_write_next(struct snapshot_handle *handle)\n{\n\tstatic struct chain_allocator ca;\n\tint error = 0;\n\n\t/* Check if we have already loaded the entire image */\n\tif (handle->cur > 1 && handle->cur > nr_meta_pages + nr_copy_pages)\n\t\treturn 0;\n\n\thandle->sync_read = 1;\n\n\tif (!handle->cur) {\n\t\tif (!buffer)\n\t\t\t/* This makes the buffer be freed by swsusp_free() */\n\t\t\tbuffer = get_image_page(GFP_ATOMIC, PG_ANY);\n\n\t\tif (!buffer)\n\t\t\treturn -ENOMEM;\n\n\t\thandle->buffer = buffer;\n\t} else if (handle->cur == 1) {\n\t\terror = load_header(buffer);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\tsafe_pages_list = NULL;\n\n\t\terror = memory_bm_create(&copy_bm, GFP_ATOMIC, PG_ANY);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\thibernate_restore_protection_begin();\n\t} else if (handle->cur <= nr_meta_pages + 1) {\n\t\terror = unpack_orig_pfns(buffer, &copy_bm);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\tif (handle->cur == nr_meta_pages + 1) {\n\t\t\terror = prepare_image(&orig_bm, &copy_bm);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\n\t\t\tchain_init(&ca, GFP_ATOMIC, PG_SAFE);\n\t\t\tmemory_bm_position_reset(&orig_bm);\n\t\t\trestore_pblist = NULL;\n\t\t\thandle->buffer = get_buffer(&orig_bm, &ca);\n\t\t\thandle->sync_read = 0;\n\t\t\tif (IS_ERR(handle->buffer))\n\t\t\t\treturn PTR_ERR(handle->buffer);\n\t\t}\n\t} else {\n\t\tcopy_last_highmem_page();\n\t\thibernate_restore_protect_page(handle->buffer);\n\t\thandle->buffer = get_buffer(&orig_bm, &ca);\n\t\tif (IS_ERR(handle->buffer))\n\t\t\treturn PTR_ERR(handle->buffer);\n\t\tif (handle->buffer != buffer)\n\t\t\thandle->sync_read = 0;\n\t}\n\thandle->cur++;\n\treturn PAGE_SIZE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Image loading progress: %3d%%\\n\"",
            "nr_pages / m * 10"
          ],
          "line": 1420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "data_of(*snapshot)",
            "data[thr].unc + off",
            "PAGE_SIZE"
          ],
          "line": 1416
        },
        "resolved": true,
        "details": {
          "function_name": "memcpy_skip",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/internal.h",
          "lines": "180-184",
          "snippet": "static inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/refcount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/refcount.h>\n#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n\nstatic inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "data_of",
          "args": [
            "*snapshot"
          ],
          "line": 1416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Invalid LZO uncompressed length\\n\""
          ],
          "line": 1409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!data[thr].unc_len ||\n\t\t\t             data[thr].unc_len > LZO_UNC_SIZE ||\n\t\t\t             data[thr].unc_len & (PAGE_SIZE - 1)"
          ],
          "line": 1406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"LZO decompression failed\\n\""
          ],
          "line": 1402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&data[thr].stop",
            "0"
          ],
          "line": 1397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_event",
          "args": [
            "data[thr].done",
            "atomic_read(&data[thr].stop)"
          ],
          "line": 1395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&data[thr].stop"
          ],
          "line": 1396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hib_wait_io",
          "args": [
            "&hb"
          ],
          "line": 1385
        },
        "resolved": true,
        "details": {
          "function_name": "hib_wait_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/swap.c",
          "lines": "305-313",
          "snippet": "static int hib_wait_io(struct hib_bio_batch *hb)\n{\n\t/*\n\t * We are relying on the behavior of blk_plug that a thread with\n\t * a plug will flush the plug list before sleeping.\n\t */\n\twait_event(hb->wait, atomic_read(&hb->count) == 0);\n\treturn blk_status_to_errno(hb->error);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/ktime.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/atomic.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/lzo.h>",
            "#include <linux/slab.h>",
            "#include <linux/pm.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/device.h>",
            "#include <linux/genhd.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/file.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/ktime.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/atomic.h>\n#include <linux/cpumask.h>\n#include <linux/vmalloc.h>\n#include <linux/lzo.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/device.h>\n#include <linux/genhd.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\nstatic int hib_wait_io(struct hib_bio_batch *hb)\n{\n\t/*\n\t * We are relying on the behavior of blk_plug that a thread with\n\t * a plug will flush the plug list before sleeping.\n\t */\n\twait_event(hb->wait, atomic_read(&hb->count) == 0);\n\treturn blk_status_to_errno(hb->error);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&data[thr].ready",
            "1"
          ],
          "line": 1377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DIV_ROUND_UP",
          "args": [
            "data[thr].cmp_len + LZO_HEADER",
            "PAGE_SIZE"
          ],
          "line": 1356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Invalid LZO compressed length\\n\""
          ],
          "line": 1351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!data[thr].cmp_len ||\n\t\t\t             data[thr].cmp_len >\n\t\t\t             lzo1x_worst_compress(LZO_UNC_SIZE)"
          ],
          "line": 1348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lzo1x_worst_compress",
          "args": [
            "LZO_UNC_SIZE"
          ],
          "line": 1350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&crc->stop",
            "0"
          ],
          "line": 1342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_event",
          "args": [
            "crc->done",
            "atomic_read(&crc->stop)"
          ],
          "line": 1341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&crc->stop"
          ],
          "line": 1341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swap_read_page",
          "args": [
            "handle",
            "page[ring]",
            "&hb"
          ],
          "line": 1304
        },
        "resolved": true,
        "details": {
          "function_name": "swap_read_page",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/swap.c",
          "lines": "1020-1047",
          "snippet": "static int swap_read_page(struct swap_map_handle *handle, void *buf,\n\t\tstruct hib_bio_batch *hb)\n{\n\tsector_t offset;\n\tint error;\n\tstruct swap_map_page_list *tmp;\n\n\tif (!handle->cur)\n\t\treturn -EINVAL;\n\toffset = handle->cur->entries[handle->k];\n\tif (!offset)\n\t\treturn -EFAULT;\n\terror = hib_submit_io(REQ_OP_READ, 0, offset, buf, hb);\n\tif (error)\n\t\treturn error;\n\tif (++handle->k >= MAP_PAGE_ENTRIES) {\n\t\thandle->k = 0;\n\t\tfree_page((unsigned long)handle->maps->map);\n\t\ttmp = handle->maps;\n\t\thandle->maps = handle->maps->next;\n\t\tkfree(tmp);\n\t\tif (!handle->maps)\n\t\t\trelease_swap_reader(handle);\n\t\telse\n\t\t\thandle->cur = handle->maps->map;\n\t}\n\treturn error;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/ktime.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/atomic.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/lzo.h>",
            "#include <linux/slab.h>",
            "#include <linux/pm.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/device.h>",
            "#include <linux/genhd.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/file.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define MAP_PAGE_ENTRIES\t(PAGE_SIZE / sizeof(sector_t) - 1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/ktime.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/atomic.h>\n#include <linux/cpumask.h>\n#include <linux/vmalloc.h>\n#include <linux/lzo.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/device.h>\n#include <linux/genhd.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\n#define MAP_PAGE_ENTRIES\t(PAGE_SIZE / sizeof(sector_t) - 1)\n\nstatic int swap_read_page(struct swap_map_handle *handle, void *buf,\n\t\tstruct hib_bio_batch *hb)\n{\n\tsector_t offset;\n\tint error;\n\tstruct swap_map_page_list *tmp;\n\n\tif (!handle->cur)\n\t\treturn -EINVAL;\n\toffset = handle->cur->entries[handle->k];\n\tif (!offset)\n\t\treturn -EFAULT;\n\terror = hib_submit_io(REQ_OP_READ, 0, offset, buf, hb);\n\tif (error)\n\t\treturn error;\n\tif (++handle->k >= MAP_PAGE_ENTRIES) {\n\t\thandle->k = 0;\n\t\tfree_page((unsigned long)handle->maps->map);\n\t\ttmp = handle->maps;\n\t\thandle->maps = handle->maps->next;\n\t\tkfree(tmp);\n\t\tif (!handle->maps)\n\t\t\trelease_swap_reader(handle);\n\t\telse\n\t\t\thandle->cur = handle->maps->map;\n\t}\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Loading and decompressing image data (%u pages)...\\n\"",
            "nr_to_read"
          ],
          "line": 1290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Using %u thread(s) for decompression\\n\"",
            "nr_threads"
          ],
          "line": 1289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Failed to allocate LZO pages\\n\""
          ],
          "line": 1279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_free_page",
          "args": [
            "i < LZO_CMP_PAGES ?\n\t\t\t\t\t\t  GFP_NOIO | __GFP_HIGH :\n\t\t\t\t\t\t  GFP_NOIO | __GFP_NOWARN |\n\t\t\t\t\t\t  __GFP_NORETRY"
          ],
          "line": 1271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clamp_val",
          "args": [
            "read_pages",
            "LZO_MIN_RD_PAGES",
            "LZO_MAX_RD_PAGES"
          ],
          "line": 1268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snapshot_get_image_size",
          "args": [],
          "line": 1267
        },
        "resolved": true,
        "details": {
          "function_name": "snapshot_get_image_size",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/snapshot.c",
          "lines": "2084-2087",
          "snippet": "unsigned long snapshot_get_image_size(void)\n{\n\treturn nr_copy_pages + nr_meta_pages + 1;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned int nr_copy_pages;",
            "static unsigned int nr_meta_pages;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\nstatic unsigned int nr_copy_pages;\nstatic unsigned int nr_meta_pages;\n\nunsigned long snapshot_get_image_size(void)\n{\n\treturn nr_copy_pages + nr_meta_pages + 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "low_free_pages",
          "args": [],
          "line": 1267
        },
        "resolved": true,
        "details": {
          "function_name": "low_free_pages",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/swap.c",
          "lines": "68-71",
          "snippet": "static inline unsigned long low_free_pages(void)\n{\n\treturn nr_free_pages() - nr_free_highpages();\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/ktime.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/atomic.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/lzo.h>",
            "#include <linux/slab.h>",
            "#include <linux/pm.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/device.h>",
            "#include <linux/genhd.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/file.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/ktime.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/atomic.h>\n#include <linux/cpumask.h>\n#include <linux/vmalloc.h>\n#include <linux/lzo.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/device.h>\n#include <linux/genhd.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\nstatic inline unsigned long low_free_pages(void)\n{\n\treturn nr_free_pages() - nr_free_highpages();\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Cannot start CRC32 thread\\n\""
          ],
          "line": 1254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "crc->thr"
          ],
          "line": 1252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kthread_run",
          "args": [
            "crc32_threadfn",
            "crc",
            "\"image_crc32\""
          ],
          "line": 1251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_waitqueue_head",
          "args": [
            "&crc->done"
          ],
          "line": 1242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_waitqueue_head",
          "args": [
            "&crc->go"
          ],
          "line": 1241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Cannot start decompression threads\\n\""
          ],
          "line": 1232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "data[thr].thr"
          ],
          "line": 1230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kthread_run",
          "args": [
            "lzo_decompress_threadfn",
            "&data[thr]",
            "\"image_decompress/%u\"",
            "thr"
          ],
          "line": 1227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_waitqueue_head",
          "args": [
            "&data[thr].done"
          ],
          "line": 1225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_waitqueue_head",
          "args": [
            "&data[thr].go"
          ],
          "line": 1224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Failed to allocate crc\\n\""
          ],
          "line": 1213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*crc)",
            "GFP_KERNEL"
          ],
          "line": 1211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Failed to allocate LZO data\\n\""
          ],
          "line": 1206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vzalloc",
          "args": [
            "array_size(nr_threads, sizeof(*data))"
          ],
          "line": 1204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "array_size",
          "args": [
            "nr_threads",
            "sizeof(*data)"
          ],
          "line": 1204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Failed to allocate LZO page\\n\""
          ],
          "line": 1199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vmalloc",
          "args": [
            "array_size(LZO_MAX_RD_PAGES, sizeof(*page))"
          ],
          "line": 1197
        },
        "resolved": true,
        "details": {
          "function_name": "array_map_vmalloc_addr",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/arraymap.c",
          "lines": "379-382",
          "snippet": "static void *array_map_vmalloc_addr(struct bpf_array *array)\n{\n\treturn (void *)round_down((unsigned long)array, PAGE_SIZE);\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/filter.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include <linux/rcupdate_trace.h>\n#include <uapi/linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/filter.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic void *array_map_vmalloc_addr(struct bpf_array *array)\n{\n\treturn (void *)round_down((unsigned long)array, PAGE_SIZE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "array_size",
          "args": [
            "LZO_MAX_RD_PAGES",
            "sizeof(*page)"
          ],
          "line": 1197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clamp_val",
          "args": [
            "nr_threads",
            "1",
            "LZO_THREADS"
          ],
          "line": 1195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "num_online_cpus",
          "args": [],
          "line": 1194
        },
        "resolved": true,
        "details": {
          "function_name": "torture_num_online_cpus",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/torture.c",
          "lines": "185-188",
          "snippet": "int torture_num_online_cpus(void)\n{\n\treturn READ_ONCE(torture_online_cpus);\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint torture_num_online_cpus(void)\n{\n\treturn READ_ONCE(torture_online_cpus);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hib_init_batch",
          "args": [
            "&hb"
          ],
          "line": 1188
        },
        "resolved": true,
        "details": {
          "function_name": "hib_init_batch",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/swap.c",
          "lines": "235-241",
          "snippet": "static void hib_init_batch(struct hib_bio_batch *hb)\n{\n\tatomic_set(&hb->count, 0);\n\tinit_waitqueue_head(&hb->wait);\n\thb->error = BLK_STS_OK;\n\tblk_start_plug(&hb->plug);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/ktime.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/atomic.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/lzo.h>",
            "#include <linux/slab.h>",
            "#include <linux/pm.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/device.h>",
            "#include <linux/genhd.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/file.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/ktime.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/atomic.h>\n#include <linux/cpumask.h>\n#include <linux/vmalloc.h>\n#include <linux/lzo.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/device.h>\n#include <linux/genhd.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\nstatic void hib_init_batch(struct hib_bio_batch *hb)\n{\n\tatomic_set(&hb->count, 0);\n\tinit_waitqueue_head(&hb->wait);\n\thb->error = BLK_STS_OK;\n\tblk_start_plug(&hb->plug);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/ktime.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/atomic.h>\n#include <linux/cpumask.h>\n#include <linux/vmalloc.h>\n#include <linux/lzo.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/device.h>\n#include <linux/genhd.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\n#define LZO_MAX_RD_PAGES\t8192\n#define LZO_MIN_RD_PAGES\t1024\n#define LZO_THREADS\t3\n#define LZO_CMP_PAGES\tDIV_ROUND_UP(lzo1x_worst_compress(LZO_UNC_SIZE) + \\\n\t\t\t             LZO_HEADER, PAGE_SIZE)\n#define LZO_UNC_SIZE\t(LZO_UNC_PAGES * PAGE_SIZE)\n#define LZO_HEADER\tsizeof(size_t)\n\nstatic bool clean_pages_on_decompress;\nstatic struct swsusp_header *swsusp_header;\n\nstatic int load_image_lzo(struct swap_map_handle *handle,\n                          struct snapshot_handle *snapshot,\n                          unsigned int nr_to_read)\n{\n\tunsigned int m;\n\tint ret = 0;\n\tint eof = 0;\n\tstruct hib_bio_batch hb;\n\tktime_t start;\n\tktime_t stop;\n\tunsigned nr_pages;\n\tsize_t off;\n\tunsigned i, thr, run_threads, nr_threads;\n\tunsigned ring = 0, pg = 0, ring_size = 0,\n\t         have = 0, want, need, asked = 0;\n\tunsigned long read_pages = 0;\n\tunsigned char **page = NULL;\n\tstruct dec_data *data = NULL;\n\tstruct crc_data *crc = NULL;\n\n\thib_init_batch(&hb);\n\n\t/*\n\t * We'll limit the number of threads for decompression to limit memory\n\t * footprint.\n\t */\n\tnr_threads = num_online_cpus() - 1;\n\tnr_threads = clamp_val(nr_threads, 1, LZO_THREADS);\n\n\tpage = vmalloc(array_size(LZO_MAX_RD_PAGES, sizeof(*page)));\n\tif (!page) {\n\t\tpr_err(\"Failed to allocate LZO page\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto out_clean;\n\t}\n\n\tdata = vzalloc(array_size(nr_threads, sizeof(*data)));\n\tif (!data) {\n\t\tpr_err(\"Failed to allocate LZO data\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto out_clean;\n\t}\n\n\tcrc = kzalloc(sizeof(*crc), GFP_KERNEL);\n\tif (!crc) {\n\t\tpr_err(\"Failed to allocate crc\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto out_clean;\n\t}\n\n\tclean_pages_on_decompress = true;\n\n\t/*\n\t * Start the decompression threads.\n\t */\n\tfor (thr = 0; thr < nr_threads; thr++) {\n\t\tinit_waitqueue_head(&data[thr].go);\n\t\tinit_waitqueue_head(&data[thr].done);\n\n\t\tdata[thr].thr = kthread_run(lzo_decompress_threadfn,\n\t\t                            &data[thr],\n\t\t                            \"image_decompress/%u\", thr);\n\t\tif (IS_ERR(data[thr].thr)) {\n\t\t\tdata[thr].thr = NULL;\n\t\t\tpr_err(\"Cannot start decompression threads\\n\");\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out_clean;\n\t\t}\n\t}\n\n\t/*\n\t * Start the CRC32 thread.\n\t */\n\tinit_waitqueue_head(&crc->go);\n\tinit_waitqueue_head(&crc->done);\n\n\thandle->crc32 = 0;\n\tcrc->crc32 = &handle->crc32;\n\tfor (thr = 0; thr < nr_threads; thr++) {\n\t\tcrc->unc[thr] = data[thr].unc;\n\t\tcrc->unc_len[thr] = &data[thr].unc_len;\n\t}\n\n\tcrc->thr = kthread_run(crc32_threadfn, crc, \"image_crc32\");\n\tif (IS_ERR(crc->thr)) {\n\t\tcrc->thr = NULL;\n\t\tpr_err(\"Cannot start CRC32 thread\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto out_clean;\n\t}\n\n\t/*\n\t * Set the number of pages for read buffering.\n\t * This is complete guesswork, because we'll only know the real\n\t * picture once prepare_image() is called, which is much later on\n\t * during the image load phase. We'll assume the worst case and\n\t * say that none of the image pages are from high memory.\n\t */\n\tif (low_free_pages() > snapshot_get_image_size())\n\t\tread_pages = (low_free_pages() - snapshot_get_image_size()) / 2;\n\tread_pages = clamp_val(read_pages, LZO_MIN_RD_PAGES, LZO_MAX_RD_PAGES);\n\n\tfor (i = 0; i < read_pages; i++) {\n\t\tpage[i] = (void *)__get_free_page(i < LZO_CMP_PAGES ?\n\t\t\t\t\t\t  GFP_NOIO | __GFP_HIGH :\n\t\t\t\t\t\t  GFP_NOIO | __GFP_NOWARN |\n\t\t\t\t\t\t  __GFP_NORETRY);\n\n\t\tif (!page[i]) {\n\t\t\tif (i < LZO_CMP_PAGES) {\n\t\t\t\tring_size = i;\n\t\t\t\tpr_err(\"Failed to allocate LZO pages\\n\");\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto out_clean;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\twant = ring_size = i;\n\n\tpr_info(\"Using %u thread(s) for decompression\\n\", nr_threads);\n\tpr_info(\"Loading and decompressing image data (%u pages)...\\n\",\n\t\tnr_to_read);\n\tm = nr_to_read / 10;\n\tif (!m)\n\t\tm = 1;\n\tnr_pages = 0;\n\tstart = ktime_get();\n\n\tret = snapshot_write_next(snapshot);\n\tif (ret <= 0)\n\t\tgoto out_finish;\n\n\tfor(;;) {\n\t\tfor (i = 0; !eof && i < want; i++) {\n\t\t\tret = swap_read_page(handle, page[ring], &hb);\n\t\t\tif (ret) {\n\t\t\t\t/*\n\t\t\t\t * On real read error, finish. On end of data,\n\t\t\t\t * set EOF flag and just exit the read loop.\n\t\t\t\t */\n\t\t\t\tif (handle->cur &&\n\t\t\t\t    handle->cur->entries[handle->k]) {\n\t\t\t\t\tgoto out_finish;\n\t\t\t\t} else {\n\t\t\t\t\teof = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (++ring >= ring_size)\n\t\t\t\tring = 0;\n\t\t}\n\t\tasked += i;\n\t\twant -= i;\n\n\t\t/*\n\t\t * We are out of data, wait for some more.\n\t\t */\n\t\tif (!have) {\n\t\t\tif (!asked)\n\t\t\t\tbreak;\n\n\t\t\tret = hib_wait_io(&hb);\n\t\t\tif (ret)\n\t\t\t\tgoto out_finish;\n\t\t\thave += asked;\n\t\t\tasked = 0;\n\t\t\tif (eof)\n\t\t\t\teof = 2;\n\t\t}\n\n\t\tif (crc->run_threads) {\n\t\t\twait_event(crc->done, atomic_read(&crc->stop));\n\t\t\tatomic_set(&crc->stop, 0);\n\t\t\tcrc->run_threads = 0;\n\t\t}\n\n\t\tfor (thr = 0; have && thr < nr_threads; thr++) {\n\t\t\tdata[thr].cmp_len = *(size_t *)page[pg];\n\t\t\tif (unlikely(!data[thr].cmp_len ||\n\t\t\t             data[thr].cmp_len >\n\t\t\t             lzo1x_worst_compress(LZO_UNC_SIZE))) {\n\t\t\t\tpr_err(\"Invalid LZO compressed length\\n\");\n\t\t\t\tret = -1;\n\t\t\t\tgoto out_finish;\n\t\t\t}\n\n\t\t\tneed = DIV_ROUND_UP(data[thr].cmp_len + LZO_HEADER,\n\t\t\t                    PAGE_SIZE);\n\t\t\tif (need > have) {\n\t\t\t\tif (eof > 1) {\n\t\t\t\t\tret = -1;\n\t\t\t\t\tgoto out_finish;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tfor (off = 0;\n\t\t\t     off < LZO_HEADER + data[thr].cmp_len;\n\t\t\t     off += PAGE_SIZE) {\n\t\t\t\tmemcpy(data[thr].cmp + off,\n\t\t\t\t       page[pg], PAGE_SIZE);\n\t\t\t\thave--;\n\t\t\t\twant++;\n\t\t\t\tif (++pg >= ring_size)\n\t\t\t\t\tpg = 0;\n\t\t\t}\n\n\t\t\tatomic_set(&data[thr].ready, 1);\n\t\t\twake_up(&data[thr].go);\n\t\t}\n\n\t\t/*\n\t\t * Wait for more data while we are decompressing.\n\t\t */\n\t\tif (have < LZO_CMP_PAGES && asked) {\n\t\t\tret = hib_wait_io(&hb);\n\t\t\tif (ret)\n\t\t\t\tgoto out_finish;\n\t\t\thave += asked;\n\t\t\tasked = 0;\n\t\t\tif (eof)\n\t\t\t\teof = 2;\n\t\t}\n\n\t\tfor (run_threads = thr, thr = 0; thr < run_threads; thr++) {\n\t\t\twait_event(data[thr].done,\n\t\t\t           atomic_read(&data[thr].stop));\n\t\t\tatomic_set(&data[thr].stop, 0);\n\n\t\t\tret = data[thr].ret;\n\n\t\t\tif (ret < 0) {\n\t\t\t\tpr_err(\"LZO decompression failed\\n\");\n\t\t\t\tgoto out_finish;\n\t\t\t}\n\n\t\t\tif (unlikely(!data[thr].unc_len ||\n\t\t\t             data[thr].unc_len > LZO_UNC_SIZE ||\n\t\t\t             data[thr].unc_len & (PAGE_SIZE - 1))) {\n\t\t\t\tpr_err(\"Invalid LZO uncompressed length\\n\");\n\t\t\t\tret = -1;\n\t\t\t\tgoto out_finish;\n\t\t\t}\n\n\t\t\tfor (off = 0;\n\t\t\t     off < data[thr].unc_len; off += PAGE_SIZE) {\n\t\t\t\tmemcpy(data_of(*snapshot),\n\t\t\t\t       data[thr].unc + off, PAGE_SIZE);\n\n\t\t\t\tif (!(nr_pages % m))\n\t\t\t\t\tpr_info(\"Image loading progress: %3d%%\\n\",\n\t\t\t\t\t\tnr_pages / m * 10);\n\t\t\t\tnr_pages++;\n\n\t\t\t\tret = snapshot_write_next(snapshot);\n\t\t\t\tif (ret <= 0) {\n\t\t\t\t\tcrc->run_threads = thr + 1;\n\t\t\t\t\tatomic_set(&crc->ready, 1);\n\t\t\t\t\twake_up(&crc->go);\n\t\t\t\t\tgoto out_finish;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcrc->run_threads = thr;\n\t\tatomic_set(&crc->ready, 1);\n\t\twake_up(&crc->go);\n\t}\n\nout_finish:\n\tif (crc->run_threads) {\n\t\twait_event(crc->done, atomic_read(&crc->stop));\n\t\tatomic_set(&crc->stop, 0);\n\t}\n\tstop = ktime_get();\n\tif (!ret) {\n\t\tpr_info(\"Image loading done\\n\");\n\t\tsnapshot_write_finalize(snapshot);\n\t\tif (!snapshot_image_loaded(snapshot))\n\t\t\tret = -ENODATA;\n\t\tif (!ret) {\n\t\t\tif (swsusp_header->flags & SF_CRC32_MODE) {\n\t\t\t\tif(handle->crc32 != swsusp_header->crc32) {\n\t\t\t\t\tpr_err(\"Invalid image CRC32!\\n\");\n\t\t\t\t\tret = -ENODATA;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tswsusp_show_speed(start, stop, nr_to_read, \"Read\");\nout_clean:\n\thib_finish_batch(&hb);\n\tfor (i = 0; i < ring_size; i++)\n\t\tfree_page((unsigned long)page[i]);\n\tif (crc) {\n\t\tif (crc->thr)\n\t\t\tkthread_stop(crc->thr);\n\t\tkfree(crc);\n\t}\n\tif (data) {\n\t\tfor (thr = 0; thr < nr_threads; thr++)\n\t\t\tif (data[thr].thr)\n\t\t\t\tkthread_stop(data[thr].thr);\n\t\tvfree(data);\n\t}\n\tvfree(page);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "lzo_decompress_threadfn",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/swap.c",
    "lines": "1133-1160",
    "snippet": "static int lzo_decompress_threadfn(void *data)\n{\n\tstruct dec_data *d = data;\n\n\twhile (1) {\n\t\twait_event(d->go, atomic_read(&d->ready) ||\n\t\t                  kthread_should_stop());\n\t\tif (kthread_should_stop()) {\n\t\t\td->thr = NULL;\n\t\t\td->ret = -1;\n\t\t\tatomic_set(&d->stop, 1);\n\t\t\twake_up(&d->done);\n\t\t\tbreak;\n\t\t}\n\t\tatomic_set(&d->ready, 0);\n\n\t\td->unc_len = LZO_UNC_SIZE;\n\t\td->ret = lzo1x_decompress_safe(d->cmp + LZO_HEADER, d->cmp_len,\n\t\t                               d->unc, &d->unc_len);\n\t\tif (clean_pages_on_decompress)\n\t\t\tflush_icache_range((unsigned long)d->unc,\n\t\t\t\t\t   (unsigned long)d->unc + d->unc_len);\n\n\t\tatomic_set(&d->stop, 1);\n\t\twake_up(&d->done);\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/ktime.h>",
      "#include <linux/crc32.h>",
      "#include <linux/kthread.h>",
      "#include <linux/atomic.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/lzo.h>",
      "#include <linux/slab.h>",
      "#include <linux/pm.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include <linux/device.h>",
      "#include <linux/genhd.h>",
      "#include <linux/bitops.h>",
      "#include <linux/delay.h>",
      "#include <linux/file.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define LZO_UNC_SIZE\t(LZO_UNC_PAGES * PAGE_SIZE)",
      "#define LZO_HEADER\tsizeof(size_t)"
    ],
    "globals_used": [
      "static bool clean_pages_on_decompress;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wake_up",
          "args": [
            "&d->done"
          ],
          "line": 1157
        },
        "resolved": true,
        "details": {
          "function_name": "wake_up_worker",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "847-853",
          "snippet": "static void wake_up_worker(struct worker_pool *pool)\n{\n\tstruct worker *worker = first_idle_worker(pool);\n\n\tif (likely(worker))\n\t\twake_up_process(worker->task);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
            "static void show_one_worker_pool(struct worker_pool *pool);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nstatic void wake_up_worker(struct worker_pool *pool)\n{\n\tstruct worker *worker = first_idle_worker(pool);\n\n\tif (likely(worker))\n\t\twake_up_process(worker->task);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&d->stop",
            "1"
          ],
          "line": 1156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_icache_range",
          "args": [
            "(unsigned long)d->unc",
            "(unsigned long)d->unc + d->unc_len"
          ],
          "line": 1153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lzo1x_decompress_safe",
          "args": [
            "d->cmp + LZO_HEADER",
            "d->cmp_len",
            "d->unc",
            "&d->unc_len"
          ],
          "line": 1150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&d->ready",
            "0"
          ],
          "line": 1147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&d->stop",
            "1"
          ],
          "line": 1143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kthread_should_stop",
          "args": [],
          "line": 1140
        },
        "resolved": true,
        "details": {
          "function_name": "kthread_should_stop",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
          "lines": "156-159",
          "snippet": "bool kthread_should_stop(void)\n{\n\treturn test_bit(KTHREAD_SHOULD_STOP, &to_kthread(current)->flags);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/numa.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mm.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nbool kthread_should_stop(void)\n{\n\treturn test_bit(KTHREAD_SHOULD_STOP, &to_kthread(current)->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_event",
          "args": [
            "d->go",
            "atomic_read(&d->ready) ||\n\t\t                  kthread_should_stop()"
          ],
          "line": 1138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&d->ready"
          ],
          "line": 1138
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/ktime.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/atomic.h>\n#include <linux/cpumask.h>\n#include <linux/vmalloc.h>\n#include <linux/lzo.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/device.h>\n#include <linux/genhd.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\n#define LZO_UNC_SIZE\t(LZO_UNC_PAGES * PAGE_SIZE)\n#define LZO_HEADER\tsizeof(size_t)\n\nstatic bool clean_pages_on_decompress;\n\nstatic int lzo_decompress_threadfn(void *data)\n{\n\tstruct dec_data *d = data;\n\n\twhile (1) {\n\t\twait_event(d->go, atomic_read(&d->ready) ||\n\t\t                  kthread_should_stop());\n\t\tif (kthread_should_stop()) {\n\t\t\td->thr = NULL;\n\t\t\td->ret = -1;\n\t\t\tatomic_set(&d->stop, 1);\n\t\t\twake_up(&d->done);\n\t\t\tbreak;\n\t\t}\n\t\tatomic_set(&d->ready, 0);\n\n\t\td->unc_len = LZO_UNC_SIZE;\n\t\td->ret = lzo1x_decompress_safe(d->cmp + LZO_HEADER, d->cmp_len,\n\t\t                               d->unc, &d->unc_len);\n\t\tif (clean_pages_on_decompress)\n\t\t\tflush_icache_range((unsigned long)d->unc,\n\t\t\t\t\t   (unsigned long)d->unc + d->unc_len);\n\n\t\tatomic_set(&d->stop, 1);\n\t\twake_up(&d->done);\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "load_image",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/swap.c",
    "lines": "1062-1112",
    "snippet": "static int load_image(struct swap_map_handle *handle,\n                      struct snapshot_handle *snapshot,\n                      unsigned int nr_to_read)\n{\n\tunsigned int m;\n\tint ret = 0;\n\tktime_t start;\n\tktime_t stop;\n\tstruct hib_bio_batch hb;\n\tint err2;\n\tunsigned nr_pages;\n\n\thib_init_batch(&hb);\n\n\tclean_pages_on_read = true;\n\tpr_info(\"Loading image data pages (%u pages)...\\n\", nr_to_read);\n\tm = nr_to_read / 10;\n\tif (!m)\n\t\tm = 1;\n\tnr_pages = 0;\n\tstart = ktime_get();\n\tfor ( ; ; ) {\n\t\tret = snapshot_write_next(snapshot);\n\t\tif (ret <= 0)\n\t\t\tbreak;\n\t\tret = swap_read_page(handle, data_of(*snapshot), &hb);\n\t\tif (ret)\n\t\t\tbreak;\n\t\tif (snapshot->sync_read)\n\t\t\tret = hib_wait_io(&hb);\n\t\tif (ret)\n\t\t\tbreak;\n\t\tif (!(nr_pages % m))\n\t\t\tpr_info(\"Image loading progress: %3d%%\\n\",\n\t\t\t\tnr_pages / m * 10);\n\t\tnr_pages++;\n\t}\n\terr2 = hib_wait_io(&hb);\n\thib_finish_batch(&hb);\n\tstop = ktime_get();\n\tif (!ret)\n\t\tret = err2;\n\tif (!ret) {\n\t\tpr_info(\"Image loading done\\n\");\n\t\tsnapshot_write_finalize(snapshot);\n\t\tif (!snapshot_image_loaded(snapshot))\n\t\t\tret = -ENODATA;\n\t}\n\tswsusp_show_speed(start, stop, nr_to_read, \"Read\");\n\treturn ret;\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/ktime.h>",
      "#include <linux/crc32.h>",
      "#include <linux/kthread.h>",
      "#include <linux/atomic.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/lzo.h>",
      "#include <linux/slab.h>",
      "#include <linux/pm.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include <linux/device.h>",
      "#include <linux/genhd.h>",
      "#include <linux/bitops.h>",
      "#include <linux/delay.h>",
      "#include <linux/file.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool clean_pages_on_read;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "swsusp_show_speed",
          "args": [
            "start",
            "stop",
            "nr_to_read",
            "\"Read\""
          ],
          "line": 1110
        },
        "resolved": true,
        "details": {
          "function_name": "swsusp_show_speed",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/hibernate.c",
          "lines": "254-273",
          "snippet": "void swsusp_show_speed(ktime_t start, ktime_t stop,\n\t\t      unsigned nr_pages, char *msg)\n{\n\tktime_t diff;\n\tu64 elapsed_centisecs64;\n\tunsigned int centisecs;\n\tunsigned int k;\n\tunsigned int kps;\n\n\tdiff = ktime_sub(stop, start);\n\telapsed_centisecs64 = ktime_divns(diff, 10*NSEC_PER_MSEC);\n\tcentisecs = elapsed_centisecs64;\n\tif (centisecs == 0)\n\t\tcentisecs = 1;\t/* avoid div-by-zero */\n\tk = nr_pages * (PAGE_SIZE / 1024);\n\tkps = (k * 100) / centisecs;\n\tpr_info(\"%s %u kbytes in %u.%02u seconds (%u.%02u MB/s)\\n\",\n\t\tmsg, k, centisecs / 100, centisecs % 100, kps / 1000,\n\t\t(kps % 1000) / 10);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <trace/events/power.h>",
            "#include <linux/secretmem.h>",
            "#include <linux/security.h>",
            "#include <linux/ktime.h>",
            "#include <linux/genhd.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/gfp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cpu.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/pm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/delay.h>",
            "#include <linux/async.h>",
            "#include <linux/device.h>",
            "#include <linux/string.h>",
            "#include <linux/reboot.h>",
            "#include <linux/suspend.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <trace/events/power.h>\n#include <linux/secretmem.h>\n#include <linux/security.h>\n#include <linux/ktime.h>\n#include <linux/genhd.h>\n#include <linux/ctype.h>\n#include <linux/syscore_ops.h>\n#include <linux/gfp.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/pm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/delay.h>\n#include <linux/async.h>\n#include <linux/device.h>\n#include <linux/string.h>\n#include <linux/reboot.h>\n#include <linux/suspend.h>\n#include <linux/export.h>\n\nvoid swsusp_show_speed(ktime_t start, ktime_t stop,\n\t\t      unsigned nr_pages, char *msg)\n{\n\tktime_t diff;\n\tu64 elapsed_centisecs64;\n\tunsigned int centisecs;\n\tunsigned int k;\n\tunsigned int kps;\n\n\tdiff = ktime_sub(stop, start);\n\telapsed_centisecs64 = ktime_divns(diff, 10*NSEC_PER_MSEC);\n\tcentisecs = elapsed_centisecs64;\n\tif (centisecs == 0)\n\t\tcentisecs = 1;\t/* avoid div-by-zero */\n\tk = nr_pages * (PAGE_SIZE / 1024);\n\tkps = (k * 100) / centisecs;\n\tpr_info(\"%s %u kbytes in %u.%02u seconds (%u.%02u MB/s)\\n\",\n\t\tmsg, k, centisecs / 100, centisecs % 100, kps / 1000,\n\t\t(kps % 1000) / 10);\n}"
        }
      },
      {
        "call_info": {
          "callee": "snapshot_image_loaded",
          "args": [
            "snapshot"
          ],
          "line": 1107
        },
        "resolved": true,
        "details": {
          "function_name": "snapshot_image_loaded",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/snapshot.c",
          "lines": "2710-2714",
          "snippet": "int snapshot_image_loaded(struct snapshot_handle *handle)\n{\n\treturn !(!nr_copy_pages || !last_highmem_page_copied() ||\n\t\t\thandle->cur <= nr_meta_pages + nr_copy_pages);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned int nr_copy_pages;",
            "static unsigned int nr_meta_pages;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\nstatic unsigned int nr_copy_pages;\nstatic unsigned int nr_meta_pages;\n\nint snapshot_image_loaded(struct snapshot_handle *handle)\n{\n\treturn !(!nr_copy_pages || !last_highmem_page_copied() ||\n\t\t\thandle->cur <= nr_meta_pages + nr_copy_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "snapshot_write_finalize",
          "args": [
            "snapshot"
          ],
          "line": 1106
        },
        "resolved": true,
        "details": {
          "function_name": "snapshot_write_finalize",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/snapshot.c",
          "lines": "2699-2708",
          "snippet": "void snapshot_write_finalize(struct snapshot_handle *handle)\n{\n\tcopy_last_highmem_page();\n\thibernate_restore_protect_page(handle->buffer);\n\t/* Do that only if we have loaded the image entirely */\n\tif (handle->cur > 1 && handle->cur > nr_meta_pages + nr_copy_pages) {\n\t\tmemory_bm_recycle(&orig_bm);\n\t\tfree_highmem_data();\n\t}\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void *buffer;",
            "static unsigned int nr_copy_pages;",
            "static unsigned int nr_meta_pages;",
            "static struct memory_bitmap orig_bm;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\nstatic void *buffer;\nstatic unsigned int nr_copy_pages;\nstatic unsigned int nr_meta_pages;\nstatic struct memory_bitmap orig_bm;\n\nvoid snapshot_write_finalize(struct snapshot_handle *handle)\n{\n\tcopy_last_highmem_page();\n\thibernate_restore_protect_page(handle->buffer);\n\t/* Do that only if we have loaded the image entirely */\n\tif (handle->cur > 1 && handle->cur > nr_meta_pages + nr_copy_pages) {\n\t\tmemory_bm_recycle(&orig_bm);\n\t\tfree_highmem_data();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Image loading done\\n\""
          ],
          "line": 1105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_get",
          "args": [],
          "line": 1101
        },
        "resolved": true,
        "details": {
          "function_name": "__ktime_get_real_seconds",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
          "lines": "1025-1030",
          "snippet": "noinstr time64_t __ktime_get_real_seconds(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\n\treturn tk->xtime_sec;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nnoinstr time64_t __ktime_get_real_seconds(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\n\treturn tk->xtime_sec;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hib_finish_batch",
          "args": [
            "&hb"
          ],
          "line": 1100
        },
        "resolved": true,
        "details": {
          "function_name": "hib_finish_batch",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/swap.c",
          "lines": "243-246",
          "snippet": "static void hib_finish_batch(struct hib_bio_batch *hb)\n{\n\tblk_finish_plug(&hb->plug);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/ktime.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/atomic.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/lzo.h>",
            "#include <linux/slab.h>",
            "#include <linux/pm.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/device.h>",
            "#include <linux/genhd.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/file.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/ktime.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/atomic.h>\n#include <linux/cpumask.h>\n#include <linux/vmalloc.h>\n#include <linux/lzo.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/device.h>\n#include <linux/genhd.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\nstatic void hib_finish_batch(struct hib_bio_batch *hb)\n{\n\tblk_finish_plug(&hb->plug);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hib_wait_io",
          "args": [
            "&hb"
          ],
          "line": 1099
        },
        "resolved": true,
        "details": {
          "function_name": "hib_wait_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/swap.c",
          "lines": "305-313",
          "snippet": "static int hib_wait_io(struct hib_bio_batch *hb)\n{\n\t/*\n\t * We are relying on the behavior of blk_plug that a thread with\n\t * a plug will flush the plug list before sleeping.\n\t */\n\twait_event(hb->wait, atomic_read(&hb->count) == 0);\n\treturn blk_status_to_errno(hb->error);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/ktime.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/atomic.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/lzo.h>",
            "#include <linux/slab.h>",
            "#include <linux/pm.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/device.h>",
            "#include <linux/genhd.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/file.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/ktime.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/atomic.h>\n#include <linux/cpumask.h>\n#include <linux/vmalloc.h>\n#include <linux/lzo.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/device.h>\n#include <linux/genhd.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\nstatic int hib_wait_io(struct hib_bio_batch *hb)\n{\n\t/*\n\t * We are relying on the behavior of blk_plug that a thread with\n\t * a plug will flush the plug list before sleeping.\n\t */\n\twait_event(hb->wait, atomic_read(&hb->count) == 0);\n\treturn blk_status_to_errno(hb->error);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Image loading progress: %3d%%\\n\"",
            "nr_pages / m * 10"
          ],
          "line": 1095
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swap_read_page",
          "args": [
            "handle",
            "data_of(*snapshot)",
            "&hb"
          ],
          "line": 1087
        },
        "resolved": true,
        "details": {
          "function_name": "swap_read_page",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/swap.c",
          "lines": "1020-1047",
          "snippet": "static int swap_read_page(struct swap_map_handle *handle, void *buf,\n\t\tstruct hib_bio_batch *hb)\n{\n\tsector_t offset;\n\tint error;\n\tstruct swap_map_page_list *tmp;\n\n\tif (!handle->cur)\n\t\treturn -EINVAL;\n\toffset = handle->cur->entries[handle->k];\n\tif (!offset)\n\t\treturn -EFAULT;\n\terror = hib_submit_io(REQ_OP_READ, 0, offset, buf, hb);\n\tif (error)\n\t\treturn error;\n\tif (++handle->k >= MAP_PAGE_ENTRIES) {\n\t\thandle->k = 0;\n\t\tfree_page((unsigned long)handle->maps->map);\n\t\ttmp = handle->maps;\n\t\thandle->maps = handle->maps->next;\n\t\tkfree(tmp);\n\t\tif (!handle->maps)\n\t\t\trelease_swap_reader(handle);\n\t\telse\n\t\t\thandle->cur = handle->maps->map;\n\t}\n\treturn error;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/ktime.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/atomic.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/lzo.h>",
            "#include <linux/slab.h>",
            "#include <linux/pm.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/device.h>",
            "#include <linux/genhd.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/file.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define MAP_PAGE_ENTRIES\t(PAGE_SIZE / sizeof(sector_t) - 1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/ktime.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/atomic.h>\n#include <linux/cpumask.h>\n#include <linux/vmalloc.h>\n#include <linux/lzo.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/device.h>\n#include <linux/genhd.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\n#define MAP_PAGE_ENTRIES\t(PAGE_SIZE / sizeof(sector_t) - 1)\n\nstatic int swap_read_page(struct swap_map_handle *handle, void *buf,\n\t\tstruct hib_bio_batch *hb)\n{\n\tsector_t offset;\n\tint error;\n\tstruct swap_map_page_list *tmp;\n\n\tif (!handle->cur)\n\t\treturn -EINVAL;\n\toffset = handle->cur->entries[handle->k];\n\tif (!offset)\n\t\treturn -EFAULT;\n\terror = hib_submit_io(REQ_OP_READ, 0, offset, buf, hb);\n\tif (error)\n\t\treturn error;\n\tif (++handle->k >= MAP_PAGE_ENTRIES) {\n\t\thandle->k = 0;\n\t\tfree_page((unsigned long)handle->maps->map);\n\t\ttmp = handle->maps;\n\t\thandle->maps = handle->maps->next;\n\t\tkfree(tmp);\n\t\tif (!handle->maps)\n\t\t\trelease_swap_reader(handle);\n\t\telse\n\t\t\thandle->cur = handle->maps->map;\n\t}\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "data_of",
          "args": [
            "*snapshot"
          ],
          "line": 1087
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snapshot_write_next",
          "args": [
            "snapshot"
          ],
          "line": 1084
        },
        "resolved": true,
        "details": {
          "function_name": "snapshot_write_next",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/snapshot.c",
          "lines": "2628-2689",
          "snippet": "int snapshot_write_next(struct snapshot_handle *handle)\n{\n\tstatic struct chain_allocator ca;\n\tint error = 0;\n\n\t/* Check if we have already loaded the entire image */\n\tif (handle->cur > 1 && handle->cur > nr_meta_pages + nr_copy_pages)\n\t\treturn 0;\n\n\thandle->sync_read = 1;\n\n\tif (!handle->cur) {\n\t\tif (!buffer)\n\t\t\t/* This makes the buffer be freed by swsusp_free() */\n\t\t\tbuffer = get_image_page(GFP_ATOMIC, PG_ANY);\n\n\t\tif (!buffer)\n\t\t\treturn -ENOMEM;\n\n\t\thandle->buffer = buffer;\n\t} else if (handle->cur == 1) {\n\t\terror = load_header(buffer);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\tsafe_pages_list = NULL;\n\n\t\terror = memory_bm_create(&copy_bm, GFP_ATOMIC, PG_ANY);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\thibernate_restore_protection_begin();\n\t} else if (handle->cur <= nr_meta_pages + 1) {\n\t\terror = unpack_orig_pfns(buffer, &copy_bm);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\tif (handle->cur == nr_meta_pages + 1) {\n\t\t\terror = prepare_image(&orig_bm, &copy_bm);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\n\t\t\tchain_init(&ca, GFP_ATOMIC, PG_SAFE);\n\t\t\tmemory_bm_position_reset(&orig_bm);\n\t\t\trestore_pblist = NULL;\n\t\t\thandle->buffer = get_buffer(&orig_bm, &ca);\n\t\t\thandle->sync_read = 0;\n\t\t\tif (IS_ERR(handle->buffer))\n\t\t\t\treturn PTR_ERR(handle->buffer);\n\t\t}\n\t} else {\n\t\tcopy_last_highmem_page();\n\t\thibernate_restore_protect_page(handle->buffer);\n\t\thandle->buffer = get_buffer(&orig_bm, &ca);\n\t\tif (IS_ERR(handle->buffer))\n\t\t\treturn PTR_ERR(handle->buffer);\n\t\tif (handle->buffer != buffer)\n\t\t\thandle->sync_read = 0;\n\t}\n\thandle->cur++;\n\treturn PAGE_SIZE;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [
            "#define PG_SAFE\t\t1",
            "#define PG_ANY\t\t0"
          ],
          "globals_used": [
            "struct pbe *restore_pblist;",
            "static struct linked_page *safe_pages_list;",
            "static void *buffer;",
            "static unsigned int nr_copy_pages;",
            "static unsigned int nr_meta_pages;",
            "static struct memory_bitmap orig_bm;",
            "static struct memory_bitmap copy_bm;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\n#define PG_SAFE\t\t1\n#define PG_ANY\t\t0\n\nstruct pbe *restore_pblist;\nstatic struct linked_page *safe_pages_list;\nstatic void *buffer;\nstatic unsigned int nr_copy_pages;\nstatic unsigned int nr_meta_pages;\nstatic struct memory_bitmap orig_bm;\nstatic struct memory_bitmap copy_bm;\n\nint snapshot_write_next(struct snapshot_handle *handle)\n{\n\tstatic struct chain_allocator ca;\n\tint error = 0;\n\n\t/* Check if we have already loaded the entire image */\n\tif (handle->cur > 1 && handle->cur > nr_meta_pages + nr_copy_pages)\n\t\treturn 0;\n\n\thandle->sync_read = 1;\n\n\tif (!handle->cur) {\n\t\tif (!buffer)\n\t\t\t/* This makes the buffer be freed by swsusp_free() */\n\t\t\tbuffer = get_image_page(GFP_ATOMIC, PG_ANY);\n\n\t\tif (!buffer)\n\t\t\treturn -ENOMEM;\n\n\t\thandle->buffer = buffer;\n\t} else if (handle->cur == 1) {\n\t\terror = load_header(buffer);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\tsafe_pages_list = NULL;\n\n\t\terror = memory_bm_create(&copy_bm, GFP_ATOMIC, PG_ANY);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\thibernate_restore_protection_begin();\n\t} else if (handle->cur <= nr_meta_pages + 1) {\n\t\terror = unpack_orig_pfns(buffer, &copy_bm);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\tif (handle->cur == nr_meta_pages + 1) {\n\t\t\terror = prepare_image(&orig_bm, &copy_bm);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\n\t\t\tchain_init(&ca, GFP_ATOMIC, PG_SAFE);\n\t\t\tmemory_bm_position_reset(&orig_bm);\n\t\t\trestore_pblist = NULL;\n\t\t\thandle->buffer = get_buffer(&orig_bm, &ca);\n\t\t\thandle->sync_read = 0;\n\t\t\tif (IS_ERR(handle->buffer))\n\t\t\t\treturn PTR_ERR(handle->buffer);\n\t\t}\n\t} else {\n\t\tcopy_last_highmem_page();\n\t\thibernate_restore_protect_page(handle->buffer);\n\t\thandle->buffer = get_buffer(&orig_bm, &ca);\n\t\tif (IS_ERR(handle->buffer))\n\t\t\treturn PTR_ERR(handle->buffer);\n\t\tif (handle->buffer != buffer)\n\t\t\thandle->sync_read = 0;\n\t}\n\thandle->cur++;\n\treturn PAGE_SIZE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Loading image data pages (%u pages)...\\n\"",
            "nr_to_read"
          ],
          "line": 1077
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hib_init_batch",
          "args": [
            "&hb"
          ],
          "line": 1074
        },
        "resolved": true,
        "details": {
          "function_name": "hib_init_batch",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/swap.c",
          "lines": "235-241",
          "snippet": "static void hib_init_batch(struct hib_bio_batch *hb)\n{\n\tatomic_set(&hb->count, 0);\n\tinit_waitqueue_head(&hb->wait);\n\thb->error = BLK_STS_OK;\n\tblk_start_plug(&hb->plug);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/ktime.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/atomic.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/lzo.h>",
            "#include <linux/slab.h>",
            "#include <linux/pm.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/device.h>",
            "#include <linux/genhd.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/file.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/ktime.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/atomic.h>\n#include <linux/cpumask.h>\n#include <linux/vmalloc.h>\n#include <linux/lzo.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/device.h>\n#include <linux/genhd.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\nstatic void hib_init_batch(struct hib_bio_batch *hb)\n{\n\tatomic_set(&hb->count, 0);\n\tinit_waitqueue_head(&hb->wait);\n\thb->error = BLK_STS_OK;\n\tblk_start_plug(&hb->plug);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/ktime.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/atomic.h>\n#include <linux/cpumask.h>\n#include <linux/vmalloc.h>\n#include <linux/lzo.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/device.h>\n#include <linux/genhd.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\nstatic bool clean_pages_on_read;\n\nstatic int load_image(struct swap_map_handle *handle,\n                      struct snapshot_handle *snapshot,\n                      unsigned int nr_to_read)\n{\n\tunsigned int m;\n\tint ret = 0;\n\tktime_t start;\n\tktime_t stop;\n\tstruct hib_bio_batch hb;\n\tint err2;\n\tunsigned nr_pages;\n\n\thib_init_batch(&hb);\n\n\tclean_pages_on_read = true;\n\tpr_info(\"Loading image data pages (%u pages)...\\n\", nr_to_read);\n\tm = nr_to_read / 10;\n\tif (!m)\n\t\tm = 1;\n\tnr_pages = 0;\n\tstart = ktime_get();\n\tfor ( ; ; ) {\n\t\tret = snapshot_write_next(snapshot);\n\t\tif (ret <= 0)\n\t\t\tbreak;\n\t\tret = swap_read_page(handle, data_of(*snapshot), &hb);\n\t\tif (ret)\n\t\t\tbreak;\n\t\tif (snapshot->sync_read)\n\t\t\tret = hib_wait_io(&hb);\n\t\tif (ret)\n\t\t\tbreak;\n\t\tif (!(nr_pages % m))\n\t\t\tpr_info(\"Image loading progress: %3d%%\\n\",\n\t\t\t\tnr_pages / m * 10);\n\t\tnr_pages++;\n\t}\n\terr2 = hib_wait_io(&hb);\n\thib_finish_batch(&hb);\n\tstop = ktime_get();\n\tif (!ret)\n\t\tret = err2;\n\tif (!ret) {\n\t\tpr_info(\"Image loading done\\n\");\n\t\tsnapshot_write_finalize(snapshot);\n\t\tif (!snapshot_image_loaded(snapshot))\n\t\t\tret = -ENODATA;\n\t}\n\tswsusp_show_speed(start, stop, nr_to_read, \"Read\");\n\treturn ret;\n}"
  },
  {
    "function_name": "swap_reader_finish",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/swap.c",
    "lines": "1049-1054",
    "snippet": "static int swap_reader_finish(struct swap_map_handle *handle)\n{\n\trelease_swap_reader(handle);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/ktime.h>",
      "#include <linux/crc32.h>",
      "#include <linux/kthread.h>",
      "#include <linux/atomic.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/lzo.h>",
      "#include <linux/slab.h>",
      "#include <linux/pm.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include <linux/device.h>",
      "#include <linux/genhd.h>",
      "#include <linux/bitops.h>",
      "#include <linux/delay.h>",
      "#include <linux/file.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "release_swap_reader",
          "args": [
            "handle"
          ],
          "line": 1051
        },
        "resolved": true,
        "details": {
          "function_name": "release_swap_reader",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/swap.c",
          "lines": "960-972",
          "snippet": "static void release_swap_reader(struct swap_map_handle *handle)\n{\n\tstruct swap_map_page_list *tmp;\n\n\twhile (handle->maps) {\n\t\tif (handle->maps->map)\n\t\t\tfree_page((unsigned long)handle->maps->map);\n\t\ttmp = handle->maps;\n\t\thandle->maps = handle->maps->next;\n\t\tkfree(tmp);\n\t}\n\thandle->cur = NULL;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/ktime.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/atomic.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/lzo.h>",
            "#include <linux/slab.h>",
            "#include <linux/pm.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/device.h>",
            "#include <linux/genhd.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/file.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/ktime.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/atomic.h>\n#include <linux/cpumask.h>\n#include <linux/vmalloc.h>\n#include <linux/lzo.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/device.h>\n#include <linux/genhd.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\nstatic void release_swap_reader(struct swap_map_handle *handle)\n{\n\tstruct swap_map_page_list *tmp;\n\n\twhile (handle->maps) {\n\t\tif (handle->maps->map)\n\t\t\tfree_page((unsigned long)handle->maps->map);\n\t\ttmp = handle->maps;\n\t\thandle->maps = handle->maps->next;\n\t\tkfree(tmp);\n\t}\n\thandle->cur = NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/ktime.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/atomic.h>\n#include <linux/cpumask.h>\n#include <linux/vmalloc.h>\n#include <linux/lzo.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/device.h>\n#include <linux/genhd.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\nstatic int swap_reader_finish(struct swap_map_handle *handle)\n{\n\trelease_swap_reader(handle);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "swap_read_page",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/swap.c",
    "lines": "1020-1047",
    "snippet": "static int swap_read_page(struct swap_map_handle *handle, void *buf,\n\t\tstruct hib_bio_batch *hb)\n{\n\tsector_t offset;\n\tint error;\n\tstruct swap_map_page_list *tmp;\n\n\tif (!handle->cur)\n\t\treturn -EINVAL;\n\toffset = handle->cur->entries[handle->k];\n\tif (!offset)\n\t\treturn -EFAULT;\n\terror = hib_submit_io(REQ_OP_READ, 0, offset, buf, hb);\n\tif (error)\n\t\treturn error;\n\tif (++handle->k >= MAP_PAGE_ENTRIES) {\n\t\thandle->k = 0;\n\t\tfree_page((unsigned long)handle->maps->map);\n\t\ttmp = handle->maps;\n\t\thandle->maps = handle->maps->next;\n\t\tkfree(tmp);\n\t\tif (!handle->maps)\n\t\t\trelease_swap_reader(handle);\n\t\telse\n\t\t\thandle->cur = handle->maps->map;\n\t}\n\treturn error;\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/ktime.h>",
      "#include <linux/crc32.h>",
      "#include <linux/kthread.h>",
      "#include <linux/atomic.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/lzo.h>",
      "#include <linux/slab.h>",
      "#include <linux/pm.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include <linux/device.h>",
      "#include <linux/genhd.h>",
      "#include <linux/bitops.h>",
      "#include <linux/delay.h>",
      "#include <linux/file.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define MAP_PAGE_ENTRIES\t(PAGE_SIZE / sizeof(sector_t) - 1)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "release_swap_reader",
          "args": [
            "handle"
          ],
          "line": 1042
        },
        "resolved": true,
        "details": {
          "function_name": "release_swap_reader",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/swap.c",
          "lines": "960-972",
          "snippet": "static void release_swap_reader(struct swap_map_handle *handle)\n{\n\tstruct swap_map_page_list *tmp;\n\n\twhile (handle->maps) {\n\t\tif (handle->maps->map)\n\t\t\tfree_page((unsigned long)handle->maps->map);\n\t\ttmp = handle->maps;\n\t\thandle->maps = handle->maps->next;\n\t\tkfree(tmp);\n\t}\n\thandle->cur = NULL;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/ktime.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/atomic.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/lzo.h>",
            "#include <linux/slab.h>",
            "#include <linux/pm.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/device.h>",
            "#include <linux/genhd.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/file.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/ktime.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/atomic.h>\n#include <linux/cpumask.h>\n#include <linux/vmalloc.h>\n#include <linux/lzo.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/device.h>\n#include <linux/genhd.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\nstatic void release_swap_reader(struct swap_map_handle *handle)\n{\n\tstruct swap_map_page_list *tmp;\n\n\twhile (handle->maps) {\n\t\tif (handle->maps->map)\n\t\t\tfree_page((unsigned long)handle->maps->map);\n\t\ttmp = handle->maps;\n\t\thandle->maps = handle->maps->next;\n\t\tkfree(tmp);\n\t}\n\thandle->cur = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "tmp"
          ],
          "line": 1040
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_page",
          "args": [
            "(unsigned long)handle->maps->map"
          ],
          "line": 1037
        },
        "resolved": true,
        "details": {
          "function_name": "clear_or_poison_free_page",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/snapshot.c",
          "lines": "1181-1187",
          "snippet": "static void clear_or_poison_free_page(struct page *page)\n{\n\tif (page_poisoning_enabled_static())\n\t\t__kernel_poison_pages(page, 1);\n\telse if (want_init_on_free())\n\t\tclear_highpage(page);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int swsusp_page_is_free(struct page *);",
            "static void swsusp_set_page_forbidden(struct page *);",
            "static void swsusp_unset_page_forbidden(struct page *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\nstatic int swsusp_page_is_free(struct page *);\nstatic void swsusp_set_page_forbidden(struct page *);\nstatic void swsusp_unset_page_forbidden(struct page *);\n\nstatic void clear_or_poison_free_page(struct page *page)\n{\n\tif (page_poisoning_enabled_static())\n\t\t__kernel_poison_pages(page, 1);\n\telse if (want_init_on_free())\n\t\tclear_highpage(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hib_submit_io",
          "args": [
            "REQ_OP_READ",
            "0",
            "offset",
            "buf",
            "hb"
          ],
          "line": 1032
        },
        "resolved": true,
        "details": {
          "function_name": "hib_submit_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/swap.c",
          "lines": "273-303",
          "snippet": "static int hib_submit_io(int op, int op_flags, pgoff_t page_off, void *addr,\n\t\tstruct hib_bio_batch *hb)\n{\n\tstruct page *page = virt_to_page(addr);\n\tstruct bio *bio;\n\tint error = 0;\n\n\tbio = bio_alloc(GFP_NOIO | __GFP_HIGH, 1);\n\tbio->bi_iter.bi_sector = page_off * (PAGE_SIZE >> 9);\n\tbio_set_dev(bio, hib_resume_bdev);\n\tbio_set_op_attrs(bio, op, op_flags);\n\n\tif (bio_add_page(bio, page, PAGE_SIZE, 0) < PAGE_SIZE) {\n\t\tpr_err(\"Adding page to bio failed at %llu\\n\",\n\t\t       (unsigned long long)bio->bi_iter.bi_sector);\n\t\tbio_put(bio);\n\t\treturn -EFAULT;\n\t}\n\n\tif (hb) {\n\t\tbio->bi_end_io = hib_end_io;\n\t\tbio->bi_private = hb;\n\t\tatomic_inc(&hb->count);\n\t\tsubmit_bio(bio);\n\t} else {\n\t\terror = submit_bio_wait(bio);\n\t\tbio_put(bio);\n\t}\n\n\treturn error;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/ktime.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/atomic.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/lzo.h>",
            "#include <linux/slab.h>",
            "#include <linux/pm.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/device.h>",
            "#include <linux/genhd.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/file.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct block_device *hib_resume_bdev;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/ktime.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/atomic.h>\n#include <linux/cpumask.h>\n#include <linux/vmalloc.h>\n#include <linux/lzo.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/device.h>\n#include <linux/genhd.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\nstatic struct block_device *hib_resume_bdev;\n\nstatic int hib_submit_io(int op, int op_flags, pgoff_t page_off, void *addr,\n\t\tstruct hib_bio_batch *hb)\n{\n\tstruct page *page = virt_to_page(addr);\n\tstruct bio *bio;\n\tint error = 0;\n\n\tbio = bio_alloc(GFP_NOIO | __GFP_HIGH, 1);\n\tbio->bi_iter.bi_sector = page_off * (PAGE_SIZE >> 9);\n\tbio_set_dev(bio, hib_resume_bdev);\n\tbio_set_op_attrs(bio, op, op_flags);\n\n\tif (bio_add_page(bio, page, PAGE_SIZE, 0) < PAGE_SIZE) {\n\t\tpr_err(\"Adding page to bio failed at %llu\\n\",\n\t\t       (unsigned long long)bio->bi_iter.bi_sector);\n\t\tbio_put(bio);\n\t\treturn -EFAULT;\n\t}\n\n\tif (hb) {\n\t\tbio->bi_end_io = hib_end_io;\n\t\tbio->bi_private = hb;\n\t\tatomic_inc(&hb->count);\n\t\tsubmit_bio(bio);\n\t} else {\n\t\terror = submit_bio_wait(bio);\n\t\tbio_put(bio);\n\t}\n\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/ktime.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/atomic.h>\n#include <linux/cpumask.h>\n#include <linux/vmalloc.h>\n#include <linux/lzo.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/device.h>\n#include <linux/genhd.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\n#define MAP_PAGE_ENTRIES\t(PAGE_SIZE / sizeof(sector_t) - 1)\n\nstatic int swap_read_page(struct swap_map_handle *handle, void *buf,\n\t\tstruct hib_bio_batch *hb)\n{\n\tsector_t offset;\n\tint error;\n\tstruct swap_map_page_list *tmp;\n\n\tif (!handle->cur)\n\t\treturn -EINVAL;\n\toffset = handle->cur->entries[handle->k];\n\tif (!offset)\n\t\treturn -EFAULT;\n\terror = hib_submit_io(REQ_OP_READ, 0, offset, buf, hb);\n\tif (error)\n\t\treturn error;\n\tif (++handle->k >= MAP_PAGE_ENTRIES) {\n\t\thandle->k = 0;\n\t\tfree_page((unsigned long)handle->maps->map);\n\t\ttmp = handle->maps;\n\t\thandle->maps = handle->maps->next;\n\t\tkfree(tmp);\n\t\tif (!handle->maps)\n\t\t\trelease_swap_reader(handle);\n\t\telse\n\t\t\thandle->cur = handle->maps->map;\n\t}\n\treturn error;\n}"
  },
  {
    "function_name": "get_swap_reader",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/swap.c",
    "lines": "974-1018",
    "snippet": "static int get_swap_reader(struct swap_map_handle *handle,\n\t\tunsigned int *flags_p)\n{\n\tint error;\n\tstruct swap_map_page_list *tmp, *last;\n\tsector_t offset;\n\n\t*flags_p = swsusp_header->flags;\n\n\tif (!swsusp_header->image) /* how can this happen? */\n\t\treturn -EINVAL;\n\n\thandle->cur = NULL;\n\tlast = handle->maps = NULL;\n\toffset = swsusp_header->image;\n\twhile (offset) {\n\t\ttmp = kzalloc(sizeof(*handle->maps), GFP_KERNEL);\n\t\tif (!tmp) {\n\t\t\trelease_swap_reader(handle);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tif (!handle->maps)\n\t\t\thandle->maps = tmp;\n\t\tif (last)\n\t\t\tlast->next = tmp;\n\t\tlast = tmp;\n\n\t\ttmp->map = (struct swap_map_page *)\n\t\t\t   __get_free_page(GFP_NOIO | __GFP_HIGH);\n\t\tif (!tmp->map) {\n\t\t\trelease_swap_reader(handle);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\terror = hib_submit_io(REQ_OP_READ, 0, offset, tmp->map, NULL);\n\t\tif (error) {\n\t\t\trelease_swap_reader(handle);\n\t\t\treturn error;\n\t\t}\n\t\toffset = tmp->map->next_swap;\n\t}\n\thandle->k = 0;\n\thandle->cur = handle->maps->map;\n\treturn 0;\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/ktime.h>",
      "#include <linux/crc32.h>",
      "#include <linux/kthread.h>",
      "#include <linux/atomic.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/lzo.h>",
      "#include <linux/slab.h>",
      "#include <linux/pm.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include <linux/device.h>",
      "#include <linux/genhd.h>",
      "#include <linux/bitops.h>",
      "#include <linux/delay.h>",
      "#include <linux/file.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct swsusp_header *swsusp_header;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "release_swap_reader",
          "args": [
            "handle"
          ],
          "line": 1010
        },
        "resolved": true,
        "details": {
          "function_name": "release_swap_reader",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/swap.c",
          "lines": "960-972",
          "snippet": "static void release_swap_reader(struct swap_map_handle *handle)\n{\n\tstruct swap_map_page_list *tmp;\n\n\twhile (handle->maps) {\n\t\tif (handle->maps->map)\n\t\t\tfree_page((unsigned long)handle->maps->map);\n\t\ttmp = handle->maps;\n\t\thandle->maps = handle->maps->next;\n\t\tkfree(tmp);\n\t}\n\thandle->cur = NULL;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/ktime.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/atomic.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/lzo.h>",
            "#include <linux/slab.h>",
            "#include <linux/pm.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/device.h>",
            "#include <linux/genhd.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/file.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/ktime.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/atomic.h>\n#include <linux/cpumask.h>\n#include <linux/vmalloc.h>\n#include <linux/lzo.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/device.h>\n#include <linux/genhd.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\nstatic void release_swap_reader(struct swap_map_handle *handle)\n{\n\tstruct swap_map_page_list *tmp;\n\n\twhile (handle->maps) {\n\t\tif (handle->maps->map)\n\t\t\tfree_page((unsigned long)handle->maps->map);\n\t\ttmp = handle->maps;\n\t\thandle->maps = handle->maps->next;\n\t\tkfree(tmp);\n\t}\n\thandle->cur = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hib_submit_io",
          "args": [
            "REQ_OP_READ",
            "0",
            "offset",
            "tmp->map",
            "NULL"
          ],
          "line": 1008
        },
        "resolved": true,
        "details": {
          "function_name": "hib_submit_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/swap.c",
          "lines": "273-303",
          "snippet": "static int hib_submit_io(int op, int op_flags, pgoff_t page_off, void *addr,\n\t\tstruct hib_bio_batch *hb)\n{\n\tstruct page *page = virt_to_page(addr);\n\tstruct bio *bio;\n\tint error = 0;\n\n\tbio = bio_alloc(GFP_NOIO | __GFP_HIGH, 1);\n\tbio->bi_iter.bi_sector = page_off * (PAGE_SIZE >> 9);\n\tbio_set_dev(bio, hib_resume_bdev);\n\tbio_set_op_attrs(bio, op, op_flags);\n\n\tif (bio_add_page(bio, page, PAGE_SIZE, 0) < PAGE_SIZE) {\n\t\tpr_err(\"Adding page to bio failed at %llu\\n\",\n\t\t       (unsigned long long)bio->bi_iter.bi_sector);\n\t\tbio_put(bio);\n\t\treturn -EFAULT;\n\t}\n\n\tif (hb) {\n\t\tbio->bi_end_io = hib_end_io;\n\t\tbio->bi_private = hb;\n\t\tatomic_inc(&hb->count);\n\t\tsubmit_bio(bio);\n\t} else {\n\t\terror = submit_bio_wait(bio);\n\t\tbio_put(bio);\n\t}\n\n\treturn error;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/ktime.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/atomic.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/lzo.h>",
            "#include <linux/slab.h>",
            "#include <linux/pm.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/device.h>",
            "#include <linux/genhd.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/file.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct block_device *hib_resume_bdev;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/ktime.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/atomic.h>\n#include <linux/cpumask.h>\n#include <linux/vmalloc.h>\n#include <linux/lzo.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/device.h>\n#include <linux/genhd.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\nstatic struct block_device *hib_resume_bdev;\n\nstatic int hib_submit_io(int op, int op_flags, pgoff_t page_off, void *addr,\n\t\tstruct hib_bio_batch *hb)\n{\n\tstruct page *page = virt_to_page(addr);\n\tstruct bio *bio;\n\tint error = 0;\n\n\tbio = bio_alloc(GFP_NOIO | __GFP_HIGH, 1);\n\tbio->bi_iter.bi_sector = page_off * (PAGE_SIZE >> 9);\n\tbio_set_dev(bio, hib_resume_bdev);\n\tbio_set_op_attrs(bio, op, op_flags);\n\n\tif (bio_add_page(bio, page, PAGE_SIZE, 0) < PAGE_SIZE) {\n\t\tpr_err(\"Adding page to bio failed at %llu\\n\",\n\t\t       (unsigned long long)bio->bi_iter.bi_sector);\n\t\tbio_put(bio);\n\t\treturn -EFAULT;\n\t}\n\n\tif (hb) {\n\t\tbio->bi_end_io = hib_end_io;\n\t\tbio->bi_private = hb;\n\t\tatomic_inc(&hb->count);\n\t\tsubmit_bio(bio);\n\t} else {\n\t\terror = submit_bio_wait(bio);\n\t\tbio_put(bio);\n\t}\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__get_free_page",
          "args": [
            "GFP_NOIO | __GFP_HIGH"
          ],
          "line": 1002
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*handle->maps)",
            "GFP_KERNEL"
          ],
          "line": 990
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/ktime.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/atomic.h>\n#include <linux/cpumask.h>\n#include <linux/vmalloc.h>\n#include <linux/lzo.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/device.h>\n#include <linux/genhd.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\nstatic struct swsusp_header *swsusp_header;\n\nstatic int get_swap_reader(struct swap_map_handle *handle,\n\t\tunsigned int *flags_p)\n{\n\tint error;\n\tstruct swap_map_page_list *tmp, *last;\n\tsector_t offset;\n\n\t*flags_p = swsusp_header->flags;\n\n\tif (!swsusp_header->image) /* how can this happen? */\n\t\treturn -EINVAL;\n\n\thandle->cur = NULL;\n\tlast = handle->maps = NULL;\n\toffset = swsusp_header->image;\n\twhile (offset) {\n\t\ttmp = kzalloc(sizeof(*handle->maps), GFP_KERNEL);\n\t\tif (!tmp) {\n\t\t\trelease_swap_reader(handle);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tif (!handle->maps)\n\t\t\thandle->maps = tmp;\n\t\tif (last)\n\t\t\tlast->next = tmp;\n\t\tlast = tmp;\n\n\t\ttmp->map = (struct swap_map_page *)\n\t\t\t   __get_free_page(GFP_NOIO | __GFP_HIGH);\n\t\tif (!tmp->map) {\n\t\t\trelease_swap_reader(handle);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\terror = hib_submit_io(REQ_OP_READ, 0, offset, tmp->map, NULL);\n\t\tif (error) {\n\t\t\trelease_swap_reader(handle);\n\t\t\treturn error;\n\t\t}\n\t\toffset = tmp->map->next_swap;\n\t}\n\thandle->k = 0;\n\thandle->cur = handle->maps->map;\n\treturn 0;\n}"
  },
  {
    "function_name": "release_swap_reader",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/swap.c",
    "lines": "960-972",
    "snippet": "static void release_swap_reader(struct swap_map_handle *handle)\n{\n\tstruct swap_map_page_list *tmp;\n\n\twhile (handle->maps) {\n\t\tif (handle->maps->map)\n\t\t\tfree_page((unsigned long)handle->maps->map);\n\t\ttmp = handle->maps;\n\t\thandle->maps = handle->maps->next;\n\t\tkfree(tmp);\n\t}\n\thandle->cur = NULL;\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/ktime.h>",
      "#include <linux/crc32.h>",
      "#include <linux/kthread.h>",
      "#include <linux/atomic.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/lzo.h>",
      "#include <linux/slab.h>",
      "#include <linux/pm.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include <linux/device.h>",
      "#include <linux/genhd.h>",
      "#include <linux/bitops.h>",
      "#include <linux/delay.h>",
      "#include <linux/file.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "tmp"
          ],
          "line": 969
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_page",
          "args": [
            "(unsigned long)handle->maps->map"
          ],
          "line": 966
        },
        "resolved": true,
        "details": {
          "function_name": "clear_or_poison_free_page",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/snapshot.c",
          "lines": "1181-1187",
          "snippet": "static void clear_or_poison_free_page(struct page *page)\n{\n\tif (page_poisoning_enabled_static())\n\t\t__kernel_poison_pages(page, 1);\n\telse if (want_init_on_free())\n\t\tclear_highpage(page);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int swsusp_page_is_free(struct page *);",
            "static void swsusp_set_page_forbidden(struct page *);",
            "static void swsusp_unset_page_forbidden(struct page *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\nstatic int swsusp_page_is_free(struct page *);\nstatic void swsusp_set_page_forbidden(struct page *);\nstatic void swsusp_unset_page_forbidden(struct page *);\n\nstatic void clear_or_poison_free_page(struct page *page)\n{\n\tif (page_poisoning_enabled_static())\n\t\t__kernel_poison_pages(page, 1);\n\telse if (want_init_on_free())\n\t\tclear_highpage(page);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/ktime.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/atomic.h>\n#include <linux/cpumask.h>\n#include <linux/vmalloc.h>\n#include <linux/lzo.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/device.h>\n#include <linux/genhd.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\nstatic void release_swap_reader(struct swap_map_handle *handle)\n{\n\tstruct swap_map_page_list *tmp;\n\n\twhile (handle->maps) {\n\t\tif (handle->maps->map)\n\t\t\tfree_page((unsigned long)handle->maps->map);\n\t\ttmp = handle->maps;\n\t\thandle->maps = handle->maps->next;\n\t\tkfree(tmp);\n\t}\n\thandle->cur = NULL;\n}"
  },
  {
    "function_name": "swsusp_write",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/swap.c",
    "lines": "914-953",
    "snippet": "int swsusp_write(unsigned int flags)\n{\n\tstruct swap_map_handle handle;\n\tstruct snapshot_handle snapshot;\n\tstruct swsusp_info *header;\n\tunsigned long pages;\n\tint error;\n\n\tpages = snapshot_get_image_size();\n\terror = get_swap_writer(&handle);\n\tif (error) {\n\t\tpr_err(\"Cannot get swap writer\\n\");\n\t\treturn error;\n\t}\n\tif (flags & SF_NOCOMPRESS_MODE) {\n\t\tif (!enough_swap(pages)) {\n\t\t\tpr_err(\"Not enough free swap\\n\");\n\t\t\terror = -ENOSPC;\n\t\t\tgoto out_finish;\n\t\t}\n\t}\n\tmemset(&snapshot, 0, sizeof(struct snapshot_handle));\n\terror = snapshot_read_next(&snapshot);\n\tif (error < (int)PAGE_SIZE) {\n\t\tif (error >= 0)\n\t\t\terror = -EFAULT;\n\n\t\tgoto out_finish;\n\t}\n\theader = (struct swsusp_info *)data_of(snapshot);\n\terror = swap_write_page(&handle, header, NULL);\n\tif (!error) {\n\t\terror = (flags & SF_NOCOMPRESS_MODE) ?\n\t\t\tsave_image(&handle, &snapshot, pages - 1) :\n\t\t\tsave_image_lzo(&handle, &snapshot, pages - 1);\n\t}\nout_finish:\n\terror = swap_writer_finish(&handle, flags, error);\n\treturn error;\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/ktime.h>",
      "#include <linux/crc32.h>",
      "#include <linux/kthread.h>",
      "#include <linux/atomic.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/lzo.h>",
      "#include <linux/slab.h>",
      "#include <linux/pm.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include <linux/device.h>",
      "#include <linux/genhd.h>",
      "#include <linux/bitops.h>",
      "#include <linux/delay.h>",
      "#include <linux/file.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "swap_writer_finish",
          "args": [
            "&handle",
            "flags",
            "error"
          ],
          "line": 951
        },
        "resolved": true,
        "details": {
          "function_name": "swap_writer_finish",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/swap.c",
          "lines": "502-518",
          "snippet": "static int swap_writer_finish(struct swap_map_handle *handle,\n\t\tunsigned int flags, int error)\n{\n\tif (!error) {\n\t\tpr_info(\"S\");\n\t\terror = mark_swapfiles(handle, flags);\n\t\tpr_cont(\"|\\n\");\n\t\tflush_swap_writer(handle);\n\t}\n\n\tif (error)\n\t\tfree_all_swap_pages(root_swap);\n\trelease_swap_writer(handle);\n\tswsusp_close(FMODE_WRITE);\n\n\treturn error;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/ktime.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/atomic.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/lzo.h>",
            "#include <linux/slab.h>",
            "#include <linux/pm.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/device.h>",
            "#include <linux/genhd.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/file.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned short root_swap = 0xffff;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/ktime.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/atomic.h>\n#include <linux/cpumask.h>\n#include <linux/vmalloc.h>\n#include <linux/lzo.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/device.h>\n#include <linux/genhd.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\nstatic unsigned short root_swap = 0xffff;\n\nstatic int swap_writer_finish(struct swap_map_handle *handle,\n\t\tunsigned int flags, int error)\n{\n\tif (!error) {\n\t\tpr_info(\"S\");\n\t\terror = mark_swapfiles(handle, flags);\n\t\tpr_cont(\"|\\n\");\n\t\tflush_swap_writer(handle);\n\t}\n\n\tif (error)\n\t\tfree_all_swap_pages(root_swap);\n\trelease_swap_writer(handle);\n\tswsusp_close(FMODE_WRITE);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "save_image_lzo",
          "args": [
            "&handle",
            "&snapshot",
            "pages - 1"
          ],
          "line": 948
        },
        "resolved": true,
        "details": {
          "function_name": "save_image_lzo",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/swap.c",
          "lines": "681-884",
          "snippet": "static int save_image_lzo(struct swap_map_handle *handle,\n                          struct snapshot_handle *snapshot,\n                          unsigned int nr_to_write)\n{\n\tunsigned int m;\n\tint ret = 0;\n\tint nr_pages;\n\tint err2;\n\tstruct hib_bio_batch hb;\n\tktime_t start;\n\tktime_t stop;\n\tsize_t off;\n\tunsigned thr, run_threads, nr_threads;\n\tunsigned char *page = NULL;\n\tstruct cmp_data *data = NULL;\n\tstruct crc_data *crc = NULL;\n\n\thib_init_batch(&hb);\n\n\t/*\n\t * We'll limit the number of threads for compression to limit memory\n\t * footprint.\n\t */\n\tnr_threads = num_online_cpus() - 1;\n\tnr_threads = clamp_val(nr_threads, 1, LZO_THREADS);\n\n\tpage = (void *)__get_free_page(GFP_NOIO | __GFP_HIGH);\n\tif (!page) {\n\t\tpr_err(\"Failed to allocate LZO page\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto out_clean;\n\t}\n\n\tdata = vzalloc(array_size(nr_threads, sizeof(*data)));\n\tif (!data) {\n\t\tpr_err(\"Failed to allocate LZO data\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto out_clean;\n\t}\n\n\tcrc = kzalloc(sizeof(*crc), GFP_KERNEL);\n\tif (!crc) {\n\t\tpr_err(\"Failed to allocate crc\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto out_clean;\n\t}\n\n\t/*\n\t * Start the compression threads.\n\t */\n\tfor (thr = 0; thr < nr_threads; thr++) {\n\t\tinit_waitqueue_head(&data[thr].go);\n\t\tinit_waitqueue_head(&data[thr].done);\n\n\t\tdata[thr].thr = kthread_run(lzo_compress_threadfn,\n\t\t                            &data[thr],\n\t\t                            \"image_compress/%u\", thr);\n\t\tif (IS_ERR(data[thr].thr)) {\n\t\t\tdata[thr].thr = NULL;\n\t\t\tpr_err(\"Cannot start compression threads\\n\");\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out_clean;\n\t\t}\n\t}\n\n\t/*\n\t * Start the CRC32 thread.\n\t */\n\tinit_waitqueue_head(&crc->go);\n\tinit_waitqueue_head(&crc->done);\n\n\thandle->crc32 = 0;\n\tcrc->crc32 = &handle->crc32;\n\tfor (thr = 0; thr < nr_threads; thr++) {\n\t\tcrc->unc[thr] = data[thr].unc;\n\t\tcrc->unc_len[thr] = &data[thr].unc_len;\n\t}\n\n\tcrc->thr = kthread_run(crc32_threadfn, crc, \"image_crc32\");\n\tif (IS_ERR(crc->thr)) {\n\t\tcrc->thr = NULL;\n\t\tpr_err(\"Cannot start CRC32 thread\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto out_clean;\n\t}\n\n\t/*\n\t * Adjust the number of required free pages after all allocations have\n\t * been done. We don't want to run out of pages when writing.\n\t */\n\thandle->reqd_free_pages = reqd_free_pages();\n\n\tpr_info(\"Using %u thread(s) for compression\\n\", nr_threads);\n\tpr_info(\"Compressing and saving image data (%u pages)...\\n\",\n\t\tnr_to_write);\n\tm = nr_to_write / 10;\n\tif (!m)\n\t\tm = 1;\n\tnr_pages = 0;\n\tstart = ktime_get();\n\tfor (;;) {\n\t\tfor (thr = 0; thr < nr_threads; thr++) {\n\t\t\tfor (off = 0; off < LZO_UNC_SIZE; off += PAGE_SIZE) {\n\t\t\t\tret = snapshot_read_next(snapshot);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tgoto out_finish;\n\n\t\t\t\tif (!ret)\n\t\t\t\t\tbreak;\n\n\t\t\t\tmemcpy(data[thr].unc + off,\n\t\t\t\t       data_of(*snapshot), PAGE_SIZE);\n\n\t\t\t\tif (!(nr_pages % m))\n\t\t\t\t\tpr_info(\"Image saving progress: %3d%%\\n\",\n\t\t\t\t\t\tnr_pages / m * 10);\n\t\t\t\tnr_pages++;\n\t\t\t}\n\t\t\tif (!off)\n\t\t\t\tbreak;\n\n\t\t\tdata[thr].unc_len = off;\n\n\t\t\tatomic_set(&data[thr].ready, 1);\n\t\t\twake_up(&data[thr].go);\n\t\t}\n\n\t\tif (!thr)\n\t\t\tbreak;\n\n\t\tcrc->run_threads = thr;\n\t\tatomic_set(&crc->ready, 1);\n\t\twake_up(&crc->go);\n\n\t\tfor (run_threads = thr, thr = 0; thr < run_threads; thr++) {\n\t\t\twait_event(data[thr].done,\n\t\t\t           atomic_read(&data[thr].stop));\n\t\t\tatomic_set(&data[thr].stop, 0);\n\n\t\t\tret = data[thr].ret;\n\n\t\t\tif (ret < 0) {\n\t\t\t\tpr_err(\"LZO compression failed\\n\");\n\t\t\t\tgoto out_finish;\n\t\t\t}\n\n\t\t\tif (unlikely(!data[thr].cmp_len ||\n\t\t\t             data[thr].cmp_len >\n\t\t\t             lzo1x_worst_compress(data[thr].unc_len))) {\n\t\t\t\tpr_err(\"Invalid LZO compressed length\\n\");\n\t\t\t\tret = -1;\n\t\t\t\tgoto out_finish;\n\t\t\t}\n\n\t\t\t*(size_t *)data[thr].cmp = data[thr].cmp_len;\n\n\t\t\t/*\n\t\t\t * Given we are writing one page at a time to disk, we\n\t\t\t * copy that much from the buffer, although the last\n\t\t\t * bit will likely be smaller than full page. This is\n\t\t\t * OK - we saved the length of the compressed data, so\n\t\t\t * any garbage at the end will be discarded when we\n\t\t\t * read it.\n\t\t\t */\n\t\t\tfor (off = 0;\n\t\t\t     off < LZO_HEADER + data[thr].cmp_len;\n\t\t\t     off += PAGE_SIZE) {\n\t\t\t\tmemcpy(page, data[thr].cmp + off, PAGE_SIZE);\n\n\t\t\t\tret = swap_write_page(handle, page, &hb);\n\t\t\t\tif (ret)\n\t\t\t\t\tgoto out_finish;\n\t\t\t}\n\t\t}\n\n\t\twait_event(crc->done, atomic_read(&crc->stop));\n\t\tatomic_set(&crc->stop, 0);\n\t}\n\nout_finish:\n\terr2 = hib_wait_io(&hb);\n\tstop = ktime_get();\n\tif (!ret)\n\t\tret = err2;\n\tif (!ret)\n\t\tpr_info(\"Image saving done\\n\");\n\tswsusp_show_speed(start, stop, nr_to_write, \"Wrote\");\nout_clean:\n\thib_finish_batch(&hb);\n\tif (crc) {\n\t\tif (crc->thr)\n\t\t\tkthread_stop(crc->thr);\n\t\tkfree(crc);\n\t}\n\tif (data) {\n\t\tfor (thr = 0; thr < nr_threads; thr++)\n\t\t\tif (data[thr].thr)\n\t\t\t\tkthread_stop(data[thr].thr);\n\t\tvfree(data);\n\t}\n\tif (page) free_page((unsigned long)page);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/ktime.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/atomic.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/lzo.h>",
            "#include <linux/slab.h>",
            "#include <linux/pm.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/device.h>",
            "#include <linux/genhd.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/file.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define LZO_THREADS\t3",
            "#define LZO_UNC_SIZE\t(LZO_UNC_PAGES * PAGE_SIZE)",
            "#define LZO_HEADER\tsizeof(size_t)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/ktime.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/atomic.h>\n#include <linux/cpumask.h>\n#include <linux/vmalloc.h>\n#include <linux/lzo.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/device.h>\n#include <linux/genhd.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\n#define LZO_THREADS\t3\n#define LZO_UNC_SIZE\t(LZO_UNC_PAGES * PAGE_SIZE)\n#define LZO_HEADER\tsizeof(size_t)\n\nstatic int save_image_lzo(struct swap_map_handle *handle,\n                          struct snapshot_handle *snapshot,\n                          unsigned int nr_to_write)\n{\n\tunsigned int m;\n\tint ret = 0;\n\tint nr_pages;\n\tint err2;\n\tstruct hib_bio_batch hb;\n\tktime_t start;\n\tktime_t stop;\n\tsize_t off;\n\tunsigned thr, run_threads, nr_threads;\n\tunsigned char *page = NULL;\n\tstruct cmp_data *data = NULL;\n\tstruct crc_data *crc = NULL;\n\n\thib_init_batch(&hb);\n\n\t/*\n\t * We'll limit the number of threads for compression to limit memory\n\t * footprint.\n\t */\n\tnr_threads = num_online_cpus() - 1;\n\tnr_threads = clamp_val(nr_threads, 1, LZO_THREADS);\n\n\tpage = (void *)__get_free_page(GFP_NOIO | __GFP_HIGH);\n\tif (!page) {\n\t\tpr_err(\"Failed to allocate LZO page\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto out_clean;\n\t}\n\n\tdata = vzalloc(array_size(nr_threads, sizeof(*data)));\n\tif (!data) {\n\t\tpr_err(\"Failed to allocate LZO data\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto out_clean;\n\t}\n\n\tcrc = kzalloc(sizeof(*crc), GFP_KERNEL);\n\tif (!crc) {\n\t\tpr_err(\"Failed to allocate crc\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto out_clean;\n\t}\n\n\t/*\n\t * Start the compression threads.\n\t */\n\tfor (thr = 0; thr < nr_threads; thr++) {\n\t\tinit_waitqueue_head(&data[thr].go);\n\t\tinit_waitqueue_head(&data[thr].done);\n\n\t\tdata[thr].thr = kthread_run(lzo_compress_threadfn,\n\t\t                            &data[thr],\n\t\t                            \"image_compress/%u\", thr);\n\t\tif (IS_ERR(data[thr].thr)) {\n\t\t\tdata[thr].thr = NULL;\n\t\t\tpr_err(\"Cannot start compression threads\\n\");\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out_clean;\n\t\t}\n\t}\n\n\t/*\n\t * Start the CRC32 thread.\n\t */\n\tinit_waitqueue_head(&crc->go);\n\tinit_waitqueue_head(&crc->done);\n\n\thandle->crc32 = 0;\n\tcrc->crc32 = &handle->crc32;\n\tfor (thr = 0; thr < nr_threads; thr++) {\n\t\tcrc->unc[thr] = data[thr].unc;\n\t\tcrc->unc_len[thr] = &data[thr].unc_len;\n\t}\n\n\tcrc->thr = kthread_run(crc32_threadfn, crc, \"image_crc32\");\n\tif (IS_ERR(crc->thr)) {\n\t\tcrc->thr = NULL;\n\t\tpr_err(\"Cannot start CRC32 thread\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto out_clean;\n\t}\n\n\t/*\n\t * Adjust the number of required free pages after all allocations have\n\t * been done. We don't want to run out of pages when writing.\n\t */\n\thandle->reqd_free_pages = reqd_free_pages();\n\n\tpr_info(\"Using %u thread(s) for compression\\n\", nr_threads);\n\tpr_info(\"Compressing and saving image data (%u pages)...\\n\",\n\t\tnr_to_write);\n\tm = nr_to_write / 10;\n\tif (!m)\n\t\tm = 1;\n\tnr_pages = 0;\n\tstart = ktime_get();\n\tfor (;;) {\n\t\tfor (thr = 0; thr < nr_threads; thr++) {\n\t\t\tfor (off = 0; off < LZO_UNC_SIZE; off += PAGE_SIZE) {\n\t\t\t\tret = snapshot_read_next(snapshot);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tgoto out_finish;\n\n\t\t\t\tif (!ret)\n\t\t\t\t\tbreak;\n\n\t\t\t\tmemcpy(data[thr].unc + off,\n\t\t\t\t       data_of(*snapshot), PAGE_SIZE);\n\n\t\t\t\tif (!(nr_pages % m))\n\t\t\t\t\tpr_info(\"Image saving progress: %3d%%\\n\",\n\t\t\t\t\t\tnr_pages / m * 10);\n\t\t\t\tnr_pages++;\n\t\t\t}\n\t\t\tif (!off)\n\t\t\t\tbreak;\n\n\t\t\tdata[thr].unc_len = off;\n\n\t\t\tatomic_set(&data[thr].ready, 1);\n\t\t\twake_up(&data[thr].go);\n\t\t}\n\n\t\tif (!thr)\n\t\t\tbreak;\n\n\t\tcrc->run_threads = thr;\n\t\tatomic_set(&crc->ready, 1);\n\t\twake_up(&crc->go);\n\n\t\tfor (run_threads = thr, thr = 0; thr < run_threads; thr++) {\n\t\t\twait_event(data[thr].done,\n\t\t\t           atomic_read(&data[thr].stop));\n\t\t\tatomic_set(&data[thr].stop, 0);\n\n\t\t\tret = data[thr].ret;\n\n\t\t\tif (ret < 0) {\n\t\t\t\tpr_err(\"LZO compression failed\\n\");\n\t\t\t\tgoto out_finish;\n\t\t\t}\n\n\t\t\tif (unlikely(!data[thr].cmp_len ||\n\t\t\t             data[thr].cmp_len >\n\t\t\t             lzo1x_worst_compress(data[thr].unc_len))) {\n\t\t\t\tpr_err(\"Invalid LZO compressed length\\n\");\n\t\t\t\tret = -1;\n\t\t\t\tgoto out_finish;\n\t\t\t}\n\n\t\t\t*(size_t *)data[thr].cmp = data[thr].cmp_len;\n\n\t\t\t/*\n\t\t\t * Given we are writing one page at a time to disk, we\n\t\t\t * copy that much from the buffer, although the last\n\t\t\t * bit will likely be smaller than full page. This is\n\t\t\t * OK - we saved the length of the compressed data, so\n\t\t\t * any garbage at the end will be discarded when we\n\t\t\t * read it.\n\t\t\t */\n\t\t\tfor (off = 0;\n\t\t\t     off < LZO_HEADER + data[thr].cmp_len;\n\t\t\t     off += PAGE_SIZE) {\n\t\t\t\tmemcpy(page, data[thr].cmp + off, PAGE_SIZE);\n\n\t\t\t\tret = swap_write_page(handle, page, &hb);\n\t\t\t\tif (ret)\n\t\t\t\t\tgoto out_finish;\n\t\t\t}\n\t\t}\n\n\t\twait_event(crc->done, atomic_read(&crc->stop));\n\t\tatomic_set(&crc->stop, 0);\n\t}\n\nout_finish:\n\terr2 = hib_wait_io(&hb);\n\tstop = ktime_get();\n\tif (!ret)\n\t\tret = err2;\n\tif (!ret)\n\t\tpr_info(\"Image saving done\\n\");\n\tswsusp_show_speed(start, stop, nr_to_write, \"Wrote\");\nout_clean:\n\thib_finish_batch(&hb);\n\tif (crc) {\n\t\tif (crc->thr)\n\t\t\tkthread_stop(crc->thr);\n\t\tkfree(crc);\n\t}\n\tif (data) {\n\t\tfor (thr = 0; thr < nr_threads; thr++)\n\t\t\tif (data[thr].thr)\n\t\t\t\tkthread_stop(data[thr].thr);\n\t\tvfree(data);\n\t}\n\tif (page) free_page((unsigned long)page);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "swap_write_page",
          "args": [
            "&handle",
            "header",
            "NULL"
          ],
          "line": 944
        },
        "resolved": true,
        "details": {
          "function_name": "swap_write_page",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/swap.c",
          "lines": "454-492",
          "snippet": "static int swap_write_page(struct swap_map_handle *handle, void *buf,\n\t\tstruct hib_bio_batch *hb)\n{\n\tint error = 0;\n\tsector_t offset;\n\n\tif (!handle->cur)\n\t\treturn -EINVAL;\n\toffset = alloc_swapdev_block(root_swap);\n\terror = write_page(buf, offset, hb);\n\tif (error)\n\t\treturn error;\n\thandle->cur->entries[handle->k++] = offset;\n\tif (handle->k >= MAP_PAGE_ENTRIES) {\n\t\toffset = alloc_swapdev_block(root_swap);\n\t\tif (!offset)\n\t\t\treturn -ENOSPC;\n\t\thandle->cur->next_swap = offset;\n\t\terror = write_page(handle->cur, handle->cur_swap, hb);\n\t\tif (error)\n\t\t\tgoto out;\n\t\tclear_page(handle->cur);\n\t\thandle->cur_swap = offset;\n\t\thandle->k = 0;\n\n\t\tif (hb && low_free_pages() <= handle->reqd_free_pages) {\n\t\t\terror = hib_wait_io(hb);\n\t\t\tif (error)\n\t\t\t\tgoto out;\n\t\t\t/*\n\t\t\t * Recalculate the number of required free pages, to\n\t\t\t * make sure we never take more than half.\n\t\t\t */\n\t\t\thandle->reqd_free_pages = reqd_free_pages();\n\t\t}\n\t}\n out:\n\treturn error;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/ktime.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/atomic.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/lzo.h>",
            "#include <linux/slab.h>",
            "#include <linux/pm.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/device.h>",
            "#include <linux/genhd.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/file.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define MAP_PAGE_ENTRIES\t(PAGE_SIZE / sizeof(sector_t) - 1)"
          ],
          "globals_used": [
            "static unsigned short root_swap = 0xffff;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/ktime.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/atomic.h>\n#include <linux/cpumask.h>\n#include <linux/vmalloc.h>\n#include <linux/lzo.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/device.h>\n#include <linux/genhd.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\n#define MAP_PAGE_ENTRIES\t(PAGE_SIZE / sizeof(sector_t) - 1)\n\nstatic unsigned short root_swap = 0xffff;\n\nstatic int swap_write_page(struct swap_map_handle *handle, void *buf,\n\t\tstruct hib_bio_batch *hb)\n{\n\tint error = 0;\n\tsector_t offset;\n\n\tif (!handle->cur)\n\t\treturn -EINVAL;\n\toffset = alloc_swapdev_block(root_swap);\n\terror = write_page(buf, offset, hb);\n\tif (error)\n\t\treturn error;\n\thandle->cur->entries[handle->k++] = offset;\n\tif (handle->k >= MAP_PAGE_ENTRIES) {\n\t\toffset = alloc_swapdev_block(root_swap);\n\t\tif (!offset)\n\t\t\treturn -ENOSPC;\n\t\thandle->cur->next_swap = offset;\n\t\terror = write_page(handle->cur, handle->cur_swap, hb);\n\t\tif (error)\n\t\t\tgoto out;\n\t\tclear_page(handle->cur);\n\t\thandle->cur_swap = offset;\n\t\thandle->k = 0;\n\n\t\tif (hb && low_free_pages() <= handle->reqd_free_pages) {\n\t\t\terror = hib_wait_io(hb);\n\t\t\tif (error)\n\t\t\t\tgoto out;\n\t\t\t/*\n\t\t\t * Recalculate the number of required free pages, to\n\t\t\t * make sure we never take more than half.\n\t\t\t */\n\t\t\thandle->reqd_free_pages = reqd_free_pages();\n\t\t}\n\t}\n out:\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "data_of",
          "args": [
            "snapshot"
          ],
          "line": 943
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snapshot_read_next",
          "args": [
            "&snapshot"
          ],
          "line": 936
        },
        "resolved": true,
        "details": {
          "function_name": "snapshot_read_next",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/snapshot.c",
          "lines": "2135-2180",
          "snippet": "int snapshot_read_next(struct snapshot_handle *handle)\n{\n\tif (handle->cur > nr_meta_pages + nr_copy_pages)\n\t\treturn 0;\n\n\tif (!buffer) {\n\t\t/* This makes the buffer be freed by swsusp_free() */\n\t\tbuffer = get_image_page(GFP_ATOMIC, PG_ANY);\n\t\tif (!buffer)\n\t\t\treturn -ENOMEM;\n\t}\n\tif (!handle->cur) {\n\t\tint error;\n\n\t\terror = init_header((struct swsusp_info *)buffer);\n\t\tif (error)\n\t\t\treturn error;\n\t\thandle->buffer = buffer;\n\t\tmemory_bm_position_reset(&orig_bm);\n\t\tmemory_bm_position_reset(&copy_bm);\n\t} else if (handle->cur <= nr_meta_pages) {\n\t\tclear_page(buffer);\n\t\tpack_pfns(buffer, &orig_bm);\n\t} else {\n\t\tstruct page *page;\n\n\t\tpage = pfn_to_page(memory_bm_next_pfn(&copy_bm));\n\t\tif (PageHighMem(page)) {\n\t\t\t/*\n\t\t\t * Highmem pages are copied to the buffer,\n\t\t\t * because we can't return with a kmapped\n\t\t\t * highmem page (we may not be called again).\n\t\t\t */\n\t\t\tvoid *kaddr;\n\n\t\t\tkaddr = kmap_atomic(page);\n\t\t\tcopy_page(buffer, kaddr);\n\t\t\tkunmap_atomic(kaddr);\n\t\t\thandle->buffer = buffer;\n\t\t} else {\n\t\t\thandle->buffer = page_address(page);\n\t\t}\n\t}\n\thandle->cur++;\n\treturn PAGE_SIZE;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [
            "#define PG_ANY\t\t0"
          ],
          "globals_used": [
            "static int swsusp_page_is_free(struct page *);",
            "static void swsusp_set_page_forbidden(struct page *);",
            "static void swsusp_unset_page_forbidden(struct page *);",
            "static void *buffer;",
            "static unsigned int nr_copy_pages;",
            "static unsigned int nr_meta_pages;",
            "static struct memory_bitmap orig_bm;",
            "static struct memory_bitmap copy_bm;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\n#define PG_ANY\t\t0\n\nstatic int swsusp_page_is_free(struct page *);\nstatic void swsusp_set_page_forbidden(struct page *);\nstatic void swsusp_unset_page_forbidden(struct page *);\nstatic void *buffer;\nstatic unsigned int nr_copy_pages;\nstatic unsigned int nr_meta_pages;\nstatic struct memory_bitmap orig_bm;\nstatic struct memory_bitmap copy_bm;\n\nint snapshot_read_next(struct snapshot_handle *handle)\n{\n\tif (handle->cur > nr_meta_pages + nr_copy_pages)\n\t\treturn 0;\n\n\tif (!buffer) {\n\t\t/* This makes the buffer be freed by swsusp_free() */\n\t\tbuffer = get_image_page(GFP_ATOMIC, PG_ANY);\n\t\tif (!buffer)\n\t\t\treturn -ENOMEM;\n\t}\n\tif (!handle->cur) {\n\t\tint error;\n\n\t\terror = init_header((struct swsusp_info *)buffer);\n\t\tif (error)\n\t\t\treturn error;\n\t\thandle->buffer = buffer;\n\t\tmemory_bm_position_reset(&orig_bm);\n\t\tmemory_bm_position_reset(&copy_bm);\n\t} else if (handle->cur <= nr_meta_pages) {\n\t\tclear_page(buffer);\n\t\tpack_pfns(buffer, &orig_bm);\n\t} else {\n\t\tstruct page *page;\n\n\t\tpage = pfn_to_page(memory_bm_next_pfn(&copy_bm));\n\t\tif (PageHighMem(page)) {\n\t\t\t/*\n\t\t\t * Highmem pages are copied to the buffer,\n\t\t\t * because we can't return with a kmapped\n\t\t\t * highmem page (we may not be called again).\n\t\t\t */\n\t\t\tvoid *kaddr;\n\n\t\t\tkaddr = kmap_atomic(page);\n\t\t\tcopy_page(buffer, kaddr);\n\t\t\tkunmap_atomic(kaddr);\n\t\t\thandle->buffer = buffer;\n\t\t} else {\n\t\t\thandle->buffer = page_address(page);\n\t\t}\n\t}\n\thandle->cur++;\n\treturn PAGE_SIZE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&snapshot",
            "0",
            "sizeof(struct snapshot_handle)"
          ],
          "line": 935
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Not enough free swap\\n\""
          ],
          "line": 930
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "enough_swap",
          "args": [
            "pages"
          ],
          "line": 929
        },
        "resolved": true,
        "details": {
          "function_name": "enough_swap",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/swap.c",
          "lines": "893-902",
          "snippet": "static int enough_swap(unsigned int nr_pages)\n{\n\tunsigned int free_swap = count_swap_pages(root_swap, 1);\n\tunsigned int required;\n\n\tpr_debug(\"Free swap pages: %u\\n\", free_swap);\n\n\trequired = PAGES_FOR_IO + nr_pages;\n\treturn free_swap > required;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/ktime.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/atomic.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/lzo.h>",
            "#include <linux/slab.h>",
            "#include <linux/pm.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/device.h>",
            "#include <linux/genhd.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/file.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned short root_swap = 0xffff;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/ktime.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/atomic.h>\n#include <linux/cpumask.h>\n#include <linux/vmalloc.h>\n#include <linux/lzo.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/device.h>\n#include <linux/genhd.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\nstatic unsigned short root_swap = 0xffff;\n\nstatic int enough_swap(unsigned int nr_pages)\n{\n\tunsigned int free_swap = count_swap_pages(root_swap, 1);\n\tunsigned int required;\n\n\tpr_debug(\"Free swap pages: %u\\n\", free_swap);\n\n\trequired = PAGES_FOR_IO + nr_pages;\n\treturn free_swap > required;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Cannot get swap writer\\n\""
          ],
          "line": 925
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_swap_writer",
          "args": [
            "&handle"
          ],
          "line": 923
        },
        "resolved": true,
        "details": {
          "function_name": "get_swap_writer",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/swap.c",
          "lines": "423-452",
          "snippet": "static int get_swap_writer(struct swap_map_handle *handle)\n{\n\tint ret;\n\n\tret = swsusp_swap_check();\n\tif (ret) {\n\t\tif (ret != -ENOSPC)\n\t\t\tpr_err(\"Cannot find swap device, try swapon -a\\n\");\n\t\treturn ret;\n\t}\n\thandle->cur = (struct swap_map_page *)get_zeroed_page(GFP_KERNEL);\n\tif (!handle->cur) {\n\t\tret = -ENOMEM;\n\t\tgoto err_close;\n\t}\n\thandle->cur_swap = alloc_swapdev_block(root_swap);\n\tif (!handle->cur_swap) {\n\t\tret = -ENOSPC;\n\t\tgoto err_rel;\n\t}\n\thandle->k = 0;\n\thandle->reqd_free_pages = reqd_free_pages();\n\thandle->first_sector = handle->cur_swap;\n\treturn 0;\nerr_rel:\n\trelease_swap_writer(handle);\nerr_close:\n\tswsusp_close(FMODE_WRITE);\n\treturn ret;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/ktime.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/atomic.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/lzo.h>",
            "#include <linux/slab.h>",
            "#include <linux/pm.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/device.h>",
            "#include <linux/genhd.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/file.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned short root_swap = 0xffff;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/ktime.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/atomic.h>\n#include <linux/cpumask.h>\n#include <linux/vmalloc.h>\n#include <linux/lzo.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/device.h>\n#include <linux/genhd.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\nstatic unsigned short root_swap = 0xffff;\n\nstatic int get_swap_writer(struct swap_map_handle *handle)\n{\n\tint ret;\n\n\tret = swsusp_swap_check();\n\tif (ret) {\n\t\tif (ret != -ENOSPC)\n\t\t\tpr_err(\"Cannot find swap device, try swapon -a\\n\");\n\t\treturn ret;\n\t}\n\thandle->cur = (struct swap_map_page *)get_zeroed_page(GFP_KERNEL);\n\tif (!handle->cur) {\n\t\tret = -ENOMEM;\n\t\tgoto err_close;\n\t}\n\thandle->cur_swap = alloc_swapdev_block(root_swap);\n\tif (!handle->cur_swap) {\n\t\tret = -ENOSPC;\n\t\tgoto err_rel;\n\t}\n\thandle->k = 0;\n\thandle->reqd_free_pages = reqd_free_pages();\n\thandle->first_sector = handle->cur_swap;\n\treturn 0;\nerr_rel:\n\trelease_swap_writer(handle);\nerr_close:\n\tswsusp_close(FMODE_WRITE);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "snapshot_get_image_size",
          "args": [],
          "line": 922
        },
        "resolved": true,
        "details": {
          "function_name": "snapshot_get_image_size",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/snapshot.c",
          "lines": "2084-2087",
          "snippet": "unsigned long snapshot_get_image_size(void)\n{\n\treturn nr_copy_pages + nr_meta_pages + 1;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned int nr_copy_pages;",
            "static unsigned int nr_meta_pages;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\nstatic unsigned int nr_copy_pages;\nstatic unsigned int nr_meta_pages;\n\nunsigned long snapshot_get_image_size(void)\n{\n\treturn nr_copy_pages + nr_meta_pages + 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/ktime.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/atomic.h>\n#include <linux/cpumask.h>\n#include <linux/vmalloc.h>\n#include <linux/lzo.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/device.h>\n#include <linux/genhd.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\nint swsusp_write(unsigned int flags)\n{\n\tstruct swap_map_handle handle;\n\tstruct snapshot_handle snapshot;\n\tstruct swsusp_info *header;\n\tunsigned long pages;\n\tint error;\n\n\tpages = snapshot_get_image_size();\n\terror = get_swap_writer(&handle);\n\tif (error) {\n\t\tpr_err(\"Cannot get swap writer\\n\");\n\t\treturn error;\n\t}\n\tif (flags & SF_NOCOMPRESS_MODE) {\n\t\tif (!enough_swap(pages)) {\n\t\t\tpr_err(\"Not enough free swap\\n\");\n\t\t\terror = -ENOSPC;\n\t\t\tgoto out_finish;\n\t\t}\n\t}\n\tmemset(&snapshot, 0, sizeof(struct snapshot_handle));\n\terror = snapshot_read_next(&snapshot);\n\tif (error < (int)PAGE_SIZE) {\n\t\tif (error >= 0)\n\t\t\terror = -EFAULT;\n\n\t\tgoto out_finish;\n\t}\n\theader = (struct swsusp_info *)data_of(snapshot);\n\terror = swap_write_page(&handle, header, NULL);\n\tif (!error) {\n\t\terror = (flags & SF_NOCOMPRESS_MODE) ?\n\t\t\tsave_image(&handle, &snapshot, pages - 1) :\n\t\t\tsave_image_lzo(&handle, &snapshot, pages - 1);\n\t}\nout_finish:\n\terror = swap_writer_finish(&handle, flags, error);\n\treturn error;\n}"
  },
  {
    "function_name": "enough_swap",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/swap.c",
    "lines": "893-902",
    "snippet": "static int enough_swap(unsigned int nr_pages)\n{\n\tunsigned int free_swap = count_swap_pages(root_swap, 1);\n\tunsigned int required;\n\n\tpr_debug(\"Free swap pages: %u\\n\", free_swap);\n\n\trequired = PAGES_FOR_IO + nr_pages;\n\treturn free_swap > required;\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/ktime.h>",
      "#include <linux/crc32.h>",
      "#include <linux/kthread.h>",
      "#include <linux/atomic.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/lzo.h>",
      "#include <linux/slab.h>",
      "#include <linux/pm.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include <linux/device.h>",
      "#include <linux/genhd.h>",
      "#include <linux/bitops.h>",
      "#include <linux/delay.h>",
      "#include <linux/file.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned short root_swap = 0xffff;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"Free swap pages: %u\\n\"",
            "free_swap"
          ],
          "line": 898
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "count_swap_pages",
          "args": [
            "root_swap",
            "1"
          ],
          "line": 895
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/ktime.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/atomic.h>\n#include <linux/cpumask.h>\n#include <linux/vmalloc.h>\n#include <linux/lzo.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/device.h>\n#include <linux/genhd.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\nstatic unsigned short root_swap = 0xffff;\n\nstatic int enough_swap(unsigned int nr_pages)\n{\n\tunsigned int free_swap = count_swap_pages(root_swap, 1);\n\tunsigned int required;\n\n\tpr_debug(\"Free swap pages: %u\\n\", free_swap);\n\n\trequired = PAGES_FOR_IO + nr_pages;\n\treturn free_swap > required;\n}"
  },
  {
    "function_name": "save_image_lzo",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/swap.c",
    "lines": "681-884",
    "snippet": "static int save_image_lzo(struct swap_map_handle *handle,\n                          struct snapshot_handle *snapshot,\n                          unsigned int nr_to_write)\n{\n\tunsigned int m;\n\tint ret = 0;\n\tint nr_pages;\n\tint err2;\n\tstruct hib_bio_batch hb;\n\tktime_t start;\n\tktime_t stop;\n\tsize_t off;\n\tunsigned thr, run_threads, nr_threads;\n\tunsigned char *page = NULL;\n\tstruct cmp_data *data = NULL;\n\tstruct crc_data *crc = NULL;\n\n\thib_init_batch(&hb);\n\n\t/*\n\t * We'll limit the number of threads for compression to limit memory\n\t * footprint.\n\t */\n\tnr_threads = num_online_cpus() - 1;\n\tnr_threads = clamp_val(nr_threads, 1, LZO_THREADS);\n\n\tpage = (void *)__get_free_page(GFP_NOIO | __GFP_HIGH);\n\tif (!page) {\n\t\tpr_err(\"Failed to allocate LZO page\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto out_clean;\n\t}\n\n\tdata = vzalloc(array_size(nr_threads, sizeof(*data)));\n\tif (!data) {\n\t\tpr_err(\"Failed to allocate LZO data\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto out_clean;\n\t}\n\n\tcrc = kzalloc(sizeof(*crc), GFP_KERNEL);\n\tif (!crc) {\n\t\tpr_err(\"Failed to allocate crc\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto out_clean;\n\t}\n\n\t/*\n\t * Start the compression threads.\n\t */\n\tfor (thr = 0; thr < nr_threads; thr++) {\n\t\tinit_waitqueue_head(&data[thr].go);\n\t\tinit_waitqueue_head(&data[thr].done);\n\n\t\tdata[thr].thr = kthread_run(lzo_compress_threadfn,\n\t\t                            &data[thr],\n\t\t                            \"image_compress/%u\", thr);\n\t\tif (IS_ERR(data[thr].thr)) {\n\t\t\tdata[thr].thr = NULL;\n\t\t\tpr_err(\"Cannot start compression threads\\n\");\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out_clean;\n\t\t}\n\t}\n\n\t/*\n\t * Start the CRC32 thread.\n\t */\n\tinit_waitqueue_head(&crc->go);\n\tinit_waitqueue_head(&crc->done);\n\n\thandle->crc32 = 0;\n\tcrc->crc32 = &handle->crc32;\n\tfor (thr = 0; thr < nr_threads; thr++) {\n\t\tcrc->unc[thr] = data[thr].unc;\n\t\tcrc->unc_len[thr] = &data[thr].unc_len;\n\t}\n\n\tcrc->thr = kthread_run(crc32_threadfn, crc, \"image_crc32\");\n\tif (IS_ERR(crc->thr)) {\n\t\tcrc->thr = NULL;\n\t\tpr_err(\"Cannot start CRC32 thread\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto out_clean;\n\t}\n\n\t/*\n\t * Adjust the number of required free pages after all allocations have\n\t * been done. We don't want to run out of pages when writing.\n\t */\n\thandle->reqd_free_pages = reqd_free_pages();\n\n\tpr_info(\"Using %u thread(s) for compression\\n\", nr_threads);\n\tpr_info(\"Compressing and saving image data (%u pages)...\\n\",\n\t\tnr_to_write);\n\tm = nr_to_write / 10;\n\tif (!m)\n\t\tm = 1;\n\tnr_pages = 0;\n\tstart = ktime_get();\n\tfor (;;) {\n\t\tfor (thr = 0; thr < nr_threads; thr++) {\n\t\t\tfor (off = 0; off < LZO_UNC_SIZE; off += PAGE_SIZE) {\n\t\t\t\tret = snapshot_read_next(snapshot);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tgoto out_finish;\n\n\t\t\t\tif (!ret)\n\t\t\t\t\tbreak;\n\n\t\t\t\tmemcpy(data[thr].unc + off,\n\t\t\t\t       data_of(*snapshot), PAGE_SIZE);\n\n\t\t\t\tif (!(nr_pages % m))\n\t\t\t\t\tpr_info(\"Image saving progress: %3d%%\\n\",\n\t\t\t\t\t\tnr_pages / m * 10);\n\t\t\t\tnr_pages++;\n\t\t\t}\n\t\t\tif (!off)\n\t\t\t\tbreak;\n\n\t\t\tdata[thr].unc_len = off;\n\n\t\t\tatomic_set(&data[thr].ready, 1);\n\t\t\twake_up(&data[thr].go);\n\t\t}\n\n\t\tif (!thr)\n\t\t\tbreak;\n\n\t\tcrc->run_threads = thr;\n\t\tatomic_set(&crc->ready, 1);\n\t\twake_up(&crc->go);\n\n\t\tfor (run_threads = thr, thr = 0; thr < run_threads; thr++) {\n\t\t\twait_event(data[thr].done,\n\t\t\t           atomic_read(&data[thr].stop));\n\t\t\tatomic_set(&data[thr].stop, 0);\n\n\t\t\tret = data[thr].ret;\n\n\t\t\tif (ret < 0) {\n\t\t\t\tpr_err(\"LZO compression failed\\n\");\n\t\t\t\tgoto out_finish;\n\t\t\t}\n\n\t\t\tif (unlikely(!data[thr].cmp_len ||\n\t\t\t             data[thr].cmp_len >\n\t\t\t             lzo1x_worst_compress(data[thr].unc_len))) {\n\t\t\t\tpr_err(\"Invalid LZO compressed length\\n\");\n\t\t\t\tret = -1;\n\t\t\t\tgoto out_finish;\n\t\t\t}\n\n\t\t\t*(size_t *)data[thr].cmp = data[thr].cmp_len;\n\n\t\t\t/*\n\t\t\t * Given we are writing one page at a time to disk, we\n\t\t\t * copy that much from the buffer, although the last\n\t\t\t * bit will likely be smaller than full page. This is\n\t\t\t * OK - we saved the length of the compressed data, so\n\t\t\t * any garbage at the end will be discarded when we\n\t\t\t * read it.\n\t\t\t */\n\t\t\tfor (off = 0;\n\t\t\t     off < LZO_HEADER + data[thr].cmp_len;\n\t\t\t     off += PAGE_SIZE) {\n\t\t\t\tmemcpy(page, data[thr].cmp + off, PAGE_SIZE);\n\n\t\t\t\tret = swap_write_page(handle, page, &hb);\n\t\t\t\tif (ret)\n\t\t\t\t\tgoto out_finish;\n\t\t\t}\n\t\t}\n\n\t\twait_event(crc->done, atomic_read(&crc->stop));\n\t\tatomic_set(&crc->stop, 0);\n\t}\n\nout_finish:\n\terr2 = hib_wait_io(&hb);\n\tstop = ktime_get();\n\tif (!ret)\n\t\tret = err2;\n\tif (!ret)\n\t\tpr_info(\"Image saving done\\n\");\n\tswsusp_show_speed(start, stop, nr_to_write, \"Wrote\");\nout_clean:\n\thib_finish_batch(&hb);\n\tif (crc) {\n\t\tif (crc->thr)\n\t\t\tkthread_stop(crc->thr);\n\t\tkfree(crc);\n\t}\n\tif (data) {\n\t\tfor (thr = 0; thr < nr_threads; thr++)\n\t\t\tif (data[thr].thr)\n\t\t\t\tkthread_stop(data[thr].thr);\n\t\tvfree(data);\n\t}\n\tif (page) free_page((unsigned long)page);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/ktime.h>",
      "#include <linux/crc32.h>",
      "#include <linux/kthread.h>",
      "#include <linux/atomic.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/lzo.h>",
      "#include <linux/slab.h>",
      "#include <linux/pm.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include <linux/device.h>",
      "#include <linux/genhd.h>",
      "#include <linux/bitops.h>",
      "#include <linux/delay.h>",
      "#include <linux/file.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define LZO_THREADS\t3",
      "#define LZO_UNC_SIZE\t(LZO_UNC_PAGES * PAGE_SIZE)",
      "#define LZO_HEADER\tsizeof(size_t)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_page",
          "args": [
            "(unsigned long)page"
          ],
          "line": 881
        },
        "resolved": true,
        "details": {
          "function_name": "clear_or_poison_free_page",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/snapshot.c",
          "lines": "1181-1187",
          "snippet": "static void clear_or_poison_free_page(struct page *page)\n{\n\tif (page_poisoning_enabled_static())\n\t\t__kernel_poison_pages(page, 1);\n\telse if (want_init_on_free())\n\t\tclear_highpage(page);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int swsusp_page_is_free(struct page *);",
            "static void swsusp_set_page_forbidden(struct page *);",
            "static void swsusp_unset_page_forbidden(struct page *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\nstatic int swsusp_page_is_free(struct page *);\nstatic void swsusp_set_page_forbidden(struct page *);\nstatic void swsusp_unset_page_forbidden(struct page *);\n\nstatic void clear_or_poison_free_page(struct page *page)\n{\n\tif (page_poisoning_enabled_static())\n\t\t__kernel_poison_pages(page, 1);\n\telse if (want_init_on_free())\n\t\tclear_highpage(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vfree",
          "args": [
            "data"
          ],
          "line": 879
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kthread_stop",
          "args": [
            "data[thr].thr"
          ],
          "line": 878
        },
        "resolved": true,
        "details": {
          "function_name": "kthread_stop",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
          "lines": "697-715",
          "snippet": "int kthread_stop(struct task_struct *k)\n{\n\tstruct kthread *kthread;\n\tint ret;\n\n\ttrace_sched_kthread_stop(k);\n\n\tget_task_struct(k);\n\tkthread = to_kthread(k);\n\tset_bit(KTHREAD_SHOULD_STOP, &kthread->flags);\n\tkthread_unpark(k);\n\twake_up_process(k);\n\twait_for_completion(&kthread->exited);\n\tret = kthread->result;\n\tput_task_struct(k);\n\n\ttrace_sched_kthread_stop_ret(ret);\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/numa.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mm.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nint kthread_stop(struct task_struct *k)\n{\n\tstruct kthread *kthread;\n\tint ret;\n\n\ttrace_sched_kthread_stop(k);\n\n\tget_task_struct(k);\n\tkthread = to_kthread(k);\n\tset_bit(KTHREAD_SHOULD_STOP, &kthread->flags);\n\tkthread_unpark(k);\n\twake_up_process(k);\n\twait_for_completion(&kthread->exited);\n\tret = kthread->result;\n\tput_task_struct(k);\n\n\ttrace_sched_kthread_stop_ret(ret);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "crc"
          ],
          "line": 873
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hib_finish_batch",
          "args": [
            "&hb"
          ],
          "line": 869
        },
        "resolved": true,
        "details": {
          "function_name": "hib_finish_batch",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/swap.c",
          "lines": "243-246",
          "snippet": "static void hib_finish_batch(struct hib_bio_batch *hb)\n{\n\tblk_finish_plug(&hb->plug);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/ktime.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/atomic.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/lzo.h>",
            "#include <linux/slab.h>",
            "#include <linux/pm.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/device.h>",
            "#include <linux/genhd.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/file.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/ktime.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/atomic.h>\n#include <linux/cpumask.h>\n#include <linux/vmalloc.h>\n#include <linux/lzo.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/device.h>\n#include <linux/genhd.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\nstatic void hib_finish_batch(struct hib_bio_batch *hb)\n{\n\tblk_finish_plug(&hb->plug);\n}"
        }
      },
      {
        "call_info": {
          "callee": "swsusp_show_speed",
          "args": [
            "start",
            "stop",
            "nr_to_write",
            "\"Wrote\""
          ],
          "line": 867
        },
        "resolved": true,
        "details": {
          "function_name": "swsusp_show_speed",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/hibernate.c",
          "lines": "254-273",
          "snippet": "void swsusp_show_speed(ktime_t start, ktime_t stop,\n\t\t      unsigned nr_pages, char *msg)\n{\n\tktime_t diff;\n\tu64 elapsed_centisecs64;\n\tunsigned int centisecs;\n\tunsigned int k;\n\tunsigned int kps;\n\n\tdiff = ktime_sub(stop, start);\n\telapsed_centisecs64 = ktime_divns(diff, 10*NSEC_PER_MSEC);\n\tcentisecs = elapsed_centisecs64;\n\tif (centisecs == 0)\n\t\tcentisecs = 1;\t/* avoid div-by-zero */\n\tk = nr_pages * (PAGE_SIZE / 1024);\n\tkps = (k * 100) / centisecs;\n\tpr_info(\"%s %u kbytes in %u.%02u seconds (%u.%02u MB/s)\\n\",\n\t\tmsg, k, centisecs / 100, centisecs % 100, kps / 1000,\n\t\t(kps % 1000) / 10);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <trace/events/power.h>",
            "#include <linux/secretmem.h>",
            "#include <linux/security.h>",
            "#include <linux/ktime.h>",
            "#include <linux/genhd.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/gfp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cpu.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/pm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/delay.h>",
            "#include <linux/async.h>",
            "#include <linux/device.h>",
            "#include <linux/string.h>",
            "#include <linux/reboot.h>",
            "#include <linux/suspend.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <trace/events/power.h>\n#include <linux/secretmem.h>\n#include <linux/security.h>\n#include <linux/ktime.h>\n#include <linux/genhd.h>\n#include <linux/ctype.h>\n#include <linux/syscore_ops.h>\n#include <linux/gfp.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/pm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/delay.h>\n#include <linux/async.h>\n#include <linux/device.h>\n#include <linux/string.h>\n#include <linux/reboot.h>\n#include <linux/suspend.h>\n#include <linux/export.h>\n\nvoid swsusp_show_speed(ktime_t start, ktime_t stop,\n\t\t      unsigned nr_pages, char *msg)\n{\n\tktime_t diff;\n\tu64 elapsed_centisecs64;\n\tunsigned int centisecs;\n\tunsigned int k;\n\tunsigned int kps;\n\n\tdiff = ktime_sub(stop, start);\n\telapsed_centisecs64 = ktime_divns(diff, 10*NSEC_PER_MSEC);\n\tcentisecs = elapsed_centisecs64;\n\tif (centisecs == 0)\n\t\tcentisecs = 1;\t/* avoid div-by-zero */\n\tk = nr_pages * (PAGE_SIZE / 1024);\n\tkps = (k * 100) / centisecs;\n\tpr_info(\"%s %u kbytes in %u.%02u seconds (%u.%02u MB/s)\\n\",\n\t\tmsg, k, centisecs / 100, centisecs % 100, kps / 1000,\n\t\t(kps % 1000) / 10);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Image saving done\\n\""
          ],
          "line": 866
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_get",
          "args": [],
          "line": 862
        },
        "resolved": true,
        "details": {
          "function_name": "__ktime_get_real_seconds",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
          "lines": "1025-1030",
          "snippet": "noinstr time64_t __ktime_get_real_seconds(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\n\treturn tk->xtime_sec;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nnoinstr time64_t __ktime_get_real_seconds(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\n\treturn tk->xtime_sec;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hib_wait_io",
          "args": [
            "&hb"
          ],
          "line": 861
        },
        "resolved": true,
        "details": {
          "function_name": "hib_wait_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/swap.c",
          "lines": "305-313",
          "snippet": "static int hib_wait_io(struct hib_bio_batch *hb)\n{\n\t/*\n\t * We are relying on the behavior of blk_plug that a thread with\n\t * a plug will flush the plug list before sleeping.\n\t */\n\twait_event(hb->wait, atomic_read(&hb->count) == 0);\n\treturn blk_status_to_errno(hb->error);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/ktime.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/atomic.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/lzo.h>",
            "#include <linux/slab.h>",
            "#include <linux/pm.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/device.h>",
            "#include <linux/genhd.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/file.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/ktime.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/atomic.h>\n#include <linux/cpumask.h>\n#include <linux/vmalloc.h>\n#include <linux/lzo.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/device.h>\n#include <linux/genhd.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\nstatic int hib_wait_io(struct hib_bio_batch *hb)\n{\n\t/*\n\t * We are relying on the behavior of blk_plug that a thread with\n\t * a plug will flush the plug list before sleeping.\n\t */\n\twait_event(hb->wait, atomic_read(&hb->count) == 0);\n\treturn blk_status_to_errno(hb->error);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&crc->stop",
            "0"
          ],
          "line": 857
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_event",
          "args": [
            "crc->done",
            "atomic_read(&crc->stop)"
          ],
          "line": 856
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&crc->stop"
          ],
          "line": 856
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swap_write_page",
          "args": [
            "handle",
            "page",
            "&hb"
          ],
          "line": 850
        },
        "resolved": true,
        "details": {
          "function_name": "swap_write_page",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/swap.c",
          "lines": "454-492",
          "snippet": "static int swap_write_page(struct swap_map_handle *handle, void *buf,\n\t\tstruct hib_bio_batch *hb)\n{\n\tint error = 0;\n\tsector_t offset;\n\n\tif (!handle->cur)\n\t\treturn -EINVAL;\n\toffset = alloc_swapdev_block(root_swap);\n\terror = write_page(buf, offset, hb);\n\tif (error)\n\t\treturn error;\n\thandle->cur->entries[handle->k++] = offset;\n\tif (handle->k >= MAP_PAGE_ENTRIES) {\n\t\toffset = alloc_swapdev_block(root_swap);\n\t\tif (!offset)\n\t\t\treturn -ENOSPC;\n\t\thandle->cur->next_swap = offset;\n\t\terror = write_page(handle->cur, handle->cur_swap, hb);\n\t\tif (error)\n\t\t\tgoto out;\n\t\tclear_page(handle->cur);\n\t\thandle->cur_swap = offset;\n\t\thandle->k = 0;\n\n\t\tif (hb && low_free_pages() <= handle->reqd_free_pages) {\n\t\t\terror = hib_wait_io(hb);\n\t\t\tif (error)\n\t\t\t\tgoto out;\n\t\t\t/*\n\t\t\t * Recalculate the number of required free pages, to\n\t\t\t * make sure we never take more than half.\n\t\t\t */\n\t\t\thandle->reqd_free_pages = reqd_free_pages();\n\t\t}\n\t}\n out:\n\treturn error;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/ktime.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/atomic.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/lzo.h>",
            "#include <linux/slab.h>",
            "#include <linux/pm.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/device.h>",
            "#include <linux/genhd.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/file.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define MAP_PAGE_ENTRIES\t(PAGE_SIZE / sizeof(sector_t) - 1)"
          ],
          "globals_used": [
            "static unsigned short root_swap = 0xffff;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/ktime.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/atomic.h>\n#include <linux/cpumask.h>\n#include <linux/vmalloc.h>\n#include <linux/lzo.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/device.h>\n#include <linux/genhd.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\n#define MAP_PAGE_ENTRIES\t(PAGE_SIZE / sizeof(sector_t) - 1)\n\nstatic unsigned short root_swap = 0xffff;\n\nstatic int swap_write_page(struct swap_map_handle *handle, void *buf,\n\t\tstruct hib_bio_batch *hb)\n{\n\tint error = 0;\n\tsector_t offset;\n\n\tif (!handle->cur)\n\t\treturn -EINVAL;\n\toffset = alloc_swapdev_block(root_swap);\n\terror = write_page(buf, offset, hb);\n\tif (error)\n\t\treturn error;\n\thandle->cur->entries[handle->k++] = offset;\n\tif (handle->k >= MAP_PAGE_ENTRIES) {\n\t\toffset = alloc_swapdev_block(root_swap);\n\t\tif (!offset)\n\t\t\treturn -ENOSPC;\n\t\thandle->cur->next_swap = offset;\n\t\terror = write_page(handle->cur, handle->cur_swap, hb);\n\t\tif (error)\n\t\t\tgoto out;\n\t\tclear_page(handle->cur);\n\t\thandle->cur_swap = offset;\n\t\thandle->k = 0;\n\n\t\tif (hb && low_free_pages() <= handle->reqd_free_pages) {\n\t\t\terror = hib_wait_io(hb);\n\t\t\tif (error)\n\t\t\t\tgoto out;\n\t\t\t/*\n\t\t\t * Recalculate the number of required free pages, to\n\t\t\t * make sure we never take more than half.\n\t\t\t */\n\t\t\thandle->reqd_free_pages = reqd_free_pages();\n\t\t}\n\t}\n out:\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "page",
            "data[thr].cmp + off",
            "PAGE_SIZE"
          ],
          "line": 848
        },
        "resolved": true,
        "details": {
          "function_name": "memcpy_skip",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/internal.h",
          "lines": "180-184",
          "snippet": "static inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/refcount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/refcount.h>\n#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n\nstatic inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Invalid LZO compressed length\\n\""
          ],
          "line": 830
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!data[thr].cmp_len ||\n\t\t\t             data[thr].cmp_len >\n\t\t\t             lzo1x_worst_compress(data[thr].unc_len)"
          ],
          "line": 827
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lzo1x_worst_compress",
          "args": [
            "data[thr].unc_len"
          ],
          "line": 829
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"LZO compression failed\\n\""
          ],
          "line": 823
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&data[thr].stop",
            "0"
          ],
          "line": 818
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_event",
          "args": [
            "data[thr].done",
            "atomic_read(&data[thr].stop)"
          ],
          "line": 816
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&data[thr].stop"
          ],
          "line": 817
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wake_up",
          "args": [
            "&crc->go"
          ],
          "line": 813
        },
        "resolved": true,
        "details": {
          "function_name": "wake_up_worker",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "847-853",
          "snippet": "static void wake_up_worker(struct worker_pool *pool)\n{\n\tstruct worker *worker = first_idle_worker(pool);\n\n\tif (likely(worker))\n\t\twake_up_process(worker->task);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
            "static void show_one_worker_pool(struct worker_pool *pool);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nstatic void wake_up_worker(struct worker_pool *pool)\n{\n\tstruct worker *worker = first_idle_worker(pool);\n\n\tif (likely(worker))\n\t\twake_up_process(worker->task);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&crc->ready",
            "1"
          ],
          "line": 812
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&data[thr].ready",
            "1"
          ],
          "line": 804
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Image saving progress: %3d%%\\n\"",
            "nr_pages / m * 10"
          ],
          "line": 795
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "data_of",
          "args": [
            "*snapshot"
          ],
          "line": 792
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snapshot_read_next",
          "args": [
            "snapshot"
          ],
          "line": 784
        },
        "resolved": true,
        "details": {
          "function_name": "snapshot_read_next",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/snapshot.c",
          "lines": "2135-2180",
          "snippet": "int snapshot_read_next(struct snapshot_handle *handle)\n{\n\tif (handle->cur > nr_meta_pages + nr_copy_pages)\n\t\treturn 0;\n\n\tif (!buffer) {\n\t\t/* This makes the buffer be freed by swsusp_free() */\n\t\tbuffer = get_image_page(GFP_ATOMIC, PG_ANY);\n\t\tif (!buffer)\n\t\t\treturn -ENOMEM;\n\t}\n\tif (!handle->cur) {\n\t\tint error;\n\n\t\terror = init_header((struct swsusp_info *)buffer);\n\t\tif (error)\n\t\t\treturn error;\n\t\thandle->buffer = buffer;\n\t\tmemory_bm_position_reset(&orig_bm);\n\t\tmemory_bm_position_reset(&copy_bm);\n\t} else if (handle->cur <= nr_meta_pages) {\n\t\tclear_page(buffer);\n\t\tpack_pfns(buffer, &orig_bm);\n\t} else {\n\t\tstruct page *page;\n\n\t\tpage = pfn_to_page(memory_bm_next_pfn(&copy_bm));\n\t\tif (PageHighMem(page)) {\n\t\t\t/*\n\t\t\t * Highmem pages are copied to the buffer,\n\t\t\t * because we can't return with a kmapped\n\t\t\t * highmem page (we may not be called again).\n\t\t\t */\n\t\t\tvoid *kaddr;\n\n\t\t\tkaddr = kmap_atomic(page);\n\t\t\tcopy_page(buffer, kaddr);\n\t\t\tkunmap_atomic(kaddr);\n\t\t\thandle->buffer = buffer;\n\t\t} else {\n\t\t\thandle->buffer = page_address(page);\n\t\t}\n\t}\n\thandle->cur++;\n\treturn PAGE_SIZE;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [
            "#define PG_ANY\t\t0"
          ],
          "globals_used": [
            "static int swsusp_page_is_free(struct page *);",
            "static void swsusp_set_page_forbidden(struct page *);",
            "static void swsusp_unset_page_forbidden(struct page *);",
            "static void *buffer;",
            "static unsigned int nr_copy_pages;",
            "static unsigned int nr_meta_pages;",
            "static struct memory_bitmap orig_bm;",
            "static struct memory_bitmap copy_bm;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\n#define PG_ANY\t\t0\n\nstatic int swsusp_page_is_free(struct page *);\nstatic void swsusp_set_page_forbidden(struct page *);\nstatic void swsusp_unset_page_forbidden(struct page *);\nstatic void *buffer;\nstatic unsigned int nr_copy_pages;\nstatic unsigned int nr_meta_pages;\nstatic struct memory_bitmap orig_bm;\nstatic struct memory_bitmap copy_bm;\n\nint snapshot_read_next(struct snapshot_handle *handle)\n{\n\tif (handle->cur > nr_meta_pages + nr_copy_pages)\n\t\treturn 0;\n\n\tif (!buffer) {\n\t\t/* This makes the buffer be freed by swsusp_free() */\n\t\tbuffer = get_image_page(GFP_ATOMIC, PG_ANY);\n\t\tif (!buffer)\n\t\t\treturn -ENOMEM;\n\t}\n\tif (!handle->cur) {\n\t\tint error;\n\n\t\terror = init_header((struct swsusp_info *)buffer);\n\t\tif (error)\n\t\t\treturn error;\n\t\thandle->buffer = buffer;\n\t\tmemory_bm_position_reset(&orig_bm);\n\t\tmemory_bm_position_reset(&copy_bm);\n\t} else if (handle->cur <= nr_meta_pages) {\n\t\tclear_page(buffer);\n\t\tpack_pfns(buffer, &orig_bm);\n\t} else {\n\t\tstruct page *page;\n\n\t\tpage = pfn_to_page(memory_bm_next_pfn(&copy_bm));\n\t\tif (PageHighMem(page)) {\n\t\t\t/*\n\t\t\t * Highmem pages are copied to the buffer,\n\t\t\t * because we can't return with a kmapped\n\t\t\t * highmem page (we may not be called again).\n\t\t\t */\n\t\t\tvoid *kaddr;\n\n\t\t\tkaddr = kmap_atomic(page);\n\t\t\tcopy_page(buffer, kaddr);\n\t\t\tkunmap_atomic(kaddr);\n\t\t\thandle->buffer = buffer;\n\t\t} else {\n\t\t\thandle->buffer = page_address(page);\n\t\t}\n\t}\n\thandle->cur++;\n\treturn PAGE_SIZE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Compressing and saving image data (%u pages)...\\n\"",
            "nr_to_write"
          ],
          "line": 774
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Using %u thread(s) for compression\\n\"",
            "nr_threads"
          ],
          "line": 773
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reqd_free_pages",
          "args": [],
          "line": 771
        },
        "resolved": true,
        "details": {
          "function_name": "reqd_free_pages",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/swap.c",
          "lines": "77-80",
          "snippet": "static inline unsigned long reqd_free_pages(void)\n{\n\treturn low_free_pages() / 2;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/ktime.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/atomic.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/lzo.h>",
            "#include <linux/slab.h>",
            "#include <linux/pm.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/device.h>",
            "#include <linux/genhd.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/file.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/ktime.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/atomic.h>\n#include <linux/cpumask.h>\n#include <linux/vmalloc.h>\n#include <linux/lzo.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/device.h>\n#include <linux/genhd.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\nstatic inline unsigned long reqd_free_pages(void)\n{\n\treturn low_free_pages() / 2;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Cannot start CRC32 thread\\n\""
          ],
          "line": 762
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "crc->thr"
          ],
          "line": 760
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kthread_run",
          "args": [
            "crc32_threadfn",
            "crc",
            "\"image_crc32\""
          ],
          "line": 759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_waitqueue_head",
          "args": [
            "&crc->done"
          ],
          "line": 750
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_waitqueue_head",
          "args": [
            "&crc->go"
          ],
          "line": 749
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Cannot start compression threads\\n\""
          ],
          "line": 740
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "data[thr].thr"
          ],
          "line": 738
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kthread_run",
          "args": [
            "lzo_compress_threadfn",
            "&data[thr]",
            "\"image_compress/%u\"",
            "thr"
          ],
          "line": 735
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_waitqueue_head",
          "args": [
            "&data[thr].done"
          ],
          "line": 733
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_waitqueue_head",
          "args": [
            "&data[thr].go"
          ],
          "line": 732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Failed to allocate crc\\n\""
          ],
          "line": 723
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*crc)",
            "GFP_KERNEL"
          ],
          "line": 721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Failed to allocate LZO data\\n\""
          ],
          "line": 716
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vzalloc",
          "args": [
            "array_size(nr_threads, sizeof(*data))"
          ],
          "line": 714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "array_size",
          "args": [
            "nr_threads",
            "sizeof(*data)"
          ],
          "line": 714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Failed to allocate LZO page\\n\""
          ],
          "line": 709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_free_page",
          "args": [
            "GFP_NOIO | __GFP_HIGH"
          ],
          "line": 707
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clamp_val",
          "args": [
            "nr_threads",
            "1",
            "LZO_THREADS"
          ],
          "line": 705
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "num_online_cpus",
          "args": [],
          "line": 704
        },
        "resolved": true,
        "details": {
          "function_name": "torture_num_online_cpus",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/torture.c",
          "lines": "185-188",
          "snippet": "int torture_num_online_cpus(void)\n{\n\treturn READ_ONCE(torture_online_cpus);\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint torture_num_online_cpus(void)\n{\n\treturn READ_ONCE(torture_online_cpus);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hib_init_batch",
          "args": [
            "&hb"
          ],
          "line": 698
        },
        "resolved": true,
        "details": {
          "function_name": "hib_init_batch",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/swap.c",
          "lines": "235-241",
          "snippet": "static void hib_init_batch(struct hib_bio_batch *hb)\n{\n\tatomic_set(&hb->count, 0);\n\tinit_waitqueue_head(&hb->wait);\n\thb->error = BLK_STS_OK;\n\tblk_start_plug(&hb->plug);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/ktime.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/atomic.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/lzo.h>",
            "#include <linux/slab.h>",
            "#include <linux/pm.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/device.h>",
            "#include <linux/genhd.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/file.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/ktime.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/atomic.h>\n#include <linux/cpumask.h>\n#include <linux/vmalloc.h>\n#include <linux/lzo.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/device.h>\n#include <linux/genhd.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\nstatic void hib_init_batch(struct hib_bio_batch *hb)\n{\n\tatomic_set(&hb->count, 0);\n\tinit_waitqueue_head(&hb->wait);\n\thb->error = BLK_STS_OK;\n\tblk_start_plug(&hb->plug);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/ktime.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/atomic.h>\n#include <linux/cpumask.h>\n#include <linux/vmalloc.h>\n#include <linux/lzo.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/device.h>\n#include <linux/genhd.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\n#define LZO_THREADS\t3\n#define LZO_UNC_SIZE\t(LZO_UNC_PAGES * PAGE_SIZE)\n#define LZO_HEADER\tsizeof(size_t)\n\nstatic int save_image_lzo(struct swap_map_handle *handle,\n                          struct snapshot_handle *snapshot,\n                          unsigned int nr_to_write)\n{\n\tunsigned int m;\n\tint ret = 0;\n\tint nr_pages;\n\tint err2;\n\tstruct hib_bio_batch hb;\n\tktime_t start;\n\tktime_t stop;\n\tsize_t off;\n\tunsigned thr, run_threads, nr_threads;\n\tunsigned char *page = NULL;\n\tstruct cmp_data *data = NULL;\n\tstruct crc_data *crc = NULL;\n\n\thib_init_batch(&hb);\n\n\t/*\n\t * We'll limit the number of threads for compression to limit memory\n\t * footprint.\n\t */\n\tnr_threads = num_online_cpus() - 1;\n\tnr_threads = clamp_val(nr_threads, 1, LZO_THREADS);\n\n\tpage = (void *)__get_free_page(GFP_NOIO | __GFP_HIGH);\n\tif (!page) {\n\t\tpr_err(\"Failed to allocate LZO page\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto out_clean;\n\t}\n\n\tdata = vzalloc(array_size(nr_threads, sizeof(*data)));\n\tif (!data) {\n\t\tpr_err(\"Failed to allocate LZO data\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto out_clean;\n\t}\n\n\tcrc = kzalloc(sizeof(*crc), GFP_KERNEL);\n\tif (!crc) {\n\t\tpr_err(\"Failed to allocate crc\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto out_clean;\n\t}\n\n\t/*\n\t * Start the compression threads.\n\t */\n\tfor (thr = 0; thr < nr_threads; thr++) {\n\t\tinit_waitqueue_head(&data[thr].go);\n\t\tinit_waitqueue_head(&data[thr].done);\n\n\t\tdata[thr].thr = kthread_run(lzo_compress_threadfn,\n\t\t                            &data[thr],\n\t\t                            \"image_compress/%u\", thr);\n\t\tif (IS_ERR(data[thr].thr)) {\n\t\t\tdata[thr].thr = NULL;\n\t\t\tpr_err(\"Cannot start compression threads\\n\");\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out_clean;\n\t\t}\n\t}\n\n\t/*\n\t * Start the CRC32 thread.\n\t */\n\tinit_waitqueue_head(&crc->go);\n\tinit_waitqueue_head(&crc->done);\n\n\thandle->crc32 = 0;\n\tcrc->crc32 = &handle->crc32;\n\tfor (thr = 0; thr < nr_threads; thr++) {\n\t\tcrc->unc[thr] = data[thr].unc;\n\t\tcrc->unc_len[thr] = &data[thr].unc_len;\n\t}\n\n\tcrc->thr = kthread_run(crc32_threadfn, crc, \"image_crc32\");\n\tif (IS_ERR(crc->thr)) {\n\t\tcrc->thr = NULL;\n\t\tpr_err(\"Cannot start CRC32 thread\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto out_clean;\n\t}\n\n\t/*\n\t * Adjust the number of required free pages after all allocations have\n\t * been done. We don't want to run out of pages when writing.\n\t */\n\thandle->reqd_free_pages = reqd_free_pages();\n\n\tpr_info(\"Using %u thread(s) for compression\\n\", nr_threads);\n\tpr_info(\"Compressing and saving image data (%u pages)...\\n\",\n\t\tnr_to_write);\n\tm = nr_to_write / 10;\n\tif (!m)\n\t\tm = 1;\n\tnr_pages = 0;\n\tstart = ktime_get();\n\tfor (;;) {\n\t\tfor (thr = 0; thr < nr_threads; thr++) {\n\t\t\tfor (off = 0; off < LZO_UNC_SIZE; off += PAGE_SIZE) {\n\t\t\t\tret = snapshot_read_next(snapshot);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tgoto out_finish;\n\n\t\t\t\tif (!ret)\n\t\t\t\t\tbreak;\n\n\t\t\t\tmemcpy(data[thr].unc + off,\n\t\t\t\t       data_of(*snapshot), PAGE_SIZE);\n\n\t\t\t\tif (!(nr_pages % m))\n\t\t\t\t\tpr_info(\"Image saving progress: %3d%%\\n\",\n\t\t\t\t\t\tnr_pages / m * 10);\n\t\t\t\tnr_pages++;\n\t\t\t}\n\t\t\tif (!off)\n\t\t\t\tbreak;\n\n\t\t\tdata[thr].unc_len = off;\n\n\t\t\tatomic_set(&data[thr].ready, 1);\n\t\t\twake_up(&data[thr].go);\n\t\t}\n\n\t\tif (!thr)\n\t\t\tbreak;\n\n\t\tcrc->run_threads = thr;\n\t\tatomic_set(&crc->ready, 1);\n\t\twake_up(&crc->go);\n\n\t\tfor (run_threads = thr, thr = 0; thr < run_threads; thr++) {\n\t\t\twait_event(data[thr].done,\n\t\t\t           atomic_read(&data[thr].stop));\n\t\t\tatomic_set(&data[thr].stop, 0);\n\n\t\t\tret = data[thr].ret;\n\n\t\t\tif (ret < 0) {\n\t\t\t\tpr_err(\"LZO compression failed\\n\");\n\t\t\t\tgoto out_finish;\n\t\t\t}\n\n\t\t\tif (unlikely(!data[thr].cmp_len ||\n\t\t\t             data[thr].cmp_len >\n\t\t\t             lzo1x_worst_compress(data[thr].unc_len))) {\n\t\t\t\tpr_err(\"Invalid LZO compressed length\\n\");\n\t\t\t\tret = -1;\n\t\t\t\tgoto out_finish;\n\t\t\t}\n\n\t\t\t*(size_t *)data[thr].cmp = data[thr].cmp_len;\n\n\t\t\t/*\n\t\t\t * Given we are writing one page at a time to disk, we\n\t\t\t * copy that much from the buffer, although the last\n\t\t\t * bit will likely be smaller than full page. This is\n\t\t\t * OK - we saved the length of the compressed data, so\n\t\t\t * any garbage at the end will be discarded when we\n\t\t\t * read it.\n\t\t\t */\n\t\t\tfor (off = 0;\n\t\t\t     off < LZO_HEADER + data[thr].cmp_len;\n\t\t\t     off += PAGE_SIZE) {\n\t\t\t\tmemcpy(page, data[thr].cmp + off, PAGE_SIZE);\n\n\t\t\t\tret = swap_write_page(handle, page, &hb);\n\t\t\t\tif (ret)\n\t\t\t\t\tgoto out_finish;\n\t\t\t}\n\t\t}\n\n\t\twait_event(crc->done, atomic_read(&crc->stop));\n\t\tatomic_set(&crc->stop, 0);\n\t}\n\nout_finish:\n\terr2 = hib_wait_io(&hb);\n\tstop = ktime_get();\n\tif (!ret)\n\t\tret = err2;\n\tif (!ret)\n\t\tpr_info(\"Image saving done\\n\");\n\tswsusp_show_speed(start, stop, nr_to_write, \"Wrote\");\nout_clean:\n\thib_finish_batch(&hb);\n\tif (crc) {\n\t\tif (crc->thr)\n\t\t\tkthread_stop(crc->thr);\n\t\tkfree(crc);\n\t}\n\tif (data) {\n\t\tfor (thr = 0; thr < nr_threads; thr++)\n\t\t\tif (data[thr].thr)\n\t\t\t\tkthread_stop(data[thr].thr);\n\t\tvfree(data);\n\t}\n\tif (page) free_page((unsigned long)page);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "lzo_compress_threadfn",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/swap.c",
    "lines": "650-673",
    "snippet": "static int lzo_compress_threadfn(void *data)\n{\n\tstruct cmp_data *d = data;\n\n\twhile (1) {\n\t\twait_event(d->go, atomic_read(&d->ready) ||\n\t\t                  kthread_should_stop());\n\t\tif (kthread_should_stop()) {\n\t\t\td->thr = NULL;\n\t\t\td->ret = -1;\n\t\t\tatomic_set(&d->stop, 1);\n\t\t\twake_up(&d->done);\n\t\t\tbreak;\n\t\t}\n\t\tatomic_set(&d->ready, 0);\n\n\t\td->ret = lzo1x_1_compress(d->unc, d->unc_len,\n\t\t                          d->cmp + LZO_HEADER, &d->cmp_len,\n\t\t                          d->wrk);\n\t\tatomic_set(&d->stop, 1);\n\t\twake_up(&d->done);\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/ktime.h>",
      "#include <linux/crc32.h>",
      "#include <linux/kthread.h>",
      "#include <linux/atomic.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/lzo.h>",
      "#include <linux/slab.h>",
      "#include <linux/pm.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include <linux/device.h>",
      "#include <linux/genhd.h>",
      "#include <linux/bitops.h>",
      "#include <linux/delay.h>",
      "#include <linux/file.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define LZO_HEADER\tsizeof(size_t)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wake_up",
          "args": [
            "&d->done"
          ],
          "line": 670
        },
        "resolved": true,
        "details": {
          "function_name": "wake_up_worker",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "847-853",
          "snippet": "static void wake_up_worker(struct worker_pool *pool)\n{\n\tstruct worker *worker = first_idle_worker(pool);\n\n\tif (likely(worker))\n\t\twake_up_process(worker->task);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
            "static void show_one_worker_pool(struct worker_pool *pool);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nstatic void wake_up_worker(struct worker_pool *pool)\n{\n\tstruct worker *worker = first_idle_worker(pool);\n\n\tif (likely(worker))\n\t\twake_up_process(worker->task);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&d->stop",
            "1"
          ],
          "line": 669
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lzo1x_1_compress",
          "args": [
            "d->unc",
            "d->unc_len",
            "d->cmp + LZO_HEADER",
            "&d->cmp_len",
            "d->wrk"
          ],
          "line": 666
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&d->ready",
            "0"
          ],
          "line": 664
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&d->stop",
            "1"
          ],
          "line": 660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kthread_should_stop",
          "args": [],
          "line": 657
        },
        "resolved": true,
        "details": {
          "function_name": "kthread_should_stop",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
          "lines": "156-159",
          "snippet": "bool kthread_should_stop(void)\n{\n\treturn test_bit(KTHREAD_SHOULD_STOP, &to_kthread(current)->flags);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/numa.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mm.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nbool kthread_should_stop(void)\n{\n\treturn test_bit(KTHREAD_SHOULD_STOP, &to_kthread(current)->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_event",
          "args": [
            "d->go",
            "atomic_read(&d->ready) ||\n\t\t                  kthread_should_stop()"
          ],
          "line": 655
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&d->ready"
          ],
          "line": 655
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/ktime.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/atomic.h>\n#include <linux/cpumask.h>\n#include <linux/vmalloc.h>\n#include <linux/lzo.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/device.h>\n#include <linux/genhd.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\n#define LZO_HEADER\tsizeof(size_t)\n\nstatic int lzo_compress_threadfn(void *data)\n{\n\tstruct cmp_data *d = data;\n\n\twhile (1) {\n\t\twait_event(d->go, atomic_read(&d->ready) ||\n\t\t                  kthread_should_stop());\n\t\tif (kthread_should_stop()) {\n\t\t\td->thr = NULL;\n\t\t\td->ret = -1;\n\t\t\tatomic_set(&d->stop, 1);\n\t\t\twake_up(&d->done);\n\t\t\tbreak;\n\t\t}\n\t\tatomic_set(&d->ready, 0);\n\n\t\td->ret = lzo1x_1_compress(d->unc, d->unc_len,\n\t\t                          d->cmp + LZO_HEADER, &d->cmp_len,\n\t\t                          d->wrk);\n\t\tatomic_set(&d->stop, 1);\n\t\twake_up(&d->done);\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "crc32_threadfn",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/swap.c",
    "lines": "606-629",
    "snippet": "static int crc32_threadfn(void *data)\n{\n\tstruct crc_data *d = data;\n\tunsigned i;\n\n\twhile (1) {\n\t\twait_event(d->go, atomic_read(&d->ready) ||\n\t\t                  kthread_should_stop());\n\t\tif (kthread_should_stop()) {\n\t\t\td->thr = NULL;\n\t\t\tatomic_set(&d->stop, 1);\n\t\t\twake_up(&d->done);\n\t\t\tbreak;\n\t\t}\n\t\tatomic_set(&d->ready, 0);\n\n\t\tfor (i = 0; i < d->run_threads; i++)\n\t\t\t*d->crc32 = crc32_le(*d->crc32,\n\t\t\t                     d->unc[i], *d->unc_len[i]);\n\t\tatomic_set(&d->stop, 1);\n\t\twake_up(&d->done);\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/ktime.h>",
      "#include <linux/crc32.h>",
      "#include <linux/kthread.h>",
      "#include <linux/atomic.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/lzo.h>",
      "#include <linux/slab.h>",
      "#include <linux/pm.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include <linux/device.h>",
      "#include <linux/genhd.h>",
      "#include <linux/bitops.h>",
      "#include <linux/delay.h>",
      "#include <linux/file.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wake_up",
          "args": [
            "&d->done"
          ],
          "line": 626
        },
        "resolved": true,
        "details": {
          "function_name": "wake_up_worker",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "847-853",
          "snippet": "static void wake_up_worker(struct worker_pool *pool)\n{\n\tstruct worker *worker = first_idle_worker(pool);\n\n\tif (likely(worker))\n\t\twake_up_process(worker->task);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
            "static void show_one_worker_pool(struct worker_pool *pool);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nstatic void wake_up_worker(struct worker_pool *pool)\n{\n\tstruct worker *worker = first_idle_worker(pool);\n\n\tif (likely(worker))\n\t\twake_up_process(worker->task);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&d->stop",
            "1"
          ],
          "line": 625
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crc32_le",
          "args": [
            "*d->crc32",
            "d->unc[i]",
            "*d->unc_len[i]"
          ],
          "line": 623
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&d->ready",
            "0"
          ],
          "line": 620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&d->stop",
            "1"
          ],
          "line": 616
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kthread_should_stop",
          "args": [],
          "line": 614
        },
        "resolved": true,
        "details": {
          "function_name": "kthread_should_stop",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
          "lines": "156-159",
          "snippet": "bool kthread_should_stop(void)\n{\n\treturn test_bit(KTHREAD_SHOULD_STOP, &to_kthread(current)->flags);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/numa.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mm.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nbool kthread_should_stop(void)\n{\n\treturn test_bit(KTHREAD_SHOULD_STOP, &to_kthread(current)->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_event",
          "args": [
            "d->go",
            "atomic_read(&d->ready) ||\n\t\t                  kthread_should_stop()"
          ],
          "line": 612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&d->ready"
          ],
          "line": 612
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/ktime.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/atomic.h>\n#include <linux/cpumask.h>\n#include <linux/vmalloc.h>\n#include <linux/lzo.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/device.h>\n#include <linux/genhd.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\nstatic int crc32_threadfn(void *data)\n{\n\tstruct crc_data *d = data;\n\tunsigned i;\n\n\twhile (1) {\n\t\twait_event(d->go, atomic_read(&d->ready) ||\n\t\t                  kthread_should_stop());\n\t\tif (kthread_should_stop()) {\n\t\t\td->thr = NULL;\n\t\t\tatomic_set(&d->stop, 1);\n\t\t\twake_up(&d->done);\n\t\t\tbreak;\n\t\t}\n\t\tatomic_set(&d->ready, 0);\n\n\t\tfor (i = 0; i < d->run_threads; i++)\n\t\t\t*d->crc32 = crc32_le(*d->crc32,\n\t\t\t                     d->unc[i], *d->unc_len[i]);\n\t\tatomic_set(&d->stop, 1);\n\t\twake_up(&d->done);\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "save_image",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/swap.c",
    "lines": "544-586",
    "snippet": "static int save_image(struct swap_map_handle *handle,\n                      struct snapshot_handle *snapshot,\n                      unsigned int nr_to_write)\n{\n\tunsigned int m;\n\tint ret;\n\tint nr_pages;\n\tint err2;\n\tstruct hib_bio_batch hb;\n\tktime_t start;\n\tktime_t stop;\n\n\thib_init_batch(&hb);\n\n\tpr_info(\"Saving image data pages (%u pages)...\\n\",\n\t\tnr_to_write);\n\tm = nr_to_write / 10;\n\tif (!m)\n\t\tm = 1;\n\tnr_pages = 0;\n\tstart = ktime_get();\n\twhile (1) {\n\t\tret = snapshot_read_next(snapshot);\n\t\tif (ret <= 0)\n\t\t\tbreak;\n\t\tret = swap_write_page(handle, data_of(*snapshot), &hb);\n\t\tif (ret)\n\t\t\tbreak;\n\t\tif (!(nr_pages % m))\n\t\t\tpr_info(\"Image saving progress: %3d%%\\n\",\n\t\t\t\tnr_pages / m * 10);\n\t\tnr_pages++;\n\t}\n\terr2 = hib_wait_io(&hb);\n\thib_finish_batch(&hb);\n\tstop = ktime_get();\n\tif (!ret)\n\t\tret = err2;\n\tif (!ret)\n\t\tpr_info(\"Image saving done\\n\");\n\tswsusp_show_speed(start, stop, nr_to_write, \"Wrote\");\n\treturn ret;\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/ktime.h>",
      "#include <linux/crc32.h>",
      "#include <linux/kthread.h>",
      "#include <linux/atomic.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/lzo.h>",
      "#include <linux/slab.h>",
      "#include <linux/pm.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include <linux/device.h>",
      "#include <linux/genhd.h>",
      "#include <linux/bitops.h>",
      "#include <linux/delay.h>",
      "#include <linux/file.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "swsusp_show_speed",
          "args": [
            "start",
            "stop",
            "nr_to_write",
            "\"Wrote\""
          ],
          "line": 584
        },
        "resolved": true,
        "details": {
          "function_name": "swsusp_show_speed",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/hibernate.c",
          "lines": "254-273",
          "snippet": "void swsusp_show_speed(ktime_t start, ktime_t stop,\n\t\t      unsigned nr_pages, char *msg)\n{\n\tktime_t diff;\n\tu64 elapsed_centisecs64;\n\tunsigned int centisecs;\n\tunsigned int k;\n\tunsigned int kps;\n\n\tdiff = ktime_sub(stop, start);\n\telapsed_centisecs64 = ktime_divns(diff, 10*NSEC_PER_MSEC);\n\tcentisecs = elapsed_centisecs64;\n\tif (centisecs == 0)\n\t\tcentisecs = 1;\t/* avoid div-by-zero */\n\tk = nr_pages * (PAGE_SIZE / 1024);\n\tkps = (k * 100) / centisecs;\n\tpr_info(\"%s %u kbytes in %u.%02u seconds (%u.%02u MB/s)\\n\",\n\t\tmsg, k, centisecs / 100, centisecs % 100, kps / 1000,\n\t\t(kps % 1000) / 10);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <trace/events/power.h>",
            "#include <linux/secretmem.h>",
            "#include <linux/security.h>",
            "#include <linux/ktime.h>",
            "#include <linux/genhd.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/gfp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cpu.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/pm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/delay.h>",
            "#include <linux/async.h>",
            "#include <linux/device.h>",
            "#include <linux/string.h>",
            "#include <linux/reboot.h>",
            "#include <linux/suspend.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <trace/events/power.h>\n#include <linux/secretmem.h>\n#include <linux/security.h>\n#include <linux/ktime.h>\n#include <linux/genhd.h>\n#include <linux/ctype.h>\n#include <linux/syscore_ops.h>\n#include <linux/gfp.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/pm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/delay.h>\n#include <linux/async.h>\n#include <linux/device.h>\n#include <linux/string.h>\n#include <linux/reboot.h>\n#include <linux/suspend.h>\n#include <linux/export.h>\n\nvoid swsusp_show_speed(ktime_t start, ktime_t stop,\n\t\t      unsigned nr_pages, char *msg)\n{\n\tktime_t diff;\n\tu64 elapsed_centisecs64;\n\tunsigned int centisecs;\n\tunsigned int k;\n\tunsigned int kps;\n\n\tdiff = ktime_sub(stop, start);\n\telapsed_centisecs64 = ktime_divns(diff, 10*NSEC_PER_MSEC);\n\tcentisecs = elapsed_centisecs64;\n\tif (centisecs == 0)\n\t\tcentisecs = 1;\t/* avoid div-by-zero */\n\tk = nr_pages * (PAGE_SIZE / 1024);\n\tkps = (k * 100) / centisecs;\n\tpr_info(\"%s %u kbytes in %u.%02u seconds (%u.%02u MB/s)\\n\",\n\t\tmsg, k, centisecs / 100, centisecs % 100, kps / 1000,\n\t\t(kps % 1000) / 10);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Image saving done\\n\""
          ],
          "line": 583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_get",
          "args": [],
          "line": 579
        },
        "resolved": true,
        "details": {
          "function_name": "__ktime_get_real_seconds",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
          "lines": "1025-1030",
          "snippet": "noinstr time64_t __ktime_get_real_seconds(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\n\treturn tk->xtime_sec;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nnoinstr time64_t __ktime_get_real_seconds(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\n\treturn tk->xtime_sec;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hib_finish_batch",
          "args": [
            "&hb"
          ],
          "line": 578
        },
        "resolved": true,
        "details": {
          "function_name": "hib_finish_batch",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/swap.c",
          "lines": "243-246",
          "snippet": "static void hib_finish_batch(struct hib_bio_batch *hb)\n{\n\tblk_finish_plug(&hb->plug);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/ktime.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/atomic.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/lzo.h>",
            "#include <linux/slab.h>",
            "#include <linux/pm.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/device.h>",
            "#include <linux/genhd.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/file.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/ktime.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/atomic.h>\n#include <linux/cpumask.h>\n#include <linux/vmalloc.h>\n#include <linux/lzo.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/device.h>\n#include <linux/genhd.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\nstatic void hib_finish_batch(struct hib_bio_batch *hb)\n{\n\tblk_finish_plug(&hb->plug);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hib_wait_io",
          "args": [
            "&hb"
          ],
          "line": 577
        },
        "resolved": true,
        "details": {
          "function_name": "hib_wait_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/swap.c",
          "lines": "305-313",
          "snippet": "static int hib_wait_io(struct hib_bio_batch *hb)\n{\n\t/*\n\t * We are relying on the behavior of blk_plug that a thread with\n\t * a plug will flush the plug list before sleeping.\n\t */\n\twait_event(hb->wait, atomic_read(&hb->count) == 0);\n\treturn blk_status_to_errno(hb->error);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/ktime.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/atomic.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/lzo.h>",
            "#include <linux/slab.h>",
            "#include <linux/pm.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/device.h>",
            "#include <linux/genhd.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/file.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/ktime.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/atomic.h>\n#include <linux/cpumask.h>\n#include <linux/vmalloc.h>\n#include <linux/lzo.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/device.h>\n#include <linux/genhd.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\nstatic int hib_wait_io(struct hib_bio_batch *hb)\n{\n\t/*\n\t * We are relying on the behavior of blk_plug that a thread with\n\t * a plug will flush the plug list before sleeping.\n\t */\n\twait_event(hb->wait, atomic_read(&hb->count) == 0);\n\treturn blk_status_to_errno(hb->error);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Image saving progress: %3d%%\\n\"",
            "nr_pages / m * 10"
          ],
          "line": 573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swap_write_page",
          "args": [
            "handle",
            "data_of(*snapshot)",
            "&hb"
          ],
          "line": 569
        },
        "resolved": true,
        "details": {
          "function_name": "swap_write_page",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/swap.c",
          "lines": "454-492",
          "snippet": "static int swap_write_page(struct swap_map_handle *handle, void *buf,\n\t\tstruct hib_bio_batch *hb)\n{\n\tint error = 0;\n\tsector_t offset;\n\n\tif (!handle->cur)\n\t\treturn -EINVAL;\n\toffset = alloc_swapdev_block(root_swap);\n\terror = write_page(buf, offset, hb);\n\tif (error)\n\t\treturn error;\n\thandle->cur->entries[handle->k++] = offset;\n\tif (handle->k >= MAP_PAGE_ENTRIES) {\n\t\toffset = alloc_swapdev_block(root_swap);\n\t\tif (!offset)\n\t\t\treturn -ENOSPC;\n\t\thandle->cur->next_swap = offset;\n\t\terror = write_page(handle->cur, handle->cur_swap, hb);\n\t\tif (error)\n\t\t\tgoto out;\n\t\tclear_page(handle->cur);\n\t\thandle->cur_swap = offset;\n\t\thandle->k = 0;\n\n\t\tif (hb && low_free_pages() <= handle->reqd_free_pages) {\n\t\t\terror = hib_wait_io(hb);\n\t\t\tif (error)\n\t\t\t\tgoto out;\n\t\t\t/*\n\t\t\t * Recalculate the number of required free pages, to\n\t\t\t * make sure we never take more than half.\n\t\t\t */\n\t\t\thandle->reqd_free_pages = reqd_free_pages();\n\t\t}\n\t}\n out:\n\treturn error;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/ktime.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/atomic.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/lzo.h>",
            "#include <linux/slab.h>",
            "#include <linux/pm.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/device.h>",
            "#include <linux/genhd.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/file.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define MAP_PAGE_ENTRIES\t(PAGE_SIZE / sizeof(sector_t) - 1)"
          ],
          "globals_used": [
            "static unsigned short root_swap = 0xffff;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/ktime.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/atomic.h>\n#include <linux/cpumask.h>\n#include <linux/vmalloc.h>\n#include <linux/lzo.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/device.h>\n#include <linux/genhd.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\n#define MAP_PAGE_ENTRIES\t(PAGE_SIZE / sizeof(sector_t) - 1)\n\nstatic unsigned short root_swap = 0xffff;\n\nstatic int swap_write_page(struct swap_map_handle *handle, void *buf,\n\t\tstruct hib_bio_batch *hb)\n{\n\tint error = 0;\n\tsector_t offset;\n\n\tif (!handle->cur)\n\t\treturn -EINVAL;\n\toffset = alloc_swapdev_block(root_swap);\n\terror = write_page(buf, offset, hb);\n\tif (error)\n\t\treturn error;\n\thandle->cur->entries[handle->k++] = offset;\n\tif (handle->k >= MAP_PAGE_ENTRIES) {\n\t\toffset = alloc_swapdev_block(root_swap);\n\t\tif (!offset)\n\t\t\treturn -ENOSPC;\n\t\thandle->cur->next_swap = offset;\n\t\terror = write_page(handle->cur, handle->cur_swap, hb);\n\t\tif (error)\n\t\t\tgoto out;\n\t\tclear_page(handle->cur);\n\t\thandle->cur_swap = offset;\n\t\thandle->k = 0;\n\n\t\tif (hb && low_free_pages() <= handle->reqd_free_pages) {\n\t\t\terror = hib_wait_io(hb);\n\t\t\tif (error)\n\t\t\t\tgoto out;\n\t\t\t/*\n\t\t\t * Recalculate the number of required free pages, to\n\t\t\t * make sure we never take more than half.\n\t\t\t */\n\t\t\thandle->reqd_free_pages = reqd_free_pages();\n\t\t}\n\t}\n out:\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "data_of",
          "args": [
            "*snapshot"
          ],
          "line": 569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snapshot_read_next",
          "args": [
            "snapshot"
          ],
          "line": 566
        },
        "resolved": true,
        "details": {
          "function_name": "snapshot_read_next",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/snapshot.c",
          "lines": "2135-2180",
          "snippet": "int snapshot_read_next(struct snapshot_handle *handle)\n{\n\tif (handle->cur > nr_meta_pages + nr_copy_pages)\n\t\treturn 0;\n\n\tif (!buffer) {\n\t\t/* This makes the buffer be freed by swsusp_free() */\n\t\tbuffer = get_image_page(GFP_ATOMIC, PG_ANY);\n\t\tif (!buffer)\n\t\t\treturn -ENOMEM;\n\t}\n\tif (!handle->cur) {\n\t\tint error;\n\n\t\terror = init_header((struct swsusp_info *)buffer);\n\t\tif (error)\n\t\t\treturn error;\n\t\thandle->buffer = buffer;\n\t\tmemory_bm_position_reset(&orig_bm);\n\t\tmemory_bm_position_reset(&copy_bm);\n\t} else if (handle->cur <= nr_meta_pages) {\n\t\tclear_page(buffer);\n\t\tpack_pfns(buffer, &orig_bm);\n\t} else {\n\t\tstruct page *page;\n\n\t\tpage = pfn_to_page(memory_bm_next_pfn(&copy_bm));\n\t\tif (PageHighMem(page)) {\n\t\t\t/*\n\t\t\t * Highmem pages are copied to the buffer,\n\t\t\t * because we can't return with a kmapped\n\t\t\t * highmem page (we may not be called again).\n\t\t\t */\n\t\t\tvoid *kaddr;\n\n\t\t\tkaddr = kmap_atomic(page);\n\t\t\tcopy_page(buffer, kaddr);\n\t\t\tkunmap_atomic(kaddr);\n\t\t\thandle->buffer = buffer;\n\t\t} else {\n\t\t\thandle->buffer = page_address(page);\n\t\t}\n\t}\n\thandle->cur++;\n\treturn PAGE_SIZE;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [
            "#define PG_ANY\t\t0"
          ],
          "globals_used": [
            "static int swsusp_page_is_free(struct page *);",
            "static void swsusp_set_page_forbidden(struct page *);",
            "static void swsusp_unset_page_forbidden(struct page *);",
            "static void *buffer;",
            "static unsigned int nr_copy_pages;",
            "static unsigned int nr_meta_pages;",
            "static struct memory_bitmap orig_bm;",
            "static struct memory_bitmap copy_bm;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\n#define PG_ANY\t\t0\n\nstatic int swsusp_page_is_free(struct page *);\nstatic void swsusp_set_page_forbidden(struct page *);\nstatic void swsusp_unset_page_forbidden(struct page *);\nstatic void *buffer;\nstatic unsigned int nr_copy_pages;\nstatic unsigned int nr_meta_pages;\nstatic struct memory_bitmap orig_bm;\nstatic struct memory_bitmap copy_bm;\n\nint snapshot_read_next(struct snapshot_handle *handle)\n{\n\tif (handle->cur > nr_meta_pages + nr_copy_pages)\n\t\treturn 0;\n\n\tif (!buffer) {\n\t\t/* This makes the buffer be freed by swsusp_free() */\n\t\tbuffer = get_image_page(GFP_ATOMIC, PG_ANY);\n\t\tif (!buffer)\n\t\t\treturn -ENOMEM;\n\t}\n\tif (!handle->cur) {\n\t\tint error;\n\n\t\terror = init_header((struct swsusp_info *)buffer);\n\t\tif (error)\n\t\t\treturn error;\n\t\thandle->buffer = buffer;\n\t\tmemory_bm_position_reset(&orig_bm);\n\t\tmemory_bm_position_reset(&copy_bm);\n\t} else if (handle->cur <= nr_meta_pages) {\n\t\tclear_page(buffer);\n\t\tpack_pfns(buffer, &orig_bm);\n\t} else {\n\t\tstruct page *page;\n\n\t\tpage = pfn_to_page(memory_bm_next_pfn(&copy_bm));\n\t\tif (PageHighMem(page)) {\n\t\t\t/*\n\t\t\t * Highmem pages are copied to the buffer,\n\t\t\t * because we can't return with a kmapped\n\t\t\t * highmem page (we may not be called again).\n\t\t\t */\n\t\t\tvoid *kaddr;\n\n\t\t\tkaddr = kmap_atomic(page);\n\t\t\tcopy_page(buffer, kaddr);\n\t\t\tkunmap_atomic(kaddr);\n\t\t\thandle->buffer = buffer;\n\t\t} else {\n\t\t\thandle->buffer = page_address(page);\n\t\t}\n\t}\n\thandle->cur++;\n\treturn PAGE_SIZE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Saving image data pages (%u pages)...\\n\"",
            "nr_to_write"
          ],
          "line": 558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hib_init_batch",
          "args": [
            "&hb"
          ],
          "line": 556
        },
        "resolved": true,
        "details": {
          "function_name": "hib_init_batch",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/swap.c",
          "lines": "235-241",
          "snippet": "static void hib_init_batch(struct hib_bio_batch *hb)\n{\n\tatomic_set(&hb->count, 0);\n\tinit_waitqueue_head(&hb->wait);\n\thb->error = BLK_STS_OK;\n\tblk_start_plug(&hb->plug);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/ktime.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/atomic.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/lzo.h>",
            "#include <linux/slab.h>",
            "#include <linux/pm.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/device.h>",
            "#include <linux/genhd.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/file.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/ktime.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/atomic.h>\n#include <linux/cpumask.h>\n#include <linux/vmalloc.h>\n#include <linux/lzo.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/device.h>\n#include <linux/genhd.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\nstatic void hib_init_batch(struct hib_bio_batch *hb)\n{\n\tatomic_set(&hb->count, 0);\n\tinit_waitqueue_head(&hb->wait);\n\thb->error = BLK_STS_OK;\n\tblk_start_plug(&hb->plug);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/ktime.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/atomic.h>\n#include <linux/cpumask.h>\n#include <linux/vmalloc.h>\n#include <linux/lzo.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/device.h>\n#include <linux/genhd.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\nstatic int save_image(struct swap_map_handle *handle,\n                      struct snapshot_handle *snapshot,\n                      unsigned int nr_to_write)\n{\n\tunsigned int m;\n\tint ret;\n\tint nr_pages;\n\tint err2;\n\tstruct hib_bio_batch hb;\n\tktime_t start;\n\tktime_t stop;\n\n\thib_init_batch(&hb);\n\n\tpr_info(\"Saving image data pages (%u pages)...\\n\",\n\t\tnr_to_write);\n\tm = nr_to_write / 10;\n\tif (!m)\n\t\tm = 1;\n\tnr_pages = 0;\n\tstart = ktime_get();\n\twhile (1) {\n\t\tret = snapshot_read_next(snapshot);\n\t\tif (ret <= 0)\n\t\t\tbreak;\n\t\tret = swap_write_page(handle, data_of(*snapshot), &hb);\n\t\tif (ret)\n\t\t\tbreak;\n\t\tif (!(nr_pages % m))\n\t\t\tpr_info(\"Image saving progress: %3d%%\\n\",\n\t\t\t\tnr_pages / m * 10);\n\t\tnr_pages++;\n\t}\n\terr2 = hib_wait_io(&hb);\n\thib_finish_batch(&hb);\n\tstop = ktime_get();\n\tif (!ret)\n\t\tret = err2;\n\tif (!ret)\n\t\tpr_info(\"Image saving done\\n\");\n\tswsusp_show_speed(start, stop, nr_to_write, \"Wrote\");\n\treturn ret;\n}"
  },
  {
    "function_name": "swap_writer_finish",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/swap.c",
    "lines": "502-518",
    "snippet": "static int swap_writer_finish(struct swap_map_handle *handle,\n\t\tunsigned int flags, int error)\n{\n\tif (!error) {\n\t\tpr_info(\"S\");\n\t\terror = mark_swapfiles(handle, flags);\n\t\tpr_cont(\"|\\n\");\n\t\tflush_swap_writer(handle);\n\t}\n\n\tif (error)\n\t\tfree_all_swap_pages(root_swap);\n\trelease_swap_writer(handle);\n\tswsusp_close(FMODE_WRITE);\n\n\treturn error;\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/ktime.h>",
      "#include <linux/crc32.h>",
      "#include <linux/kthread.h>",
      "#include <linux/atomic.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/lzo.h>",
      "#include <linux/slab.h>",
      "#include <linux/pm.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include <linux/device.h>",
      "#include <linux/genhd.h>",
      "#include <linux/bitops.h>",
      "#include <linux/delay.h>",
      "#include <linux/file.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned short root_swap = 0xffff;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "swsusp_close",
          "args": [
            "FMODE_WRITE"
          ],
          "line": 515
        },
        "resolved": true,
        "details": {
          "function_name": "swsusp_close",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/swap.c",
          "lines": "1572-1580",
          "snippet": "void swsusp_close(fmode_t mode)\n{\n\tif (IS_ERR(hib_resume_bdev)) {\n\t\tpr_debug(\"Image device not initialised\\n\");\n\t\treturn;\n\t}\n\n\tblkdev_put(hib_resume_bdev, mode);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/ktime.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/atomic.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/lzo.h>",
            "#include <linux/slab.h>",
            "#include <linux/pm.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/device.h>",
            "#include <linux/genhd.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/file.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct block_device *hib_resume_bdev;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/ktime.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/atomic.h>\n#include <linux/cpumask.h>\n#include <linux/vmalloc.h>\n#include <linux/lzo.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/device.h>\n#include <linux/genhd.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\nstatic struct block_device *hib_resume_bdev;\n\nvoid swsusp_close(fmode_t mode)\n{\n\tif (IS_ERR(hib_resume_bdev)) {\n\t\tpr_debug(\"Image device not initialised\\n\");\n\t\treturn;\n\t}\n\n\tblkdev_put(hib_resume_bdev, mode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "release_swap_writer",
          "args": [
            "handle"
          ],
          "line": 514
        },
        "resolved": true,
        "details": {
          "function_name": "release_swap_writer",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/swap.c",
          "lines": "416-421",
          "snippet": "static void release_swap_writer(struct swap_map_handle *handle)\n{\n\tif (handle->cur)\n\t\tfree_page((unsigned long)handle->cur);\n\thandle->cur = NULL;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/ktime.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/atomic.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/lzo.h>",
            "#include <linux/slab.h>",
            "#include <linux/pm.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/device.h>",
            "#include <linux/genhd.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/file.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/ktime.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/atomic.h>\n#include <linux/cpumask.h>\n#include <linux/vmalloc.h>\n#include <linux/lzo.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/device.h>\n#include <linux/genhd.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\nstatic void release_swap_writer(struct swap_map_handle *handle)\n{\n\tif (handle->cur)\n\t\tfree_page((unsigned long)handle->cur);\n\thandle->cur = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_all_swap_pages",
          "args": [
            "root_swap"
          ],
          "line": 513
        },
        "resolved": true,
        "details": {
          "function_name": "free_all_swap_pages",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/swap.c",
          "lines": "199-214",
          "snippet": "void free_all_swap_pages(int swap)\n{\n\tstruct rb_node *node;\n\n\twhile ((node = swsusp_extents.rb_node)) {\n\t\tstruct swsusp_extent *ext;\n\t\tunsigned long offset;\n\n\t\text = rb_entry(node, struct swsusp_extent, node);\n\t\trb_erase(node, &swsusp_extents);\n\t\tfor (offset = ext->start; offset <= ext->end; offset++)\n\t\t\tswap_free(swp_entry(swap, offset));\n\n\t\tkfree(ext);\n\t}\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/ktime.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/atomic.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/lzo.h>",
            "#include <linux/slab.h>",
            "#include <linux/pm.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/device.h>",
            "#include <linux/genhd.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/file.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct rb_root swsusp_extents = RB_ROOT;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/ktime.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/atomic.h>\n#include <linux/cpumask.h>\n#include <linux/vmalloc.h>\n#include <linux/lzo.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/device.h>\n#include <linux/genhd.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\nstatic struct rb_root swsusp_extents = RB_ROOT;\n\nvoid free_all_swap_pages(int swap)\n{\n\tstruct rb_node *node;\n\n\twhile ((node = swsusp_extents.rb_node)) {\n\t\tstruct swsusp_extent *ext;\n\t\tunsigned long offset;\n\n\t\text = rb_entry(node, struct swsusp_extent, node);\n\t\trb_erase(node, &swsusp_extents);\n\t\tfor (offset = ext->start; offset <= ext->end; offset++)\n\t\t\tswap_free(swp_entry(swap, offset));\n\n\t\tkfree(ext);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "flush_swap_writer",
          "args": [
            "handle"
          ],
          "line": 509
        },
        "resolved": true,
        "details": {
          "function_name": "flush_swap_writer",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/swap.c",
          "lines": "494-500",
          "snippet": "static int flush_swap_writer(struct swap_map_handle *handle)\n{\n\tif (handle->cur && handle->cur_swap)\n\t\treturn write_page(handle->cur, handle->cur_swap, NULL);\n\telse\n\t\treturn -EINVAL;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/ktime.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/atomic.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/lzo.h>",
            "#include <linux/slab.h>",
            "#include <linux/pm.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/device.h>",
            "#include <linux/genhd.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/file.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/ktime.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/atomic.h>\n#include <linux/cpumask.h>\n#include <linux/vmalloc.h>\n#include <linux/lzo.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/device.h>\n#include <linux/genhd.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\nstatic int flush_swap_writer(struct swap_map_handle *handle)\n{\n\tif (handle->cur && handle->cur_swap)\n\t\treturn write_page(handle->cur, handle->cur_swap, NULL);\n\telse\n\t\treturn -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\"|\\n\""
          ],
          "line": 508
        },
        "resolved": true,
        "details": {
          "function_name": "pr_cont_pool_info",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "4715-4721",
          "snippet": "static void pr_cont_pool_info(struct worker_pool *pool)\n{\n\tpr_cont(\" cpus=%*pbl\", nr_cpumask_bits, pool->attrs->cpumask);\n\tif (pool->node != NUMA_NO_NODE)\n\t\tpr_cont(\" node=%d\", pool->node);\n\tpr_cont(\" flags=0x%x nice=%d\", pool->flags, pool->attrs->nice);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
            "static void show_one_worker_pool(struct worker_pool *pool);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nstatic void pr_cont_pool_info(struct worker_pool *pool)\n{\n\tpr_cont(\" cpus=%*pbl\", nr_cpumask_bits, pool->attrs->cpumask);\n\tif (pool->node != NUMA_NO_NODE)\n\t\tpr_cont(\" node=%d\", pool->node);\n\tpr_cont(\" flags=0x%x nice=%d\", pool->flags, pool->attrs->nice);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_swapfiles",
          "args": [
            "handle",
            "flags"
          ],
          "line": 507
        },
        "resolved": true,
        "details": {
          "function_name": "mark_swapfiles",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/swap.c",
          "lines": "318-343",
          "snippet": "static int mark_swapfiles(struct swap_map_handle *handle, unsigned int flags)\n{\n\tint error;\n\n\thib_submit_io(REQ_OP_READ, 0, swsusp_resume_block,\n\t\t      swsusp_header, NULL);\n\tif (!memcmp(\"SWAP-SPACE\",swsusp_header->sig, 10) ||\n\t    !memcmp(\"SWAPSPACE2\",swsusp_header->sig, 10)) {\n\t\tmemcpy(swsusp_header->orig_sig,swsusp_header->sig, 10);\n\t\tmemcpy(swsusp_header->sig, HIBERNATE_SIG, 10);\n\t\tswsusp_header->image = handle->first_sector;\n\t\tif (swsusp_hardware_signature) {\n\t\t\tswsusp_header->hw_sig = swsusp_hardware_signature;\n\t\t\tflags |= SF_HW_SIG;\n\t\t}\n\t\tswsusp_header->flags = flags;\n\t\tif (flags & SF_CRC32_MODE)\n\t\t\tswsusp_header->crc32 = handle->crc32;\n\t\terror = hib_submit_io(REQ_OP_WRITE, REQ_SYNC,\n\t\t\t\t      swsusp_resume_block, swsusp_header, NULL);\n\t} else {\n\t\tpr_err(\"Swap header not found!\\n\");\n\t\terror = -ENODEV;\n\t}\n\treturn error;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/ktime.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/atomic.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/lzo.h>",
            "#include <linux/slab.h>",
            "#include <linux/pm.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/device.h>",
            "#include <linux/genhd.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/file.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define HIBERNATE_SIG\t\"S1SUSPEND\""
          ],
          "globals_used": [
            "u32 swsusp_hardware_signature;",
            "static struct swsusp_header *swsusp_header;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/ktime.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/atomic.h>\n#include <linux/cpumask.h>\n#include <linux/vmalloc.h>\n#include <linux/lzo.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/device.h>\n#include <linux/genhd.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\n#define HIBERNATE_SIG\t\"S1SUSPEND\"\n\nu32 swsusp_hardware_signature;\nstatic struct swsusp_header *swsusp_header;\n\nstatic int mark_swapfiles(struct swap_map_handle *handle, unsigned int flags)\n{\n\tint error;\n\n\thib_submit_io(REQ_OP_READ, 0, swsusp_resume_block,\n\t\t      swsusp_header, NULL);\n\tif (!memcmp(\"SWAP-SPACE\",swsusp_header->sig, 10) ||\n\t    !memcmp(\"SWAPSPACE2\",swsusp_header->sig, 10)) {\n\t\tmemcpy(swsusp_header->orig_sig,swsusp_header->sig, 10);\n\t\tmemcpy(swsusp_header->sig, HIBERNATE_SIG, 10);\n\t\tswsusp_header->image = handle->first_sector;\n\t\tif (swsusp_hardware_signature) {\n\t\t\tswsusp_header->hw_sig = swsusp_hardware_signature;\n\t\t\tflags |= SF_HW_SIG;\n\t\t}\n\t\tswsusp_header->flags = flags;\n\t\tif (flags & SF_CRC32_MODE)\n\t\t\tswsusp_header->crc32 = handle->crc32;\n\t\terror = hib_submit_io(REQ_OP_WRITE, REQ_SYNC,\n\t\t\t\t      swsusp_resume_block, swsusp_header, NULL);\n\t} else {\n\t\tpr_err(\"Swap header not found!\\n\");\n\t\terror = -ENODEV;\n\t}\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"S\""
          ],
          "line": 506
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/ktime.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/atomic.h>\n#include <linux/cpumask.h>\n#include <linux/vmalloc.h>\n#include <linux/lzo.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/device.h>\n#include <linux/genhd.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\nstatic unsigned short root_swap = 0xffff;\n\nstatic int swap_writer_finish(struct swap_map_handle *handle,\n\t\tunsigned int flags, int error)\n{\n\tif (!error) {\n\t\tpr_info(\"S\");\n\t\terror = mark_swapfiles(handle, flags);\n\t\tpr_cont(\"|\\n\");\n\t\tflush_swap_writer(handle);\n\t}\n\n\tif (error)\n\t\tfree_all_swap_pages(root_swap);\n\trelease_swap_writer(handle);\n\tswsusp_close(FMODE_WRITE);\n\n\treturn error;\n}"
  },
  {
    "function_name": "flush_swap_writer",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/swap.c",
    "lines": "494-500",
    "snippet": "static int flush_swap_writer(struct swap_map_handle *handle)\n{\n\tif (handle->cur && handle->cur_swap)\n\t\treturn write_page(handle->cur, handle->cur_swap, NULL);\n\telse\n\t\treturn -EINVAL;\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/ktime.h>",
      "#include <linux/crc32.h>",
      "#include <linux/kthread.h>",
      "#include <linux/atomic.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/lzo.h>",
      "#include <linux/slab.h>",
      "#include <linux/pm.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include <linux/device.h>",
      "#include <linux/genhd.h>",
      "#include <linux/bitops.h>",
      "#include <linux/delay.h>",
      "#include <linux/file.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "write_page",
          "args": [
            "handle->cur",
            "handle->cur_swap",
            "NULL"
          ],
          "line": 497
        },
        "resolved": true,
        "details": {
          "function_name": "swap_write_page",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/swap.c",
          "lines": "454-492",
          "snippet": "static int swap_write_page(struct swap_map_handle *handle, void *buf,\n\t\tstruct hib_bio_batch *hb)\n{\n\tint error = 0;\n\tsector_t offset;\n\n\tif (!handle->cur)\n\t\treturn -EINVAL;\n\toffset = alloc_swapdev_block(root_swap);\n\terror = write_page(buf, offset, hb);\n\tif (error)\n\t\treturn error;\n\thandle->cur->entries[handle->k++] = offset;\n\tif (handle->k >= MAP_PAGE_ENTRIES) {\n\t\toffset = alloc_swapdev_block(root_swap);\n\t\tif (!offset)\n\t\t\treturn -ENOSPC;\n\t\thandle->cur->next_swap = offset;\n\t\terror = write_page(handle->cur, handle->cur_swap, hb);\n\t\tif (error)\n\t\t\tgoto out;\n\t\tclear_page(handle->cur);\n\t\thandle->cur_swap = offset;\n\t\thandle->k = 0;\n\n\t\tif (hb && low_free_pages() <= handle->reqd_free_pages) {\n\t\t\terror = hib_wait_io(hb);\n\t\t\tif (error)\n\t\t\t\tgoto out;\n\t\t\t/*\n\t\t\t * Recalculate the number of required free pages, to\n\t\t\t * make sure we never take more than half.\n\t\t\t */\n\t\t\thandle->reqd_free_pages = reqd_free_pages();\n\t\t}\n\t}\n out:\n\treturn error;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/ktime.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/atomic.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/lzo.h>",
            "#include <linux/slab.h>",
            "#include <linux/pm.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/device.h>",
            "#include <linux/genhd.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/file.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define MAP_PAGE_ENTRIES\t(PAGE_SIZE / sizeof(sector_t) - 1)"
          ],
          "globals_used": [
            "static unsigned short root_swap = 0xffff;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/ktime.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/atomic.h>\n#include <linux/cpumask.h>\n#include <linux/vmalloc.h>\n#include <linux/lzo.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/device.h>\n#include <linux/genhd.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\n#define MAP_PAGE_ENTRIES\t(PAGE_SIZE / sizeof(sector_t) - 1)\n\nstatic unsigned short root_swap = 0xffff;\n\nstatic int swap_write_page(struct swap_map_handle *handle, void *buf,\n\t\tstruct hib_bio_batch *hb)\n{\n\tint error = 0;\n\tsector_t offset;\n\n\tif (!handle->cur)\n\t\treturn -EINVAL;\n\toffset = alloc_swapdev_block(root_swap);\n\terror = write_page(buf, offset, hb);\n\tif (error)\n\t\treturn error;\n\thandle->cur->entries[handle->k++] = offset;\n\tif (handle->k >= MAP_PAGE_ENTRIES) {\n\t\toffset = alloc_swapdev_block(root_swap);\n\t\tif (!offset)\n\t\t\treturn -ENOSPC;\n\t\thandle->cur->next_swap = offset;\n\t\terror = write_page(handle->cur, handle->cur_swap, hb);\n\t\tif (error)\n\t\t\tgoto out;\n\t\tclear_page(handle->cur);\n\t\thandle->cur_swap = offset;\n\t\thandle->k = 0;\n\n\t\tif (hb && low_free_pages() <= handle->reqd_free_pages) {\n\t\t\terror = hib_wait_io(hb);\n\t\t\tif (error)\n\t\t\t\tgoto out;\n\t\t\t/*\n\t\t\t * Recalculate the number of required free pages, to\n\t\t\t * make sure we never take more than half.\n\t\t\t */\n\t\t\thandle->reqd_free_pages = reqd_free_pages();\n\t\t}\n\t}\n out:\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/ktime.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/atomic.h>\n#include <linux/cpumask.h>\n#include <linux/vmalloc.h>\n#include <linux/lzo.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/device.h>\n#include <linux/genhd.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\nstatic int flush_swap_writer(struct swap_map_handle *handle)\n{\n\tif (handle->cur && handle->cur_swap)\n\t\treturn write_page(handle->cur, handle->cur_swap, NULL);\n\telse\n\t\treturn -EINVAL;\n}"
  },
  {
    "function_name": "swap_write_page",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/swap.c",
    "lines": "454-492",
    "snippet": "static int swap_write_page(struct swap_map_handle *handle, void *buf,\n\t\tstruct hib_bio_batch *hb)\n{\n\tint error = 0;\n\tsector_t offset;\n\n\tif (!handle->cur)\n\t\treturn -EINVAL;\n\toffset = alloc_swapdev_block(root_swap);\n\terror = write_page(buf, offset, hb);\n\tif (error)\n\t\treturn error;\n\thandle->cur->entries[handle->k++] = offset;\n\tif (handle->k >= MAP_PAGE_ENTRIES) {\n\t\toffset = alloc_swapdev_block(root_swap);\n\t\tif (!offset)\n\t\t\treturn -ENOSPC;\n\t\thandle->cur->next_swap = offset;\n\t\terror = write_page(handle->cur, handle->cur_swap, hb);\n\t\tif (error)\n\t\t\tgoto out;\n\t\tclear_page(handle->cur);\n\t\thandle->cur_swap = offset;\n\t\thandle->k = 0;\n\n\t\tif (hb && low_free_pages() <= handle->reqd_free_pages) {\n\t\t\terror = hib_wait_io(hb);\n\t\t\tif (error)\n\t\t\t\tgoto out;\n\t\t\t/*\n\t\t\t * Recalculate the number of required free pages, to\n\t\t\t * make sure we never take more than half.\n\t\t\t */\n\t\t\thandle->reqd_free_pages = reqd_free_pages();\n\t\t}\n\t}\n out:\n\treturn error;\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/ktime.h>",
      "#include <linux/crc32.h>",
      "#include <linux/kthread.h>",
      "#include <linux/atomic.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/lzo.h>",
      "#include <linux/slab.h>",
      "#include <linux/pm.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include <linux/device.h>",
      "#include <linux/genhd.h>",
      "#include <linux/bitops.h>",
      "#include <linux/delay.h>",
      "#include <linux/file.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define MAP_PAGE_ENTRIES\t(PAGE_SIZE / sizeof(sector_t) - 1)"
    ],
    "globals_used": [
      "static unsigned short root_swap = 0xffff;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "reqd_free_pages",
          "args": [],
          "line": 487
        },
        "resolved": true,
        "details": {
          "function_name": "reqd_free_pages",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/swap.c",
          "lines": "77-80",
          "snippet": "static inline unsigned long reqd_free_pages(void)\n{\n\treturn low_free_pages() / 2;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/ktime.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/atomic.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/lzo.h>",
            "#include <linux/slab.h>",
            "#include <linux/pm.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/device.h>",
            "#include <linux/genhd.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/file.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/ktime.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/atomic.h>\n#include <linux/cpumask.h>\n#include <linux/vmalloc.h>\n#include <linux/lzo.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/device.h>\n#include <linux/genhd.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\nstatic inline unsigned long reqd_free_pages(void)\n{\n\treturn low_free_pages() / 2;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hib_wait_io",
          "args": [
            "hb"
          ],
          "line": 480
        },
        "resolved": true,
        "details": {
          "function_name": "hib_wait_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/swap.c",
          "lines": "305-313",
          "snippet": "static int hib_wait_io(struct hib_bio_batch *hb)\n{\n\t/*\n\t * We are relying on the behavior of blk_plug that a thread with\n\t * a plug will flush the plug list before sleeping.\n\t */\n\twait_event(hb->wait, atomic_read(&hb->count) == 0);\n\treturn blk_status_to_errno(hb->error);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/ktime.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/atomic.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/lzo.h>",
            "#include <linux/slab.h>",
            "#include <linux/pm.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/device.h>",
            "#include <linux/genhd.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/file.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/ktime.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/atomic.h>\n#include <linux/cpumask.h>\n#include <linux/vmalloc.h>\n#include <linux/lzo.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/device.h>\n#include <linux/genhd.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\nstatic int hib_wait_io(struct hib_bio_batch *hb)\n{\n\t/*\n\t * We are relying on the behavior of blk_plug that a thread with\n\t * a plug will flush the plug list before sleeping.\n\t */\n\twait_event(hb->wait, atomic_read(&hb->count) == 0);\n\treturn blk_status_to_errno(hb->error);\n}"
        }
      },
      {
        "call_info": {
          "callee": "low_free_pages",
          "args": [],
          "line": 479
        },
        "resolved": true,
        "details": {
          "function_name": "low_free_pages",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/swap.c",
          "lines": "68-71",
          "snippet": "static inline unsigned long low_free_pages(void)\n{\n\treturn nr_free_pages() - nr_free_highpages();\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/ktime.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/atomic.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/lzo.h>",
            "#include <linux/slab.h>",
            "#include <linux/pm.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/device.h>",
            "#include <linux/genhd.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/file.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/ktime.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/atomic.h>\n#include <linux/cpumask.h>\n#include <linux/vmalloc.h>\n#include <linux/lzo.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/device.h>\n#include <linux/genhd.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\nstatic inline unsigned long low_free_pages(void)\n{\n\treturn nr_free_pages() - nr_free_highpages();\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_page",
          "args": [
            "handle->cur"
          ],
          "line": 475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_page",
          "args": [
            "handle->cur",
            "handle->cur_swap",
            "hb"
          ],
          "line": 472
        },
        "resolved": true,
        "details": {
          "function_name": "swap_write_page",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/swap.c",
          "lines": "454-492",
          "snippet": "static int swap_write_page(struct swap_map_handle *handle, void *buf,\n\t\tstruct hib_bio_batch *hb)\n{\n\tint error = 0;\n\tsector_t offset;\n\n\tif (!handle->cur)\n\t\treturn -EINVAL;\n\toffset = alloc_swapdev_block(root_swap);\n\terror = write_page(buf, offset, hb);\n\tif (error)\n\t\treturn error;\n\thandle->cur->entries[handle->k++] = offset;\n\tif (handle->k >= MAP_PAGE_ENTRIES) {\n\t\toffset = alloc_swapdev_block(root_swap);\n\t\tif (!offset)\n\t\t\treturn -ENOSPC;\n\t\thandle->cur->next_swap = offset;\n\t\terror = write_page(handle->cur, handle->cur_swap, hb);\n\t\tif (error)\n\t\t\tgoto out;\n\t\tclear_page(handle->cur);\n\t\thandle->cur_swap = offset;\n\t\thandle->k = 0;\n\n\t\tif (hb && low_free_pages() <= handle->reqd_free_pages) {\n\t\t\terror = hib_wait_io(hb);\n\t\t\tif (error)\n\t\t\t\tgoto out;\n\t\t\t/*\n\t\t\t * Recalculate the number of required free pages, to\n\t\t\t * make sure we never take more than half.\n\t\t\t */\n\t\t\thandle->reqd_free_pages = reqd_free_pages();\n\t\t}\n\t}\n out:\n\treturn error;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "alloc_swapdev_block",
          "args": [
            "root_swap"
          ],
          "line": 468
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_swapdev_block",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/swap.c",
          "lines": "179-191",
          "snippet": "sector_t alloc_swapdev_block(int swap)\n{\n\tunsigned long offset;\n\n\toffset = swp_offset(get_swap_page_of_type(swap));\n\tif (offset) {\n\t\tif (swsusp_extents_insert(offset))\n\t\t\tswap_free(swp_entry(swap, offset));\n\t\telse\n\t\t\treturn swapdev_block(swap, offset);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/ktime.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/atomic.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/lzo.h>",
            "#include <linux/slab.h>",
            "#include <linux/pm.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/device.h>",
            "#include <linux/genhd.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/file.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/ktime.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/atomic.h>\n#include <linux/cpumask.h>\n#include <linux/vmalloc.h>\n#include <linux/lzo.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/device.h>\n#include <linux/genhd.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\nsector_t alloc_swapdev_block(int swap)\n{\n\tunsigned long offset;\n\n\toffset = swp_offset(get_swap_page_of_type(swap));\n\tif (offset) {\n\t\tif (swsusp_extents_insert(offset))\n\t\t\tswap_free(swp_entry(swap, offset));\n\t\telse\n\t\t\treturn swapdev_block(swap, offset);\n\t}\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/ktime.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/atomic.h>\n#include <linux/cpumask.h>\n#include <linux/vmalloc.h>\n#include <linux/lzo.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/device.h>\n#include <linux/genhd.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\n#define MAP_PAGE_ENTRIES\t(PAGE_SIZE / sizeof(sector_t) - 1)\n\nstatic unsigned short root_swap = 0xffff;\n\nstatic int swap_write_page(struct swap_map_handle *handle, void *buf,\n\t\tstruct hib_bio_batch *hb)\n{\n\tint error = 0;\n\tsector_t offset;\n\n\tif (!handle->cur)\n\t\treturn -EINVAL;\n\toffset = alloc_swapdev_block(root_swap);\n\terror = write_page(buf, offset, hb);\n\tif (error)\n\t\treturn error;\n\thandle->cur->entries[handle->k++] = offset;\n\tif (handle->k >= MAP_PAGE_ENTRIES) {\n\t\toffset = alloc_swapdev_block(root_swap);\n\t\tif (!offset)\n\t\t\treturn -ENOSPC;\n\t\thandle->cur->next_swap = offset;\n\t\terror = write_page(handle->cur, handle->cur_swap, hb);\n\t\tif (error)\n\t\t\tgoto out;\n\t\tclear_page(handle->cur);\n\t\thandle->cur_swap = offset;\n\t\thandle->k = 0;\n\n\t\tif (hb && low_free_pages() <= handle->reqd_free_pages) {\n\t\t\terror = hib_wait_io(hb);\n\t\t\tif (error)\n\t\t\t\tgoto out;\n\t\t\t/*\n\t\t\t * Recalculate the number of required free pages, to\n\t\t\t * make sure we never take more than half.\n\t\t\t */\n\t\t\thandle->reqd_free_pages = reqd_free_pages();\n\t\t}\n\t}\n out:\n\treturn error;\n}"
  },
  {
    "function_name": "get_swap_writer",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/swap.c",
    "lines": "423-452",
    "snippet": "static int get_swap_writer(struct swap_map_handle *handle)\n{\n\tint ret;\n\n\tret = swsusp_swap_check();\n\tif (ret) {\n\t\tif (ret != -ENOSPC)\n\t\t\tpr_err(\"Cannot find swap device, try swapon -a\\n\");\n\t\treturn ret;\n\t}\n\thandle->cur = (struct swap_map_page *)get_zeroed_page(GFP_KERNEL);\n\tif (!handle->cur) {\n\t\tret = -ENOMEM;\n\t\tgoto err_close;\n\t}\n\thandle->cur_swap = alloc_swapdev_block(root_swap);\n\tif (!handle->cur_swap) {\n\t\tret = -ENOSPC;\n\t\tgoto err_rel;\n\t}\n\thandle->k = 0;\n\thandle->reqd_free_pages = reqd_free_pages();\n\thandle->first_sector = handle->cur_swap;\n\treturn 0;\nerr_rel:\n\trelease_swap_writer(handle);\nerr_close:\n\tswsusp_close(FMODE_WRITE);\n\treturn ret;\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/ktime.h>",
      "#include <linux/crc32.h>",
      "#include <linux/kthread.h>",
      "#include <linux/atomic.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/lzo.h>",
      "#include <linux/slab.h>",
      "#include <linux/pm.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include <linux/device.h>",
      "#include <linux/genhd.h>",
      "#include <linux/bitops.h>",
      "#include <linux/delay.h>",
      "#include <linux/file.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned short root_swap = 0xffff;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "swsusp_close",
          "args": [
            "FMODE_WRITE"
          ],
          "line": 450
        },
        "resolved": true,
        "details": {
          "function_name": "swsusp_close",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/swap.c",
          "lines": "1572-1580",
          "snippet": "void swsusp_close(fmode_t mode)\n{\n\tif (IS_ERR(hib_resume_bdev)) {\n\t\tpr_debug(\"Image device not initialised\\n\");\n\t\treturn;\n\t}\n\n\tblkdev_put(hib_resume_bdev, mode);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/ktime.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/atomic.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/lzo.h>",
            "#include <linux/slab.h>",
            "#include <linux/pm.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/device.h>",
            "#include <linux/genhd.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/file.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct block_device *hib_resume_bdev;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/ktime.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/atomic.h>\n#include <linux/cpumask.h>\n#include <linux/vmalloc.h>\n#include <linux/lzo.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/device.h>\n#include <linux/genhd.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\nstatic struct block_device *hib_resume_bdev;\n\nvoid swsusp_close(fmode_t mode)\n{\n\tif (IS_ERR(hib_resume_bdev)) {\n\t\tpr_debug(\"Image device not initialised\\n\");\n\t\treturn;\n\t}\n\n\tblkdev_put(hib_resume_bdev, mode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "release_swap_writer",
          "args": [
            "handle"
          ],
          "line": 448
        },
        "resolved": true,
        "details": {
          "function_name": "release_swap_writer",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/swap.c",
          "lines": "416-421",
          "snippet": "static void release_swap_writer(struct swap_map_handle *handle)\n{\n\tif (handle->cur)\n\t\tfree_page((unsigned long)handle->cur);\n\thandle->cur = NULL;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/ktime.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/atomic.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/lzo.h>",
            "#include <linux/slab.h>",
            "#include <linux/pm.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/device.h>",
            "#include <linux/genhd.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/file.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/ktime.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/atomic.h>\n#include <linux/cpumask.h>\n#include <linux/vmalloc.h>\n#include <linux/lzo.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/device.h>\n#include <linux/genhd.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\nstatic void release_swap_writer(struct swap_map_handle *handle)\n{\n\tif (handle->cur)\n\t\tfree_page((unsigned long)handle->cur);\n\thandle->cur = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reqd_free_pages",
          "args": [],
          "line": 444
        },
        "resolved": true,
        "details": {
          "function_name": "reqd_free_pages",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/swap.c",
          "lines": "77-80",
          "snippet": "static inline unsigned long reqd_free_pages(void)\n{\n\treturn low_free_pages() / 2;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/ktime.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/atomic.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/lzo.h>",
            "#include <linux/slab.h>",
            "#include <linux/pm.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/device.h>",
            "#include <linux/genhd.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/file.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/ktime.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/atomic.h>\n#include <linux/cpumask.h>\n#include <linux/vmalloc.h>\n#include <linux/lzo.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/device.h>\n#include <linux/genhd.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\nstatic inline unsigned long reqd_free_pages(void)\n{\n\treturn low_free_pages() / 2;\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_swapdev_block",
          "args": [
            "root_swap"
          ],
          "line": 438
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_swapdev_block",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/swap.c",
          "lines": "179-191",
          "snippet": "sector_t alloc_swapdev_block(int swap)\n{\n\tunsigned long offset;\n\n\toffset = swp_offset(get_swap_page_of_type(swap));\n\tif (offset) {\n\t\tif (swsusp_extents_insert(offset))\n\t\t\tswap_free(swp_entry(swap, offset));\n\t\telse\n\t\t\treturn swapdev_block(swap, offset);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/ktime.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/atomic.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/lzo.h>",
            "#include <linux/slab.h>",
            "#include <linux/pm.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/device.h>",
            "#include <linux/genhd.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/file.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/ktime.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/atomic.h>\n#include <linux/cpumask.h>\n#include <linux/vmalloc.h>\n#include <linux/lzo.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/device.h>\n#include <linux/genhd.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\nsector_t alloc_swapdev_block(int swap)\n{\n\tunsigned long offset;\n\n\toffset = swp_offset(get_swap_page_of_type(swap));\n\tif (offset) {\n\t\tif (swsusp_extents_insert(offset))\n\t\t\tswap_free(swp_entry(swap, offset));\n\t\telse\n\t\t\treturn swapdev_block(swap, offset);\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_zeroed_page",
          "args": [
            "GFP_KERNEL"
          ],
          "line": 433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Cannot find swap device, try swapon -a\\n\""
          ],
          "line": 430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swsusp_swap_check",
          "args": [],
          "line": 427
        },
        "resolved": true,
        "details": {
          "function_name": "swsusp_swap_check",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/swap.c",
          "lines": "351-373",
          "snippet": "static int swsusp_swap_check(void)\n{\n\tint res;\n\n\tif (swsusp_resume_device)\n\t\tres = swap_type_of(swsusp_resume_device, swsusp_resume_block);\n\telse\n\t\tres = find_first_swap(&swsusp_resume_device);\n\tif (res < 0)\n\t\treturn res;\n\troot_swap = res;\n\n\thib_resume_bdev = blkdev_get_by_dev(swsusp_resume_device, FMODE_WRITE,\n\t\t\tNULL);\n\tif (IS_ERR(hib_resume_bdev))\n\t\treturn PTR_ERR(hib_resume_bdev);\n\n\tres = set_blocksize(hib_resume_bdev, PAGE_SIZE);\n\tif (res < 0)\n\t\tblkdev_put(hib_resume_bdev, FMODE_WRITE);\n\n\treturn res;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/ktime.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/atomic.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/lzo.h>",
            "#include <linux/slab.h>",
            "#include <linux/pm.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/device.h>",
            "#include <linux/genhd.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/file.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned short root_swap = 0xffff;",
            "static struct block_device *hib_resume_bdev;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/ktime.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/atomic.h>\n#include <linux/cpumask.h>\n#include <linux/vmalloc.h>\n#include <linux/lzo.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/device.h>\n#include <linux/genhd.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\nstatic unsigned short root_swap = 0xffff;\nstatic struct block_device *hib_resume_bdev;\n\nstatic int swsusp_swap_check(void)\n{\n\tint res;\n\n\tif (swsusp_resume_device)\n\t\tres = swap_type_of(swsusp_resume_device, swsusp_resume_block);\n\telse\n\t\tres = find_first_swap(&swsusp_resume_device);\n\tif (res < 0)\n\t\treturn res;\n\troot_swap = res;\n\n\thib_resume_bdev = blkdev_get_by_dev(swsusp_resume_device, FMODE_WRITE,\n\t\t\tNULL);\n\tif (IS_ERR(hib_resume_bdev))\n\t\treturn PTR_ERR(hib_resume_bdev);\n\n\tres = set_blocksize(hib_resume_bdev, PAGE_SIZE);\n\tif (res < 0)\n\t\tblkdev_put(hib_resume_bdev, FMODE_WRITE);\n\n\treturn res;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/ktime.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/atomic.h>\n#include <linux/cpumask.h>\n#include <linux/vmalloc.h>\n#include <linux/lzo.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/device.h>\n#include <linux/genhd.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\nstatic unsigned short root_swap = 0xffff;\n\nstatic int get_swap_writer(struct swap_map_handle *handle)\n{\n\tint ret;\n\n\tret = swsusp_swap_check();\n\tif (ret) {\n\t\tif (ret != -ENOSPC)\n\t\t\tpr_err(\"Cannot find swap device, try swapon -a\\n\");\n\t\treturn ret;\n\t}\n\thandle->cur = (struct swap_map_page *)get_zeroed_page(GFP_KERNEL);\n\tif (!handle->cur) {\n\t\tret = -ENOMEM;\n\t\tgoto err_close;\n\t}\n\thandle->cur_swap = alloc_swapdev_block(root_swap);\n\tif (!handle->cur_swap) {\n\t\tret = -ENOSPC;\n\t\tgoto err_rel;\n\t}\n\thandle->k = 0;\n\thandle->reqd_free_pages = reqd_free_pages();\n\thandle->first_sector = handle->cur_swap;\n\treturn 0;\nerr_rel:\n\trelease_swap_writer(handle);\nerr_close:\n\tswsusp_close(FMODE_WRITE);\n\treturn ret;\n}"
  },
  {
    "function_name": "release_swap_writer",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/swap.c",
    "lines": "416-421",
    "snippet": "static void release_swap_writer(struct swap_map_handle *handle)\n{\n\tif (handle->cur)\n\t\tfree_page((unsigned long)handle->cur);\n\thandle->cur = NULL;\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/ktime.h>",
      "#include <linux/crc32.h>",
      "#include <linux/kthread.h>",
      "#include <linux/atomic.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/lzo.h>",
      "#include <linux/slab.h>",
      "#include <linux/pm.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include <linux/device.h>",
      "#include <linux/genhd.h>",
      "#include <linux/bitops.h>",
      "#include <linux/delay.h>",
      "#include <linux/file.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_page",
          "args": [
            "(unsigned long)handle->cur"
          ],
          "line": 419
        },
        "resolved": true,
        "details": {
          "function_name": "clear_or_poison_free_page",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/snapshot.c",
          "lines": "1181-1187",
          "snippet": "static void clear_or_poison_free_page(struct page *page)\n{\n\tif (page_poisoning_enabled_static())\n\t\t__kernel_poison_pages(page, 1);\n\telse if (want_init_on_free())\n\t\tclear_highpage(page);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int swsusp_page_is_free(struct page *);",
            "static void swsusp_set_page_forbidden(struct page *);",
            "static void swsusp_unset_page_forbidden(struct page *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\nstatic int swsusp_page_is_free(struct page *);\nstatic void swsusp_set_page_forbidden(struct page *);\nstatic void swsusp_unset_page_forbidden(struct page *);\n\nstatic void clear_or_poison_free_page(struct page *page)\n{\n\tif (page_poisoning_enabled_static())\n\t\t__kernel_poison_pages(page, 1);\n\telse if (want_init_on_free())\n\t\tclear_highpage(page);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/ktime.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/atomic.h>\n#include <linux/cpumask.h>\n#include <linux/vmalloc.h>\n#include <linux/lzo.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/device.h>\n#include <linux/genhd.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\nstatic void release_swap_writer(struct swap_map_handle *handle)\n{\n\tif (handle->cur)\n\t\tfree_page((unsigned long)handle->cur);\n\thandle->cur = NULL;\n}"
  },
  {
    "function_name": "write_page",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/swap.c",
    "lines": "382-414",
    "snippet": "static int write_page(void *buf, sector_t offset, struct hib_bio_batch *hb)\n{\n\tvoid *src;\n\tint ret;\n\n\tif (!offset)\n\t\treturn -ENOSPC;\n\n\tif (hb) {\n\t\tsrc = (void *)__get_free_page(GFP_NOIO | __GFP_NOWARN |\n\t\t                              __GFP_NORETRY);\n\t\tif (src) {\n\t\t\tcopy_page(src, buf);\n\t\t} else {\n\t\t\tret = hib_wait_io(hb); /* Free pages */\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t\tsrc = (void *)__get_free_page(GFP_NOIO |\n\t\t\t                              __GFP_NOWARN |\n\t\t\t                              __GFP_NORETRY);\n\t\t\tif (src) {\n\t\t\t\tcopy_page(src, buf);\n\t\t\t} else {\n\t\t\t\tWARN_ON_ONCE(1);\n\t\t\t\thb = NULL;\t/* Go synchronous */\n\t\t\t\tsrc = buf;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tsrc = buf;\n\t}\n\treturn hib_submit_io(REQ_OP_WRITE, REQ_SYNC, offset, src, hb);\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/ktime.h>",
      "#include <linux/crc32.h>",
      "#include <linux/kthread.h>",
      "#include <linux/atomic.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/lzo.h>",
      "#include <linux/slab.h>",
      "#include <linux/pm.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include <linux/device.h>",
      "#include <linux/genhd.h>",
      "#include <linux/bitops.h>",
      "#include <linux/delay.h>",
      "#include <linux/file.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hib_submit_io",
          "args": [
            "REQ_OP_WRITE",
            "REQ_SYNC",
            "offset",
            "src",
            "hb"
          ],
          "line": 413
        },
        "resolved": true,
        "details": {
          "function_name": "hib_submit_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/swap.c",
          "lines": "273-303",
          "snippet": "static int hib_submit_io(int op, int op_flags, pgoff_t page_off, void *addr,\n\t\tstruct hib_bio_batch *hb)\n{\n\tstruct page *page = virt_to_page(addr);\n\tstruct bio *bio;\n\tint error = 0;\n\n\tbio = bio_alloc(GFP_NOIO | __GFP_HIGH, 1);\n\tbio->bi_iter.bi_sector = page_off * (PAGE_SIZE >> 9);\n\tbio_set_dev(bio, hib_resume_bdev);\n\tbio_set_op_attrs(bio, op, op_flags);\n\n\tif (bio_add_page(bio, page, PAGE_SIZE, 0) < PAGE_SIZE) {\n\t\tpr_err(\"Adding page to bio failed at %llu\\n\",\n\t\t       (unsigned long long)bio->bi_iter.bi_sector);\n\t\tbio_put(bio);\n\t\treturn -EFAULT;\n\t}\n\n\tif (hb) {\n\t\tbio->bi_end_io = hib_end_io;\n\t\tbio->bi_private = hb;\n\t\tatomic_inc(&hb->count);\n\t\tsubmit_bio(bio);\n\t} else {\n\t\terror = submit_bio_wait(bio);\n\t\tbio_put(bio);\n\t}\n\n\treturn error;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/ktime.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/atomic.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/lzo.h>",
            "#include <linux/slab.h>",
            "#include <linux/pm.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/device.h>",
            "#include <linux/genhd.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/file.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct block_device *hib_resume_bdev;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/ktime.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/atomic.h>\n#include <linux/cpumask.h>\n#include <linux/vmalloc.h>\n#include <linux/lzo.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/device.h>\n#include <linux/genhd.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\nstatic struct block_device *hib_resume_bdev;\n\nstatic int hib_submit_io(int op, int op_flags, pgoff_t page_off, void *addr,\n\t\tstruct hib_bio_batch *hb)\n{\n\tstruct page *page = virt_to_page(addr);\n\tstruct bio *bio;\n\tint error = 0;\n\n\tbio = bio_alloc(GFP_NOIO | __GFP_HIGH, 1);\n\tbio->bi_iter.bi_sector = page_off * (PAGE_SIZE >> 9);\n\tbio_set_dev(bio, hib_resume_bdev);\n\tbio_set_op_attrs(bio, op, op_flags);\n\n\tif (bio_add_page(bio, page, PAGE_SIZE, 0) < PAGE_SIZE) {\n\t\tpr_err(\"Adding page to bio failed at %llu\\n\",\n\t\t       (unsigned long long)bio->bi_iter.bi_sector);\n\t\tbio_put(bio);\n\t\treturn -EFAULT;\n\t}\n\n\tif (hb) {\n\t\tbio->bi_end_io = hib_end_io;\n\t\tbio->bi_private = hb;\n\t\tatomic_inc(&hb->count);\n\t\tsubmit_bio(bio);\n\t} else {\n\t\terror = submit_bio_wait(bio);\n\t\tbio_put(bio);\n\t}\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "1"
          ],
          "line": 405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_page",
          "args": [
            "src",
            "buf"
          ],
          "line": 403
        },
        "resolved": true,
        "details": {
          "function_name": "safe_copy_page",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/snapshot.c",
          "lines": "1395-1404",
          "snippet": "static void safe_copy_page(void *dst, struct page *s_page)\n{\n\tif (kernel_page_present(s_page)) {\n\t\tdo_copy_page(dst, page_address(s_page));\n\t} else {\n\t\thibernate_map_page(s_page);\n\t\tdo_copy_page(dst, page_address(s_page));\n\t\thibernate_unmap_page(s_page);\n\t}\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int swsusp_page_is_free(struct page *);",
            "static void swsusp_set_page_forbidden(struct page *);",
            "static void swsusp_unset_page_forbidden(struct page *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\nstatic int swsusp_page_is_free(struct page *);\nstatic void swsusp_set_page_forbidden(struct page *);\nstatic void swsusp_unset_page_forbidden(struct page *);\n\nstatic void safe_copy_page(void *dst, struct page *s_page)\n{\n\tif (kernel_page_present(s_page)) {\n\t\tdo_copy_page(dst, page_address(s_page));\n\t} else {\n\t\thibernate_map_page(s_page);\n\t\tdo_copy_page(dst, page_address(s_page));\n\t\thibernate_unmap_page(s_page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "__get_free_page",
          "args": [
            "GFP_NOIO |\n\t\t\t                              __GFP_NOWARN |\n\t\t\t                              __GFP_NORETRY"
          ],
          "line": 399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hib_wait_io",
          "args": [
            "hb"
          ],
          "line": 396
        },
        "resolved": true,
        "details": {
          "function_name": "hib_wait_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/swap.c",
          "lines": "305-313",
          "snippet": "static int hib_wait_io(struct hib_bio_batch *hb)\n{\n\t/*\n\t * We are relying on the behavior of blk_plug that a thread with\n\t * a plug will flush the plug list before sleeping.\n\t */\n\twait_event(hb->wait, atomic_read(&hb->count) == 0);\n\treturn blk_status_to_errno(hb->error);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/ktime.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/atomic.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/lzo.h>",
            "#include <linux/slab.h>",
            "#include <linux/pm.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/device.h>",
            "#include <linux/genhd.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/file.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/ktime.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/atomic.h>\n#include <linux/cpumask.h>\n#include <linux/vmalloc.h>\n#include <linux/lzo.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/device.h>\n#include <linux/genhd.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\nstatic int hib_wait_io(struct hib_bio_batch *hb)\n{\n\t/*\n\t * We are relying on the behavior of blk_plug that a thread with\n\t * a plug will flush the plug list before sleeping.\n\t */\n\twait_event(hb->wait, atomic_read(&hb->count) == 0);\n\treturn blk_status_to_errno(hb->error);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__get_free_page",
          "args": [
            "GFP_NOIO | __GFP_NOWARN |\n\t\t                              __GFP_NORETRY"
          ],
          "line": 391
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/ktime.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/atomic.h>\n#include <linux/cpumask.h>\n#include <linux/vmalloc.h>\n#include <linux/lzo.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/device.h>\n#include <linux/genhd.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\nstatic int write_page(void *buf, sector_t offset, struct hib_bio_batch *hb)\n{\n\tvoid *src;\n\tint ret;\n\n\tif (!offset)\n\t\treturn -ENOSPC;\n\n\tif (hb) {\n\t\tsrc = (void *)__get_free_page(GFP_NOIO | __GFP_NOWARN |\n\t\t                              __GFP_NORETRY);\n\t\tif (src) {\n\t\t\tcopy_page(src, buf);\n\t\t} else {\n\t\t\tret = hib_wait_io(hb); /* Free pages */\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t\tsrc = (void *)__get_free_page(GFP_NOIO |\n\t\t\t                              __GFP_NOWARN |\n\t\t\t                              __GFP_NORETRY);\n\t\t\tif (src) {\n\t\t\t\tcopy_page(src, buf);\n\t\t\t} else {\n\t\t\t\tWARN_ON_ONCE(1);\n\t\t\t\thb = NULL;\t/* Go synchronous */\n\t\t\t\tsrc = buf;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tsrc = buf;\n\t}\n\treturn hib_submit_io(REQ_OP_WRITE, REQ_SYNC, offset, src, hb);\n}"
  },
  {
    "function_name": "swsusp_swap_check",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/swap.c",
    "lines": "351-373",
    "snippet": "static int swsusp_swap_check(void)\n{\n\tint res;\n\n\tif (swsusp_resume_device)\n\t\tres = swap_type_of(swsusp_resume_device, swsusp_resume_block);\n\telse\n\t\tres = find_first_swap(&swsusp_resume_device);\n\tif (res < 0)\n\t\treturn res;\n\troot_swap = res;\n\n\thib_resume_bdev = blkdev_get_by_dev(swsusp_resume_device, FMODE_WRITE,\n\t\t\tNULL);\n\tif (IS_ERR(hib_resume_bdev))\n\t\treturn PTR_ERR(hib_resume_bdev);\n\n\tres = set_blocksize(hib_resume_bdev, PAGE_SIZE);\n\tif (res < 0)\n\t\tblkdev_put(hib_resume_bdev, FMODE_WRITE);\n\n\treturn res;\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/ktime.h>",
      "#include <linux/crc32.h>",
      "#include <linux/kthread.h>",
      "#include <linux/atomic.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/lzo.h>",
      "#include <linux/slab.h>",
      "#include <linux/pm.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include <linux/device.h>",
      "#include <linux/genhd.h>",
      "#include <linux/bitops.h>",
      "#include <linux/delay.h>",
      "#include <linux/file.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned short root_swap = 0xffff;",
      "static struct block_device *hib_resume_bdev;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "blkdev_put",
          "args": [
            "hib_resume_bdev",
            "FMODE_WRITE"
          ],
          "line": 370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_blocksize",
          "args": [
            "hib_resume_bdev",
            "PAGE_SIZE"
          ],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "hib_resume_bdev"
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "hib_resume_bdev"
          ],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blkdev_get_by_dev",
          "args": [
            "swsusp_resume_device",
            "FMODE_WRITE",
            "NULL"
          ],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_first_swap",
          "args": [
            "&swsusp_resume_device"
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swap_type_of",
          "args": [
            "swsusp_resume_device",
            "swsusp_resume_block"
          ],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/ktime.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/atomic.h>\n#include <linux/cpumask.h>\n#include <linux/vmalloc.h>\n#include <linux/lzo.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/device.h>\n#include <linux/genhd.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\nstatic unsigned short root_swap = 0xffff;\nstatic struct block_device *hib_resume_bdev;\n\nstatic int swsusp_swap_check(void)\n{\n\tint res;\n\n\tif (swsusp_resume_device)\n\t\tres = swap_type_of(swsusp_resume_device, swsusp_resume_block);\n\telse\n\t\tres = find_first_swap(&swsusp_resume_device);\n\tif (res < 0)\n\t\treturn res;\n\troot_swap = res;\n\n\thib_resume_bdev = blkdev_get_by_dev(swsusp_resume_device, FMODE_WRITE,\n\t\t\tNULL);\n\tif (IS_ERR(hib_resume_bdev))\n\t\treturn PTR_ERR(hib_resume_bdev);\n\n\tres = set_blocksize(hib_resume_bdev, PAGE_SIZE);\n\tif (res < 0)\n\t\tblkdev_put(hib_resume_bdev, FMODE_WRITE);\n\n\treturn res;\n}"
  },
  {
    "function_name": "mark_swapfiles",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/swap.c",
    "lines": "318-343",
    "snippet": "static int mark_swapfiles(struct swap_map_handle *handle, unsigned int flags)\n{\n\tint error;\n\n\thib_submit_io(REQ_OP_READ, 0, swsusp_resume_block,\n\t\t      swsusp_header, NULL);\n\tif (!memcmp(\"SWAP-SPACE\",swsusp_header->sig, 10) ||\n\t    !memcmp(\"SWAPSPACE2\",swsusp_header->sig, 10)) {\n\t\tmemcpy(swsusp_header->orig_sig,swsusp_header->sig, 10);\n\t\tmemcpy(swsusp_header->sig, HIBERNATE_SIG, 10);\n\t\tswsusp_header->image = handle->first_sector;\n\t\tif (swsusp_hardware_signature) {\n\t\t\tswsusp_header->hw_sig = swsusp_hardware_signature;\n\t\t\tflags |= SF_HW_SIG;\n\t\t}\n\t\tswsusp_header->flags = flags;\n\t\tif (flags & SF_CRC32_MODE)\n\t\t\tswsusp_header->crc32 = handle->crc32;\n\t\terror = hib_submit_io(REQ_OP_WRITE, REQ_SYNC,\n\t\t\t\t      swsusp_resume_block, swsusp_header, NULL);\n\t} else {\n\t\tpr_err(\"Swap header not found!\\n\");\n\t\terror = -ENODEV;\n\t}\n\treturn error;\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/ktime.h>",
      "#include <linux/crc32.h>",
      "#include <linux/kthread.h>",
      "#include <linux/atomic.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/lzo.h>",
      "#include <linux/slab.h>",
      "#include <linux/pm.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include <linux/device.h>",
      "#include <linux/genhd.h>",
      "#include <linux/bitops.h>",
      "#include <linux/delay.h>",
      "#include <linux/file.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define HIBERNATE_SIG\t\"S1SUSPEND\""
    ],
    "globals_used": [
      "u32 swsusp_hardware_signature;",
      "static struct swsusp_header *swsusp_header;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Swap header not found!\\n\""
          ],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hib_submit_io",
          "args": [
            "REQ_OP_WRITE",
            "REQ_SYNC",
            "swsusp_resume_block",
            "swsusp_header",
            "NULL"
          ],
          "line": 336
        },
        "resolved": true,
        "details": {
          "function_name": "hib_submit_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/swap.c",
          "lines": "273-303",
          "snippet": "static int hib_submit_io(int op, int op_flags, pgoff_t page_off, void *addr,\n\t\tstruct hib_bio_batch *hb)\n{\n\tstruct page *page = virt_to_page(addr);\n\tstruct bio *bio;\n\tint error = 0;\n\n\tbio = bio_alloc(GFP_NOIO | __GFP_HIGH, 1);\n\tbio->bi_iter.bi_sector = page_off * (PAGE_SIZE >> 9);\n\tbio_set_dev(bio, hib_resume_bdev);\n\tbio_set_op_attrs(bio, op, op_flags);\n\n\tif (bio_add_page(bio, page, PAGE_SIZE, 0) < PAGE_SIZE) {\n\t\tpr_err(\"Adding page to bio failed at %llu\\n\",\n\t\t       (unsigned long long)bio->bi_iter.bi_sector);\n\t\tbio_put(bio);\n\t\treturn -EFAULT;\n\t}\n\n\tif (hb) {\n\t\tbio->bi_end_io = hib_end_io;\n\t\tbio->bi_private = hb;\n\t\tatomic_inc(&hb->count);\n\t\tsubmit_bio(bio);\n\t} else {\n\t\terror = submit_bio_wait(bio);\n\t\tbio_put(bio);\n\t}\n\n\treturn error;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/ktime.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/atomic.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/lzo.h>",
            "#include <linux/slab.h>",
            "#include <linux/pm.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/device.h>",
            "#include <linux/genhd.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/file.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct block_device *hib_resume_bdev;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/ktime.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/atomic.h>\n#include <linux/cpumask.h>\n#include <linux/vmalloc.h>\n#include <linux/lzo.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/device.h>\n#include <linux/genhd.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\nstatic struct block_device *hib_resume_bdev;\n\nstatic int hib_submit_io(int op, int op_flags, pgoff_t page_off, void *addr,\n\t\tstruct hib_bio_batch *hb)\n{\n\tstruct page *page = virt_to_page(addr);\n\tstruct bio *bio;\n\tint error = 0;\n\n\tbio = bio_alloc(GFP_NOIO | __GFP_HIGH, 1);\n\tbio->bi_iter.bi_sector = page_off * (PAGE_SIZE >> 9);\n\tbio_set_dev(bio, hib_resume_bdev);\n\tbio_set_op_attrs(bio, op, op_flags);\n\n\tif (bio_add_page(bio, page, PAGE_SIZE, 0) < PAGE_SIZE) {\n\t\tpr_err(\"Adding page to bio failed at %llu\\n\",\n\t\t       (unsigned long long)bio->bi_iter.bi_sector);\n\t\tbio_put(bio);\n\t\treturn -EFAULT;\n\t}\n\n\tif (hb) {\n\t\tbio->bi_end_io = hib_end_io;\n\t\tbio->bi_private = hb;\n\t\tatomic_inc(&hb->count);\n\t\tsubmit_bio(bio);\n\t} else {\n\t\terror = submit_bio_wait(bio);\n\t\tbio_put(bio);\n\t}\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "swsusp_header->sig",
            "HIBERNATE_SIG",
            "10"
          ],
          "line": 327
        },
        "resolved": true,
        "details": {
          "function_name": "memcpy_skip",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/internal.h",
          "lines": "180-184",
          "snippet": "static inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/refcount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/refcount.h>\n#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n\nstatic inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "\"SWAPSPACE2\"",
            "swsusp_header->sig",
            "10"
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "\"SWAP-SPACE\"",
            "swsusp_header->sig",
            "10"
          ],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/ktime.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/atomic.h>\n#include <linux/cpumask.h>\n#include <linux/vmalloc.h>\n#include <linux/lzo.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/device.h>\n#include <linux/genhd.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\n#define HIBERNATE_SIG\t\"S1SUSPEND\"\n\nu32 swsusp_hardware_signature;\nstatic struct swsusp_header *swsusp_header;\n\nstatic int mark_swapfiles(struct swap_map_handle *handle, unsigned int flags)\n{\n\tint error;\n\n\thib_submit_io(REQ_OP_READ, 0, swsusp_resume_block,\n\t\t      swsusp_header, NULL);\n\tif (!memcmp(\"SWAP-SPACE\",swsusp_header->sig, 10) ||\n\t    !memcmp(\"SWAPSPACE2\",swsusp_header->sig, 10)) {\n\t\tmemcpy(swsusp_header->orig_sig,swsusp_header->sig, 10);\n\t\tmemcpy(swsusp_header->sig, HIBERNATE_SIG, 10);\n\t\tswsusp_header->image = handle->first_sector;\n\t\tif (swsusp_hardware_signature) {\n\t\t\tswsusp_header->hw_sig = swsusp_hardware_signature;\n\t\t\tflags |= SF_HW_SIG;\n\t\t}\n\t\tswsusp_header->flags = flags;\n\t\tif (flags & SF_CRC32_MODE)\n\t\t\tswsusp_header->crc32 = handle->crc32;\n\t\terror = hib_submit_io(REQ_OP_WRITE, REQ_SYNC,\n\t\t\t\t      swsusp_resume_block, swsusp_header, NULL);\n\t} else {\n\t\tpr_err(\"Swap header not found!\\n\");\n\t\terror = -ENODEV;\n\t}\n\treturn error;\n}"
  },
  {
    "function_name": "hib_wait_io",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/swap.c",
    "lines": "305-313",
    "snippet": "static int hib_wait_io(struct hib_bio_batch *hb)\n{\n\t/*\n\t * We are relying on the behavior of blk_plug that a thread with\n\t * a plug will flush the plug list before sleeping.\n\t */\n\twait_event(hb->wait, atomic_read(&hb->count) == 0);\n\treturn blk_status_to_errno(hb->error);\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/ktime.h>",
      "#include <linux/crc32.h>",
      "#include <linux/kthread.h>",
      "#include <linux/atomic.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/lzo.h>",
      "#include <linux/slab.h>",
      "#include <linux/pm.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include <linux/device.h>",
      "#include <linux/genhd.h>",
      "#include <linux/bitops.h>",
      "#include <linux/delay.h>",
      "#include <linux/file.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "blk_status_to_errno",
          "args": [
            "hb->error"
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_event",
          "args": [
            "hb->wait",
            "atomic_read(&hb->count) == 0"
          ],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&hb->count"
          ],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/ktime.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/atomic.h>\n#include <linux/cpumask.h>\n#include <linux/vmalloc.h>\n#include <linux/lzo.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/device.h>\n#include <linux/genhd.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\nstatic int hib_wait_io(struct hib_bio_batch *hb)\n{\n\t/*\n\t * We are relying on the behavior of blk_plug that a thread with\n\t * a plug will flush the plug list before sleeping.\n\t */\n\twait_event(hb->wait, atomic_read(&hb->count) == 0);\n\treturn blk_status_to_errno(hb->error);\n}"
  },
  {
    "function_name": "hib_submit_io",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/swap.c",
    "lines": "273-303",
    "snippet": "static int hib_submit_io(int op, int op_flags, pgoff_t page_off, void *addr,\n\t\tstruct hib_bio_batch *hb)\n{\n\tstruct page *page = virt_to_page(addr);\n\tstruct bio *bio;\n\tint error = 0;\n\n\tbio = bio_alloc(GFP_NOIO | __GFP_HIGH, 1);\n\tbio->bi_iter.bi_sector = page_off * (PAGE_SIZE >> 9);\n\tbio_set_dev(bio, hib_resume_bdev);\n\tbio_set_op_attrs(bio, op, op_flags);\n\n\tif (bio_add_page(bio, page, PAGE_SIZE, 0) < PAGE_SIZE) {\n\t\tpr_err(\"Adding page to bio failed at %llu\\n\",\n\t\t       (unsigned long long)bio->bi_iter.bi_sector);\n\t\tbio_put(bio);\n\t\treturn -EFAULT;\n\t}\n\n\tif (hb) {\n\t\tbio->bi_end_io = hib_end_io;\n\t\tbio->bi_private = hb;\n\t\tatomic_inc(&hb->count);\n\t\tsubmit_bio(bio);\n\t} else {\n\t\terror = submit_bio_wait(bio);\n\t\tbio_put(bio);\n\t}\n\n\treturn error;\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/ktime.h>",
      "#include <linux/crc32.h>",
      "#include <linux/kthread.h>",
      "#include <linux/atomic.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/lzo.h>",
      "#include <linux/slab.h>",
      "#include <linux/pm.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include <linux/device.h>",
      "#include <linux/genhd.h>",
      "#include <linux/bitops.h>",
      "#include <linux/delay.h>",
      "#include <linux/file.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct block_device *hib_resume_bdev;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bio_put",
          "args": [
            "bio"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "submit_bio_wait",
          "args": [
            "bio"
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "submit_bio",
          "args": [
            "bio"
          ],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&hb->count"
          ],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bio_put",
          "args": [
            "bio"
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Adding page to bio failed at %llu\\n\"",
            "(unsigned long long)bio->bi_iter.bi_sector"
          ],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bio_add_page",
          "args": [
            "bio",
            "page",
            "PAGE_SIZE",
            "0"
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bio_set_op_attrs",
          "args": [
            "bio",
            "op",
            "op_flags"
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bio_set_dev",
          "args": [
            "bio",
            "hib_resume_bdev"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bio_alloc",
          "args": [
            "GFP_NOIO | __GFP_HIGH",
            "1"
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virt_to_page",
          "args": [
            "addr"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/ktime.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/atomic.h>\n#include <linux/cpumask.h>\n#include <linux/vmalloc.h>\n#include <linux/lzo.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/device.h>\n#include <linux/genhd.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\nstatic struct block_device *hib_resume_bdev;\n\nstatic int hib_submit_io(int op, int op_flags, pgoff_t page_off, void *addr,\n\t\tstruct hib_bio_batch *hb)\n{\n\tstruct page *page = virt_to_page(addr);\n\tstruct bio *bio;\n\tint error = 0;\n\n\tbio = bio_alloc(GFP_NOIO | __GFP_HIGH, 1);\n\tbio->bi_iter.bi_sector = page_off * (PAGE_SIZE >> 9);\n\tbio_set_dev(bio, hib_resume_bdev);\n\tbio_set_op_attrs(bio, op, op_flags);\n\n\tif (bio_add_page(bio, page, PAGE_SIZE, 0) < PAGE_SIZE) {\n\t\tpr_err(\"Adding page to bio failed at %llu\\n\",\n\t\t       (unsigned long long)bio->bi_iter.bi_sector);\n\t\tbio_put(bio);\n\t\treturn -EFAULT;\n\t}\n\n\tif (hb) {\n\t\tbio->bi_end_io = hib_end_io;\n\t\tbio->bi_private = hb;\n\t\tatomic_inc(&hb->count);\n\t\tsubmit_bio(bio);\n\t} else {\n\t\terror = submit_bio_wait(bio);\n\t\tbio_put(bio);\n\t}\n\n\treturn error;\n}"
  },
  {
    "function_name": "hib_end_io",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/swap.c",
    "lines": "248-271",
    "snippet": "static void hib_end_io(struct bio *bio)\n{\n\tstruct hib_bio_batch *hb = bio->bi_private;\n\tstruct page *page = bio_first_page_all(bio);\n\n\tif (bio->bi_status) {\n\t\tpr_alert(\"Read-error on swap-device (%u:%u:%Lu)\\n\",\n\t\t\t MAJOR(bio_dev(bio)), MINOR(bio_dev(bio)),\n\t\t\t (unsigned long long)bio->bi_iter.bi_sector);\n\t}\n\n\tif (bio_data_dir(bio) == WRITE)\n\t\tput_page(page);\n\telse if (clean_pages_on_read)\n\t\tflush_icache_range((unsigned long)page_address(page),\n\t\t\t\t   (unsigned long)page_address(page) + PAGE_SIZE);\n\n\tif (bio->bi_status && !hb->error)\n\t\thb->error = bio->bi_status;\n\tif (atomic_dec_and_test(&hb->count))\n\t\twake_up(&hb->wait);\n\n\tbio_put(bio);\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/ktime.h>",
      "#include <linux/crc32.h>",
      "#include <linux/kthread.h>",
      "#include <linux/atomic.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/lzo.h>",
      "#include <linux/slab.h>",
      "#include <linux/pm.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include <linux/device.h>",
      "#include <linux/genhd.h>",
      "#include <linux/bitops.h>",
      "#include <linux/delay.h>",
      "#include <linux/file.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool clean_pages_on_read;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bio_put",
          "args": [
            "bio"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wake_up",
          "args": [
            "&hb->wait"
          ],
          "line": 268
        },
        "resolved": true,
        "details": {
          "function_name": "wake_up_worker",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "847-853",
          "snippet": "static void wake_up_worker(struct worker_pool *pool)\n{\n\tstruct worker *worker = first_idle_worker(pool);\n\n\tif (likely(worker))\n\t\twake_up_process(worker->task);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
            "static void show_one_worker_pool(struct worker_pool *pool);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nstatic void wake_up_worker(struct worker_pool *pool)\n{\n\tstruct worker *worker = first_idle_worker(pool);\n\n\tif (likely(worker))\n\t\twake_up_process(worker->task);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_dec_and_test",
          "args": [
            "&hb->count"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_icache_range",
          "args": [
            "(unsigned long)page_address(page)",
            "(unsigned long)page_address(page) + PAGE_SIZE"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "page"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "page"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "page"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bio_data_dir",
          "args": [
            "bio"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_alert",
          "args": [
            "\"Read-error on swap-device (%u:%u:%Lu)\\n\"",
            "MAJOR(bio_dev(bio))",
            "MINOR(bio_dev(bio))",
            "(unsigned long long)bio->bi_iter.bi_sector"
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MINOR",
          "args": [
            "bio_dev(bio)"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bio_dev",
          "args": [
            "bio"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAJOR",
          "args": [
            "bio_dev(bio)"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bio_dev",
          "args": [
            "bio"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bio_first_page_all",
          "args": [
            "bio"
          ],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/ktime.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/atomic.h>\n#include <linux/cpumask.h>\n#include <linux/vmalloc.h>\n#include <linux/lzo.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/device.h>\n#include <linux/genhd.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\nstatic bool clean_pages_on_read;\n\nstatic void hib_end_io(struct bio *bio)\n{\n\tstruct hib_bio_batch *hb = bio->bi_private;\n\tstruct page *page = bio_first_page_all(bio);\n\n\tif (bio->bi_status) {\n\t\tpr_alert(\"Read-error on swap-device (%u:%u:%Lu)\\n\",\n\t\t\t MAJOR(bio_dev(bio)), MINOR(bio_dev(bio)),\n\t\t\t (unsigned long long)bio->bi_iter.bi_sector);\n\t}\n\n\tif (bio_data_dir(bio) == WRITE)\n\t\tput_page(page);\n\telse if (clean_pages_on_read)\n\t\tflush_icache_range((unsigned long)page_address(page),\n\t\t\t\t   (unsigned long)page_address(page) + PAGE_SIZE);\n\n\tif (bio->bi_status && !hb->error)\n\t\thb->error = bio->bi_status;\n\tif (atomic_dec_and_test(&hb->count))\n\t\twake_up(&hb->wait);\n\n\tbio_put(bio);\n}"
  },
  {
    "function_name": "hib_finish_batch",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/swap.c",
    "lines": "243-246",
    "snippet": "static void hib_finish_batch(struct hib_bio_batch *hb)\n{\n\tblk_finish_plug(&hb->plug);\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/ktime.h>",
      "#include <linux/crc32.h>",
      "#include <linux/kthread.h>",
      "#include <linux/atomic.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/lzo.h>",
      "#include <linux/slab.h>",
      "#include <linux/pm.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include <linux/device.h>",
      "#include <linux/genhd.h>",
      "#include <linux/bitops.h>",
      "#include <linux/delay.h>",
      "#include <linux/file.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "blk_finish_plug",
          "args": [
            "&hb->plug"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/ktime.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/atomic.h>\n#include <linux/cpumask.h>\n#include <linux/vmalloc.h>\n#include <linux/lzo.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/device.h>\n#include <linux/genhd.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\nstatic void hib_finish_batch(struct hib_bio_batch *hb)\n{\n\tblk_finish_plug(&hb->plug);\n}"
  },
  {
    "function_name": "hib_init_batch",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/swap.c",
    "lines": "235-241",
    "snippet": "static void hib_init_batch(struct hib_bio_batch *hb)\n{\n\tatomic_set(&hb->count, 0);\n\tinit_waitqueue_head(&hb->wait);\n\thb->error = BLK_STS_OK;\n\tblk_start_plug(&hb->plug);\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/ktime.h>",
      "#include <linux/crc32.h>",
      "#include <linux/kthread.h>",
      "#include <linux/atomic.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/lzo.h>",
      "#include <linux/slab.h>",
      "#include <linux/pm.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include <linux/device.h>",
      "#include <linux/genhd.h>",
      "#include <linux/bitops.h>",
      "#include <linux/delay.h>",
      "#include <linux/file.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "blk_start_plug",
          "args": [
            "&hb->plug"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_waitqueue_head",
          "args": [
            "&hb->wait"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&hb->count",
            "0"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/ktime.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/atomic.h>\n#include <linux/cpumask.h>\n#include <linux/vmalloc.h>\n#include <linux/lzo.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/device.h>\n#include <linux/genhd.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\nstatic void hib_init_batch(struct hib_bio_batch *hb)\n{\n\tatomic_set(&hb->count, 0);\n\tinit_waitqueue_head(&hb->wait);\n\thb->error = BLK_STS_OK;\n\tblk_start_plug(&hb->plug);\n}"
  },
  {
    "function_name": "swsusp_swap_in_use",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/swap.c",
    "lines": "216-219",
    "snippet": "int swsusp_swap_in_use(void)\n{\n\treturn (swsusp_extents.rb_node != NULL);\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/ktime.h>",
      "#include <linux/crc32.h>",
      "#include <linux/kthread.h>",
      "#include <linux/atomic.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/lzo.h>",
      "#include <linux/slab.h>",
      "#include <linux/pm.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include <linux/device.h>",
      "#include <linux/genhd.h>",
      "#include <linux/bitops.h>",
      "#include <linux/delay.h>",
      "#include <linux/file.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct rb_root swsusp_extents = RB_ROOT;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/ktime.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/atomic.h>\n#include <linux/cpumask.h>\n#include <linux/vmalloc.h>\n#include <linux/lzo.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/device.h>\n#include <linux/genhd.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\nstatic struct rb_root swsusp_extents = RB_ROOT;\n\nint swsusp_swap_in_use(void)\n{\n\treturn (swsusp_extents.rb_node != NULL);\n}"
  },
  {
    "function_name": "free_all_swap_pages",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/swap.c",
    "lines": "199-214",
    "snippet": "void free_all_swap_pages(int swap)\n{\n\tstruct rb_node *node;\n\n\twhile ((node = swsusp_extents.rb_node)) {\n\t\tstruct swsusp_extent *ext;\n\t\tunsigned long offset;\n\n\t\text = rb_entry(node, struct swsusp_extent, node);\n\t\trb_erase(node, &swsusp_extents);\n\t\tfor (offset = ext->start; offset <= ext->end; offset++)\n\t\t\tswap_free(swp_entry(swap, offset));\n\n\t\tkfree(ext);\n\t}\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/ktime.h>",
      "#include <linux/crc32.h>",
      "#include <linux/kthread.h>",
      "#include <linux/atomic.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/lzo.h>",
      "#include <linux/slab.h>",
      "#include <linux/pm.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include <linux/device.h>",
      "#include <linux/genhd.h>",
      "#include <linux/bitops.h>",
      "#include <linux/delay.h>",
      "#include <linux/file.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct rb_root swsusp_extents = RB_ROOT;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ext"
          ],
          "line": 212
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "swap_free",
          "args": [
            "swp_entry(swap, offset)"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swp_entry",
          "args": [
            "swap",
            "offset"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_erase",
          "args": [
            "node",
            "&swsusp_extents"
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "node",
            "structswsusp_extent",
            "node"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/ktime.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/atomic.h>\n#include <linux/cpumask.h>\n#include <linux/vmalloc.h>\n#include <linux/lzo.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/device.h>\n#include <linux/genhd.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\nstatic struct rb_root swsusp_extents = RB_ROOT;\n\nvoid free_all_swap_pages(int swap)\n{\n\tstruct rb_node *node;\n\n\twhile ((node = swsusp_extents.rb_node)) {\n\t\tstruct swsusp_extent *ext;\n\t\tunsigned long offset;\n\n\t\text = rb_entry(node, struct swsusp_extent, node);\n\t\trb_erase(node, &swsusp_extents);\n\t\tfor (offset = ext->start; offset <= ext->end; offset++)\n\t\t\tswap_free(swp_entry(swap, offset));\n\n\t\tkfree(ext);\n\t}\n}"
  },
  {
    "function_name": "alloc_swapdev_block",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/swap.c",
    "lines": "179-191",
    "snippet": "sector_t alloc_swapdev_block(int swap)\n{\n\tunsigned long offset;\n\n\toffset = swp_offset(get_swap_page_of_type(swap));\n\tif (offset) {\n\t\tif (swsusp_extents_insert(offset))\n\t\t\tswap_free(swp_entry(swap, offset));\n\t\telse\n\t\t\treturn swapdev_block(swap, offset);\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/ktime.h>",
      "#include <linux/crc32.h>",
      "#include <linux/kthread.h>",
      "#include <linux/atomic.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/lzo.h>",
      "#include <linux/slab.h>",
      "#include <linux/pm.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include <linux/device.h>",
      "#include <linux/genhd.h>",
      "#include <linux/bitops.h>",
      "#include <linux/delay.h>",
      "#include <linux/file.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "swapdev_block",
          "args": [
            "swap",
            "offset"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swap_free",
          "args": [
            "swp_entry(swap, offset)"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swp_entry",
          "args": [
            "swap",
            "offset"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swsusp_extents_insert",
          "args": [
            "offset"
          ],
          "line": 185
        },
        "resolved": true,
        "details": {
          "function_name": "swsusp_extents_insert",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/swap.c",
          "lines": "133-172",
          "snippet": "static int swsusp_extents_insert(unsigned long swap_offset)\n{\n\tstruct rb_node **new = &(swsusp_extents.rb_node);\n\tstruct rb_node *parent = NULL;\n\tstruct swsusp_extent *ext;\n\n\t/* Figure out where to put the new node */\n\twhile (*new) {\n\t\text = rb_entry(*new, struct swsusp_extent, node);\n\t\tparent = *new;\n\t\tif (swap_offset < ext->start) {\n\t\t\t/* Try to merge */\n\t\t\tif (swap_offset == ext->start - 1) {\n\t\t\t\text->start--;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tnew = &((*new)->rb_left);\n\t\t} else if (swap_offset > ext->end) {\n\t\t\t/* Try to merge */\n\t\t\tif (swap_offset == ext->end + 1) {\n\t\t\t\text->end++;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tnew = &((*new)->rb_right);\n\t\t} else {\n\t\t\t/* It already is in the tree */\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\t/* Add the new node and rebalance the tree. */\n\text = kzalloc(sizeof(struct swsusp_extent), GFP_KERNEL);\n\tif (!ext)\n\t\treturn -ENOMEM;\n\n\text->start = swap_offset;\n\text->end = swap_offset;\n\trb_link_node(&ext->node, parent, new);\n\trb_insert_color(&ext->node, &swsusp_extents);\n\treturn 0;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/ktime.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/atomic.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/lzo.h>",
            "#include <linux/slab.h>",
            "#include <linux/pm.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/device.h>",
            "#include <linux/genhd.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/file.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct rb_root swsusp_extents = RB_ROOT;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/ktime.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/atomic.h>\n#include <linux/cpumask.h>\n#include <linux/vmalloc.h>\n#include <linux/lzo.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/device.h>\n#include <linux/genhd.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\nstatic struct rb_root swsusp_extents = RB_ROOT;\n\nstatic int swsusp_extents_insert(unsigned long swap_offset)\n{\n\tstruct rb_node **new = &(swsusp_extents.rb_node);\n\tstruct rb_node *parent = NULL;\n\tstruct swsusp_extent *ext;\n\n\t/* Figure out where to put the new node */\n\twhile (*new) {\n\t\text = rb_entry(*new, struct swsusp_extent, node);\n\t\tparent = *new;\n\t\tif (swap_offset < ext->start) {\n\t\t\t/* Try to merge */\n\t\t\tif (swap_offset == ext->start - 1) {\n\t\t\t\text->start--;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tnew = &((*new)->rb_left);\n\t\t} else if (swap_offset > ext->end) {\n\t\t\t/* Try to merge */\n\t\t\tif (swap_offset == ext->end + 1) {\n\t\t\t\text->end++;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tnew = &((*new)->rb_right);\n\t\t} else {\n\t\t\t/* It already is in the tree */\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\t/* Add the new node and rebalance the tree. */\n\text = kzalloc(sizeof(struct swsusp_extent), GFP_KERNEL);\n\tif (!ext)\n\t\treturn -ENOMEM;\n\n\text->start = swap_offset;\n\text->end = swap_offset;\n\trb_link_node(&ext->node, parent, new);\n\trb_insert_color(&ext->node, &swsusp_extents);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "swp_offset",
          "args": [
            "get_swap_page_of_type(swap)"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_swap_page_of_type",
          "args": [
            "swap"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/ktime.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/atomic.h>\n#include <linux/cpumask.h>\n#include <linux/vmalloc.h>\n#include <linux/lzo.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/device.h>\n#include <linux/genhd.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\nsector_t alloc_swapdev_block(int swap)\n{\n\tunsigned long offset;\n\n\toffset = swp_offset(get_swap_page_of_type(swap));\n\tif (offset) {\n\t\tif (swsusp_extents_insert(offset))\n\t\t\tswap_free(swp_entry(swap, offset));\n\t\telse\n\t\t\treturn swapdev_block(swap, offset);\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "swsusp_extents_insert",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/swap.c",
    "lines": "133-172",
    "snippet": "static int swsusp_extents_insert(unsigned long swap_offset)\n{\n\tstruct rb_node **new = &(swsusp_extents.rb_node);\n\tstruct rb_node *parent = NULL;\n\tstruct swsusp_extent *ext;\n\n\t/* Figure out where to put the new node */\n\twhile (*new) {\n\t\text = rb_entry(*new, struct swsusp_extent, node);\n\t\tparent = *new;\n\t\tif (swap_offset < ext->start) {\n\t\t\t/* Try to merge */\n\t\t\tif (swap_offset == ext->start - 1) {\n\t\t\t\text->start--;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tnew = &((*new)->rb_left);\n\t\t} else if (swap_offset > ext->end) {\n\t\t\t/* Try to merge */\n\t\t\tif (swap_offset == ext->end + 1) {\n\t\t\t\text->end++;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tnew = &((*new)->rb_right);\n\t\t} else {\n\t\t\t/* It already is in the tree */\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\t/* Add the new node and rebalance the tree. */\n\text = kzalloc(sizeof(struct swsusp_extent), GFP_KERNEL);\n\tif (!ext)\n\t\treturn -ENOMEM;\n\n\text->start = swap_offset;\n\text->end = swap_offset;\n\trb_link_node(&ext->node, parent, new);\n\trb_insert_color(&ext->node, &swsusp_extents);\n\treturn 0;\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/ktime.h>",
      "#include <linux/crc32.h>",
      "#include <linux/kthread.h>",
      "#include <linux/atomic.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/lzo.h>",
      "#include <linux/slab.h>",
      "#include <linux/pm.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include <linux/device.h>",
      "#include <linux/genhd.h>",
      "#include <linux/bitops.h>",
      "#include <linux/delay.h>",
      "#include <linux/file.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct rb_root swsusp_extents = RB_ROOT;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rb_insert_color",
          "args": [
            "&ext->node",
            "&swsusp_extents"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_link_node",
          "args": [
            "&ext->node",
            "parent",
            "new"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct swsusp_extent)",
            "GFP_KERNEL"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "*new",
            "structswsusp_extent",
            "node"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/ktime.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/atomic.h>\n#include <linux/cpumask.h>\n#include <linux/vmalloc.h>\n#include <linux/lzo.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/device.h>\n#include <linux/genhd.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\nstatic struct rb_root swsusp_extents = RB_ROOT;\n\nstatic int swsusp_extents_insert(unsigned long swap_offset)\n{\n\tstruct rb_node **new = &(swsusp_extents.rb_node);\n\tstruct rb_node *parent = NULL;\n\tstruct swsusp_extent *ext;\n\n\t/* Figure out where to put the new node */\n\twhile (*new) {\n\t\text = rb_entry(*new, struct swsusp_extent, node);\n\t\tparent = *new;\n\t\tif (swap_offset < ext->start) {\n\t\t\t/* Try to merge */\n\t\t\tif (swap_offset == ext->start - 1) {\n\t\t\t\text->start--;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tnew = &((*new)->rb_left);\n\t\t} else if (swap_offset > ext->end) {\n\t\t\t/* Try to merge */\n\t\t\tif (swap_offset == ext->end + 1) {\n\t\t\t\text->end++;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tnew = &((*new)->rb_right);\n\t\t} else {\n\t\t\t/* It already is in the tree */\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\t/* Add the new node and rebalance the tree. */\n\text = kzalloc(sizeof(struct swsusp_extent), GFP_KERNEL);\n\tif (!ext)\n\t\treturn -ENOMEM;\n\n\text->start = swap_offset;\n\text->end = swap_offset;\n\trb_link_node(&ext->node, parent, new);\n\trb_insert_color(&ext->node, &swsusp_extents);\n\treturn 0;\n}"
  },
  {
    "function_name": "reqd_free_pages",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/swap.c",
    "lines": "77-80",
    "snippet": "static inline unsigned long reqd_free_pages(void)\n{\n\treturn low_free_pages() / 2;\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/ktime.h>",
      "#include <linux/crc32.h>",
      "#include <linux/kthread.h>",
      "#include <linux/atomic.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/lzo.h>",
      "#include <linux/slab.h>",
      "#include <linux/pm.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include <linux/device.h>",
      "#include <linux/genhd.h>",
      "#include <linux/bitops.h>",
      "#include <linux/delay.h>",
      "#include <linux/file.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "low_free_pages",
          "args": [],
          "line": 79
        },
        "resolved": true,
        "details": {
          "function_name": "low_free_pages",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/swap.c",
          "lines": "68-71",
          "snippet": "static inline unsigned long low_free_pages(void)\n{\n\treturn nr_free_pages() - nr_free_highpages();\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/ktime.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/atomic.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/lzo.h>",
            "#include <linux/slab.h>",
            "#include <linux/pm.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/device.h>",
            "#include <linux/genhd.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/file.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/ktime.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/atomic.h>\n#include <linux/cpumask.h>\n#include <linux/vmalloc.h>\n#include <linux/lzo.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/device.h>\n#include <linux/genhd.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\nstatic inline unsigned long low_free_pages(void)\n{\n\treturn nr_free_pages() - nr_free_highpages();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/ktime.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/atomic.h>\n#include <linux/cpumask.h>\n#include <linux/vmalloc.h>\n#include <linux/lzo.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/device.h>\n#include <linux/genhd.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\nstatic inline unsigned long reqd_free_pages(void)\n{\n\treturn low_free_pages() / 2;\n}"
  },
  {
    "function_name": "low_free_pages",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/swap.c",
    "lines": "68-71",
    "snippet": "static inline unsigned long low_free_pages(void)\n{\n\treturn nr_free_pages() - nr_free_highpages();\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/ktime.h>",
      "#include <linux/crc32.h>",
      "#include <linux/kthread.h>",
      "#include <linux/atomic.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/lzo.h>",
      "#include <linux/slab.h>",
      "#include <linux/pm.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include <linux/device.h>",
      "#include <linux/genhd.h>",
      "#include <linux/bitops.h>",
      "#include <linux/delay.h>",
      "#include <linux/file.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nr_free_highpages",
          "args": [],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nr_free_pages",
          "args": [],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/ktime.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/atomic.h>\n#include <linux/cpumask.h>\n#include <linux/vmalloc.h>\n#include <linux/lzo.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/device.h>\n#include <linux/genhd.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\nstatic inline unsigned long low_free_pages(void)\n{\n\treturn nr_free_pages() - nr_free_highpages();\n}"
  }
]