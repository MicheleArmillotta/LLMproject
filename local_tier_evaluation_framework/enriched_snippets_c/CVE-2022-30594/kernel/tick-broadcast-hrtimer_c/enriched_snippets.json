[
  {
    "function_name": "tick_setup_hrtimer_broadcast",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-broadcast-hrtimer.c",
    "lines": "106-111",
    "snippet": "void tick_setup_hrtimer_broadcast(void)\n{\n\thrtimer_init(&bctimer, CLOCK_MONOTONIC, HRTIMER_MODE_ABS_HARD);\n\tbctimer.function = bc_handler;\n\tclockevents_register_device(&ce_broadcast_hrtimer);\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/clockchips.h>",
      "#include <linux/profile.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct hrtimer bctimer;",
      "static struct clock_event_device ce_broadcast_hrtimer = {\n\t.name\t\t\t= \"bc_hrtimer\",\n\t.set_state_shutdown\t= bc_shutdown,\n\t.set_next_ktime\t\t= bc_set_next,\n\t.features\t\t= CLOCK_EVT_FEAT_ONESHOT |\n\t\t\t\t  CLOCK_EVT_FEAT_KTIME |\n\t\t\t\t  CLOCK_EVT_FEAT_HRTIMER,\n\t.rating\t\t\t= 0,\n\t.bound_on\t\t= -1,\n\t.min_delta_ns\t\t= 1,\n\t.max_delta_ns\t\t= KTIME_MAX,\n\t.min_delta_ticks\t= 1,\n\t.max_delta_ticks\t= ULONG_MAX,\n\t.mult\t\t\t= 1,\n\t.shift\t\t\t= 0,\n\t.cpumask\t\t= cpu_possible_mask,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "clockevents_register_device",
          "args": [
            "&ce_broadcast_hrtimer"
          ],
          "line": 110
        },
        "resolved": true,
        "details": {
          "function_name": "clockevents_register_device",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clockevents.c",
          "lines": "443-468",
          "snippet": "void clockevents_register_device(struct clock_event_device *dev)\n{\n\tunsigned long flags;\n\n\t/* Initialize state to DETACHED */\n\tclockevent_set_state(dev, CLOCK_EVT_STATE_DETACHED);\n\n\tif (!dev->cpumask) {\n\t\tWARN_ON(num_possible_cpus() > 1);\n\t\tdev->cpumask = cpumask_of(smp_processor_id());\n\t}\n\n\tif (dev->cpumask == cpu_all_mask) {\n\t\tWARN(1, \"%s cpumask == cpu_all_mask, using cpu_possible_mask instead\\n\",\n\t\t     dev->name);\n\t\tdev->cpumask = cpu_possible_mask;\n\t}\n\n\traw_spin_lock_irqsave(&clockevents_lock, flags);\n\n\tlist_add(&dev->list, &clockevent_devices);\n\ttick_check_new_device(dev);\n\tclockevents_notify_released();\n\n\traw_spin_unlock_irqrestore(&clockevents_lock, flags);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/smp.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/clockchips.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(clockevent_devices);",
            "static DEFINE_RAW_SPINLOCK(clockevents_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/device.h>\n#include <linux/smp.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/hrtimer.h>\n#include <linux/clockchips.h>\n\nstatic LIST_HEAD(clockevent_devices);\nstatic DEFINE_RAW_SPINLOCK(clockevents_lock);\n\nvoid clockevents_register_device(struct clock_event_device *dev)\n{\n\tunsigned long flags;\n\n\t/* Initialize state to DETACHED */\n\tclockevent_set_state(dev, CLOCK_EVT_STATE_DETACHED);\n\n\tif (!dev->cpumask) {\n\t\tWARN_ON(num_possible_cpus() > 1);\n\t\tdev->cpumask = cpumask_of(smp_processor_id());\n\t}\n\n\tif (dev->cpumask == cpu_all_mask) {\n\t\tWARN(1, \"%s cpumask == cpu_all_mask, using cpu_possible_mask instead\\n\",\n\t\t     dev->name);\n\t\tdev->cpumask = cpu_possible_mask;\n\t}\n\n\traw_spin_lock_irqsave(&clockevents_lock, flags);\n\n\tlist_add(&dev->list, &clockevent_devices);\n\ttick_check_new_device(dev);\n\tclockevents_notify_released();\n\n\traw_spin_unlock_irqrestore(&clockevents_lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hrtimer_init",
          "args": [
            "&bctimer",
            "CLOCK_MONOTONIC",
            "HRTIMER_MODE_ABS_HARD"
          ],
          "line": 108
        },
        "resolved": true,
        "details": {
          "function_name": "hrtimer_init_sleeper",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
          "lines": "2007-2013",
          "snippet": "void hrtimer_init_sleeper(struct hrtimer_sleeper *sl, clockid_t clock_id,\n\t\t\t  enum hrtimer_mode mode)\n{\n\tdebug_init(&sl->timer, clock_id, mode);\n\t__hrtimer_init_sleeper(sl, clock_id, mode);\n\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nvoid hrtimer_init_sleeper(struct hrtimer_sleeper *sl, clockid_t clock_id,\n\t\t\t  enum hrtimer_mode mode)\n{\n\tdebug_init(&sl->timer, clock_id, mode);\n\t__hrtimer_init_sleeper(sl, clock_id, mode);\n\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/module.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/clockchips.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic struct hrtimer bctimer;\nstatic struct clock_event_device ce_broadcast_hrtimer = {\n\t.name\t\t\t= \"bc_hrtimer\",\n\t.set_state_shutdown\t= bc_shutdown,\n\t.set_next_ktime\t\t= bc_set_next,\n\t.features\t\t= CLOCK_EVT_FEAT_ONESHOT |\n\t\t\t\t  CLOCK_EVT_FEAT_KTIME |\n\t\t\t\t  CLOCK_EVT_FEAT_HRTIMER,\n\t.rating\t\t\t= 0,\n\t.bound_on\t\t= -1,\n\t.min_delta_ns\t\t= 1,\n\t.max_delta_ns\t\t= KTIME_MAX,\n\t.min_delta_ticks\t= 1,\n\t.max_delta_ticks\t= ULONG_MAX,\n\t.mult\t\t\t= 1,\n\t.shift\t\t\t= 0,\n\t.cpumask\t\t= cpu_possible_mask,\n};\n\nvoid tick_setup_hrtimer_broadcast(void)\n{\n\thrtimer_init(&bctimer, CLOCK_MONOTONIC, HRTIMER_MODE_ABS_HARD);\n\tbctimer.function = bc_handler;\n\tclockevents_register_device(&ce_broadcast_hrtimer);\n}"
  },
  {
    "function_name": "bc_handler",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-broadcast-hrtimer.c",
    "lines": "99-104",
    "snippet": "static enum hrtimer_restart bc_handler(struct hrtimer *t)\n{\n\tce_broadcast_hrtimer.event_handler(&ce_broadcast_hrtimer);\n\n\treturn HRTIMER_NORESTART;\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/clockchips.h>",
      "#include <linux/profile.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct clock_event_device ce_broadcast_hrtimer = {\n\t.name\t\t\t= \"bc_hrtimer\",\n\t.set_state_shutdown\t= bc_shutdown,\n\t.set_next_ktime\t\t= bc_set_next,\n\t.features\t\t= CLOCK_EVT_FEAT_ONESHOT |\n\t\t\t\t  CLOCK_EVT_FEAT_KTIME |\n\t\t\t\t  CLOCK_EVT_FEAT_HRTIMER,\n\t.rating\t\t\t= 0,\n\t.bound_on\t\t= -1,\n\t.min_delta_ns\t\t= 1,\n\t.max_delta_ns\t\t= KTIME_MAX,\n\t.min_delta_ticks\t= 1,\n\t.max_delta_ticks\t= ULONG_MAX,\n\t.mult\t\t\t= 1,\n\t.shift\t\t\t= 0,\n\t.cpumask\t\t= cpu_possible_mask,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ce_broadcast_hrtimer.event_handler",
          "args": [
            "&ce_broadcast_hrtimer"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/module.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/clockchips.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic struct clock_event_device ce_broadcast_hrtimer = {\n\t.name\t\t\t= \"bc_hrtimer\",\n\t.set_state_shutdown\t= bc_shutdown,\n\t.set_next_ktime\t\t= bc_set_next,\n\t.features\t\t= CLOCK_EVT_FEAT_ONESHOT |\n\t\t\t\t  CLOCK_EVT_FEAT_KTIME |\n\t\t\t\t  CLOCK_EVT_FEAT_HRTIMER,\n\t.rating\t\t\t= 0,\n\t.bound_on\t\t= -1,\n\t.min_delta_ns\t\t= 1,\n\t.max_delta_ns\t\t= KTIME_MAX,\n\t.min_delta_ticks\t= 1,\n\t.max_delta_ticks\t= ULONG_MAX,\n\t.mult\t\t\t= 1,\n\t.shift\t\t\t= 0,\n\t.cpumask\t\t= cpu_possible_mask,\n};\n\nstatic enum hrtimer_restart bc_handler(struct hrtimer *t)\n{\n\tce_broadcast_hrtimer.event_handler(&ce_broadcast_hrtimer);\n\n\treturn HRTIMER_NORESTART;\n}"
  },
  {
    "function_name": "bc_set_next",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-broadcast-hrtimer.c",
    "lines": "43-79",
    "snippet": "static int bc_set_next(ktime_t expires, struct clock_event_device *bc)\n{\n\t/*\n\t * This is called either from enter/exit idle code or from the\n\t * broadcast handler. In all cases tick_broadcast_lock is held.\n\t *\n\t * hrtimer_cancel() cannot be called here neither from the\n\t * broadcast handler nor from the enter/exit idle code. The idle\n\t * code can run into the problem described in bc_shutdown() and the\n\t * broadcast handler cannot wait for itself to complete for obvious\n\t * reasons.\n\t *\n\t * Each caller tries to arm the hrtimer on its own CPU, but if the\n\t * hrtimer callback function is currently running, then\n\t * hrtimer_start() cannot move it and the timer stays on the CPU on\n\t * which it is assigned at the moment.\n\t *\n\t * As this can be called from idle code, the hrtimer_start()\n\t * invocation has to be wrapped with RCU_NONIDLE() as\n\t * hrtimer_start() can call into tracing.\n\t */\n\tRCU_NONIDLE( {\n\t\thrtimer_start(&bctimer, expires, HRTIMER_MODE_ABS_PINNED_HARD);\n\t\t/*\n\t\t * The core tick broadcast mode expects bc->bound_on to be set\n\t\t * correctly to prevent a CPU which has the broadcast hrtimer\n\t\t * armed from going deep idle.\n\t\t *\n\t\t * As tick_broadcast_lock is held, nothing can change the cpu\n\t\t * base which was just established in hrtimer_start() above. So\n\t\t * the below access is safe even without holding the hrtimer\n\t\t * base lock.\n\t\t */\n\t\tbc->bound_on = bctimer.base->cpu_base->cpu;\n\t} );\n\treturn 0;\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/clockchips.h>",
      "#include <linux/profile.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct hrtimer bctimer;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "RCU_NONIDLE",
          "args": [
            "{\n\t\thrtimer_start(&bctimer, expires, HRTIMER_MODE_ABS_PINNED_HARD);\n\t\t/*\n\t\t * The core tick broadcast mode expects bc->bound_on to be set\n\t\t * correctly to prevent a CPU which has the broadcast hrtimer\n\t\t * armed from going deep idle.\n\t\t *\n\t\t * As tick_broadcast_lock is held, nothing can change the cpu\n\t\t * base which was just established in hrtimer_start() above. So\n\t\t * the below access is safe even without holding the hrtimer\n\t\t * base lock.\n\t\t */\n\t\tbc->bound_on = bctimer.base->cpu_base->cpu;\n\t}"
          ],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hrtimer_start",
          "args": [
            "&bctimer",
            "expires",
            "HRTIMER_MODE_ABS_PINNED_HARD"
          ],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/module.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/clockchips.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic struct hrtimer bctimer;\n\nstatic int bc_set_next(ktime_t expires, struct clock_event_device *bc)\n{\n\t/*\n\t * This is called either from enter/exit idle code or from the\n\t * broadcast handler. In all cases tick_broadcast_lock is held.\n\t *\n\t * hrtimer_cancel() cannot be called here neither from the\n\t * broadcast handler nor from the enter/exit idle code. The idle\n\t * code can run into the problem described in bc_shutdown() and the\n\t * broadcast handler cannot wait for itself to complete for obvious\n\t * reasons.\n\t *\n\t * Each caller tries to arm the hrtimer on its own CPU, but if the\n\t * hrtimer callback function is currently running, then\n\t * hrtimer_start() cannot move it and the timer stays on the CPU on\n\t * which it is assigned at the moment.\n\t *\n\t * As this can be called from idle code, the hrtimer_start()\n\t * invocation has to be wrapped with RCU_NONIDLE() as\n\t * hrtimer_start() can call into tracing.\n\t */\n\tRCU_NONIDLE( {\n\t\thrtimer_start(&bctimer, expires, HRTIMER_MODE_ABS_PINNED_HARD);\n\t\t/*\n\t\t * The core tick broadcast mode expects bc->bound_on to be set\n\t\t * correctly to prevent a CPU which has the broadcast hrtimer\n\t\t * armed from going deep idle.\n\t\t *\n\t\t * As tick_broadcast_lock is held, nothing can change the cpu\n\t\t * base which was just established in hrtimer_start() above. So\n\t\t * the below access is safe even without holding the hrtimer\n\t\t * base lock.\n\t\t */\n\t\tbc->bound_on = bctimer.base->cpu_base->cpu;\n\t} );\n\treturn 0;\n}"
  },
  {
    "function_name": "bc_shutdown",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-broadcast-hrtimer.c",
    "lines": "20-37",
    "snippet": "static int bc_shutdown(struct clock_event_device *evt)\n{\n\t/*\n\t * Note, we cannot cancel the timer here as we might\n\t * run into the following live lock scenario:\n\t *\n\t * cpu 0\t\tcpu1\n\t * lock(broadcast_lock);\n\t *\t\t\thrtimer_interrupt()\n\t *\t\t\tbc_handler()\n\t *\t\t\t   tick_handle_oneshot_broadcast();\n\t *\t\t\t    lock(broadcast_lock);\n\t * hrtimer_cancel()\n\t *  wait_for_callback()\n\t */\n\thrtimer_try_to_cancel(&bctimer);\n\treturn 0;\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/clockchips.h>",
      "#include <linux/profile.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct hrtimer bctimer;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "hrtimer_try_to_cancel",
          "args": [
            "&bctimer"
          ],
          "line": 35
        },
        "resolved": true,
        "details": {
          "function_name": "common_hrtimer_try_to_cancel",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-timers.c",
          "lines": "823-826",
          "snippet": "static int common_hrtimer_try_to_cancel(struct k_itimer *timr)\n{\n\treturn hrtimer_try_to_cancel(&timr->it.real.timer);\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include \"timekeeping.h\"",
            "#include <linux/time_namespace.h>",
            "#include <linux/nospec.h>",
            "#include <linux/compat.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/export.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/wait.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/posix-clock.h>",
            "#include <linux/hash.h>",
            "#include <linux/compiler.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/mutex.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include \"timekeeping.h\"\n#include <linux/time_namespace.h>\n#include <linux/nospec.h>\n#include <linux/compat.h>\n#include <linux/hashtable.h>\n#include <linux/export.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/syscalls.h>\n#include <linux/posix-timers.h>\n#include <linux/posix-clock.h>\n#include <linux/hash.h>\n#include <linux/compiler.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task.h>\n#include <linux/mutex.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nstatic int common_hrtimer_try_to_cancel(struct k_itimer *timr)\n{\n\treturn hrtimer_try_to_cancel(&timr->it.real.timer);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/module.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/clockchips.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic struct hrtimer bctimer;\n\nstatic int bc_shutdown(struct clock_event_device *evt)\n{\n\t/*\n\t * Note, we cannot cancel the timer here as we might\n\t * run into the following live lock scenario:\n\t *\n\t * cpu 0\t\tcpu1\n\t * lock(broadcast_lock);\n\t *\t\t\thrtimer_interrupt()\n\t *\t\t\tbc_handler()\n\t *\t\t\t   tick_handle_oneshot_broadcast();\n\t *\t\t\t    lock(broadcast_lock);\n\t * hrtimer_cancel()\n\t *  wait_for_callback()\n\t */\n\thrtimer_try_to_cancel(&bctimer);\n\treturn 0;\n}"
  }
]