[
  {
    "function_name": "mutex_destroy",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/mutex-debug.c",
    "lines": "100-104",
    "snippet": "void mutex_destroy(struct mutex *lock)\n{\n\tDEBUG_LOCKS_WARN_ON(mutex_is_locked(lock));\n\tlock->magic = NULL;\n}",
    "includes": [
      "#include \"mutex.h\"",
      "#include <linux/debug_locks.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/sched.h>",
      "#include <linux/poison.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "DEBUG_LOCKS_WARN_ON",
          "args": [
            "mutex_is_locked(lock)"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_is_locked",
          "args": [
            "lock"
          ],
          "line": 102
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_is_locked",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/mutex.c",
          "lines": "86-89",
          "snippet": "bool mutex_is_locked(struct mutex *lock)\n{\n\treturn __mutex_owner(lock) != NULL;\n}",
          "includes": [
            "#include \"ww_mutex.h\"",
            "#include \"mutex.h\"",
            "#include <linux/osq_lock.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/ww_mutex.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ww_mutex.h\"\n#include \"mutex.h\"\n#include <linux/osq_lock.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/ww_mutex.h>\n#include <linux/mutex.h>\n\nbool mutex_is_locked(struct mutex *lock)\n{\n\treturn __mutex_owner(lock) != NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"mutex.h\"\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/poison.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/mutex.h>\n\nvoid mutex_destroy(struct mutex *lock)\n{\n\tDEBUG_LOCKS_WARN_ON(mutex_is_locked(lock));\n\tlock->magic = NULL;\n}"
  },
  {
    "function_name": "debug_mutex_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/mutex-debug.c",
    "lines": "79-90",
    "snippet": "void debug_mutex_init(struct mutex *lock, const char *name,\n\t\t      struct lock_class_key *key)\n{\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\n\t/*\n\t * Make sure we are not reinitializing a held lock:\n\t */\n\tdebug_check_no_locks_freed((void *)lock, sizeof(*lock));\n\tlockdep_init_map_wait(&lock->dep_map, name, key, 0, LD_WAIT_SLEEP);\n#endif\n\tlock->magic = lock;\n}",
    "includes": [
      "#include \"mutex.h\"",
      "#include <linux/debug_locks.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/sched.h>",
      "#include <linux/poison.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lockdep_init_map_wait",
          "args": [
            "&lock->dep_map",
            "name",
            "key",
            "0",
            "LD_WAIT_SLEEP"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_check_no_locks_freed",
          "args": [
            "(void *)lock",
            "sizeof(*lock)"
          ],
          "line": 86
        },
        "resolved": true,
        "details": {
          "function_name": "debug_check_no_locks_freed",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "6405-6427",
          "snippet": "void debug_check_no_locks_freed(const void *mem_from, unsigned long mem_len)\n{\n\tstruct task_struct *curr = current;\n\tstruct held_lock *hlock;\n\tunsigned long flags;\n\tint i;\n\n\tif (unlikely(!debug_locks))\n\t\treturn;\n\n\traw_local_irq_save(flags);\n\tfor (i = 0; i < curr->lockdep_depth; i++) {\n\t\thlock = curr->held_locks + i;\n\n\t\tif (not_in_range(mem_from, mem_len, hlock->instance,\n\t\t\t\t\tsizeof(*hlock->instance)))\n\t\t\tcontinue;\n\n\t\tprint_freed_lock_bug(curr, mem_from, mem_from + mem_len, hlock);\n\t\tbreak;\n\t}\n\traw_local_irq_restore(flags);\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nvoid debug_check_no_locks_freed(const void *mem_from, unsigned long mem_len)\n{\n\tstruct task_struct *curr = current;\n\tstruct held_lock *hlock;\n\tunsigned long flags;\n\tint i;\n\n\tif (unlikely(!debug_locks))\n\t\treturn;\n\n\traw_local_irq_save(flags);\n\tfor (i = 0; i < curr->lockdep_depth; i++) {\n\t\thlock = curr->held_locks + i;\n\n\t\tif (not_in_range(mem_from, mem_len, hlock->instance,\n\t\t\t\t\tsizeof(*hlock->instance)))\n\t\t\tcontinue;\n\n\t\tprint_freed_lock_bug(curr, mem_from, mem_from + mem_len, hlock);\n\t\tbreak;\n\t}\n\traw_local_irq_restore(flags);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"mutex.h\"\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/poison.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/mutex.h>\n\nvoid debug_mutex_init(struct mutex *lock, const char *name,\n\t\t      struct lock_class_key *key)\n{\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\n\t/*\n\t * Make sure we are not reinitializing a held lock:\n\t */\n\tdebug_check_no_locks_freed((void *)lock, sizeof(*lock));\n\tlockdep_init_map_wait(&lock->dep_map, name, key, 0, LD_WAIT_SLEEP);\n#endif\n\tlock->magic = lock;\n}"
  },
  {
    "function_name": "debug_mutex_unlock",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/mutex-debug.c",
    "lines": "71-77",
    "snippet": "void debug_mutex_unlock(struct mutex *lock)\n{\n\tif (likely(debug_locks)) {\n\t\tDEBUG_LOCKS_WARN_ON(lock->magic != lock);\n\t\tDEBUG_LOCKS_WARN_ON(!lock->wait_list.prev && !lock->wait_list.next);\n\t}\n}",
    "includes": [
      "#include \"mutex.h\"",
      "#include <linux/debug_locks.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/sched.h>",
      "#include <linux/poison.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "DEBUG_LOCKS_WARN_ON",
          "args": [
            "!lock->wait_list.prev && !lock->wait_list.next"
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEBUG_LOCKS_WARN_ON",
          "args": [
            "lock->magic != lock"
          ],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "debug_locks"
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"mutex.h\"\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/poison.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/mutex.h>\n\nvoid debug_mutex_unlock(struct mutex *lock)\n{\n\tif (likely(debug_locks)) {\n\t\tDEBUG_LOCKS_WARN_ON(lock->magic != lock);\n\t\tDEBUG_LOCKS_WARN_ON(!lock->wait_list.prev && !lock->wait_list.next);\n\t}\n}"
  },
  {
    "function_name": "debug_mutex_remove_waiter",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/mutex-debug.c",
    "lines": "59-69",
    "snippet": "void debug_mutex_remove_waiter(struct mutex *lock, struct mutex_waiter *waiter,\n\t\t\t struct task_struct *task)\n{\n\tDEBUG_LOCKS_WARN_ON(list_empty(&waiter->list));\n\tDEBUG_LOCKS_WARN_ON(waiter->task != task);\n\tDEBUG_LOCKS_WARN_ON(task->blocked_on != waiter);\n\ttask->blocked_on = NULL;\n\n\tINIT_LIST_HEAD(&waiter->list);\n\twaiter->task = NULL;\n}",
    "includes": [
      "#include \"mutex.h\"",
      "#include <linux/debug_locks.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/sched.h>",
      "#include <linux/poison.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&waiter->list"
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEBUG_LOCKS_WARN_ON",
          "args": [
            "task->blocked_on != waiter"
          ],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEBUG_LOCKS_WARN_ON",
          "args": [
            "waiter->task != task"
          ],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEBUG_LOCKS_WARN_ON",
          "args": [
            "list_empty(&waiter->list)"
          ],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&waiter->list"
          ],
          "line": 62
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "41-44",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "long rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nlong rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"mutex.h\"\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/poison.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/mutex.h>\n\nvoid debug_mutex_remove_waiter(struct mutex *lock, struct mutex_waiter *waiter,\n\t\t\t struct task_struct *task)\n{\n\tDEBUG_LOCKS_WARN_ON(list_empty(&waiter->list));\n\tDEBUG_LOCKS_WARN_ON(waiter->task != task);\n\tDEBUG_LOCKS_WARN_ON(task->blocked_on != waiter);\n\ttask->blocked_on = NULL;\n\n\tINIT_LIST_HEAD(&waiter->list);\n\twaiter->task = NULL;\n}"
  },
  {
    "function_name": "debug_mutex_add_waiter",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/mutex-debug.c",
    "lines": "50-57",
    "snippet": "void debug_mutex_add_waiter(struct mutex *lock, struct mutex_waiter *waiter,\n\t\t\t    struct task_struct *task)\n{\n\tlockdep_assert_held(&lock->wait_lock);\n\n\t/* Mark the current thread as blocked on the lock: */\n\ttask->blocked_on = waiter;\n}",
    "includes": [
      "#include \"mutex.h\"",
      "#include <linux/debug_locks.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/sched.h>",
      "#include <linux/poison.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&lock->wait_lock"
          ],
          "line": 53
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"mutex.h\"\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/poison.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/mutex.h>\n\nvoid debug_mutex_add_waiter(struct mutex *lock, struct mutex_waiter *waiter,\n\t\t\t    struct task_struct *task)\n{\n\tlockdep_assert_held(&lock->wait_lock);\n\n\t/* Mark the current thread as blocked on the lock: */\n\ttask->blocked_on = waiter;\n}"
  },
  {
    "function_name": "debug_mutex_free_waiter",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/mutex-debug.c",
    "lines": "44-48",
    "snippet": "void debug_mutex_free_waiter(struct mutex_waiter *waiter)\n{\n\tDEBUG_LOCKS_WARN_ON(!list_empty(&waiter->list));\n\tmemset(waiter, MUTEX_DEBUG_FREE, sizeof(*waiter));\n}",
    "includes": [
      "#include \"mutex.h\"",
      "#include <linux/debug_locks.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/sched.h>",
      "#include <linux/poison.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "waiter",
            "MUTEX_DEBUG_FREE",
            "sizeof(*waiter)"
          ],
          "line": 47
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEBUG_LOCKS_WARN_ON",
          "args": [
            "!list_empty(&waiter->list)"
          ],
          "line": 46
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&waiter->list"
          ],
          "line": 46
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "41-44",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "long rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nlong rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"mutex.h\"\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/poison.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/mutex.h>\n\nvoid debug_mutex_free_waiter(struct mutex_waiter *waiter)\n{\n\tDEBUG_LOCKS_WARN_ON(!list_empty(&waiter->list));\n\tmemset(waiter, MUTEX_DEBUG_FREE, sizeof(*waiter));\n}"
  },
  {
    "function_name": "debug_mutex_wake_waiter",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/mutex-debug.c",
    "lines": "36-42",
    "snippet": "void debug_mutex_wake_waiter(struct mutex *lock, struct mutex_waiter *waiter)\n{\n\tlockdep_assert_held(&lock->wait_lock);\n\tDEBUG_LOCKS_WARN_ON(list_empty(&lock->wait_list));\n\tDEBUG_LOCKS_WARN_ON(waiter->magic != waiter);\n\tDEBUG_LOCKS_WARN_ON(list_empty(&waiter->list));\n}",
    "includes": [
      "#include \"mutex.h\"",
      "#include <linux/debug_locks.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/sched.h>",
      "#include <linux/poison.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "DEBUG_LOCKS_WARN_ON",
          "args": [
            "list_empty(&waiter->list)"
          ],
          "line": 41
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&waiter->list"
          ],
          "line": 41
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "41-44",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "long rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nlong rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DEBUG_LOCKS_WARN_ON",
          "args": [
            "waiter->magic != waiter"
          ],
          "line": 40
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEBUG_LOCKS_WARN_ON",
          "args": [
            "list_empty(&lock->wait_list)"
          ],
          "line": 39
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&lock->wait_lock"
          ],
          "line": 38
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"mutex.h\"\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/poison.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/mutex.h>\n\nvoid debug_mutex_wake_waiter(struct mutex *lock, struct mutex_waiter *waiter)\n{\n\tlockdep_assert_held(&lock->wait_lock);\n\tDEBUG_LOCKS_WARN_ON(list_empty(&lock->wait_list));\n\tDEBUG_LOCKS_WARN_ON(waiter->magic != waiter);\n\tDEBUG_LOCKS_WARN_ON(list_empty(&waiter->list));\n}"
  },
  {
    "function_name": "debug_mutex_lock_common",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/mutex-debug.c",
    "lines": "28-34",
    "snippet": "void debug_mutex_lock_common(struct mutex *lock, struct mutex_waiter *waiter)\n{\n\tmemset(waiter, MUTEX_DEBUG_INIT, sizeof(*waiter));\n\twaiter->magic = waiter;\n\tINIT_LIST_HEAD(&waiter->list);\n\twaiter->ww_ctx = MUTEX_POISON_WW_CTX;\n}",
    "includes": [
      "#include \"mutex.h\"",
      "#include <linux/debug_locks.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/sched.h>",
      "#include <linux/poison.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/mutex.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&waiter->list"
          ],
          "line": 32
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "waiter",
            "MUTEX_DEBUG_INIT",
            "sizeof(*waiter)"
          ],
          "line": 30
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"mutex.h\"\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/poison.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/mutex.h>\n\nvoid debug_mutex_lock_common(struct mutex *lock, struct mutex_waiter *waiter)\n{\n\tmemset(waiter, MUTEX_DEBUG_INIT, sizeof(*waiter));\n\twaiter->magic = waiter;\n\tINIT_LIST_HEAD(&waiter->list);\n\twaiter->ww_ctx = MUTEX_POISON_WW_CTX;\n}"
  }
]