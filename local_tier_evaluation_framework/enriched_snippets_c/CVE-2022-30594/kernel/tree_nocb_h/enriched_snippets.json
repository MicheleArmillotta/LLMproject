[
  {
    "function_name": "show_rcu_nocb_state",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_nocb.h",
    "lines": "1544-1546",
    "snippet": "static void show_rcu_nocb_state(struct rcu_data *rdp)\n{\n}",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "static void show_rcu_nocb_state(struct rcu_data *rdp)\n{\n}"
  },
  {
    "function_name": "rcu_spawn_nocb_kthreads",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_nocb.h",
    "lines": "1540-1542",
    "snippet": "static void __init rcu_spawn_nocb_kthreads(void)\n{\n}",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "static void __init rcu_spawn_nocb_kthreads(void)\n{\n}"
  },
  {
    "function_name": "rcu_spawn_cpu_nocb_kthread",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_nocb.h",
    "lines": "1536-1538",
    "snippet": "static void rcu_spawn_cpu_nocb_kthread(int cpu)\n{\n}",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "static void rcu_spawn_cpu_nocb_kthread(int cpu)\n{\n}"
  },
  {
    "function_name": "do_nocb_deferred_wakeup",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_nocb.h",
    "lines": "1531-1534",
    "snippet": "static bool do_nocb_deferred_wakeup(struct rcu_data *rdp)\n{\n\treturn false;\n}",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "static bool do_nocb_deferred_wakeup(struct rcu_data *rdp)\n{\n\treturn false;\n}"
  },
  {
    "function_name": "rcu_nocb_need_deferred_wakeup",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_nocb.h",
    "lines": "1526-1529",
    "snippet": "static int rcu_nocb_need_deferred_wakeup(struct rcu_data *rdp, int level)\n{\n\treturn false;\n}",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "static int rcu_nocb_need_deferred_wakeup(struct rcu_data *rdp, int level)\n{\n\treturn false;\n}"
  },
  {
    "function_name": "rcu_boot_init_nocb_percpu_data",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_nocb.h",
    "lines": "1522-1524",
    "snippet": "static void __init rcu_boot_init_nocb_percpu_data(struct rcu_data *rdp)\n{\n}",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "static void __init rcu_boot_init_nocb_percpu_data(struct rcu_data *rdp)\n{\n}"
  },
  {
    "function_name": "__call_rcu_nocb_wake",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_nocb.h",
    "lines": "1516-1520",
    "snippet": "static void __call_rcu_nocb_wake(struct rcu_data *rdp, bool was_empty,\n\t\t\t\t unsigned long flags)\n{\n\tWARN_ON_ONCE(1);  /* Should be dead code! */\n}",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "1"
          ],
          "line": 1519
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "static void __call_rcu_nocb_wake(struct rcu_data *rdp, bool was_empty,\n\t\t\t\t unsigned long flags)\n{\n\tWARN_ON_ONCE(1);  /* Should be dead code! */\n}"
  },
  {
    "function_name": "rcu_nocb_try_bypass",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_nocb.h",
    "lines": "1510-1514",
    "snippet": "static bool rcu_nocb_try_bypass(struct rcu_data *rdp, struct rcu_head *rhp,\n\t\t\t\tbool *was_alldone, unsigned long flags)\n{\n\treturn false;\n}",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "static bool rcu_nocb_try_bypass(struct rcu_data *rdp, struct rcu_head *rhp,\n\t\t\t\tbool *was_alldone, unsigned long flags)\n{\n\treturn false;\n}"
  },
  {
    "function_name": "rcu_nocb_flush_bypass",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_nocb.h",
    "lines": "1504-1508",
    "snippet": "static bool rcu_nocb_flush_bypass(struct rcu_data *rdp, struct rcu_head *rhp,\n\t\t\t\t  unsigned long j)\n{\n\treturn true;\n}",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "static bool rcu_nocb_flush_bypass(struct rcu_data *rdp, struct rcu_head *rhp,\n\t\t\t\t  unsigned long j)\n{\n\treturn true;\n}"
  },
  {
    "function_name": "rcu_init_one_nocb",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_nocb.h",
    "lines": "1500-1502",
    "snippet": "static void rcu_init_one_nocb(struct rcu_node *rnp)\n{\n}",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "static void rcu_init_one_nocb(struct rcu_node *rnp)\n{\n}"
  },
  {
    "function_name": "rcu_nocb_gp_get",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_nocb.h",
    "lines": "1495-1498",
    "snippet": "static struct swait_queue_head *rcu_nocb_gp_get(struct rcu_node *rnp)\n{\n\treturn NULL;\n}",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "static struct swait_queue_head *rcu_nocb_gp_get(struct rcu_node *rnp)\n{\n\treturn NULL;\n}"
  },
  {
    "function_name": "rcu_nocb_gp_cleanup",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_nocb.h",
    "lines": "1491-1493",
    "snippet": "static void rcu_nocb_gp_cleanup(struct swait_queue_head *sq)\n{\n}",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "static void rcu_nocb_gp_cleanup(struct swait_queue_head *sq)\n{\n}"
  },
  {
    "function_name": "rcu_lockdep_assert_cblist_protected",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_nocb.h",
    "lines": "1486-1489",
    "snippet": "static void rcu_lockdep_assert_cblist_protected(struct rcu_data *rdp)\n{\n\tlockdep_assert_irqs_disabled();\n}",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lockdep_assert_irqs_disabled",
          "args": [],
          "line": 1488
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "static void rcu_lockdep_assert_cblist_protected(struct rcu_data *rdp)\n{\n\tlockdep_assert_irqs_disabled();\n}"
  },
  {
    "function_name": "rcu_nocb_unlock_irqrestore",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_nocb.h",
    "lines": "1479-1483",
    "snippet": "static void rcu_nocb_unlock_irqrestore(struct rcu_data *rdp,\n\t\t\t\t       unsigned long flags)\n{\n\tlocal_irq_restore(flags);\n}",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 1482
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "static void rcu_nocb_unlock_irqrestore(struct rcu_data *rdp,\n\t\t\t\t       unsigned long flags)\n{\n\tlocal_irq_restore(flags);\n}"
  },
  {
    "function_name": "rcu_nocb_unlock",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_nocb.h",
    "lines": "1474-1476",
    "snippet": "static void rcu_nocb_unlock(struct rcu_data *rdp)\n{\n}",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "static void rcu_nocb_unlock(struct rcu_data *rdp)\n{\n}"
  },
  {
    "function_name": "rcu_nocb_lock",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_nocb.h",
    "lines": "1469-1471",
    "snippet": "static void rcu_nocb_lock(struct rcu_data *rdp)\n{\n}",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "static void rcu_nocb_lock(struct rcu_data *rdp)\n{\n}"
  },
  {
    "function_name": "rcu_current_is_nocb_kthread",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_nocb.h",
    "lines": "1463-1466",
    "snippet": "static inline bool rcu_current_is_nocb_kthread(struct rcu_data *rdp)\n{\n\treturn false;\n}",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "static inline bool rcu_current_is_nocb_kthread(struct rcu_data *rdp)\n{\n\treturn false;\n}"
  },
  {
    "function_name": "rcu_lockdep_is_held_nocb",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_nocb.h",
    "lines": "1458-1461",
    "snippet": "static inline int rcu_lockdep_is_held_nocb(struct rcu_data *rdp)\n{\n\treturn 0;\n}",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "static inline int rcu_lockdep_is_held_nocb(struct rcu_data *rdp)\n{\n\treturn 0;\n}"
  },
  {
    "function_name": "show_rcu_nocb_state",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_nocb.h",
    "lines": "1397-1454",
    "snippet": "static void show_rcu_nocb_state(struct rcu_data *rdp)\n{\n\tchar bufw[20];\n\tchar bufr[20];\n\tstruct rcu_data *nocb_next_rdp;\n\tstruct rcu_segcblist *rsclp = &rdp->cblist;\n\tbool waslocked;\n\tbool wassleep;\n\n\tif (rdp->nocb_gp_rdp == rdp)\n\t\tshow_rcu_nocb_gp_state(rdp);\n\n\tnocb_next_rdp = list_next_or_null_rcu(&rdp->nocb_gp_rdp->nocb_head_rdp,\n\t\t\t\t\t      &rdp->nocb_entry_rdp,\n\t\t\t\t\t      typeof(*rdp),\n\t\t\t\t\t      nocb_entry_rdp);\n\n\tsprintf(bufw, \"%ld\", rsclp->gp_seq[RCU_WAIT_TAIL]);\n\tsprintf(bufr, \"%ld\", rsclp->gp_seq[RCU_NEXT_READY_TAIL]);\n\tpr_info(\"   CB %d^%d->%d %c%c%c%c%c%c F%ld L%ld C%d %c%c%s%c%s%c%c q%ld %c CPU %d%s\\n\",\n\t\trdp->cpu, rdp->nocb_gp_rdp->cpu,\n\t\tnocb_next_rdp ? nocb_next_rdp->cpu : -1,\n\t\t\"kK\"[!!rdp->nocb_cb_kthread],\n\t\t\"bB\"[raw_spin_is_locked(&rdp->nocb_bypass_lock)],\n\t\t\"cC\"[!!atomic_read(&rdp->nocb_lock_contended)],\n\t\t\"lL\"[raw_spin_is_locked(&rdp->nocb_lock)],\n\t\t\"sS\"[!!rdp->nocb_cb_sleep],\n\t\t\".W\"[swait_active(&rdp->nocb_cb_wq)],\n\t\tjiffies - rdp->nocb_bypass_first,\n\t\tjiffies - rdp->nocb_nobypass_last,\n\t\trdp->nocb_nobypass_count,\n\t\t\".D\"[rcu_segcblist_ready_cbs(rsclp)],\n\t\t\".W\"[!rcu_segcblist_segempty(rsclp, RCU_WAIT_TAIL)],\n\t\trcu_segcblist_segempty(rsclp, RCU_WAIT_TAIL) ? \"\" : bufw,\n\t\t\".R\"[!rcu_segcblist_segempty(rsclp, RCU_NEXT_READY_TAIL)],\n\t\trcu_segcblist_segempty(rsclp, RCU_NEXT_READY_TAIL) ? \"\" : bufr,\n\t\t\".N\"[!rcu_segcblist_segempty(rsclp, RCU_NEXT_TAIL)],\n\t\t\".B\"[!!rcu_cblist_n_cbs(&rdp->nocb_bypass)],\n\t\trcu_segcblist_n_cbs(&rdp->cblist),\n\t\trdp->nocb_cb_kthread ? task_state_to_char(rdp->nocb_cb_kthread) : '.',\n\t\trdp->nocb_cb_kthread ? (int)task_cpu(rdp->nocb_gp_kthread) : -1,\n\t\tshow_rcu_should_be_on_cpu(rdp->nocb_cb_kthread));\n\n\t/* It is OK for GP kthreads to have GP state. */\n\tif (rdp->nocb_gp_rdp == rdp)\n\t\treturn;\n\n\twaslocked = raw_spin_is_locked(&rdp->nocb_gp_lock);\n\twassleep = swait_active(&rdp->nocb_gp_wq);\n\tif (!rdp->nocb_gp_sleep && !waslocked && !wassleep)\n\t\treturn;  /* Nothing untoward. */\n\n\tpr_info(\"   nocb GP activity on CB-only CPU!!! %c%c%c %c\\n\",\n\t\t\"lL\"[waslocked],\n\t\t\"dD\"[!!rdp->nocb_defer_wakeup],\n\t\t\"sS\"[!!rdp->nocb_gp_sleep],\n\t\t\".W\"[wassleep]);\n}",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"   nocb GP activity on CB-only CPU!!! %c%c%c %c\\n\"",
            "\"lL\"[waslocked]",
            "\"dD\"[!!rdp->nocb_defer_wakeup]",
            "\"sS\"[!!rdp->nocb_gp_sleep]",
            "\".W\"[wassleep]"
          ],
          "line": 1449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swait_active",
          "args": [
            "&rdp->nocb_gp_wq"
          ],
          "line": 1445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_is_locked",
          "args": [
            "&rdp->nocb_gp_lock"
          ],
          "line": 1444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"   CB %d^%d->%d %c%c%c%c%c%c F%ld L%ld C%d %c%c%s%c%s%c%c q%ld %c CPU %d%s\\n\"",
            "rdp->cpu",
            "rdp->nocb_gp_rdp->cpu",
            "nocb_next_rdp ? nocb_next_rdp->cpu : -1",
            "\"kK\"[!!rdp->nocb_cb_kthread]",
            "\"bB\"[raw_spin_is_locked(&rdp->nocb_bypass_lock)]",
            "\"cC\"[!!atomic_read(&rdp->nocb_lock_contended)]",
            "\"lL\"[raw_spin_is_locked(&rdp->nocb_lock)]",
            "\"sS\"[!!rdp->nocb_cb_sleep]",
            "\".W\"[swait_active(&rdp->nocb_cb_wq)]",
            "jiffies - rdp->nocb_bypass_first",
            "jiffies - rdp->nocb_nobypass_last",
            "rdp->nocb_nobypass_count",
            "\".D\"[rcu_segcblist_ready_cbs(rsclp)]",
            "\".W\"[!rcu_segcblist_segempty(rsclp, RCU_WAIT_TAIL)]",
            "rcu_segcblist_segempty(rsclp, RCU_WAIT_TAIL) ? \"\" : bufw",
            "\".R\"[!rcu_segcblist_segempty(rsclp, RCU_NEXT_READY_TAIL)]",
            "rcu_segcblist_segempty(rsclp, RCU_NEXT_READY_TAIL) ? \"\" : bufr",
            "\".N\"[!rcu_segcblist_segempty(rsclp, RCU_NEXT_TAIL)]",
            "\".B\"[!!rcu_cblist_n_cbs(&rdp->nocb_bypass)]",
            "rcu_segcblist_n_cbs(&rdp->cblist)",
            "rdp->nocb_cb_kthread ? task_state_to_char(rdp->nocb_cb_kthread) : '.'",
            "rdp->nocb_cb_kthread ? (int)task_cpu(rdp->nocb_gp_kthread) : -1",
            "show_rcu_should_be_on_cpu(rdp->nocb_cb_kthread)"
          ],
          "line": 1416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "show_rcu_should_be_on_cpu",
          "args": [
            "rdp->nocb_cb_kthread"
          ],
          "line": 1438
        },
        "resolved": true,
        "details": {
          "function_name": "show_rcu_should_be_on_cpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_nocb.h",
          "lines": "1363-1366",
          "snippet": "static char *show_rcu_should_be_on_cpu(struct task_struct *tsp)\n{\n\treturn \"\";\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static char *show_rcu_should_be_on_cpu(struct task_struct *tsp)\n{\n\treturn \"\";\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_cpu",
          "args": [
            "rdp->nocb_gp_kthread"
          ],
          "line": 1437
        },
        "resolved": true,
        "details": {
          "function_name": "ignore_task_cpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "7612-7633",
          "snippet": "static void ignore_task_cpu(void *data)\n{\n\tstruct trace_array *tr = data;\n\tstruct trace_pid_list *pid_list;\n\tstruct trace_pid_list *no_pid_list;\n\n\t/*\n\t * This function is called by on_each_cpu() while the\n\t * event_mutex is held.\n\t */\n\tpid_list = rcu_dereference_protected(tr->function_pids,\n\t\t\t\t\t     mutex_is_locked(&ftrace_lock));\n\tno_pid_list = rcu_dereference_protected(tr->function_no_pids,\n\t\t\t\t\t\tmutex_is_locked(&ftrace_lock));\n\n\tif (trace_ignore_this_task(pid_list, no_pid_list, current))\n\t\tthis_cpu_write(tr->array_buffer.data->ftrace_ignore_pid,\n\t\t\t       FTRACE_PID_IGNORE);\n\telse\n\t\tthis_cpu_write(tr->array_buffer.data->ftrace_ignore_pid,\n\t\t\t       current->pid);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ignore_task_cpu(void *data)\n{\n\tstruct trace_array *tr = data;\n\tstruct trace_pid_list *pid_list;\n\tstruct trace_pid_list *no_pid_list;\n\n\t/*\n\t * This function is called by on_each_cpu() while the\n\t * event_mutex is held.\n\t */\n\tpid_list = rcu_dereference_protected(tr->function_pids,\n\t\t\t\t\t     mutex_is_locked(&ftrace_lock));\n\tno_pid_list = rcu_dereference_protected(tr->function_no_pids,\n\t\t\t\t\t\tmutex_is_locked(&ftrace_lock));\n\n\tif (trace_ignore_this_task(pid_list, no_pid_list, current))\n\t\tthis_cpu_write(tr->array_buffer.data->ftrace_ignore_pid,\n\t\t\t       FTRACE_PID_IGNORE);\n\telse\n\t\tthis_cpu_write(tr->array_buffer.data->ftrace_ignore_pid,\n\t\t\t       current->pid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_state_to_char",
          "args": [
            "rdp->nocb_cb_kthread"
          ],
          "line": 1436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_segcblist_n_cbs",
          "args": [
            "&rdp->cblist"
          ],
          "line": 1435
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_n_cbs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "47-54",
          "snippet": "static inline long rcu_segcblist_n_cbs(struct rcu_segcblist *rsclp)\n{\n#ifdef CONFIG_RCU_NOCB_CPU\n\treturn atomic_long_read(&rsclp->len);\n#else\n\treturn READ_ONCE(rsclp->len);\n#endif\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "long rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nlong rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline long rcu_segcblist_n_cbs(struct rcu_segcblist *rsclp)\n{\n#ifdef CONFIG_RCU_NOCB_CPU\n\treturn atomic_long_read(&rsclp->len);\n#else\n\treturn READ_ONCE(rsclp->len);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_cblist_n_cbs",
          "args": [
            "&rdp->nocb_bypass"
          ],
          "line": 1434
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_cblist_n_cbs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "13-16",
          "snippet": "static inline long rcu_cblist_n_cbs(struct rcu_cblist *rclp)\n{\n\treturn READ_ONCE(rclp->len);\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void rcu_cblist_init(struct rcu_cblist *rclp);",
            "struct rcu_head *rcu_cblist_dequeue(struct rcu_cblist *rclp);",
            "void rcu_segcblist_extract_done_cbs(struct rcu_segcblist *rsclp,\n\t\t\t\t    struct rcu_cblist *rclp);",
            "void rcu_segcblist_extract_pend_cbs(struct rcu_segcblist *rsclp,\n\t\t\t\t    struct rcu_cblist *rclp);",
            "void rcu_segcblist_insert_count(struct rcu_segcblist *rsclp,\n\t\t\t\tstruct rcu_cblist *rclp);",
            "void rcu_segcblist_insert_done_cbs(struct rcu_segcblist *rsclp,\n\t\t\t\t   struct rcu_cblist *rclp);",
            "void rcu_segcblist_insert_pend_cbs(struct rcu_segcblist *rsclp,\n\t\t\t\t   struct rcu_cblist *rclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nvoid rcu_cblist_init(struct rcu_cblist *rclp);\nstruct rcu_head *rcu_cblist_dequeue(struct rcu_cblist *rclp);\nvoid rcu_segcblist_extract_done_cbs(struct rcu_segcblist *rsclp,\n\t\t\t\t    struct rcu_cblist *rclp);\nvoid rcu_segcblist_extract_pend_cbs(struct rcu_segcblist *rsclp,\n\t\t\t\t    struct rcu_cblist *rclp);\nvoid rcu_segcblist_insert_count(struct rcu_segcblist *rsclp,\n\t\t\t\tstruct rcu_cblist *rclp);\nvoid rcu_segcblist_insert_done_cbs(struct rcu_segcblist *rsclp,\n\t\t\t\t   struct rcu_cblist *rclp);\nvoid rcu_segcblist_insert_pend_cbs(struct rcu_segcblist *rsclp,\n\t\t\t\t   struct rcu_cblist *rclp);\n\nstatic inline long rcu_cblist_n_cbs(struct rcu_cblist *rclp)\n{\n\treturn READ_ONCE(rclp->len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_segcblist_segempty",
          "args": [
            "rsclp",
            "RCU_NEXT_TAIL"
          ],
          "line": 1433
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_segempty",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "119-124",
          "snippet": "static inline bool rcu_segcblist_segempty(struct rcu_segcblist *rsclp, int seg)\n{\n\tif (seg == RCU_DONE_TAIL)\n\t\treturn &rsclp->head == rsclp->tails[RCU_DONE_TAIL];\n\treturn rsclp->tails[seg - 1] == rsclp->tails[seg];\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "long rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nlong rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_segempty(struct rcu_segcblist *rsclp, int seg)\n{\n\tif (seg == RCU_DONE_TAIL)\n\t\treturn &rsclp->head == rsclp->tails[RCU_DONE_TAIL];\n\treturn rsclp->tails[seg - 1] == rsclp->tails[seg];\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_segcblist_ready_cbs",
          "args": [
            "rsclp"
          ],
          "line": 1428
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_ready_cbs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.c",
          "lines": "278-282",
          "snippet": "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp)\n{\n\treturn rcu_segcblist_is_enabled(rsclp) &&\n\t       &rsclp->head != READ_ONCE(rsclp->tails[RCU_DONE_TAIL]);\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/cpu.h>\n\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp)\n{\n\treturn rcu_segcblist_is_enabled(rsclp) &&\n\t       &rsclp->head != READ_ONCE(rsclp->tails[RCU_DONE_TAIL]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "swait_active",
          "args": [
            "&rdp->nocb_cb_wq"
          ],
          "line": 1424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_is_locked",
          "args": [
            "&rdp->nocb_lock"
          ],
          "line": 1422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&rdp->nocb_lock_contended"
          ],
          "line": 1421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_is_locked",
          "args": [
            "&rdp->nocb_bypass_lock"
          ],
          "line": 1420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "bufr",
            "\"%ld\"",
            "rsclp->gp_seq[RCU_NEXT_READY_TAIL]"
          ],
          "line": 1415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "bufw",
            "\"%ld\"",
            "rsclp->gp_seq[RCU_WAIT_TAIL]"
          ],
          "line": 1414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_next_or_null_rcu",
          "args": [
            "&rdp->nocb_gp_rdp->nocb_head_rdp",
            "&rdp->nocb_entry_rdp",
            "typeof(*rdp)",
            "nocb_entry_rdp"
          ],
          "line": 1409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "typeof",
          "args": [
            "*rdp"
          ],
          "line": 1411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "show_rcu_nocb_gp_state",
          "args": [
            "rdp"
          ],
          "line": 1407
        },
        "resolved": true,
        "details": {
          "function_name": "show_rcu_nocb_gp_state",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_nocb.h",
          "lines": "1373-1394",
          "snippet": "static void show_rcu_nocb_gp_state(struct rcu_data *rdp)\n{\n\tstruct rcu_node *rnp = rdp->mynode;\n\n\tpr_info(\"nocb GP %d %c%c%c%c%c %c[%c%c] %c%c:%ld rnp %d:%d %lu %c CPU %d%s\\n\",\n\t\trdp->cpu,\n\t\t\"kK\"[!!rdp->nocb_gp_kthread],\n\t\t\"lL\"[raw_spin_is_locked(&rdp->nocb_gp_lock)],\n\t\t\"dD\"[!!rdp->nocb_defer_wakeup],\n\t\t\"tT\"[timer_pending(&rdp->nocb_timer)],\n\t\t\"sS\"[!!rdp->nocb_gp_sleep],\n\t\t\".W\"[swait_active(&rdp->nocb_gp_wq)],\n\t\t\".W\"[swait_active(&rnp->nocb_gp_wq[0])],\n\t\t\".W\"[swait_active(&rnp->nocb_gp_wq[1])],\n\t\t\".B\"[!!rdp->nocb_gp_bypass],\n\t\t\".G\"[!!rdp->nocb_gp_gp],\n\t\t(long)rdp->nocb_gp_seq,\n\t\trnp->grplo, rnp->grphi, READ_ONCE(rdp->nocb_gp_loops),\n\t\trdp->nocb_gp_kthread ? task_state_to_char(rdp->nocb_gp_kthread) : '.',\n\t\trdp->nocb_cb_kthread ? (int)task_cpu(rdp->nocb_gp_kthread) : -1,\n\t\tshow_rcu_should_be_on_cpu(rdp->nocb_cb_kthread));\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static void show_rcu_nocb_gp_state(struct rcu_data *rdp)\n{\n\tstruct rcu_node *rnp = rdp->mynode;\n\n\tpr_info(\"nocb GP %d %c%c%c%c%c %c[%c%c] %c%c:%ld rnp %d:%d %lu %c CPU %d%s\\n\",\n\t\trdp->cpu,\n\t\t\"kK\"[!!rdp->nocb_gp_kthread],\n\t\t\"lL\"[raw_spin_is_locked(&rdp->nocb_gp_lock)],\n\t\t\"dD\"[!!rdp->nocb_defer_wakeup],\n\t\t\"tT\"[timer_pending(&rdp->nocb_timer)],\n\t\t\"sS\"[!!rdp->nocb_gp_sleep],\n\t\t\".W\"[swait_active(&rdp->nocb_gp_wq)],\n\t\t\".W\"[swait_active(&rnp->nocb_gp_wq[0])],\n\t\t\".W\"[swait_active(&rnp->nocb_gp_wq[1])],\n\t\t\".B\"[!!rdp->nocb_gp_bypass],\n\t\t\".G\"[!!rdp->nocb_gp_gp],\n\t\t(long)rdp->nocb_gp_seq,\n\t\trnp->grplo, rnp->grphi, READ_ONCE(rdp->nocb_gp_loops),\n\t\trdp->nocb_gp_kthread ? task_state_to_char(rdp->nocb_gp_kthread) : '.',\n\t\trdp->nocb_cb_kthread ? (int)task_cpu(rdp->nocb_gp_kthread) : -1,\n\t\tshow_rcu_should_be_on_cpu(rdp->nocb_cb_kthread));\n}"
        }
      }
    ],
    "contextual_snippet": "static void show_rcu_nocb_state(struct rcu_data *rdp)\n{\n\tchar bufw[20];\n\tchar bufr[20];\n\tstruct rcu_data *nocb_next_rdp;\n\tstruct rcu_segcblist *rsclp = &rdp->cblist;\n\tbool waslocked;\n\tbool wassleep;\n\n\tif (rdp->nocb_gp_rdp == rdp)\n\t\tshow_rcu_nocb_gp_state(rdp);\n\n\tnocb_next_rdp = list_next_or_null_rcu(&rdp->nocb_gp_rdp->nocb_head_rdp,\n\t\t\t\t\t      &rdp->nocb_entry_rdp,\n\t\t\t\t\t      typeof(*rdp),\n\t\t\t\t\t      nocb_entry_rdp);\n\n\tsprintf(bufw, \"%ld\", rsclp->gp_seq[RCU_WAIT_TAIL]);\n\tsprintf(bufr, \"%ld\", rsclp->gp_seq[RCU_NEXT_READY_TAIL]);\n\tpr_info(\"   CB %d^%d->%d %c%c%c%c%c%c F%ld L%ld C%d %c%c%s%c%s%c%c q%ld %c CPU %d%s\\n\",\n\t\trdp->cpu, rdp->nocb_gp_rdp->cpu,\n\t\tnocb_next_rdp ? nocb_next_rdp->cpu : -1,\n\t\t\"kK\"[!!rdp->nocb_cb_kthread],\n\t\t\"bB\"[raw_spin_is_locked(&rdp->nocb_bypass_lock)],\n\t\t\"cC\"[!!atomic_read(&rdp->nocb_lock_contended)],\n\t\t\"lL\"[raw_spin_is_locked(&rdp->nocb_lock)],\n\t\t\"sS\"[!!rdp->nocb_cb_sleep],\n\t\t\".W\"[swait_active(&rdp->nocb_cb_wq)],\n\t\tjiffies - rdp->nocb_bypass_first,\n\t\tjiffies - rdp->nocb_nobypass_last,\n\t\trdp->nocb_nobypass_count,\n\t\t\".D\"[rcu_segcblist_ready_cbs(rsclp)],\n\t\t\".W\"[!rcu_segcblist_segempty(rsclp, RCU_WAIT_TAIL)],\n\t\trcu_segcblist_segempty(rsclp, RCU_WAIT_TAIL) ? \"\" : bufw,\n\t\t\".R\"[!rcu_segcblist_segempty(rsclp, RCU_NEXT_READY_TAIL)],\n\t\trcu_segcblist_segempty(rsclp, RCU_NEXT_READY_TAIL) ? \"\" : bufr,\n\t\t\".N\"[!rcu_segcblist_segempty(rsclp, RCU_NEXT_TAIL)],\n\t\t\".B\"[!!rcu_cblist_n_cbs(&rdp->nocb_bypass)],\n\t\trcu_segcblist_n_cbs(&rdp->cblist),\n\t\trdp->nocb_cb_kthread ? task_state_to_char(rdp->nocb_cb_kthread) : '.',\n\t\trdp->nocb_cb_kthread ? (int)task_cpu(rdp->nocb_gp_kthread) : -1,\n\t\tshow_rcu_should_be_on_cpu(rdp->nocb_cb_kthread));\n\n\t/* It is OK for GP kthreads to have GP state. */\n\tif (rdp->nocb_gp_rdp == rdp)\n\t\treturn;\n\n\twaslocked = raw_spin_is_locked(&rdp->nocb_gp_lock);\n\twassleep = swait_active(&rdp->nocb_gp_wq);\n\tif (!rdp->nocb_gp_sleep && !waslocked && !wassleep)\n\t\treturn;  /* Nothing untoward. */\n\n\tpr_info(\"   nocb GP activity on CB-only CPU!!! %c%c%c %c\\n\",\n\t\t\"lL\"[waslocked],\n\t\t\"dD\"[!!rdp->nocb_defer_wakeup],\n\t\t\"sS\"[!!rdp->nocb_gp_sleep],\n\t\t\".W\"[wassleep]);\n}"
  },
  {
    "function_name": "show_rcu_nocb_gp_state",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_nocb.h",
    "lines": "1373-1394",
    "snippet": "static void show_rcu_nocb_gp_state(struct rcu_data *rdp)\n{\n\tstruct rcu_node *rnp = rdp->mynode;\n\n\tpr_info(\"nocb GP %d %c%c%c%c%c %c[%c%c] %c%c:%ld rnp %d:%d %lu %c CPU %d%s\\n\",\n\t\trdp->cpu,\n\t\t\"kK\"[!!rdp->nocb_gp_kthread],\n\t\t\"lL\"[raw_spin_is_locked(&rdp->nocb_gp_lock)],\n\t\t\"dD\"[!!rdp->nocb_defer_wakeup],\n\t\t\"tT\"[timer_pending(&rdp->nocb_timer)],\n\t\t\"sS\"[!!rdp->nocb_gp_sleep],\n\t\t\".W\"[swait_active(&rdp->nocb_gp_wq)],\n\t\t\".W\"[swait_active(&rnp->nocb_gp_wq[0])],\n\t\t\".W\"[swait_active(&rnp->nocb_gp_wq[1])],\n\t\t\".B\"[!!rdp->nocb_gp_bypass],\n\t\t\".G\"[!!rdp->nocb_gp_gp],\n\t\t(long)rdp->nocb_gp_seq,\n\t\trnp->grplo, rnp->grphi, READ_ONCE(rdp->nocb_gp_loops),\n\t\trdp->nocb_gp_kthread ? task_state_to_char(rdp->nocb_gp_kthread) : '.',\n\t\trdp->nocb_cb_kthread ? (int)task_cpu(rdp->nocb_gp_kthread) : -1,\n\t\tshow_rcu_should_be_on_cpu(rdp->nocb_cb_kthread));\n}",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"nocb GP %d %c%c%c%c%c %c[%c%c] %c%c:%ld rnp %d:%d %lu %c CPU %d%s\\n\"",
            "rdp->cpu",
            "\"kK\"[!!rdp->nocb_gp_kthread]",
            "\"lL\"[raw_spin_is_locked(&rdp->nocb_gp_lock)]",
            "\"dD\"[!!rdp->nocb_defer_wakeup]",
            "\"tT\"[timer_pending(&rdp->nocb_timer)]",
            "\"sS\"[!!rdp->nocb_gp_sleep]",
            "\".W\"[swait_active(&rdp->nocb_gp_wq)]",
            "\".W\"[swait_active(&rnp->nocb_gp_wq[0])]",
            "\".W\"[swait_active(&rnp->nocb_gp_wq[1])]",
            "\".B\"[!!rdp->nocb_gp_bypass]",
            "\".G\"[!!rdp->nocb_gp_gp]",
            "(long)rdp->nocb_gp_seq",
            "rnp->grplo",
            "rnp->grphi",
            "READ_ONCE(rdp->nocb_gp_loops)",
            "rdp->nocb_gp_kthread ? task_state_to_char(rdp->nocb_gp_kthread) : '.'",
            "rdp->nocb_cb_kthread ? (int)task_cpu(rdp->nocb_gp_kthread) : -1",
            "show_rcu_should_be_on_cpu(rdp->nocb_cb_kthread)"
          ],
          "line": 1377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "show_rcu_should_be_on_cpu",
          "args": [
            "rdp->nocb_cb_kthread"
          ],
          "line": 1393
        },
        "resolved": true,
        "details": {
          "function_name": "show_rcu_should_be_on_cpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_nocb.h",
          "lines": "1363-1366",
          "snippet": "static char *show_rcu_should_be_on_cpu(struct task_struct *tsp)\n{\n\treturn \"\";\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static char *show_rcu_should_be_on_cpu(struct task_struct *tsp)\n{\n\treturn \"\";\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_cpu",
          "args": [
            "rdp->nocb_gp_kthread"
          ],
          "line": 1392
        },
        "resolved": true,
        "details": {
          "function_name": "ignore_task_cpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "7612-7633",
          "snippet": "static void ignore_task_cpu(void *data)\n{\n\tstruct trace_array *tr = data;\n\tstruct trace_pid_list *pid_list;\n\tstruct trace_pid_list *no_pid_list;\n\n\t/*\n\t * This function is called by on_each_cpu() while the\n\t * event_mutex is held.\n\t */\n\tpid_list = rcu_dereference_protected(tr->function_pids,\n\t\t\t\t\t     mutex_is_locked(&ftrace_lock));\n\tno_pid_list = rcu_dereference_protected(tr->function_no_pids,\n\t\t\t\t\t\tmutex_is_locked(&ftrace_lock));\n\n\tif (trace_ignore_this_task(pid_list, no_pid_list, current))\n\t\tthis_cpu_write(tr->array_buffer.data->ftrace_ignore_pid,\n\t\t\t       FTRACE_PID_IGNORE);\n\telse\n\t\tthis_cpu_write(tr->array_buffer.data->ftrace_ignore_pid,\n\t\t\t       current->pid);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ignore_task_cpu(void *data)\n{\n\tstruct trace_array *tr = data;\n\tstruct trace_pid_list *pid_list;\n\tstruct trace_pid_list *no_pid_list;\n\n\t/*\n\t * This function is called by on_each_cpu() while the\n\t * event_mutex is held.\n\t */\n\tpid_list = rcu_dereference_protected(tr->function_pids,\n\t\t\t\t\t     mutex_is_locked(&ftrace_lock));\n\tno_pid_list = rcu_dereference_protected(tr->function_no_pids,\n\t\t\t\t\t\tmutex_is_locked(&ftrace_lock));\n\n\tif (trace_ignore_this_task(pid_list, no_pid_list, current))\n\t\tthis_cpu_write(tr->array_buffer.data->ftrace_ignore_pid,\n\t\t\t       FTRACE_PID_IGNORE);\n\telse\n\t\tthis_cpu_write(tr->array_buffer.data->ftrace_ignore_pid,\n\t\t\t       current->pid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_state_to_char",
          "args": [
            "rdp->nocb_gp_kthread"
          ],
          "line": 1391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rdp->nocb_gp_loops"
          ],
          "line": 1390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swait_active",
          "args": [
            "&rnp->nocb_gp_wq[1]"
          ],
          "line": 1386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swait_active",
          "args": [
            "&rnp->nocb_gp_wq[0]"
          ],
          "line": 1385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swait_active",
          "args": [
            "&rdp->nocb_gp_wq"
          ],
          "line": 1384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timer_pending",
          "args": [
            "&rdp->nocb_timer"
          ],
          "line": 1382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_is_locked",
          "args": [
            "&rdp->nocb_gp_lock"
          ],
          "line": 1380
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "static void show_rcu_nocb_gp_state(struct rcu_data *rdp)\n{\n\tstruct rcu_node *rnp = rdp->mynode;\n\n\tpr_info(\"nocb GP %d %c%c%c%c%c %c[%c%c] %c%c:%ld rnp %d:%d %lu %c CPU %d%s\\n\",\n\t\trdp->cpu,\n\t\t\"kK\"[!!rdp->nocb_gp_kthread],\n\t\t\"lL\"[raw_spin_is_locked(&rdp->nocb_gp_lock)],\n\t\t\"dD\"[!!rdp->nocb_defer_wakeup],\n\t\t\"tT\"[timer_pending(&rdp->nocb_timer)],\n\t\t\"sS\"[!!rdp->nocb_gp_sleep],\n\t\t\".W\"[swait_active(&rdp->nocb_gp_wq)],\n\t\t\".W\"[swait_active(&rnp->nocb_gp_wq[0])],\n\t\t\".W\"[swait_active(&rnp->nocb_gp_wq[1])],\n\t\t\".B\"[!!rdp->nocb_gp_bypass],\n\t\t\".G\"[!!rdp->nocb_gp_gp],\n\t\t(long)rdp->nocb_gp_seq,\n\t\trnp->grplo, rnp->grphi, READ_ONCE(rdp->nocb_gp_loops),\n\t\trdp->nocb_gp_kthread ? task_state_to_char(rdp->nocb_gp_kthread) : '.',\n\t\trdp->nocb_cb_kthread ? (int)task_cpu(rdp->nocb_gp_kthread) : -1,\n\t\tshow_rcu_should_be_on_cpu(rdp->nocb_cb_kthread));\n}"
  },
  {
    "function_name": "show_rcu_should_be_on_cpu",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_nocb.h",
    "lines": "1363-1366",
    "snippet": "static char *show_rcu_should_be_on_cpu(struct task_struct *tsp)\n{\n\treturn \"\";\n}",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "static char *show_rcu_should_be_on_cpu(struct task_struct *tsp)\n{\n\treturn \"\";\n}"
  },
  {
    "function_name": "show_rcu_should_be_on_cpu",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_nocb.h",
    "lines": "1358-1361",
    "snippet": "static char *show_rcu_should_be_on_cpu(struct task_struct *tsp)\n{\n\treturn tsp && task_is_running(tsp) && !tsp->on_cpu ? \"!\" : \"\";\n}",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "task_is_running",
          "args": [
            "tsp"
          ],
          "line": 1360
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "static char *show_rcu_should_be_on_cpu(struct task_struct *tsp)\n{\n\treturn tsp && task_is_running(tsp) && !tsp->on_cpu ? \"!\" : \"\";\n}"
  },
  {
    "function_name": "rcu_bind_current_to_nocb",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_nocb.h",
    "lines": "1349-1353",
    "snippet": "void rcu_bind_current_to_nocb(void)\n{\n\tif (cpumask_available(rcu_nocb_mask) && cpumask_weight(rcu_nocb_mask))\n\t\tWARN_ON(sched_setaffinity(current->pid, rcu_nocb_mask));\n}",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "sched_setaffinity(current->pid, rcu_nocb_mask)"
          ],
          "line": 1352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sched_setaffinity",
          "args": [
            "current->pid",
            "rcu_nocb_mask"
          ],
          "line": 1352
        },
        "resolved": true,
        "details": {
          "function_name": "rcutorture_sched_setaffinity",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "483-490",
          "snippet": "long rcutorture_sched_setaffinity(pid_t pid, const struct cpumask *in_mask)\n{\n\tint ret;\n\n\tret = sched_setaffinity(pid, in_mask);\n\tWARN_ONCE(ret, \"%s: sched_setaffinity() returned %d\\n\", __func__, ret);\n\treturn ret;\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nlong rcutorture_sched_setaffinity(pid_t pid, const struct cpumask *in_mask)\n{\n\tint ret;\n\n\tret = sched_setaffinity(pid, in_mask);\n\tWARN_ONCE(ret, \"%s: sched_setaffinity() returned %d\\n\", __func__, ret);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_weight",
          "args": [
            "rcu_nocb_mask"
          ],
          "line": 1351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_available",
          "args": [
            "rcu_nocb_mask"
          ],
          "line": 1351
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "void rcu_bind_current_to_nocb(void)\n{\n\tif (cpumask_available(rcu_nocb_mask) && cpumask_weight(rcu_nocb_mask))\n\t\tWARN_ON(sched_setaffinity(current->pid, rcu_nocb_mask));\n}"
  },
  {
    "function_name": "rcu_organize_nocb_kthreads",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_nocb.h",
    "lines": "1291-1343",
    "snippet": "static void __init rcu_organize_nocb_kthreads(void)\n{\n\tint cpu;\n\tbool firsttime = true;\n\tbool gotnocbs = false;\n\tbool gotnocbscbs = true;\n\tint ls = rcu_nocb_gp_stride;\n\tint nl = 0;  /* Next GP kthread. */\n\tstruct rcu_data *rdp;\n\tstruct rcu_data *rdp_gp = NULL;  /* Suppress misguided gcc warn. */\n\n\tif (!cpumask_available(rcu_nocb_mask))\n\t\treturn;\n\tif (ls == -1) {\n\t\tls = nr_cpu_ids / int_sqrt(nr_cpu_ids);\n\t\trcu_nocb_gp_stride = ls;\n\t}\n\n\t/*\n\t * Each pass through this loop sets up one rcu_data structure.\n\t * Should the corresponding CPU come online in the future, then\n\t * we will spawn the needed set of rcu_nocb_kthread() kthreads.\n\t */\n\tfor_each_possible_cpu(cpu) {\n\t\trdp = per_cpu_ptr(&rcu_data, cpu);\n\t\tif (rdp->cpu >= nl) {\n\t\t\t/* New GP kthread, set up for CBs & next GP. */\n\t\t\tgotnocbs = true;\n\t\t\tnl = DIV_ROUND_UP(rdp->cpu + 1, ls) * ls;\n\t\t\trdp_gp = rdp;\n\t\t\tINIT_LIST_HEAD(&rdp->nocb_head_rdp);\n\t\t\tif (dump_tree) {\n\t\t\t\tif (!firsttime)\n\t\t\t\t\tpr_cont(\"%s\\n\", gotnocbscbs\n\t\t\t\t\t\t\t? \"\" : \" (self only)\");\n\t\t\t\tgotnocbscbs = false;\n\t\t\t\tfirsttime = false;\n\t\t\t\tpr_alert(\"%s: No-CB GP kthread CPU %d:\",\n\t\t\t\t\t __func__, cpu);\n\t\t\t}\n\t\t} else {\n\t\t\t/* Another CB kthread, link to previous GP kthread. */\n\t\t\tgotnocbscbs = true;\n\t\t\tif (dump_tree)\n\t\t\t\tpr_cont(\" %d\", cpu);\n\t\t}\n\t\trdp->nocb_gp_rdp = rdp_gp;\n\t\tif (cpumask_test_cpu(cpu, rcu_nocb_mask))\n\t\t\tlist_add_tail(&rdp->nocb_entry_rdp, &rdp_gp->nocb_head_rdp);\n\t}\n\tif (gotnocbs && dump_tree)\n\t\tpr_cont(\"%s\\n\", gotnocbscbs ? \"\" : \" (self only)\");\n}",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\"%s\\n\"",
            "gotnocbscbs ? \"\" : \" (self only)\""
          ],
          "line": 1342
        },
        "resolved": true,
        "details": {
          "function_name": "pr_cont_work",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "4723-4735",
          "snippet": "static void pr_cont_work(bool comma, struct work_struct *work)\n{\n\tif (work->func == wq_barrier_func) {\n\t\tstruct wq_barrier *barr;\n\n\t\tbarr = container_of(work, struct wq_barrier, work);\n\n\t\tpr_cont(\"%s BAR(%d)\", comma ? \",\" : \"\",\n\t\t\ttask_pid_nr(barr->task));\n\t} else {\n\t\tpr_cont(\"%s %ps\", comma ? \",\" : \"\", work->func);\n\t}\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void pr_cont_work(bool comma, struct work_struct *work)\n{\n\tif (work->func == wq_barrier_func) {\n\t\tstruct wq_barrier *barr;\n\n\t\tbarr = container_of(work, struct wq_barrier, work);\n\n\t\tpr_cont(\"%s BAR(%d)\", comma ? \",\" : \"\",\n\t\t\ttask_pid_nr(barr->task));\n\t} else {\n\t\tpr_cont(\"%s %ps\", comma ? \",\" : \"\", work->func);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&rdp->nocb_entry_rdp",
            "&rdp_gp->nocb_head_rdp"
          ],
          "line": 1339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_test_cpu",
          "args": [
            "cpu",
            "rcu_nocb_mask"
          ],
          "line": 1338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_alert",
          "args": [
            "\"%s: No-CB GP kthread CPU %d:\"",
            "__func__",
            "cpu"
          ],
          "line": 1328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&rdp->nocb_head_rdp"
          ],
          "line": 1321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DIV_ROUND_UP",
          "args": [
            "rdp->cpu + 1",
            "ls"
          ],
          "line": 1319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "&rcu_data",
            "cpu"
          ],
          "line": 1315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "int_sqrt",
          "args": [
            "nr_cpu_ids"
          ],
          "line": 1305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_available",
          "args": [
            "rcu_nocb_mask"
          ],
          "line": 1302
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "static void __init rcu_organize_nocb_kthreads(void)\n{\n\tint cpu;\n\tbool firsttime = true;\n\tbool gotnocbs = false;\n\tbool gotnocbscbs = true;\n\tint ls = rcu_nocb_gp_stride;\n\tint nl = 0;  /* Next GP kthread. */\n\tstruct rcu_data *rdp;\n\tstruct rcu_data *rdp_gp = NULL;  /* Suppress misguided gcc warn. */\n\n\tif (!cpumask_available(rcu_nocb_mask))\n\t\treturn;\n\tif (ls == -1) {\n\t\tls = nr_cpu_ids / int_sqrt(nr_cpu_ids);\n\t\trcu_nocb_gp_stride = ls;\n\t}\n\n\t/*\n\t * Each pass through this loop sets up one rcu_data structure.\n\t * Should the corresponding CPU come online in the future, then\n\t * we will spawn the needed set of rcu_nocb_kthread() kthreads.\n\t */\n\tfor_each_possible_cpu(cpu) {\n\t\trdp = per_cpu_ptr(&rcu_data, cpu);\n\t\tif (rdp->cpu >= nl) {\n\t\t\t/* New GP kthread, set up for CBs & next GP. */\n\t\t\tgotnocbs = true;\n\t\t\tnl = DIV_ROUND_UP(rdp->cpu + 1, ls) * ls;\n\t\t\trdp_gp = rdp;\n\t\t\tINIT_LIST_HEAD(&rdp->nocb_head_rdp);\n\t\t\tif (dump_tree) {\n\t\t\t\tif (!firsttime)\n\t\t\t\t\tpr_cont(\"%s\\n\", gotnocbscbs\n\t\t\t\t\t\t\t? \"\" : \" (self only)\");\n\t\t\t\tgotnocbscbs = false;\n\t\t\t\tfirsttime = false;\n\t\t\t\tpr_alert(\"%s: No-CB GP kthread CPU %d:\",\n\t\t\t\t\t __func__, cpu);\n\t\t\t}\n\t\t} else {\n\t\t\t/* Another CB kthread, link to previous GP kthread. */\n\t\t\tgotnocbscbs = true;\n\t\t\tif (dump_tree)\n\t\t\t\tpr_cont(\" %d\", cpu);\n\t\t}\n\t\trdp->nocb_gp_rdp = rdp_gp;\n\t\tif (cpumask_test_cpu(cpu, rcu_nocb_mask))\n\t\t\tlist_add_tail(&rdp->nocb_entry_rdp, &rdp_gp->nocb_head_rdp);\n\t}\n\tif (gotnocbs && dump_tree)\n\t\tpr_cont(\"%s\\n\", gotnocbscbs ? \"\" : \" (self only)\");\n}"
  },
  {
    "function_name": "rcu_spawn_nocb_kthreads",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_nocb.h",
    "lines": "1274-1282",
    "snippet": "static void __init rcu_spawn_nocb_kthreads(void)\n{\n\tint cpu;\n\n\tif (rcu_nocb_is_setup) {\n\t\tfor_each_online_cpu(cpu)\n\t\t\trcu_spawn_cpu_nocb_kthread(cpu);\n\t}\n}",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "static void __init rcu_spawn_nocb_kthreads(void)\n{\n\tint cpu;\n\n\tif (rcu_nocb_is_setup) {\n\t\tfor_each_online_cpu(cpu)\n\t\t\trcu_spawn_cpu_nocb_kthread(cpu);\n\t}\n}"
  },
  {
    "function_name": "rcu_spawn_cpu_nocb_kthread",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_nocb.h",
    "lines": "1236-1266",
    "snippet": "static void rcu_spawn_cpu_nocb_kthread(int cpu)\n{\n\tstruct rcu_data *rdp = per_cpu_ptr(&rcu_data, cpu);\n\tstruct rcu_data *rdp_gp;\n\tstruct task_struct *t;\n\n\tif (!rcu_scheduler_fully_active || !rcu_nocb_is_setup)\n\t\treturn;\n\n\t/* If there already is an rcuo kthread, then nothing to do. */\n\tif (rdp->nocb_cb_kthread)\n\t\treturn;\n\n\t/* If we didn't spawn the GP kthread first, reorganize! */\n\trdp_gp = rdp->nocb_gp_rdp;\n\tif (!rdp_gp->nocb_gp_kthread) {\n\t\tt = kthread_run(rcu_nocb_gp_kthread, rdp_gp,\n\t\t\t\t\"rcuog/%d\", rdp_gp->cpu);\n\t\tif (WARN_ONCE(IS_ERR(t), \"%s: Could not start rcuo GP kthread, OOM is now expected behavior\\n\", __func__))\n\t\t\treturn;\n\t\tWRITE_ONCE(rdp_gp->nocb_gp_kthread, t);\n\t}\n\n\t/* Spawn the kthread for this CPU. */\n\tt = kthread_run(rcu_nocb_cb_kthread, rdp,\n\t\t\t\"rcuo%c/%d\", rcu_state.abbr, cpu);\n\tif (WARN_ONCE(IS_ERR(t), \"%s: Could not start rcuo CB kthread, OOM is now expected behavior\\n\", __func__))\n\t\treturn;\n\tWRITE_ONCE(rdp->nocb_cb_kthread, t);\n\tWRITE_ONCE(rdp->nocb_gp_kthread, rdp_gp->nocb_gp_kthread);\n}",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "rdp->nocb_gp_kthread",
            "rdp_gp->nocb_gp_kthread"
          ],
          "line": 1265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "rdp->nocb_cb_kthread",
            "t"
          ],
          "line": 1264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ONCE",
          "args": [
            "IS_ERR(t)",
            "\"%s: Could not start rcuo CB kthread, OOM is now expected behavior\\n\"",
            "__func__"
          ],
          "line": 1262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "t"
          ],
          "line": 1262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kthread_run",
          "args": [
            "rcu_nocb_cb_kthread",
            "rdp",
            "\"rcuo%c/%d\"",
            "rcu_state.abbr",
            "cpu"
          ],
          "line": 1260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "rdp_gp->nocb_gp_kthread",
            "t"
          ],
          "line": 1256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ONCE",
          "args": [
            "IS_ERR(t)",
            "\"%s: Could not start rcuo GP kthread, OOM is now expected behavior\\n\"",
            "__func__"
          ],
          "line": 1254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "t"
          ],
          "line": 1254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kthread_run",
          "args": [
            "rcu_nocb_gp_kthread",
            "rdp_gp",
            "\"rcuog/%d\"",
            "rdp_gp->cpu"
          ],
          "line": 1252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "&rcu_data",
            "cpu"
          ],
          "line": 1238
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "static void rcu_spawn_cpu_nocb_kthread(int cpu)\n{\n\tstruct rcu_data *rdp = per_cpu_ptr(&rcu_data, cpu);\n\tstruct rcu_data *rdp_gp;\n\tstruct task_struct *t;\n\n\tif (!rcu_scheduler_fully_active || !rcu_nocb_is_setup)\n\t\treturn;\n\n\t/* If there already is an rcuo kthread, then nothing to do. */\n\tif (rdp->nocb_cb_kthread)\n\t\treturn;\n\n\t/* If we didn't spawn the GP kthread first, reorganize! */\n\trdp_gp = rdp->nocb_gp_rdp;\n\tif (!rdp_gp->nocb_gp_kthread) {\n\t\tt = kthread_run(rcu_nocb_gp_kthread, rdp_gp,\n\t\t\t\t\"rcuog/%d\", rdp_gp->cpu);\n\t\tif (WARN_ONCE(IS_ERR(t), \"%s: Could not start rcuo GP kthread, OOM is now expected behavior\\n\", __func__))\n\t\t\treturn;\n\t\tWRITE_ONCE(rdp_gp->nocb_gp_kthread, t);\n\t}\n\n\t/* Spawn the kthread for this CPU. */\n\tt = kthread_run(rcu_nocb_cb_kthread, rdp,\n\t\t\t\"rcuo%c/%d\", rcu_state.abbr, cpu);\n\tif (WARN_ONCE(IS_ERR(t), \"%s: Could not start rcuo CB kthread, OOM is now expected behavior\\n\", __func__))\n\t\treturn;\n\tWRITE_ONCE(rdp->nocb_cb_kthread, t);\n\tWRITE_ONCE(rdp->nocb_gp_kthread, rdp_gp->nocb_gp_kthread);\n}"
  },
  {
    "function_name": "rcu_boot_init_nocb_percpu_data",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_nocb.h",
    "lines": "1219-1229",
    "snippet": "static void __init rcu_boot_init_nocb_percpu_data(struct rcu_data *rdp)\n{\n\tinit_swait_queue_head(&rdp->nocb_cb_wq);\n\tinit_swait_queue_head(&rdp->nocb_gp_wq);\n\tinit_swait_queue_head(&rdp->nocb_state_wq);\n\traw_spin_lock_init(&rdp->nocb_lock);\n\traw_spin_lock_init(&rdp->nocb_bypass_lock);\n\traw_spin_lock_init(&rdp->nocb_gp_lock);\n\ttimer_setup(&rdp->nocb_timer, do_nocb_deferred_wakeup_timer, 0);\n\trcu_cblist_init(&rdp->nocb_bypass);\n}",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_cblist_init",
          "args": [
            "&rdp->nocb_bypass"
          ],
          "line": 1228
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_cblist_init",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.c",
          "lines": "18-23",
          "snippet": "void rcu_cblist_init(struct rcu_cblist *rclp)\n{\n\trclp->head = NULL;\n\trclp->tail = &rclp->head;\n\trclp->len = 0;\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/cpu.h>\n\nvoid rcu_cblist_init(struct rcu_cblist *rclp)\n{\n\trclp->head = NULL;\n\trclp->tail = &rclp->head;\n\trclp->len = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "timer_setup",
          "args": [
            "&rdp->nocb_timer",
            "do_nocb_deferred_wakeup_timer",
            "0"
          ],
          "line": 1227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_init",
          "args": [
            "&rdp->nocb_gp_lock"
          ],
          "line": 1226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_init",
          "args": [
            "&rdp->nocb_bypass_lock"
          ],
          "line": 1225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_init",
          "args": [
            "&rdp->nocb_lock"
          ],
          "line": 1224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_swait_queue_head",
          "args": [
            "&rdp->nocb_state_wq"
          ],
          "line": 1223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_swait_queue_head",
          "args": [
            "&rdp->nocb_gp_wq"
          ],
          "line": 1222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_swait_queue_head",
          "args": [
            "&rdp->nocb_cb_wq"
          ],
          "line": 1221
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "static void __init rcu_boot_init_nocb_percpu_data(struct rcu_data *rdp)\n{\n\tinit_swait_queue_head(&rdp->nocb_cb_wq);\n\tinit_swait_queue_head(&rdp->nocb_gp_wq);\n\tinit_swait_queue_head(&rdp->nocb_state_wq);\n\traw_spin_lock_init(&rdp->nocb_lock);\n\traw_spin_lock_init(&rdp->nocb_bypass_lock);\n\traw_spin_lock_init(&rdp->nocb_gp_lock);\n\ttimer_setup(&rdp->nocb_timer, do_nocb_deferred_wakeup_timer, 0);\n\trcu_cblist_init(&rdp->nocb_bypass);\n}"
  },
  {
    "function_name": "rcu_init_nohz",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_nocb.h",
    "lines": "1165-1216",
    "snippet": "void __init rcu_init_nohz(void)\n{\n\tint cpu;\n\tbool need_rcu_nocb_mask = false;\n\tstruct rcu_data *rdp;\n\n#if defined(CONFIG_NO_HZ_FULL)\n\tif (tick_nohz_full_running && cpumask_weight(tick_nohz_full_mask))\n\t\tneed_rcu_nocb_mask = true;\n#endif /* #if defined(CONFIG_NO_HZ_FULL) */\n\n\tif (need_rcu_nocb_mask) {\n\t\tif (!cpumask_available(rcu_nocb_mask)) {\n\t\t\tif (!zalloc_cpumask_var(&rcu_nocb_mask, GFP_KERNEL)) {\n\t\t\t\tpr_info(\"rcu_nocb_mask allocation failed, callback offloading disabled.\\n\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\trcu_nocb_is_setup = true;\n\t}\n\n\tif (!rcu_nocb_is_setup)\n\t\treturn;\n\n#if defined(CONFIG_NO_HZ_FULL)\n\tif (tick_nohz_full_running)\n\t\tcpumask_or(rcu_nocb_mask, rcu_nocb_mask, tick_nohz_full_mask);\n#endif /* #if defined(CONFIG_NO_HZ_FULL) */\n\n\tif (!cpumask_subset(rcu_nocb_mask, cpu_possible_mask)) {\n\t\tpr_info(\"\\tNote: kernel parameter 'rcu_nocbs=', 'nohz_full', or 'isolcpus=' contains nonexistent CPUs.\\n\");\n\t\tcpumask_and(rcu_nocb_mask, cpu_possible_mask,\n\t\t\t    rcu_nocb_mask);\n\t}\n\tif (cpumask_empty(rcu_nocb_mask))\n\t\tpr_info(\"\\tOffload RCU callbacks from CPUs: (none).\\n\");\n\telse\n\t\tpr_info(\"\\tOffload RCU callbacks from CPUs: %*pbl.\\n\",\n\t\t\tcpumask_pr_args(rcu_nocb_mask));\n\tif (rcu_nocb_poll)\n\t\tpr_info(\"\\tPoll for callbacks from no-CBs CPUs.\\n\");\n\n\tfor_each_cpu(cpu, rcu_nocb_mask) {\n\t\trdp = per_cpu_ptr(&rcu_data, cpu);\n\t\tif (rcu_segcblist_empty(&rdp->cblist))\n\t\t\trcu_segcblist_init(&rdp->cblist);\n\t\trcu_segcblist_offload(&rdp->cblist, true);\n\t\trcu_segcblist_set_flags(&rdp->cblist, SEGCBLIST_KTHREAD_CB | SEGCBLIST_KTHREAD_GP);\n\t\trcu_segcblist_clear_flags(&rdp->cblist, SEGCBLIST_RCU_CORE);\n\t}\n\trcu_organize_nocb_kthreads();\n}",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_organize_nocb_kthreads",
          "args": [],
          "line": 1215
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_organize_nocb_kthreads",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_nocb.h",
          "lines": "1291-1343",
          "snippet": "static void __init rcu_organize_nocb_kthreads(void)\n{\n\tint cpu;\n\tbool firsttime = true;\n\tbool gotnocbs = false;\n\tbool gotnocbscbs = true;\n\tint ls = rcu_nocb_gp_stride;\n\tint nl = 0;  /* Next GP kthread. */\n\tstruct rcu_data *rdp;\n\tstruct rcu_data *rdp_gp = NULL;  /* Suppress misguided gcc warn. */\n\n\tif (!cpumask_available(rcu_nocb_mask))\n\t\treturn;\n\tif (ls == -1) {\n\t\tls = nr_cpu_ids / int_sqrt(nr_cpu_ids);\n\t\trcu_nocb_gp_stride = ls;\n\t}\n\n\t/*\n\t * Each pass through this loop sets up one rcu_data structure.\n\t * Should the corresponding CPU come online in the future, then\n\t * we will spawn the needed set of rcu_nocb_kthread() kthreads.\n\t */\n\tfor_each_possible_cpu(cpu) {\n\t\trdp = per_cpu_ptr(&rcu_data, cpu);\n\t\tif (rdp->cpu >= nl) {\n\t\t\t/* New GP kthread, set up for CBs & next GP. */\n\t\t\tgotnocbs = true;\n\t\t\tnl = DIV_ROUND_UP(rdp->cpu + 1, ls) * ls;\n\t\t\trdp_gp = rdp;\n\t\t\tINIT_LIST_HEAD(&rdp->nocb_head_rdp);\n\t\t\tif (dump_tree) {\n\t\t\t\tif (!firsttime)\n\t\t\t\t\tpr_cont(\"%s\\n\", gotnocbscbs\n\t\t\t\t\t\t\t? \"\" : \" (self only)\");\n\t\t\t\tgotnocbscbs = false;\n\t\t\t\tfirsttime = false;\n\t\t\t\tpr_alert(\"%s: No-CB GP kthread CPU %d:\",\n\t\t\t\t\t __func__, cpu);\n\t\t\t}\n\t\t} else {\n\t\t\t/* Another CB kthread, link to previous GP kthread. */\n\t\t\tgotnocbscbs = true;\n\t\t\tif (dump_tree)\n\t\t\t\tpr_cont(\" %d\", cpu);\n\t\t}\n\t\trdp->nocb_gp_rdp = rdp_gp;\n\t\tif (cpumask_test_cpu(cpu, rcu_nocb_mask))\n\t\t\tlist_add_tail(&rdp->nocb_entry_rdp, &rdp_gp->nocb_head_rdp);\n\t}\n\tif (gotnocbs && dump_tree)\n\t\tpr_cont(\"%s\\n\", gotnocbscbs ? \"\" : \" (self only)\");\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static void __init rcu_organize_nocb_kthreads(void)\n{\n\tint cpu;\n\tbool firsttime = true;\n\tbool gotnocbs = false;\n\tbool gotnocbscbs = true;\n\tint ls = rcu_nocb_gp_stride;\n\tint nl = 0;  /* Next GP kthread. */\n\tstruct rcu_data *rdp;\n\tstruct rcu_data *rdp_gp = NULL;  /* Suppress misguided gcc warn. */\n\n\tif (!cpumask_available(rcu_nocb_mask))\n\t\treturn;\n\tif (ls == -1) {\n\t\tls = nr_cpu_ids / int_sqrt(nr_cpu_ids);\n\t\trcu_nocb_gp_stride = ls;\n\t}\n\n\t/*\n\t * Each pass through this loop sets up one rcu_data structure.\n\t * Should the corresponding CPU come online in the future, then\n\t * we will spawn the needed set of rcu_nocb_kthread() kthreads.\n\t */\n\tfor_each_possible_cpu(cpu) {\n\t\trdp = per_cpu_ptr(&rcu_data, cpu);\n\t\tif (rdp->cpu >= nl) {\n\t\t\t/* New GP kthread, set up for CBs & next GP. */\n\t\t\tgotnocbs = true;\n\t\t\tnl = DIV_ROUND_UP(rdp->cpu + 1, ls) * ls;\n\t\t\trdp_gp = rdp;\n\t\t\tINIT_LIST_HEAD(&rdp->nocb_head_rdp);\n\t\t\tif (dump_tree) {\n\t\t\t\tif (!firsttime)\n\t\t\t\t\tpr_cont(\"%s\\n\", gotnocbscbs\n\t\t\t\t\t\t\t? \"\" : \" (self only)\");\n\t\t\t\tgotnocbscbs = false;\n\t\t\t\tfirsttime = false;\n\t\t\t\tpr_alert(\"%s: No-CB GP kthread CPU %d:\",\n\t\t\t\t\t __func__, cpu);\n\t\t\t}\n\t\t} else {\n\t\t\t/* Another CB kthread, link to previous GP kthread. */\n\t\t\tgotnocbscbs = true;\n\t\t\tif (dump_tree)\n\t\t\t\tpr_cont(\" %d\", cpu);\n\t\t}\n\t\trdp->nocb_gp_rdp = rdp_gp;\n\t\tif (cpumask_test_cpu(cpu, rcu_nocb_mask))\n\t\t\tlist_add_tail(&rdp->nocb_entry_rdp, &rdp_gp->nocb_head_rdp);\n\t}\n\tif (gotnocbs && dump_tree)\n\t\tpr_cont(\"%s\\n\", gotnocbscbs ? \"\" : \" (self only)\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_segcblist_clear_flags",
          "args": [
            "&rdp->cblist",
            "SEGCBLIST_RCU_CORE"
          ],
          "line": 1213
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_clear_flags",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "62-66",
          "snippet": "static inline void rcu_segcblist_clear_flags(struct rcu_segcblist *rsclp,\n\t\t\t\t\t     int flags)\n{\n\trsclp->flags &= ~flags;\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "long rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nlong rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline void rcu_segcblist_clear_flags(struct rcu_segcblist *rsclp,\n\t\t\t\t\t     int flags)\n{\n\trsclp->flags &= ~flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_segcblist_set_flags",
          "args": [
            "&rdp->cblist",
            "SEGCBLIST_KTHREAD_CB | SEGCBLIST_KTHREAD_GP"
          ],
          "line": 1212
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_set_flags",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "56-60",
          "snippet": "static inline void rcu_segcblist_set_flags(struct rcu_segcblist *rsclp,\n\t\t\t\t\t   int flags)\n{\n\trsclp->flags |= flags;\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "long rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nlong rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline void rcu_segcblist_set_flags(struct rcu_segcblist *rsclp,\n\t\t\t\t\t   int flags)\n{\n\trsclp->flags |= flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_segcblist_offload",
          "args": [
            "&rdp->cblist",
            "true"
          ],
          "line": 1211
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_offload",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.c",
          "lines": "266-272",
          "snippet": "void rcu_segcblist_offload(struct rcu_segcblist *rsclp, bool offload)\n{\n\tif (offload)\n\t\trcu_segcblist_set_flags(rsclp, SEGCBLIST_LOCKING | SEGCBLIST_OFFLOADED);\n\telse\n\t\trcu_segcblist_clear_flags(rsclp, SEGCBLIST_OFFLOADED);\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/cpu.h>\n\nvoid rcu_segcblist_offload(struct rcu_segcblist *rsclp, bool offload)\n{\n\tif (offload)\n\t\trcu_segcblist_set_flags(rsclp, SEGCBLIST_LOCKING | SEGCBLIST_OFFLOADED);\n\telse\n\t\trcu_segcblist_clear_flags(rsclp, SEGCBLIST_OFFLOADED);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_segcblist_init",
          "args": [
            "&rdp->cblist"
          ],
          "line": 1210
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_init",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.c",
          "lines": "237-250",
          "snippet": "void rcu_segcblist_init(struct rcu_segcblist *rsclp)\n{\n\tint i;\n\n\tBUILD_BUG_ON(RCU_NEXT_TAIL + 1 != ARRAY_SIZE(rsclp->gp_seq));\n\tBUILD_BUG_ON(ARRAY_SIZE(rsclp->tails) != ARRAY_SIZE(rsclp->gp_seq));\n\trsclp->head = NULL;\n\tfor (i = 0; i < RCU_CBLIST_NSEGS; i++) {\n\t\trsclp->tails[i] = &rsclp->head;\n\t\trcu_segcblist_set_seglen(rsclp, i, 0);\n\t}\n\trcu_segcblist_set_len(rsclp, 0);\n\trcu_segcblist_set_flags(rsclp, SEGCBLIST_ENABLED);\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/cpu.h>\n\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp)\n{\n\tint i;\n\n\tBUILD_BUG_ON(RCU_NEXT_TAIL + 1 != ARRAY_SIZE(rsclp->gp_seq));\n\tBUILD_BUG_ON(ARRAY_SIZE(rsclp->tails) != ARRAY_SIZE(rsclp->gp_seq));\n\trsclp->head = NULL;\n\tfor (i = 0; i < RCU_CBLIST_NSEGS; i++) {\n\t\trsclp->tails[i] = &rsclp->head;\n\t\trcu_segcblist_set_seglen(rsclp, i, 0);\n\t}\n\trcu_segcblist_set_len(rsclp, 0);\n\trcu_segcblist_set_flags(rsclp, SEGCBLIST_ENABLED);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_segcblist_empty",
          "args": [
            "&rdp->cblist"
          ],
          "line": 1209
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "41-44",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "long rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nlong rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "&rcu_data",
            "cpu"
          ],
          "line": 1208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_cpu",
          "args": [
            "cpu",
            "rcu_nocb_mask"
          ],
          "line": 1207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"\\tPoll for callbacks from no-CBs CPUs.\\n\""
          ],
          "line": 1205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"\\tOffload RCU callbacks from CPUs: %*pbl.\\n\"",
            "cpumask_pr_args(rcu_nocb_mask)"
          ],
          "line": 1202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_pr_args",
          "args": [
            "rcu_nocb_mask"
          ],
          "line": 1203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"\\tOffload RCU callbacks from CPUs: (none).\\n\""
          ],
          "line": 1200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_empty",
          "args": [
            "rcu_nocb_mask"
          ],
          "line": 1199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_and",
          "args": [
            "rcu_nocb_mask",
            "cpu_possible_mask",
            "rcu_nocb_mask"
          ],
          "line": 1196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"\\tNote: kernel parameter 'rcu_nocbs=', 'nohz_full', or 'isolcpus=' contains nonexistent CPUs.\\n\""
          ],
          "line": 1195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_subset",
          "args": [
            "rcu_nocb_mask",
            "cpu_possible_mask"
          ],
          "line": 1194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_or",
          "args": [
            "rcu_nocb_mask",
            "rcu_nocb_mask",
            "tick_nohz_full_mask"
          ],
          "line": 1191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"rcu_nocb_mask allocation failed, callback offloading disabled.\\n\""
          ],
          "line": 1179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zalloc_cpumask_var",
          "args": [
            "&rcu_nocb_mask",
            "GFP_KERNEL"
          ],
          "line": 1178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_available",
          "args": [
            "rcu_nocb_mask"
          ],
          "line": 1177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_weight",
          "args": [
            "tick_nohz_full_mask"
          ],
          "line": 1172
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "void __init rcu_init_nohz(void)\n{\n\tint cpu;\n\tbool need_rcu_nocb_mask = false;\n\tstruct rcu_data *rdp;\n\n#if defined(CONFIG_NO_HZ_FULL)\n\tif (tick_nohz_full_running && cpumask_weight(tick_nohz_full_mask))\n\t\tneed_rcu_nocb_mask = true;\n#endif /* #if defined(CONFIG_NO_HZ_FULL) */\n\n\tif (need_rcu_nocb_mask) {\n\t\tif (!cpumask_available(rcu_nocb_mask)) {\n\t\t\tif (!zalloc_cpumask_var(&rcu_nocb_mask, GFP_KERNEL)) {\n\t\t\t\tpr_info(\"rcu_nocb_mask allocation failed, callback offloading disabled.\\n\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\trcu_nocb_is_setup = true;\n\t}\n\n\tif (!rcu_nocb_is_setup)\n\t\treturn;\n\n#if defined(CONFIG_NO_HZ_FULL)\n\tif (tick_nohz_full_running)\n\t\tcpumask_or(rcu_nocb_mask, rcu_nocb_mask, tick_nohz_full_mask);\n#endif /* #if defined(CONFIG_NO_HZ_FULL) */\n\n\tif (!cpumask_subset(rcu_nocb_mask, cpu_possible_mask)) {\n\t\tpr_info(\"\\tNote: kernel parameter 'rcu_nocbs=', 'nohz_full', or 'isolcpus=' contains nonexistent CPUs.\\n\");\n\t\tcpumask_and(rcu_nocb_mask, cpu_possible_mask,\n\t\t\t    rcu_nocb_mask);\n\t}\n\tif (cpumask_empty(rcu_nocb_mask))\n\t\tpr_info(\"\\tOffload RCU callbacks from CPUs: (none).\\n\");\n\telse\n\t\tpr_info(\"\\tOffload RCU callbacks from CPUs: %*pbl.\\n\",\n\t\t\tcpumask_pr_args(rcu_nocb_mask));\n\tif (rcu_nocb_poll)\n\t\tpr_info(\"\\tPoll for callbacks from no-CBs CPUs.\\n\");\n\n\tfor_each_cpu(cpu, rcu_nocb_mask) {\n\t\trdp = per_cpu_ptr(&rcu_data, cpu);\n\t\tif (rcu_segcblist_empty(&rdp->cblist))\n\t\t\trcu_segcblist_init(&rdp->cblist);\n\t\trcu_segcblist_offload(&rdp->cblist, true);\n\t\trcu_segcblist_set_flags(&rdp->cblist, SEGCBLIST_KTHREAD_CB | SEGCBLIST_KTHREAD_GP);\n\t\trcu_segcblist_clear_flags(&rdp->cblist, SEGCBLIST_RCU_CORE);\n\t}\n\trcu_organize_nocb_kthreads();\n}"
  },
  {
    "function_name": "rcu_nocb_cpu_offload",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_nocb.h",
    "lines": "1141-1162",
    "snippet": "int rcu_nocb_cpu_offload(int cpu)\n{\n\tstruct rcu_data *rdp = per_cpu_ptr(&rcu_data, cpu);\n\tint ret = 0;\n\n\tmutex_lock(&rcu_state.barrier_mutex);\n\tcpus_read_lock();\n\tif (!rcu_rdp_is_offloaded(rdp)) {\n\t\tif (cpu_online(cpu)) {\n\t\t\tret = work_on_cpu(cpu, rcu_nocb_rdp_offload, rdp);\n\t\t\tif (!ret)\n\t\t\t\tcpumask_set_cpu(cpu, rcu_nocb_mask);\n\t\t} else {\n\t\t\tpr_info(\"NOCB: Can't CB-offload an offline CPU\\n\");\n\t\t\tret = -EINVAL;\n\t\t}\n\t}\n\tcpus_read_unlock();\n\tmutex_unlock(&rcu_state.barrier_mutex);\n\n\treturn ret;\n}",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&rcu_state.barrier_mutex"
          ],
          "line": 1159
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpus_read_unlock",
          "args": [],
          "line": 1158
        },
        "resolved": true,
        "details": {
          "function_name": "cpus_read_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "319-322",
          "snippet": "void cpus_read_unlock(void)\n{\n\tpercpu_up_read(&cpu_hotplug_lock);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nvoid cpus_read_unlock(void)\n{\n\tpercpu_up_read(&cpu_hotplug_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"NOCB: Can't CB-offload an offline CPU\\n\""
          ],
          "line": 1154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_set_cpu",
          "args": [
            "cpu",
            "rcu_nocb_mask"
          ],
          "line": 1152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "work_on_cpu",
          "args": [
            "cpu",
            "rcu_nocb_rdp_offload",
            "rdp"
          ],
          "line": 1150
        },
        "resolved": true,
        "details": {
          "function_name": "work_on_cpu_safe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "5220-5229",
          "snippet": "long work_on_cpu_safe(int cpu, long (*fn)(void *), void *arg)\n{\n\tlong ret = -ENODEV;\n\n\tcpus_read_lock();\n\tif (cpu_online(cpu))\n\t\tret = work_on_cpu(cpu, fn, arg);\n\tcpus_read_unlock();\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nlong work_on_cpu_safe(int cpu, long (*fn)(void *), void *arg)\n{\n\tlong ret = -ENODEV;\n\n\tcpus_read_lock();\n\tif (cpu_online(cpu))\n\t\tret = work_on_cpu(cpu, fn, arg);\n\tcpus_read_unlock();\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_online",
          "args": [
            "cpu"
          ],
          "line": 1149
        },
        "resolved": true,
        "details": {
          "function_name": "init_cpu_online",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "2616-2619",
          "snippet": "void init_cpu_online(const struct cpumask *src)\n{\n\tcpumask_copy(&__cpu_online_mask, src);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct cpumask __cpu_online_mask"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstruct cpumask __cpu_online_mask;\n\nvoid init_cpu_online(const struct cpumask *src)\n{\n\tcpumask_copy(&__cpu_online_mask, src);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_rdp_is_offloaded",
          "args": [
            "rdp"
          ],
          "line": 1148
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_rdp_is_offloaded",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "16-38",
          "snippet": "static bool rcu_rdp_is_offloaded(struct rcu_data *rdp)\n{\n\t/*\n\t * In order to read the offloaded state of an rdp in a safe\n\t * and stable way and prevent from its value to be changed\n\t * under us, we must either hold the barrier mutex, the cpu\n\t * hotplug lock (read or write) or the nocb lock. Local\n\t * non-preemptible reads are also safe. NOCB kthreads and\n\t * timers have their own means of synchronization against the\n\t * offloaded state updaters.\n\t */\n\tRCU_LOCKDEP_WARN(\n\t\t!(lockdep_is_held(&rcu_state.barrier_mutex) ||\n\t\t  (IS_ENABLED(CONFIG_HOTPLUG_CPU) && lockdep_is_cpus_held()) ||\n\t\t  rcu_lockdep_is_held_nocb(rdp) ||\n\t\t  (rdp == this_cpu_ptr(&rcu_data) &&\n\t\t   !(IS_ENABLED(CONFIG_PREEMPT_COUNT) && preemptible())) ||\n\t\t  rcu_current_is_nocb_kthread(rdp)),\n\t\t\"Unsafe read of RCU_NOCB offloaded state\"\n\t);\n\n\treturn rcu_segcblist_is_offloaded(&rdp->cblist);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nstatic bool rcu_rdp_is_offloaded(struct rcu_data *rdp)\n{\n\t/*\n\t * In order to read the offloaded state of an rdp in a safe\n\t * and stable way and prevent from its value to be changed\n\t * under us, we must either hold the barrier mutex, the cpu\n\t * hotplug lock (read or write) or the nocb lock. Local\n\t * non-preemptible reads are also safe. NOCB kthreads and\n\t * timers have their own means of synchronization against the\n\t * offloaded state updaters.\n\t */\n\tRCU_LOCKDEP_WARN(\n\t\t!(lockdep_is_held(&rcu_state.barrier_mutex) ||\n\t\t  (IS_ENABLED(CONFIG_HOTPLUG_CPU) && lockdep_is_cpus_held()) ||\n\t\t  rcu_lockdep_is_held_nocb(rdp) ||\n\t\t  (rdp == this_cpu_ptr(&rcu_data) &&\n\t\t   !(IS_ENABLED(CONFIG_PREEMPT_COUNT) && preemptible())) ||\n\t\t  rcu_current_is_nocb_kthread(rdp)),\n\t\t\"Unsafe read of RCU_NOCB offloaded state\"\n\t);\n\n\treturn rcu_segcblist_is_offloaded(&rdp->cblist);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpus_read_lock",
          "args": [],
          "line": 1147
        },
        "resolved": true,
        "details": {
          "function_name": "cpus_read_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "307-310",
          "snippet": "void cpus_read_lock(void)\n{\n\tpercpu_down_read(&cpu_hotplug_lock);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nvoid cpus_read_lock(void)\n{\n\tpercpu_down_read(&cpu_hotplug_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&rcu_state.barrier_mutex"
          ],
          "line": 1146
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "&rcu_data",
            "cpu"
          ],
          "line": 1143
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "int rcu_nocb_cpu_offload(int cpu)\n{\n\tstruct rcu_data *rdp = per_cpu_ptr(&rcu_data, cpu);\n\tint ret = 0;\n\n\tmutex_lock(&rcu_state.barrier_mutex);\n\tcpus_read_lock();\n\tif (!rcu_rdp_is_offloaded(rdp)) {\n\t\tif (cpu_online(cpu)) {\n\t\t\tret = work_on_cpu(cpu, rcu_nocb_rdp_offload, rdp);\n\t\t\tif (!ret)\n\t\t\t\tcpumask_set_cpu(cpu, rcu_nocb_mask);\n\t\t} else {\n\t\t\tpr_info(\"NOCB: Can't CB-offload an offline CPU\\n\");\n\t\t\tret = -EINVAL;\n\t\t}\n\t}\n\tcpus_read_unlock();\n\tmutex_unlock(&rcu_state.barrier_mutex);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "rcu_nocb_rdp_offload",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_nocb.h",
    "lines": "1076-1139",
    "snippet": "static long rcu_nocb_rdp_offload(void *arg)\n{\n\tstruct rcu_data *rdp = arg;\n\tstruct rcu_segcblist *cblist = &rdp->cblist;\n\tunsigned long flags;\n\tint ret;\n\n\tWARN_ON_ONCE(rdp->cpu != raw_smp_processor_id());\n\t/*\n\t * For now we only support re-offload, ie: the rdp must have been\n\t * offloaded on boot first.\n\t */\n\tif (!rdp->nocb_gp_rdp)\n\t\treturn -EINVAL;\n\n\tpr_info(\"Offloading %d\\n\", rdp->cpu);\n\n\t/*\n\t * Cause future nocb_gp_wait() invocations to iterate over\n\t * structure, resetting ->nocb_gp_sleep and waking up the related\n\t * \"rcuog\".  Since nocb_gp_wait() in turn locks ->nocb_gp_lock\n\t * before setting ->nocb_gp_sleep again, we are guaranteed to\n\t * iterate this newly added structure before \"rcuog\" goes to\n\t * sleep again.\n\t */\n\tlist_add_tail_rcu(&rdp->nocb_entry_rdp, &rdp->nocb_gp_rdp->nocb_head_rdp);\n\n\t/*\n\t * Can't use rcu_nocb_lock_irqsave() before SEGCBLIST_LOCKING\n\t * is set.\n\t */\n\traw_spin_lock_irqsave(&rdp->nocb_lock, flags);\n\n\t/*\n\t * We didn't take the nocb lock while working on the\n\t * rdp->cblist with SEGCBLIST_LOCKING cleared (pure softirq/rcuc mode).\n\t * Every modifications that have been done previously on\n\t * rdp->cblist must be visible remotely by the nocb kthreads\n\t * upon wake up after reading the cblist flags.\n\t *\n\t * The layout against nocb_lock enforces that ordering:\n\t *\n\t *  __rcu_nocb_rdp_offload()   nocb_cb_wait()/nocb_gp_wait()\n\t * -------------------------   ----------------------------\n\t *      WRITE callbacks           rcu_nocb_lock()\n\t *      rcu_nocb_lock()           READ flags\n\t *      WRITE flags               READ callbacks\n\t *      rcu_nocb_unlock()         rcu_nocb_unlock()\n\t */\n\tret = rdp_offload_toggle(rdp, true, flags);\n\tswait_event_exclusive(rdp->nocb_state_wq,\n\t\t\t      rcu_segcblist_test_flags(cblist, SEGCBLIST_KTHREAD_CB) &&\n\t\t\t      rcu_segcblist_test_flags(cblist, SEGCBLIST_KTHREAD_GP));\n\n\t/*\n\t * All kthreads are ready to work, we can finally relieve rcu_core() and\n\t * enable nocb bypass.\n\t */\n\trcu_nocb_lock_irqsave(rdp, flags);\n\trcu_segcblist_clear_flags(cblist, SEGCBLIST_RCU_CORE);\n\trcu_nocb_unlock_irqrestore(rdp, flags);\n\n\treturn ret;\n}",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_nocb_unlock_irqrestore",
          "args": [
            "rdp",
            "flags"
          ],
          "line": 1136
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_nocb_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_nocb.h",
          "lines": "1479-1483",
          "snippet": "static void rcu_nocb_unlock_irqrestore(struct rcu_data *rdp,\n\t\t\t\t       unsigned long flags)\n{\n\tlocal_irq_restore(flags);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static void rcu_nocb_unlock_irqrestore(struct rcu_data *rdp,\n\t\t\t\t       unsigned long flags)\n{\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_segcblist_clear_flags",
          "args": [
            "cblist",
            "SEGCBLIST_RCU_CORE"
          ],
          "line": 1135
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_clear_flags",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "62-66",
          "snippet": "static inline void rcu_segcblist_clear_flags(struct rcu_segcblist *rsclp,\n\t\t\t\t\t     int flags)\n{\n\trsclp->flags &= ~flags;\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "long rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nlong rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline void rcu_segcblist_clear_flags(struct rcu_segcblist *rsclp,\n\t\t\t\t\t     int flags)\n{\n\trsclp->flags &= ~flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_nocb_lock_irqsave",
          "args": [
            "rdp",
            "flags"
          ],
          "line": 1134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swait_event_exclusive",
          "args": [
            "rdp->nocb_state_wq",
            "rcu_segcblist_test_flags(cblist, SEGCBLIST_KTHREAD_CB) &&\n\t\t\t      rcu_segcblist_test_flags(cblist, SEGCBLIST_KTHREAD_GP)"
          ],
          "line": 1126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_segcblist_test_flags",
          "args": [
            "cblist",
            "SEGCBLIST_KTHREAD_GP"
          ],
          "line": 1128
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_test_flags",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "68-72",
          "snippet": "static inline bool rcu_segcblist_test_flags(struct rcu_segcblist *rsclp,\n\t\t\t\t\t    int flags)\n{\n\treturn READ_ONCE(rsclp->flags) & flags;\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "long rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nlong rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_test_flags(struct rcu_segcblist *rsclp,\n\t\t\t\t\t    int flags)\n{\n\treturn READ_ONCE(rsclp->flags) & flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rdp_offload_toggle",
          "args": [
            "rdp",
            "true",
            "flags"
          ],
          "line": 1125
        },
        "resolved": true,
        "details": {
          "function_name": "rdp_offload_toggle",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_nocb.h",
          "lines": "959-990",
          "snippet": "static int rdp_offload_toggle(struct rcu_data *rdp,\n\t\t\t       bool offload, unsigned long flags)\n\t__releases(rdp->nocb_lock)\n{\n\tstruct rcu_segcblist *cblist = &rdp->cblist;\n\tstruct rcu_data *rdp_gp = rdp->nocb_gp_rdp;\n\tbool wake_gp = false;\n\n\trcu_segcblist_offload(cblist, offload);\n\n\tif (rdp->nocb_cb_sleep)\n\t\trdp->nocb_cb_sleep = false;\n\trcu_nocb_unlock_irqrestore(rdp, flags);\n\n\t/*\n\t * Ignore former value of nocb_cb_sleep and force wake up as it could\n\t * have been spuriously set to false already.\n\t */\n\tswake_up_one(&rdp->nocb_cb_wq);\n\n\traw_spin_lock_irqsave(&rdp_gp->nocb_gp_lock, flags);\n\tif (rdp_gp->nocb_gp_sleep) {\n\t\trdp_gp->nocb_gp_sleep = false;\n\t\twake_gp = true;\n\t}\n\traw_spin_unlock_irqrestore(&rdp_gp->nocb_gp_lock, flags);\n\n\tif (wake_gp)\n\t\twake_up_process(rdp_gp->nocb_gp_kthread);\n\n\treturn 0;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static int rdp_offload_toggle(struct rcu_data *rdp,\n\t\t\t       bool offload, unsigned long flags)\n\t__releases(rdp->nocb_lock)\n{\n\tstruct rcu_segcblist *cblist = &rdp->cblist;\n\tstruct rcu_data *rdp_gp = rdp->nocb_gp_rdp;\n\tbool wake_gp = false;\n\n\trcu_segcblist_offload(cblist, offload);\n\n\tif (rdp->nocb_cb_sleep)\n\t\trdp->nocb_cb_sleep = false;\n\trcu_nocb_unlock_irqrestore(rdp, flags);\n\n\t/*\n\t * Ignore former value of nocb_cb_sleep and force wake up as it could\n\t * have been spuriously set to false already.\n\t */\n\tswake_up_one(&rdp->nocb_cb_wq);\n\n\traw_spin_lock_irqsave(&rdp_gp->nocb_gp_lock, flags);\n\tif (rdp_gp->nocb_gp_sleep) {\n\t\trdp_gp->nocb_gp_sleep = false;\n\t\twake_gp = true;\n\t}\n\traw_spin_unlock_irqrestore(&rdp_gp->nocb_gp_lock, flags);\n\n\tif (wake_gp)\n\t\twake_up_process(rdp_gp->nocb_gp_kthread);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave",
          "args": [
            "&rdp->nocb_lock",
            "flags"
          ],
          "line": 1107
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "383-393",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add_tail_rcu",
          "args": [
            "&rdp->nocb_entry_rdp",
            "&rdp->nocb_gp_rdp->nocb_head_rdp"
          ],
          "line": 1101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Offloading %d\\n\"",
            "rdp->cpu"
          ],
          "line": 1091
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "rdp->cpu != raw_smp_processor_id()"
          ],
          "line": 1083
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_smp_processor_id",
          "args": [],
          "line": 1083
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "static long rcu_nocb_rdp_offload(void *arg)\n{\n\tstruct rcu_data *rdp = arg;\n\tstruct rcu_segcblist *cblist = &rdp->cblist;\n\tunsigned long flags;\n\tint ret;\n\n\tWARN_ON_ONCE(rdp->cpu != raw_smp_processor_id());\n\t/*\n\t * For now we only support re-offload, ie: the rdp must have been\n\t * offloaded on boot first.\n\t */\n\tif (!rdp->nocb_gp_rdp)\n\t\treturn -EINVAL;\n\n\tpr_info(\"Offloading %d\\n\", rdp->cpu);\n\n\t/*\n\t * Cause future nocb_gp_wait() invocations to iterate over\n\t * structure, resetting ->nocb_gp_sleep and waking up the related\n\t * \"rcuog\".  Since nocb_gp_wait() in turn locks ->nocb_gp_lock\n\t * before setting ->nocb_gp_sleep again, we are guaranteed to\n\t * iterate this newly added structure before \"rcuog\" goes to\n\t * sleep again.\n\t */\n\tlist_add_tail_rcu(&rdp->nocb_entry_rdp, &rdp->nocb_gp_rdp->nocb_head_rdp);\n\n\t/*\n\t * Can't use rcu_nocb_lock_irqsave() before SEGCBLIST_LOCKING\n\t * is set.\n\t */\n\traw_spin_lock_irqsave(&rdp->nocb_lock, flags);\n\n\t/*\n\t * We didn't take the nocb lock while working on the\n\t * rdp->cblist with SEGCBLIST_LOCKING cleared (pure softirq/rcuc mode).\n\t * Every modifications that have been done previously on\n\t * rdp->cblist must be visible remotely by the nocb kthreads\n\t * upon wake up after reading the cblist flags.\n\t *\n\t * The layout against nocb_lock enforces that ordering:\n\t *\n\t *  __rcu_nocb_rdp_offload()   nocb_cb_wait()/nocb_gp_wait()\n\t * -------------------------   ----------------------------\n\t *      WRITE callbacks           rcu_nocb_lock()\n\t *      rcu_nocb_lock()           READ flags\n\t *      WRITE flags               READ callbacks\n\t *      rcu_nocb_unlock()         rcu_nocb_unlock()\n\t */\n\tret = rdp_offload_toggle(rdp, true, flags);\n\tswait_event_exclusive(rdp->nocb_state_wq,\n\t\t\t      rcu_segcblist_test_flags(cblist, SEGCBLIST_KTHREAD_CB) &&\n\t\t\t      rcu_segcblist_test_flags(cblist, SEGCBLIST_KTHREAD_GP));\n\n\t/*\n\t * All kthreads are ready to work, we can finally relieve rcu_core() and\n\t * enable nocb bypass.\n\t */\n\trcu_nocb_lock_irqsave(rdp, flags);\n\trcu_segcblist_clear_flags(cblist, SEGCBLIST_RCU_CORE);\n\trcu_nocb_unlock_irqrestore(rdp, flags);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "rcu_nocb_cpu_deoffload",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_nocb.h",
    "lines": "1052-1073",
    "snippet": "int rcu_nocb_cpu_deoffload(int cpu)\n{\n\tstruct rcu_data *rdp = per_cpu_ptr(&rcu_data, cpu);\n\tint ret = 0;\n\n\tmutex_lock(&rcu_state.barrier_mutex);\n\tcpus_read_lock();\n\tif (rcu_rdp_is_offloaded(rdp)) {\n\t\tif (cpu_online(cpu)) {\n\t\t\tret = work_on_cpu(cpu, rcu_nocb_rdp_deoffload, rdp);\n\t\t\tif (!ret)\n\t\t\t\tcpumask_clear_cpu(cpu, rcu_nocb_mask);\n\t\t} else {\n\t\t\tpr_info(\"NOCB: Can't CB-deoffload an offline CPU\\n\");\n\t\t\tret = -EINVAL;\n\t\t}\n\t}\n\tcpus_read_unlock();\n\tmutex_unlock(&rcu_state.barrier_mutex);\n\n\treturn ret;\n}",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&rcu_state.barrier_mutex"
          ],
          "line": 1070
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpus_read_unlock",
          "args": [],
          "line": 1069
        },
        "resolved": true,
        "details": {
          "function_name": "cpus_read_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "319-322",
          "snippet": "void cpus_read_unlock(void)\n{\n\tpercpu_up_read(&cpu_hotplug_lock);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nvoid cpus_read_unlock(void)\n{\n\tpercpu_up_read(&cpu_hotplug_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"NOCB: Can't CB-deoffload an offline CPU\\n\""
          ],
          "line": 1065
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_clear_cpu",
          "args": [
            "cpu",
            "rcu_nocb_mask"
          ],
          "line": 1063
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "work_on_cpu",
          "args": [
            "cpu",
            "rcu_nocb_rdp_deoffload",
            "rdp"
          ],
          "line": 1061
        },
        "resolved": true,
        "details": {
          "function_name": "work_on_cpu_safe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "5220-5229",
          "snippet": "long work_on_cpu_safe(int cpu, long (*fn)(void *), void *arg)\n{\n\tlong ret = -ENODEV;\n\n\tcpus_read_lock();\n\tif (cpu_online(cpu))\n\t\tret = work_on_cpu(cpu, fn, arg);\n\tcpus_read_unlock();\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nlong work_on_cpu_safe(int cpu, long (*fn)(void *), void *arg)\n{\n\tlong ret = -ENODEV;\n\n\tcpus_read_lock();\n\tif (cpu_online(cpu))\n\t\tret = work_on_cpu(cpu, fn, arg);\n\tcpus_read_unlock();\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_online",
          "args": [
            "cpu"
          ],
          "line": 1060
        },
        "resolved": true,
        "details": {
          "function_name": "init_cpu_online",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "2616-2619",
          "snippet": "void init_cpu_online(const struct cpumask *src)\n{\n\tcpumask_copy(&__cpu_online_mask, src);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct cpumask __cpu_online_mask"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstruct cpumask __cpu_online_mask;\n\nvoid init_cpu_online(const struct cpumask *src)\n{\n\tcpumask_copy(&__cpu_online_mask, src);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_rdp_is_offloaded",
          "args": [
            "rdp"
          ],
          "line": 1059
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_rdp_is_offloaded",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "16-38",
          "snippet": "static bool rcu_rdp_is_offloaded(struct rcu_data *rdp)\n{\n\t/*\n\t * In order to read the offloaded state of an rdp in a safe\n\t * and stable way and prevent from its value to be changed\n\t * under us, we must either hold the barrier mutex, the cpu\n\t * hotplug lock (read or write) or the nocb lock. Local\n\t * non-preemptible reads are also safe. NOCB kthreads and\n\t * timers have their own means of synchronization against the\n\t * offloaded state updaters.\n\t */\n\tRCU_LOCKDEP_WARN(\n\t\t!(lockdep_is_held(&rcu_state.barrier_mutex) ||\n\t\t  (IS_ENABLED(CONFIG_HOTPLUG_CPU) && lockdep_is_cpus_held()) ||\n\t\t  rcu_lockdep_is_held_nocb(rdp) ||\n\t\t  (rdp == this_cpu_ptr(&rcu_data) &&\n\t\t   !(IS_ENABLED(CONFIG_PREEMPT_COUNT) && preemptible())) ||\n\t\t  rcu_current_is_nocb_kthread(rdp)),\n\t\t\"Unsafe read of RCU_NOCB offloaded state\"\n\t);\n\n\treturn rcu_segcblist_is_offloaded(&rdp->cblist);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nstatic bool rcu_rdp_is_offloaded(struct rcu_data *rdp)\n{\n\t/*\n\t * In order to read the offloaded state of an rdp in a safe\n\t * and stable way and prevent from its value to be changed\n\t * under us, we must either hold the barrier mutex, the cpu\n\t * hotplug lock (read or write) or the nocb lock. Local\n\t * non-preemptible reads are also safe. NOCB kthreads and\n\t * timers have their own means of synchronization against the\n\t * offloaded state updaters.\n\t */\n\tRCU_LOCKDEP_WARN(\n\t\t!(lockdep_is_held(&rcu_state.barrier_mutex) ||\n\t\t  (IS_ENABLED(CONFIG_HOTPLUG_CPU) && lockdep_is_cpus_held()) ||\n\t\t  rcu_lockdep_is_held_nocb(rdp) ||\n\t\t  (rdp == this_cpu_ptr(&rcu_data) &&\n\t\t   !(IS_ENABLED(CONFIG_PREEMPT_COUNT) && preemptible())) ||\n\t\t  rcu_current_is_nocb_kthread(rdp)),\n\t\t\"Unsafe read of RCU_NOCB offloaded state\"\n\t);\n\n\treturn rcu_segcblist_is_offloaded(&rdp->cblist);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpus_read_lock",
          "args": [],
          "line": 1058
        },
        "resolved": true,
        "details": {
          "function_name": "cpus_read_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "307-310",
          "snippet": "void cpus_read_lock(void)\n{\n\tpercpu_down_read(&cpu_hotplug_lock);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nvoid cpus_read_lock(void)\n{\n\tpercpu_down_read(&cpu_hotplug_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&rcu_state.barrier_mutex"
          ],
          "line": 1057
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "&rcu_data",
            "cpu"
          ],
          "line": 1054
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "int rcu_nocb_cpu_deoffload(int cpu)\n{\n\tstruct rcu_data *rdp = per_cpu_ptr(&rcu_data, cpu);\n\tint ret = 0;\n\n\tmutex_lock(&rcu_state.barrier_mutex);\n\tcpus_read_lock();\n\tif (rcu_rdp_is_offloaded(rdp)) {\n\t\tif (cpu_online(cpu)) {\n\t\t\tret = work_on_cpu(cpu, rcu_nocb_rdp_deoffload, rdp);\n\t\t\tif (!ret)\n\t\t\t\tcpumask_clear_cpu(cpu, rcu_nocb_mask);\n\t\t} else {\n\t\t\tpr_info(\"NOCB: Can't CB-deoffload an offline CPU\\n\");\n\t\t\tret = -EINVAL;\n\t\t}\n\t}\n\tcpus_read_unlock();\n\tmutex_unlock(&rcu_state.barrier_mutex);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "rcu_nocb_rdp_deoffload",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_nocb.h",
    "lines": "992-1050",
    "snippet": "static long rcu_nocb_rdp_deoffload(void *arg)\n{\n\tstruct rcu_data *rdp = arg;\n\tstruct rcu_segcblist *cblist = &rdp->cblist;\n\tunsigned long flags;\n\tint ret;\n\n\tWARN_ON_ONCE(rdp->cpu != raw_smp_processor_id());\n\n\tpr_info(\"De-offloading %d\\n\", rdp->cpu);\n\n\trcu_nocb_lock_irqsave(rdp, flags);\n\t/*\n\t * Flush once and for all now. This suffices because we are\n\t * running on the target CPU holding ->nocb_lock (thus having\n\t * interrupts disabled), and because rdp_offload_toggle()\n\t * invokes rcu_segcblist_offload(), which clears SEGCBLIST_OFFLOADED.\n\t * Thus future calls to rcu_segcblist_completely_offloaded() will\n\t * return false, which means that future calls to rcu_nocb_try_bypass()\n\t * will refuse to put anything into the bypass.\n\t */\n\tWARN_ON_ONCE(!rcu_nocb_flush_bypass(rdp, NULL, jiffies));\n\t/*\n\t * Start with invoking rcu_core() early. This way if the current thread\n\t * happens to preempt an ongoing call to rcu_core() in the middle,\n\t * leaving some work dismissed because rcu_core() still thinks the rdp is\n\t * completely offloaded, we are guaranteed a nearby future instance of\n\t * rcu_core() to catch up.\n\t */\n\trcu_segcblist_set_flags(cblist, SEGCBLIST_RCU_CORE);\n\tinvoke_rcu_core();\n\tret = rdp_offload_toggle(rdp, false, flags);\n\tswait_event_exclusive(rdp->nocb_state_wq,\n\t\t\t      !rcu_segcblist_test_flags(cblist, SEGCBLIST_KTHREAD_CB |\n\t\t\t\t\t\t\tSEGCBLIST_KTHREAD_GP));\n\t/* Stop nocb_gp_wait() from iterating over this structure. */\n\tlist_del_rcu(&rdp->nocb_entry_rdp);\n\t/*\n\t * Lock one last time to acquire latest callback updates from kthreads\n\t * so we can later handle callbacks locally without locking.\n\t */\n\trcu_nocb_lock_irqsave(rdp, flags);\n\t/*\n\t * Theoretically we could clear SEGCBLIST_LOCKING after the nocb\n\t * lock is released but how about being paranoid for once?\n\t */\n\trcu_segcblist_clear_flags(cblist, SEGCBLIST_LOCKING);\n\t/*\n\t * Without SEGCBLIST_LOCKING, we can't use\n\t * rcu_nocb_unlock_irqrestore() anymore.\n\t */\n\traw_spin_unlock_irqrestore(&rdp->nocb_lock, flags);\n\n\t/* Sanity check */\n\tWARN_ON_ONCE(rcu_cblist_n_cbs(&rdp->nocb_bypass));\n\n\n\treturn ret;\n}",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "rcu_cblist_n_cbs(&rdp->nocb_bypass)"
          ],
          "line": 1046
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_cblist_n_cbs",
          "args": [
            "&rdp->nocb_bypass"
          ],
          "line": 1046
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_cblist_n_cbs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "13-16",
          "snippet": "static inline long rcu_cblist_n_cbs(struct rcu_cblist *rclp)\n{\n\treturn READ_ONCE(rclp->len);\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void rcu_cblist_init(struct rcu_cblist *rclp);",
            "struct rcu_head *rcu_cblist_dequeue(struct rcu_cblist *rclp);",
            "void rcu_segcblist_extract_done_cbs(struct rcu_segcblist *rsclp,\n\t\t\t\t    struct rcu_cblist *rclp);",
            "void rcu_segcblist_extract_pend_cbs(struct rcu_segcblist *rsclp,\n\t\t\t\t    struct rcu_cblist *rclp);",
            "void rcu_segcblist_insert_count(struct rcu_segcblist *rsclp,\n\t\t\t\tstruct rcu_cblist *rclp);",
            "void rcu_segcblist_insert_done_cbs(struct rcu_segcblist *rsclp,\n\t\t\t\t   struct rcu_cblist *rclp);",
            "void rcu_segcblist_insert_pend_cbs(struct rcu_segcblist *rsclp,\n\t\t\t\t   struct rcu_cblist *rclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nvoid rcu_cblist_init(struct rcu_cblist *rclp);\nstruct rcu_head *rcu_cblist_dequeue(struct rcu_cblist *rclp);\nvoid rcu_segcblist_extract_done_cbs(struct rcu_segcblist *rsclp,\n\t\t\t\t    struct rcu_cblist *rclp);\nvoid rcu_segcblist_extract_pend_cbs(struct rcu_segcblist *rsclp,\n\t\t\t\t    struct rcu_cblist *rclp);\nvoid rcu_segcblist_insert_count(struct rcu_segcblist *rsclp,\n\t\t\t\tstruct rcu_cblist *rclp);\nvoid rcu_segcblist_insert_done_cbs(struct rcu_segcblist *rsclp,\n\t\t\t\t   struct rcu_cblist *rclp);\nvoid rcu_segcblist_insert_pend_cbs(struct rcu_segcblist *rsclp,\n\t\t\t\t   struct rcu_cblist *rclp);\n\nstatic inline long rcu_cblist_n_cbs(struct rcu_cblist *rclp)\n{\n\treturn READ_ONCE(rclp->len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore",
          "args": [
            "&rdp->nocb_lock",
            "flags"
          ],
          "line": 1043
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "192-195",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_segcblist_clear_flags",
          "args": [
            "cblist",
            "SEGCBLIST_LOCKING"
          ],
          "line": 1038
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_clear_flags",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "62-66",
          "snippet": "static inline void rcu_segcblist_clear_flags(struct rcu_segcblist *rsclp,\n\t\t\t\t\t     int flags)\n{\n\trsclp->flags &= ~flags;\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "long rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nlong rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline void rcu_segcblist_clear_flags(struct rcu_segcblist *rsclp,\n\t\t\t\t\t     int flags)\n{\n\trsclp->flags &= ~flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_nocb_lock_irqsave",
          "args": [
            "rdp",
            "flags"
          ],
          "line": 1033
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_rcu",
          "args": [
            "&rdp->nocb_entry_rdp"
          ],
          "line": 1028
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swait_event_exclusive",
          "args": [
            "rdp->nocb_state_wq",
            "!rcu_segcblist_test_flags(cblist, SEGCBLIST_KTHREAD_CB |\n\t\t\t\t\t\t\tSEGCBLIST_KTHREAD_GP)"
          ],
          "line": 1024
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_segcblist_test_flags",
          "args": [
            "cblist",
            "SEGCBLIST_KTHREAD_CB |\n\t\t\t\t\t\t\tSEGCBLIST_KTHREAD_GP"
          ],
          "line": 1025
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_test_flags",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "68-72",
          "snippet": "static inline bool rcu_segcblist_test_flags(struct rcu_segcblist *rsclp,\n\t\t\t\t\t    int flags)\n{\n\treturn READ_ONCE(rsclp->flags) & flags;\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "long rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nlong rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_test_flags(struct rcu_segcblist *rsclp,\n\t\t\t\t\t    int flags)\n{\n\treturn READ_ONCE(rsclp->flags) & flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rdp_offload_toggle",
          "args": [
            "rdp",
            "false",
            "flags"
          ],
          "line": 1023
        },
        "resolved": true,
        "details": {
          "function_name": "rdp_offload_toggle",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_nocb.h",
          "lines": "959-990",
          "snippet": "static int rdp_offload_toggle(struct rcu_data *rdp,\n\t\t\t       bool offload, unsigned long flags)\n\t__releases(rdp->nocb_lock)\n{\n\tstruct rcu_segcblist *cblist = &rdp->cblist;\n\tstruct rcu_data *rdp_gp = rdp->nocb_gp_rdp;\n\tbool wake_gp = false;\n\n\trcu_segcblist_offload(cblist, offload);\n\n\tif (rdp->nocb_cb_sleep)\n\t\trdp->nocb_cb_sleep = false;\n\trcu_nocb_unlock_irqrestore(rdp, flags);\n\n\t/*\n\t * Ignore former value of nocb_cb_sleep and force wake up as it could\n\t * have been spuriously set to false already.\n\t */\n\tswake_up_one(&rdp->nocb_cb_wq);\n\n\traw_spin_lock_irqsave(&rdp_gp->nocb_gp_lock, flags);\n\tif (rdp_gp->nocb_gp_sleep) {\n\t\trdp_gp->nocb_gp_sleep = false;\n\t\twake_gp = true;\n\t}\n\traw_spin_unlock_irqrestore(&rdp_gp->nocb_gp_lock, flags);\n\n\tif (wake_gp)\n\t\twake_up_process(rdp_gp->nocb_gp_kthread);\n\n\treturn 0;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static int rdp_offload_toggle(struct rcu_data *rdp,\n\t\t\t       bool offload, unsigned long flags)\n\t__releases(rdp->nocb_lock)\n{\n\tstruct rcu_segcblist *cblist = &rdp->cblist;\n\tstruct rcu_data *rdp_gp = rdp->nocb_gp_rdp;\n\tbool wake_gp = false;\n\n\trcu_segcblist_offload(cblist, offload);\n\n\tif (rdp->nocb_cb_sleep)\n\t\trdp->nocb_cb_sleep = false;\n\trcu_nocb_unlock_irqrestore(rdp, flags);\n\n\t/*\n\t * Ignore former value of nocb_cb_sleep and force wake up as it could\n\t * have been spuriously set to false already.\n\t */\n\tswake_up_one(&rdp->nocb_cb_wq);\n\n\traw_spin_lock_irqsave(&rdp_gp->nocb_gp_lock, flags);\n\tif (rdp_gp->nocb_gp_sleep) {\n\t\trdp_gp->nocb_gp_sleep = false;\n\t\twake_gp = true;\n\t}\n\traw_spin_unlock_irqrestore(&rdp_gp->nocb_gp_lock, flags);\n\n\tif (wake_gp)\n\t\twake_up_process(rdp_gp->nocb_gp_kthread);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "invoke_rcu_core",
          "args": [],
          "line": 1022
        },
        "resolved": true,
        "details": {
          "function_name": "invoke_rcu_core",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "2824-2832",
          "snippet": "static void invoke_rcu_core(void)\n{\n\tif (!cpu_online(smp_processor_id()))\n\t\treturn;\n\tif (use_softirq)\n\t\traise_softirq(RCU_SOFTIRQ);\n\telse\n\t\tinvoke_rcu_core_kthread();\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool use_softirq = !IS_ENABLED(CONFIG_PREEMPT_RT);",
            "static void invoke_rcu_core(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic bool use_softirq = !IS_ENABLED(CONFIG_PREEMPT_RT);\nstatic void invoke_rcu_core(void);\n\nstatic void invoke_rcu_core(void)\n{\n\tif (!cpu_online(smp_processor_id()))\n\t\treturn;\n\tif (use_softirq)\n\t\traise_softirq(RCU_SOFTIRQ);\n\telse\n\t\tinvoke_rcu_core_kthread();\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_segcblist_set_flags",
          "args": [
            "cblist",
            "SEGCBLIST_RCU_CORE"
          ],
          "line": 1021
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_set_flags",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "56-60",
          "snippet": "static inline void rcu_segcblist_set_flags(struct rcu_segcblist *rsclp,\n\t\t\t\t\t   int flags)\n{\n\trsclp->flags |= flags;\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "long rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nlong rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline void rcu_segcblist_set_flags(struct rcu_segcblist *rsclp,\n\t\t\t\t\t   int flags)\n{\n\trsclp->flags |= flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!rcu_nocb_flush_bypass(rdp, NULL, jiffies)"
          ],
          "line": 1013
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_nocb_flush_bypass",
          "args": [
            "rdp",
            "NULL",
            "jiffies"
          ],
          "line": 1013
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_nocb_flush_bypass",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_nocb.h",
          "lines": "1504-1508",
          "snippet": "static bool rcu_nocb_flush_bypass(struct rcu_data *rdp, struct rcu_head *rhp,\n\t\t\t\t  unsigned long j)\n{\n\treturn true;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static bool rcu_nocb_flush_bypass(struct rcu_data *rdp, struct rcu_head *rhp,\n\t\t\t\t  unsigned long j)\n{\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_nocb_lock_irqsave",
          "args": [
            "rdp",
            "flags"
          ],
          "line": 1003
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"De-offloading %d\\n\"",
            "rdp->cpu"
          ],
          "line": 1001
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "rdp->cpu != raw_smp_processor_id()"
          ],
          "line": 999
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_smp_processor_id",
          "args": [],
          "line": 999
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "static long rcu_nocb_rdp_deoffload(void *arg)\n{\n\tstruct rcu_data *rdp = arg;\n\tstruct rcu_segcblist *cblist = &rdp->cblist;\n\tunsigned long flags;\n\tint ret;\n\n\tWARN_ON_ONCE(rdp->cpu != raw_smp_processor_id());\n\n\tpr_info(\"De-offloading %d\\n\", rdp->cpu);\n\n\trcu_nocb_lock_irqsave(rdp, flags);\n\t/*\n\t * Flush once and for all now. This suffices because we are\n\t * running on the target CPU holding ->nocb_lock (thus having\n\t * interrupts disabled), and because rdp_offload_toggle()\n\t * invokes rcu_segcblist_offload(), which clears SEGCBLIST_OFFLOADED.\n\t * Thus future calls to rcu_segcblist_completely_offloaded() will\n\t * return false, which means that future calls to rcu_nocb_try_bypass()\n\t * will refuse to put anything into the bypass.\n\t */\n\tWARN_ON_ONCE(!rcu_nocb_flush_bypass(rdp, NULL, jiffies));\n\t/*\n\t * Start with invoking rcu_core() early. This way if the current thread\n\t * happens to preempt an ongoing call to rcu_core() in the middle,\n\t * leaving some work dismissed because rcu_core() still thinks the rdp is\n\t * completely offloaded, we are guaranteed a nearby future instance of\n\t * rcu_core() to catch up.\n\t */\n\trcu_segcblist_set_flags(cblist, SEGCBLIST_RCU_CORE);\n\tinvoke_rcu_core();\n\tret = rdp_offload_toggle(rdp, false, flags);\n\tswait_event_exclusive(rdp->nocb_state_wq,\n\t\t\t      !rcu_segcblist_test_flags(cblist, SEGCBLIST_KTHREAD_CB |\n\t\t\t\t\t\t\tSEGCBLIST_KTHREAD_GP));\n\t/* Stop nocb_gp_wait() from iterating over this structure. */\n\tlist_del_rcu(&rdp->nocb_entry_rdp);\n\t/*\n\t * Lock one last time to acquire latest callback updates from kthreads\n\t * so we can later handle callbacks locally without locking.\n\t */\n\trcu_nocb_lock_irqsave(rdp, flags);\n\t/*\n\t * Theoretically we could clear SEGCBLIST_LOCKING after the nocb\n\t * lock is released but how about being paranoid for once?\n\t */\n\trcu_segcblist_clear_flags(cblist, SEGCBLIST_LOCKING);\n\t/*\n\t * Without SEGCBLIST_LOCKING, we can't use\n\t * rcu_nocb_unlock_irqrestore() anymore.\n\t */\n\traw_spin_unlock_irqrestore(&rdp->nocb_lock, flags);\n\n\t/* Sanity check */\n\tWARN_ON_ONCE(rcu_cblist_n_cbs(&rdp->nocb_bypass));\n\n\n\treturn ret;\n}"
  },
  {
    "function_name": "rdp_offload_toggle",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_nocb.h",
    "lines": "959-990",
    "snippet": "static int rdp_offload_toggle(struct rcu_data *rdp,\n\t\t\t       bool offload, unsigned long flags)\n\t__releases(rdp->nocb_lock)\n{\n\tstruct rcu_segcblist *cblist = &rdp->cblist;\n\tstruct rcu_data *rdp_gp = rdp->nocb_gp_rdp;\n\tbool wake_gp = false;\n\n\trcu_segcblist_offload(cblist, offload);\n\n\tif (rdp->nocb_cb_sleep)\n\t\trdp->nocb_cb_sleep = false;\n\trcu_nocb_unlock_irqrestore(rdp, flags);\n\n\t/*\n\t * Ignore former value of nocb_cb_sleep and force wake up as it could\n\t * have been spuriously set to false already.\n\t */\n\tswake_up_one(&rdp->nocb_cb_wq);\n\n\traw_spin_lock_irqsave(&rdp_gp->nocb_gp_lock, flags);\n\tif (rdp_gp->nocb_gp_sleep) {\n\t\trdp_gp->nocb_gp_sleep = false;\n\t\twake_gp = true;\n\t}\n\traw_spin_unlock_irqrestore(&rdp_gp->nocb_gp_lock, flags);\n\n\tif (wake_gp)\n\t\twake_up_process(rdp_gp->nocb_gp_kthread);\n\n\treturn 0;\n}",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wake_up_process",
          "args": [
            "rdp_gp->nocb_gp_kthread"
          ],
          "line": 987
        },
        "resolved": true,
        "details": {
          "function_name": "wake_up_process",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "4215-4218",
          "snippet": "int wake_up_process(struct task_struct *p)\n{\n\treturn try_to_wake_up(p, TASK_NORMAL, 0);\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\nint wake_up_process(struct task_struct *p)\n{\n\treturn try_to_wake_up(p, TASK_NORMAL, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore",
          "args": [
            "&rdp_gp->nocb_gp_lock",
            "flags"
          ],
          "line": 984
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "192-195",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave",
          "args": [
            "&rdp_gp->nocb_gp_lock",
            "flags"
          ],
          "line": 979
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "383-393",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "swake_up_one",
          "args": [
            "&rdp->nocb_cb_wq"
          ],
          "line": 977
        },
        "resolved": true,
        "details": {
          "function_name": "swake_up_one",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/swait.c",
          "lines": "48-55",
          "snippet": "void swake_up_one(struct swait_queue_head *q)\n{\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&q->lock, flags);\n\tswake_up_locked(q);\n\traw_spin_unlock_irqrestore(&q->lock, flags);\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nvoid swake_up_one(struct swait_queue_head *q)\n{\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&q->lock, flags);\n\tswake_up_locked(q);\n\traw_spin_unlock_irqrestore(&q->lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_nocb_unlock_irqrestore",
          "args": [
            "rdp",
            "flags"
          ],
          "line": 971
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_nocb_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_nocb.h",
          "lines": "1479-1483",
          "snippet": "static void rcu_nocb_unlock_irqrestore(struct rcu_data *rdp,\n\t\t\t\t       unsigned long flags)\n{\n\tlocal_irq_restore(flags);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static void rcu_nocb_unlock_irqrestore(struct rcu_data *rdp,\n\t\t\t\t       unsigned long flags)\n{\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_segcblist_offload",
          "args": [
            "cblist",
            "offload"
          ],
          "line": 967
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_offload",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.c",
          "lines": "266-272",
          "snippet": "void rcu_segcblist_offload(struct rcu_segcblist *rsclp, bool offload)\n{\n\tif (offload)\n\t\trcu_segcblist_set_flags(rsclp, SEGCBLIST_LOCKING | SEGCBLIST_OFFLOADED);\n\telse\n\t\trcu_segcblist_clear_flags(rsclp, SEGCBLIST_OFFLOADED);\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/cpu.h>\n\nvoid rcu_segcblist_offload(struct rcu_segcblist *rsclp, bool offload)\n{\n\tif (offload)\n\t\trcu_segcblist_set_flags(rsclp, SEGCBLIST_LOCKING | SEGCBLIST_OFFLOADED);\n\telse\n\t\trcu_segcblist_clear_flags(rsclp, SEGCBLIST_OFFLOADED);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__releases",
          "args": [
            "rdp->nocb_lock"
          ],
          "line": 961
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "static int rdp_offload_toggle(struct rcu_data *rdp,\n\t\t\t       bool offload, unsigned long flags)\n\t__releases(rdp->nocb_lock)\n{\n\tstruct rcu_segcblist *cblist = &rdp->cblist;\n\tstruct rcu_data *rdp_gp = rdp->nocb_gp_rdp;\n\tbool wake_gp = false;\n\n\trcu_segcblist_offload(cblist, offload);\n\n\tif (rdp->nocb_cb_sleep)\n\t\trdp->nocb_cb_sleep = false;\n\trcu_nocb_unlock_irqrestore(rdp, flags);\n\n\t/*\n\t * Ignore former value of nocb_cb_sleep and force wake up as it could\n\t * have been spuriously set to false already.\n\t */\n\tswake_up_one(&rdp->nocb_cb_wq);\n\n\traw_spin_lock_irqsave(&rdp_gp->nocb_gp_lock, flags);\n\tif (rdp_gp->nocb_gp_sleep) {\n\t\trdp_gp->nocb_gp_sleep = false;\n\t\twake_gp = true;\n\t}\n\traw_spin_unlock_irqrestore(&rdp_gp->nocb_gp_lock, flags);\n\n\tif (wake_gp)\n\t\twake_up_process(rdp_gp->nocb_gp_kthread);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "rcu_nocb_flush_deferred_wakeup",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_nocb.h",
    "lines": "953-956",
    "snippet": "void rcu_nocb_flush_deferred_wakeup(void)\n{\n\tdo_nocb_deferred_wakeup(this_cpu_ptr(&rcu_data));\n}",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_nocb_deferred_wakeup",
          "args": [
            "this_cpu_ptr(&rcu_data)"
          ],
          "line": 955
        },
        "resolved": true,
        "details": {
          "function_name": "do_nocb_deferred_wakeup",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_nocb.h",
          "lines": "1531-1534",
          "snippet": "static bool do_nocb_deferred_wakeup(struct rcu_data *rdp)\n{\n\treturn false;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static bool do_nocb_deferred_wakeup(struct rcu_data *rdp)\n{\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&rcu_data"
          ],
          "line": 955
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "void rcu_nocb_flush_deferred_wakeup(void)\n{\n\tdo_nocb_deferred_wakeup(this_cpu_ptr(&rcu_data));\n}"
  },
  {
    "function_name": "do_nocb_deferred_wakeup",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_nocb.h",
    "lines": "941-951",
    "snippet": "static bool do_nocb_deferred_wakeup(struct rcu_data *rdp)\n{\n\tunsigned long flags;\n\tstruct rcu_data *rdp_gp = rdp->nocb_gp_rdp;\n\n\tif (!rdp_gp || !rcu_nocb_need_deferred_wakeup(rdp_gp, RCU_NOCB_WAKE))\n\t\treturn false;\n\n\traw_spin_lock_irqsave(&rdp_gp->nocb_gp_lock, flags);\n\treturn do_nocb_deferred_wakeup_common(rdp_gp, rdp, RCU_NOCB_WAKE, flags);\n}",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_nocb_deferred_wakeup_common",
          "args": [
            "rdp_gp",
            "rdp",
            "RCU_NOCB_WAKE",
            "flags"
          ],
          "line": 950
        },
        "resolved": true,
        "details": {
          "function_name": "do_nocb_deferred_wakeup_common",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_nocb.h",
          "lines": "902-920",
          "snippet": "static bool do_nocb_deferred_wakeup_common(struct rcu_data *rdp_gp,\n\t\t\t\t\t   struct rcu_data *rdp, int level,\n\t\t\t\t\t   unsigned long flags)\n\t__releases(rdp_gp->nocb_gp_lock)\n{\n\tint ndw;\n\tint ret;\n\n\tif (!rcu_nocb_need_deferred_wakeup(rdp_gp, level)) {\n\t\traw_spin_unlock_irqrestore(&rdp_gp->nocb_gp_lock, flags);\n\t\treturn false;\n\t}\n\n\tndw = rdp_gp->nocb_defer_wakeup;\n\tret = __wake_nocb_gp(rdp_gp, rdp, ndw == RCU_NOCB_WAKE_FORCE, flags);\n\ttrace_rcu_nocb_wake(rcu_state.name, rdp->cpu, TPS(\"DeferredWake\"));\n\n\treturn ret;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static bool do_nocb_deferred_wakeup_common(struct rcu_data *rdp_gp,\n\t\t\t\t\t   struct rcu_data *rdp, int level,\n\t\t\t\t\t   unsigned long flags)\n\t__releases(rdp_gp->nocb_gp_lock)\n{\n\tint ndw;\n\tint ret;\n\n\tif (!rcu_nocb_need_deferred_wakeup(rdp_gp, level)) {\n\t\traw_spin_unlock_irqrestore(&rdp_gp->nocb_gp_lock, flags);\n\t\treturn false;\n\t}\n\n\tndw = rdp_gp->nocb_defer_wakeup;\n\tret = __wake_nocb_gp(rdp_gp, rdp, ndw == RCU_NOCB_WAKE_FORCE, flags);\n\ttrace_rcu_nocb_wake(rcu_state.name, rdp->cpu, TPS(\"DeferredWake\"));\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave",
          "args": [
            "&rdp_gp->nocb_gp_lock",
            "flags"
          ],
          "line": 949
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "383-393",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_nocb_need_deferred_wakeup",
          "args": [
            "rdp_gp",
            "RCU_NOCB_WAKE"
          ],
          "line": 946
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_nocb_need_deferred_wakeup",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_nocb.h",
          "lines": "1526-1529",
          "snippet": "static int rcu_nocb_need_deferred_wakeup(struct rcu_data *rdp, int level)\n{\n\treturn false;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static int rcu_nocb_need_deferred_wakeup(struct rcu_data *rdp, int level)\n{\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "static bool do_nocb_deferred_wakeup(struct rcu_data *rdp)\n{\n\tunsigned long flags;\n\tstruct rcu_data *rdp_gp = rdp->nocb_gp_rdp;\n\n\tif (!rdp_gp || !rcu_nocb_need_deferred_wakeup(rdp_gp, RCU_NOCB_WAKE))\n\t\treturn false;\n\n\traw_spin_lock_irqsave(&rdp_gp->nocb_gp_lock, flags);\n\treturn do_nocb_deferred_wakeup_common(rdp_gp, rdp, RCU_NOCB_WAKE, flags);\n}"
  },
  {
    "function_name": "do_nocb_deferred_wakeup_timer",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_nocb.h",
    "lines": "923-934",
    "snippet": "static void do_nocb_deferred_wakeup_timer(struct timer_list *t)\n{\n\tunsigned long flags;\n\tstruct rcu_data *rdp = from_timer(rdp, t, nocb_timer);\n\n\tWARN_ON_ONCE(rdp->nocb_gp_rdp != rdp);\n\ttrace_rcu_nocb_wake(rcu_state.name, rdp->cpu, TPS(\"Timer\"));\n\n\traw_spin_lock_irqsave(&rdp->nocb_gp_lock, flags);\n\tsmp_mb__after_spinlock(); /* Timer expire before wakeup. */\n\tdo_nocb_deferred_wakeup_common(rdp, rdp, RCU_NOCB_WAKE_BYPASS, flags);\n}",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_nocb_deferred_wakeup_common",
          "args": [
            "rdp",
            "rdp",
            "RCU_NOCB_WAKE_BYPASS",
            "flags"
          ],
          "line": 933
        },
        "resolved": true,
        "details": {
          "function_name": "do_nocb_deferred_wakeup_common",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_nocb.h",
          "lines": "902-920",
          "snippet": "static bool do_nocb_deferred_wakeup_common(struct rcu_data *rdp_gp,\n\t\t\t\t\t   struct rcu_data *rdp, int level,\n\t\t\t\t\t   unsigned long flags)\n\t__releases(rdp_gp->nocb_gp_lock)\n{\n\tint ndw;\n\tint ret;\n\n\tif (!rcu_nocb_need_deferred_wakeup(rdp_gp, level)) {\n\t\traw_spin_unlock_irqrestore(&rdp_gp->nocb_gp_lock, flags);\n\t\treturn false;\n\t}\n\n\tndw = rdp_gp->nocb_defer_wakeup;\n\tret = __wake_nocb_gp(rdp_gp, rdp, ndw == RCU_NOCB_WAKE_FORCE, flags);\n\ttrace_rcu_nocb_wake(rcu_state.name, rdp->cpu, TPS(\"DeferredWake\"));\n\n\treturn ret;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static bool do_nocb_deferred_wakeup_common(struct rcu_data *rdp_gp,\n\t\t\t\t\t   struct rcu_data *rdp, int level,\n\t\t\t\t\t   unsigned long flags)\n\t__releases(rdp_gp->nocb_gp_lock)\n{\n\tint ndw;\n\tint ret;\n\n\tif (!rcu_nocb_need_deferred_wakeup(rdp_gp, level)) {\n\t\traw_spin_unlock_irqrestore(&rdp_gp->nocb_gp_lock, flags);\n\t\treturn false;\n\t}\n\n\tndw = rdp_gp->nocb_defer_wakeup;\n\tret = __wake_nocb_gp(rdp_gp, rdp, ndw == RCU_NOCB_WAKE_FORCE, flags);\n\ttrace_rcu_nocb_wake(rcu_state.name, rdp->cpu, TPS(\"DeferredWake\"));\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_mb__after_spinlock",
          "args": [],
          "line": 932
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave",
          "args": [
            "&rdp->nocb_gp_lock",
            "flags"
          ],
          "line": 931
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "383-393",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_rcu_nocb_wake",
          "args": [
            "rcu_state.name",
            "rdp->cpu",
            "TPS(\"Timer\")"
          ],
          "line": 929
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPS",
          "args": [
            "\"Timer\""
          ],
          "line": 929
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "rdp->nocb_gp_rdp != rdp"
          ],
          "line": 928
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "from_timer",
          "args": [
            "rdp",
            "t",
            "nocb_timer"
          ],
          "line": 926
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "static void do_nocb_deferred_wakeup_timer(struct timer_list *t)\n{\n\tunsigned long flags;\n\tstruct rcu_data *rdp = from_timer(rdp, t, nocb_timer);\n\n\tWARN_ON_ONCE(rdp->nocb_gp_rdp != rdp);\n\ttrace_rcu_nocb_wake(rcu_state.name, rdp->cpu, TPS(\"Timer\"));\n\n\traw_spin_lock_irqsave(&rdp->nocb_gp_lock, flags);\n\tsmp_mb__after_spinlock(); /* Timer expire before wakeup. */\n\tdo_nocb_deferred_wakeup_common(rdp, rdp, RCU_NOCB_WAKE_BYPASS, flags);\n}"
  },
  {
    "function_name": "do_nocb_deferred_wakeup_common",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_nocb.h",
    "lines": "902-920",
    "snippet": "static bool do_nocb_deferred_wakeup_common(struct rcu_data *rdp_gp,\n\t\t\t\t\t   struct rcu_data *rdp, int level,\n\t\t\t\t\t   unsigned long flags)\n\t__releases(rdp_gp->nocb_gp_lock)\n{\n\tint ndw;\n\tint ret;\n\n\tif (!rcu_nocb_need_deferred_wakeup(rdp_gp, level)) {\n\t\traw_spin_unlock_irqrestore(&rdp_gp->nocb_gp_lock, flags);\n\t\treturn false;\n\t}\n\n\tndw = rdp_gp->nocb_defer_wakeup;\n\tret = __wake_nocb_gp(rdp_gp, rdp, ndw == RCU_NOCB_WAKE_FORCE, flags);\n\ttrace_rcu_nocb_wake(rcu_state.name, rdp->cpu, TPS(\"DeferredWake\"));\n\n\treturn ret;\n}",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_rcu_nocb_wake",
          "args": [
            "rcu_state.name",
            "rdp->cpu",
            "TPS(\"DeferredWake\")"
          ],
          "line": 917
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPS",
          "args": [
            "\"DeferredWake\""
          ],
          "line": 917
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__wake_nocb_gp",
          "args": [
            "rdp_gp",
            "rdp",
            "ndw == RCU_NOCB_WAKE_FORCE",
            "flags"
          ],
          "line": 916
        },
        "resolved": true,
        "details": {
          "function_name": "__wake_nocb_gp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_nocb.h",
          "lines": "226-256",
          "snippet": "static bool __wake_nocb_gp(struct rcu_data *rdp_gp,\n\t\t\t   struct rcu_data *rdp,\n\t\t\t   bool force, unsigned long flags)\n\t__releases(rdp_gp->nocb_gp_lock)\n{\n\tbool needwake = false;\n\n\tif (!READ_ONCE(rdp_gp->nocb_gp_kthread)) {\n\t\traw_spin_unlock_irqrestore(&rdp_gp->nocb_gp_lock, flags);\n\t\ttrace_rcu_nocb_wake(rcu_state.name, rdp->cpu,\n\t\t\t\t    TPS(\"AlreadyAwake\"));\n\t\treturn false;\n\t}\n\n\tif (rdp_gp->nocb_defer_wakeup > RCU_NOCB_WAKE_NOT) {\n\t\tWRITE_ONCE(rdp_gp->nocb_defer_wakeup, RCU_NOCB_WAKE_NOT);\n\t\tdel_timer(&rdp_gp->nocb_timer);\n\t}\n\n\tif (force || READ_ONCE(rdp_gp->nocb_gp_sleep)) {\n\t\tWRITE_ONCE(rdp_gp->nocb_gp_sleep, false);\n\t\tneedwake = true;\n\t}\n\traw_spin_unlock_irqrestore(&rdp_gp->nocb_gp_lock, flags);\n\tif (needwake) {\n\t\ttrace_rcu_nocb_wake(rcu_state.name, rdp->cpu, TPS(\"DoWake\"));\n\t\twake_up_process(rdp_gp->nocb_gp_kthread);\n\t}\n\n\treturn needwake;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static bool __wake_nocb_gp(struct rcu_data *rdp_gp,\n\t\t\t   struct rcu_data *rdp,\n\t\t\t   bool force, unsigned long flags)\n\t__releases(rdp_gp->nocb_gp_lock)\n{\n\tbool needwake = false;\n\n\tif (!READ_ONCE(rdp_gp->nocb_gp_kthread)) {\n\t\traw_spin_unlock_irqrestore(&rdp_gp->nocb_gp_lock, flags);\n\t\ttrace_rcu_nocb_wake(rcu_state.name, rdp->cpu,\n\t\t\t\t    TPS(\"AlreadyAwake\"));\n\t\treturn false;\n\t}\n\n\tif (rdp_gp->nocb_defer_wakeup > RCU_NOCB_WAKE_NOT) {\n\t\tWRITE_ONCE(rdp_gp->nocb_defer_wakeup, RCU_NOCB_WAKE_NOT);\n\t\tdel_timer(&rdp_gp->nocb_timer);\n\t}\n\n\tif (force || READ_ONCE(rdp_gp->nocb_gp_sleep)) {\n\t\tWRITE_ONCE(rdp_gp->nocb_gp_sleep, false);\n\t\tneedwake = true;\n\t}\n\traw_spin_unlock_irqrestore(&rdp_gp->nocb_gp_lock, flags);\n\tif (needwake) {\n\t\ttrace_rcu_nocb_wake(rcu_state.name, rdp->cpu, TPS(\"DoWake\"));\n\t\twake_up_process(rdp_gp->nocb_gp_kthread);\n\t}\n\n\treturn needwake;\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore",
          "args": [
            "&rdp_gp->nocb_gp_lock",
            "flags"
          ],
          "line": 911
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "192-195",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_nocb_need_deferred_wakeup",
          "args": [
            "rdp_gp",
            "level"
          ],
          "line": 910
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_nocb_need_deferred_wakeup",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_nocb.h",
          "lines": "1526-1529",
          "snippet": "static int rcu_nocb_need_deferred_wakeup(struct rcu_data *rdp, int level)\n{\n\treturn false;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static int rcu_nocb_need_deferred_wakeup(struct rcu_data *rdp, int level)\n{\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__releases",
          "args": [
            "rdp_gp->nocb_gp_lock"
          ],
          "line": 905
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "static bool do_nocb_deferred_wakeup_common(struct rcu_data *rdp_gp,\n\t\t\t\t\t   struct rcu_data *rdp, int level,\n\t\t\t\t\t   unsigned long flags)\n\t__releases(rdp_gp->nocb_gp_lock)\n{\n\tint ndw;\n\tint ret;\n\n\tif (!rcu_nocb_need_deferred_wakeup(rdp_gp, level)) {\n\t\traw_spin_unlock_irqrestore(&rdp_gp->nocb_gp_lock, flags);\n\t\treturn false;\n\t}\n\n\tndw = rdp_gp->nocb_defer_wakeup;\n\tret = __wake_nocb_gp(rdp_gp, rdp, ndw == RCU_NOCB_WAKE_FORCE, flags);\n\ttrace_rcu_nocb_wake(rcu_state.name, rdp->cpu, TPS(\"DeferredWake\"));\n\n\treturn ret;\n}"
  },
  {
    "function_name": "rcu_nocb_need_deferred_wakeup",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_nocb.h",
    "lines": "896-899",
    "snippet": "static int rcu_nocb_need_deferred_wakeup(struct rcu_data *rdp, int level)\n{\n\treturn READ_ONCE(rdp->nocb_defer_wakeup) >= level;\n}",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rdp->nocb_defer_wakeup"
          ],
          "line": 898
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "static int rcu_nocb_need_deferred_wakeup(struct rcu_data *rdp, int level)\n{\n\treturn READ_ONCE(rdp->nocb_defer_wakeup) >= level;\n}"
  },
  {
    "function_name": "rcu_nocb_cb_kthread",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_nocb.h",
    "lines": "882-893",
    "snippet": "static int rcu_nocb_cb_kthread(void *arg)\n{\n\tstruct rcu_data *rdp = arg;\n\n\t// Each pass through this loop does one callback batch, and,\n\t// if there are no more ready callbacks, waits for them.\n\tfor (;;) {\n\t\tnocb_cb_wait(rdp);\n\t\tcond_resched_tasks_rcu_qs();\n\t}\n\treturn 0;\n}",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cond_resched_tasks_rcu_qs",
          "args": [],
          "line": 890
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nocb_cb_wait",
          "args": [
            "rdp"
          ],
          "line": 889
        },
        "resolved": true,
        "details": {
          "function_name": "nocb_cb_wait",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_nocb.h",
          "lines": "802-876",
          "snippet": "static void nocb_cb_wait(struct rcu_data *rdp)\n{\n\tstruct rcu_segcblist *cblist = &rdp->cblist;\n\tunsigned long cur_gp_seq;\n\tunsigned long flags;\n\tbool needwake_state = false;\n\tbool needwake_gp = false;\n\tbool can_sleep = true;\n\tstruct rcu_node *rnp = rdp->mynode;\n\n\tdo {\n\t\tswait_event_interruptible_exclusive(rdp->nocb_cb_wq,\n\t\t\t\t\t\t    nocb_cb_wait_cond(rdp));\n\n\t\t// VVV Ensure CB invocation follows _sleep test.\n\t\tif (smp_load_acquire(&rdp->nocb_cb_sleep)) { // ^^^\n\t\t\tWARN_ON(signal_pending(current));\n\t\t\ttrace_rcu_nocb_wake(rcu_state.name, rdp->cpu, TPS(\"WokeEmpty\"));\n\t\t}\n\t} while (!nocb_cb_can_run(rdp));\n\n\n\tlocal_irq_save(flags);\n\trcu_momentary_dyntick_idle();\n\tlocal_irq_restore(flags);\n\t/*\n\t * Disable BH to provide the expected environment.  Also, when\n\t * transitioning to/from NOCB mode, a self-requeuing callback might\n\t * be invoked from softirq.  A short grace period could cause both\n\t * instances of this callback would execute concurrently.\n\t */\n\tlocal_bh_disable();\n\trcu_do_batch(rdp);\n\tlocal_bh_enable();\n\tlockdep_assert_irqs_enabled();\n\trcu_nocb_lock_irqsave(rdp, flags);\n\tif (rcu_segcblist_nextgp(cblist, &cur_gp_seq) &&\n\t    rcu_seq_done(&rnp->gp_seq, cur_gp_seq) &&\n\t    raw_spin_trylock_rcu_node(rnp)) { /* irqs already disabled. */\n\t\tneedwake_gp = rcu_advance_cbs(rdp->mynode, rdp);\n\t\traw_spin_unlock_rcu_node(rnp); /* irqs remain disabled. */\n\t}\n\n\tif (rcu_segcblist_test_flags(cblist, SEGCBLIST_OFFLOADED)) {\n\t\tif (!rcu_segcblist_test_flags(cblist, SEGCBLIST_KTHREAD_CB)) {\n\t\t\trcu_segcblist_set_flags(cblist, SEGCBLIST_KTHREAD_CB);\n\t\t\tif (rcu_segcblist_test_flags(cblist, SEGCBLIST_KTHREAD_GP))\n\t\t\t\tneedwake_state = true;\n\t\t}\n\t\tif (rcu_segcblist_ready_cbs(cblist))\n\t\t\tcan_sleep = false;\n\t} else {\n\t\t/*\n\t\t * De-offloading. Clear our flag and notify the de-offload worker.\n\t\t * We won't touch the callbacks and keep sleeping until we ever\n\t\t * get re-offloaded.\n\t\t */\n\t\tWARN_ON_ONCE(!rcu_segcblist_test_flags(cblist, SEGCBLIST_KTHREAD_CB));\n\t\trcu_segcblist_clear_flags(cblist, SEGCBLIST_KTHREAD_CB);\n\t\tif (!rcu_segcblist_test_flags(cblist, SEGCBLIST_KTHREAD_GP))\n\t\t\tneedwake_state = true;\n\t}\n\n\tWRITE_ONCE(rdp->nocb_cb_sleep, can_sleep);\n\n\tif (rdp->nocb_cb_sleep)\n\t\ttrace_rcu_nocb_wake(rcu_state.name, rdp->cpu, TPS(\"CBSleep\"));\n\n\trcu_nocb_unlock_irqrestore(rdp, flags);\n\tif (needwake_gp)\n\t\trcu_gp_kthread_wake();\n\n\tif (needwake_state)\n\t\tswake_up_one(&rdp->nocb_state_wq);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static void nocb_cb_wait(struct rcu_data *rdp)\n{\n\tstruct rcu_segcblist *cblist = &rdp->cblist;\n\tunsigned long cur_gp_seq;\n\tunsigned long flags;\n\tbool needwake_state = false;\n\tbool needwake_gp = false;\n\tbool can_sleep = true;\n\tstruct rcu_node *rnp = rdp->mynode;\n\n\tdo {\n\t\tswait_event_interruptible_exclusive(rdp->nocb_cb_wq,\n\t\t\t\t\t\t    nocb_cb_wait_cond(rdp));\n\n\t\t// VVV Ensure CB invocation follows _sleep test.\n\t\tif (smp_load_acquire(&rdp->nocb_cb_sleep)) { // ^^^\n\t\t\tWARN_ON(signal_pending(current));\n\t\t\ttrace_rcu_nocb_wake(rcu_state.name, rdp->cpu, TPS(\"WokeEmpty\"));\n\t\t}\n\t} while (!nocb_cb_can_run(rdp));\n\n\n\tlocal_irq_save(flags);\n\trcu_momentary_dyntick_idle();\n\tlocal_irq_restore(flags);\n\t/*\n\t * Disable BH to provide the expected environment.  Also, when\n\t * transitioning to/from NOCB mode, a self-requeuing callback might\n\t * be invoked from softirq.  A short grace period could cause both\n\t * instances of this callback would execute concurrently.\n\t */\n\tlocal_bh_disable();\n\trcu_do_batch(rdp);\n\tlocal_bh_enable();\n\tlockdep_assert_irqs_enabled();\n\trcu_nocb_lock_irqsave(rdp, flags);\n\tif (rcu_segcblist_nextgp(cblist, &cur_gp_seq) &&\n\t    rcu_seq_done(&rnp->gp_seq, cur_gp_seq) &&\n\t    raw_spin_trylock_rcu_node(rnp)) { /* irqs already disabled. */\n\t\tneedwake_gp = rcu_advance_cbs(rdp->mynode, rdp);\n\t\traw_spin_unlock_rcu_node(rnp); /* irqs remain disabled. */\n\t}\n\n\tif (rcu_segcblist_test_flags(cblist, SEGCBLIST_OFFLOADED)) {\n\t\tif (!rcu_segcblist_test_flags(cblist, SEGCBLIST_KTHREAD_CB)) {\n\t\t\trcu_segcblist_set_flags(cblist, SEGCBLIST_KTHREAD_CB);\n\t\t\tif (rcu_segcblist_test_flags(cblist, SEGCBLIST_KTHREAD_GP))\n\t\t\t\tneedwake_state = true;\n\t\t}\n\t\tif (rcu_segcblist_ready_cbs(cblist))\n\t\t\tcan_sleep = false;\n\t} else {\n\t\t/*\n\t\t * De-offloading. Clear our flag and notify the de-offload worker.\n\t\t * We won't touch the callbacks and keep sleeping until we ever\n\t\t * get re-offloaded.\n\t\t */\n\t\tWARN_ON_ONCE(!rcu_segcblist_test_flags(cblist, SEGCBLIST_KTHREAD_CB));\n\t\trcu_segcblist_clear_flags(cblist, SEGCBLIST_KTHREAD_CB);\n\t\tif (!rcu_segcblist_test_flags(cblist, SEGCBLIST_KTHREAD_GP))\n\t\t\tneedwake_state = true;\n\t}\n\n\tWRITE_ONCE(rdp->nocb_cb_sleep, can_sleep);\n\n\tif (rdp->nocb_cb_sleep)\n\t\ttrace_rcu_nocb_wake(rcu_state.name, rdp->cpu, TPS(\"CBSleep\"));\n\n\trcu_nocb_unlock_irqrestore(rdp, flags);\n\tif (needwake_gp)\n\t\trcu_gp_kthread_wake();\n\n\tif (needwake_state)\n\t\tswake_up_one(&rdp->nocb_state_wq);\n}"
        }
      }
    ],
    "contextual_snippet": "static int rcu_nocb_cb_kthread(void *arg)\n{\n\tstruct rcu_data *rdp = arg;\n\n\t// Each pass through this loop does one callback batch, and,\n\t// if there are no more ready callbacks, waits for them.\n\tfor (;;) {\n\t\tnocb_cb_wait(rdp);\n\t\tcond_resched_tasks_rcu_qs();\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "nocb_cb_wait",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_nocb.h",
    "lines": "802-876",
    "snippet": "static void nocb_cb_wait(struct rcu_data *rdp)\n{\n\tstruct rcu_segcblist *cblist = &rdp->cblist;\n\tunsigned long cur_gp_seq;\n\tunsigned long flags;\n\tbool needwake_state = false;\n\tbool needwake_gp = false;\n\tbool can_sleep = true;\n\tstruct rcu_node *rnp = rdp->mynode;\n\n\tdo {\n\t\tswait_event_interruptible_exclusive(rdp->nocb_cb_wq,\n\t\t\t\t\t\t    nocb_cb_wait_cond(rdp));\n\n\t\t// VVV Ensure CB invocation follows _sleep test.\n\t\tif (smp_load_acquire(&rdp->nocb_cb_sleep)) { // ^^^\n\t\t\tWARN_ON(signal_pending(current));\n\t\t\ttrace_rcu_nocb_wake(rcu_state.name, rdp->cpu, TPS(\"WokeEmpty\"));\n\t\t}\n\t} while (!nocb_cb_can_run(rdp));\n\n\n\tlocal_irq_save(flags);\n\trcu_momentary_dyntick_idle();\n\tlocal_irq_restore(flags);\n\t/*\n\t * Disable BH to provide the expected environment.  Also, when\n\t * transitioning to/from NOCB mode, a self-requeuing callback might\n\t * be invoked from softirq.  A short grace period could cause both\n\t * instances of this callback would execute concurrently.\n\t */\n\tlocal_bh_disable();\n\trcu_do_batch(rdp);\n\tlocal_bh_enable();\n\tlockdep_assert_irqs_enabled();\n\trcu_nocb_lock_irqsave(rdp, flags);\n\tif (rcu_segcblist_nextgp(cblist, &cur_gp_seq) &&\n\t    rcu_seq_done(&rnp->gp_seq, cur_gp_seq) &&\n\t    raw_spin_trylock_rcu_node(rnp)) { /* irqs already disabled. */\n\t\tneedwake_gp = rcu_advance_cbs(rdp->mynode, rdp);\n\t\traw_spin_unlock_rcu_node(rnp); /* irqs remain disabled. */\n\t}\n\n\tif (rcu_segcblist_test_flags(cblist, SEGCBLIST_OFFLOADED)) {\n\t\tif (!rcu_segcblist_test_flags(cblist, SEGCBLIST_KTHREAD_CB)) {\n\t\t\trcu_segcblist_set_flags(cblist, SEGCBLIST_KTHREAD_CB);\n\t\t\tif (rcu_segcblist_test_flags(cblist, SEGCBLIST_KTHREAD_GP))\n\t\t\t\tneedwake_state = true;\n\t\t}\n\t\tif (rcu_segcblist_ready_cbs(cblist))\n\t\t\tcan_sleep = false;\n\t} else {\n\t\t/*\n\t\t * De-offloading. Clear our flag and notify the de-offload worker.\n\t\t * We won't touch the callbacks and keep sleeping until we ever\n\t\t * get re-offloaded.\n\t\t */\n\t\tWARN_ON_ONCE(!rcu_segcblist_test_flags(cblist, SEGCBLIST_KTHREAD_CB));\n\t\trcu_segcblist_clear_flags(cblist, SEGCBLIST_KTHREAD_CB);\n\t\tif (!rcu_segcblist_test_flags(cblist, SEGCBLIST_KTHREAD_GP))\n\t\t\tneedwake_state = true;\n\t}\n\n\tWRITE_ONCE(rdp->nocb_cb_sleep, can_sleep);\n\n\tif (rdp->nocb_cb_sleep)\n\t\ttrace_rcu_nocb_wake(rcu_state.name, rdp->cpu, TPS(\"CBSleep\"));\n\n\trcu_nocb_unlock_irqrestore(rdp, flags);\n\tif (needwake_gp)\n\t\trcu_gp_kthread_wake();\n\n\tif (needwake_state)\n\t\tswake_up_one(&rdp->nocb_state_wq);\n}",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "swake_up_one",
          "args": [
            "&rdp->nocb_state_wq"
          ],
          "line": 875
        },
        "resolved": true,
        "details": {
          "function_name": "swake_up_one",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/swait.c",
          "lines": "48-55",
          "snippet": "void swake_up_one(struct swait_queue_head *q)\n{\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&q->lock, flags);\n\tswake_up_locked(q);\n\traw_spin_unlock_irqrestore(&q->lock, flags);\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nvoid swake_up_one(struct swait_queue_head *q)\n{\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&q->lock, flags);\n\tswake_up_locked(q);\n\traw_spin_unlock_irqrestore(&q->lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_gp_kthread_wake",
          "args": [],
          "line": 872
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_gp_kthread_wake",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "1473-1483",
          "snippet": "static void rcu_gp_kthread_wake(void)\n{\n\tstruct task_struct *t = READ_ONCE(rcu_state.gp_kthread);\n\n\tif ((current == t && !in_hardirq() && !in_serving_softirq()) ||\n\t    !READ_ONCE(rcu_state.gp_flags) || !t)\n\t\treturn;\n\tWRITE_ONCE(rcu_state.gp_wake_time, jiffies);\n\tWRITE_ONCE(rcu_state.gp_wake_seq, READ_ONCE(rcu_state.gp_seq));\n\tswake_up_one(&rcu_state.gp_wq);\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\n\nstatic void rcu_gp_kthread_wake(void)\n{\n\tstruct task_struct *t = READ_ONCE(rcu_state.gp_kthread);\n\n\tif ((current == t && !in_hardirq() && !in_serving_softirq()) ||\n\t    !READ_ONCE(rcu_state.gp_flags) || !t)\n\t\treturn;\n\tWRITE_ONCE(rcu_state.gp_wake_time, jiffies);\n\tWRITE_ONCE(rcu_state.gp_wake_seq, READ_ONCE(rcu_state.gp_seq));\n\tswake_up_one(&rcu_state.gp_wq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_nocb_unlock_irqrestore",
          "args": [
            "rdp",
            "flags"
          ],
          "line": 870
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_nocb_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_nocb.h",
          "lines": "1479-1483",
          "snippet": "static void rcu_nocb_unlock_irqrestore(struct rcu_data *rdp,\n\t\t\t\t       unsigned long flags)\n{\n\tlocal_irq_restore(flags);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static void rcu_nocb_unlock_irqrestore(struct rcu_data *rdp,\n\t\t\t\t       unsigned long flags)\n{\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_rcu_nocb_wake",
          "args": [
            "rcu_state.name",
            "rdp->cpu",
            "TPS(\"CBSleep\")"
          ],
          "line": 868
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPS",
          "args": [
            "\"CBSleep\""
          ],
          "line": 868
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "rdp->nocb_cb_sleep",
            "can_sleep"
          ],
          "line": 865
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_segcblist_test_flags",
          "args": [
            "cblist",
            "SEGCBLIST_KTHREAD_GP"
          ],
          "line": 861
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_test_flags",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "68-72",
          "snippet": "static inline bool rcu_segcblist_test_flags(struct rcu_segcblist *rsclp,\n\t\t\t\t\t    int flags)\n{\n\treturn READ_ONCE(rsclp->flags) & flags;\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "long rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nlong rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_test_flags(struct rcu_segcblist *rsclp,\n\t\t\t\t\t    int flags)\n{\n\treturn READ_ONCE(rsclp->flags) & flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_segcblist_clear_flags",
          "args": [
            "cblist",
            "SEGCBLIST_KTHREAD_CB"
          ],
          "line": 860
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_clear_flags",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "62-66",
          "snippet": "static inline void rcu_segcblist_clear_flags(struct rcu_segcblist *rsclp,\n\t\t\t\t\t     int flags)\n{\n\trsclp->flags &= ~flags;\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "long rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nlong rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline void rcu_segcblist_clear_flags(struct rcu_segcblist *rsclp,\n\t\t\t\t\t     int flags)\n{\n\trsclp->flags &= ~flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!rcu_segcblist_test_flags(cblist, SEGCBLIST_KTHREAD_CB)"
          ],
          "line": 859
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_segcblist_ready_cbs",
          "args": [
            "cblist"
          ],
          "line": 851
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_ready_cbs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.c",
          "lines": "278-282",
          "snippet": "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp)\n{\n\treturn rcu_segcblist_is_enabled(rsclp) &&\n\t       &rsclp->head != READ_ONCE(rsclp->tails[RCU_DONE_TAIL]);\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/cpu.h>\n\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp)\n{\n\treturn rcu_segcblist_is_enabled(rsclp) &&\n\t       &rsclp->head != READ_ONCE(rsclp->tails[RCU_DONE_TAIL]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_segcblist_set_flags",
          "args": [
            "cblist",
            "SEGCBLIST_KTHREAD_CB"
          ],
          "line": 847
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_set_flags",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "56-60",
          "snippet": "static inline void rcu_segcblist_set_flags(struct rcu_segcblist *rsclp,\n\t\t\t\t\t   int flags)\n{\n\trsclp->flags |= flags;\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "long rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nlong rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline void rcu_segcblist_set_flags(struct rcu_segcblist *rsclp,\n\t\t\t\t\t   int flags)\n{\n\trsclp->flags |= flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_rcu_node",
          "args": [
            "rnp"
          ],
          "line": 842
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_advance_cbs",
          "args": [
            "rdp->mynode",
            "rdp"
          ],
          "line": 841
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_advance_cbs_nowake",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "1596-1606",
          "snippet": "static void __maybe_unused rcu_advance_cbs_nowake(struct rcu_node *rnp,\n\t\t\t\t\t\t  struct rcu_data *rdp)\n{\n\trcu_lockdep_assert_cblist_protected(rdp);\n\tif (!rcu_seq_state(rcu_seq_current(&rnp->gp_seq)) || !raw_spin_trylock_rcu_node(rnp))\n\t\treturn;\n\t// The grace period cannot end while we hold the rcu_node lock.\n\tif (rcu_seq_state(rcu_seq_current(&rnp->gp_seq)))\n\t\tWARN_ON_ONCE(rcu_advance_cbs(rnp, rdp));\n\traw_spin_unlock_rcu_node(rnp);\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};",
            "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
            "static void check_cb_ovld_locked(struct rcu_data *rdp, struct rcu_node *rnp);",
            "static bool rcu_rdp_is_offloaded(struct rcu_data *rdp);",
            "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void check_cb_ovld_locked(struct rcu_data *rdp, struct rcu_node *rnp);\nstatic bool rcu_rdp_is_offloaded(struct rcu_data *rdp);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nstatic void __maybe_unused rcu_advance_cbs_nowake(struct rcu_node *rnp,\n\t\t\t\t\t\t  struct rcu_data *rdp)\n{\n\trcu_lockdep_assert_cblist_protected(rdp);\n\tif (!rcu_seq_state(rcu_seq_current(&rnp->gp_seq)) || !raw_spin_trylock_rcu_node(rnp))\n\t\treturn;\n\t// The grace period cannot end while we hold the rcu_node lock.\n\tif (rcu_seq_state(rcu_seq_current(&rnp->gp_seq)))\n\t\tWARN_ON_ONCE(rcu_advance_cbs(rnp, rdp));\n\traw_spin_unlock_rcu_node(rnp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_trylock_rcu_node",
          "args": [
            "rnp"
          ],
          "line": 840
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_seq_done",
          "args": [
            "&rnp->gp_seq",
            "cur_gp_seq"
          ],
          "line": 839
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_seq_done",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu.h",
          "lines": "115-118",
          "snippet": "static inline bool rcu_seq_done(unsigned long *sp, unsigned long s)\n{\n\treturn ULONG_CMP_GE(READ_ONCE(*sp), s);\n}",
          "includes": [
            "#include <linux/rcu_node_tree.h>",
            "#include <trace/events/rcu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_node_tree.h>\n#include <trace/events/rcu.h>\n\nstatic inline bool rcu_seq_done(unsigned long *sp, unsigned long s)\n{\n\treturn ULONG_CMP_GE(READ_ONCE(*sp), s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_segcblist_nextgp",
          "args": [
            "cblist",
            "&cur_gp_seq"
          ],
          "line": 838
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_nextgp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.c",
          "lines": "323-329",
          "snippet": "bool rcu_segcblist_nextgp(struct rcu_segcblist *rsclp, unsigned long *lp)\n{\n\tif (!rcu_segcblist_pend_cbs(rsclp))\n\t\treturn false;\n\t*lp = rsclp->gp_seq[RCU_WAIT_TAIL];\n\treturn true;\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/cpu.h>\n\nbool rcu_segcblist_nextgp(struct rcu_segcblist *rsclp, unsigned long *lp)\n{\n\tif (!rcu_segcblist_pend_cbs(rsclp))\n\t\treturn false;\n\t*lp = rsclp->gp_seq[RCU_WAIT_TAIL];\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_nocb_lock_irqsave",
          "args": [
            "rdp",
            "flags"
          ],
          "line": 837
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_irqs_enabled",
          "args": [],
          "line": 836
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_bh_enable",
          "args": [],
          "line": 835
        },
        "resolved": true,
        "details": {
          "function_name": "_local_bh_enable",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/softirq.c",
          "lines": "353-357",
          "snippet": "void _local_bh_enable(void)\n{\n\tWARN_ON_ONCE(in_irq());\n\t__local_bh_enable(SOFTIRQ_DISABLE_OFFSET);\n}",
          "includes": [
            "#include <trace/events/irq.h>",
            "#include <asm/softirq_stack.h>",
            "#include <linux/wait_bit.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/smp.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/mm.h>",
            "#include <linux/local_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/irq.h>\n#include <asm/softirq_stack.h>\n#include <linux/wait_bit.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/smpboot.h>\n#include <linux/smp.h>\n#include <linux/ftrace.h>\n#include <linux/rcupdate.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/mm.h>\n#include <linux/local_lock.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/kernel_stat.h>\n#include <linux/export.h>\n\nvoid _local_bh_enable(void)\n{\n\tWARN_ON_ONCE(in_irq());\n\t__local_bh_enable(SOFTIRQ_DISABLE_OFFSET);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_do_batch",
          "args": [
            "rdp"
          ],
          "line": 834
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_do_batch",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "2465-2592",
          "snippet": "static void rcu_do_batch(struct rcu_data *rdp)\n{\n\tint div;\n\tbool __maybe_unused empty;\n\tunsigned long flags;\n\tstruct rcu_head *rhp;\n\tstruct rcu_cblist rcl = RCU_CBLIST_INITIALIZER(rcl);\n\tlong bl, count = 0;\n\tlong pending, tlimit = 0;\n\n\t/* If no callbacks are ready, just return. */\n\tif (!rcu_segcblist_ready_cbs(&rdp->cblist)) {\n\t\ttrace_rcu_batch_start(rcu_state.name,\n\t\t\t\t      rcu_segcblist_n_cbs(&rdp->cblist), 0);\n\t\ttrace_rcu_batch_end(rcu_state.name, 0,\n\t\t\t\t    !rcu_segcblist_empty(&rdp->cblist),\n\t\t\t\t    need_resched(), is_idle_task(current),\n\t\t\t\t    rcu_is_callbacks_kthread());\n\t\treturn;\n\t}\n\n\t/*\n\t * Extract the list of ready callbacks, disabling IRQs to prevent\n\t * races with call_rcu() from interrupt handlers.  Leave the\n\t * callback counts, as rcu_barrier() needs to be conservative.\n\t */\n\trcu_nocb_lock_irqsave(rdp, flags);\n\tWARN_ON_ONCE(cpu_is_offline(smp_processor_id()));\n\tpending = rcu_segcblist_n_cbs(&rdp->cblist);\n\tdiv = READ_ONCE(rcu_divisor);\n\tdiv = div < 0 ? 7 : div > sizeof(long) * 8 - 2 ? sizeof(long) * 8 - 2 : div;\n\tbl = max(rdp->blimit, pending >> div);\n\tif (in_serving_softirq() && unlikely(bl > 100)) {\n\t\tlong rrn = READ_ONCE(rcu_resched_ns);\n\n\t\trrn = rrn < NSEC_PER_MSEC ? NSEC_PER_MSEC : rrn > NSEC_PER_SEC ? NSEC_PER_SEC : rrn;\n\t\ttlimit = local_clock() + rrn;\n\t}\n\ttrace_rcu_batch_start(rcu_state.name,\n\t\t\t      rcu_segcblist_n_cbs(&rdp->cblist), bl);\n\trcu_segcblist_extract_done_cbs(&rdp->cblist, &rcl);\n\tif (rcu_rdp_is_offloaded(rdp))\n\t\trdp->qlen_last_fqs_check = rcu_segcblist_n_cbs(&rdp->cblist);\n\n\ttrace_rcu_segcb_stats(&rdp->cblist, TPS(\"SegCbDequeued\"));\n\trcu_nocb_unlock_irqrestore(rdp, flags);\n\n\t/* Invoke callbacks. */\n\ttick_dep_set_task(current, TICK_DEP_BIT_RCU);\n\trhp = rcu_cblist_dequeue(&rcl);\n\n\tfor (; rhp; rhp = rcu_cblist_dequeue(&rcl)) {\n\t\trcu_callback_t f;\n\n\t\tcount++;\n\t\tdebug_rcu_head_unqueue(rhp);\n\n\t\trcu_lock_acquire(&rcu_callback_map);\n\t\ttrace_rcu_invoke_callback(rcu_state.name, rhp);\n\n\t\tf = rhp->func;\n\t\tWRITE_ONCE(rhp->func, (rcu_callback_t)0L);\n\t\tf(rhp);\n\n\t\trcu_lock_release(&rcu_callback_map);\n\n\t\t/*\n\t\t * Stop only if limit reached and CPU has something to do.\n\t\t */\n\t\tif (in_serving_softirq()) {\n\t\t\tif (count >= bl && (need_resched() || !is_idle_task(current)))\n\t\t\t\tbreak;\n\t\t\t/*\n\t\t\t * Make sure we don't spend too much time here and deprive other\n\t\t\t * softirq vectors of CPU cycles.\n\t\t\t */\n\t\t\tif (unlikely(tlimit)) {\n\t\t\t\t/* only call local_clock() every 32 callbacks */\n\t\t\t\tif (likely((count & 31) || local_clock() < tlimit))\n\t\t\t\t\tcontinue;\n\t\t\t\t/* Exceeded the time limit, so leave. */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tlocal_bh_enable();\n\t\t\tlockdep_assert_irqs_enabled();\n\t\t\tcond_resched_tasks_rcu_qs();\n\t\t\tlockdep_assert_irqs_enabled();\n\t\t\tlocal_bh_disable();\n\t\t}\n\t}\n\n\trcu_nocb_lock_irqsave(rdp, flags);\n\trdp->n_cbs_invoked += count;\n\ttrace_rcu_batch_end(rcu_state.name, count, !!rcl.head, need_resched(),\n\t\t\t    is_idle_task(current), rcu_is_callbacks_kthread());\n\n\t/* Update counts and requeue any remaining callbacks. */\n\trcu_segcblist_insert_done_cbs(&rdp->cblist, &rcl);\n\trcu_segcblist_add_len(&rdp->cblist, -count);\n\n\t/* Reinstate batch limit if we have worked down the excess. */\n\tcount = rcu_segcblist_n_cbs(&rdp->cblist);\n\tif (rdp->blimit >= DEFAULT_MAX_RCU_BLIMIT && count <= qlowmark)\n\t\trdp->blimit = blimit;\n\n\t/* Reset ->qlen_last_fqs_check trigger if enough CBs have drained. */\n\tif (count == 0 && rdp->qlen_last_fqs_check != 0) {\n\t\trdp->qlen_last_fqs_check = 0;\n\t\trdp->n_force_qs_snap = READ_ONCE(rcu_state.n_force_qs);\n\t} else if (count < rdp->qlen_last_fqs_check - qhimark)\n\t\trdp->qlen_last_fqs_check = count;\n\n\t/*\n\t * The following usually indicates a double call_rcu().  To track\n\t * this down, try building with CONFIG_DEBUG_OBJECTS_RCU_HEAD=y.\n\t */\n\tempty = rcu_segcblist_empty(&rdp->cblist);\n\tWARN_ON_ONCE(count == 0 && !empty);\n\tWARN_ON_ONCE(!IS_ENABLED(CONFIG_RCU_NOCB_CPU) &&\n\t\t     count != 0 && empty);\n\tWARN_ON_ONCE(count == 0 && rcu_segcblist_n_segment_cbs(&rdp->cblist) != 0);\n\tWARN_ON_ONCE(!empty && rcu_segcblist_n_segment_cbs(&rdp->cblist) == 0);\n\n\trcu_nocb_unlock_irqrestore(rdp, flags);\n\n\ttick_dep_clear_task(current, TICK_DEP_BIT_RCU);\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define DEFAULT_MAX_RCU_BLIMIT 10000 // ... even during callback flood."
          ],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};",
            "static struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};",
            "static void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);",
            "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
            "static bool rcu_rdp_is_offloaded(struct rcu_data *rdp);",
            "static long blimit = DEFAULT_RCU_BLIMIT;",
            "static long qhimark = DEFAULT_RCU_QHIMARK;",
            "static long qlowmark = DEFAULT_RCU_QLOMARK;",
            "static int rcu_divisor = 7;",
            "static long rcu_resched_ns = 3 * NSEC_PER_MSEC;",
            "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define DEFAULT_MAX_RCU_BLIMIT 10000 // ... even during callback flood.\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};\nstatic struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\nstatic void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic bool rcu_rdp_is_offloaded(struct rcu_data *rdp);\nstatic long blimit = DEFAULT_RCU_BLIMIT;\nstatic long qhimark = DEFAULT_RCU_QHIMARK;\nstatic long qlowmark = DEFAULT_RCU_QLOMARK;\nstatic int rcu_divisor = 7;\nstatic long rcu_resched_ns = 3 * NSEC_PER_MSEC;\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nstatic void rcu_do_batch(struct rcu_data *rdp)\n{\n\tint div;\n\tbool __maybe_unused empty;\n\tunsigned long flags;\n\tstruct rcu_head *rhp;\n\tstruct rcu_cblist rcl = RCU_CBLIST_INITIALIZER(rcl);\n\tlong bl, count = 0;\n\tlong pending, tlimit = 0;\n\n\t/* If no callbacks are ready, just return. */\n\tif (!rcu_segcblist_ready_cbs(&rdp->cblist)) {\n\t\ttrace_rcu_batch_start(rcu_state.name,\n\t\t\t\t      rcu_segcblist_n_cbs(&rdp->cblist), 0);\n\t\ttrace_rcu_batch_end(rcu_state.name, 0,\n\t\t\t\t    !rcu_segcblist_empty(&rdp->cblist),\n\t\t\t\t    need_resched(), is_idle_task(current),\n\t\t\t\t    rcu_is_callbacks_kthread());\n\t\treturn;\n\t}\n\n\t/*\n\t * Extract the list of ready callbacks, disabling IRQs to prevent\n\t * races with call_rcu() from interrupt handlers.  Leave the\n\t * callback counts, as rcu_barrier() needs to be conservative.\n\t */\n\trcu_nocb_lock_irqsave(rdp, flags);\n\tWARN_ON_ONCE(cpu_is_offline(smp_processor_id()));\n\tpending = rcu_segcblist_n_cbs(&rdp->cblist);\n\tdiv = READ_ONCE(rcu_divisor);\n\tdiv = div < 0 ? 7 : div > sizeof(long) * 8 - 2 ? sizeof(long) * 8 - 2 : div;\n\tbl = max(rdp->blimit, pending >> div);\n\tif (in_serving_softirq() && unlikely(bl > 100)) {\n\t\tlong rrn = READ_ONCE(rcu_resched_ns);\n\n\t\trrn = rrn < NSEC_PER_MSEC ? NSEC_PER_MSEC : rrn > NSEC_PER_SEC ? NSEC_PER_SEC : rrn;\n\t\ttlimit = local_clock() + rrn;\n\t}\n\ttrace_rcu_batch_start(rcu_state.name,\n\t\t\t      rcu_segcblist_n_cbs(&rdp->cblist), bl);\n\trcu_segcblist_extract_done_cbs(&rdp->cblist, &rcl);\n\tif (rcu_rdp_is_offloaded(rdp))\n\t\trdp->qlen_last_fqs_check = rcu_segcblist_n_cbs(&rdp->cblist);\n\n\ttrace_rcu_segcb_stats(&rdp->cblist, TPS(\"SegCbDequeued\"));\n\trcu_nocb_unlock_irqrestore(rdp, flags);\n\n\t/* Invoke callbacks. */\n\ttick_dep_set_task(current, TICK_DEP_BIT_RCU);\n\trhp = rcu_cblist_dequeue(&rcl);\n\n\tfor (; rhp; rhp = rcu_cblist_dequeue(&rcl)) {\n\t\trcu_callback_t f;\n\n\t\tcount++;\n\t\tdebug_rcu_head_unqueue(rhp);\n\n\t\trcu_lock_acquire(&rcu_callback_map);\n\t\ttrace_rcu_invoke_callback(rcu_state.name, rhp);\n\n\t\tf = rhp->func;\n\t\tWRITE_ONCE(rhp->func, (rcu_callback_t)0L);\n\t\tf(rhp);\n\n\t\trcu_lock_release(&rcu_callback_map);\n\n\t\t/*\n\t\t * Stop only if limit reached and CPU has something to do.\n\t\t */\n\t\tif (in_serving_softirq()) {\n\t\t\tif (count >= bl && (need_resched() || !is_idle_task(current)))\n\t\t\t\tbreak;\n\t\t\t/*\n\t\t\t * Make sure we don't spend too much time here and deprive other\n\t\t\t * softirq vectors of CPU cycles.\n\t\t\t */\n\t\t\tif (unlikely(tlimit)) {\n\t\t\t\t/* only call local_clock() every 32 callbacks */\n\t\t\t\tif (likely((count & 31) || local_clock() < tlimit))\n\t\t\t\t\tcontinue;\n\t\t\t\t/* Exceeded the time limit, so leave. */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tlocal_bh_enable();\n\t\t\tlockdep_assert_irqs_enabled();\n\t\t\tcond_resched_tasks_rcu_qs();\n\t\t\tlockdep_assert_irqs_enabled();\n\t\t\tlocal_bh_disable();\n\t\t}\n\t}\n\n\trcu_nocb_lock_irqsave(rdp, flags);\n\trdp->n_cbs_invoked += count;\n\ttrace_rcu_batch_end(rcu_state.name, count, !!rcl.head, need_resched(),\n\t\t\t    is_idle_task(current), rcu_is_callbacks_kthread());\n\n\t/* Update counts and requeue any remaining callbacks. */\n\trcu_segcblist_insert_done_cbs(&rdp->cblist, &rcl);\n\trcu_segcblist_add_len(&rdp->cblist, -count);\n\n\t/* Reinstate batch limit if we have worked down the excess. */\n\tcount = rcu_segcblist_n_cbs(&rdp->cblist);\n\tif (rdp->blimit >= DEFAULT_MAX_RCU_BLIMIT && count <= qlowmark)\n\t\trdp->blimit = blimit;\n\n\t/* Reset ->qlen_last_fqs_check trigger if enough CBs have drained. */\n\tif (count == 0 && rdp->qlen_last_fqs_check != 0) {\n\t\trdp->qlen_last_fqs_check = 0;\n\t\trdp->n_force_qs_snap = READ_ONCE(rcu_state.n_force_qs);\n\t} else if (count < rdp->qlen_last_fqs_check - qhimark)\n\t\trdp->qlen_last_fqs_check = count;\n\n\t/*\n\t * The following usually indicates a double call_rcu().  To track\n\t * this down, try building with CONFIG_DEBUG_OBJECTS_RCU_HEAD=y.\n\t */\n\tempty = rcu_segcblist_empty(&rdp->cblist);\n\tWARN_ON_ONCE(count == 0 && !empty);\n\tWARN_ON_ONCE(!IS_ENABLED(CONFIG_RCU_NOCB_CPU) &&\n\t\t     count != 0 && empty);\n\tWARN_ON_ONCE(count == 0 && rcu_segcblist_n_segment_cbs(&rdp->cblist) != 0);\n\tWARN_ON_ONCE(!empty && rcu_segcblist_n_segment_cbs(&rdp->cblist) == 0);\n\n\trcu_nocb_unlock_irqrestore(rdp, flags);\n\n\ttick_dep_clear_task(current, TICK_DEP_BIT_RCU);\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_bh_disable",
          "args": [],
          "line": 833
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 826
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_momentary_dyntick_idle",
          "args": [],
          "line": 825
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_momentary_dyntick_idle",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "402-411",
          "snippet": "notrace void rcu_momentary_dyntick_idle(void)\n{\n\tint seq;\n\n\traw_cpu_write(rcu_data.rcu_need_heavy_qs, false);\n\tseq = rcu_dynticks_inc(2);\n\t/* It is illegal to call this from idle state. */\n\tWARN_ON_ONCE(!(seq & 0x1));\n\trcu_preempt_deferred_qs(current);\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};\n\nnotrace void rcu_momentary_dyntick_idle(void)\n{\n\tint seq;\n\n\traw_cpu_write(rcu_data.rcu_need_heavy_qs, false);\n\tseq = rcu_dynticks_inc(2);\n\t/* It is illegal to call this from idle state. */\n\tWARN_ON_ONCE(!(seq & 0x1));\n\trcu_preempt_deferred_qs(current);\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_irq_save",
          "args": [
            "flags"
          ],
          "line": 824
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nocb_cb_can_run",
          "args": [
            "rdp"
          ],
          "line": 821
        },
        "resolved": true,
        "details": {
          "function_name": "nocb_cb_can_run",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_nocb.h",
          "lines": "786-791",
          "snippet": "static inline bool nocb_cb_can_run(struct rcu_data *rdp)\n{\n\tu8 flags = SEGCBLIST_OFFLOADED | SEGCBLIST_KTHREAD_CB;\n\n\treturn rcu_segcblist_test_flags(&rdp->cblist, flags);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline bool nocb_cb_can_run(struct rcu_data *rdp)\n{\n\tu8 flags = SEGCBLIST_OFFLOADED | SEGCBLIST_KTHREAD_CB;\n\n\treturn rcu_segcblist_test_flags(&rdp->cblist, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_rcu_nocb_wake",
          "args": [
            "rcu_state.name",
            "rdp->cpu",
            "TPS(\"WokeEmpty\")"
          ],
          "line": 819
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPS",
          "args": [
            "\"WokeEmpty\""
          ],
          "line": 819
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "signal_pending(current)"
          ],
          "line": 818
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "signal_pending",
          "args": [
            "current"
          ],
          "line": 818
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_load_acquire",
          "args": [
            "&rdp->nocb_cb_sleep"
          ],
          "line": 817
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swait_event_interruptible_exclusive",
          "args": [
            "rdp->nocb_cb_wq",
            "nocb_cb_wait_cond(rdp)"
          ],
          "line": 813
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nocb_cb_wait_cond",
          "args": [
            "rdp"
          ],
          "line": 814
        },
        "resolved": true,
        "details": {
          "function_name": "nocb_cb_wait_cond",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_nocb.h",
          "lines": "793-796",
          "snippet": "static inline bool nocb_cb_wait_cond(struct rcu_data *rdp)\n{\n\treturn nocb_cb_can_run(rdp) && !READ_ONCE(rdp->nocb_cb_sleep);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline bool nocb_cb_wait_cond(struct rcu_data *rdp)\n{\n\treturn nocb_cb_can_run(rdp) && !READ_ONCE(rdp->nocb_cb_sleep);\n}"
        }
      }
    ],
    "contextual_snippet": "static void nocb_cb_wait(struct rcu_data *rdp)\n{\n\tstruct rcu_segcblist *cblist = &rdp->cblist;\n\tunsigned long cur_gp_seq;\n\tunsigned long flags;\n\tbool needwake_state = false;\n\tbool needwake_gp = false;\n\tbool can_sleep = true;\n\tstruct rcu_node *rnp = rdp->mynode;\n\n\tdo {\n\t\tswait_event_interruptible_exclusive(rdp->nocb_cb_wq,\n\t\t\t\t\t\t    nocb_cb_wait_cond(rdp));\n\n\t\t// VVV Ensure CB invocation follows _sleep test.\n\t\tif (smp_load_acquire(&rdp->nocb_cb_sleep)) { // ^^^\n\t\t\tWARN_ON(signal_pending(current));\n\t\t\ttrace_rcu_nocb_wake(rcu_state.name, rdp->cpu, TPS(\"WokeEmpty\"));\n\t\t}\n\t} while (!nocb_cb_can_run(rdp));\n\n\n\tlocal_irq_save(flags);\n\trcu_momentary_dyntick_idle();\n\tlocal_irq_restore(flags);\n\t/*\n\t * Disable BH to provide the expected environment.  Also, when\n\t * transitioning to/from NOCB mode, a self-requeuing callback might\n\t * be invoked from softirq.  A short grace period could cause both\n\t * instances of this callback would execute concurrently.\n\t */\n\tlocal_bh_disable();\n\trcu_do_batch(rdp);\n\tlocal_bh_enable();\n\tlockdep_assert_irqs_enabled();\n\trcu_nocb_lock_irqsave(rdp, flags);\n\tif (rcu_segcblist_nextgp(cblist, &cur_gp_seq) &&\n\t    rcu_seq_done(&rnp->gp_seq, cur_gp_seq) &&\n\t    raw_spin_trylock_rcu_node(rnp)) { /* irqs already disabled. */\n\t\tneedwake_gp = rcu_advance_cbs(rdp->mynode, rdp);\n\t\traw_spin_unlock_rcu_node(rnp); /* irqs remain disabled. */\n\t}\n\n\tif (rcu_segcblist_test_flags(cblist, SEGCBLIST_OFFLOADED)) {\n\t\tif (!rcu_segcblist_test_flags(cblist, SEGCBLIST_KTHREAD_CB)) {\n\t\t\trcu_segcblist_set_flags(cblist, SEGCBLIST_KTHREAD_CB);\n\t\t\tif (rcu_segcblist_test_flags(cblist, SEGCBLIST_KTHREAD_GP))\n\t\t\t\tneedwake_state = true;\n\t\t}\n\t\tif (rcu_segcblist_ready_cbs(cblist))\n\t\t\tcan_sleep = false;\n\t} else {\n\t\t/*\n\t\t * De-offloading. Clear our flag and notify the de-offload worker.\n\t\t * We won't touch the callbacks and keep sleeping until we ever\n\t\t * get re-offloaded.\n\t\t */\n\t\tWARN_ON_ONCE(!rcu_segcblist_test_flags(cblist, SEGCBLIST_KTHREAD_CB));\n\t\trcu_segcblist_clear_flags(cblist, SEGCBLIST_KTHREAD_CB);\n\t\tif (!rcu_segcblist_test_flags(cblist, SEGCBLIST_KTHREAD_GP))\n\t\t\tneedwake_state = true;\n\t}\n\n\tWRITE_ONCE(rdp->nocb_cb_sleep, can_sleep);\n\n\tif (rdp->nocb_cb_sleep)\n\t\ttrace_rcu_nocb_wake(rcu_state.name, rdp->cpu, TPS(\"CBSleep\"));\n\n\trcu_nocb_unlock_irqrestore(rdp, flags);\n\tif (needwake_gp)\n\t\trcu_gp_kthread_wake();\n\n\tif (needwake_state)\n\t\tswake_up_one(&rdp->nocb_state_wq);\n}"
  },
  {
    "function_name": "nocb_cb_wait_cond",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_nocb.h",
    "lines": "793-796",
    "snippet": "static inline bool nocb_cb_wait_cond(struct rcu_data *rdp)\n{\n\treturn nocb_cb_can_run(rdp) && !READ_ONCE(rdp->nocb_cb_sleep);\n}",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rdp->nocb_cb_sleep"
          ],
          "line": 795
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nocb_cb_can_run",
          "args": [
            "rdp"
          ],
          "line": 795
        },
        "resolved": true,
        "details": {
          "function_name": "nocb_cb_can_run",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_nocb.h",
          "lines": "786-791",
          "snippet": "static inline bool nocb_cb_can_run(struct rcu_data *rdp)\n{\n\tu8 flags = SEGCBLIST_OFFLOADED | SEGCBLIST_KTHREAD_CB;\n\n\treturn rcu_segcblist_test_flags(&rdp->cblist, flags);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline bool nocb_cb_can_run(struct rcu_data *rdp)\n{\n\tu8 flags = SEGCBLIST_OFFLOADED | SEGCBLIST_KTHREAD_CB;\n\n\treturn rcu_segcblist_test_flags(&rdp->cblist, flags);\n}"
        }
      }
    ],
    "contextual_snippet": "static inline bool nocb_cb_wait_cond(struct rcu_data *rdp)\n{\n\treturn nocb_cb_can_run(rdp) && !READ_ONCE(rdp->nocb_cb_sleep);\n}"
  },
  {
    "function_name": "nocb_cb_can_run",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_nocb.h",
    "lines": "786-791",
    "snippet": "static inline bool nocb_cb_can_run(struct rcu_data *rdp)\n{\n\tu8 flags = SEGCBLIST_OFFLOADED | SEGCBLIST_KTHREAD_CB;\n\n\treturn rcu_segcblist_test_flags(&rdp->cblist, flags);\n}",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_segcblist_test_flags",
          "args": [
            "&rdp->cblist",
            "flags"
          ],
          "line": 790
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_test_flags",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "68-72",
          "snippet": "static inline bool rcu_segcblist_test_flags(struct rcu_segcblist *rsclp,\n\t\t\t\t\t    int flags)\n{\n\treturn READ_ONCE(rsclp->flags) & flags;\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "long rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nlong rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_test_flags(struct rcu_segcblist *rsclp,\n\t\t\t\t\t    int flags)\n{\n\treturn READ_ONCE(rsclp->flags) & flags;\n}"
        }
      }
    ],
    "contextual_snippet": "static inline bool nocb_cb_can_run(struct rcu_data *rdp)\n{\n\tu8 flags = SEGCBLIST_OFFLOADED | SEGCBLIST_KTHREAD_CB;\n\n\treturn rcu_segcblist_test_flags(&rdp->cblist, flags);\n}"
  },
  {
    "function_name": "rcu_nocb_gp_kthread",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_nocb.h",
    "lines": "774-784",
    "snippet": "static int rcu_nocb_gp_kthread(void *arg)\n{\n\tstruct rcu_data *rdp = arg;\n\n\tfor (;;) {\n\t\tWRITE_ONCE(rdp->nocb_gp_loops, rdp->nocb_gp_loops + 1);\n\t\tnocb_gp_wait(rdp);\n\t\tcond_resched_tasks_rcu_qs();\n\t}\n\treturn 0;\n}",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cond_resched_tasks_rcu_qs",
          "args": [],
          "line": 781
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nocb_gp_wait",
          "args": [
            "rdp"
          ],
          "line": 780
        },
        "resolved": true,
        "details": {
          "function_name": "nocb_gp_wait",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_nocb.h",
          "lines": "611-764",
          "snippet": "static void nocb_gp_wait(struct rcu_data *my_rdp)\n{\n\tbool bypass = false;\n\tlong bypass_ncbs;\n\tint __maybe_unused cpu = my_rdp->cpu;\n\tunsigned long cur_gp_seq;\n\tunsigned long flags;\n\tbool gotcbs = false;\n\tunsigned long j = jiffies;\n\tbool needwait_gp = false; // This prevents actual uninitialized use.\n\tbool needwake;\n\tbool needwake_gp;\n\tstruct rcu_data *rdp;\n\tstruct rcu_node *rnp;\n\tunsigned long wait_gp_seq = 0; // Suppress \"use uninitialized\" warning.\n\tbool wasempty = false;\n\n\t/*\n\t * Each pass through the following loop checks for CBs and for the\n\t * nearest grace period (if any) to wait for next.  The CB kthreads\n\t * and the global grace-period kthread are awakened if needed.\n\t */\n\tWARN_ON_ONCE(my_rdp->nocb_gp_rdp != my_rdp);\n\t/*\n\t * An rcu_data structure is removed from the list after its\n\t * CPU is de-offloaded and added to the list before that CPU is\n\t * (re-)offloaded.  If the following loop happens to be referencing\n\t * that rcu_data structure during the time that the corresponding\n\t * CPU is de-offloaded and then immediately re-offloaded, this\n\t * loop's rdp pointer will be carried to the end of the list by\n\t * the resulting pair of list operations.  This can cause the loop\n\t * to skip over some of the rcu_data structures that were supposed\n\t * to have been scanned.  Fortunately a new iteration through the\n\t * entire loop is forced after a given CPU's rcu_data structure\n\t * is added to the list, so the skipped-over rcu_data structures\n\t * won't be ignored for long.\n\t */\n\tlist_for_each_entry_rcu(rdp, &my_rdp->nocb_head_rdp, nocb_entry_rdp, 1) {\n\t\tbool needwake_state = false;\n\n\t\tif (!nocb_gp_enabled_cb(rdp))\n\t\t\tcontinue;\n\t\ttrace_rcu_nocb_wake(rcu_state.name, rdp->cpu, TPS(\"Check\"));\n\t\trcu_nocb_lock_irqsave(rdp, flags);\n\t\tif (nocb_gp_update_state_deoffloading(rdp, &needwake_state)) {\n\t\t\trcu_nocb_unlock_irqrestore(rdp, flags);\n\t\t\tif (needwake_state)\n\t\t\t\tswake_up_one(&rdp->nocb_state_wq);\n\t\t\tcontinue;\n\t\t}\n\t\tbypass_ncbs = rcu_cblist_n_cbs(&rdp->nocb_bypass);\n\t\tif (bypass_ncbs &&\n\t\t    (time_after(j, READ_ONCE(rdp->nocb_bypass_first) + 1) ||\n\t\t     bypass_ncbs > 2 * qhimark)) {\n\t\t\t// Bypass full or old, so flush it.\n\t\t\t(void)rcu_nocb_try_flush_bypass(rdp, j);\n\t\t\tbypass_ncbs = rcu_cblist_n_cbs(&rdp->nocb_bypass);\n\t\t} else if (!bypass_ncbs && rcu_segcblist_empty(&rdp->cblist)) {\n\t\t\trcu_nocb_unlock_irqrestore(rdp, flags);\n\t\t\tif (needwake_state)\n\t\t\t\tswake_up_one(&rdp->nocb_state_wq);\n\t\t\tcontinue; /* No callbacks here, try next. */\n\t\t}\n\t\tif (bypass_ncbs) {\n\t\t\ttrace_rcu_nocb_wake(rcu_state.name, rdp->cpu,\n\t\t\t\t\t    TPS(\"Bypass\"));\n\t\t\tbypass = true;\n\t\t}\n\t\trnp = rdp->mynode;\n\n\t\t// Advance callbacks if helpful and low contention.\n\t\tneedwake_gp = false;\n\t\tif (!rcu_segcblist_restempty(&rdp->cblist,\n\t\t\t\t\t     RCU_NEXT_READY_TAIL) ||\n\t\t    (rcu_segcblist_nextgp(&rdp->cblist, &cur_gp_seq) &&\n\t\t     rcu_seq_done(&rnp->gp_seq, cur_gp_seq))) {\n\t\t\traw_spin_lock_rcu_node(rnp); /* irqs disabled. */\n\t\t\tneedwake_gp = rcu_advance_cbs(rnp, rdp);\n\t\t\twasempty = rcu_segcblist_restempty(&rdp->cblist,\n\t\t\t\t\t\t\t   RCU_NEXT_READY_TAIL);\n\t\t\traw_spin_unlock_rcu_node(rnp); /* irqs disabled. */\n\t\t}\n\t\t// Need to wait on some grace period?\n\t\tWARN_ON_ONCE(wasempty &&\n\t\t\t     !rcu_segcblist_restempty(&rdp->cblist,\n\t\t\t\t\t\t      RCU_NEXT_READY_TAIL));\n\t\tif (rcu_segcblist_nextgp(&rdp->cblist, &cur_gp_seq)) {\n\t\t\tif (!needwait_gp ||\n\t\t\t    ULONG_CMP_LT(cur_gp_seq, wait_gp_seq))\n\t\t\t\twait_gp_seq = cur_gp_seq;\n\t\t\tneedwait_gp = true;\n\t\t\ttrace_rcu_nocb_wake(rcu_state.name, rdp->cpu,\n\t\t\t\t\t    TPS(\"NeedWaitGP\"));\n\t\t}\n\t\tif (rcu_segcblist_ready_cbs(&rdp->cblist)) {\n\t\t\tneedwake = rdp->nocb_cb_sleep;\n\t\t\tWRITE_ONCE(rdp->nocb_cb_sleep, false);\n\t\t\tsmp_mb(); /* CB invocation -after- GP end. */\n\t\t} else {\n\t\t\tneedwake = false;\n\t\t}\n\t\trcu_nocb_unlock_irqrestore(rdp, flags);\n\t\tif (needwake) {\n\t\t\tswake_up_one(&rdp->nocb_cb_wq);\n\t\t\tgotcbs = true;\n\t\t}\n\t\tif (needwake_gp)\n\t\t\trcu_gp_kthread_wake();\n\t\tif (needwake_state)\n\t\t\tswake_up_one(&rdp->nocb_state_wq);\n\t}\n\n\tmy_rdp->nocb_gp_bypass = bypass;\n\tmy_rdp->nocb_gp_gp = needwait_gp;\n\tmy_rdp->nocb_gp_seq = needwait_gp ? wait_gp_seq : 0;\n\n\tif (bypass && !rcu_nocb_poll) {\n\t\t// At least one child with non-empty ->nocb_bypass, so set\n\t\t// timer in order to avoid stranding its callbacks.\n\t\twake_nocb_gp_defer(my_rdp, RCU_NOCB_WAKE_BYPASS,\n\t\t\t\t   TPS(\"WakeBypassIsDeferred\"));\n\t}\n\tif (rcu_nocb_poll) {\n\t\t/* Polling, so trace if first poll in the series. */\n\t\tif (gotcbs)\n\t\t\ttrace_rcu_nocb_wake(rcu_state.name, cpu, TPS(\"Poll\"));\n\t\tschedule_timeout_idle(1);\n\t} else if (!needwait_gp) {\n\t\t/* Wait for callbacks to appear. */\n\t\ttrace_rcu_nocb_wake(rcu_state.name, cpu, TPS(\"Sleep\"));\n\t\tswait_event_interruptible_exclusive(my_rdp->nocb_gp_wq,\n\t\t\t\t!READ_ONCE(my_rdp->nocb_gp_sleep));\n\t\ttrace_rcu_nocb_wake(rcu_state.name, cpu, TPS(\"EndSleep\"));\n\t} else {\n\t\trnp = my_rdp->mynode;\n\t\ttrace_rcu_this_gp(rnp, my_rdp, wait_gp_seq, TPS(\"StartWait\"));\n\t\tswait_event_interruptible_exclusive(\n\t\t\trnp->nocb_gp_wq[rcu_seq_ctr(wait_gp_seq) & 0x1],\n\t\t\trcu_seq_done(&rnp->gp_seq, wait_gp_seq) ||\n\t\t\t!READ_ONCE(my_rdp->nocb_gp_sleep));\n\t\ttrace_rcu_this_gp(rnp, my_rdp, wait_gp_seq, TPS(\"EndWait\"));\n\t}\n\tif (!rcu_nocb_poll) {\n\t\traw_spin_lock_irqsave(&my_rdp->nocb_gp_lock, flags);\n\t\tif (my_rdp->nocb_defer_wakeup > RCU_NOCB_WAKE_NOT) {\n\t\t\tWRITE_ONCE(my_rdp->nocb_defer_wakeup, RCU_NOCB_WAKE_NOT);\n\t\t\tdel_timer(&my_rdp->nocb_timer);\n\t\t}\n\t\tWRITE_ONCE(my_rdp->nocb_gp_sleep, true);\n\t\traw_spin_unlock_irqrestore(&my_rdp->nocb_gp_lock, flags);\n\t}\n\tmy_rdp->nocb_gp_seq = -1;\n\tWARN_ON(signal_pending(current));\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static void nocb_gp_wait(struct rcu_data *my_rdp)\n{\n\tbool bypass = false;\n\tlong bypass_ncbs;\n\tint __maybe_unused cpu = my_rdp->cpu;\n\tunsigned long cur_gp_seq;\n\tunsigned long flags;\n\tbool gotcbs = false;\n\tunsigned long j = jiffies;\n\tbool needwait_gp = false; // This prevents actual uninitialized use.\n\tbool needwake;\n\tbool needwake_gp;\n\tstruct rcu_data *rdp;\n\tstruct rcu_node *rnp;\n\tunsigned long wait_gp_seq = 0; // Suppress \"use uninitialized\" warning.\n\tbool wasempty = false;\n\n\t/*\n\t * Each pass through the following loop checks for CBs and for the\n\t * nearest grace period (if any) to wait for next.  The CB kthreads\n\t * and the global grace-period kthread are awakened if needed.\n\t */\n\tWARN_ON_ONCE(my_rdp->nocb_gp_rdp != my_rdp);\n\t/*\n\t * An rcu_data structure is removed from the list after its\n\t * CPU is de-offloaded and added to the list before that CPU is\n\t * (re-)offloaded.  If the following loop happens to be referencing\n\t * that rcu_data structure during the time that the corresponding\n\t * CPU is de-offloaded and then immediately re-offloaded, this\n\t * loop's rdp pointer will be carried to the end of the list by\n\t * the resulting pair of list operations.  This can cause the loop\n\t * to skip over some of the rcu_data structures that were supposed\n\t * to have been scanned.  Fortunately a new iteration through the\n\t * entire loop is forced after a given CPU's rcu_data structure\n\t * is added to the list, so the skipped-over rcu_data structures\n\t * won't be ignored for long.\n\t */\n\tlist_for_each_entry_rcu(rdp, &my_rdp->nocb_head_rdp, nocb_entry_rdp, 1) {\n\t\tbool needwake_state = false;\n\n\t\tif (!nocb_gp_enabled_cb(rdp))\n\t\t\tcontinue;\n\t\ttrace_rcu_nocb_wake(rcu_state.name, rdp->cpu, TPS(\"Check\"));\n\t\trcu_nocb_lock_irqsave(rdp, flags);\n\t\tif (nocb_gp_update_state_deoffloading(rdp, &needwake_state)) {\n\t\t\trcu_nocb_unlock_irqrestore(rdp, flags);\n\t\t\tif (needwake_state)\n\t\t\t\tswake_up_one(&rdp->nocb_state_wq);\n\t\t\tcontinue;\n\t\t}\n\t\tbypass_ncbs = rcu_cblist_n_cbs(&rdp->nocb_bypass);\n\t\tif (bypass_ncbs &&\n\t\t    (time_after(j, READ_ONCE(rdp->nocb_bypass_first) + 1) ||\n\t\t     bypass_ncbs > 2 * qhimark)) {\n\t\t\t// Bypass full or old, so flush it.\n\t\t\t(void)rcu_nocb_try_flush_bypass(rdp, j);\n\t\t\tbypass_ncbs = rcu_cblist_n_cbs(&rdp->nocb_bypass);\n\t\t} else if (!bypass_ncbs && rcu_segcblist_empty(&rdp->cblist)) {\n\t\t\trcu_nocb_unlock_irqrestore(rdp, flags);\n\t\t\tif (needwake_state)\n\t\t\t\tswake_up_one(&rdp->nocb_state_wq);\n\t\t\tcontinue; /* No callbacks here, try next. */\n\t\t}\n\t\tif (bypass_ncbs) {\n\t\t\ttrace_rcu_nocb_wake(rcu_state.name, rdp->cpu,\n\t\t\t\t\t    TPS(\"Bypass\"));\n\t\t\tbypass = true;\n\t\t}\n\t\trnp = rdp->mynode;\n\n\t\t// Advance callbacks if helpful and low contention.\n\t\tneedwake_gp = false;\n\t\tif (!rcu_segcblist_restempty(&rdp->cblist,\n\t\t\t\t\t     RCU_NEXT_READY_TAIL) ||\n\t\t    (rcu_segcblist_nextgp(&rdp->cblist, &cur_gp_seq) &&\n\t\t     rcu_seq_done(&rnp->gp_seq, cur_gp_seq))) {\n\t\t\traw_spin_lock_rcu_node(rnp); /* irqs disabled. */\n\t\t\tneedwake_gp = rcu_advance_cbs(rnp, rdp);\n\t\t\twasempty = rcu_segcblist_restempty(&rdp->cblist,\n\t\t\t\t\t\t\t   RCU_NEXT_READY_TAIL);\n\t\t\traw_spin_unlock_rcu_node(rnp); /* irqs disabled. */\n\t\t}\n\t\t// Need to wait on some grace period?\n\t\tWARN_ON_ONCE(wasempty &&\n\t\t\t     !rcu_segcblist_restempty(&rdp->cblist,\n\t\t\t\t\t\t      RCU_NEXT_READY_TAIL));\n\t\tif (rcu_segcblist_nextgp(&rdp->cblist, &cur_gp_seq)) {\n\t\t\tif (!needwait_gp ||\n\t\t\t    ULONG_CMP_LT(cur_gp_seq, wait_gp_seq))\n\t\t\t\twait_gp_seq = cur_gp_seq;\n\t\t\tneedwait_gp = true;\n\t\t\ttrace_rcu_nocb_wake(rcu_state.name, rdp->cpu,\n\t\t\t\t\t    TPS(\"NeedWaitGP\"));\n\t\t}\n\t\tif (rcu_segcblist_ready_cbs(&rdp->cblist)) {\n\t\t\tneedwake = rdp->nocb_cb_sleep;\n\t\t\tWRITE_ONCE(rdp->nocb_cb_sleep, false);\n\t\t\tsmp_mb(); /* CB invocation -after- GP end. */\n\t\t} else {\n\t\t\tneedwake = false;\n\t\t}\n\t\trcu_nocb_unlock_irqrestore(rdp, flags);\n\t\tif (needwake) {\n\t\t\tswake_up_one(&rdp->nocb_cb_wq);\n\t\t\tgotcbs = true;\n\t\t}\n\t\tif (needwake_gp)\n\t\t\trcu_gp_kthread_wake();\n\t\tif (needwake_state)\n\t\t\tswake_up_one(&rdp->nocb_state_wq);\n\t}\n\n\tmy_rdp->nocb_gp_bypass = bypass;\n\tmy_rdp->nocb_gp_gp = needwait_gp;\n\tmy_rdp->nocb_gp_seq = needwait_gp ? wait_gp_seq : 0;\n\n\tif (bypass && !rcu_nocb_poll) {\n\t\t// At least one child with non-empty ->nocb_bypass, so set\n\t\t// timer in order to avoid stranding its callbacks.\n\t\twake_nocb_gp_defer(my_rdp, RCU_NOCB_WAKE_BYPASS,\n\t\t\t\t   TPS(\"WakeBypassIsDeferred\"));\n\t}\n\tif (rcu_nocb_poll) {\n\t\t/* Polling, so trace if first poll in the series. */\n\t\tif (gotcbs)\n\t\t\ttrace_rcu_nocb_wake(rcu_state.name, cpu, TPS(\"Poll\"));\n\t\tschedule_timeout_idle(1);\n\t} else if (!needwait_gp) {\n\t\t/* Wait for callbacks to appear. */\n\t\ttrace_rcu_nocb_wake(rcu_state.name, cpu, TPS(\"Sleep\"));\n\t\tswait_event_interruptible_exclusive(my_rdp->nocb_gp_wq,\n\t\t\t\t!READ_ONCE(my_rdp->nocb_gp_sleep));\n\t\ttrace_rcu_nocb_wake(rcu_state.name, cpu, TPS(\"EndSleep\"));\n\t} else {\n\t\trnp = my_rdp->mynode;\n\t\ttrace_rcu_this_gp(rnp, my_rdp, wait_gp_seq, TPS(\"StartWait\"));\n\t\tswait_event_interruptible_exclusive(\n\t\t\trnp->nocb_gp_wq[rcu_seq_ctr(wait_gp_seq) & 0x1],\n\t\t\trcu_seq_done(&rnp->gp_seq, wait_gp_seq) ||\n\t\t\t!READ_ONCE(my_rdp->nocb_gp_sleep));\n\t\ttrace_rcu_this_gp(rnp, my_rdp, wait_gp_seq, TPS(\"EndWait\"));\n\t}\n\tif (!rcu_nocb_poll) {\n\t\traw_spin_lock_irqsave(&my_rdp->nocb_gp_lock, flags);\n\t\tif (my_rdp->nocb_defer_wakeup > RCU_NOCB_WAKE_NOT) {\n\t\t\tWRITE_ONCE(my_rdp->nocb_defer_wakeup, RCU_NOCB_WAKE_NOT);\n\t\t\tdel_timer(&my_rdp->nocb_timer);\n\t\t}\n\t\tWRITE_ONCE(my_rdp->nocb_gp_sleep, true);\n\t\traw_spin_unlock_irqrestore(&my_rdp->nocb_gp_lock, flags);\n\t}\n\tmy_rdp->nocb_gp_seq = -1;\n\tWARN_ON(signal_pending(current));\n}"
        }
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "rdp->nocb_gp_loops",
            "rdp->nocb_gp_loops + 1"
          ],
          "line": 779
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "static int rcu_nocb_gp_kthread(void *arg)\n{\n\tstruct rcu_data *rdp = arg;\n\n\tfor (;;) {\n\t\tWRITE_ONCE(rdp->nocb_gp_loops, rdp->nocb_gp_loops + 1);\n\t\tnocb_gp_wait(rdp);\n\t\tcond_resched_tasks_rcu_qs();\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "nocb_gp_wait",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_nocb.h",
    "lines": "611-764",
    "snippet": "static void nocb_gp_wait(struct rcu_data *my_rdp)\n{\n\tbool bypass = false;\n\tlong bypass_ncbs;\n\tint __maybe_unused cpu = my_rdp->cpu;\n\tunsigned long cur_gp_seq;\n\tunsigned long flags;\n\tbool gotcbs = false;\n\tunsigned long j = jiffies;\n\tbool needwait_gp = false; // This prevents actual uninitialized use.\n\tbool needwake;\n\tbool needwake_gp;\n\tstruct rcu_data *rdp;\n\tstruct rcu_node *rnp;\n\tunsigned long wait_gp_seq = 0; // Suppress \"use uninitialized\" warning.\n\tbool wasempty = false;\n\n\t/*\n\t * Each pass through the following loop checks for CBs and for the\n\t * nearest grace period (if any) to wait for next.  The CB kthreads\n\t * and the global grace-period kthread are awakened if needed.\n\t */\n\tWARN_ON_ONCE(my_rdp->nocb_gp_rdp != my_rdp);\n\t/*\n\t * An rcu_data structure is removed from the list after its\n\t * CPU is de-offloaded and added to the list before that CPU is\n\t * (re-)offloaded.  If the following loop happens to be referencing\n\t * that rcu_data structure during the time that the corresponding\n\t * CPU is de-offloaded and then immediately re-offloaded, this\n\t * loop's rdp pointer will be carried to the end of the list by\n\t * the resulting pair of list operations.  This can cause the loop\n\t * to skip over some of the rcu_data structures that were supposed\n\t * to have been scanned.  Fortunately a new iteration through the\n\t * entire loop is forced after a given CPU's rcu_data structure\n\t * is added to the list, so the skipped-over rcu_data structures\n\t * won't be ignored for long.\n\t */\n\tlist_for_each_entry_rcu(rdp, &my_rdp->nocb_head_rdp, nocb_entry_rdp, 1) {\n\t\tbool needwake_state = false;\n\n\t\tif (!nocb_gp_enabled_cb(rdp))\n\t\t\tcontinue;\n\t\ttrace_rcu_nocb_wake(rcu_state.name, rdp->cpu, TPS(\"Check\"));\n\t\trcu_nocb_lock_irqsave(rdp, flags);\n\t\tif (nocb_gp_update_state_deoffloading(rdp, &needwake_state)) {\n\t\t\trcu_nocb_unlock_irqrestore(rdp, flags);\n\t\t\tif (needwake_state)\n\t\t\t\tswake_up_one(&rdp->nocb_state_wq);\n\t\t\tcontinue;\n\t\t}\n\t\tbypass_ncbs = rcu_cblist_n_cbs(&rdp->nocb_bypass);\n\t\tif (bypass_ncbs &&\n\t\t    (time_after(j, READ_ONCE(rdp->nocb_bypass_first) + 1) ||\n\t\t     bypass_ncbs > 2 * qhimark)) {\n\t\t\t// Bypass full or old, so flush it.\n\t\t\t(void)rcu_nocb_try_flush_bypass(rdp, j);\n\t\t\tbypass_ncbs = rcu_cblist_n_cbs(&rdp->nocb_bypass);\n\t\t} else if (!bypass_ncbs && rcu_segcblist_empty(&rdp->cblist)) {\n\t\t\trcu_nocb_unlock_irqrestore(rdp, flags);\n\t\t\tif (needwake_state)\n\t\t\t\tswake_up_one(&rdp->nocb_state_wq);\n\t\t\tcontinue; /* No callbacks here, try next. */\n\t\t}\n\t\tif (bypass_ncbs) {\n\t\t\ttrace_rcu_nocb_wake(rcu_state.name, rdp->cpu,\n\t\t\t\t\t    TPS(\"Bypass\"));\n\t\t\tbypass = true;\n\t\t}\n\t\trnp = rdp->mynode;\n\n\t\t// Advance callbacks if helpful and low contention.\n\t\tneedwake_gp = false;\n\t\tif (!rcu_segcblist_restempty(&rdp->cblist,\n\t\t\t\t\t     RCU_NEXT_READY_TAIL) ||\n\t\t    (rcu_segcblist_nextgp(&rdp->cblist, &cur_gp_seq) &&\n\t\t     rcu_seq_done(&rnp->gp_seq, cur_gp_seq))) {\n\t\t\traw_spin_lock_rcu_node(rnp); /* irqs disabled. */\n\t\t\tneedwake_gp = rcu_advance_cbs(rnp, rdp);\n\t\t\twasempty = rcu_segcblist_restempty(&rdp->cblist,\n\t\t\t\t\t\t\t   RCU_NEXT_READY_TAIL);\n\t\t\traw_spin_unlock_rcu_node(rnp); /* irqs disabled. */\n\t\t}\n\t\t// Need to wait on some grace period?\n\t\tWARN_ON_ONCE(wasempty &&\n\t\t\t     !rcu_segcblist_restempty(&rdp->cblist,\n\t\t\t\t\t\t      RCU_NEXT_READY_TAIL));\n\t\tif (rcu_segcblist_nextgp(&rdp->cblist, &cur_gp_seq)) {\n\t\t\tif (!needwait_gp ||\n\t\t\t    ULONG_CMP_LT(cur_gp_seq, wait_gp_seq))\n\t\t\t\twait_gp_seq = cur_gp_seq;\n\t\t\tneedwait_gp = true;\n\t\t\ttrace_rcu_nocb_wake(rcu_state.name, rdp->cpu,\n\t\t\t\t\t    TPS(\"NeedWaitGP\"));\n\t\t}\n\t\tif (rcu_segcblist_ready_cbs(&rdp->cblist)) {\n\t\t\tneedwake = rdp->nocb_cb_sleep;\n\t\t\tWRITE_ONCE(rdp->nocb_cb_sleep, false);\n\t\t\tsmp_mb(); /* CB invocation -after- GP end. */\n\t\t} else {\n\t\t\tneedwake = false;\n\t\t}\n\t\trcu_nocb_unlock_irqrestore(rdp, flags);\n\t\tif (needwake) {\n\t\t\tswake_up_one(&rdp->nocb_cb_wq);\n\t\t\tgotcbs = true;\n\t\t}\n\t\tif (needwake_gp)\n\t\t\trcu_gp_kthread_wake();\n\t\tif (needwake_state)\n\t\t\tswake_up_one(&rdp->nocb_state_wq);\n\t}\n\n\tmy_rdp->nocb_gp_bypass = bypass;\n\tmy_rdp->nocb_gp_gp = needwait_gp;\n\tmy_rdp->nocb_gp_seq = needwait_gp ? wait_gp_seq : 0;\n\n\tif (bypass && !rcu_nocb_poll) {\n\t\t// At least one child with non-empty ->nocb_bypass, so set\n\t\t// timer in order to avoid stranding its callbacks.\n\t\twake_nocb_gp_defer(my_rdp, RCU_NOCB_WAKE_BYPASS,\n\t\t\t\t   TPS(\"WakeBypassIsDeferred\"));\n\t}\n\tif (rcu_nocb_poll) {\n\t\t/* Polling, so trace if first poll in the series. */\n\t\tif (gotcbs)\n\t\t\ttrace_rcu_nocb_wake(rcu_state.name, cpu, TPS(\"Poll\"));\n\t\tschedule_timeout_idle(1);\n\t} else if (!needwait_gp) {\n\t\t/* Wait for callbacks to appear. */\n\t\ttrace_rcu_nocb_wake(rcu_state.name, cpu, TPS(\"Sleep\"));\n\t\tswait_event_interruptible_exclusive(my_rdp->nocb_gp_wq,\n\t\t\t\t!READ_ONCE(my_rdp->nocb_gp_sleep));\n\t\ttrace_rcu_nocb_wake(rcu_state.name, cpu, TPS(\"EndSleep\"));\n\t} else {\n\t\trnp = my_rdp->mynode;\n\t\ttrace_rcu_this_gp(rnp, my_rdp, wait_gp_seq, TPS(\"StartWait\"));\n\t\tswait_event_interruptible_exclusive(\n\t\t\trnp->nocb_gp_wq[rcu_seq_ctr(wait_gp_seq) & 0x1],\n\t\t\trcu_seq_done(&rnp->gp_seq, wait_gp_seq) ||\n\t\t\t!READ_ONCE(my_rdp->nocb_gp_sleep));\n\t\ttrace_rcu_this_gp(rnp, my_rdp, wait_gp_seq, TPS(\"EndWait\"));\n\t}\n\tif (!rcu_nocb_poll) {\n\t\traw_spin_lock_irqsave(&my_rdp->nocb_gp_lock, flags);\n\t\tif (my_rdp->nocb_defer_wakeup > RCU_NOCB_WAKE_NOT) {\n\t\t\tWRITE_ONCE(my_rdp->nocb_defer_wakeup, RCU_NOCB_WAKE_NOT);\n\t\t\tdel_timer(&my_rdp->nocb_timer);\n\t\t}\n\t\tWRITE_ONCE(my_rdp->nocb_gp_sleep, true);\n\t\traw_spin_unlock_irqrestore(&my_rdp->nocb_gp_lock, flags);\n\t}\n\tmy_rdp->nocb_gp_seq = -1;\n\tWARN_ON(signal_pending(current));\n}",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "signal_pending(current)"
          ],
          "line": 763
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "signal_pending",
          "args": [
            "current"
          ],
          "line": 763
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore",
          "args": [
            "&my_rdp->nocb_gp_lock",
            "flags"
          ],
          "line": 760
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "192-195",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "my_rdp->nocb_gp_sleep",
            "true"
          ],
          "line": 759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "del_timer",
          "args": [
            "&my_rdp->nocb_timer"
          ],
          "line": 757
        },
        "resolved": true,
        "details": {
          "function_name": "del_timer_sync",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timer.c",
          "lines": "1352-1391",
          "snippet": "int del_timer_sync(struct timer_list *timer)\n{\n\tint ret;\n\n#ifdef CONFIG_LOCKDEP\n\tunsigned long flags;\n\n\t/*\n\t * If lockdep gives a backtrace here, please reference\n\t * the synchronization rules above.\n\t */\n\tlocal_irq_save(flags);\n\tlock_map_acquire(&timer->lockdep_map);\n\tlock_map_release(&timer->lockdep_map);\n\tlocal_irq_restore(flags);\n#endif\n\t/*\n\t * don't use it in hardirq context, because it\n\t * could lead to deadlock.\n\t */\n\tWARN_ON(in_irq() && !(timer->flags & TIMER_IRQSAFE));\n\n\t/*\n\t * Must be able to sleep on PREEMPT_RT because of the slowpath in\n\t * del_timer_wait_running().\n\t */\n\tif (IS_ENABLED(CONFIG_PREEMPT_RT) && !(timer->flags & TIMER_IRQSAFE))\n\t\tlockdep_assert_preemption_enabled();\n\n\tdo {\n\t\tret = try_to_del_timer_sync(timer);\n\n\t\tif (unlikely(ret < 0)) {\n\t\t\tdel_timer_wait_running(timer);\n\t\t\tcpu_relax();\n\t\t}\n\t} while (ret < 0);\n\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/random.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/random.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nint del_timer_sync(struct timer_list *timer)\n{\n\tint ret;\n\n#ifdef CONFIG_LOCKDEP\n\tunsigned long flags;\n\n\t/*\n\t * If lockdep gives a backtrace here, please reference\n\t * the synchronization rules above.\n\t */\n\tlocal_irq_save(flags);\n\tlock_map_acquire(&timer->lockdep_map);\n\tlock_map_release(&timer->lockdep_map);\n\tlocal_irq_restore(flags);\n#endif\n\t/*\n\t * don't use it in hardirq context, because it\n\t * could lead to deadlock.\n\t */\n\tWARN_ON(in_irq() && !(timer->flags & TIMER_IRQSAFE));\n\n\t/*\n\t * Must be able to sleep on PREEMPT_RT because of the slowpath in\n\t * del_timer_wait_running().\n\t */\n\tif (IS_ENABLED(CONFIG_PREEMPT_RT) && !(timer->flags & TIMER_IRQSAFE))\n\t\tlockdep_assert_preemption_enabled();\n\n\tdo {\n\t\tret = try_to_del_timer_sync(timer);\n\n\t\tif (unlikely(ret < 0)) {\n\t\t\tdel_timer_wait_running(timer);\n\t\t\tcpu_relax();\n\t\t}\n\t} while (ret < 0);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "my_rdp->nocb_defer_wakeup",
            "RCU_NOCB_WAKE_NOT"
          ],
          "line": 756
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave",
          "args": [
            "&my_rdp->nocb_gp_lock",
            "flags"
          ],
          "line": 754
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "383-393",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_rcu_this_gp",
          "args": [
            "rnp",
            "my_rdp",
            "wait_gp_seq",
            "TPS(\"EndWait\")"
          ],
          "line": 751
        },
        "resolved": true,
        "details": {
          "function_name": "trace_rcu_this_gp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "1346-1352",
          "snippet": "static void trace_rcu_this_gp(struct rcu_node *rnp, struct rcu_data *rdp,\n\t\t\t      unsigned long gp_seq_req, const char *s)\n{\n\ttrace_rcu_future_grace_period(rcu_state.name, READ_ONCE(rnp->gp_seq),\n\t\t\t\t      gp_seq_req, rnp->level,\n\t\t\t\t      rnp->grplo, rnp->grphi, s);\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};",
            "static struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};",
            "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
            "static void check_cb_ovld_locked(struct rcu_data *rdp, struct rcu_node *rnp);",
            "static bool rcu_rdp_is_offloaded(struct rcu_data *rdp);",
            "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};\nstatic struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void check_cb_ovld_locked(struct rcu_data *rdp, struct rcu_node *rnp);\nstatic bool rcu_rdp_is_offloaded(struct rcu_data *rdp);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nstatic void trace_rcu_this_gp(struct rcu_node *rnp, struct rcu_data *rdp,\n\t\t\t      unsigned long gp_seq_req, const char *s)\n{\n\ttrace_rcu_future_grace_period(rcu_state.name, READ_ONCE(rnp->gp_seq),\n\t\t\t\t      gp_seq_req, rnp->level,\n\t\t\t\t      rnp->grplo, rnp->grphi, s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "TPS",
          "args": [
            "\"EndWait\""
          ],
          "line": 751
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swait_event_interruptible_exclusive",
          "args": [
            "rnp->nocb_gp_wq[rcu_seq_ctr(wait_gp_seq) & 0x1]",
            "rcu_seq_done(&rnp->gp_seq, wait_gp_seq) ||\n\t\t\t!READ_ONCE(my_rdp->nocb_gp_sleep)"
          ],
          "line": 747
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "my_rdp->nocb_gp_sleep"
          ],
          "line": 750
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_seq_done",
          "args": [
            "&rnp->gp_seq",
            "wait_gp_seq"
          ],
          "line": 749
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_seq_done",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu.h",
          "lines": "115-118",
          "snippet": "static inline bool rcu_seq_done(unsigned long *sp, unsigned long s)\n{\n\treturn ULONG_CMP_GE(READ_ONCE(*sp), s);\n}",
          "includes": [
            "#include <linux/rcu_node_tree.h>",
            "#include <trace/events/rcu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_node_tree.h>\n#include <trace/events/rcu.h>\n\nstatic inline bool rcu_seq_done(unsigned long *sp, unsigned long s)\n{\n\treturn ULONG_CMP_GE(READ_ONCE(*sp), s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_seq_ctr",
          "args": [
            "wait_gp_seq"
          ],
          "line": 748
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_seq_ctr",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu.h",
          "lines": "30-33",
          "snippet": "static inline unsigned long rcu_seq_ctr(unsigned long s)\n{\n\treturn s >> RCU_SEQ_CTR_SHIFT;\n}",
          "includes": [
            "#include <linux/rcu_node_tree.h>",
            "#include <trace/events/rcu.h>"
          ],
          "macros_used": [
            "#define RCU_SEQ_CTR_SHIFT\t2"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_node_tree.h>\n#include <trace/events/rcu.h>\n\n#define RCU_SEQ_CTR_SHIFT\t2\n\nstatic inline unsigned long rcu_seq_ctr(unsigned long s)\n{\n\treturn s >> RCU_SEQ_CTR_SHIFT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "TPS",
          "args": [
            "\"StartWait\""
          ],
          "line": 746
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_rcu_nocb_wake",
          "args": [
            "rcu_state.name",
            "cpu",
            "TPS(\"EndSleep\")"
          ],
          "line": 743
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPS",
          "args": [
            "\"EndSleep\""
          ],
          "line": 743
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swait_event_interruptible_exclusive",
          "args": [
            "my_rdp->nocb_gp_wq",
            "!READ_ONCE(my_rdp->nocb_gp_sleep)"
          ],
          "line": 741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "my_rdp->nocb_gp_sleep"
          ],
          "line": 742
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_rcu_nocb_wake",
          "args": [
            "rcu_state.name",
            "cpu",
            "TPS(\"Sleep\")"
          ],
          "line": 740
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPS",
          "args": [
            "\"Sleep\""
          ],
          "line": 740
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schedule_timeout_idle",
          "args": [
            "1"
          ],
          "line": 737
        },
        "resolved": true,
        "details": {
          "function_name": "schedule_timeout_idle",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timer.c",
          "lines": "1923-1927",
          "snippet": "signed long __sched schedule_timeout_idle(signed long timeout)\n{\n\t__set_current_state(TASK_IDLE);\n\treturn schedule_timeout(timeout);\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/random.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/random.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nsigned long __sched schedule_timeout_idle(signed long timeout)\n{\n\t__set_current_state(TASK_IDLE);\n\treturn schedule_timeout(timeout);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_rcu_nocb_wake",
          "args": [
            "rcu_state.name",
            "cpu",
            "TPS(\"Poll\")"
          ],
          "line": 736
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPS",
          "args": [
            "\"Poll\""
          ],
          "line": 736
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wake_nocb_gp_defer",
          "args": [
            "my_rdp",
            "RCU_NOCB_WAKE_BYPASS",
            "TPS(\"WakeBypassIsDeferred\")"
          ],
          "line": 730
        },
        "resolved": true,
        "details": {
          "function_name": "wake_nocb_gp_defer",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_nocb.h",
          "lines": "274-299",
          "snippet": "static void wake_nocb_gp_defer(struct rcu_data *rdp, int waketype,\n\t\t\t       const char *reason)\n{\n\tunsigned long flags;\n\tstruct rcu_data *rdp_gp = rdp->nocb_gp_rdp;\n\n\traw_spin_lock_irqsave(&rdp_gp->nocb_gp_lock, flags);\n\n\t/*\n\t * Bypass wakeup overrides previous deferments. In case\n\t * of callback storm, no need to wake up too early.\n\t */\n\tif (waketype == RCU_NOCB_WAKE_BYPASS) {\n\t\tmod_timer(&rdp_gp->nocb_timer, jiffies + 2);\n\t\tWRITE_ONCE(rdp_gp->nocb_defer_wakeup, waketype);\n\t} else {\n\t\tif (rdp_gp->nocb_defer_wakeup < RCU_NOCB_WAKE)\n\t\t\tmod_timer(&rdp_gp->nocb_timer, jiffies + 1);\n\t\tif (rdp_gp->nocb_defer_wakeup < waketype)\n\t\t\tWRITE_ONCE(rdp_gp->nocb_defer_wakeup, waketype);\n\t}\n\n\traw_spin_unlock_irqrestore(&rdp_gp->nocb_gp_lock, flags);\n\n\ttrace_rcu_nocb_wake(rcu_state.name, rdp->cpu, reason);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static void wake_nocb_gp_defer(struct rcu_data *rdp, int waketype,\n\t\t\t       const char *reason)\n{\n\tunsigned long flags;\n\tstruct rcu_data *rdp_gp = rdp->nocb_gp_rdp;\n\n\traw_spin_lock_irqsave(&rdp_gp->nocb_gp_lock, flags);\n\n\t/*\n\t * Bypass wakeup overrides previous deferments. In case\n\t * of callback storm, no need to wake up too early.\n\t */\n\tif (waketype == RCU_NOCB_WAKE_BYPASS) {\n\t\tmod_timer(&rdp_gp->nocb_timer, jiffies + 2);\n\t\tWRITE_ONCE(rdp_gp->nocb_defer_wakeup, waketype);\n\t} else {\n\t\tif (rdp_gp->nocb_defer_wakeup < RCU_NOCB_WAKE)\n\t\t\tmod_timer(&rdp_gp->nocb_timer, jiffies + 1);\n\t\tif (rdp_gp->nocb_defer_wakeup < waketype)\n\t\t\tWRITE_ONCE(rdp_gp->nocb_defer_wakeup, waketype);\n\t}\n\n\traw_spin_unlock_irqrestore(&rdp_gp->nocb_gp_lock, flags);\n\n\ttrace_rcu_nocb_wake(rcu_state.name, rdp->cpu, reason);\n}"
        }
      },
      {
        "call_info": {
          "callee": "TPS",
          "args": [
            "\"WakeBypassIsDeferred\""
          ],
          "line": 731
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swake_up_one",
          "args": [
            "&rdp->nocb_state_wq"
          ],
          "line": 720
        },
        "resolved": true,
        "details": {
          "function_name": "swake_up_one",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/swait.c",
          "lines": "48-55",
          "snippet": "void swake_up_one(struct swait_queue_head *q)\n{\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&q->lock, flags);\n\tswake_up_locked(q);\n\traw_spin_unlock_irqrestore(&q->lock, flags);\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nvoid swake_up_one(struct swait_queue_head *q)\n{\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&q->lock, flags);\n\tswake_up_locked(q);\n\traw_spin_unlock_irqrestore(&q->lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_gp_kthread_wake",
          "args": [],
          "line": 718
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_gp_kthread_wake",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "1473-1483",
          "snippet": "static void rcu_gp_kthread_wake(void)\n{\n\tstruct task_struct *t = READ_ONCE(rcu_state.gp_kthread);\n\n\tif ((current == t && !in_hardirq() && !in_serving_softirq()) ||\n\t    !READ_ONCE(rcu_state.gp_flags) || !t)\n\t\treturn;\n\tWRITE_ONCE(rcu_state.gp_wake_time, jiffies);\n\tWRITE_ONCE(rcu_state.gp_wake_seq, READ_ONCE(rcu_state.gp_seq));\n\tswake_up_one(&rcu_state.gp_wq);\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\n\nstatic void rcu_gp_kthread_wake(void)\n{\n\tstruct task_struct *t = READ_ONCE(rcu_state.gp_kthread);\n\n\tif ((current == t && !in_hardirq() && !in_serving_softirq()) ||\n\t    !READ_ONCE(rcu_state.gp_flags) || !t)\n\t\treturn;\n\tWRITE_ONCE(rcu_state.gp_wake_time, jiffies);\n\tWRITE_ONCE(rcu_state.gp_wake_seq, READ_ONCE(rcu_state.gp_seq));\n\tswake_up_one(&rcu_state.gp_wq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_nocb_unlock_irqrestore",
          "args": [
            "rdp",
            "flags"
          ],
          "line": 712
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_nocb_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_nocb.h",
          "lines": "1479-1483",
          "snippet": "static void rcu_nocb_unlock_irqrestore(struct rcu_data *rdp,\n\t\t\t\t       unsigned long flags)\n{\n\tlocal_irq_restore(flags);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static void rcu_nocb_unlock_irqrestore(struct rcu_data *rdp,\n\t\t\t\t       unsigned long flags)\n{\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_mb",
          "args": [],
          "line": 708
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "rdp->nocb_cb_sleep",
            "false"
          ],
          "line": 707
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_segcblist_ready_cbs",
          "args": [
            "&rdp->cblist"
          ],
          "line": 705
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_ready_cbs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.c",
          "lines": "278-282",
          "snippet": "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp)\n{\n\treturn rcu_segcblist_is_enabled(rsclp) &&\n\t       &rsclp->head != READ_ONCE(rsclp->tails[RCU_DONE_TAIL]);\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/cpu.h>\n\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp)\n{\n\treturn rcu_segcblist_is_enabled(rsclp) &&\n\t       &rsclp->head != READ_ONCE(rsclp->tails[RCU_DONE_TAIL]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_rcu_nocb_wake",
          "args": [
            "rcu_state.name",
            "rdp->cpu",
            "TPS(\"NeedWaitGP\")"
          ],
          "line": 702
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPS",
          "args": [
            "\"NeedWaitGP\""
          ],
          "line": 703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ULONG_CMP_LT",
          "args": [
            "cur_gp_seq",
            "wait_gp_seq"
          ],
          "line": 699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_segcblist_nextgp",
          "args": [
            "&rdp->cblist",
            "&cur_gp_seq"
          ],
          "line": 697
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_nextgp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.c",
          "lines": "323-329",
          "snippet": "bool rcu_segcblist_nextgp(struct rcu_segcblist *rsclp, unsigned long *lp)\n{\n\tif (!rcu_segcblist_pend_cbs(rsclp))\n\t\treturn false;\n\t*lp = rsclp->gp_seq[RCU_WAIT_TAIL];\n\treturn true;\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/cpu.h>\n\nbool rcu_segcblist_nextgp(struct rcu_segcblist *rsclp, unsigned long *lp)\n{\n\tif (!rcu_segcblist_pend_cbs(rsclp))\n\t\treturn false;\n\t*lp = rsclp->gp_seq[RCU_WAIT_TAIL];\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "wasempty &&\n\t\t\t     !rcu_segcblist_restempty(&rdp->cblist,\n\t\t\t\t\t\t      RCU_NEXT_READY_TAIL)"
          ],
          "line": 694
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_segcblist_restempty",
          "args": [
            "&rdp->cblist",
            "RCU_NEXT_READY_TAIL"
          ],
          "line": 695
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_restempty",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "110-113",
          "snippet": "static inline bool rcu_segcblist_restempty(struct rcu_segcblist *rsclp, int seg)\n{\n\treturn !READ_ONCE(*READ_ONCE(rsclp->tails[seg]));\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "long rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nlong rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_restempty(struct rcu_segcblist *rsclp, int seg)\n{\n\treturn !READ_ONCE(*READ_ONCE(rsclp->tails[seg]));\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_rcu_node",
          "args": [
            "rnp"
          ],
          "line": 691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_advance_cbs",
          "args": [
            "rnp",
            "rdp"
          ],
          "line": 688
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_advance_cbs_nowake",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "1596-1606",
          "snippet": "static void __maybe_unused rcu_advance_cbs_nowake(struct rcu_node *rnp,\n\t\t\t\t\t\t  struct rcu_data *rdp)\n{\n\trcu_lockdep_assert_cblist_protected(rdp);\n\tif (!rcu_seq_state(rcu_seq_current(&rnp->gp_seq)) || !raw_spin_trylock_rcu_node(rnp))\n\t\treturn;\n\t// The grace period cannot end while we hold the rcu_node lock.\n\tif (rcu_seq_state(rcu_seq_current(&rnp->gp_seq)))\n\t\tWARN_ON_ONCE(rcu_advance_cbs(rnp, rdp));\n\traw_spin_unlock_rcu_node(rnp);\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};",
            "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
            "static void check_cb_ovld_locked(struct rcu_data *rdp, struct rcu_node *rnp);",
            "static bool rcu_rdp_is_offloaded(struct rcu_data *rdp);",
            "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void check_cb_ovld_locked(struct rcu_data *rdp, struct rcu_node *rnp);\nstatic bool rcu_rdp_is_offloaded(struct rcu_data *rdp);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nstatic void __maybe_unused rcu_advance_cbs_nowake(struct rcu_node *rnp,\n\t\t\t\t\t\t  struct rcu_data *rdp)\n{\n\trcu_lockdep_assert_cblist_protected(rdp);\n\tif (!rcu_seq_state(rcu_seq_current(&rnp->gp_seq)) || !raw_spin_trylock_rcu_node(rnp))\n\t\treturn;\n\t// The grace period cannot end while we hold the rcu_node lock.\n\tif (rcu_seq_state(rcu_seq_current(&rnp->gp_seq)))\n\t\tWARN_ON_ONCE(rcu_advance_cbs(rnp, rdp));\n\traw_spin_unlock_rcu_node(rnp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_rcu_node",
          "args": [
            "rnp"
          ],
          "line": 687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_rcu_nocb_wake",
          "args": [
            "rcu_state.name",
            "rdp->cpu",
            "TPS(\"Bypass\")"
          ],
          "line": 675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPS",
          "args": [
            "\"Bypass\""
          ],
          "line": 676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_segcblist_empty",
          "args": [
            "&rdp->cblist"
          ],
          "line": 668
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "41-44",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "long rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nlong rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_cblist_n_cbs",
          "args": [
            "&rdp->nocb_bypass"
          ],
          "line": 667
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_cblist_n_cbs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "13-16",
          "snippet": "static inline long rcu_cblist_n_cbs(struct rcu_cblist *rclp)\n{\n\treturn READ_ONCE(rclp->len);\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void rcu_cblist_init(struct rcu_cblist *rclp);",
            "struct rcu_head *rcu_cblist_dequeue(struct rcu_cblist *rclp);",
            "void rcu_segcblist_extract_done_cbs(struct rcu_segcblist *rsclp,\n\t\t\t\t    struct rcu_cblist *rclp);",
            "void rcu_segcblist_extract_pend_cbs(struct rcu_segcblist *rsclp,\n\t\t\t\t    struct rcu_cblist *rclp);",
            "void rcu_segcblist_insert_count(struct rcu_segcblist *rsclp,\n\t\t\t\tstruct rcu_cblist *rclp);",
            "void rcu_segcblist_insert_done_cbs(struct rcu_segcblist *rsclp,\n\t\t\t\t   struct rcu_cblist *rclp);",
            "void rcu_segcblist_insert_pend_cbs(struct rcu_segcblist *rsclp,\n\t\t\t\t   struct rcu_cblist *rclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nvoid rcu_cblist_init(struct rcu_cblist *rclp);\nstruct rcu_head *rcu_cblist_dequeue(struct rcu_cblist *rclp);\nvoid rcu_segcblist_extract_done_cbs(struct rcu_segcblist *rsclp,\n\t\t\t\t    struct rcu_cblist *rclp);\nvoid rcu_segcblist_extract_pend_cbs(struct rcu_segcblist *rsclp,\n\t\t\t\t    struct rcu_cblist *rclp);\nvoid rcu_segcblist_insert_count(struct rcu_segcblist *rsclp,\n\t\t\t\tstruct rcu_cblist *rclp);\nvoid rcu_segcblist_insert_done_cbs(struct rcu_segcblist *rsclp,\n\t\t\t\t   struct rcu_cblist *rclp);\nvoid rcu_segcblist_insert_pend_cbs(struct rcu_segcblist *rsclp,\n\t\t\t\t   struct rcu_cblist *rclp);\n\nstatic inline long rcu_cblist_n_cbs(struct rcu_cblist *rclp)\n{\n\treturn READ_ONCE(rclp->len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_nocb_try_flush_bypass",
          "args": [
            "rdp",
            "j"
          ],
          "line": 666
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_nocb_try_flush_bypass",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_nocb.h",
          "lines": "353-360",
          "snippet": "static void rcu_nocb_try_flush_bypass(struct rcu_data *rdp, unsigned long j)\n{\n\trcu_lockdep_assert_cblist_protected(rdp);\n\tif (!rcu_rdp_is_offloaded(rdp) ||\n\t    !rcu_nocb_bypass_trylock(rdp))\n\t\treturn;\n\tWARN_ON_ONCE(!rcu_nocb_do_flush_bypass(rdp, NULL, j));\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static void rcu_nocb_try_flush_bypass(struct rcu_data *rdp, unsigned long j)\n{\n\trcu_lockdep_assert_cblist_protected(rdp);\n\tif (!rcu_rdp_is_offloaded(rdp) ||\n\t    !rcu_nocb_bypass_trylock(rdp))\n\t\treturn;\n\tWARN_ON_ONCE(!rcu_nocb_do_flush_bypass(rdp, NULL, j));\n}"
        }
      },
      {
        "call_info": {
          "callee": "time_after",
          "args": [
            "j",
            "READ_ONCE(rdp->nocb_bypass_first) + 1"
          ],
          "line": 663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rdp->nocb_bypass_first"
          ],
          "line": 663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nocb_gp_update_state_deoffloading",
          "args": [
            "rdp",
            "&needwake_state"
          ],
          "line": 655
        },
        "resolved": true,
        "details": {
          "function_name": "nocb_gp_update_state_deoffloading",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_nocb.h",
          "lines": "581-604",
          "snippet": "static inline bool nocb_gp_update_state_deoffloading(struct rcu_data *rdp,\n\t\t\t\t\t\t     bool *needwake_state)\n{\n\tstruct rcu_segcblist *cblist = &rdp->cblist;\n\n\tif (rcu_segcblist_test_flags(cblist, SEGCBLIST_OFFLOADED)) {\n\t\tif (!rcu_segcblist_test_flags(cblist, SEGCBLIST_KTHREAD_GP)) {\n\t\t\trcu_segcblist_set_flags(cblist, SEGCBLIST_KTHREAD_GP);\n\t\t\tif (rcu_segcblist_test_flags(cblist, SEGCBLIST_KTHREAD_CB))\n\t\t\t\t*needwake_state = true;\n\t\t}\n\t\treturn false;\n\t}\n\n\t/*\n\t * De-offloading. Clear our flag and notify the de-offload worker.\n\t * We will ignore this rdp until it ever gets re-offloaded.\n\t */\n\tWARN_ON_ONCE(!rcu_segcblist_test_flags(cblist, SEGCBLIST_KTHREAD_GP));\n\trcu_segcblist_clear_flags(cblist, SEGCBLIST_KTHREAD_GP);\n\tif (!rcu_segcblist_test_flags(cblist, SEGCBLIST_KTHREAD_CB))\n\t\t*needwake_state = true;\n\treturn true;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline bool nocb_gp_update_state_deoffloading(struct rcu_data *rdp,\n\t\t\t\t\t\t     bool *needwake_state)\n{\n\tstruct rcu_segcblist *cblist = &rdp->cblist;\n\n\tif (rcu_segcblist_test_flags(cblist, SEGCBLIST_OFFLOADED)) {\n\t\tif (!rcu_segcblist_test_flags(cblist, SEGCBLIST_KTHREAD_GP)) {\n\t\t\trcu_segcblist_set_flags(cblist, SEGCBLIST_KTHREAD_GP);\n\t\t\tif (rcu_segcblist_test_flags(cblist, SEGCBLIST_KTHREAD_CB))\n\t\t\t\t*needwake_state = true;\n\t\t}\n\t\treturn false;\n\t}\n\n\t/*\n\t * De-offloading. Clear our flag and notify the de-offload worker.\n\t * We will ignore this rdp until it ever gets re-offloaded.\n\t */\n\tWARN_ON_ONCE(!rcu_segcblist_test_flags(cblist, SEGCBLIST_KTHREAD_GP));\n\trcu_segcblist_clear_flags(cblist, SEGCBLIST_KTHREAD_GP);\n\tif (!rcu_segcblist_test_flags(cblist, SEGCBLIST_KTHREAD_CB))\n\t\t*needwake_state = true;\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_nocb_lock_irqsave",
          "args": [
            "rdp",
            "flags"
          ],
          "line": 654
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_rcu_nocb_wake",
          "args": [
            "rcu_state.name",
            "rdp->cpu",
            "TPS(\"Check\")"
          ],
          "line": 653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPS",
          "args": [
            "\"Check\""
          ],
          "line": 653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nocb_gp_enabled_cb",
          "args": [
            "rdp"
          ],
          "line": 651
        },
        "resolved": true,
        "details": {
          "function_name": "nocb_gp_enabled_cb",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_nocb.h",
          "lines": "574-579",
          "snippet": "static inline bool nocb_gp_enabled_cb(struct rcu_data *rdp)\n{\n\tu8 flags = SEGCBLIST_OFFLOADED | SEGCBLIST_KTHREAD_GP;\n\n\treturn rcu_segcblist_test_flags(&rdp->cblist, flags);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline bool nocb_gp_enabled_cb(struct rcu_data *rdp)\n{\n\tu8 flags = SEGCBLIST_OFFLOADED | SEGCBLIST_KTHREAD_GP;\n\n\treturn rcu_segcblist_test_flags(&rdp->cblist, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_rcu",
          "args": [
            "rdp",
            "&my_rdp->nocb_head_rdp",
            "nocb_entry_rdp",
            "1"
          ],
          "line": 648
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "my_rdp->nocb_gp_rdp != my_rdp"
          ],
          "line": 633
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "static void nocb_gp_wait(struct rcu_data *my_rdp)\n{\n\tbool bypass = false;\n\tlong bypass_ncbs;\n\tint __maybe_unused cpu = my_rdp->cpu;\n\tunsigned long cur_gp_seq;\n\tunsigned long flags;\n\tbool gotcbs = false;\n\tunsigned long j = jiffies;\n\tbool needwait_gp = false; // This prevents actual uninitialized use.\n\tbool needwake;\n\tbool needwake_gp;\n\tstruct rcu_data *rdp;\n\tstruct rcu_node *rnp;\n\tunsigned long wait_gp_seq = 0; // Suppress \"use uninitialized\" warning.\n\tbool wasempty = false;\n\n\t/*\n\t * Each pass through the following loop checks for CBs and for the\n\t * nearest grace period (if any) to wait for next.  The CB kthreads\n\t * and the global grace-period kthread are awakened if needed.\n\t */\n\tWARN_ON_ONCE(my_rdp->nocb_gp_rdp != my_rdp);\n\t/*\n\t * An rcu_data structure is removed from the list after its\n\t * CPU is de-offloaded and added to the list before that CPU is\n\t * (re-)offloaded.  If the following loop happens to be referencing\n\t * that rcu_data structure during the time that the corresponding\n\t * CPU is de-offloaded and then immediately re-offloaded, this\n\t * loop's rdp pointer will be carried to the end of the list by\n\t * the resulting pair of list operations.  This can cause the loop\n\t * to skip over some of the rcu_data structures that were supposed\n\t * to have been scanned.  Fortunately a new iteration through the\n\t * entire loop is forced after a given CPU's rcu_data structure\n\t * is added to the list, so the skipped-over rcu_data structures\n\t * won't be ignored for long.\n\t */\n\tlist_for_each_entry_rcu(rdp, &my_rdp->nocb_head_rdp, nocb_entry_rdp, 1) {\n\t\tbool needwake_state = false;\n\n\t\tif (!nocb_gp_enabled_cb(rdp))\n\t\t\tcontinue;\n\t\ttrace_rcu_nocb_wake(rcu_state.name, rdp->cpu, TPS(\"Check\"));\n\t\trcu_nocb_lock_irqsave(rdp, flags);\n\t\tif (nocb_gp_update_state_deoffloading(rdp, &needwake_state)) {\n\t\t\trcu_nocb_unlock_irqrestore(rdp, flags);\n\t\t\tif (needwake_state)\n\t\t\t\tswake_up_one(&rdp->nocb_state_wq);\n\t\t\tcontinue;\n\t\t}\n\t\tbypass_ncbs = rcu_cblist_n_cbs(&rdp->nocb_bypass);\n\t\tif (bypass_ncbs &&\n\t\t    (time_after(j, READ_ONCE(rdp->nocb_bypass_first) + 1) ||\n\t\t     bypass_ncbs > 2 * qhimark)) {\n\t\t\t// Bypass full or old, so flush it.\n\t\t\t(void)rcu_nocb_try_flush_bypass(rdp, j);\n\t\t\tbypass_ncbs = rcu_cblist_n_cbs(&rdp->nocb_bypass);\n\t\t} else if (!bypass_ncbs && rcu_segcblist_empty(&rdp->cblist)) {\n\t\t\trcu_nocb_unlock_irqrestore(rdp, flags);\n\t\t\tif (needwake_state)\n\t\t\t\tswake_up_one(&rdp->nocb_state_wq);\n\t\t\tcontinue; /* No callbacks here, try next. */\n\t\t}\n\t\tif (bypass_ncbs) {\n\t\t\ttrace_rcu_nocb_wake(rcu_state.name, rdp->cpu,\n\t\t\t\t\t    TPS(\"Bypass\"));\n\t\t\tbypass = true;\n\t\t}\n\t\trnp = rdp->mynode;\n\n\t\t// Advance callbacks if helpful and low contention.\n\t\tneedwake_gp = false;\n\t\tif (!rcu_segcblist_restempty(&rdp->cblist,\n\t\t\t\t\t     RCU_NEXT_READY_TAIL) ||\n\t\t    (rcu_segcblist_nextgp(&rdp->cblist, &cur_gp_seq) &&\n\t\t     rcu_seq_done(&rnp->gp_seq, cur_gp_seq))) {\n\t\t\traw_spin_lock_rcu_node(rnp); /* irqs disabled. */\n\t\t\tneedwake_gp = rcu_advance_cbs(rnp, rdp);\n\t\t\twasempty = rcu_segcblist_restempty(&rdp->cblist,\n\t\t\t\t\t\t\t   RCU_NEXT_READY_TAIL);\n\t\t\traw_spin_unlock_rcu_node(rnp); /* irqs disabled. */\n\t\t}\n\t\t// Need to wait on some grace period?\n\t\tWARN_ON_ONCE(wasempty &&\n\t\t\t     !rcu_segcblist_restempty(&rdp->cblist,\n\t\t\t\t\t\t      RCU_NEXT_READY_TAIL));\n\t\tif (rcu_segcblist_nextgp(&rdp->cblist, &cur_gp_seq)) {\n\t\t\tif (!needwait_gp ||\n\t\t\t    ULONG_CMP_LT(cur_gp_seq, wait_gp_seq))\n\t\t\t\twait_gp_seq = cur_gp_seq;\n\t\t\tneedwait_gp = true;\n\t\t\ttrace_rcu_nocb_wake(rcu_state.name, rdp->cpu,\n\t\t\t\t\t    TPS(\"NeedWaitGP\"));\n\t\t}\n\t\tif (rcu_segcblist_ready_cbs(&rdp->cblist)) {\n\t\t\tneedwake = rdp->nocb_cb_sleep;\n\t\t\tWRITE_ONCE(rdp->nocb_cb_sleep, false);\n\t\t\tsmp_mb(); /* CB invocation -after- GP end. */\n\t\t} else {\n\t\t\tneedwake = false;\n\t\t}\n\t\trcu_nocb_unlock_irqrestore(rdp, flags);\n\t\tif (needwake) {\n\t\t\tswake_up_one(&rdp->nocb_cb_wq);\n\t\t\tgotcbs = true;\n\t\t}\n\t\tif (needwake_gp)\n\t\t\trcu_gp_kthread_wake();\n\t\tif (needwake_state)\n\t\t\tswake_up_one(&rdp->nocb_state_wq);\n\t}\n\n\tmy_rdp->nocb_gp_bypass = bypass;\n\tmy_rdp->nocb_gp_gp = needwait_gp;\n\tmy_rdp->nocb_gp_seq = needwait_gp ? wait_gp_seq : 0;\n\n\tif (bypass && !rcu_nocb_poll) {\n\t\t// At least one child with non-empty ->nocb_bypass, so set\n\t\t// timer in order to avoid stranding its callbacks.\n\t\twake_nocb_gp_defer(my_rdp, RCU_NOCB_WAKE_BYPASS,\n\t\t\t\t   TPS(\"WakeBypassIsDeferred\"));\n\t}\n\tif (rcu_nocb_poll) {\n\t\t/* Polling, so trace if first poll in the series. */\n\t\tif (gotcbs)\n\t\t\ttrace_rcu_nocb_wake(rcu_state.name, cpu, TPS(\"Poll\"));\n\t\tschedule_timeout_idle(1);\n\t} else if (!needwait_gp) {\n\t\t/* Wait for callbacks to appear. */\n\t\ttrace_rcu_nocb_wake(rcu_state.name, cpu, TPS(\"Sleep\"));\n\t\tswait_event_interruptible_exclusive(my_rdp->nocb_gp_wq,\n\t\t\t\t!READ_ONCE(my_rdp->nocb_gp_sleep));\n\t\ttrace_rcu_nocb_wake(rcu_state.name, cpu, TPS(\"EndSleep\"));\n\t} else {\n\t\trnp = my_rdp->mynode;\n\t\ttrace_rcu_this_gp(rnp, my_rdp, wait_gp_seq, TPS(\"StartWait\"));\n\t\tswait_event_interruptible_exclusive(\n\t\t\trnp->nocb_gp_wq[rcu_seq_ctr(wait_gp_seq) & 0x1],\n\t\t\trcu_seq_done(&rnp->gp_seq, wait_gp_seq) ||\n\t\t\t!READ_ONCE(my_rdp->nocb_gp_sleep));\n\t\ttrace_rcu_this_gp(rnp, my_rdp, wait_gp_seq, TPS(\"EndWait\"));\n\t}\n\tif (!rcu_nocb_poll) {\n\t\traw_spin_lock_irqsave(&my_rdp->nocb_gp_lock, flags);\n\t\tif (my_rdp->nocb_defer_wakeup > RCU_NOCB_WAKE_NOT) {\n\t\t\tWRITE_ONCE(my_rdp->nocb_defer_wakeup, RCU_NOCB_WAKE_NOT);\n\t\t\tdel_timer(&my_rdp->nocb_timer);\n\t\t}\n\t\tWRITE_ONCE(my_rdp->nocb_gp_sleep, true);\n\t\traw_spin_unlock_irqrestore(&my_rdp->nocb_gp_lock, flags);\n\t}\n\tmy_rdp->nocb_gp_seq = -1;\n\tWARN_ON(signal_pending(current));\n}"
  },
  {
    "function_name": "nocb_gp_update_state_deoffloading",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_nocb.h",
    "lines": "581-604",
    "snippet": "static inline bool nocb_gp_update_state_deoffloading(struct rcu_data *rdp,\n\t\t\t\t\t\t     bool *needwake_state)\n{\n\tstruct rcu_segcblist *cblist = &rdp->cblist;\n\n\tif (rcu_segcblist_test_flags(cblist, SEGCBLIST_OFFLOADED)) {\n\t\tif (!rcu_segcblist_test_flags(cblist, SEGCBLIST_KTHREAD_GP)) {\n\t\t\trcu_segcblist_set_flags(cblist, SEGCBLIST_KTHREAD_GP);\n\t\t\tif (rcu_segcblist_test_flags(cblist, SEGCBLIST_KTHREAD_CB))\n\t\t\t\t*needwake_state = true;\n\t\t}\n\t\treturn false;\n\t}\n\n\t/*\n\t * De-offloading. Clear our flag and notify the de-offload worker.\n\t * We will ignore this rdp until it ever gets re-offloaded.\n\t */\n\tWARN_ON_ONCE(!rcu_segcblist_test_flags(cblist, SEGCBLIST_KTHREAD_GP));\n\trcu_segcblist_clear_flags(cblist, SEGCBLIST_KTHREAD_GP);\n\tif (!rcu_segcblist_test_flags(cblist, SEGCBLIST_KTHREAD_CB))\n\t\t*needwake_state = true;\n\treturn true;\n}",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_segcblist_test_flags",
          "args": [
            "cblist",
            "SEGCBLIST_KTHREAD_CB"
          ],
          "line": 601
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_test_flags",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "68-72",
          "snippet": "static inline bool rcu_segcblist_test_flags(struct rcu_segcblist *rsclp,\n\t\t\t\t\t    int flags)\n{\n\treturn READ_ONCE(rsclp->flags) & flags;\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "long rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nlong rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_test_flags(struct rcu_segcblist *rsclp,\n\t\t\t\t\t    int flags)\n{\n\treturn READ_ONCE(rsclp->flags) & flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_segcblist_clear_flags",
          "args": [
            "cblist",
            "SEGCBLIST_KTHREAD_GP"
          ],
          "line": 600
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_clear_flags",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "62-66",
          "snippet": "static inline void rcu_segcblist_clear_flags(struct rcu_segcblist *rsclp,\n\t\t\t\t\t     int flags)\n{\n\trsclp->flags &= ~flags;\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "long rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nlong rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline void rcu_segcblist_clear_flags(struct rcu_segcblist *rsclp,\n\t\t\t\t\t     int flags)\n{\n\trsclp->flags &= ~flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!rcu_segcblist_test_flags(cblist, SEGCBLIST_KTHREAD_GP)"
          ],
          "line": 599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_segcblist_set_flags",
          "args": [
            "cblist",
            "SEGCBLIST_KTHREAD_GP"
          ],
          "line": 588
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_set_flags",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "56-60",
          "snippet": "static inline void rcu_segcblist_set_flags(struct rcu_segcblist *rsclp,\n\t\t\t\t\t   int flags)\n{\n\trsclp->flags |= flags;\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "long rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nlong rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline void rcu_segcblist_set_flags(struct rcu_segcblist *rsclp,\n\t\t\t\t\t   int flags)\n{\n\trsclp->flags |= flags;\n}"
        }
      }
    ],
    "contextual_snippet": "static inline bool nocb_gp_update_state_deoffloading(struct rcu_data *rdp,\n\t\t\t\t\t\t     bool *needwake_state)\n{\n\tstruct rcu_segcblist *cblist = &rdp->cblist;\n\n\tif (rcu_segcblist_test_flags(cblist, SEGCBLIST_OFFLOADED)) {\n\t\tif (!rcu_segcblist_test_flags(cblist, SEGCBLIST_KTHREAD_GP)) {\n\t\t\trcu_segcblist_set_flags(cblist, SEGCBLIST_KTHREAD_GP);\n\t\t\tif (rcu_segcblist_test_flags(cblist, SEGCBLIST_KTHREAD_CB))\n\t\t\t\t*needwake_state = true;\n\t\t}\n\t\treturn false;\n\t}\n\n\t/*\n\t * De-offloading. Clear our flag and notify the de-offload worker.\n\t * We will ignore this rdp until it ever gets re-offloaded.\n\t */\n\tWARN_ON_ONCE(!rcu_segcblist_test_flags(cblist, SEGCBLIST_KTHREAD_GP));\n\trcu_segcblist_clear_flags(cblist, SEGCBLIST_KTHREAD_GP);\n\tif (!rcu_segcblist_test_flags(cblist, SEGCBLIST_KTHREAD_CB))\n\t\t*needwake_state = true;\n\treturn true;\n}"
  },
  {
    "function_name": "nocb_gp_enabled_cb",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_nocb.h",
    "lines": "574-579",
    "snippet": "static inline bool nocb_gp_enabled_cb(struct rcu_data *rdp)\n{\n\tu8 flags = SEGCBLIST_OFFLOADED | SEGCBLIST_KTHREAD_GP;\n\n\treturn rcu_segcblist_test_flags(&rdp->cblist, flags);\n}",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_segcblist_test_flags",
          "args": [
            "&rdp->cblist",
            "flags"
          ],
          "line": 578
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_test_flags",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "68-72",
          "snippet": "static inline bool rcu_segcblist_test_flags(struct rcu_segcblist *rsclp,\n\t\t\t\t\t    int flags)\n{\n\treturn READ_ONCE(rsclp->flags) & flags;\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "long rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nlong rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_test_flags(struct rcu_segcblist *rsclp,\n\t\t\t\t\t    int flags)\n{\n\treturn READ_ONCE(rsclp->flags) & flags;\n}"
        }
      }
    ],
    "contextual_snippet": "static inline bool nocb_gp_enabled_cb(struct rcu_data *rdp)\n{\n\tu8 flags = SEGCBLIST_OFFLOADED | SEGCBLIST_KTHREAD_GP;\n\n\treturn rcu_segcblist_test_flags(&rdp->cblist, flags);\n}"
  },
  {
    "function_name": "__call_rcu_nocb_wake",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_nocb.h",
    "lines": "501-558",
    "snippet": "static void __call_rcu_nocb_wake(struct rcu_data *rdp, bool was_alldone,\n\t\t\t\t unsigned long flags)\n\t\t\t\t __releases(rdp->nocb_lock)\n{\n\tunsigned long cur_gp_seq;\n\tunsigned long j;\n\tlong len;\n\tstruct task_struct *t;\n\n\t// If we are being polled or there is no kthread, just leave.\n\tt = READ_ONCE(rdp->nocb_gp_kthread);\n\tif (rcu_nocb_poll || !t) {\n\t\trcu_nocb_unlock_irqrestore(rdp, flags);\n\t\ttrace_rcu_nocb_wake(rcu_state.name, rdp->cpu,\n\t\t\t\t    TPS(\"WakeNotPoll\"));\n\t\treturn;\n\t}\n\t// Need to actually to a wakeup.\n\tlen = rcu_segcblist_n_cbs(&rdp->cblist);\n\tif (was_alldone) {\n\t\trdp->qlen_last_fqs_check = len;\n\t\tif (!irqs_disabled_flags(flags)) {\n\t\t\t/* ... if queue was empty ... */\n\t\t\trcu_nocb_unlock_irqrestore(rdp, flags);\n\t\t\twake_nocb_gp(rdp, false);\n\t\t\ttrace_rcu_nocb_wake(rcu_state.name, rdp->cpu,\n\t\t\t\t\t    TPS(\"WakeEmpty\"));\n\t\t} else {\n\t\t\trcu_nocb_unlock_irqrestore(rdp, flags);\n\t\t\twake_nocb_gp_defer(rdp, RCU_NOCB_WAKE,\n\t\t\t\t\t   TPS(\"WakeEmptyIsDeferred\"));\n\t\t}\n\t} else if (len > rdp->qlen_last_fqs_check + qhimark) {\n\t\t/* ... or if many callbacks queued. */\n\t\trdp->qlen_last_fqs_check = len;\n\t\tj = jiffies;\n\t\tif (j != rdp->nocb_gp_adv_time &&\n\t\t    rcu_segcblist_nextgp(&rdp->cblist, &cur_gp_seq) &&\n\t\t    rcu_seq_done(&rdp->mynode->gp_seq, cur_gp_seq)) {\n\t\t\trcu_advance_cbs_nowake(rdp->mynode, rdp);\n\t\t\trdp->nocb_gp_adv_time = j;\n\t\t}\n\t\tsmp_mb(); /* Enqueue before timer_pending(). */\n\t\tif ((rdp->nocb_cb_sleep ||\n\t\t     !rcu_segcblist_ready_cbs(&rdp->cblist)) &&\n\t\t    !timer_pending(&rdp->nocb_timer)) {\n\t\t\trcu_nocb_unlock_irqrestore(rdp, flags);\n\t\t\twake_nocb_gp_defer(rdp, RCU_NOCB_WAKE_FORCE,\n\t\t\t\t\t   TPS(\"WakeOvfIsDeferred\"));\n\t\t} else {\n\t\t\trcu_nocb_unlock_irqrestore(rdp, flags);\n\t\t\ttrace_rcu_nocb_wake(rcu_state.name, rdp->cpu, TPS(\"WakeNot\"));\n\t\t}\n\t} else {\n\t\trcu_nocb_unlock_irqrestore(rdp, flags);\n\t\ttrace_rcu_nocb_wake(rcu_state.name, rdp->cpu, TPS(\"WakeNot\"));\n\t}\n}",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_rcu_nocb_wake",
          "args": [
            "rcu_state.name",
            "rdp->cpu",
            "TPS(\"WakeNot\")"
          ],
          "line": 556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPS",
          "args": [
            "\"WakeNot\""
          ],
          "line": 556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_nocb_unlock_irqrestore",
          "args": [
            "rdp",
            "flags"
          ],
          "line": 555
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_nocb_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_nocb.h",
          "lines": "1479-1483",
          "snippet": "static void rcu_nocb_unlock_irqrestore(struct rcu_data *rdp,\n\t\t\t\t       unsigned long flags)\n{\n\tlocal_irq_restore(flags);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static void rcu_nocb_unlock_irqrestore(struct rcu_data *rdp,\n\t\t\t\t       unsigned long flags)\n{\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_rcu_nocb_wake",
          "args": [
            "rcu_state.name",
            "rdp->cpu",
            "TPS(\"WakeNot\")"
          ],
          "line": 552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPS",
          "args": [
            "\"WakeNot\""
          ],
          "line": 552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wake_nocb_gp_defer",
          "args": [
            "rdp",
            "RCU_NOCB_WAKE_FORCE",
            "TPS(\"WakeOvfIsDeferred\")"
          ],
          "line": 548
        },
        "resolved": true,
        "details": {
          "function_name": "wake_nocb_gp_defer",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_nocb.h",
          "lines": "274-299",
          "snippet": "static void wake_nocb_gp_defer(struct rcu_data *rdp, int waketype,\n\t\t\t       const char *reason)\n{\n\tunsigned long flags;\n\tstruct rcu_data *rdp_gp = rdp->nocb_gp_rdp;\n\n\traw_spin_lock_irqsave(&rdp_gp->nocb_gp_lock, flags);\n\n\t/*\n\t * Bypass wakeup overrides previous deferments. In case\n\t * of callback storm, no need to wake up too early.\n\t */\n\tif (waketype == RCU_NOCB_WAKE_BYPASS) {\n\t\tmod_timer(&rdp_gp->nocb_timer, jiffies + 2);\n\t\tWRITE_ONCE(rdp_gp->nocb_defer_wakeup, waketype);\n\t} else {\n\t\tif (rdp_gp->nocb_defer_wakeup < RCU_NOCB_WAKE)\n\t\t\tmod_timer(&rdp_gp->nocb_timer, jiffies + 1);\n\t\tif (rdp_gp->nocb_defer_wakeup < waketype)\n\t\t\tWRITE_ONCE(rdp_gp->nocb_defer_wakeup, waketype);\n\t}\n\n\traw_spin_unlock_irqrestore(&rdp_gp->nocb_gp_lock, flags);\n\n\ttrace_rcu_nocb_wake(rcu_state.name, rdp->cpu, reason);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static void wake_nocb_gp_defer(struct rcu_data *rdp, int waketype,\n\t\t\t       const char *reason)\n{\n\tunsigned long flags;\n\tstruct rcu_data *rdp_gp = rdp->nocb_gp_rdp;\n\n\traw_spin_lock_irqsave(&rdp_gp->nocb_gp_lock, flags);\n\n\t/*\n\t * Bypass wakeup overrides previous deferments. In case\n\t * of callback storm, no need to wake up too early.\n\t */\n\tif (waketype == RCU_NOCB_WAKE_BYPASS) {\n\t\tmod_timer(&rdp_gp->nocb_timer, jiffies + 2);\n\t\tWRITE_ONCE(rdp_gp->nocb_defer_wakeup, waketype);\n\t} else {\n\t\tif (rdp_gp->nocb_defer_wakeup < RCU_NOCB_WAKE)\n\t\t\tmod_timer(&rdp_gp->nocb_timer, jiffies + 1);\n\t\tif (rdp_gp->nocb_defer_wakeup < waketype)\n\t\t\tWRITE_ONCE(rdp_gp->nocb_defer_wakeup, waketype);\n\t}\n\n\traw_spin_unlock_irqrestore(&rdp_gp->nocb_gp_lock, flags);\n\n\ttrace_rcu_nocb_wake(rcu_state.name, rdp->cpu, reason);\n}"
        }
      },
      {
        "call_info": {
          "callee": "TPS",
          "args": [
            "\"WakeOvfIsDeferred\""
          ],
          "line": 549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timer_pending",
          "args": [
            "&rdp->nocb_timer"
          ],
          "line": 546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_segcblist_ready_cbs",
          "args": [
            "&rdp->cblist"
          ],
          "line": 545
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_ready_cbs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.c",
          "lines": "278-282",
          "snippet": "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp)\n{\n\treturn rcu_segcblist_is_enabled(rsclp) &&\n\t       &rsclp->head != READ_ONCE(rsclp->tails[RCU_DONE_TAIL]);\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/cpu.h>\n\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp)\n{\n\treturn rcu_segcblist_is_enabled(rsclp) &&\n\t       &rsclp->head != READ_ONCE(rsclp->tails[RCU_DONE_TAIL]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_mb",
          "args": [],
          "line": 543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_advance_cbs_nowake",
          "args": [
            "rdp->mynode",
            "rdp"
          ],
          "line": 540
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_advance_cbs_nowake",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "1596-1606",
          "snippet": "static void __maybe_unused rcu_advance_cbs_nowake(struct rcu_node *rnp,\n\t\t\t\t\t\t  struct rcu_data *rdp)\n{\n\trcu_lockdep_assert_cblist_protected(rdp);\n\tif (!rcu_seq_state(rcu_seq_current(&rnp->gp_seq)) || !raw_spin_trylock_rcu_node(rnp))\n\t\treturn;\n\t// The grace period cannot end while we hold the rcu_node lock.\n\tif (rcu_seq_state(rcu_seq_current(&rnp->gp_seq)))\n\t\tWARN_ON_ONCE(rcu_advance_cbs(rnp, rdp));\n\traw_spin_unlock_rcu_node(rnp);\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};",
            "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
            "static void check_cb_ovld_locked(struct rcu_data *rdp, struct rcu_node *rnp);",
            "static bool rcu_rdp_is_offloaded(struct rcu_data *rdp);",
            "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void check_cb_ovld_locked(struct rcu_data *rdp, struct rcu_node *rnp);\nstatic bool rcu_rdp_is_offloaded(struct rcu_data *rdp);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nstatic void __maybe_unused rcu_advance_cbs_nowake(struct rcu_node *rnp,\n\t\t\t\t\t\t  struct rcu_data *rdp)\n{\n\trcu_lockdep_assert_cblist_protected(rdp);\n\tif (!rcu_seq_state(rcu_seq_current(&rnp->gp_seq)) || !raw_spin_trylock_rcu_node(rnp))\n\t\treturn;\n\t// The grace period cannot end while we hold the rcu_node lock.\n\tif (rcu_seq_state(rcu_seq_current(&rnp->gp_seq)))\n\t\tWARN_ON_ONCE(rcu_advance_cbs(rnp, rdp));\n\traw_spin_unlock_rcu_node(rnp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_seq_done",
          "args": [
            "&rdp->mynode->gp_seq",
            "cur_gp_seq"
          ],
          "line": 539
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_seq_done",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu.h",
          "lines": "115-118",
          "snippet": "static inline bool rcu_seq_done(unsigned long *sp, unsigned long s)\n{\n\treturn ULONG_CMP_GE(READ_ONCE(*sp), s);\n}",
          "includes": [
            "#include <linux/rcu_node_tree.h>",
            "#include <trace/events/rcu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_node_tree.h>\n#include <trace/events/rcu.h>\n\nstatic inline bool rcu_seq_done(unsigned long *sp, unsigned long s)\n{\n\treturn ULONG_CMP_GE(READ_ONCE(*sp), s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_segcblist_nextgp",
          "args": [
            "&rdp->cblist",
            "&cur_gp_seq"
          ],
          "line": 538
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_nextgp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.c",
          "lines": "323-329",
          "snippet": "bool rcu_segcblist_nextgp(struct rcu_segcblist *rsclp, unsigned long *lp)\n{\n\tif (!rcu_segcblist_pend_cbs(rsclp))\n\t\treturn false;\n\t*lp = rsclp->gp_seq[RCU_WAIT_TAIL];\n\treturn true;\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/cpu.h>\n\nbool rcu_segcblist_nextgp(struct rcu_segcblist *rsclp, unsigned long *lp)\n{\n\tif (!rcu_segcblist_pend_cbs(rsclp))\n\t\treturn false;\n\t*lp = rsclp->gp_seq[RCU_WAIT_TAIL];\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "TPS",
          "args": [
            "\"WakeEmptyIsDeferred\""
          ],
          "line": 531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_rcu_nocb_wake",
          "args": [
            "rcu_state.name",
            "rdp->cpu",
            "TPS(\"WakeEmpty\")"
          ],
          "line": 526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPS",
          "args": [
            "\"WakeEmpty\""
          ],
          "line": 527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wake_nocb_gp",
          "args": [
            "rdp",
            "false"
          ],
          "line": 525
        },
        "resolved": true,
        "details": {
          "function_name": "wake_nocb_gp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_nocb.h",
          "lines": "261-268",
          "snippet": "static bool wake_nocb_gp(struct rcu_data *rdp, bool force)\n{\n\tunsigned long flags;\n\tstruct rcu_data *rdp_gp = rdp->nocb_gp_rdp;\n\n\traw_spin_lock_irqsave(&rdp_gp->nocb_gp_lock, flags);\n\treturn __wake_nocb_gp(rdp_gp, rdp, force, flags);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static bool wake_nocb_gp(struct rcu_data *rdp, bool force)\n{\n\tunsigned long flags;\n\tstruct rcu_data *rdp_gp = rdp->nocb_gp_rdp;\n\n\traw_spin_lock_irqsave(&rdp_gp->nocb_gp_lock, flags);\n\treturn __wake_nocb_gp(rdp_gp, rdp, force, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "irqs_disabled_flags",
          "args": [
            "flags"
          ],
          "line": 522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_segcblist_n_cbs",
          "args": [
            "&rdp->cblist"
          ],
          "line": 519
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_n_cbs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "47-54",
          "snippet": "static inline long rcu_segcblist_n_cbs(struct rcu_segcblist *rsclp)\n{\n#ifdef CONFIG_RCU_NOCB_CPU\n\treturn atomic_long_read(&rsclp->len);\n#else\n\treturn READ_ONCE(rsclp->len);\n#endif\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "long rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nlong rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline long rcu_segcblist_n_cbs(struct rcu_segcblist *rsclp)\n{\n#ifdef CONFIG_RCU_NOCB_CPU\n\treturn atomic_long_read(&rsclp->len);\n#else\n\treturn READ_ONCE(rsclp->len);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_rcu_nocb_wake",
          "args": [
            "rcu_state.name",
            "rdp->cpu",
            "TPS(\"WakeNotPoll\")"
          ],
          "line": 514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPS",
          "args": [
            "\"WakeNotPoll\""
          ],
          "line": 515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rdp->nocb_gp_kthread"
          ],
          "line": 511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__releases",
          "args": [
            "rdp->nocb_lock"
          ],
          "line": 503
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "static void __call_rcu_nocb_wake(struct rcu_data *rdp, bool was_alldone,\n\t\t\t\t unsigned long flags)\n\t\t\t\t __releases(rdp->nocb_lock)\n{\n\tunsigned long cur_gp_seq;\n\tunsigned long j;\n\tlong len;\n\tstruct task_struct *t;\n\n\t// If we are being polled or there is no kthread, just leave.\n\tt = READ_ONCE(rdp->nocb_gp_kthread);\n\tif (rcu_nocb_poll || !t) {\n\t\trcu_nocb_unlock_irqrestore(rdp, flags);\n\t\ttrace_rcu_nocb_wake(rcu_state.name, rdp->cpu,\n\t\t\t\t    TPS(\"WakeNotPoll\"));\n\t\treturn;\n\t}\n\t// Need to actually to a wakeup.\n\tlen = rcu_segcblist_n_cbs(&rdp->cblist);\n\tif (was_alldone) {\n\t\trdp->qlen_last_fqs_check = len;\n\t\tif (!irqs_disabled_flags(flags)) {\n\t\t\t/* ... if queue was empty ... */\n\t\t\trcu_nocb_unlock_irqrestore(rdp, flags);\n\t\t\twake_nocb_gp(rdp, false);\n\t\t\ttrace_rcu_nocb_wake(rcu_state.name, rdp->cpu,\n\t\t\t\t\t    TPS(\"WakeEmpty\"));\n\t\t} else {\n\t\t\trcu_nocb_unlock_irqrestore(rdp, flags);\n\t\t\twake_nocb_gp_defer(rdp, RCU_NOCB_WAKE,\n\t\t\t\t\t   TPS(\"WakeEmptyIsDeferred\"));\n\t\t}\n\t} else if (len > rdp->qlen_last_fqs_check + qhimark) {\n\t\t/* ... or if many callbacks queued. */\n\t\trdp->qlen_last_fqs_check = len;\n\t\tj = jiffies;\n\t\tif (j != rdp->nocb_gp_adv_time &&\n\t\t    rcu_segcblist_nextgp(&rdp->cblist, &cur_gp_seq) &&\n\t\t    rcu_seq_done(&rdp->mynode->gp_seq, cur_gp_seq)) {\n\t\t\trcu_advance_cbs_nowake(rdp->mynode, rdp);\n\t\t\trdp->nocb_gp_adv_time = j;\n\t\t}\n\t\tsmp_mb(); /* Enqueue before timer_pending(). */\n\t\tif ((rdp->nocb_cb_sleep ||\n\t\t     !rcu_segcblist_ready_cbs(&rdp->cblist)) &&\n\t\t    !timer_pending(&rdp->nocb_timer)) {\n\t\t\trcu_nocb_unlock_irqrestore(rdp, flags);\n\t\t\twake_nocb_gp_defer(rdp, RCU_NOCB_WAKE_FORCE,\n\t\t\t\t\t   TPS(\"WakeOvfIsDeferred\"));\n\t\t} else {\n\t\t\trcu_nocb_unlock_irqrestore(rdp, flags);\n\t\t\ttrace_rcu_nocb_wake(rcu_state.name, rdp->cpu, TPS(\"WakeNot\"));\n\t\t}\n\t} else {\n\t\trcu_nocb_unlock_irqrestore(rdp, flags);\n\t\ttrace_rcu_nocb_wake(rcu_state.name, rdp->cpu, TPS(\"WakeNot\"));\n\t}\n}"
  },
  {
    "function_name": "rcu_nocb_try_bypass",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_nocb.h",
    "lines": "380-493",
    "snippet": "static bool rcu_nocb_try_bypass(struct rcu_data *rdp, struct rcu_head *rhp,\n\t\t\t\tbool *was_alldone, unsigned long flags)\n{\n\tunsigned long c;\n\tunsigned long cur_gp_seq;\n\tunsigned long j = jiffies;\n\tlong ncbs = rcu_cblist_n_cbs(&rdp->nocb_bypass);\n\n\tlockdep_assert_irqs_disabled();\n\n\t// Pure softirq/rcuc based processing: no bypassing, no\n\t// locking.\n\tif (!rcu_rdp_is_offloaded(rdp)) {\n\t\t*was_alldone = !rcu_segcblist_pend_cbs(&rdp->cblist);\n\t\treturn false;\n\t}\n\n\t// In the process of (de-)offloading: no bypassing, but\n\t// locking.\n\tif (!rcu_segcblist_completely_offloaded(&rdp->cblist)) {\n\t\trcu_nocb_lock(rdp);\n\t\t*was_alldone = !rcu_segcblist_pend_cbs(&rdp->cblist);\n\t\treturn false; /* Not offloaded, no bypassing. */\n\t}\n\n\t// Don't use ->nocb_bypass during early boot.\n\tif (rcu_scheduler_active != RCU_SCHEDULER_RUNNING) {\n\t\trcu_nocb_lock(rdp);\n\t\tWARN_ON_ONCE(rcu_cblist_n_cbs(&rdp->nocb_bypass));\n\t\t*was_alldone = !rcu_segcblist_pend_cbs(&rdp->cblist);\n\t\treturn false;\n\t}\n\n\t// If we have advanced to a new jiffy, reset counts to allow\n\t// moving back from ->nocb_bypass to ->cblist.\n\tif (j == rdp->nocb_nobypass_last) {\n\t\tc = rdp->nocb_nobypass_count + 1;\n\t} else {\n\t\tWRITE_ONCE(rdp->nocb_nobypass_last, j);\n\t\tc = rdp->nocb_nobypass_count - nocb_nobypass_lim_per_jiffy;\n\t\tif (ULONG_CMP_LT(rdp->nocb_nobypass_count,\n\t\t\t\t nocb_nobypass_lim_per_jiffy))\n\t\t\tc = 0;\n\t\telse if (c > nocb_nobypass_lim_per_jiffy)\n\t\t\tc = nocb_nobypass_lim_per_jiffy;\n\t}\n\tWRITE_ONCE(rdp->nocb_nobypass_count, c);\n\n\t// If there hasn't yet been all that many ->cblist enqueues\n\t// this jiffy, tell the caller to enqueue onto ->cblist.  But flush\n\t// ->nocb_bypass first.\n\tif (rdp->nocb_nobypass_count < nocb_nobypass_lim_per_jiffy) {\n\t\trcu_nocb_lock(rdp);\n\t\t*was_alldone = !rcu_segcblist_pend_cbs(&rdp->cblist);\n\t\tif (*was_alldone)\n\t\t\ttrace_rcu_nocb_wake(rcu_state.name, rdp->cpu,\n\t\t\t\t\t    TPS(\"FirstQ\"));\n\t\tWARN_ON_ONCE(!rcu_nocb_flush_bypass(rdp, NULL, j));\n\t\tWARN_ON_ONCE(rcu_cblist_n_cbs(&rdp->nocb_bypass));\n\t\treturn false; // Caller must enqueue the callback.\n\t}\n\n\t// If ->nocb_bypass has been used too long or is too full,\n\t// flush ->nocb_bypass to ->cblist.\n\tif ((ncbs && j != READ_ONCE(rdp->nocb_bypass_first)) ||\n\t    ncbs >= qhimark) {\n\t\trcu_nocb_lock(rdp);\n\t\tif (!rcu_nocb_flush_bypass(rdp, rhp, j)) {\n\t\t\t*was_alldone = !rcu_segcblist_pend_cbs(&rdp->cblist);\n\t\t\tif (*was_alldone)\n\t\t\t\ttrace_rcu_nocb_wake(rcu_state.name, rdp->cpu,\n\t\t\t\t\t\t    TPS(\"FirstQ\"));\n\t\t\tWARN_ON_ONCE(rcu_cblist_n_cbs(&rdp->nocb_bypass));\n\t\t\treturn false; // Caller must enqueue the callback.\n\t\t}\n\t\tif (j != rdp->nocb_gp_adv_time &&\n\t\t    rcu_segcblist_nextgp(&rdp->cblist, &cur_gp_seq) &&\n\t\t    rcu_seq_done(&rdp->mynode->gp_seq, cur_gp_seq)) {\n\t\t\trcu_advance_cbs_nowake(rdp->mynode, rdp);\n\t\t\trdp->nocb_gp_adv_time = j;\n\t\t}\n\t\trcu_nocb_unlock_irqrestore(rdp, flags);\n\t\treturn true; // Callback already enqueued.\n\t}\n\n\t// We need to use the bypass.\n\trcu_nocb_wait_contended(rdp);\n\trcu_nocb_bypass_lock(rdp);\n\tncbs = rcu_cblist_n_cbs(&rdp->nocb_bypass);\n\trcu_segcblist_inc_len(&rdp->cblist); /* Must precede enqueue. */\n\trcu_cblist_enqueue(&rdp->nocb_bypass, rhp);\n\tif (!ncbs) {\n\t\tWRITE_ONCE(rdp->nocb_bypass_first, j);\n\t\ttrace_rcu_nocb_wake(rcu_state.name, rdp->cpu, TPS(\"FirstBQ\"));\n\t}\n\trcu_nocb_bypass_unlock(rdp);\n\tsmp_mb(); /* Order enqueue before wake. */\n\tif (ncbs) {\n\t\tlocal_irq_restore(flags);\n\t} else {\n\t\t// No-CBs GP kthread might be indefinitely asleep, if so, wake.\n\t\trcu_nocb_lock(rdp); // Rare during call_rcu() flood.\n\t\tif (!rcu_segcblist_pend_cbs(&rdp->cblist)) {\n\t\t\ttrace_rcu_nocb_wake(rcu_state.name, rdp->cpu,\n\t\t\t\t\t    TPS(\"FirstBQwake\"));\n\t\t\t__call_rcu_nocb_wake(rdp, true, flags);\n\t\t} else {\n\t\t\ttrace_rcu_nocb_wake(rcu_state.name, rdp->cpu,\n\t\t\t\t\t    TPS(\"FirstBQnoWake\"));\n\t\t\trcu_nocb_unlock_irqrestore(rdp, flags);\n\t\t}\n\t}\n\treturn true; // Callback already enqueued.\n}",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_nocb_unlock_irqrestore",
          "args": [
            "rdp",
            "flags"
          ],
          "line": 489
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_nocb_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_nocb.h",
          "lines": "1479-1483",
          "snippet": "static void rcu_nocb_unlock_irqrestore(struct rcu_data *rdp,\n\t\t\t\t       unsigned long flags)\n{\n\tlocal_irq_restore(flags);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static void rcu_nocb_unlock_irqrestore(struct rcu_data *rdp,\n\t\t\t\t       unsigned long flags)\n{\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_rcu_nocb_wake",
          "args": [
            "rcu_state.name",
            "rdp->cpu",
            "TPS(\"FirstBQnoWake\")"
          ],
          "line": 487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPS",
          "args": [
            "\"FirstBQnoWake\""
          ],
          "line": 488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__call_rcu_nocb_wake",
          "args": [
            "rdp",
            "true",
            "flags"
          ],
          "line": 485
        },
        "resolved": true,
        "details": {
          "function_name": "__call_rcu_nocb_wake",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_nocb.h",
          "lines": "1516-1520",
          "snippet": "static void __call_rcu_nocb_wake(struct rcu_data *rdp, bool was_empty,\n\t\t\t\t unsigned long flags)\n{\n\tWARN_ON_ONCE(1);  /* Should be dead code! */\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static void __call_rcu_nocb_wake(struct rcu_data *rdp, bool was_empty,\n\t\t\t\t unsigned long flags)\n{\n\tWARN_ON_ONCE(1);  /* Should be dead code! */\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_rcu_nocb_wake",
          "args": [
            "rcu_state.name",
            "rdp->cpu",
            "TPS(\"FirstBQwake\")"
          ],
          "line": 483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPS",
          "args": [
            "\"FirstBQwake\""
          ],
          "line": 484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_segcblist_pend_cbs",
          "args": [
            "&rdp->cblist"
          ],
          "line": 482
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_pend_cbs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.c",
          "lines": "288-292",
          "snippet": "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp)\n{\n\treturn rcu_segcblist_is_enabled(rsclp) &&\n\t       !rcu_segcblist_restempty(rsclp, RCU_DONE_TAIL);\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/cpu.h>\n\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp)\n{\n\treturn rcu_segcblist_is_enabled(rsclp) &&\n\t       !rcu_segcblist_restempty(rsclp, RCU_DONE_TAIL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_nocb_lock",
          "args": [
            "rdp"
          ],
          "line": 481
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_nocb_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_nocb.h",
          "lines": "1469-1471",
          "snippet": "static void rcu_nocb_lock(struct rcu_data *rdp)\n{\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static void rcu_nocb_lock(struct rcu_data *rdp)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_mb",
          "args": [],
          "line": 476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_nocb_bypass_unlock",
          "args": [
            "rdp"
          ],
          "line": 475
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_nocb_bypass_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_nocb.h",
          "lines": "144-149",
          "snippet": "static void rcu_nocb_bypass_unlock(struct rcu_data *rdp)\n\t__releases(&rdp->nocb_bypass_lock)\n{\n\tlockdep_assert_irqs_disabled();\n\traw_spin_unlock(&rdp->nocb_bypass_lock);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static void rcu_nocb_bypass_unlock(struct rcu_data *rdp)\n\t__releases(&rdp->nocb_bypass_lock)\n{\n\tlockdep_assert_irqs_disabled();\n\traw_spin_unlock(&rdp->nocb_bypass_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_rcu_nocb_wake",
          "args": [
            "rcu_state.name",
            "rdp->cpu",
            "TPS(\"FirstBQ\")"
          ],
          "line": 473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPS",
          "args": [
            "\"FirstBQ\""
          ],
          "line": 473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "rdp->nocb_bypass_first",
            "j"
          ],
          "line": 472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_cblist_enqueue",
          "args": [
            "&rdp->nocb_bypass",
            "rhp"
          ],
          "line": 470
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_cblist_enqueue",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.c",
          "lines": "28-33",
          "snippet": "void rcu_cblist_enqueue(struct rcu_cblist *rclp, struct rcu_head *rhp)\n{\n\t*rclp->tail = rhp;\n\trclp->tail = &rhp->next;\n\tWRITE_ONCE(rclp->len, rclp->len + 1);\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/cpu.h>\n\nvoid rcu_cblist_enqueue(struct rcu_cblist *rclp, struct rcu_head *rhp)\n{\n\t*rclp->tail = rhp;\n\trclp->tail = &rhp->next;\n\tWRITE_ONCE(rclp->len, rclp->len + 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_segcblist_inc_len",
          "args": [
            "&rdp->cblist"
          ],
          "line": 469
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_inc_len",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.c",
          "lines": "229-232",
          "snippet": "void rcu_segcblist_inc_len(struct rcu_segcblist *rsclp)\n{\n\trcu_segcblist_add_len(rsclp, 1);\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/cpu.h>\n\nvoid rcu_segcblist_inc_len(struct rcu_segcblist *rsclp)\n{\n\trcu_segcblist_add_len(rsclp, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_cblist_n_cbs",
          "args": [
            "&rdp->nocb_bypass"
          ],
          "line": 468
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_cblist_n_cbs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "13-16",
          "snippet": "static inline long rcu_cblist_n_cbs(struct rcu_cblist *rclp)\n{\n\treturn READ_ONCE(rclp->len);\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void rcu_cblist_init(struct rcu_cblist *rclp);",
            "struct rcu_head *rcu_cblist_dequeue(struct rcu_cblist *rclp);",
            "void rcu_segcblist_extract_done_cbs(struct rcu_segcblist *rsclp,\n\t\t\t\t    struct rcu_cblist *rclp);",
            "void rcu_segcblist_extract_pend_cbs(struct rcu_segcblist *rsclp,\n\t\t\t\t    struct rcu_cblist *rclp);",
            "void rcu_segcblist_insert_count(struct rcu_segcblist *rsclp,\n\t\t\t\tstruct rcu_cblist *rclp);",
            "void rcu_segcblist_insert_done_cbs(struct rcu_segcblist *rsclp,\n\t\t\t\t   struct rcu_cblist *rclp);",
            "void rcu_segcblist_insert_pend_cbs(struct rcu_segcblist *rsclp,\n\t\t\t\t   struct rcu_cblist *rclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nvoid rcu_cblist_init(struct rcu_cblist *rclp);\nstruct rcu_head *rcu_cblist_dequeue(struct rcu_cblist *rclp);\nvoid rcu_segcblist_extract_done_cbs(struct rcu_segcblist *rsclp,\n\t\t\t\t    struct rcu_cblist *rclp);\nvoid rcu_segcblist_extract_pend_cbs(struct rcu_segcblist *rsclp,\n\t\t\t\t    struct rcu_cblist *rclp);\nvoid rcu_segcblist_insert_count(struct rcu_segcblist *rsclp,\n\t\t\t\tstruct rcu_cblist *rclp);\nvoid rcu_segcblist_insert_done_cbs(struct rcu_segcblist *rsclp,\n\t\t\t\t   struct rcu_cblist *rclp);\nvoid rcu_segcblist_insert_pend_cbs(struct rcu_segcblist *rsclp,\n\t\t\t\t   struct rcu_cblist *rclp);\n\nstatic inline long rcu_cblist_n_cbs(struct rcu_cblist *rclp)\n{\n\treturn READ_ONCE(rclp->len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_nocb_bypass_lock",
          "args": [
            "rdp"
          ],
          "line": 467
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_nocb_bypass_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_nocb.h",
          "lines": "100-112",
          "snippet": "static void rcu_nocb_bypass_lock(struct rcu_data *rdp)\n\t__acquires(&rdp->nocb_bypass_lock)\n{\n\tlockdep_assert_irqs_disabled();\n\tif (raw_spin_trylock(&rdp->nocb_bypass_lock))\n\t\treturn;\n\tatomic_inc(&rdp->nocb_lock_contended);\n\tWARN_ON_ONCE(smp_processor_id() != rdp->cpu);\n\tsmp_mb__after_atomic(); /* atomic_inc() before lock. */\n\traw_spin_lock(&rdp->nocb_bypass_lock);\n\tsmp_mb__before_atomic(); /* atomic_dec() after lock. */\n\tatomic_dec(&rdp->nocb_lock_contended);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static void rcu_nocb_bypass_lock(struct rcu_data *rdp)\n\t__acquires(&rdp->nocb_bypass_lock)\n{\n\tlockdep_assert_irqs_disabled();\n\tif (raw_spin_trylock(&rdp->nocb_bypass_lock))\n\t\treturn;\n\tatomic_inc(&rdp->nocb_lock_contended);\n\tWARN_ON_ONCE(smp_processor_id() != rdp->cpu);\n\tsmp_mb__after_atomic(); /* atomic_inc() before lock. */\n\traw_spin_lock(&rdp->nocb_bypass_lock);\n\tsmp_mb__before_atomic(); /* atomic_dec() after lock. */\n\tatomic_dec(&rdp->nocb_lock_contended);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_nocb_wait_contended",
          "args": [
            "rdp"
          ],
          "line": 466
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_nocb_wait_contended",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_nocb.h",
          "lines": "124-129",
          "snippet": "static void rcu_nocb_wait_contended(struct rcu_data *rdp)\n{\n\tWARN_ON_ONCE(smp_processor_id() != rdp->cpu);\n\twhile (WARN_ON_ONCE(atomic_read(&rdp->nocb_lock_contended)))\n\t\tcpu_relax();\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static void rcu_nocb_wait_contended(struct rcu_data *rdp)\n{\n\tWARN_ON_ONCE(smp_processor_id() != rdp->cpu);\n\twhile (WARN_ON_ONCE(atomic_read(&rdp->nocb_lock_contended)))\n\t\tcpu_relax();\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_advance_cbs_nowake",
          "args": [
            "rdp->mynode",
            "rdp"
          ],
          "line": 458
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_advance_cbs_nowake",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "1596-1606",
          "snippet": "static void __maybe_unused rcu_advance_cbs_nowake(struct rcu_node *rnp,\n\t\t\t\t\t\t  struct rcu_data *rdp)\n{\n\trcu_lockdep_assert_cblist_protected(rdp);\n\tif (!rcu_seq_state(rcu_seq_current(&rnp->gp_seq)) || !raw_spin_trylock_rcu_node(rnp))\n\t\treturn;\n\t// The grace period cannot end while we hold the rcu_node lock.\n\tif (rcu_seq_state(rcu_seq_current(&rnp->gp_seq)))\n\t\tWARN_ON_ONCE(rcu_advance_cbs(rnp, rdp));\n\traw_spin_unlock_rcu_node(rnp);\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};",
            "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
            "static void check_cb_ovld_locked(struct rcu_data *rdp, struct rcu_node *rnp);",
            "static bool rcu_rdp_is_offloaded(struct rcu_data *rdp);",
            "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void check_cb_ovld_locked(struct rcu_data *rdp, struct rcu_node *rnp);\nstatic bool rcu_rdp_is_offloaded(struct rcu_data *rdp);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nstatic void __maybe_unused rcu_advance_cbs_nowake(struct rcu_node *rnp,\n\t\t\t\t\t\t  struct rcu_data *rdp)\n{\n\trcu_lockdep_assert_cblist_protected(rdp);\n\tif (!rcu_seq_state(rcu_seq_current(&rnp->gp_seq)) || !raw_spin_trylock_rcu_node(rnp))\n\t\treturn;\n\t// The grace period cannot end while we hold the rcu_node lock.\n\tif (rcu_seq_state(rcu_seq_current(&rnp->gp_seq)))\n\t\tWARN_ON_ONCE(rcu_advance_cbs(rnp, rdp));\n\traw_spin_unlock_rcu_node(rnp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_seq_done",
          "args": [
            "&rdp->mynode->gp_seq",
            "cur_gp_seq"
          ],
          "line": 457
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_seq_done",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu.h",
          "lines": "115-118",
          "snippet": "static inline bool rcu_seq_done(unsigned long *sp, unsigned long s)\n{\n\treturn ULONG_CMP_GE(READ_ONCE(*sp), s);\n}",
          "includes": [
            "#include <linux/rcu_node_tree.h>",
            "#include <trace/events/rcu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_node_tree.h>\n#include <trace/events/rcu.h>\n\nstatic inline bool rcu_seq_done(unsigned long *sp, unsigned long s)\n{\n\treturn ULONG_CMP_GE(READ_ONCE(*sp), s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_segcblist_nextgp",
          "args": [
            "&rdp->cblist",
            "&cur_gp_seq"
          ],
          "line": 456
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_nextgp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.c",
          "lines": "323-329",
          "snippet": "bool rcu_segcblist_nextgp(struct rcu_segcblist *rsclp, unsigned long *lp)\n{\n\tif (!rcu_segcblist_pend_cbs(rsclp))\n\t\treturn false;\n\t*lp = rsclp->gp_seq[RCU_WAIT_TAIL];\n\treturn true;\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/cpu.h>\n\nbool rcu_segcblist_nextgp(struct rcu_segcblist *rsclp, unsigned long *lp)\n{\n\tif (!rcu_segcblist_pend_cbs(rsclp))\n\t\treturn false;\n\t*lp = rsclp->gp_seq[RCU_WAIT_TAIL];\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "rcu_cblist_n_cbs(&rdp->nocb_bypass)"
          ],
          "line": 452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_rcu_nocb_wake",
          "args": [
            "rcu_state.name",
            "rdp->cpu",
            "TPS(\"FirstQ\")"
          ],
          "line": 450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPS",
          "args": [
            "\"FirstQ\""
          ],
          "line": 451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_nocb_flush_bypass",
          "args": [
            "rdp",
            "rhp",
            "j"
          ],
          "line": 447
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_nocb_flush_bypass",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_nocb.h",
          "lines": "1504-1508",
          "snippet": "static bool rcu_nocb_flush_bypass(struct rcu_data *rdp, struct rcu_head *rhp,\n\t\t\t\t  unsigned long j)\n{\n\treturn true;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static bool rcu_nocb_flush_bypass(struct rcu_data *rdp, struct rcu_head *rhp,\n\t\t\t\t  unsigned long j)\n{\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rdp->nocb_bypass_first"
          ],
          "line": 444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "rcu_cblist_n_cbs(&rdp->nocb_bypass)"
          ],
          "line": 438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!rcu_nocb_flush_bypass(rdp, NULL, j)"
          ],
          "line": 437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_rcu_nocb_wake",
          "args": [
            "rcu_state.name",
            "rdp->cpu",
            "TPS(\"FirstQ\")"
          ],
          "line": 435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPS",
          "args": [
            "\"FirstQ\""
          ],
          "line": 436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "rdp->nocb_nobypass_count",
            "c"
          ],
          "line": 426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ULONG_CMP_LT",
          "args": [
            "rdp->nocb_nobypass_count",
            "nocb_nobypass_lim_per_jiffy"
          ],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "rdp->nocb_nobypass_last",
            "j"
          ],
          "line": 418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "rcu_cblist_n_cbs(&rdp->nocb_bypass)"
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_segcblist_completely_offloaded",
          "args": [
            "&rdp->cblist"
          ],
          "line": 399
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_completely_offloaded",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "96-103",
          "snippet": "static inline bool rcu_segcblist_completely_offloaded(struct rcu_segcblist *rsclp)\n{\n\tif (IS_ENABLED(CONFIG_RCU_NOCB_CPU) &&\n\t    !rcu_segcblist_test_flags(rsclp, SEGCBLIST_RCU_CORE))\n\t\treturn true;\n\n\treturn false;\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "long rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nlong rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_completely_offloaded(struct rcu_segcblist *rsclp)\n{\n\tif (IS_ENABLED(CONFIG_RCU_NOCB_CPU) &&\n\t    !rcu_segcblist_test_flags(rsclp, SEGCBLIST_RCU_CORE))\n\t\treturn true;\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_rdp_is_offloaded",
          "args": [
            "rdp"
          ],
          "line": 392
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_rdp_is_offloaded",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "16-38",
          "snippet": "static bool rcu_rdp_is_offloaded(struct rcu_data *rdp)\n{\n\t/*\n\t * In order to read the offloaded state of an rdp in a safe\n\t * and stable way and prevent from its value to be changed\n\t * under us, we must either hold the barrier mutex, the cpu\n\t * hotplug lock (read or write) or the nocb lock. Local\n\t * non-preemptible reads are also safe. NOCB kthreads and\n\t * timers have their own means of synchronization against the\n\t * offloaded state updaters.\n\t */\n\tRCU_LOCKDEP_WARN(\n\t\t!(lockdep_is_held(&rcu_state.barrier_mutex) ||\n\t\t  (IS_ENABLED(CONFIG_HOTPLUG_CPU) && lockdep_is_cpus_held()) ||\n\t\t  rcu_lockdep_is_held_nocb(rdp) ||\n\t\t  (rdp == this_cpu_ptr(&rcu_data) &&\n\t\t   !(IS_ENABLED(CONFIG_PREEMPT_COUNT) && preemptible())) ||\n\t\t  rcu_current_is_nocb_kthread(rdp)),\n\t\t\"Unsafe read of RCU_NOCB offloaded state\"\n\t);\n\n\treturn rcu_segcblist_is_offloaded(&rdp->cblist);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nstatic bool rcu_rdp_is_offloaded(struct rcu_data *rdp)\n{\n\t/*\n\t * In order to read the offloaded state of an rdp in a safe\n\t * and stable way and prevent from its value to be changed\n\t * under us, we must either hold the barrier mutex, the cpu\n\t * hotplug lock (read or write) or the nocb lock. Local\n\t * non-preemptible reads are also safe. NOCB kthreads and\n\t * timers have their own means of synchronization against the\n\t * offloaded state updaters.\n\t */\n\tRCU_LOCKDEP_WARN(\n\t\t!(lockdep_is_held(&rcu_state.barrier_mutex) ||\n\t\t  (IS_ENABLED(CONFIG_HOTPLUG_CPU) && lockdep_is_cpus_held()) ||\n\t\t  rcu_lockdep_is_held_nocb(rdp) ||\n\t\t  (rdp == this_cpu_ptr(&rcu_data) &&\n\t\t   !(IS_ENABLED(CONFIG_PREEMPT_COUNT) && preemptible())) ||\n\t\t  rcu_current_is_nocb_kthread(rdp)),\n\t\t\"Unsafe read of RCU_NOCB offloaded state\"\n\t);\n\n\treturn rcu_segcblist_is_offloaded(&rdp->cblist);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_assert_irqs_disabled",
          "args": [],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "static bool rcu_nocb_try_bypass(struct rcu_data *rdp, struct rcu_head *rhp,\n\t\t\t\tbool *was_alldone, unsigned long flags)\n{\n\tunsigned long c;\n\tunsigned long cur_gp_seq;\n\tunsigned long j = jiffies;\n\tlong ncbs = rcu_cblist_n_cbs(&rdp->nocb_bypass);\n\n\tlockdep_assert_irqs_disabled();\n\n\t// Pure softirq/rcuc based processing: no bypassing, no\n\t// locking.\n\tif (!rcu_rdp_is_offloaded(rdp)) {\n\t\t*was_alldone = !rcu_segcblist_pend_cbs(&rdp->cblist);\n\t\treturn false;\n\t}\n\n\t// In the process of (de-)offloading: no bypassing, but\n\t// locking.\n\tif (!rcu_segcblist_completely_offloaded(&rdp->cblist)) {\n\t\trcu_nocb_lock(rdp);\n\t\t*was_alldone = !rcu_segcblist_pend_cbs(&rdp->cblist);\n\t\treturn false; /* Not offloaded, no bypassing. */\n\t}\n\n\t// Don't use ->nocb_bypass during early boot.\n\tif (rcu_scheduler_active != RCU_SCHEDULER_RUNNING) {\n\t\trcu_nocb_lock(rdp);\n\t\tWARN_ON_ONCE(rcu_cblist_n_cbs(&rdp->nocb_bypass));\n\t\t*was_alldone = !rcu_segcblist_pend_cbs(&rdp->cblist);\n\t\treturn false;\n\t}\n\n\t// If we have advanced to a new jiffy, reset counts to allow\n\t// moving back from ->nocb_bypass to ->cblist.\n\tif (j == rdp->nocb_nobypass_last) {\n\t\tc = rdp->nocb_nobypass_count + 1;\n\t} else {\n\t\tWRITE_ONCE(rdp->nocb_nobypass_last, j);\n\t\tc = rdp->nocb_nobypass_count - nocb_nobypass_lim_per_jiffy;\n\t\tif (ULONG_CMP_LT(rdp->nocb_nobypass_count,\n\t\t\t\t nocb_nobypass_lim_per_jiffy))\n\t\t\tc = 0;\n\t\telse if (c > nocb_nobypass_lim_per_jiffy)\n\t\t\tc = nocb_nobypass_lim_per_jiffy;\n\t}\n\tWRITE_ONCE(rdp->nocb_nobypass_count, c);\n\n\t// If there hasn't yet been all that many ->cblist enqueues\n\t// this jiffy, tell the caller to enqueue onto ->cblist.  But flush\n\t// ->nocb_bypass first.\n\tif (rdp->nocb_nobypass_count < nocb_nobypass_lim_per_jiffy) {\n\t\trcu_nocb_lock(rdp);\n\t\t*was_alldone = !rcu_segcblist_pend_cbs(&rdp->cblist);\n\t\tif (*was_alldone)\n\t\t\ttrace_rcu_nocb_wake(rcu_state.name, rdp->cpu,\n\t\t\t\t\t    TPS(\"FirstQ\"));\n\t\tWARN_ON_ONCE(!rcu_nocb_flush_bypass(rdp, NULL, j));\n\t\tWARN_ON_ONCE(rcu_cblist_n_cbs(&rdp->nocb_bypass));\n\t\treturn false; // Caller must enqueue the callback.\n\t}\n\n\t// If ->nocb_bypass has been used too long or is too full,\n\t// flush ->nocb_bypass to ->cblist.\n\tif ((ncbs && j != READ_ONCE(rdp->nocb_bypass_first)) ||\n\t    ncbs >= qhimark) {\n\t\trcu_nocb_lock(rdp);\n\t\tif (!rcu_nocb_flush_bypass(rdp, rhp, j)) {\n\t\t\t*was_alldone = !rcu_segcblist_pend_cbs(&rdp->cblist);\n\t\t\tif (*was_alldone)\n\t\t\t\ttrace_rcu_nocb_wake(rcu_state.name, rdp->cpu,\n\t\t\t\t\t\t    TPS(\"FirstQ\"));\n\t\t\tWARN_ON_ONCE(rcu_cblist_n_cbs(&rdp->nocb_bypass));\n\t\t\treturn false; // Caller must enqueue the callback.\n\t\t}\n\t\tif (j != rdp->nocb_gp_adv_time &&\n\t\t    rcu_segcblist_nextgp(&rdp->cblist, &cur_gp_seq) &&\n\t\t    rcu_seq_done(&rdp->mynode->gp_seq, cur_gp_seq)) {\n\t\t\trcu_advance_cbs_nowake(rdp->mynode, rdp);\n\t\t\trdp->nocb_gp_adv_time = j;\n\t\t}\n\t\trcu_nocb_unlock_irqrestore(rdp, flags);\n\t\treturn true; // Callback already enqueued.\n\t}\n\n\t// We need to use the bypass.\n\trcu_nocb_wait_contended(rdp);\n\trcu_nocb_bypass_lock(rdp);\n\tncbs = rcu_cblist_n_cbs(&rdp->nocb_bypass);\n\trcu_segcblist_inc_len(&rdp->cblist); /* Must precede enqueue. */\n\trcu_cblist_enqueue(&rdp->nocb_bypass, rhp);\n\tif (!ncbs) {\n\t\tWRITE_ONCE(rdp->nocb_bypass_first, j);\n\t\ttrace_rcu_nocb_wake(rcu_state.name, rdp->cpu, TPS(\"FirstBQ\"));\n\t}\n\trcu_nocb_bypass_unlock(rdp);\n\tsmp_mb(); /* Order enqueue before wake. */\n\tif (ncbs) {\n\t\tlocal_irq_restore(flags);\n\t} else {\n\t\t// No-CBs GP kthread might be indefinitely asleep, if so, wake.\n\t\trcu_nocb_lock(rdp); // Rare during call_rcu() flood.\n\t\tif (!rcu_segcblist_pend_cbs(&rdp->cblist)) {\n\t\t\ttrace_rcu_nocb_wake(rcu_state.name, rdp->cpu,\n\t\t\t\t\t    TPS(\"FirstBQwake\"));\n\t\t\t__call_rcu_nocb_wake(rdp, true, flags);\n\t\t} else {\n\t\t\ttrace_rcu_nocb_wake(rcu_state.name, rdp->cpu,\n\t\t\t\t\t    TPS(\"FirstBQnoWake\"));\n\t\t\trcu_nocb_unlock_irqrestore(rdp, flags);\n\t\t}\n\t}\n\treturn true; // Callback already enqueued.\n}"
  },
  {
    "function_name": "rcu_nocb_try_flush_bypass",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_nocb.h",
    "lines": "353-360",
    "snippet": "static void rcu_nocb_try_flush_bypass(struct rcu_data *rdp, unsigned long j)\n{\n\trcu_lockdep_assert_cblist_protected(rdp);\n\tif (!rcu_rdp_is_offloaded(rdp) ||\n\t    !rcu_nocb_bypass_trylock(rdp))\n\t\treturn;\n\tWARN_ON_ONCE(!rcu_nocb_do_flush_bypass(rdp, NULL, j));\n}",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!rcu_nocb_do_flush_bypass(rdp, NULL, j)"
          ],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_nocb_do_flush_bypass",
          "args": [
            "rdp",
            "NULL",
            "j"
          ],
          "line": 359
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_nocb_do_flush_bypass",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_nocb.h",
          "lines": "309-329",
          "snippet": "static bool rcu_nocb_do_flush_bypass(struct rcu_data *rdp, struct rcu_head *rhp,\n\t\t\t\t     unsigned long j)\n{\n\tstruct rcu_cblist rcl;\n\n\tWARN_ON_ONCE(!rcu_rdp_is_offloaded(rdp));\n\trcu_lockdep_assert_cblist_protected(rdp);\n\tlockdep_assert_held(&rdp->nocb_bypass_lock);\n\tif (rhp && !rcu_cblist_n_cbs(&rdp->nocb_bypass)) {\n\t\traw_spin_unlock(&rdp->nocb_bypass_lock);\n\t\treturn false;\n\t}\n\t/* Note: ->cblist.len already accounts for ->nocb_bypass contents. */\n\tif (rhp)\n\t\trcu_segcblist_inc_len(&rdp->cblist); /* Must precede enqueue. */\n\trcu_cblist_flush_enqueue(&rcl, &rdp->nocb_bypass, rhp);\n\trcu_segcblist_insert_pend_cbs(&rdp->cblist, &rcl);\n\tWRITE_ONCE(rdp->nocb_bypass_first, j);\n\trcu_nocb_bypass_unlock(rdp);\n\treturn true;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static bool rcu_nocb_do_flush_bypass(struct rcu_data *rdp, struct rcu_head *rhp,\n\t\t\t\t     unsigned long j)\n{\n\tstruct rcu_cblist rcl;\n\n\tWARN_ON_ONCE(!rcu_rdp_is_offloaded(rdp));\n\trcu_lockdep_assert_cblist_protected(rdp);\n\tlockdep_assert_held(&rdp->nocb_bypass_lock);\n\tif (rhp && !rcu_cblist_n_cbs(&rdp->nocb_bypass)) {\n\t\traw_spin_unlock(&rdp->nocb_bypass_lock);\n\t\treturn false;\n\t}\n\t/* Note: ->cblist.len already accounts for ->nocb_bypass contents. */\n\tif (rhp)\n\t\trcu_segcblist_inc_len(&rdp->cblist); /* Must precede enqueue. */\n\trcu_cblist_flush_enqueue(&rcl, &rdp->nocb_bypass, rhp);\n\trcu_segcblist_insert_pend_cbs(&rdp->cblist, &rcl);\n\tWRITE_ONCE(rdp->nocb_bypass_first, j);\n\trcu_nocb_bypass_unlock(rdp);\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_nocb_bypass_trylock",
          "args": [
            "rdp"
          ],
          "line": 357
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_nocb_bypass_trylock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_nocb.h",
          "lines": "135-139",
          "snippet": "static bool rcu_nocb_bypass_trylock(struct rcu_data *rdp)\n{\n\tlockdep_assert_irqs_disabled();\n\treturn raw_spin_trylock(&rdp->nocb_bypass_lock);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static bool rcu_nocb_bypass_trylock(struct rcu_data *rdp)\n{\n\tlockdep_assert_irqs_disabled();\n\treturn raw_spin_trylock(&rdp->nocb_bypass_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_rdp_is_offloaded",
          "args": [
            "rdp"
          ],
          "line": 356
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_rdp_is_offloaded",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "16-38",
          "snippet": "static bool rcu_rdp_is_offloaded(struct rcu_data *rdp)\n{\n\t/*\n\t * In order to read the offloaded state of an rdp in a safe\n\t * and stable way and prevent from its value to be changed\n\t * under us, we must either hold the barrier mutex, the cpu\n\t * hotplug lock (read or write) or the nocb lock. Local\n\t * non-preemptible reads are also safe. NOCB kthreads and\n\t * timers have their own means of synchronization against the\n\t * offloaded state updaters.\n\t */\n\tRCU_LOCKDEP_WARN(\n\t\t!(lockdep_is_held(&rcu_state.barrier_mutex) ||\n\t\t  (IS_ENABLED(CONFIG_HOTPLUG_CPU) && lockdep_is_cpus_held()) ||\n\t\t  rcu_lockdep_is_held_nocb(rdp) ||\n\t\t  (rdp == this_cpu_ptr(&rcu_data) &&\n\t\t   !(IS_ENABLED(CONFIG_PREEMPT_COUNT) && preemptible())) ||\n\t\t  rcu_current_is_nocb_kthread(rdp)),\n\t\t\"Unsafe read of RCU_NOCB offloaded state\"\n\t);\n\n\treturn rcu_segcblist_is_offloaded(&rdp->cblist);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nstatic bool rcu_rdp_is_offloaded(struct rcu_data *rdp)\n{\n\t/*\n\t * In order to read the offloaded state of an rdp in a safe\n\t * and stable way and prevent from its value to be changed\n\t * under us, we must either hold the barrier mutex, the cpu\n\t * hotplug lock (read or write) or the nocb lock. Local\n\t * non-preemptible reads are also safe. NOCB kthreads and\n\t * timers have their own means of synchronization against the\n\t * offloaded state updaters.\n\t */\n\tRCU_LOCKDEP_WARN(\n\t\t!(lockdep_is_held(&rcu_state.barrier_mutex) ||\n\t\t  (IS_ENABLED(CONFIG_HOTPLUG_CPU) && lockdep_is_cpus_held()) ||\n\t\t  rcu_lockdep_is_held_nocb(rdp) ||\n\t\t  (rdp == this_cpu_ptr(&rcu_data) &&\n\t\t   !(IS_ENABLED(CONFIG_PREEMPT_COUNT) && preemptible())) ||\n\t\t  rcu_current_is_nocb_kthread(rdp)),\n\t\t\"Unsafe read of RCU_NOCB offloaded state\"\n\t);\n\n\treturn rcu_segcblist_is_offloaded(&rdp->cblist);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_lockdep_assert_cblist_protected",
          "args": [
            "rdp"
          ],
          "line": 355
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_lockdep_assert_cblist_protected",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_nocb.h",
          "lines": "1486-1489",
          "snippet": "static void rcu_lockdep_assert_cblist_protected(struct rcu_data *rdp)\n{\n\tlockdep_assert_irqs_disabled();\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static void rcu_lockdep_assert_cblist_protected(struct rcu_data *rdp)\n{\n\tlockdep_assert_irqs_disabled();\n}"
        }
      }
    ],
    "contextual_snippet": "static void rcu_nocb_try_flush_bypass(struct rcu_data *rdp, unsigned long j)\n{\n\trcu_lockdep_assert_cblist_protected(rdp);\n\tif (!rcu_rdp_is_offloaded(rdp) ||\n\t    !rcu_nocb_bypass_trylock(rdp))\n\t\treturn;\n\tWARN_ON_ONCE(!rcu_nocb_do_flush_bypass(rdp, NULL, j));\n}"
  },
  {
    "function_name": "rcu_nocb_flush_bypass",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_nocb.h",
    "lines": "339-347",
    "snippet": "static bool rcu_nocb_flush_bypass(struct rcu_data *rdp, struct rcu_head *rhp,\n\t\t\t\t  unsigned long j)\n{\n\tif (!rcu_rdp_is_offloaded(rdp))\n\t\treturn true;\n\trcu_lockdep_assert_cblist_protected(rdp);\n\trcu_nocb_bypass_lock(rdp);\n\treturn rcu_nocb_do_flush_bypass(rdp, rhp, j);\n}",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_nocb_do_flush_bypass",
          "args": [
            "rdp",
            "rhp",
            "j"
          ],
          "line": 346
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_nocb_do_flush_bypass",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_nocb.h",
          "lines": "309-329",
          "snippet": "static bool rcu_nocb_do_flush_bypass(struct rcu_data *rdp, struct rcu_head *rhp,\n\t\t\t\t     unsigned long j)\n{\n\tstruct rcu_cblist rcl;\n\n\tWARN_ON_ONCE(!rcu_rdp_is_offloaded(rdp));\n\trcu_lockdep_assert_cblist_protected(rdp);\n\tlockdep_assert_held(&rdp->nocb_bypass_lock);\n\tif (rhp && !rcu_cblist_n_cbs(&rdp->nocb_bypass)) {\n\t\traw_spin_unlock(&rdp->nocb_bypass_lock);\n\t\treturn false;\n\t}\n\t/* Note: ->cblist.len already accounts for ->nocb_bypass contents. */\n\tif (rhp)\n\t\trcu_segcblist_inc_len(&rdp->cblist); /* Must precede enqueue. */\n\trcu_cblist_flush_enqueue(&rcl, &rdp->nocb_bypass, rhp);\n\trcu_segcblist_insert_pend_cbs(&rdp->cblist, &rcl);\n\tWRITE_ONCE(rdp->nocb_bypass_first, j);\n\trcu_nocb_bypass_unlock(rdp);\n\treturn true;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static bool rcu_nocb_do_flush_bypass(struct rcu_data *rdp, struct rcu_head *rhp,\n\t\t\t\t     unsigned long j)\n{\n\tstruct rcu_cblist rcl;\n\n\tWARN_ON_ONCE(!rcu_rdp_is_offloaded(rdp));\n\trcu_lockdep_assert_cblist_protected(rdp);\n\tlockdep_assert_held(&rdp->nocb_bypass_lock);\n\tif (rhp && !rcu_cblist_n_cbs(&rdp->nocb_bypass)) {\n\t\traw_spin_unlock(&rdp->nocb_bypass_lock);\n\t\treturn false;\n\t}\n\t/* Note: ->cblist.len already accounts for ->nocb_bypass contents. */\n\tif (rhp)\n\t\trcu_segcblist_inc_len(&rdp->cblist); /* Must precede enqueue. */\n\trcu_cblist_flush_enqueue(&rcl, &rdp->nocb_bypass, rhp);\n\trcu_segcblist_insert_pend_cbs(&rdp->cblist, &rcl);\n\tWRITE_ONCE(rdp->nocb_bypass_first, j);\n\trcu_nocb_bypass_unlock(rdp);\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_nocb_bypass_lock",
          "args": [
            "rdp"
          ],
          "line": 345
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_nocb_bypass_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_nocb.h",
          "lines": "100-112",
          "snippet": "static void rcu_nocb_bypass_lock(struct rcu_data *rdp)\n\t__acquires(&rdp->nocb_bypass_lock)\n{\n\tlockdep_assert_irqs_disabled();\n\tif (raw_spin_trylock(&rdp->nocb_bypass_lock))\n\t\treturn;\n\tatomic_inc(&rdp->nocb_lock_contended);\n\tWARN_ON_ONCE(smp_processor_id() != rdp->cpu);\n\tsmp_mb__after_atomic(); /* atomic_inc() before lock. */\n\traw_spin_lock(&rdp->nocb_bypass_lock);\n\tsmp_mb__before_atomic(); /* atomic_dec() after lock. */\n\tatomic_dec(&rdp->nocb_lock_contended);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static void rcu_nocb_bypass_lock(struct rcu_data *rdp)\n\t__acquires(&rdp->nocb_bypass_lock)\n{\n\tlockdep_assert_irqs_disabled();\n\tif (raw_spin_trylock(&rdp->nocb_bypass_lock))\n\t\treturn;\n\tatomic_inc(&rdp->nocb_lock_contended);\n\tWARN_ON_ONCE(smp_processor_id() != rdp->cpu);\n\tsmp_mb__after_atomic(); /* atomic_inc() before lock. */\n\traw_spin_lock(&rdp->nocb_bypass_lock);\n\tsmp_mb__before_atomic(); /* atomic_dec() after lock. */\n\tatomic_dec(&rdp->nocb_lock_contended);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_lockdep_assert_cblist_protected",
          "args": [
            "rdp"
          ],
          "line": 344
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_lockdep_assert_cblist_protected",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_nocb.h",
          "lines": "1486-1489",
          "snippet": "static void rcu_lockdep_assert_cblist_protected(struct rcu_data *rdp)\n{\n\tlockdep_assert_irqs_disabled();\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static void rcu_lockdep_assert_cblist_protected(struct rcu_data *rdp)\n{\n\tlockdep_assert_irqs_disabled();\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_rdp_is_offloaded",
          "args": [
            "rdp"
          ],
          "line": 342
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_rdp_is_offloaded",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "16-38",
          "snippet": "static bool rcu_rdp_is_offloaded(struct rcu_data *rdp)\n{\n\t/*\n\t * In order to read the offloaded state of an rdp in a safe\n\t * and stable way and prevent from its value to be changed\n\t * under us, we must either hold the barrier mutex, the cpu\n\t * hotplug lock (read or write) or the nocb lock. Local\n\t * non-preemptible reads are also safe. NOCB kthreads and\n\t * timers have their own means of synchronization against the\n\t * offloaded state updaters.\n\t */\n\tRCU_LOCKDEP_WARN(\n\t\t!(lockdep_is_held(&rcu_state.barrier_mutex) ||\n\t\t  (IS_ENABLED(CONFIG_HOTPLUG_CPU) && lockdep_is_cpus_held()) ||\n\t\t  rcu_lockdep_is_held_nocb(rdp) ||\n\t\t  (rdp == this_cpu_ptr(&rcu_data) &&\n\t\t   !(IS_ENABLED(CONFIG_PREEMPT_COUNT) && preemptible())) ||\n\t\t  rcu_current_is_nocb_kthread(rdp)),\n\t\t\"Unsafe read of RCU_NOCB offloaded state\"\n\t);\n\n\treturn rcu_segcblist_is_offloaded(&rdp->cblist);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nstatic bool rcu_rdp_is_offloaded(struct rcu_data *rdp)\n{\n\t/*\n\t * In order to read the offloaded state of an rdp in a safe\n\t * and stable way and prevent from its value to be changed\n\t * under us, we must either hold the barrier mutex, the cpu\n\t * hotplug lock (read or write) or the nocb lock. Local\n\t * non-preemptible reads are also safe. NOCB kthreads and\n\t * timers have their own means of synchronization against the\n\t * offloaded state updaters.\n\t */\n\tRCU_LOCKDEP_WARN(\n\t\t!(lockdep_is_held(&rcu_state.barrier_mutex) ||\n\t\t  (IS_ENABLED(CONFIG_HOTPLUG_CPU) && lockdep_is_cpus_held()) ||\n\t\t  rcu_lockdep_is_held_nocb(rdp) ||\n\t\t  (rdp == this_cpu_ptr(&rcu_data) &&\n\t\t   !(IS_ENABLED(CONFIG_PREEMPT_COUNT) && preemptible())) ||\n\t\t  rcu_current_is_nocb_kthread(rdp)),\n\t\t\"Unsafe read of RCU_NOCB offloaded state\"\n\t);\n\n\treturn rcu_segcblist_is_offloaded(&rdp->cblist);\n}"
        }
      }
    ],
    "contextual_snippet": "static bool rcu_nocb_flush_bypass(struct rcu_data *rdp, struct rcu_head *rhp,\n\t\t\t\t  unsigned long j)\n{\n\tif (!rcu_rdp_is_offloaded(rdp))\n\t\treturn true;\n\trcu_lockdep_assert_cblist_protected(rdp);\n\trcu_nocb_bypass_lock(rdp);\n\treturn rcu_nocb_do_flush_bypass(rdp, rhp, j);\n}"
  },
  {
    "function_name": "rcu_nocb_do_flush_bypass",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_nocb.h",
    "lines": "309-329",
    "snippet": "static bool rcu_nocb_do_flush_bypass(struct rcu_data *rdp, struct rcu_head *rhp,\n\t\t\t\t     unsigned long j)\n{\n\tstruct rcu_cblist rcl;\n\n\tWARN_ON_ONCE(!rcu_rdp_is_offloaded(rdp));\n\trcu_lockdep_assert_cblist_protected(rdp);\n\tlockdep_assert_held(&rdp->nocb_bypass_lock);\n\tif (rhp && !rcu_cblist_n_cbs(&rdp->nocb_bypass)) {\n\t\traw_spin_unlock(&rdp->nocb_bypass_lock);\n\t\treturn false;\n\t}\n\t/* Note: ->cblist.len already accounts for ->nocb_bypass contents. */\n\tif (rhp)\n\t\trcu_segcblist_inc_len(&rdp->cblist); /* Must precede enqueue. */\n\trcu_cblist_flush_enqueue(&rcl, &rdp->nocb_bypass, rhp);\n\trcu_segcblist_insert_pend_cbs(&rdp->cblist, &rcl);\n\tWRITE_ONCE(rdp->nocb_bypass_first, j);\n\trcu_nocb_bypass_unlock(rdp);\n\treturn true;\n}",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_nocb_bypass_unlock",
          "args": [
            "rdp"
          ],
          "line": 327
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_nocb_bypass_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_nocb.h",
          "lines": "144-149",
          "snippet": "static void rcu_nocb_bypass_unlock(struct rcu_data *rdp)\n\t__releases(&rdp->nocb_bypass_lock)\n{\n\tlockdep_assert_irqs_disabled();\n\traw_spin_unlock(&rdp->nocb_bypass_lock);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static void rcu_nocb_bypass_unlock(struct rcu_data *rdp)\n\t__releases(&rdp->nocb_bypass_lock)\n{\n\tlockdep_assert_irqs_disabled();\n\traw_spin_unlock(&rdp->nocb_bypass_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "rdp->nocb_bypass_first",
            "j"
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_segcblist_insert_pend_cbs",
          "args": [
            "&rdp->cblist",
            "&rcl"
          ],
          "line": 325
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_insert_pend_cbs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.c",
          "lines": "465-474",
          "snippet": "void rcu_segcblist_insert_pend_cbs(struct rcu_segcblist *rsclp,\n\t\t\t\t   struct rcu_cblist *rclp)\n{\n\tif (!rclp->head)\n\t\treturn; /* Nothing to do. */\n\n\trcu_segcblist_add_seglen(rsclp, RCU_NEXT_TAIL, rclp->len);\n\tWRITE_ONCE(*rsclp->tails[RCU_NEXT_TAIL], rclp->head);\n\tWRITE_ONCE(rsclp->tails[RCU_NEXT_TAIL], rclp->tail);\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/cpu.h>\n\nvoid rcu_segcblist_insert_pend_cbs(struct rcu_segcblist *rsclp,\n\t\t\t\t   struct rcu_cblist *rclp)\n{\n\tif (!rclp->head)\n\t\treturn; /* Nothing to do. */\n\n\trcu_segcblist_add_seglen(rsclp, RCU_NEXT_TAIL, rclp->len);\n\tWRITE_ONCE(*rsclp->tails[RCU_NEXT_TAIL], rclp->head);\n\tWRITE_ONCE(rsclp->tails[RCU_NEXT_TAIL], rclp->tail);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_cblist_flush_enqueue",
          "args": [
            "&rcl",
            "&rdp->nocb_bypass",
            "rhp"
          ],
          "line": 324
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_cblist_flush_enqueue",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.c",
          "lines": "43-61",
          "snippet": "void rcu_cblist_flush_enqueue(struct rcu_cblist *drclp,\n\t\t\t      struct rcu_cblist *srclp,\n\t\t\t      struct rcu_head *rhp)\n{\n\tdrclp->head = srclp->head;\n\tif (drclp->head)\n\t\tdrclp->tail = srclp->tail;\n\telse\n\t\tdrclp->tail = &drclp->head;\n\tdrclp->len = srclp->len;\n\tif (!rhp) {\n\t\trcu_cblist_init(srclp);\n\t} else {\n\t\trhp->next = NULL;\n\t\tsrclp->head = rhp;\n\t\tsrclp->tail = &rhp->next;\n\t\tWRITE_ONCE(srclp->len, 1);\n\t}\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/cpu.h>\n\nvoid rcu_cblist_flush_enqueue(struct rcu_cblist *drclp,\n\t\t\t      struct rcu_cblist *srclp,\n\t\t\t      struct rcu_head *rhp)\n{\n\tdrclp->head = srclp->head;\n\tif (drclp->head)\n\t\tdrclp->tail = srclp->tail;\n\telse\n\t\tdrclp->tail = &drclp->head;\n\tdrclp->len = srclp->len;\n\tif (!rhp) {\n\t\trcu_cblist_init(srclp);\n\t} else {\n\t\trhp->next = NULL;\n\t\tsrclp->head = rhp;\n\t\tsrclp->tail = &rhp->next;\n\t\tWRITE_ONCE(srclp->len, 1);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_segcblist_inc_len",
          "args": [
            "&rdp->cblist"
          ],
          "line": 323
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_inc_len",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.c",
          "lines": "229-232",
          "snippet": "void rcu_segcblist_inc_len(struct rcu_segcblist *rsclp)\n{\n\trcu_segcblist_add_len(rsclp, 1);\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/cpu.h>\n\nvoid rcu_segcblist_inc_len(struct rcu_segcblist *rsclp)\n{\n\trcu_segcblist_add_len(rsclp, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock",
          "args": [
            "&rdp->nocb_bypass_lock"
          ],
          "line": 318
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_bh",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "208-211",
          "snippet": "void __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_cblist_n_cbs",
          "args": [
            "&rdp->nocb_bypass"
          ],
          "line": 317
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_cblist_n_cbs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "13-16",
          "snippet": "static inline long rcu_cblist_n_cbs(struct rcu_cblist *rclp)\n{\n\treturn READ_ONCE(rclp->len);\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void rcu_cblist_init(struct rcu_cblist *rclp);",
            "struct rcu_head *rcu_cblist_dequeue(struct rcu_cblist *rclp);",
            "void rcu_segcblist_extract_done_cbs(struct rcu_segcblist *rsclp,\n\t\t\t\t    struct rcu_cblist *rclp);",
            "void rcu_segcblist_extract_pend_cbs(struct rcu_segcblist *rsclp,\n\t\t\t\t    struct rcu_cblist *rclp);",
            "void rcu_segcblist_insert_count(struct rcu_segcblist *rsclp,\n\t\t\t\tstruct rcu_cblist *rclp);",
            "void rcu_segcblist_insert_done_cbs(struct rcu_segcblist *rsclp,\n\t\t\t\t   struct rcu_cblist *rclp);",
            "void rcu_segcblist_insert_pend_cbs(struct rcu_segcblist *rsclp,\n\t\t\t\t   struct rcu_cblist *rclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nvoid rcu_cblist_init(struct rcu_cblist *rclp);\nstruct rcu_head *rcu_cblist_dequeue(struct rcu_cblist *rclp);\nvoid rcu_segcblist_extract_done_cbs(struct rcu_segcblist *rsclp,\n\t\t\t\t    struct rcu_cblist *rclp);\nvoid rcu_segcblist_extract_pend_cbs(struct rcu_segcblist *rsclp,\n\t\t\t\t    struct rcu_cblist *rclp);\nvoid rcu_segcblist_insert_count(struct rcu_segcblist *rsclp,\n\t\t\t\tstruct rcu_cblist *rclp);\nvoid rcu_segcblist_insert_done_cbs(struct rcu_segcblist *rsclp,\n\t\t\t\t   struct rcu_cblist *rclp);\nvoid rcu_segcblist_insert_pend_cbs(struct rcu_segcblist *rsclp,\n\t\t\t\t   struct rcu_cblist *rclp);\n\nstatic inline long rcu_cblist_n_cbs(struct rcu_cblist *rclp)\n{\n\treturn READ_ONCE(rclp->len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&rdp->nocb_bypass_lock"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_lockdep_assert_cblist_protected",
          "args": [
            "rdp"
          ],
          "line": 315
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_lockdep_assert_cblist_protected",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_nocb.h",
          "lines": "1486-1489",
          "snippet": "static void rcu_lockdep_assert_cblist_protected(struct rcu_data *rdp)\n{\n\tlockdep_assert_irqs_disabled();\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static void rcu_lockdep_assert_cblist_protected(struct rcu_data *rdp)\n{\n\tlockdep_assert_irqs_disabled();\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!rcu_rdp_is_offloaded(rdp)"
          ],
          "line": 314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_rdp_is_offloaded",
          "args": [
            "rdp"
          ],
          "line": 314
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_rdp_is_offloaded",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "16-38",
          "snippet": "static bool rcu_rdp_is_offloaded(struct rcu_data *rdp)\n{\n\t/*\n\t * In order to read the offloaded state of an rdp in a safe\n\t * and stable way and prevent from its value to be changed\n\t * under us, we must either hold the barrier mutex, the cpu\n\t * hotplug lock (read or write) or the nocb lock. Local\n\t * non-preemptible reads are also safe. NOCB kthreads and\n\t * timers have their own means of synchronization against the\n\t * offloaded state updaters.\n\t */\n\tRCU_LOCKDEP_WARN(\n\t\t!(lockdep_is_held(&rcu_state.barrier_mutex) ||\n\t\t  (IS_ENABLED(CONFIG_HOTPLUG_CPU) && lockdep_is_cpus_held()) ||\n\t\t  rcu_lockdep_is_held_nocb(rdp) ||\n\t\t  (rdp == this_cpu_ptr(&rcu_data) &&\n\t\t   !(IS_ENABLED(CONFIG_PREEMPT_COUNT) && preemptible())) ||\n\t\t  rcu_current_is_nocb_kthread(rdp)),\n\t\t\"Unsafe read of RCU_NOCB offloaded state\"\n\t);\n\n\treturn rcu_segcblist_is_offloaded(&rdp->cblist);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nstatic bool rcu_rdp_is_offloaded(struct rcu_data *rdp)\n{\n\t/*\n\t * In order to read the offloaded state of an rdp in a safe\n\t * and stable way and prevent from its value to be changed\n\t * under us, we must either hold the barrier mutex, the cpu\n\t * hotplug lock (read or write) or the nocb lock. Local\n\t * non-preemptible reads are also safe. NOCB kthreads and\n\t * timers have their own means of synchronization against the\n\t * offloaded state updaters.\n\t */\n\tRCU_LOCKDEP_WARN(\n\t\t!(lockdep_is_held(&rcu_state.barrier_mutex) ||\n\t\t  (IS_ENABLED(CONFIG_HOTPLUG_CPU) && lockdep_is_cpus_held()) ||\n\t\t  rcu_lockdep_is_held_nocb(rdp) ||\n\t\t  (rdp == this_cpu_ptr(&rcu_data) &&\n\t\t   !(IS_ENABLED(CONFIG_PREEMPT_COUNT) && preemptible())) ||\n\t\t  rcu_current_is_nocb_kthread(rdp)),\n\t\t\"Unsafe read of RCU_NOCB offloaded state\"\n\t);\n\n\treturn rcu_segcblist_is_offloaded(&rdp->cblist);\n}"
        }
      }
    ],
    "contextual_snippet": "static bool rcu_nocb_do_flush_bypass(struct rcu_data *rdp, struct rcu_head *rhp,\n\t\t\t\t     unsigned long j)\n{\n\tstruct rcu_cblist rcl;\n\n\tWARN_ON_ONCE(!rcu_rdp_is_offloaded(rdp));\n\trcu_lockdep_assert_cblist_protected(rdp);\n\tlockdep_assert_held(&rdp->nocb_bypass_lock);\n\tif (rhp && !rcu_cblist_n_cbs(&rdp->nocb_bypass)) {\n\t\traw_spin_unlock(&rdp->nocb_bypass_lock);\n\t\treturn false;\n\t}\n\t/* Note: ->cblist.len already accounts for ->nocb_bypass contents. */\n\tif (rhp)\n\t\trcu_segcblist_inc_len(&rdp->cblist); /* Must precede enqueue. */\n\trcu_cblist_flush_enqueue(&rcl, &rdp->nocb_bypass, rhp);\n\trcu_segcblist_insert_pend_cbs(&rdp->cblist, &rcl);\n\tWRITE_ONCE(rdp->nocb_bypass_first, j);\n\trcu_nocb_bypass_unlock(rdp);\n\treturn true;\n}"
  },
  {
    "function_name": "wake_nocb_gp_defer",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_nocb.h",
    "lines": "274-299",
    "snippet": "static void wake_nocb_gp_defer(struct rcu_data *rdp, int waketype,\n\t\t\t       const char *reason)\n{\n\tunsigned long flags;\n\tstruct rcu_data *rdp_gp = rdp->nocb_gp_rdp;\n\n\traw_spin_lock_irqsave(&rdp_gp->nocb_gp_lock, flags);\n\n\t/*\n\t * Bypass wakeup overrides previous deferments. In case\n\t * of callback storm, no need to wake up too early.\n\t */\n\tif (waketype == RCU_NOCB_WAKE_BYPASS) {\n\t\tmod_timer(&rdp_gp->nocb_timer, jiffies + 2);\n\t\tWRITE_ONCE(rdp_gp->nocb_defer_wakeup, waketype);\n\t} else {\n\t\tif (rdp_gp->nocb_defer_wakeup < RCU_NOCB_WAKE)\n\t\t\tmod_timer(&rdp_gp->nocb_timer, jiffies + 1);\n\t\tif (rdp_gp->nocb_defer_wakeup < waketype)\n\t\t\tWRITE_ONCE(rdp_gp->nocb_defer_wakeup, waketype);\n\t}\n\n\traw_spin_unlock_irqrestore(&rdp_gp->nocb_gp_lock, flags);\n\n\ttrace_rcu_nocb_wake(rcu_state.name, rdp->cpu, reason);\n}",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_rcu_nocb_wake",
          "args": [
            "rcu_state.name",
            "rdp->cpu",
            "reason"
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore",
          "args": [
            "&rdp_gp->nocb_gp_lock",
            "flags"
          ],
          "line": 296
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "192-195",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "rdp_gp->nocb_defer_wakeup",
            "waketype"
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mod_timer",
          "args": [
            "&rdp_gp->nocb_timer",
            "jiffies + 1"
          ],
          "line": 291
        },
        "resolved": true,
        "details": {
          "function_name": "mod_timer",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timer.c",
          "lines": "1106-1109",
          "snippet": "int mod_timer(struct timer_list *timer, unsigned long expires)\n{\n\treturn __mod_timer(timer, expires, 0);\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/random.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/random.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nint mod_timer(struct timer_list *timer, unsigned long expires)\n{\n\treturn __mod_timer(timer, expires, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "rdp_gp->nocb_defer_wakeup",
            "waketype"
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave",
          "args": [
            "&rdp_gp->nocb_gp_lock",
            "flags"
          ],
          "line": 280
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "383-393",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}"
        }
      }
    ],
    "contextual_snippet": "static void wake_nocb_gp_defer(struct rcu_data *rdp, int waketype,\n\t\t\t       const char *reason)\n{\n\tunsigned long flags;\n\tstruct rcu_data *rdp_gp = rdp->nocb_gp_rdp;\n\n\traw_spin_lock_irqsave(&rdp_gp->nocb_gp_lock, flags);\n\n\t/*\n\t * Bypass wakeup overrides previous deferments. In case\n\t * of callback storm, no need to wake up too early.\n\t */\n\tif (waketype == RCU_NOCB_WAKE_BYPASS) {\n\t\tmod_timer(&rdp_gp->nocb_timer, jiffies + 2);\n\t\tWRITE_ONCE(rdp_gp->nocb_defer_wakeup, waketype);\n\t} else {\n\t\tif (rdp_gp->nocb_defer_wakeup < RCU_NOCB_WAKE)\n\t\t\tmod_timer(&rdp_gp->nocb_timer, jiffies + 1);\n\t\tif (rdp_gp->nocb_defer_wakeup < waketype)\n\t\t\tWRITE_ONCE(rdp_gp->nocb_defer_wakeup, waketype);\n\t}\n\n\traw_spin_unlock_irqrestore(&rdp_gp->nocb_gp_lock, flags);\n\n\ttrace_rcu_nocb_wake(rcu_state.name, rdp->cpu, reason);\n}"
  },
  {
    "function_name": "wake_nocb_gp",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_nocb.h",
    "lines": "261-268",
    "snippet": "static bool wake_nocb_gp(struct rcu_data *rdp, bool force)\n{\n\tunsigned long flags;\n\tstruct rcu_data *rdp_gp = rdp->nocb_gp_rdp;\n\n\traw_spin_lock_irqsave(&rdp_gp->nocb_gp_lock, flags);\n\treturn __wake_nocb_gp(rdp_gp, rdp, force, flags);\n}",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__wake_nocb_gp",
          "args": [
            "rdp_gp",
            "rdp",
            "force",
            "flags"
          ],
          "line": 267
        },
        "resolved": true,
        "details": {
          "function_name": "__wake_nocb_gp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_nocb.h",
          "lines": "226-256",
          "snippet": "static bool __wake_nocb_gp(struct rcu_data *rdp_gp,\n\t\t\t   struct rcu_data *rdp,\n\t\t\t   bool force, unsigned long flags)\n\t__releases(rdp_gp->nocb_gp_lock)\n{\n\tbool needwake = false;\n\n\tif (!READ_ONCE(rdp_gp->nocb_gp_kthread)) {\n\t\traw_spin_unlock_irqrestore(&rdp_gp->nocb_gp_lock, flags);\n\t\ttrace_rcu_nocb_wake(rcu_state.name, rdp->cpu,\n\t\t\t\t    TPS(\"AlreadyAwake\"));\n\t\treturn false;\n\t}\n\n\tif (rdp_gp->nocb_defer_wakeup > RCU_NOCB_WAKE_NOT) {\n\t\tWRITE_ONCE(rdp_gp->nocb_defer_wakeup, RCU_NOCB_WAKE_NOT);\n\t\tdel_timer(&rdp_gp->nocb_timer);\n\t}\n\n\tif (force || READ_ONCE(rdp_gp->nocb_gp_sleep)) {\n\t\tWRITE_ONCE(rdp_gp->nocb_gp_sleep, false);\n\t\tneedwake = true;\n\t}\n\traw_spin_unlock_irqrestore(&rdp_gp->nocb_gp_lock, flags);\n\tif (needwake) {\n\t\ttrace_rcu_nocb_wake(rcu_state.name, rdp->cpu, TPS(\"DoWake\"));\n\t\twake_up_process(rdp_gp->nocb_gp_kthread);\n\t}\n\n\treturn needwake;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static bool __wake_nocb_gp(struct rcu_data *rdp_gp,\n\t\t\t   struct rcu_data *rdp,\n\t\t\t   bool force, unsigned long flags)\n\t__releases(rdp_gp->nocb_gp_lock)\n{\n\tbool needwake = false;\n\n\tif (!READ_ONCE(rdp_gp->nocb_gp_kthread)) {\n\t\traw_spin_unlock_irqrestore(&rdp_gp->nocb_gp_lock, flags);\n\t\ttrace_rcu_nocb_wake(rcu_state.name, rdp->cpu,\n\t\t\t\t    TPS(\"AlreadyAwake\"));\n\t\treturn false;\n\t}\n\n\tif (rdp_gp->nocb_defer_wakeup > RCU_NOCB_WAKE_NOT) {\n\t\tWRITE_ONCE(rdp_gp->nocb_defer_wakeup, RCU_NOCB_WAKE_NOT);\n\t\tdel_timer(&rdp_gp->nocb_timer);\n\t}\n\n\tif (force || READ_ONCE(rdp_gp->nocb_gp_sleep)) {\n\t\tWRITE_ONCE(rdp_gp->nocb_gp_sleep, false);\n\t\tneedwake = true;\n\t}\n\traw_spin_unlock_irqrestore(&rdp_gp->nocb_gp_lock, flags);\n\tif (needwake) {\n\t\ttrace_rcu_nocb_wake(rcu_state.name, rdp->cpu, TPS(\"DoWake\"));\n\t\twake_up_process(rdp_gp->nocb_gp_kthread);\n\t}\n\n\treturn needwake;\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave",
          "args": [
            "&rdp_gp->nocb_gp_lock",
            "flags"
          ],
          "line": 266
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "383-393",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}"
        }
      }
    ],
    "contextual_snippet": "static bool wake_nocb_gp(struct rcu_data *rdp, bool force)\n{\n\tunsigned long flags;\n\tstruct rcu_data *rdp_gp = rdp->nocb_gp_rdp;\n\n\traw_spin_lock_irqsave(&rdp_gp->nocb_gp_lock, flags);\n\treturn __wake_nocb_gp(rdp_gp, rdp, force, flags);\n}"
  },
  {
    "function_name": "__wake_nocb_gp",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_nocb.h",
    "lines": "226-256",
    "snippet": "static bool __wake_nocb_gp(struct rcu_data *rdp_gp,\n\t\t\t   struct rcu_data *rdp,\n\t\t\t   bool force, unsigned long flags)\n\t__releases(rdp_gp->nocb_gp_lock)\n{\n\tbool needwake = false;\n\n\tif (!READ_ONCE(rdp_gp->nocb_gp_kthread)) {\n\t\traw_spin_unlock_irqrestore(&rdp_gp->nocb_gp_lock, flags);\n\t\ttrace_rcu_nocb_wake(rcu_state.name, rdp->cpu,\n\t\t\t\t    TPS(\"AlreadyAwake\"));\n\t\treturn false;\n\t}\n\n\tif (rdp_gp->nocb_defer_wakeup > RCU_NOCB_WAKE_NOT) {\n\t\tWRITE_ONCE(rdp_gp->nocb_defer_wakeup, RCU_NOCB_WAKE_NOT);\n\t\tdel_timer(&rdp_gp->nocb_timer);\n\t}\n\n\tif (force || READ_ONCE(rdp_gp->nocb_gp_sleep)) {\n\t\tWRITE_ONCE(rdp_gp->nocb_gp_sleep, false);\n\t\tneedwake = true;\n\t}\n\traw_spin_unlock_irqrestore(&rdp_gp->nocb_gp_lock, flags);\n\tif (needwake) {\n\t\ttrace_rcu_nocb_wake(rcu_state.name, rdp->cpu, TPS(\"DoWake\"));\n\t\twake_up_process(rdp_gp->nocb_gp_kthread);\n\t}\n\n\treturn needwake;\n}",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wake_up_process",
          "args": [
            "rdp_gp->nocb_gp_kthread"
          ],
          "line": 252
        },
        "resolved": true,
        "details": {
          "function_name": "wake_up_process",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "4215-4218",
          "snippet": "int wake_up_process(struct task_struct *p)\n{\n\treturn try_to_wake_up(p, TASK_NORMAL, 0);\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\nint wake_up_process(struct task_struct *p)\n{\n\treturn try_to_wake_up(p, TASK_NORMAL, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_rcu_nocb_wake",
          "args": [
            "rcu_state.name",
            "rdp->cpu",
            "TPS(\"DoWake\")"
          ],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPS",
          "args": [
            "\"DoWake\""
          ],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore",
          "args": [
            "&rdp_gp->nocb_gp_lock",
            "flags"
          ],
          "line": 249
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "192-195",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "rdp_gp->nocb_gp_sleep",
            "false"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rdp_gp->nocb_gp_sleep"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "del_timer",
          "args": [
            "&rdp_gp->nocb_timer"
          ],
          "line": 242
        },
        "resolved": true,
        "details": {
          "function_name": "del_timer_sync",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timer.c",
          "lines": "1352-1391",
          "snippet": "int del_timer_sync(struct timer_list *timer)\n{\n\tint ret;\n\n#ifdef CONFIG_LOCKDEP\n\tunsigned long flags;\n\n\t/*\n\t * If lockdep gives a backtrace here, please reference\n\t * the synchronization rules above.\n\t */\n\tlocal_irq_save(flags);\n\tlock_map_acquire(&timer->lockdep_map);\n\tlock_map_release(&timer->lockdep_map);\n\tlocal_irq_restore(flags);\n#endif\n\t/*\n\t * don't use it in hardirq context, because it\n\t * could lead to deadlock.\n\t */\n\tWARN_ON(in_irq() && !(timer->flags & TIMER_IRQSAFE));\n\n\t/*\n\t * Must be able to sleep on PREEMPT_RT because of the slowpath in\n\t * del_timer_wait_running().\n\t */\n\tif (IS_ENABLED(CONFIG_PREEMPT_RT) && !(timer->flags & TIMER_IRQSAFE))\n\t\tlockdep_assert_preemption_enabled();\n\n\tdo {\n\t\tret = try_to_del_timer_sync(timer);\n\n\t\tif (unlikely(ret < 0)) {\n\t\t\tdel_timer_wait_running(timer);\n\t\t\tcpu_relax();\n\t\t}\n\t} while (ret < 0);\n\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/random.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/random.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nint del_timer_sync(struct timer_list *timer)\n{\n\tint ret;\n\n#ifdef CONFIG_LOCKDEP\n\tunsigned long flags;\n\n\t/*\n\t * If lockdep gives a backtrace here, please reference\n\t * the synchronization rules above.\n\t */\n\tlocal_irq_save(flags);\n\tlock_map_acquire(&timer->lockdep_map);\n\tlock_map_release(&timer->lockdep_map);\n\tlocal_irq_restore(flags);\n#endif\n\t/*\n\t * don't use it in hardirq context, because it\n\t * could lead to deadlock.\n\t */\n\tWARN_ON(in_irq() && !(timer->flags & TIMER_IRQSAFE));\n\n\t/*\n\t * Must be able to sleep on PREEMPT_RT because of the slowpath in\n\t * del_timer_wait_running().\n\t */\n\tif (IS_ENABLED(CONFIG_PREEMPT_RT) && !(timer->flags & TIMER_IRQSAFE))\n\t\tlockdep_assert_preemption_enabled();\n\n\tdo {\n\t\tret = try_to_del_timer_sync(timer);\n\n\t\tif (unlikely(ret < 0)) {\n\t\t\tdel_timer_wait_running(timer);\n\t\t\tcpu_relax();\n\t\t}\n\t} while (ret < 0);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "rdp_gp->nocb_defer_wakeup",
            "RCU_NOCB_WAKE_NOT"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_rcu_nocb_wake",
          "args": [
            "rcu_state.name",
            "rdp->cpu",
            "TPS(\"AlreadyAwake\")"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPS",
          "args": [
            "\"AlreadyAwake\""
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rdp_gp->nocb_gp_kthread"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__releases",
          "args": [
            "rdp_gp->nocb_gp_lock"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "static bool __wake_nocb_gp(struct rcu_data *rdp_gp,\n\t\t\t   struct rcu_data *rdp,\n\t\t\t   bool force, unsigned long flags)\n\t__releases(rdp_gp->nocb_gp_lock)\n{\n\tbool needwake = false;\n\n\tif (!READ_ONCE(rdp_gp->nocb_gp_kthread)) {\n\t\traw_spin_unlock_irqrestore(&rdp_gp->nocb_gp_lock, flags);\n\t\ttrace_rcu_nocb_wake(rcu_state.name, rdp->cpu,\n\t\t\t\t    TPS(\"AlreadyAwake\"));\n\t\treturn false;\n\t}\n\n\tif (rdp_gp->nocb_defer_wakeup > RCU_NOCB_WAKE_NOT) {\n\t\tWRITE_ONCE(rdp_gp->nocb_defer_wakeup, RCU_NOCB_WAKE_NOT);\n\t\tdel_timer(&rdp_gp->nocb_timer);\n\t}\n\n\tif (force || READ_ONCE(rdp_gp->nocb_gp_sleep)) {\n\t\tWRITE_ONCE(rdp_gp->nocb_gp_sleep, false);\n\t\tneedwake = true;\n\t}\n\traw_spin_unlock_irqrestore(&rdp_gp->nocb_gp_lock, flags);\n\tif (needwake) {\n\t\ttrace_rcu_nocb_wake(rcu_state.name, rdp->cpu, TPS(\"DoWake\"));\n\t\twake_up_process(rdp_gp->nocb_gp_kthread);\n\t}\n\n\treturn needwake;\n}"
  },
  {
    "function_name": "rcu_is_nocb_cpu",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_nocb.h",
    "lines": "219-224",
    "snippet": "bool rcu_is_nocb_cpu(int cpu)\n{\n\tif (cpumask_available(rcu_nocb_mask))\n\t\treturn cpumask_test_cpu(cpu, rcu_nocb_mask);\n\treturn false;\n}",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpumask_test_cpu",
          "args": [
            "cpu",
            "rcu_nocb_mask"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_available",
          "args": [
            "rcu_nocb_mask"
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "bool rcu_is_nocb_cpu(int cpu)\n{\n\tif (cpumask_available(rcu_nocb_mask))\n\t\treturn cpumask_test_cpu(cpu, rcu_nocb_mask);\n\treturn false;\n}"
  },
  {
    "function_name": "rcu_init_one_nocb",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_nocb.h",
    "lines": "212-216",
    "snippet": "static void rcu_init_one_nocb(struct rcu_node *rnp)\n{\n\tinit_swait_queue_head(&rnp->nocb_gp_wq[0]);\n\tinit_swait_queue_head(&rnp->nocb_gp_wq[1]);\n}",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "init_swait_queue_head",
          "args": [
            "&rnp->nocb_gp_wq[1]"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_swait_queue_head",
          "args": [
            "&rnp->nocb_gp_wq[0]"
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "static void rcu_init_one_nocb(struct rcu_node *rnp)\n{\n\tinit_swait_queue_head(&rnp->nocb_gp_wq[0]);\n\tinit_swait_queue_head(&rnp->nocb_gp_wq[1]);\n}"
  },
  {
    "function_name": "rcu_nocb_gp_get",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_nocb.h",
    "lines": "207-210",
    "snippet": "static struct swait_queue_head *rcu_nocb_gp_get(struct rcu_node *rnp)\n{\n\treturn &rnp->nocb_gp_wq[rcu_seq_ctr(rnp->gp_seq) & 0x1];\n}",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_seq_ctr",
          "args": [
            "rnp->gp_seq"
          ],
          "line": 209
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_seq_ctr",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu.h",
          "lines": "30-33",
          "snippet": "static inline unsigned long rcu_seq_ctr(unsigned long s)\n{\n\treturn s >> RCU_SEQ_CTR_SHIFT;\n}",
          "includes": [
            "#include <linux/rcu_node_tree.h>",
            "#include <trace/events/rcu.h>"
          ],
          "macros_used": [
            "#define RCU_SEQ_CTR_SHIFT\t2"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_node_tree.h>\n#include <trace/events/rcu.h>\n\n#define RCU_SEQ_CTR_SHIFT\t2\n\nstatic inline unsigned long rcu_seq_ctr(unsigned long s)\n{\n\treturn s >> RCU_SEQ_CTR_SHIFT;\n}"
        }
      }
    ],
    "contextual_snippet": "static struct swait_queue_head *rcu_nocb_gp_get(struct rcu_node *rnp)\n{\n\treturn &rnp->nocb_gp_wq[rcu_seq_ctr(rnp->gp_seq) & 0x1];\n}"
  },
  {
    "function_name": "rcu_nocb_gp_cleanup",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_nocb.h",
    "lines": "202-205",
    "snippet": "static void rcu_nocb_gp_cleanup(struct swait_queue_head *sq)\n{\n\tswake_up_all(sq);\n}",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "swake_up_all",
          "args": [
            "sq"
          ],
          "line": 204
        },
        "resolved": true,
        "details": {
          "function_name": "swake_up_all",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/swait.c",
          "lines": "62-82",
          "snippet": "void swake_up_all(struct swait_queue_head *q)\n{\n\tstruct swait_queue *curr;\n\tLIST_HEAD(tmp);\n\n\traw_spin_lock_irq(&q->lock);\n\tlist_splice_init(&q->task_list, &tmp);\n\twhile (!list_empty(&tmp)) {\n\t\tcurr = list_first_entry(&tmp, typeof(*curr), task_list);\n\n\t\twake_up_state(curr->task, TASK_NORMAL);\n\t\tlist_del_init(&curr->task_list);\n\n\t\tif (list_empty(&tmp))\n\t\t\tbreak;\n\n\t\traw_spin_unlock_irq(&q->lock);\n\t\traw_spin_lock_irq(&q->lock);\n\t}\n\traw_spin_unlock_irq(&q->lock);\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nvoid swake_up_all(struct swait_queue_head *q)\n{\n\tstruct swait_queue *curr;\n\tLIST_HEAD(tmp);\n\n\traw_spin_lock_irq(&q->lock);\n\tlist_splice_init(&q->task_list, &tmp);\n\twhile (!list_empty(&tmp)) {\n\t\tcurr = list_first_entry(&tmp, typeof(*curr), task_list);\n\n\t\twake_up_state(curr->task, TASK_NORMAL);\n\t\tlist_del_init(&curr->task_list);\n\n\t\tif (list_empty(&tmp))\n\t\t\tbreak;\n\n\t\traw_spin_unlock_irq(&q->lock);\n\t\traw_spin_lock_irq(&q->lock);\n\t}\n\traw_spin_unlock_irq(&q->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "static void rcu_nocb_gp_cleanup(struct swait_queue_head *sq)\n{\n\tswake_up_all(sq);\n}"
  },
  {
    "function_name": "rcu_lockdep_assert_cblist_protected",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_nocb.h",
    "lines": "191-196",
    "snippet": "static void rcu_lockdep_assert_cblist_protected(struct rcu_data *rdp)\n{\n\tlockdep_assert_irqs_disabled();\n\tif (rcu_rdp_is_offloaded(rdp))\n\t\tlockdep_assert_held(&rdp->nocb_lock);\n}",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&rdp->nocb_lock"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_rdp_is_offloaded",
          "args": [
            "rdp"
          ],
          "line": 194
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_rdp_is_offloaded",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "16-38",
          "snippet": "static bool rcu_rdp_is_offloaded(struct rcu_data *rdp)\n{\n\t/*\n\t * In order to read the offloaded state of an rdp in a safe\n\t * and stable way and prevent from its value to be changed\n\t * under us, we must either hold the barrier mutex, the cpu\n\t * hotplug lock (read or write) or the nocb lock. Local\n\t * non-preemptible reads are also safe. NOCB kthreads and\n\t * timers have their own means of synchronization against the\n\t * offloaded state updaters.\n\t */\n\tRCU_LOCKDEP_WARN(\n\t\t!(lockdep_is_held(&rcu_state.barrier_mutex) ||\n\t\t  (IS_ENABLED(CONFIG_HOTPLUG_CPU) && lockdep_is_cpus_held()) ||\n\t\t  rcu_lockdep_is_held_nocb(rdp) ||\n\t\t  (rdp == this_cpu_ptr(&rcu_data) &&\n\t\t   !(IS_ENABLED(CONFIG_PREEMPT_COUNT) && preemptible())) ||\n\t\t  rcu_current_is_nocb_kthread(rdp)),\n\t\t\"Unsafe read of RCU_NOCB offloaded state\"\n\t);\n\n\treturn rcu_segcblist_is_offloaded(&rdp->cblist);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nstatic bool rcu_rdp_is_offloaded(struct rcu_data *rdp)\n{\n\t/*\n\t * In order to read the offloaded state of an rdp in a safe\n\t * and stable way and prevent from its value to be changed\n\t * under us, we must either hold the barrier mutex, the cpu\n\t * hotplug lock (read or write) or the nocb lock. Local\n\t * non-preemptible reads are also safe. NOCB kthreads and\n\t * timers have their own means of synchronization against the\n\t * offloaded state updaters.\n\t */\n\tRCU_LOCKDEP_WARN(\n\t\t!(lockdep_is_held(&rcu_state.barrier_mutex) ||\n\t\t  (IS_ENABLED(CONFIG_HOTPLUG_CPU) && lockdep_is_cpus_held()) ||\n\t\t  rcu_lockdep_is_held_nocb(rdp) ||\n\t\t  (rdp == this_cpu_ptr(&rcu_data) &&\n\t\t   !(IS_ENABLED(CONFIG_PREEMPT_COUNT) && preemptible())) ||\n\t\t  rcu_current_is_nocb_kthread(rdp)),\n\t\t\"Unsafe read of RCU_NOCB offloaded state\"\n\t);\n\n\treturn rcu_segcblist_is_offloaded(&rdp->cblist);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_assert_irqs_disabled",
          "args": [],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "static void rcu_lockdep_assert_cblist_protected(struct rcu_data *rdp)\n{\n\tlockdep_assert_irqs_disabled();\n\tif (rcu_rdp_is_offloaded(rdp))\n\t\tlockdep_assert_held(&rdp->nocb_lock);\n}"
  },
  {
    "function_name": "rcu_nocb_unlock_irqrestore",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_nocb.h",
    "lines": "179-188",
    "snippet": "static void rcu_nocb_unlock_irqrestore(struct rcu_data *rdp,\n\t\t\t\t       unsigned long flags)\n{\n\tif (rcu_rdp_is_offloaded(rdp)) {\n\t\tlockdep_assert_irqs_disabled();\n\t\traw_spin_unlock_irqrestore(&rdp->nocb_lock, flags);\n\t} else {\n\t\tlocal_irq_restore(flags);\n\t}\n}",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore",
          "args": [
            "&rdp->nocb_lock",
            "flags"
          ],
          "line": 184
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "192-195",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_assert_irqs_disabled",
          "args": [],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_rdp_is_offloaded",
          "args": [
            "rdp"
          ],
          "line": 182
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_rdp_is_offloaded",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "16-38",
          "snippet": "static bool rcu_rdp_is_offloaded(struct rcu_data *rdp)\n{\n\t/*\n\t * In order to read the offloaded state of an rdp in a safe\n\t * and stable way and prevent from its value to be changed\n\t * under us, we must either hold the barrier mutex, the cpu\n\t * hotplug lock (read or write) or the nocb lock. Local\n\t * non-preemptible reads are also safe. NOCB kthreads and\n\t * timers have their own means of synchronization against the\n\t * offloaded state updaters.\n\t */\n\tRCU_LOCKDEP_WARN(\n\t\t!(lockdep_is_held(&rcu_state.barrier_mutex) ||\n\t\t  (IS_ENABLED(CONFIG_HOTPLUG_CPU) && lockdep_is_cpus_held()) ||\n\t\t  rcu_lockdep_is_held_nocb(rdp) ||\n\t\t  (rdp == this_cpu_ptr(&rcu_data) &&\n\t\t   !(IS_ENABLED(CONFIG_PREEMPT_COUNT) && preemptible())) ||\n\t\t  rcu_current_is_nocb_kthread(rdp)),\n\t\t\"Unsafe read of RCU_NOCB offloaded state\"\n\t);\n\n\treturn rcu_segcblist_is_offloaded(&rdp->cblist);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nstatic bool rcu_rdp_is_offloaded(struct rcu_data *rdp)\n{\n\t/*\n\t * In order to read the offloaded state of an rdp in a safe\n\t * and stable way and prevent from its value to be changed\n\t * under us, we must either hold the barrier mutex, the cpu\n\t * hotplug lock (read or write) or the nocb lock. Local\n\t * non-preemptible reads are also safe. NOCB kthreads and\n\t * timers have their own means of synchronization against the\n\t * offloaded state updaters.\n\t */\n\tRCU_LOCKDEP_WARN(\n\t\t!(lockdep_is_held(&rcu_state.barrier_mutex) ||\n\t\t  (IS_ENABLED(CONFIG_HOTPLUG_CPU) && lockdep_is_cpus_held()) ||\n\t\t  rcu_lockdep_is_held_nocb(rdp) ||\n\t\t  (rdp == this_cpu_ptr(&rcu_data) &&\n\t\t   !(IS_ENABLED(CONFIG_PREEMPT_COUNT) && preemptible())) ||\n\t\t  rcu_current_is_nocb_kthread(rdp)),\n\t\t\"Unsafe read of RCU_NOCB offloaded state\"\n\t);\n\n\treturn rcu_segcblist_is_offloaded(&rdp->cblist);\n}"
        }
      }
    ],
    "contextual_snippet": "static void rcu_nocb_unlock_irqrestore(struct rcu_data *rdp,\n\t\t\t\t       unsigned long flags)\n{\n\tif (rcu_rdp_is_offloaded(rdp)) {\n\t\tlockdep_assert_irqs_disabled();\n\t\traw_spin_unlock_irqrestore(&rdp->nocb_lock, flags);\n\t} else {\n\t\tlocal_irq_restore(flags);\n\t}\n}"
  },
  {
    "function_name": "rcu_nocb_unlock",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_nocb.h",
    "lines": "167-173",
    "snippet": "static void rcu_nocb_unlock(struct rcu_data *rdp)\n{\n\tif (rcu_rdp_is_offloaded(rdp)) {\n\t\tlockdep_assert_irqs_disabled();\n\t\traw_spin_unlock(&rdp->nocb_lock);\n\t}\n}",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock",
          "args": [
            "&rdp->nocb_lock"
          ],
          "line": 171
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_bh",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "208-211",
          "snippet": "void __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_assert_irqs_disabled",
          "args": [],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_rdp_is_offloaded",
          "args": [
            "rdp"
          ],
          "line": 169
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_rdp_is_offloaded",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "16-38",
          "snippet": "static bool rcu_rdp_is_offloaded(struct rcu_data *rdp)\n{\n\t/*\n\t * In order to read the offloaded state of an rdp in a safe\n\t * and stable way and prevent from its value to be changed\n\t * under us, we must either hold the barrier mutex, the cpu\n\t * hotplug lock (read or write) or the nocb lock. Local\n\t * non-preemptible reads are also safe. NOCB kthreads and\n\t * timers have their own means of synchronization against the\n\t * offloaded state updaters.\n\t */\n\tRCU_LOCKDEP_WARN(\n\t\t!(lockdep_is_held(&rcu_state.barrier_mutex) ||\n\t\t  (IS_ENABLED(CONFIG_HOTPLUG_CPU) && lockdep_is_cpus_held()) ||\n\t\t  rcu_lockdep_is_held_nocb(rdp) ||\n\t\t  (rdp == this_cpu_ptr(&rcu_data) &&\n\t\t   !(IS_ENABLED(CONFIG_PREEMPT_COUNT) && preemptible())) ||\n\t\t  rcu_current_is_nocb_kthread(rdp)),\n\t\t\"Unsafe read of RCU_NOCB offloaded state\"\n\t);\n\n\treturn rcu_segcblist_is_offloaded(&rdp->cblist);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nstatic bool rcu_rdp_is_offloaded(struct rcu_data *rdp)\n{\n\t/*\n\t * In order to read the offloaded state of an rdp in a safe\n\t * and stable way and prevent from its value to be changed\n\t * under us, we must either hold the barrier mutex, the cpu\n\t * hotplug lock (read or write) or the nocb lock. Local\n\t * non-preemptible reads are also safe. NOCB kthreads and\n\t * timers have their own means of synchronization against the\n\t * offloaded state updaters.\n\t */\n\tRCU_LOCKDEP_WARN(\n\t\t!(lockdep_is_held(&rcu_state.barrier_mutex) ||\n\t\t  (IS_ENABLED(CONFIG_HOTPLUG_CPU) && lockdep_is_cpus_held()) ||\n\t\t  rcu_lockdep_is_held_nocb(rdp) ||\n\t\t  (rdp == this_cpu_ptr(&rcu_data) &&\n\t\t   !(IS_ENABLED(CONFIG_PREEMPT_COUNT) && preemptible())) ||\n\t\t  rcu_current_is_nocb_kthread(rdp)),\n\t\t\"Unsafe read of RCU_NOCB offloaded state\"\n\t);\n\n\treturn rcu_segcblist_is_offloaded(&rdp->cblist);\n}"
        }
      }
    ],
    "contextual_snippet": "static void rcu_nocb_unlock(struct rcu_data *rdp)\n{\n\tif (rcu_rdp_is_offloaded(rdp)) {\n\t\tlockdep_assert_irqs_disabled();\n\t\traw_spin_unlock(&rdp->nocb_lock);\n\t}\n}"
  },
  {
    "function_name": "rcu_nocb_lock",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_nocb.h",
    "lines": "155-161",
    "snippet": "static void rcu_nocb_lock(struct rcu_data *rdp)\n{\n\tlockdep_assert_irqs_disabled();\n\tif (!rcu_rdp_is_offloaded(rdp))\n\t\treturn;\n\traw_spin_lock(&rdp->nocb_lock);\n}",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_lock",
          "args": [
            "&rdp->nocb_lock"
          ],
          "line": 160
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_bh",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "176-179",
          "snippet": "void __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_rdp_is_offloaded",
          "args": [
            "rdp"
          ],
          "line": 158
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_rdp_is_offloaded",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "16-38",
          "snippet": "static bool rcu_rdp_is_offloaded(struct rcu_data *rdp)\n{\n\t/*\n\t * In order to read the offloaded state of an rdp in a safe\n\t * and stable way and prevent from its value to be changed\n\t * under us, we must either hold the barrier mutex, the cpu\n\t * hotplug lock (read or write) or the nocb lock. Local\n\t * non-preemptible reads are also safe. NOCB kthreads and\n\t * timers have their own means of synchronization against the\n\t * offloaded state updaters.\n\t */\n\tRCU_LOCKDEP_WARN(\n\t\t!(lockdep_is_held(&rcu_state.barrier_mutex) ||\n\t\t  (IS_ENABLED(CONFIG_HOTPLUG_CPU) && lockdep_is_cpus_held()) ||\n\t\t  rcu_lockdep_is_held_nocb(rdp) ||\n\t\t  (rdp == this_cpu_ptr(&rcu_data) &&\n\t\t   !(IS_ENABLED(CONFIG_PREEMPT_COUNT) && preemptible())) ||\n\t\t  rcu_current_is_nocb_kthread(rdp)),\n\t\t\"Unsafe read of RCU_NOCB offloaded state\"\n\t);\n\n\treturn rcu_segcblist_is_offloaded(&rdp->cblist);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nstatic bool rcu_rdp_is_offloaded(struct rcu_data *rdp)\n{\n\t/*\n\t * In order to read the offloaded state of an rdp in a safe\n\t * and stable way and prevent from its value to be changed\n\t * under us, we must either hold the barrier mutex, the cpu\n\t * hotplug lock (read or write) or the nocb lock. Local\n\t * non-preemptible reads are also safe. NOCB kthreads and\n\t * timers have their own means of synchronization against the\n\t * offloaded state updaters.\n\t */\n\tRCU_LOCKDEP_WARN(\n\t\t!(lockdep_is_held(&rcu_state.barrier_mutex) ||\n\t\t  (IS_ENABLED(CONFIG_HOTPLUG_CPU) && lockdep_is_cpus_held()) ||\n\t\t  rcu_lockdep_is_held_nocb(rdp) ||\n\t\t  (rdp == this_cpu_ptr(&rcu_data) &&\n\t\t   !(IS_ENABLED(CONFIG_PREEMPT_COUNT) && preemptible())) ||\n\t\t  rcu_current_is_nocb_kthread(rdp)),\n\t\t\"Unsafe read of RCU_NOCB offloaded state\"\n\t);\n\n\treturn rcu_segcblist_is_offloaded(&rdp->cblist);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_assert_irqs_disabled",
          "args": [],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "static void rcu_nocb_lock(struct rcu_data *rdp)\n{\n\tlockdep_assert_irqs_disabled();\n\tif (!rcu_rdp_is_offloaded(rdp))\n\t\treturn;\n\traw_spin_lock(&rdp->nocb_lock);\n}"
  },
  {
    "function_name": "rcu_nocb_bypass_unlock",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_nocb.h",
    "lines": "144-149",
    "snippet": "static void rcu_nocb_bypass_unlock(struct rcu_data *rdp)\n\t__releases(&rdp->nocb_bypass_lock)\n{\n\tlockdep_assert_irqs_disabled();\n\traw_spin_unlock(&rdp->nocb_bypass_lock);\n}",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock",
          "args": [
            "&rdp->nocb_bypass_lock"
          ],
          "line": 148
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_bh",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "208-211",
          "snippet": "void __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_assert_irqs_disabled",
          "args": [],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__releases",
          "args": [
            "&rdp->nocb_bypass_lock"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "static void rcu_nocb_bypass_unlock(struct rcu_data *rdp)\n\t__releases(&rdp->nocb_bypass_lock)\n{\n\tlockdep_assert_irqs_disabled();\n\traw_spin_unlock(&rdp->nocb_bypass_lock);\n}"
  },
  {
    "function_name": "rcu_nocb_bypass_trylock",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_nocb.h",
    "lines": "135-139",
    "snippet": "static bool rcu_nocb_bypass_trylock(struct rcu_data *rdp)\n{\n\tlockdep_assert_irqs_disabled();\n\treturn raw_spin_trylock(&rdp->nocb_bypass_lock);\n}",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_trylock",
          "args": [
            "&rdp->nocb_bypass_lock"
          ],
          "line": 138
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_trylock_bh",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "144-147",
          "snippet": "int __lockfunc _raw_spin_trylock_bh(raw_spinlock_t *lock)\n{\n\treturn __raw_spin_trylock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nint __lockfunc _raw_spin_trylock_bh(raw_spinlock_t *lock)\n{\n\treturn __raw_spin_trylock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_assert_irqs_disabled",
          "args": [],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "static bool rcu_nocb_bypass_trylock(struct rcu_data *rdp)\n{\n\tlockdep_assert_irqs_disabled();\n\treturn raw_spin_trylock(&rdp->nocb_bypass_lock);\n}"
  },
  {
    "function_name": "rcu_nocb_wait_contended",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_nocb.h",
    "lines": "124-129",
    "snippet": "static void rcu_nocb_wait_contended(struct rcu_data *rdp)\n{\n\tWARN_ON_ONCE(smp_processor_id() != rdp->cpu);\n\twhile (WARN_ON_ONCE(atomic_read(&rdp->nocb_lock_contended)))\n\t\tcpu_relax();\n}",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_relax",
          "args": [],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "atomic_read(&rdp->nocb_lock_contended)"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&rdp->nocb_lock_contended"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "smp_processor_id() != rdp->cpu"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "static void rcu_nocb_wait_contended(struct rcu_data *rdp)\n{\n\tWARN_ON_ONCE(smp_processor_id() != rdp->cpu);\n\twhile (WARN_ON_ONCE(atomic_read(&rdp->nocb_lock_contended)))\n\t\tcpu_relax();\n}"
  },
  {
    "function_name": "rcu_nocb_bypass_lock",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_nocb.h",
    "lines": "100-112",
    "snippet": "static void rcu_nocb_bypass_lock(struct rcu_data *rdp)\n\t__acquires(&rdp->nocb_bypass_lock)\n{\n\tlockdep_assert_irqs_disabled();\n\tif (raw_spin_trylock(&rdp->nocb_bypass_lock))\n\t\treturn;\n\tatomic_inc(&rdp->nocb_lock_contended);\n\tWARN_ON_ONCE(smp_processor_id() != rdp->cpu);\n\tsmp_mb__after_atomic(); /* atomic_inc() before lock. */\n\traw_spin_lock(&rdp->nocb_bypass_lock);\n\tsmp_mb__before_atomic(); /* atomic_dec() after lock. */\n\tatomic_dec(&rdp->nocb_lock_contended);\n}",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&rdp->nocb_lock_contended"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_mb__before_atomic",
          "args": [],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock",
          "args": [
            "&rdp->nocb_bypass_lock"
          ],
          "line": 109
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_bh",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "176-179",
          "snippet": "void __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_mb__after_atomic",
          "args": [],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "smp_processor_id() != rdp->cpu"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&rdp->nocb_lock_contended"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_trylock",
          "args": [
            "&rdp->nocb_bypass_lock"
          ],
          "line": 104
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_trylock_bh",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "144-147",
          "snippet": "int __lockfunc _raw_spin_trylock_bh(raw_spinlock_t *lock)\n{\n\treturn __raw_spin_trylock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nint __lockfunc _raw_spin_trylock_bh(raw_spinlock_t *lock)\n{\n\treturn __raw_spin_trylock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_assert_irqs_disabled",
          "args": [],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__acquires",
          "args": [
            "&rdp->nocb_bypass_lock"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "static void rcu_nocb_bypass_lock(struct rcu_data *rdp)\n\t__acquires(&rdp->nocb_bypass_lock)\n{\n\tlockdep_assert_irqs_disabled();\n\tif (raw_spin_trylock(&rdp->nocb_bypass_lock))\n\t\treturn;\n\tatomic_inc(&rdp->nocb_lock_contended);\n\tWARN_ON_ONCE(smp_processor_id() != rdp->cpu);\n\tsmp_mb__after_atomic(); /* atomic_inc() before lock. */\n\traw_spin_lock(&rdp->nocb_bypass_lock);\n\tsmp_mb__before_atomic(); /* atomic_dec() after lock. */\n\tatomic_dec(&rdp->nocb_lock_contended);\n}"
  },
  {
    "function_name": "parse_rcu_nocb_poll",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_nocb.h",
    "lines": "80-84",
    "snippet": "static int __init parse_rcu_nocb_poll(char *arg)\n{\n\trcu_nocb_poll = true;\n\treturn 0;\n}",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "static int __init parse_rcu_nocb_poll(char *arg)\n{\n\trcu_nocb_poll = true;\n\treturn 0;\n}"
  },
  {
    "function_name": "rcu_nocb_setup",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_nocb.h",
    "lines": "66-77",
    "snippet": "static int __init rcu_nocb_setup(char *str)\n{\n\talloc_bootmem_cpumask_var(&rcu_nocb_mask);\n\tif (*str == '=') {\n\t\tif (cpulist_parse(++str, rcu_nocb_mask)) {\n\t\t\tpr_warn(\"rcu_nocbs= bad CPU range, all CPUs set\\n\");\n\t\t\tcpumask_setall(rcu_nocb_mask);\n\t\t}\n\t}\n\trcu_nocb_is_setup = true;\n\treturn 1;\n}",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpumask_setall",
          "args": [
            "rcu_nocb_mask"
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"rcu_nocbs= bad CPU range, all CPUs set\\n\""
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpulist_parse",
          "args": [
            "++str",
            "rcu_nocb_mask"
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_bootmem_cpumask_var",
          "args": [
            "&rcu_nocb_mask"
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "static int __init rcu_nocb_setup(char *str)\n{\n\talloc_bootmem_cpumask_var(&rcu_nocb_mask);\n\tif (*str == '=') {\n\t\tif (cpulist_parse(++str, rcu_nocb_mask)) {\n\t\t\tpr_warn(\"rcu_nocbs= bad CPU range, all CPUs set\\n\");\n\t\t\tcpumask_setall(rcu_nocb_mask);\n\t\t}\n\t}\n\trcu_nocb_is_setup = true;\n\treturn 1;\n}"
  },
  {
    "function_name": "rcu_current_is_nocb_kthread",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_nocb.h",
    "lines": "24-34",
    "snippet": "static inline bool rcu_current_is_nocb_kthread(struct rcu_data *rdp)\n{\n\t/* Race on early boot between thread creation and assignment */\n\tif (!rdp->nocb_cb_kthread || !rdp->nocb_gp_kthread)\n\t\treturn true;\n\n\tif (current == rdp->nocb_cb_kthread || current == rdp->nocb_gp_kthread)\n\t\tif (in_task())\n\t\t\treturn true;\n\treturn false;\n}",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "in_task",
          "args": [],
          "line": 31
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "static inline bool rcu_current_is_nocb_kthread(struct rcu_data *rdp)\n{\n\t/* Race on early boot between thread creation and assignment */\n\tif (!rdp->nocb_cb_kthread || !rdp->nocb_gp_kthread)\n\t\treturn true;\n\n\tif (current == rdp->nocb_cb_kthread || current == rdp->nocb_gp_kthread)\n\t\tif (in_task())\n\t\t\treturn true;\n\treturn false;\n}"
  },
  {
    "function_name": "rcu_lockdep_is_held_nocb",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_nocb.h",
    "lines": "19-22",
    "snippet": "static inline int rcu_lockdep_is_held_nocb(struct rcu_data *rdp)\n{\n\treturn lockdep_is_held(&rdp->nocb_lock);\n}",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lockdep_is_held",
          "args": [
            "&rdp->nocb_lock"
          ],
          "line": 21
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_lockdep_is_held_nocb",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_nocb.h",
          "lines": "1458-1461",
          "snippet": "static inline int rcu_lockdep_is_held_nocb(struct rcu_data *rdp)\n{\n\treturn 0;\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "static inline int rcu_lockdep_is_held_nocb(struct rcu_data *rdp)\n{\n\treturn lockdep_is_held(&rdp->nocb_lock);\n}"
  }
]