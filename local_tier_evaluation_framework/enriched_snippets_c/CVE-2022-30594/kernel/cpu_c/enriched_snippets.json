[
  {
    "function_name": "cpu_mitigations_auto_nosmt",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
    "lines": "2708-2711",
    "snippet": "bool cpu_mitigations_auto_nosmt(void)\n{\n\treturn cpu_mitigations == CPU_MITIGATIONS_AUTO_NOSMT;\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/scs.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sched/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static enum cpu_mitigations cpu_mitigations"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstatic enum cpu_mitigations cpu_mitigations;\n\nbool cpu_mitigations_auto_nosmt(void)\n{\n\treturn cpu_mitigations == CPU_MITIGATIONS_AUTO_NOSMT;\n}"
  },
  {
    "function_name": "cpu_mitigations_off",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
    "lines": "2701-2704",
    "snippet": "bool cpu_mitigations_off(void)\n{\n\treturn cpu_mitigations == CPU_MITIGATIONS_OFF;\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/scs.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sched/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static enum cpu_mitigations cpu_mitigations"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstatic enum cpu_mitigations cpu_mitigations;\n\nbool cpu_mitigations_off(void)\n{\n\treturn cpu_mitigations == CPU_MITIGATIONS_OFF;\n}"
  },
  {
    "function_name": "mitigations_parse_cmdline",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
    "lines": "2684-2697",
    "snippet": "static int __init mitigations_parse_cmdline(char *arg)\n{\n\tif (!strcmp(arg, \"off\"))\n\t\tcpu_mitigations = CPU_MITIGATIONS_OFF;\n\telse if (!strcmp(arg, \"auto\"))\n\t\tcpu_mitigations = CPU_MITIGATIONS_AUTO;\n\telse if (!strcmp(arg, \"auto,nosmt\"))\n\t\tcpu_mitigations = CPU_MITIGATIONS_AUTO_NOSMT;\n\telse\n\t\tpr_crit(\"Unsupported mitigations=%s, system may still be vulnerable\\n\",\n\t\t\targ);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/scs.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sched/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static enum cpu_mitigations cpu_mitigations"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_crit",
          "args": [
            "\"Unsupported mitigations=%s, system may still be vulnerable\\n\"",
            "arg"
          ],
          "line": 2693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"auto,nosmt\""
          ],
          "line": 2690
        },
        "resolved": true,
        "details": {
          "function_name": "sym_strcmp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/report.c",
          "lines": "356-365",
          "snippet": "static int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}",
          "includes": [
            "#include \"encoding.h\"",
            "#include \"kcsan.h\"",
            "#include <linux/stacktrace.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/delay.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"encoding.h\"\n#include \"kcsan.h\"\n#include <linux/stacktrace.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/lockdep.h>\n#include <linux/kernel.h>\n#include <linux/kallsyms.h>\n#include <linux/jiffies.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n\nstatic int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstatic enum cpu_mitigations cpu_mitigations;\n\nstatic int __init mitigations_parse_cmdline(char *arg)\n{\n\tif (!strcmp(arg, \"off\"))\n\t\tcpu_mitigations = CPU_MITIGATIONS_OFF;\n\telse if (!strcmp(arg, \"auto\"))\n\t\tcpu_mitigations = CPU_MITIGATIONS_AUTO;\n\telse if (!strcmp(arg, \"auto,nosmt\"))\n\t\tcpu_mitigations = CPU_MITIGATIONS_AUTO_NOSMT;\n\telse\n\t\tpr_crit(\"Unsupported mitigations=%s, system may still be vulnerable\\n\",\n\t\t\targ);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "boot_cpu_hotplug_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
    "lines": "2663-2669",
    "snippet": "void __init boot_cpu_hotplug_init(void)\n{\n#ifdef CONFIG_SMP\n\tcpumask_set_cpu(smp_processor_id(), &cpus_booted_once_mask);\n#endif\n\tthis_cpu_write(cpuhp_state.state, CPUHP_ONLINE);\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/scs.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sched/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "this_cpu_write",
          "args": [
            "cpuhp_state.state",
            "CPUHP_ONLINE"
          ],
          "line": 2668
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_set_cpu",
          "args": [
            "smp_processor_id()",
            "&cpus_booted_once_mask"
          ],
          "line": 2666
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 2666
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\n\nvoid __init boot_cpu_hotplug_init(void)\n{\n#ifdef CONFIG_SMP\n\tcpumask_set_cpu(smp_processor_id(), &cpus_booted_once_mask);\n#endif\n\tthis_cpu_write(cpuhp_state.state, CPUHP_ONLINE);\n}"
  },
  {
    "function_name": "boot_cpu_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
    "lines": "2645-2658",
    "snippet": "void __init boot_cpu_init(void)\n{\n\tint cpu = smp_processor_id();\n\n\t/* Mark the boot cpu \"present\", \"online\" etc for SMP and UP case */\n\tset_cpu_online(cpu, true);\n\tset_cpu_active(cpu, true);\n\tset_cpu_present(cpu, true);\n\tset_cpu_possible(cpu, true);\n\n#ifdef CONFIG_SMP\n\t__boot_cpu_id = cpu;\n#endif\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/scs.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sched/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_cpu_possible",
          "args": [
            "cpu",
            "true"
          ],
          "line": 2653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_cpu_present",
          "args": [
            "cpu",
            "true"
          ],
          "line": 2652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_cpu_active",
          "args": [
            "cpu",
            "true"
          ],
          "line": 2651
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_cpu_online",
          "args": [
            "cpu",
            "true"
          ],
          "line": 2650
        },
        "resolved": true,
        "details": {
          "function_name": "set_cpu_online",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "2621-2640",
          "snippet": "void set_cpu_online(unsigned int cpu, bool online)\n{\n\t/*\n\t * atomic_inc/dec() is required to handle the horrid abuse of this\n\t * function by the reboot and kexec code which invoke it from\n\t * IPI/NMI broadcasts when shutting down CPUs. Invocation from\n\t * regular CPU hotplug is properly serialized.\n\t *\n\t * Note, that the fact that __num_online_cpus is of type atomic_t\n\t * does not protect readers which are not serialized against\n\t * concurrent hotplug operations.\n\t */\n\tif (online) {\n\t\tif (!cpumask_test_and_set_cpu(cpu, &__cpu_online_mask))\n\t\t\tatomic_inc(&__num_online_cpus);\n\t} else {\n\t\tif (cpumask_test_and_clear_cpu(cpu, &__cpu_online_mask))\n\t\t\tatomic_dec(&__num_online_cpus);\n\t}\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct cpumask __cpu_online_mask",
            "atomic_t __num_online_cpus"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstruct cpumask __cpu_online_mask;\natomic_t __num_online_cpus;\n\nvoid set_cpu_online(unsigned int cpu, bool online)\n{\n\t/*\n\t * atomic_inc/dec() is required to handle the horrid abuse of this\n\t * function by the reboot and kexec code which invoke it from\n\t * IPI/NMI broadcasts when shutting down CPUs. Invocation from\n\t * regular CPU hotplug is properly serialized.\n\t *\n\t * Note, that the fact that __num_online_cpus is of type atomic_t\n\t * does not protect readers which are not serialized against\n\t * concurrent hotplug operations.\n\t */\n\tif (online) {\n\t\tif (!cpumask_test_and_set_cpu(cpu, &__cpu_online_mask))\n\t\t\tatomic_inc(&__num_online_cpus);\n\t} else {\n\t\tif (cpumask_test_and_clear_cpu(cpu, &__cpu_online_mask))\n\t\t\tatomic_dec(&__num_online_cpus);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 2647
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nvoid __init boot_cpu_init(void)\n{\n\tint cpu = smp_processor_id();\n\n\t/* Mark the boot cpu \"present\", \"online\" etc for SMP and UP case */\n\tset_cpu_online(cpu, true);\n\tset_cpu_active(cpu, true);\n\tset_cpu_present(cpu, true);\n\tset_cpu_possible(cpu, true);\n\n#ifdef CONFIG_SMP\n\t__boot_cpu_id = cpu;\n#endif\n}"
  },
  {
    "function_name": "set_cpu_online",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
    "lines": "2621-2640",
    "snippet": "void set_cpu_online(unsigned int cpu, bool online)\n{\n\t/*\n\t * atomic_inc/dec() is required to handle the horrid abuse of this\n\t * function by the reboot and kexec code which invoke it from\n\t * IPI/NMI broadcasts when shutting down CPUs. Invocation from\n\t * regular CPU hotplug is properly serialized.\n\t *\n\t * Note, that the fact that __num_online_cpus is of type atomic_t\n\t * does not protect readers which are not serialized against\n\t * concurrent hotplug operations.\n\t */\n\tif (online) {\n\t\tif (!cpumask_test_and_set_cpu(cpu, &__cpu_online_mask))\n\t\t\tatomic_inc(&__num_online_cpus);\n\t} else {\n\t\tif (cpumask_test_and_clear_cpu(cpu, &__cpu_online_mask))\n\t\t\tatomic_dec(&__num_online_cpus);\n\t}\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/scs.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sched/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct cpumask __cpu_online_mask",
      "atomic_t __num_online_cpus"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&__num_online_cpus"
          ],
          "line": 2638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_test_and_clear_cpu",
          "args": [
            "cpu",
            "&__cpu_online_mask"
          ],
          "line": 2637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&__num_online_cpus"
          ],
          "line": 2635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_test_and_set_cpu",
          "args": [
            "cpu",
            "&__cpu_online_mask"
          ],
          "line": 2634
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstruct cpumask __cpu_online_mask;\natomic_t __num_online_cpus;\n\nvoid set_cpu_online(unsigned int cpu, bool online)\n{\n\t/*\n\t * atomic_inc/dec() is required to handle the horrid abuse of this\n\t * function by the reboot and kexec code which invoke it from\n\t * IPI/NMI broadcasts when shutting down CPUs. Invocation from\n\t * regular CPU hotplug is properly serialized.\n\t *\n\t * Note, that the fact that __num_online_cpus is of type atomic_t\n\t * does not protect readers which are not serialized against\n\t * concurrent hotplug operations.\n\t */\n\tif (online) {\n\t\tif (!cpumask_test_and_set_cpu(cpu, &__cpu_online_mask))\n\t\t\tatomic_inc(&__num_online_cpus);\n\t} else {\n\t\tif (cpumask_test_and_clear_cpu(cpu, &__cpu_online_mask))\n\t\t\tatomic_dec(&__num_online_cpus);\n\t}\n}"
  },
  {
    "function_name": "init_cpu_online",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
    "lines": "2616-2619",
    "snippet": "void init_cpu_online(const struct cpumask *src)\n{\n\tcpumask_copy(&__cpu_online_mask, src);\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/scs.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sched/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct cpumask __cpu_online_mask"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpumask_copy",
          "args": [
            "&__cpu_online_mask",
            "src"
          ],
          "line": 2618
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstruct cpumask __cpu_online_mask;\n\nvoid init_cpu_online(const struct cpumask *src)\n{\n\tcpumask_copy(&__cpu_online_mask, src);\n}"
  },
  {
    "function_name": "init_cpu_possible",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
    "lines": "2611-2614",
    "snippet": "void init_cpu_possible(const struct cpumask *src)\n{\n\tcpumask_copy(&__cpu_possible_mask, src);\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/scs.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sched/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpumask_copy",
          "args": [
            "&__cpu_possible_mask",
            "src"
          ],
          "line": 2613
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nvoid init_cpu_possible(const struct cpumask *src)\n{\n\tcpumask_copy(&__cpu_possible_mask, src);\n}"
  },
  {
    "function_name": "init_cpu_present",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
    "lines": "2606-2609",
    "snippet": "void init_cpu_present(const struct cpumask *src)\n{\n\tcpumask_copy(&__cpu_present_mask, src);\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/scs.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sched/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct cpumask __cpu_present_mask"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpumask_copy",
          "args": [
            "&__cpu_present_mask",
            "src"
          ],
          "line": 2608
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstruct cpumask __cpu_present_mask;\n\nvoid init_cpu_present(const struct cpumask *src)\n{\n\tcpumask_copy(&__cpu_present_mask, src);\n}"
  },
  {
    "function_name": "cpuhp_sysfs_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
    "lines": "2528-2551",
    "snippet": "static int __init cpuhp_sysfs_init(void)\n{\n\tint cpu, ret;\n\n\tret = cpu_smt_sysfs_init();\n\tif (ret)\n\t\treturn ret;\n\n\tret = sysfs_create_group(&cpu_subsys.dev_root->kobj,\n\t\t\t\t &cpuhp_cpu_root_attr_group);\n\tif (ret)\n\t\treturn ret;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tstruct device *dev = get_cpu_device(cpu);\n\n\t\tif (!dev)\n\t\t\tcontinue;\n\t\tret = sysfs_create_group(&dev->kobj, &cpuhp_cpu_attr_group);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/scs.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sched/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sysfs_create_group",
          "args": [
            "&dev->kobj",
            "&cpuhp_cpu_attr_group"
          ],
          "line": 2546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_cpu_device",
          "args": [
            "cpu"
          ],
          "line": 2542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sysfs_create_group",
          "args": [
            "&cpu_subsys.dev_root->kobj",
            "&cpuhp_cpu_root_attr_group"
          ],
          "line": 2536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_smt_sysfs_init",
          "args": [],
          "line": 2532
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_smt_sysfs_init",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "2522-2526",
          "snippet": "static int __init cpu_smt_sysfs_init(void)\n{\n\treturn sysfs_create_group(&cpu_subsys.dev_root->kobj,\n\t\t\t\t  &cpuhp_smt_attr_group);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstatic int __init cpu_smt_sysfs_init(void)\n{\n\treturn sysfs_create_group(&cpu_subsys.dev_root->kobj,\n\t\t\t\t  &cpuhp_smt_attr_group);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstatic int __init cpuhp_sysfs_init(void)\n{\n\tint cpu, ret;\n\n\tret = cpu_smt_sysfs_init();\n\tif (ret)\n\t\treturn ret;\n\n\tret = sysfs_create_group(&cpu_subsys.dev_root->kobj,\n\t\t\t\t &cpuhp_cpu_root_attr_group);\n\tif (ret)\n\t\treturn ret;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tstruct device *dev = get_cpu_device(cpu);\n\n\t\tif (!dev)\n\t\t\tcontinue;\n\t\tret = sysfs_create_group(&dev->kobj, &cpuhp_cpu_attr_group);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "cpu_smt_sysfs_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
    "lines": "2522-2526",
    "snippet": "static int __init cpu_smt_sysfs_init(void)\n{\n\treturn sysfs_create_group(&cpu_subsys.dev_root->kobj,\n\t\t\t\t  &cpuhp_smt_attr_group);\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/scs.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sched/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sysfs_create_group",
          "args": [
            "&cpu_subsys.dev_root->kobj",
            "&cpuhp_smt_attr_group"
          ],
          "line": 2524
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstatic int __init cpu_smt_sysfs_init(void)\n{\n\treturn sysfs_create_group(&cpu_subsys.dev_root->kobj,\n\t\t\t\t  &cpuhp_smt_attr_group);\n}"
  },
  {
    "function_name": "active_show",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
    "lines": "2503-2507",
    "snippet": "static ssize_t active_show(struct device *dev,\n\t\t\t   struct device_attribute *attr, char *buf)\n{\n\treturn snprintf(buf, PAGE_SIZE - 2, \"%d\\n\", sched_smt_active());\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/scs.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sched/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "PAGE_SIZE - 2",
            "\"%d\\n\"",
            "sched_smt_active()"
          ],
          "line": 2506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sched_smt_active",
          "args": [],
          "line": 2506
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstatic ssize_t active_show(struct device *dev,\n\t\t\t   struct device_attribute *attr, char *buf)\n{\n\treturn snprintf(buf, PAGE_SIZE - 2, \"%d\\n\", sched_smt_active());\n}"
  },
  {
    "function_name": "control_store",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
    "lines": "2496-2500",
    "snippet": "static ssize_t control_store(struct device *dev, struct device_attribute *attr,\n\t\t\t     const char *buf, size_t count)\n{\n\treturn __store_smt_control(dev, attr, buf, count);\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/scs.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sched/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__store_smt_control",
          "args": [
            "dev",
            "attr",
            "buf",
            "count"
          ],
          "line": 2499
        },
        "resolved": true,
        "details": {
          "function_name": "__store_smt_control",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "2472-2477",
          "snippet": "static ssize_t\n__store_smt_control(struct device *dev, struct device_attribute *attr,\n\t\t    const char *buf, size_t count)\n{\n\treturn -ENODEV;\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstatic ssize_t\n__store_smt_control(struct device *dev, struct device_attribute *attr,\n\t\t    const char *buf, size_t count)\n{\n\treturn -ENODEV;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstatic ssize_t control_store(struct device *dev, struct device_attribute *attr,\n\t\t\t     const char *buf, size_t count)\n{\n\treturn __store_smt_control(dev, attr, buf, count);\n}"
  },
  {
    "function_name": "control_show",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
    "lines": "2488-2494",
    "snippet": "static ssize_t control_show(struct device *dev,\n\t\t\t    struct device_attribute *attr, char *buf)\n{\n\tconst char *state = smt_states[cpu_smt_control];\n\n\treturn snprintf(buf, PAGE_SIZE - 2, \"%s\\n\", state);\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/scs.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sched/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "PAGE_SIZE - 2",
            "\"%s\\n\"",
            "state"
          ],
          "line": 2493
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstatic ssize_t control_show(struct device *dev,\n\t\t\t    struct device_attribute *attr, char *buf)\n{\n\tconst char *state = smt_states[cpu_smt_control];\n\n\treturn snprintf(buf, PAGE_SIZE - 2, \"%s\\n\", state);\n}"
  },
  {
    "function_name": "__store_smt_control",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
    "lines": "2472-2477",
    "snippet": "static ssize_t\n__store_smt_control(struct device *dev, struct device_attribute *attr,\n\t\t    const char *buf, size_t count)\n{\n\treturn -ENODEV;\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/scs.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sched/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstatic ssize_t\n__store_smt_control(struct device *dev, struct device_attribute *attr,\n\t\t    const char *buf, size_t count)\n{\n\treturn -ENODEV;\n}"
  },
  {
    "function_name": "__store_smt_control",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
    "lines": "2430-2469",
    "snippet": "static ssize_t\n__store_smt_control(struct device *dev, struct device_attribute *attr,\n\t\t    const char *buf, size_t count)\n{\n\tint ctrlval, ret;\n\n\tif (sysfs_streq(buf, \"on\"))\n\t\tctrlval = CPU_SMT_ENABLED;\n\telse if (sysfs_streq(buf, \"off\"))\n\t\tctrlval = CPU_SMT_DISABLED;\n\telse if (sysfs_streq(buf, \"forceoff\"))\n\t\tctrlval = CPU_SMT_FORCE_DISABLED;\n\telse\n\t\treturn -EINVAL;\n\n\tif (cpu_smt_control == CPU_SMT_FORCE_DISABLED)\n\t\treturn -EPERM;\n\n\tif (cpu_smt_control == CPU_SMT_NOT_SUPPORTED)\n\t\treturn -ENODEV;\n\n\tret = lock_device_hotplug_sysfs();\n\tif (ret)\n\t\treturn ret;\n\n\tif (ctrlval != cpu_smt_control) {\n\t\tswitch (ctrlval) {\n\t\tcase CPU_SMT_ENABLED:\n\t\t\tret = cpuhp_smt_enable();\n\t\t\tbreak;\n\t\tcase CPU_SMT_DISABLED:\n\t\tcase CPU_SMT_FORCE_DISABLED:\n\t\t\tret = cpuhp_smt_disable(ctrlval);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tunlock_device_hotplug();\n\treturn ret ? ret : count;\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/scs.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sched/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_device_hotplug",
          "args": [],
          "line": 2467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpuhp_smt_disable",
          "args": [
            "ctrlval"
          ],
          "line": 2462
        },
        "resolved": true,
        "details": {
          "function_name": "cpuhp_smt_disable",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "2212-2242",
          "snippet": "int cpuhp_smt_disable(enum cpuhp_smt_control ctrlval)\n{\n\tint cpu, ret = 0;\n\n\tcpu_maps_update_begin();\n\tfor_each_online_cpu(cpu) {\n\t\tif (topology_is_primary_thread(cpu))\n\t\t\tcontinue;\n\t\tret = cpu_down_maps_locked(cpu, CPUHP_OFFLINE);\n\t\tif (ret)\n\t\t\tbreak;\n\t\t/*\n\t\t * As this needs to hold the cpu maps lock it's impossible\n\t\t * to call device_offline() because that ends up calling\n\t\t * cpu_down() which takes cpu maps lock. cpu maps lock\n\t\t * needs to be held as this might race against in kernel\n\t\t * abusers of the hotplug machinery (thermal management).\n\t\t *\n\t\t * So nothing would update device:offline state. That would\n\t\t * leave the sysfs entry stale and prevent onlining after\n\t\t * smt control has been changed to 'off' again. This is\n\t\t * called under the sysfs hotplug lock, so it is properly\n\t\t * serialized against the regular offline usage.\n\t\t */\n\t\tcpuhp_offline_cpu_device(cpu);\n\t}\n\tif (!ret)\n\t\tcpu_smt_control = ctrlval;\n\tcpu_maps_update_done();\n\treturn ret;\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nint cpuhp_smt_disable(enum cpuhp_smt_control ctrlval)\n{\n\tint cpu, ret = 0;\n\n\tcpu_maps_update_begin();\n\tfor_each_online_cpu(cpu) {\n\t\tif (topology_is_primary_thread(cpu))\n\t\t\tcontinue;\n\t\tret = cpu_down_maps_locked(cpu, CPUHP_OFFLINE);\n\t\tif (ret)\n\t\t\tbreak;\n\t\t/*\n\t\t * As this needs to hold the cpu maps lock it's impossible\n\t\t * to call device_offline() because that ends up calling\n\t\t * cpu_down() which takes cpu maps lock. cpu maps lock\n\t\t * needs to be held as this might race against in kernel\n\t\t * abusers of the hotplug machinery (thermal management).\n\t\t *\n\t\t * So nothing would update device:offline state. That would\n\t\t * leave the sysfs entry stale and prevent onlining after\n\t\t * smt control has been changed to 'off' again. This is\n\t\t * called under the sysfs hotplug lock, so it is properly\n\t\t * serialized against the regular offline usage.\n\t\t */\n\t\tcpuhp_offline_cpu_device(cpu);\n\t}\n\tif (!ret)\n\t\tcpu_smt_control = ctrlval;\n\tcpu_maps_update_done();\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpuhp_smt_enable",
          "args": [],
          "line": 2458
        },
        "resolved": true,
        "details": {
          "function_name": "cpuhp_smt_enable",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "2244-2262",
          "snippet": "int cpuhp_smt_enable(void)\n{\n\tint cpu, ret = 0;\n\n\tcpu_maps_update_begin();\n\tcpu_smt_control = CPU_SMT_ENABLED;\n\tfor_each_present_cpu(cpu) {\n\t\t/* Skip online CPUs and CPUs on offline nodes */\n\t\tif (cpu_online(cpu) || !node_online(cpu_to_node(cpu)))\n\t\t\tcontinue;\n\t\tret = _cpu_up(cpu, 0, CPUHP_ONLINE);\n\t\tif (ret)\n\t\t\tbreak;\n\t\t/* See comment in cpuhp_smt_disable() */\n\t\tcpuhp_online_cpu_device(cpu);\n\t}\n\tcpu_maps_update_done();\n\treturn ret;\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nint cpuhp_smt_enable(void)\n{\n\tint cpu, ret = 0;\n\n\tcpu_maps_update_begin();\n\tcpu_smt_control = CPU_SMT_ENABLED;\n\tfor_each_present_cpu(cpu) {\n\t\t/* Skip online CPUs and CPUs on offline nodes */\n\t\tif (cpu_online(cpu) || !node_online(cpu_to_node(cpu)))\n\t\t\tcontinue;\n\t\tret = _cpu_up(cpu, 0, CPUHP_ONLINE);\n\t\tif (ret)\n\t\t\tbreak;\n\t\t/* See comment in cpuhp_smt_disable() */\n\t\tcpuhp_online_cpu_device(cpu);\n\t}\n\tcpu_maps_update_done();\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lock_device_hotplug_sysfs",
          "args": [],
          "line": 2451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sysfs_streq",
          "args": [
            "buf",
            "\"forceoff\""
          ],
          "line": 2440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sysfs_streq",
          "args": [
            "buf",
            "\"off\""
          ],
          "line": 2438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sysfs_streq",
          "args": [
            "buf",
            "\"on\""
          ],
          "line": 2436
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstatic ssize_t\n__store_smt_control(struct device *dev, struct device_attribute *attr,\n\t\t    const char *buf, size_t count)\n{\n\tint ctrlval, ret;\n\n\tif (sysfs_streq(buf, \"on\"))\n\t\tctrlval = CPU_SMT_ENABLED;\n\telse if (sysfs_streq(buf, \"off\"))\n\t\tctrlval = CPU_SMT_DISABLED;\n\telse if (sysfs_streq(buf, \"forceoff\"))\n\t\tctrlval = CPU_SMT_FORCE_DISABLED;\n\telse\n\t\treturn -EINVAL;\n\n\tif (cpu_smt_control == CPU_SMT_FORCE_DISABLED)\n\t\treturn -EPERM;\n\n\tif (cpu_smt_control == CPU_SMT_NOT_SUPPORTED)\n\t\treturn -ENODEV;\n\n\tret = lock_device_hotplug_sysfs();\n\tif (ret)\n\t\treturn ret;\n\n\tif (ctrlval != cpu_smt_control) {\n\t\tswitch (ctrlval) {\n\t\tcase CPU_SMT_ENABLED:\n\t\t\tret = cpuhp_smt_enable();\n\t\t\tbreak;\n\t\tcase CPU_SMT_DISABLED:\n\t\tcase CPU_SMT_FORCE_DISABLED:\n\t\t\tret = cpuhp_smt_disable(ctrlval);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tunlock_device_hotplug();\n\treturn ret ? ret : count;\n}"
  },
  {
    "function_name": "states_show",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
    "lines": "2396-2414",
    "snippet": "static ssize_t states_show(struct device *dev,\n\t\t\t\t struct device_attribute *attr, char *buf)\n{\n\tssize_t cur, res = 0;\n\tint i;\n\n\tmutex_lock(&cpuhp_state_mutex);\n\tfor (i = CPUHP_OFFLINE; i <= CPUHP_ONLINE; i++) {\n\t\tstruct cpuhp_step *sp = cpuhp_get_step(i);\n\n\t\tif (sp->name) {\n\t\t\tcur = sprintf(buf, \"%3d: %s\\n\", i, sp->name);\n\t\t\tbuf += cur;\n\t\t\tres += cur;\n\t\t}\n\t}\n\tmutex_unlock(&cpuhp_state_mutex);\n\treturn res;\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/scs.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sched/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(cpuhp_state_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&cpuhp_state_mutex"
          ],
          "line": 2412
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"%3d: %s\\n\"",
            "i",
            "sp->name"
          ],
          "line": 2407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpuhp_get_step",
          "args": [
            "i"
          ],
          "line": 2404
        },
        "resolved": true,
        "details": {
          "function_name": "cpuhp_get_step",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "144-147",
          "snippet": "static struct cpuhp_step *cpuhp_get_step(enum cpuhp_state state)\n{\n\treturn cpuhp_hp_states + state;\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};",
            "static struct cpuhp_step cpuhp_hp_states[];",
            "static struct cpuhp_step cpuhp_hp_states[] = {\n\t[CPUHP_OFFLINE] = {\n\t\t.name\t\t\t= \"offline\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= NULL,\n\t},\n#ifdef CONFIG_SMP\n\t[CPUHP_CREATE_THREADS]= {\n\t\t.name\t\t\t= \"threads:prepare\",\n\t\t.startup.single\t\t= smpboot_create_threads,\n\t\t.teardown.single\t= NULL,\n\t\t.cant_stop\t\t= true,\n\t},\n\t[CPUHP_PERF_PREPARE] = {\n\t\t.name\t\t\t= \"perf:prepare\",\n\t\t.startup.single\t\t= perf_event_init_cpu,\n\t\t.teardown.single\t= perf_event_exit_cpu,\n\t},\n\t[CPUHP_WORKQUEUE_PREP] = {\n\t\t.name\t\t\t= \"workqueue:prepare\",\n\t\t.startup.single\t\t= workqueue_prepare_cpu,\n\t\t.teardown.single\t= NULL,\n\t},\n\t[CPUHP_HRTIMERS_PREPARE] = {\n\t\t.name\t\t\t= \"hrtimers:prepare\",\n\t\t.startup.single\t\t= hrtimers_prepare_cpu,\n\t\t.teardown.single\t= hrtimers_dead_cpu,\n\t},\n\t[CPUHP_SMPCFD_PREPARE] = {\n\t\t.name\t\t\t= \"smpcfd:prepare\",\n\t\t.startup.single\t\t= smpcfd_prepare_cpu,\n\t\t.teardown.single\t= smpcfd_dead_cpu,\n\t},\n\t[CPUHP_RELAY_PREPARE] = {\n\t\t.name\t\t\t= \"relay:prepare\",\n\t\t.startup.single\t\t= relay_prepare_cpu,\n\t\t.teardown.single\t= NULL,\n\t},\n\t[CPUHP_SLAB_PREPARE] = {\n\t\t.name\t\t\t= \"slab:prepare\",\n\t\t.startup.single\t\t= slab_prepare_cpu,\n\t\t.teardown.single\t= slab_dead_cpu,\n\t},\n\t[CPUHP_RCUTREE_PREP] = {\n\t\t.name\t\t\t= \"RCU/tree:prepare\",\n\t\t.startup.single\t\t= rcutree_prepare_cpu,\n\t\t.teardown.single\t= rcutree_dead_cpu,\n\t},\n\t/*\n\t * On the tear-down path, timers_dead_cpu() must be invoked\n\t * before blk_mq_queue_reinit_notify() from notify_dead(),\n\t * otherwise a RCU stall occurs.\n\t */\n\t[CPUHP_TIMERS_PREPARE] = {\n\t\t.name\t\t\t= \"timers:prepare\",\n\t\t.startup.single\t\t= timers_prepare_cpu,\n\t\t.teardown.single\t= timers_dead_cpu,\n\t},\n\t/* Kicks the plugged cpu into life */\n\t[CPUHP_BRINGUP_CPU] = {\n\t\t.name\t\t\t= \"cpu:bringup\",\n\t\t.startup.single\t\t= bringup_cpu,\n\t\t.teardown.single\t= finish_cpu,\n\t\t.cant_stop\t\t= true,\n\t},\n\t/* Final state before CPU kills itself */\n\t[CPUHP_AP_IDLE_DEAD] = {\n\t\t.name\t\t\t= \"idle:dead\",\n\t},\n\t/*\n\t * Last state before CPU enters the idle loop to die. Transient state\n\t * for synchronization.\n\t */\n\t[CPUHP_AP_OFFLINE] = {\n\t\t.name\t\t\t= \"ap:offline\",\n\t\t.cant_stop\t\t= true,\n\t},\n\t/* First state is scheduler control. Interrupts are disabled */\n\t[CPUHP_AP_SCHED_STARTING] = {\n\t\t.name\t\t\t= \"sched:starting\",\n\t\t.startup.single\t\t= sched_cpu_starting,\n\t\t.teardown.single\t= sched_cpu_dying,\n\t},\n\t[CPUHP_AP_RCUTREE_DYING] = {\n\t\t.name\t\t\t= \"RCU/tree:dying\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= rcutree_dying_cpu,\n\t},\n\t[CPUHP_AP_SMPCFD_DYING] = {\n\t\t.name\t\t\t= \"smpcfd:dying\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= smpcfd_dying_cpu,\n\t},\n\t/* Entry state on starting. Interrupts enabled from here on. Transient\n\t * state for synchronsization */\n\t[CPUHP_AP_ONLINE] = {\n\t\t.name\t\t\t= \"ap:online\",\n\t},\n\t/*\n\t * Handled on control processor until the plugged processor manages\n\t * this itself.\n\t */\n\t[CPUHP_TEARDOWN_CPU] = {\n\t\t.name\t\t\t= \"cpu:teardown\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= takedown_cpu,\n\t\t.cant_stop\t\t= true,\n\t},\n\n\t[CPUHP_AP_SCHED_WAIT_EMPTY] = {\n\t\t.name\t\t\t= \"sched:waitempty\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= sched_cpu_wait_empty,\n\t},\n\n\t/* Handle smpboot threads park/unpark */\n\t[CPUHP_AP_SMPBOOT_THREADS] = {\n\t\t.name\t\t\t= \"smpboot/threads:online\",\n\t\t.startup.single\t\t= smpboot_unpark_threads,\n\t\t.teardown.single\t= smpboot_park_threads,\n\t},\n\t[CPUHP_AP_IRQ_AFFINITY_ONLINE] = {\n\t\t.name\t\t\t= \"irq/affinity:online\",\n\t\t.startup.single\t\t= irq_affinity_online_cpu,\n\t\t.teardown.single\t= NULL,\n\t},\n\t[CPUHP_AP_PERF_ONLINE] = {\n\t\t.name\t\t\t= \"perf:online\",\n\t\t.startup.single\t\t= perf_event_init_cpu,\n\t\t.teardown.single\t= perf_event_exit_cpu,\n\t},\n\t[CPUHP_AP_WATCHDOG_ONLINE] = {\n\t\t.name\t\t\t= \"lockup_detector:online\",\n\t\t.startup.single\t\t= lockup_detector_online_cpu,\n\t\t.teardown.single\t= lockup_detector_offline_cpu,\n\t},\n\t[CPUHP_AP_WORKQUEUE_ONLINE] = {\n\t\t.name\t\t\t= \"workqueue:online\",\n\t\t.startup.single\t\t= workqueue_online_cpu,\n\t\t.teardown.single\t= workqueue_offline_cpu,\n\t},\n\t[CPUHP_AP_RCUTREE_ONLINE] = {\n\t\t.name\t\t\t= \"RCU/tree:online\",\n\t\t.startup.single\t\t= rcutree_online_cpu,\n\t\t.teardown.single\t= rcutree_offline_cpu,\n\t},\n#endif\n\t/*\n\t * The dynamically registered state space is here\n\t */\n\n#ifdef CONFIG_SMP\n\t/* Last state is scheduler control setting the cpu active */\n\t[CPUHP_AP_ACTIVE] = {\n\t\t.name\t\t\t= \"sched:active\",\n\t\t.startup.single\t\t= sched_cpu_activate,\n\t\t.teardown.single\t= sched_cpu_deactivate,\n\t},\n#endif\n\n\t/* CPU is fully up and running. */\n\t[CPUHP_ONLINE] = {\n\t\t.name\t\t\t= \"online\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= NULL,\n\t},\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\nstatic struct cpuhp_step cpuhp_hp_states[];\nstatic struct cpuhp_step cpuhp_hp_states[] = {\n\t[CPUHP_OFFLINE] = {\n\t\t.name\t\t\t= \"offline\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= NULL,\n\t},\n#ifdef CONFIG_SMP\n\t[CPUHP_CREATE_THREADS]= {\n\t\t.name\t\t\t= \"threads:prepare\",\n\t\t.startup.single\t\t= smpboot_create_threads,\n\t\t.teardown.single\t= NULL,\n\t\t.cant_stop\t\t= true,\n\t},\n\t[CPUHP_PERF_PREPARE] = {\n\t\t.name\t\t\t= \"perf:prepare\",\n\t\t.startup.single\t\t= perf_event_init_cpu,\n\t\t.teardown.single\t= perf_event_exit_cpu,\n\t},\n\t[CPUHP_WORKQUEUE_PREP] = {\n\t\t.name\t\t\t= \"workqueue:prepare\",\n\t\t.startup.single\t\t= workqueue_prepare_cpu,\n\t\t.teardown.single\t= NULL,\n\t},\n\t[CPUHP_HRTIMERS_PREPARE] = {\n\t\t.name\t\t\t= \"hrtimers:prepare\",\n\t\t.startup.single\t\t= hrtimers_prepare_cpu,\n\t\t.teardown.single\t= hrtimers_dead_cpu,\n\t},\n\t[CPUHP_SMPCFD_PREPARE] = {\n\t\t.name\t\t\t= \"smpcfd:prepare\",\n\t\t.startup.single\t\t= smpcfd_prepare_cpu,\n\t\t.teardown.single\t= smpcfd_dead_cpu,\n\t},\n\t[CPUHP_RELAY_PREPARE] = {\n\t\t.name\t\t\t= \"relay:prepare\",\n\t\t.startup.single\t\t= relay_prepare_cpu,\n\t\t.teardown.single\t= NULL,\n\t},\n\t[CPUHP_SLAB_PREPARE] = {\n\t\t.name\t\t\t= \"slab:prepare\",\n\t\t.startup.single\t\t= slab_prepare_cpu,\n\t\t.teardown.single\t= slab_dead_cpu,\n\t},\n\t[CPUHP_RCUTREE_PREP] = {\n\t\t.name\t\t\t= \"RCU/tree:prepare\",\n\t\t.startup.single\t\t= rcutree_prepare_cpu,\n\t\t.teardown.single\t= rcutree_dead_cpu,\n\t},\n\t/*\n\t * On the tear-down path, timers_dead_cpu() must be invoked\n\t * before blk_mq_queue_reinit_notify() from notify_dead(),\n\t * otherwise a RCU stall occurs.\n\t */\n\t[CPUHP_TIMERS_PREPARE] = {\n\t\t.name\t\t\t= \"timers:prepare\",\n\t\t.startup.single\t\t= timers_prepare_cpu,\n\t\t.teardown.single\t= timers_dead_cpu,\n\t},\n\t/* Kicks the plugged cpu into life */\n\t[CPUHP_BRINGUP_CPU] = {\n\t\t.name\t\t\t= \"cpu:bringup\",\n\t\t.startup.single\t\t= bringup_cpu,\n\t\t.teardown.single\t= finish_cpu,\n\t\t.cant_stop\t\t= true,\n\t},\n\t/* Final state before CPU kills itself */\n\t[CPUHP_AP_IDLE_DEAD] = {\n\t\t.name\t\t\t= \"idle:dead\",\n\t},\n\t/*\n\t * Last state before CPU enters the idle loop to die. Transient state\n\t * for synchronization.\n\t */\n\t[CPUHP_AP_OFFLINE] = {\n\t\t.name\t\t\t= \"ap:offline\",\n\t\t.cant_stop\t\t= true,\n\t},\n\t/* First state is scheduler control. Interrupts are disabled */\n\t[CPUHP_AP_SCHED_STARTING] = {\n\t\t.name\t\t\t= \"sched:starting\",\n\t\t.startup.single\t\t= sched_cpu_starting,\n\t\t.teardown.single\t= sched_cpu_dying,\n\t},\n\t[CPUHP_AP_RCUTREE_DYING] = {\n\t\t.name\t\t\t= \"RCU/tree:dying\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= rcutree_dying_cpu,\n\t},\n\t[CPUHP_AP_SMPCFD_DYING] = {\n\t\t.name\t\t\t= \"smpcfd:dying\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= smpcfd_dying_cpu,\n\t},\n\t/* Entry state on starting. Interrupts enabled from here on. Transient\n\t * state for synchronsization */\n\t[CPUHP_AP_ONLINE] = {\n\t\t.name\t\t\t= \"ap:online\",\n\t},\n\t/*\n\t * Handled on control processor until the plugged processor manages\n\t * this itself.\n\t */\n\t[CPUHP_TEARDOWN_CPU] = {\n\t\t.name\t\t\t= \"cpu:teardown\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= takedown_cpu,\n\t\t.cant_stop\t\t= true,\n\t},\n\n\t[CPUHP_AP_SCHED_WAIT_EMPTY] = {\n\t\t.name\t\t\t= \"sched:waitempty\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= sched_cpu_wait_empty,\n\t},\n\n\t/* Handle smpboot threads park/unpark */\n\t[CPUHP_AP_SMPBOOT_THREADS] = {\n\t\t.name\t\t\t= \"smpboot/threads:online\",\n\t\t.startup.single\t\t= smpboot_unpark_threads,\n\t\t.teardown.single\t= smpboot_park_threads,\n\t},\n\t[CPUHP_AP_IRQ_AFFINITY_ONLINE] = {\n\t\t.name\t\t\t= \"irq/affinity:online\",\n\t\t.startup.single\t\t= irq_affinity_online_cpu,\n\t\t.teardown.single\t= NULL,\n\t},\n\t[CPUHP_AP_PERF_ONLINE] = {\n\t\t.name\t\t\t= \"perf:online\",\n\t\t.startup.single\t\t= perf_event_init_cpu,\n\t\t.teardown.single\t= perf_event_exit_cpu,\n\t},\n\t[CPUHP_AP_WATCHDOG_ONLINE] = {\n\t\t.name\t\t\t= \"lockup_detector:online\",\n\t\t.startup.single\t\t= lockup_detector_online_cpu,\n\t\t.teardown.single\t= lockup_detector_offline_cpu,\n\t},\n\t[CPUHP_AP_WORKQUEUE_ONLINE] = {\n\t\t.name\t\t\t= \"workqueue:online\",\n\t\t.startup.single\t\t= workqueue_online_cpu,\n\t\t.teardown.single\t= workqueue_offline_cpu,\n\t},\n\t[CPUHP_AP_RCUTREE_ONLINE] = {\n\t\t.name\t\t\t= \"RCU/tree:online\",\n\t\t.startup.single\t\t= rcutree_online_cpu,\n\t\t.teardown.single\t= rcutree_offline_cpu,\n\t},\n#endif\n\t/*\n\t * The dynamically registered state space is here\n\t */\n\n#ifdef CONFIG_SMP\n\t/* Last state is scheduler control setting the cpu active */\n\t[CPUHP_AP_ACTIVE] = {\n\t\t.name\t\t\t= \"sched:active\",\n\t\t.startup.single\t\t= sched_cpu_activate,\n\t\t.teardown.single\t= sched_cpu_deactivate,\n\t},\n#endif\n\n\t/* CPU is fully up and running. */\n\t[CPUHP_ONLINE] = {\n\t\t.name\t\t\t= \"online\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= NULL,\n\t},\n};\n\nstatic struct cpuhp_step *cpuhp_get_step(enum cpuhp_state state)\n{\n\treturn cpuhp_hp_states + state;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&cpuhp_state_mutex"
          ],
          "line": 2402
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstatic DEFINE_MUTEX(cpuhp_state_mutex);\n\nstatic ssize_t states_show(struct device *dev,\n\t\t\t\t struct device_attribute *attr, char *buf)\n{\n\tssize_t cur, res = 0;\n\tint i;\n\n\tmutex_lock(&cpuhp_state_mutex);\n\tfor (i = CPUHP_OFFLINE; i <= CPUHP_ONLINE; i++) {\n\t\tstruct cpuhp_step *sp = cpuhp_get_step(i);\n\n\t\tif (sp->name) {\n\t\t\tcur = sprintf(buf, \"%3d: %s\\n\", i, sp->name);\n\t\t\tbuf += cur;\n\t\t\tres += cur;\n\t\t}\n\t}\n\tmutex_unlock(&cpuhp_state_mutex);\n\treturn res;\n}"
  },
  {
    "function_name": "fail_show",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
    "lines": "2373-2379",
    "snippet": "static ssize_t fail_show(struct device *dev,\n\t\t\t struct device_attribute *attr, char *buf)\n{\n\tstruct cpuhp_cpu_state *st = per_cpu_ptr(&cpuhp_state, dev->id);\n\n\treturn sprintf(buf, \"%d\\n\", st->fail);\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/scs.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sched/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"%d\\n\"",
            "st->fail"
          ],
          "line": 2378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "&cpuhp_state",
            "dev->id"
          ],
          "line": 2376
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\n\nstatic ssize_t fail_show(struct device *dev,\n\t\t\t struct device_attribute *attr, char *buf)\n{\n\tstruct cpuhp_cpu_state *st = per_cpu_ptr(&cpuhp_state, dev->id);\n\n\treturn sprintf(buf, \"%d\\n\", st->fail);\n}"
  },
  {
    "function_name": "fail_store",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
    "lines": "2323-2371",
    "snippet": "static ssize_t fail_store(struct device *dev, struct device_attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct cpuhp_cpu_state *st = per_cpu_ptr(&cpuhp_state, dev->id);\n\tstruct cpuhp_step *sp;\n\tint fail, ret;\n\n\tret = kstrtoint(buf, 10, &fail);\n\tif (ret)\n\t\treturn ret;\n\n\tif (fail == CPUHP_INVALID) {\n\t\tst->fail = fail;\n\t\treturn count;\n\t}\n\n\tif (fail < CPUHP_OFFLINE || fail > CPUHP_ONLINE)\n\t\treturn -EINVAL;\n\n\t/*\n\t * Cannot fail STARTING/DYING callbacks.\n\t */\n\tif (cpuhp_is_atomic_state(fail))\n\t\treturn -EINVAL;\n\n\t/*\n\t * DEAD callbacks cannot fail...\n\t * ... neither can CPUHP_BRINGUP_CPU during hotunplug. The latter\n\t * triggering STARTING callbacks, a failure in this state would\n\t * hinder rollback.\n\t */\n\tif (fail <= CPUHP_BRINGUP_CPU && st->state > CPUHP_BRINGUP_CPU)\n\t\treturn -EINVAL;\n\n\t/*\n\t * Cannot fail anything that doesn't have callbacks.\n\t */\n\tmutex_lock(&cpuhp_state_mutex);\n\tsp = cpuhp_get_step(fail);\n\tif (!sp->startup.single && !sp->teardown.single)\n\t\tret = -EINVAL;\n\tmutex_unlock(&cpuhp_state_mutex);\n\tif (ret)\n\t\treturn ret;\n\n\tst->fail = fail;\n\n\treturn count;\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/scs.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sched/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};",
      "static DEFINE_MUTEX(cpuhp_state_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&cpuhp_state_mutex"
          ],
          "line": 2364
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpuhp_get_step",
          "args": [
            "fail"
          ],
          "line": 2361
        },
        "resolved": true,
        "details": {
          "function_name": "cpuhp_get_step",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "144-147",
          "snippet": "static struct cpuhp_step *cpuhp_get_step(enum cpuhp_state state)\n{\n\treturn cpuhp_hp_states + state;\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};",
            "static struct cpuhp_step cpuhp_hp_states[];",
            "static struct cpuhp_step cpuhp_hp_states[] = {\n\t[CPUHP_OFFLINE] = {\n\t\t.name\t\t\t= \"offline\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= NULL,\n\t},\n#ifdef CONFIG_SMP\n\t[CPUHP_CREATE_THREADS]= {\n\t\t.name\t\t\t= \"threads:prepare\",\n\t\t.startup.single\t\t= smpboot_create_threads,\n\t\t.teardown.single\t= NULL,\n\t\t.cant_stop\t\t= true,\n\t},\n\t[CPUHP_PERF_PREPARE] = {\n\t\t.name\t\t\t= \"perf:prepare\",\n\t\t.startup.single\t\t= perf_event_init_cpu,\n\t\t.teardown.single\t= perf_event_exit_cpu,\n\t},\n\t[CPUHP_WORKQUEUE_PREP] = {\n\t\t.name\t\t\t= \"workqueue:prepare\",\n\t\t.startup.single\t\t= workqueue_prepare_cpu,\n\t\t.teardown.single\t= NULL,\n\t},\n\t[CPUHP_HRTIMERS_PREPARE] = {\n\t\t.name\t\t\t= \"hrtimers:prepare\",\n\t\t.startup.single\t\t= hrtimers_prepare_cpu,\n\t\t.teardown.single\t= hrtimers_dead_cpu,\n\t},\n\t[CPUHP_SMPCFD_PREPARE] = {\n\t\t.name\t\t\t= \"smpcfd:prepare\",\n\t\t.startup.single\t\t= smpcfd_prepare_cpu,\n\t\t.teardown.single\t= smpcfd_dead_cpu,\n\t},\n\t[CPUHP_RELAY_PREPARE] = {\n\t\t.name\t\t\t= \"relay:prepare\",\n\t\t.startup.single\t\t= relay_prepare_cpu,\n\t\t.teardown.single\t= NULL,\n\t},\n\t[CPUHP_SLAB_PREPARE] = {\n\t\t.name\t\t\t= \"slab:prepare\",\n\t\t.startup.single\t\t= slab_prepare_cpu,\n\t\t.teardown.single\t= slab_dead_cpu,\n\t},\n\t[CPUHP_RCUTREE_PREP] = {\n\t\t.name\t\t\t= \"RCU/tree:prepare\",\n\t\t.startup.single\t\t= rcutree_prepare_cpu,\n\t\t.teardown.single\t= rcutree_dead_cpu,\n\t},\n\t/*\n\t * On the tear-down path, timers_dead_cpu() must be invoked\n\t * before blk_mq_queue_reinit_notify() from notify_dead(),\n\t * otherwise a RCU stall occurs.\n\t */\n\t[CPUHP_TIMERS_PREPARE] = {\n\t\t.name\t\t\t= \"timers:prepare\",\n\t\t.startup.single\t\t= timers_prepare_cpu,\n\t\t.teardown.single\t= timers_dead_cpu,\n\t},\n\t/* Kicks the plugged cpu into life */\n\t[CPUHP_BRINGUP_CPU] = {\n\t\t.name\t\t\t= \"cpu:bringup\",\n\t\t.startup.single\t\t= bringup_cpu,\n\t\t.teardown.single\t= finish_cpu,\n\t\t.cant_stop\t\t= true,\n\t},\n\t/* Final state before CPU kills itself */\n\t[CPUHP_AP_IDLE_DEAD] = {\n\t\t.name\t\t\t= \"idle:dead\",\n\t},\n\t/*\n\t * Last state before CPU enters the idle loop to die. Transient state\n\t * for synchronization.\n\t */\n\t[CPUHP_AP_OFFLINE] = {\n\t\t.name\t\t\t= \"ap:offline\",\n\t\t.cant_stop\t\t= true,\n\t},\n\t/* First state is scheduler control. Interrupts are disabled */\n\t[CPUHP_AP_SCHED_STARTING] = {\n\t\t.name\t\t\t= \"sched:starting\",\n\t\t.startup.single\t\t= sched_cpu_starting,\n\t\t.teardown.single\t= sched_cpu_dying,\n\t},\n\t[CPUHP_AP_RCUTREE_DYING] = {\n\t\t.name\t\t\t= \"RCU/tree:dying\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= rcutree_dying_cpu,\n\t},\n\t[CPUHP_AP_SMPCFD_DYING] = {\n\t\t.name\t\t\t= \"smpcfd:dying\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= smpcfd_dying_cpu,\n\t},\n\t/* Entry state on starting. Interrupts enabled from here on. Transient\n\t * state for synchronsization */\n\t[CPUHP_AP_ONLINE] = {\n\t\t.name\t\t\t= \"ap:online\",\n\t},\n\t/*\n\t * Handled on control processor until the plugged processor manages\n\t * this itself.\n\t */\n\t[CPUHP_TEARDOWN_CPU] = {\n\t\t.name\t\t\t= \"cpu:teardown\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= takedown_cpu,\n\t\t.cant_stop\t\t= true,\n\t},\n\n\t[CPUHP_AP_SCHED_WAIT_EMPTY] = {\n\t\t.name\t\t\t= \"sched:waitempty\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= sched_cpu_wait_empty,\n\t},\n\n\t/* Handle smpboot threads park/unpark */\n\t[CPUHP_AP_SMPBOOT_THREADS] = {\n\t\t.name\t\t\t= \"smpboot/threads:online\",\n\t\t.startup.single\t\t= smpboot_unpark_threads,\n\t\t.teardown.single\t= smpboot_park_threads,\n\t},\n\t[CPUHP_AP_IRQ_AFFINITY_ONLINE] = {\n\t\t.name\t\t\t= \"irq/affinity:online\",\n\t\t.startup.single\t\t= irq_affinity_online_cpu,\n\t\t.teardown.single\t= NULL,\n\t},\n\t[CPUHP_AP_PERF_ONLINE] = {\n\t\t.name\t\t\t= \"perf:online\",\n\t\t.startup.single\t\t= perf_event_init_cpu,\n\t\t.teardown.single\t= perf_event_exit_cpu,\n\t},\n\t[CPUHP_AP_WATCHDOG_ONLINE] = {\n\t\t.name\t\t\t= \"lockup_detector:online\",\n\t\t.startup.single\t\t= lockup_detector_online_cpu,\n\t\t.teardown.single\t= lockup_detector_offline_cpu,\n\t},\n\t[CPUHP_AP_WORKQUEUE_ONLINE] = {\n\t\t.name\t\t\t= \"workqueue:online\",\n\t\t.startup.single\t\t= workqueue_online_cpu,\n\t\t.teardown.single\t= workqueue_offline_cpu,\n\t},\n\t[CPUHP_AP_RCUTREE_ONLINE] = {\n\t\t.name\t\t\t= \"RCU/tree:online\",\n\t\t.startup.single\t\t= rcutree_online_cpu,\n\t\t.teardown.single\t= rcutree_offline_cpu,\n\t},\n#endif\n\t/*\n\t * The dynamically registered state space is here\n\t */\n\n#ifdef CONFIG_SMP\n\t/* Last state is scheduler control setting the cpu active */\n\t[CPUHP_AP_ACTIVE] = {\n\t\t.name\t\t\t= \"sched:active\",\n\t\t.startup.single\t\t= sched_cpu_activate,\n\t\t.teardown.single\t= sched_cpu_deactivate,\n\t},\n#endif\n\n\t/* CPU is fully up and running. */\n\t[CPUHP_ONLINE] = {\n\t\t.name\t\t\t= \"online\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= NULL,\n\t},\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\nstatic struct cpuhp_step cpuhp_hp_states[];\nstatic struct cpuhp_step cpuhp_hp_states[] = {\n\t[CPUHP_OFFLINE] = {\n\t\t.name\t\t\t= \"offline\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= NULL,\n\t},\n#ifdef CONFIG_SMP\n\t[CPUHP_CREATE_THREADS]= {\n\t\t.name\t\t\t= \"threads:prepare\",\n\t\t.startup.single\t\t= smpboot_create_threads,\n\t\t.teardown.single\t= NULL,\n\t\t.cant_stop\t\t= true,\n\t},\n\t[CPUHP_PERF_PREPARE] = {\n\t\t.name\t\t\t= \"perf:prepare\",\n\t\t.startup.single\t\t= perf_event_init_cpu,\n\t\t.teardown.single\t= perf_event_exit_cpu,\n\t},\n\t[CPUHP_WORKQUEUE_PREP] = {\n\t\t.name\t\t\t= \"workqueue:prepare\",\n\t\t.startup.single\t\t= workqueue_prepare_cpu,\n\t\t.teardown.single\t= NULL,\n\t},\n\t[CPUHP_HRTIMERS_PREPARE] = {\n\t\t.name\t\t\t= \"hrtimers:prepare\",\n\t\t.startup.single\t\t= hrtimers_prepare_cpu,\n\t\t.teardown.single\t= hrtimers_dead_cpu,\n\t},\n\t[CPUHP_SMPCFD_PREPARE] = {\n\t\t.name\t\t\t= \"smpcfd:prepare\",\n\t\t.startup.single\t\t= smpcfd_prepare_cpu,\n\t\t.teardown.single\t= smpcfd_dead_cpu,\n\t},\n\t[CPUHP_RELAY_PREPARE] = {\n\t\t.name\t\t\t= \"relay:prepare\",\n\t\t.startup.single\t\t= relay_prepare_cpu,\n\t\t.teardown.single\t= NULL,\n\t},\n\t[CPUHP_SLAB_PREPARE] = {\n\t\t.name\t\t\t= \"slab:prepare\",\n\t\t.startup.single\t\t= slab_prepare_cpu,\n\t\t.teardown.single\t= slab_dead_cpu,\n\t},\n\t[CPUHP_RCUTREE_PREP] = {\n\t\t.name\t\t\t= \"RCU/tree:prepare\",\n\t\t.startup.single\t\t= rcutree_prepare_cpu,\n\t\t.teardown.single\t= rcutree_dead_cpu,\n\t},\n\t/*\n\t * On the tear-down path, timers_dead_cpu() must be invoked\n\t * before blk_mq_queue_reinit_notify() from notify_dead(),\n\t * otherwise a RCU stall occurs.\n\t */\n\t[CPUHP_TIMERS_PREPARE] = {\n\t\t.name\t\t\t= \"timers:prepare\",\n\t\t.startup.single\t\t= timers_prepare_cpu,\n\t\t.teardown.single\t= timers_dead_cpu,\n\t},\n\t/* Kicks the plugged cpu into life */\n\t[CPUHP_BRINGUP_CPU] = {\n\t\t.name\t\t\t= \"cpu:bringup\",\n\t\t.startup.single\t\t= bringup_cpu,\n\t\t.teardown.single\t= finish_cpu,\n\t\t.cant_stop\t\t= true,\n\t},\n\t/* Final state before CPU kills itself */\n\t[CPUHP_AP_IDLE_DEAD] = {\n\t\t.name\t\t\t= \"idle:dead\",\n\t},\n\t/*\n\t * Last state before CPU enters the idle loop to die. Transient state\n\t * for synchronization.\n\t */\n\t[CPUHP_AP_OFFLINE] = {\n\t\t.name\t\t\t= \"ap:offline\",\n\t\t.cant_stop\t\t= true,\n\t},\n\t/* First state is scheduler control. Interrupts are disabled */\n\t[CPUHP_AP_SCHED_STARTING] = {\n\t\t.name\t\t\t= \"sched:starting\",\n\t\t.startup.single\t\t= sched_cpu_starting,\n\t\t.teardown.single\t= sched_cpu_dying,\n\t},\n\t[CPUHP_AP_RCUTREE_DYING] = {\n\t\t.name\t\t\t= \"RCU/tree:dying\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= rcutree_dying_cpu,\n\t},\n\t[CPUHP_AP_SMPCFD_DYING] = {\n\t\t.name\t\t\t= \"smpcfd:dying\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= smpcfd_dying_cpu,\n\t},\n\t/* Entry state on starting. Interrupts enabled from here on. Transient\n\t * state for synchronsization */\n\t[CPUHP_AP_ONLINE] = {\n\t\t.name\t\t\t= \"ap:online\",\n\t},\n\t/*\n\t * Handled on control processor until the plugged processor manages\n\t * this itself.\n\t */\n\t[CPUHP_TEARDOWN_CPU] = {\n\t\t.name\t\t\t= \"cpu:teardown\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= takedown_cpu,\n\t\t.cant_stop\t\t= true,\n\t},\n\n\t[CPUHP_AP_SCHED_WAIT_EMPTY] = {\n\t\t.name\t\t\t= \"sched:waitempty\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= sched_cpu_wait_empty,\n\t},\n\n\t/* Handle smpboot threads park/unpark */\n\t[CPUHP_AP_SMPBOOT_THREADS] = {\n\t\t.name\t\t\t= \"smpboot/threads:online\",\n\t\t.startup.single\t\t= smpboot_unpark_threads,\n\t\t.teardown.single\t= smpboot_park_threads,\n\t},\n\t[CPUHP_AP_IRQ_AFFINITY_ONLINE] = {\n\t\t.name\t\t\t= \"irq/affinity:online\",\n\t\t.startup.single\t\t= irq_affinity_online_cpu,\n\t\t.teardown.single\t= NULL,\n\t},\n\t[CPUHP_AP_PERF_ONLINE] = {\n\t\t.name\t\t\t= \"perf:online\",\n\t\t.startup.single\t\t= perf_event_init_cpu,\n\t\t.teardown.single\t= perf_event_exit_cpu,\n\t},\n\t[CPUHP_AP_WATCHDOG_ONLINE] = {\n\t\t.name\t\t\t= \"lockup_detector:online\",\n\t\t.startup.single\t\t= lockup_detector_online_cpu,\n\t\t.teardown.single\t= lockup_detector_offline_cpu,\n\t},\n\t[CPUHP_AP_WORKQUEUE_ONLINE] = {\n\t\t.name\t\t\t= \"workqueue:online\",\n\t\t.startup.single\t\t= workqueue_online_cpu,\n\t\t.teardown.single\t= workqueue_offline_cpu,\n\t},\n\t[CPUHP_AP_RCUTREE_ONLINE] = {\n\t\t.name\t\t\t= \"RCU/tree:online\",\n\t\t.startup.single\t\t= rcutree_online_cpu,\n\t\t.teardown.single\t= rcutree_offline_cpu,\n\t},\n#endif\n\t/*\n\t * The dynamically registered state space is here\n\t */\n\n#ifdef CONFIG_SMP\n\t/* Last state is scheduler control setting the cpu active */\n\t[CPUHP_AP_ACTIVE] = {\n\t\t.name\t\t\t= \"sched:active\",\n\t\t.startup.single\t\t= sched_cpu_activate,\n\t\t.teardown.single\t= sched_cpu_deactivate,\n\t},\n#endif\n\n\t/* CPU is fully up and running. */\n\t[CPUHP_ONLINE] = {\n\t\t.name\t\t\t= \"online\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= NULL,\n\t},\n};\n\nstatic struct cpuhp_step *cpuhp_get_step(enum cpuhp_state state)\n{\n\treturn cpuhp_hp_states + state;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&cpuhp_state_mutex"
          ],
          "line": 2360
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpuhp_is_atomic_state",
          "args": [
            "fail"
          ],
          "line": 2345
        },
        "resolved": true,
        "details": {
          "function_name": "cpuhp_is_atomic_state",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "273-276",
          "snippet": "static bool cpuhp_is_atomic_state(enum cpuhp_state state)\n{\n\treturn CPUHP_AP_IDLE_DEAD <= state && state < CPUHP_AP_ONLINE;\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\n\nstatic bool cpuhp_is_atomic_state(enum cpuhp_state state)\n{\n\treturn CPUHP_AP_IDLE_DEAD <= state && state < CPUHP_AP_ONLINE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kstrtoint",
          "args": [
            "buf",
            "10",
            "&fail"
          ],
          "line": 2330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "&cpuhp_state",
            "dev->id"
          ],
          "line": 2326
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\nstatic DEFINE_MUTEX(cpuhp_state_mutex);\n\nstatic ssize_t fail_store(struct device *dev, struct device_attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct cpuhp_cpu_state *st = per_cpu_ptr(&cpuhp_state, dev->id);\n\tstruct cpuhp_step *sp;\n\tint fail, ret;\n\n\tret = kstrtoint(buf, 10, &fail);\n\tif (ret)\n\t\treturn ret;\n\n\tif (fail == CPUHP_INVALID) {\n\t\tst->fail = fail;\n\t\treturn count;\n\t}\n\n\tif (fail < CPUHP_OFFLINE || fail > CPUHP_ONLINE)\n\t\treturn -EINVAL;\n\n\t/*\n\t * Cannot fail STARTING/DYING callbacks.\n\t */\n\tif (cpuhp_is_atomic_state(fail))\n\t\treturn -EINVAL;\n\n\t/*\n\t * DEAD callbacks cannot fail...\n\t * ... neither can CPUHP_BRINGUP_CPU during hotunplug. The latter\n\t * triggering STARTING callbacks, a failure in this state would\n\t * hinder rollback.\n\t */\n\tif (fail <= CPUHP_BRINGUP_CPU && st->state > CPUHP_BRINGUP_CPU)\n\t\treturn -EINVAL;\n\n\t/*\n\t * Cannot fail anything that doesn't have callbacks.\n\t */\n\tmutex_lock(&cpuhp_state_mutex);\n\tsp = cpuhp_get_step(fail);\n\tif (!sp->startup.single && !sp->teardown.single)\n\t\tret = -EINVAL;\n\tmutex_unlock(&cpuhp_state_mutex);\n\tif (ret)\n\t\treturn ret;\n\n\tst->fail = fail;\n\n\treturn count;\n}"
  },
  {
    "function_name": "target_show",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
    "lines": "2314-2320",
    "snippet": "static ssize_t target_show(struct device *dev,\n\t\t\t   struct device_attribute *attr, char *buf)\n{\n\tstruct cpuhp_cpu_state *st = per_cpu_ptr(&cpuhp_state, dev->id);\n\n\treturn sprintf(buf, \"%d\\n\", st->target);\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/scs.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sched/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"%d\\n\"",
            "st->target"
          ],
          "line": 2319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "&cpuhp_state",
            "dev->id"
          ],
          "line": 2317
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\n\nstatic ssize_t target_show(struct device *dev,\n\t\t\t   struct device_attribute *attr, char *buf)\n{\n\tstruct cpuhp_cpu_state *st = per_cpu_ptr(&cpuhp_state, dev->id);\n\n\treturn sprintf(buf, \"%d\\n\", st->target);\n}"
  },
  {
    "function_name": "target_store",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
    "lines": "2275-2312",
    "snippet": "static ssize_t target_store(struct device *dev, struct device_attribute *attr,\n\t\t\t    const char *buf, size_t count)\n{\n\tstruct cpuhp_cpu_state *st = per_cpu_ptr(&cpuhp_state, dev->id);\n\tstruct cpuhp_step *sp;\n\tint target, ret;\n\n\tret = kstrtoint(buf, 10, &target);\n\tif (ret)\n\t\treturn ret;\n\n#ifdef CONFIG_CPU_HOTPLUG_STATE_CONTROL\n\tif (target < CPUHP_OFFLINE || target > CPUHP_ONLINE)\n\t\treturn -EINVAL;\n#else\n\tif (target != CPUHP_OFFLINE && target != CPUHP_ONLINE)\n\t\treturn -EINVAL;\n#endif\n\n\tret = lock_device_hotplug_sysfs();\n\tif (ret)\n\t\treturn ret;\n\n\tmutex_lock(&cpuhp_state_mutex);\n\tsp = cpuhp_get_step(target);\n\tret = !sp->name || sp->cant_stop ? -EINVAL : 0;\n\tmutex_unlock(&cpuhp_state_mutex);\n\tif (ret)\n\t\tgoto out;\n\n\tif (st->state < target)\n\t\tret = cpu_up(dev->id, target);\n\telse\n\t\tret = cpu_down(dev->id, target);\nout:\n\tunlock_device_hotplug();\n\treturn ret ? ret : count;\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/scs.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sched/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};",
      "static DEFINE_MUTEX(cpuhp_state_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_device_hotplug",
          "args": [],
          "line": 2310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_down",
          "args": [
            "dev->id",
            "target"
          ],
          "line": 2308
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_down",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "1193-1201",
          "snippet": "static int cpu_down(unsigned int cpu, enum cpuhp_state target)\n{\n\tint err;\n\n\tcpu_maps_update_begin();\n\terr = cpu_down_maps_locked(cpu, target);\n\tcpu_maps_update_done();\n\treturn err;\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\n\nstatic int cpu_down(unsigned int cpu, enum cpuhp_state target)\n{\n\tint err;\n\n\tcpu_maps_update_begin();\n\terr = cpu_down_maps_locked(cpu, target);\n\tcpu_maps_update_done();\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_up",
          "args": [
            "dev->id",
            "target"
          ],
          "line": 2306
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_up",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "1383-1415",
          "snippet": "static int cpu_up(unsigned int cpu, enum cpuhp_state target)\n{\n\tint err = 0;\n\n\tif (!cpu_possible(cpu)) {\n\t\tpr_err(\"can't online cpu %d because it is not configured as may-hotadd at boot time\\n\",\n\t\t       cpu);\n#if defined(CONFIG_IA64)\n\t\tpr_err(\"please check additional_cpus= boot parameter\\n\");\n#endif\n\t\treturn -EINVAL;\n\t}\n\n\terr = try_online_node(cpu_to_node(cpu));\n\tif (err)\n\t\treturn err;\n\n\tcpu_maps_update_begin();\n\n\tif (cpu_hotplug_disabled) {\n\t\terr = -EBUSY;\n\t\tgoto out;\n\t}\n\tif (!cpu_smt_allowed(cpu)) {\n\t\terr = -EPERM;\n\t\tgoto out;\n\t}\n\n\terr = _cpu_up(cpu, 0, target);\nout:\n\tcpu_maps_update_done();\n\treturn err;\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\n\nstatic int cpu_up(unsigned int cpu, enum cpuhp_state target)\n{\n\tint err = 0;\n\n\tif (!cpu_possible(cpu)) {\n\t\tpr_err(\"can't online cpu %d because it is not configured as may-hotadd at boot time\\n\",\n\t\t       cpu);\n#if defined(CONFIG_IA64)\n\t\tpr_err(\"please check additional_cpus= boot parameter\\n\");\n#endif\n\t\treturn -EINVAL;\n\t}\n\n\terr = try_online_node(cpu_to_node(cpu));\n\tif (err)\n\t\treturn err;\n\n\tcpu_maps_update_begin();\n\n\tif (cpu_hotplug_disabled) {\n\t\terr = -EBUSY;\n\t\tgoto out;\n\t}\n\tif (!cpu_smt_allowed(cpu)) {\n\t\terr = -EPERM;\n\t\tgoto out;\n\t}\n\n\terr = _cpu_up(cpu, 0, target);\nout:\n\tcpu_maps_update_done();\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&cpuhp_state_mutex"
          ],
          "line": 2301
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpuhp_get_step",
          "args": [
            "target"
          ],
          "line": 2299
        },
        "resolved": true,
        "details": {
          "function_name": "cpuhp_get_step",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "144-147",
          "snippet": "static struct cpuhp_step *cpuhp_get_step(enum cpuhp_state state)\n{\n\treturn cpuhp_hp_states + state;\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};",
            "static struct cpuhp_step cpuhp_hp_states[];",
            "static struct cpuhp_step cpuhp_hp_states[] = {\n\t[CPUHP_OFFLINE] = {\n\t\t.name\t\t\t= \"offline\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= NULL,\n\t},\n#ifdef CONFIG_SMP\n\t[CPUHP_CREATE_THREADS]= {\n\t\t.name\t\t\t= \"threads:prepare\",\n\t\t.startup.single\t\t= smpboot_create_threads,\n\t\t.teardown.single\t= NULL,\n\t\t.cant_stop\t\t= true,\n\t},\n\t[CPUHP_PERF_PREPARE] = {\n\t\t.name\t\t\t= \"perf:prepare\",\n\t\t.startup.single\t\t= perf_event_init_cpu,\n\t\t.teardown.single\t= perf_event_exit_cpu,\n\t},\n\t[CPUHP_WORKQUEUE_PREP] = {\n\t\t.name\t\t\t= \"workqueue:prepare\",\n\t\t.startup.single\t\t= workqueue_prepare_cpu,\n\t\t.teardown.single\t= NULL,\n\t},\n\t[CPUHP_HRTIMERS_PREPARE] = {\n\t\t.name\t\t\t= \"hrtimers:prepare\",\n\t\t.startup.single\t\t= hrtimers_prepare_cpu,\n\t\t.teardown.single\t= hrtimers_dead_cpu,\n\t},\n\t[CPUHP_SMPCFD_PREPARE] = {\n\t\t.name\t\t\t= \"smpcfd:prepare\",\n\t\t.startup.single\t\t= smpcfd_prepare_cpu,\n\t\t.teardown.single\t= smpcfd_dead_cpu,\n\t},\n\t[CPUHP_RELAY_PREPARE] = {\n\t\t.name\t\t\t= \"relay:prepare\",\n\t\t.startup.single\t\t= relay_prepare_cpu,\n\t\t.teardown.single\t= NULL,\n\t},\n\t[CPUHP_SLAB_PREPARE] = {\n\t\t.name\t\t\t= \"slab:prepare\",\n\t\t.startup.single\t\t= slab_prepare_cpu,\n\t\t.teardown.single\t= slab_dead_cpu,\n\t},\n\t[CPUHP_RCUTREE_PREP] = {\n\t\t.name\t\t\t= \"RCU/tree:prepare\",\n\t\t.startup.single\t\t= rcutree_prepare_cpu,\n\t\t.teardown.single\t= rcutree_dead_cpu,\n\t},\n\t/*\n\t * On the tear-down path, timers_dead_cpu() must be invoked\n\t * before blk_mq_queue_reinit_notify() from notify_dead(),\n\t * otherwise a RCU stall occurs.\n\t */\n\t[CPUHP_TIMERS_PREPARE] = {\n\t\t.name\t\t\t= \"timers:prepare\",\n\t\t.startup.single\t\t= timers_prepare_cpu,\n\t\t.teardown.single\t= timers_dead_cpu,\n\t},\n\t/* Kicks the plugged cpu into life */\n\t[CPUHP_BRINGUP_CPU] = {\n\t\t.name\t\t\t= \"cpu:bringup\",\n\t\t.startup.single\t\t= bringup_cpu,\n\t\t.teardown.single\t= finish_cpu,\n\t\t.cant_stop\t\t= true,\n\t},\n\t/* Final state before CPU kills itself */\n\t[CPUHP_AP_IDLE_DEAD] = {\n\t\t.name\t\t\t= \"idle:dead\",\n\t},\n\t/*\n\t * Last state before CPU enters the idle loop to die. Transient state\n\t * for synchronization.\n\t */\n\t[CPUHP_AP_OFFLINE] = {\n\t\t.name\t\t\t= \"ap:offline\",\n\t\t.cant_stop\t\t= true,\n\t},\n\t/* First state is scheduler control. Interrupts are disabled */\n\t[CPUHP_AP_SCHED_STARTING] = {\n\t\t.name\t\t\t= \"sched:starting\",\n\t\t.startup.single\t\t= sched_cpu_starting,\n\t\t.teardown.single\t= sched_cpu_dying,\n\t},\n\t[CPUHP_AP_RCUTREE_DYING] = {\n\t\t.name\t\t\t= \"RCU/tree:dying\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= rcutree_dying_cpu,\n\t},\n\t[CPUHP_AP_SMPCFD_DYING] = {\n\t\t.name\t\t\t= \"smpcfd:dying\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= smpcfd_dying_cpu,\n\t},\n\t/* Entry state on starting. Interrupts enabled from here on. Transient\n\t * state for synchronsization */\n\t[CPUHP_AP_ONLINE] = {\n\t\t.name\t\t\t= \"ap:online\",\n\t},\n\t/*\n\t * Handled on control processor until the plugged processor manages\n\t * this itself.\n\t */\n\t[CPUHP_TEARDOWN_CPU] = {\n\t\t.name\t\t\t= \"cpu:teardown\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= takedown_cpu,\n\t\t.cant_stop\t\t= true,\n\t},\n\n\t[CPUHP_AP_SCHED_WAIT_EMPTY] = {\n\t\t.name\t\t\t= \"sched:waitempty\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= sched_cpu_wait_empty,\n\t},\n\n\t/* Handle smpboot threads park/unpark */\n\t[CPUHP_AP_SMPBOOT_THREADS] = {\n\t\t.name\t\t\t= \"smpboot/threads:online\",\n\t\t.startup.single\t\t= smpboot_unpark_threads,\n\t\t.teardown.single\t= smpboot_park_threads,\n\t},\n\t[CPUHP_AP_IRQ_AFFINITY_ONLINE] = {\n\t\t.name\t\t\t= \"irq/affinity:online\",\n\t\t.startup.single\t\t= irq_affinity_online_cpu,\n\t\t.teardown.single\t= NULL,\n\t},\n\t[CPUHP_AP_PERF_ONLINE] = {\n\t\t.name\t\t\t= \"perf:online\",\n\t\t.startup.single\t\t= perf_event_init_cpu,\n\t\t.teardown.single\t= perf_event_exit_cpu,\n\t},\n\t[CPUHP_AP_WATCHDOG_ONLINE] = {\n\t\t.name\t\t\t= \"lockup_detector:online\",\n\t\t.startup.single\t\t= lockup_detector_online_cpu,\n\t\t.teardown.single\t= lockup_detector_offline_cpu,\n\t},\n\t[CPUHP_AP_WORKQUEUE_ONLINE] = {\n\t\t.name\t\t\t= \"workqueue:online\",\n\t\t.startup.single\t\t= workqueue_online_cpu,\n\t\t.teardown.single\t= workqueue_offline_cpu,\n\t},\n\t[CPUHP_AP_RCUTREE_ONLINE] = {\n\t\t.name\t\t\t= \"RCU/tree:online\",\n\t\t.startup.single\t\t= rcutree_online_cpu,\n\t\t.teardown.single\t= rcutree_offline_cpu,\n\t},\n#endif\n\t/*\n\t * The dynamically registered state space is here\n\t */\n\n#ifdef CONFIG_SMP\n\t/* Last state is scheduler control setting the cpu active */\n\t[CPUHP_AP_ACTIVE] = {\n\t\t.name\t\t\t= \"sched:active\",\n\t\t.startup.single\t\t= sched_cpu_activate,\n\t\t.teardown.single\t= sched_cpu_deactivate,\n\t},\n#endif\n\n\t/* CPU is fully up and running. */\n\t[CPUHP_ONLINE] = {\n\t\t.name\t\t\t= \"online\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= NULL,\n\t},\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\nstatic struct cpuhp_step cpuhp_hp_states[];\nstatic struct cpuhp_step cpuhp_hp_states[] = {\n\t[CPUHP_OFFLINE] = {\n\t\t.name\t\t\t= \"offline\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= NULL,\n\t},\n#ifdef CONFIG_SMP\n\t[CPUHP_CREATE_THREADS]= {\n\t\t.name\t\t\t= \"threads:prepare\",\n\t\t.startup.single\t\t= smpboot_create_threads,\n\t\t.teardown.single\t= NULL,\n\t\t.cant_stop\t\t= true,\n\t},\n\t[CPUHP_PERF_PREPARE] = {\n\t\t.name\t\t\t= \"perf:prepare\",\n\t\t.startup.single\t\t= perf_event_init_cpu,\n\t\t.teardown.single\t= perf_event_exit_cpu,\n\t},\n\t[CPUHP_WORKQUEUE_PREP] = {\n\t\t.name\t\t\t= \"workqueue:prepare\",\n\t\t.startup.single\t\t= workqueue_prepare_cpu,\n\t\t.teardown.single\t= NULL,\n\t},\n\t[CPUHP_HRTIMERS_PREPARE] = {\n\t\t.name\t\t\t= \"hrtimers:prepare\",\n\t\t.startup.single\t\t= hrtimers_prepare_cpu,\n\t\t.teardown.single\t= hrtimers_dead_cpu,\n\t},\n\t[CPUHP_SMPCFD_PREPARE] = {\n\t\t.name\t\t\t= \"smpcfd:prepare\",\n\t\t.startup.single\t\t= smpcfd_prepare_cpu,\n\t\t.teardown.single\t= smpcfd_dead_cpu,\n\t},\n\t[CPUHP_RELAY_PREPARE] = {\n\t\t.name\t\t\t= \"relay:prepare\",\n\t\t.startup.single\t\t= relay_prepare_cpu,\n\t\t.teardown.single\t= NULL,\n\t},\n\t[CPUHP_SLAB_PREPARE] = {\n\t\t.name\t\t\t= \"slab:prepare\",\n\t\t.startup.single\t\t= slab_prepare_cpu,\n\t\t.teardown.single\t= slab_dead_cpu,\n\t},\n\t[CPUHP_RCUTREE_PREP] = {\n\t\t.name\t\t\t= \"RCU/tree:prepare\",\n\t\t.startup.single\t\t= rcutree_prepare_cpu,\n\t\t.teardown.single\t= rcutree_dead_cpu,\n\t},\n\t/*\n\t * On the tear-down path, timers_dead_cpu() must be invoked\n\t * before blk_mq_queue_reinit_notify() from notify_dead(),\n\t * otherwise a RCU stall occurs.\n\t */\n\t[CPUHP_TIMERS_PREPARE] = {\n\t\t.name\t\t\t= \"timers:prepare\",\n\t\t.startup.single\t\t= timers_prepare_cpu,\n\t\t.teardown.single\t= timers_dead_cpu,\n\t},\n\t/* Kicks the plugged cpu into life */\n\t[CPUHP_BRINGUP_CPU] = {\n\t\t.name\t\t\t= \"cpu:bringup\",\n\t\t.startup.single\t\t= bringup_cpu,\n\t\t.teardown.single\t= finish_cpu,\n\t\t.cant_stop\t\t= true,\n\t},\n\t/* Final state before CPU kills itself */\n\t[CPUHP_AP_IDLE_DEAD] = {\n\t\t.name\t\t\t= \"idle:dead\",\n\t},\n\t/*\n\t * Last state before CPU enters the idle loop to die. Transient state\n\t * for synchronization.\n\t */\n\t[CPUHP_AP_OFFLINE] = {\n\t\t.name\t\t\t= \"ap:offline\",\n\t\t.cant_stop\t\t= true,\n\t},\n\t/* First state is scheduler control. Interrupts are disabled */\n\t[CPUHP_AP_SCHED_STARTING] = {\n\t\t.name\t\t\t= \"sched:starting\",\n\t\t.startup.single\t\t= sched_cpu_starting,\n\t\t.teardown.single\t= sched_cpu_dying,\n\t},\n\t[CPUHP_AP_RCUTREE_DYING] = {\n\t\t.name\t\t\t= \"RCU/tree:dying\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= rcutree_dying_cpu,\n\t},\n\t[CPUHP_AP_SMPCFD_DYING] = {\n\t\t.name\t\t\t= \"smpcfd:dying\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= smpcfd_dying_cpu,\n\t},\n\t/* Entry state on starting. Interrupts enabled from here on. Transient\n\t * state for synchronsization */\n\t[CPUHP_AP_ONLINE] = {\n\t\t.name\t\t\t= \"ap:online\",\n\t},\n\t/*\n\t * Handled on control processor until the plugged processor manages\n\t * this itself.\n\t */\n\t[CPUHP_TEARDOWN_CPU] = {\n\t\t.name\t\t\t= \"cpu:teardown\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= takedown_cpu,\n\t\t.cant_stop\t\t= true,\n\t},\n\n\t[CPUHP_AP_SCHED_WAIT_EMPTY] = {\n\t\t.name\t\t\t= \"sched:waitempty\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= sched_cpu_wait_empty,\n\t},\n\n\t/* Handle smpboot threads park/unpark */\n\t[CPUHP_AP_SMPBOOT_THREADS] = {\n\t\t.name\t\t\t= \"smpboot/threads:online\",\n\t\t.startup.single\t\t= smpboot_unpark_threads,\n\t\t.teardown.single\t= smpboot_park_threads,\n\t},\n\t[CPUHP_AP_IRQ_AFFINITY_ONLINE] = {\n\t\t.name\t\t\t= \"irq/affinity:online\",\n\t\t.startup.single\t\t= irq_affinity_online_cpu,\n\t\t.teardown.single\t= NULL,\n\t},\n\t[CPUHP_AP_PERF_ONLINE] = {\n\t\t.name\t\t\t= \"perf:online\",\n\t\t.startup.single\t\t= perf_event_init_cpu,\n\t\t.teardown.single\t= perf_event_exit_cpu,\n\t},\n\t[CPUHP_AP_WATCHDOG_ONLINE] = {\n\t\t.name\t\t\t= \"lockup_detector:online\",\n\t\t.startup.single\t\t= lockup_detector_online_cpu,\n\t\t.teardown.single\t= lockup_detector_offline_cpu,\n\t},\n\t[CPUHP_AP_WORKQUEUE_ONLINE] = {\n\t\t.name\t\t\t= \"workqueue:online\",\n\t\t.startup.single\t\t= workqueue_online_cpu,\n\t\t.teardown.single\t= workqueue_offline_cpu,\n\t},\n\t[CPUHP_AP_RCUTREE_ONLINE] = {\n\t\t.name\t\t\t= \"RCU/tree:online\",\n\t\t.startup.single\t\t= rcutree_online_cpu,\n\t\t.teardown.single\t= rcutree_offline_cpu,\n\t},\n#endif\n\t/*\n\t * The dynamically registered state space is here\n\t */\n\n#ifdef CONFIG_SMP\n\t/* Last state is scheduler control setting the cpu active */\n\t[CPUHP_AP_ACTIVE] = {\n\t\t.name\t\t\t= \"sched:active\",\n\t\t.startup.single\t\t= sched_cpu_activate,\n\t\t.teardown.single\t= sched_cpu_deactivate,\n\t},\n#endif\n\n\t/* CPU is fully up and running. */\n\t[CPUHP_ONLINE] = {\n\t\t.name\t\t\t= \"online\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= NULL,\n\t},\n};\n\nstatic struct cpuhp_step *cpuhp_get_step(enum cpuhp_state state)\n{\n\treturn cpuhp_hp_states + state;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&cpuhp_state_mutex"
          ],
          "line": 2298
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lock_device_hotplug_sysfs",
          "args": [],
          "line": 2294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrtoint",
          "args": [
            "buf",
            "10",
            "&target"
          ],
          "line": 2282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "&cpuhp_state",
            "dev->id"
          ],
          "line": 2278
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\nstatic DEFINE_MUTEX(cpuhp_state_mutex);\n\nstatic ssize_t target_store(struct device *dev, struct device_attribute *attr,\n\t\t\t    const char *buf, size_t count)\n{\n\tstruct cpuhp_cpu_state *st = per_cpu_ptr(&cpuhp_state, dev->id);\n\tstruct cpuhp_step *sp;\n\tint target, ret;\n\n\tret = kstrtoint(buf, 10, &target);\n\tif (ret)\n\t\treturn ret;\n\n#ifdef CONFIG_CPU_HOTPLUG_STATE_CONTROL\n\tif (target < CPUHP_OFFLINE || target > CPUHP_ONLINE)\n\t\treturn -EINVAL;\n#else\n\tif (target != CPUHP_OFFLINE && target != CPUHP_ONLINE)\n\t\treturn -EINVAL;\n#endif\n\n\tret = lock_device_hotplug_sysfs();\n\tif (ret)\n\t\treturn ret;\n\n\tmutex_lock(&cpuhp_state_mutex);\n\tsp = cpuhp_get_step(target);\n\tret = !sp->name || sp->cant_stop ? -EINVAL : 0;\n\tmutex_unlock(&cpuhp_state_mutex);\n\tif (ret)\n\t\tgoto out;\n\n\tif (st->state < target)\n\t\tret = cpu_up(dev->id, target);\n\telse\n\t\tret = cpu_down(dev->id, target);\nout:\n\tunlock_device_hotplug();\n\treturn ret ? ret : count;\n}"
  },
  {
    "function_name": "state_show",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
    "lines": "2266-2272",
    "snippet": "static ssize_t state_show(struct device *dev,\n\t\t\t  struct device_attribute *attr, char *buf)\n{\n\tstruct cpuhp_cpu_state *st = per_cpu_ptr(&cpuhp_state, dev->id);\n\n\treturn sprintf(buf, \"%d\\n\", st->state);\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/scs.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sched/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"%d\\n\"",
            "st->state"
          ],
          "line": 2271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "&cpuhp_state",
            "dev->id"
          ],
          "line": 2269
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\n\nstatic ssize_t state_show(struct device *dev,\n\t\t\t  struct device_attribute *attr, char *buf)\n{\n\tstruct cpuhp_cpu_state *st = per_cpu_ptr(&cpuhp_state, dev->id);\n\n\treturn sprintf(buf, \"%d\\n\", st->state);\n}"
  },
  {
    "function_name": "cpuhp_smt_enable",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
    "lines": "2244-2262",
    "snippet": "int cpuhp_smt_enable(void)\n{\n\tint cpu, ret = 0;\n\n\tcpu_maps_update_begin();\n\tcpu_smt_control = CPU_SMT_ENABLED;\n\tfor_each_present_cpu(cpu) {\n\t\t/* Skip online CPUs and CPUs on offline nodes */\n\t\tif (cpu_online(cpu) || !node_online(cpu_to_node(cpu)))\n\t\t\tcontinue;\n\t\tret = _cpu_up(cpu, 0, CPUHP_ONLINE);\n\t\tif (ret)\n\t\t\tbreak;\n\t\t/* See comment in cpuhp_smt_disable() */\n\t\tcpuhp_online_cpu_device(cpu);\n\t}\n\tcpu_maps_update_done();\n\treturn ret;\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/scs.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sched/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_maps_update_done",
          "args": [],
          "line": 2260
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_maps_update_done",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "292-295",
          "snippet": "void cpu_maps_update_done(void)\n{\n\tmutex_unlock(&cpu_add_remove_lock);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nvoid cpu_maps_update_done(void)\n{\n\tmutex_unlock(&cpu_add_remove_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpuhp_online_cpu_device",
          "args": [
            "cpu"
          ],
          "line": 2258
        },
        "resolved": true,
        "details": {
          "function_name": "cpuhp_online_cpu_device",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "2203-2210",
          "snippet": "static void cpuhp_online_cpu_device(unsigned int cpu)\n{\n\tstruct device *dev = get_cpu_device(cpu);\n\n\tdev->offline = false;\n\t/* Tell user space about the state change */\n\tkobject_uevent(&dev->kobj, KOBJ_ONLINE);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstatic void cpuhp_online_cpu_device(unsigned int cpu)\n{\n\tstruct device *dev = get_cpu_device(cpu);\n\n\tdev->offline = false;\n\t/* Tell user space about the state change */\n\tkobject_uevent(&dev->kobj, KOBJ_ONLINE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "_cpu_up",
          "args": [
            "cpu",
            "0",
            "CPUHP_ONLINE"
          ],
          "line": 2254
        },
        "resolved": true,
        "details": {
          "function_name": "_cpu_up",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "1323-1381",
          "snippet": "static int _cpu_up(unsigned int cpu, int tasks_frozen, enum cpuhp_state target)\n{\n\tstruct cpuhp_cpu_state *st = per_cpu_ptr(&cpuhp_state, cpu);\n\tstruct task_struct *idle;\n\tint ret = 0;\n\n\tcpus_write_lock();\n\n\tif (!cpu_present(cpu)) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * The caller of cpu_up() might have raced with another\n\t * caller. Nothing to do.\n\t */\n\tif (st->state >= target)\n\t\tgoto out;\n\n\tif (st->state == CPUHP_OFFLINE) {\n\t\t/* Let it fail before we try to bring the cpu up */\n\t\tidle = idle_thread_get(cpu);\n\t\tif (IS_ERR(idle)) {\n\t\t\tret = PTR_ERR(idle);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tcpuhp_tasks_frozen = tasks_frozen;\n\n\tcpuhp_set_state(st, target);\n\t/*\n\t * If the current CPU state is in the range of the AP hotplug thread,\n\t * then we need to kick the thread once more.\n\t */\n\tif (st->state > CPUHP_BRINGUP_CPU) {\n\t\tret = cpuhp_kick_ap_work(cpu);\n\t\t/*\n\t\t * The AP side has done the error rollback already. Just\n\t\t * return the error code..\n\t\t */\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\t/*\n\t * Try to reach the target state. We max out on the BP at\n\t * CPUHP_BRINGUP_CPU. After that the AP hotplug thread is\n\t * responsible for bringing it up to the target state.\n\t */\n\ttarget = min((int)target, CPUHP_BRINGUP_CPU);\n\tret = cpuhp_up_callbacks(cpu, st, target);\nout:\n\tcpus_write_unlock();\n\tarch_smt_update();\n\tcpu_up_down_serialize_trainwrecks(tasks_frozen);\n\treturn ret;\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\n\nstatic int _cpu_up(unsigned int cpu, int tasks_frozen, enum cpuhp_state target)\n{\n\tstruct cpuhp_cpu_state *st = per_cpu_ptr(&cpuhp_state, cpu);\n\tstruct task_struct *idle;\n\tint ret = 0;\n\n\tcpus_write_lock();\n\n\tif (!cpu_present(cpu)) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * The caller of cpu_up() might have raced with another\n\t * caller. Nothing to do.\n\t */\n\tif (st->state >= target)\n\t\tgoto out;\n\n\tif (st->state == CPUHP_OFFLINE) {\n\t\t/* Let it fail before we try to bring the cpu up */\n\t\tidle = idle_thread_get(cpu);\n\t\tif (IS_ERR(idle)) {\n\t\t\tret = PTR_ERR(idle);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tcpuhp_tasks_frozen = tasks_frozen;\n\n\tcpuhp_set_state(st, target);\n\t/*\n\t * If the current CPU state is in the range of the AP hotplug thread,\n\t * then we need to kick the thread once more.\n\t */\n\tif (st->state > CPUHP_BRINGUP_CPU) {\n\t\tret = cpuhp_kick_ap_work(cpu);\n\t\t/*\n\t\t * The AP side has done the error rollback already. Just\n\t\t * return the error code..\n\t\t */\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\t/*\n\t * Try to reach the target state. We max out on the BP at\n\t * CPUHP_BRINGUP_CPU. After that the AP hotplug thread is\n\t * responsible for bringing it up to the target state.\n\t */\n\ttarget = min((int)target, CPUHP_BRINGUP_CPU);\n\tret = cpuhp_up_callbacks(cpu, st, target);\nout:\n\tcpus_write_unlock();\n\tarch_smt_update();\n\tcpu_up_down_serialize_trainwrecks(tasks_frozen);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "node_online",
          "args": [
            "cpu_to_node(cpu)"
          ],
          "line": 2252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_node",
          "args": [
            "cpu"
          ],
          "line": 2252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_online",
          "args": [
            "cpu"
          ],
          "line": 2252
        },
        "resolved": true,
        "details": {
          "function_name": "init_cpu_online",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "2616-2619",
          "snippet": "void init_cpu_online(const struct cpumask *src)\n{\n\tcpumask_copy(&__cpu_online_mask, src);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct cpumask __cpu_online_mask"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstruct cpumask __cpu_online_mask;\n\nvoid init_cpu_online(const struct cpumask *src)\n{\n\tcpumask_copy(&__cpu_online_mask, src);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_maps_update_begin",
          "args": [],
          "line": 2248
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_maps_update_begin",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "287-290",
          "snippet": "void cpu_maps_update_begin(void)\n{\n\tmutex_lock(&cpu_add_remove_lock);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nvoid cpu_maps_update_begin(void)\n{\n\tmutex_lock(&cpu_add_remove_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nint cpuhp_smt_enable(void)\n{\n\tint cpu, ret = 0;\n\n\tcpu_maps_update_begin();\n\tcpu_smt_control = CPU_SMT_ENABLED;\n\tfor_each_present_cpu(cpu) {\n\t\t/* Skip online CPUs and CPUs on offline nodes */\n\t\tif (cpu_online(cpu) || !node_online(cpu_to_node(cpu)))\n\t\t\tcontinue;\n\t\tret = _cpu_up(cpu, 0, CPUHP_ONLINE);\n\t\tif (ret)\n\t\t\tbreak;\n\t\t/* See comment in cpuhp_smt_disable() */\n\t\tcpuhp_online_cpu_device(cpu);\n\t}\n\tcpu_maps_update_done();\n\treturn ret;\n}"
  },
  {
    "function_name": "cpuhp_smt_disable",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
    "lines": "2212-2242",
    "snippet": "int cpuhp_smt_disable(enum cpuhp_smt_control ctrlval)\n{\n\tint cpu, ret = 0;\n\n\tcpu_maps_update_begin();\n\tfor_each_online_cpu(cpu) {\n\t\tif (topology_is_primary_thread(cpu))\n\t\t\tcontinue;\n\t\tret = cpu_down_maps_locked(cpu, CPUHP_OFFLINE);\n\t\tif (ret)\n\t\t\tbreak;\n\t\t/*\n\t\t * As this needs to hold the cpu maps lock it's impossible\n\t\t * to call device_offline() because that ends up calling\n\t\t * cpu_down() which takes cpu maps lock. cpu maps lock\n\t\t * needs to be held as this might race against in kernel\n\t\t * abusers of the hotplug machinery (thermal management).\n\t\t *\n\t\t * So nothing would update device:offline state. That would\n\t\t * leave the sysfs entry stale and prevent onlining after\n\t\t * smt control has been changed to 'off' again. This is\n\t\t * called under the sysfs hotplug lock, so it is properly\n\t\t * serialized against the regular offline usage.\n\t\t */\n\t\tcpuhp_offline_cpu_device(cpu);\n\t}\n\tif (!ret)\n\t\tcpu_smt_control = ctrlval;\n\tcpu_maps_update_done();\n\treturn ret;\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/scs.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sched/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_maps_update_done",
          "args": [],
          "line": 2240
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_maps_update_done",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "292-295",
          "snippet": "void cpu_maps_update_done(void)\n{\n\tmutex_unlock(&cpu_add_remove_lock);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nvoid cpu_maps_update_done(void)\n{\n\tmutex_unlock(&cpu_add_remove_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpuhp_offline_cpu_device",
          "args": [
            "cpu"
          ],
          "line": 2236
        },
        "resolved": true,
        "details": {
          "function_name": "cpuhp_offline_cpu_device",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "2194-2201",
          "snippet": "static void cpuhp_offline_cpu_device(unsigned int cpu)\n{\n\tstruct device *dev = get_cpu_device(cpu);\n\n\tdev->offline = true;\n\t/* Tell user space about the state change */\n\tkobject_uevent(&dev->kobj, KOBJ_OFFLINE);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstatic void cpuhp_offline_cpu_device(unsigned int cpu)\n{\n\tstruct device *dev = get_cpu_device(cpu);\n\n\tdev->offline = true;\n\t/* Tell user space about the state change */\n\tkobject_uevent(&dev->kobj, KOBJ_OFFLINE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_down_maps_locked",
          "args": [
            "cpu",
            "CPUHP_OFFLINE"
          ],
          "line": 2220
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_down_maps_locked",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "1186-1191",
          "snippet": "static int cpu_down_maps_locked(unsigned int cpu, enum cpuhp_state target)\n{\n\tif (cpu_hotplug_disabled)\n\t\treturn -EBUSY;\n\treturn _cpu_down(cpu, 0, target);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\n\nstatic int cpu_down_maps_locked(unsigned int cpu, enum cpuhp_state target)\n{\n\tif (cpu_hotplug_disabled)\n\t\treturn -EBUSY;\n\treturn _cpu_down(cpu, 0, target);\n}"
        }
      },
      {
        "call_info": {
          "callee": "topology_is_primary_thread",
          "args": [
            "cpu"
          ],
          "line": 2218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_maps_update_begin",
          "args": [],
          "line": 2216
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_maps_update_begin",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "287-290",
          "snippet": "void cpu_maps_update_begin(void)\n{\n\tmutex_lock(&cpu_add_remove_lock);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nvoid cpu_maps_update_begin(void)\n{\n\tmutex_lock(&cpu_add_remove_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nint cpuhp_smt_disable(enum cpuhp_smt_control ctrlval)\n{\n\tint cpu, ret = 0;\n\n\tcpu_maps_update_begin();\n\tfor_each_online_cpu(cpu) {\n\t\tif (topology_is_primary_thread(cpu))\n\t\t\tcontinue;\n\t\tret = cpu_down_maps_locked(cpu, CPUHP_OFFLINE);\n\t\tif (ret)\n\t\t\tbreak;\n\t\t/*\n\t\t * As this needs to hold the cpu maps lock it's impossible\n\t\t * to call device_offline() because that ends up calling\n\t\t * cpu_down() which takes cpu maps lock. cpu maps lock\n\t\t * needs to be held as this might race against in kernel\n\t\t * abusers of the hotplug machinery (thermal management).\n\t\t *\n\t\t * So nothing would update device:offline state. That would\n\t\t * leave the sysfs entry stale and prevent onlining after\n\t\t * smt control has been changed to 'off' again. This is\n\t\t * called under the sysfs hotplug lock, so it is properly\n\t\t * serialized against the regular offline usage.\n\t\t */\n\t\tcpuhp_offline_cpu_device(cpu);\n\t}\n\tif (!ret)\n\t\tcpu_smt_control = ctrlval;\n\tcpu_maps_update_done();\n\treturn ret;\n}"
  },
  {
    "function_name": "cpuhp_online_cpu_device",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
    "lines": "2203-2210",
    "snippet": "static void cpuhp_online_cpu_device(unsigned int cpu)\n{\n\tstruct device *dev = get_cpu_device(cpu);\n\n\tdev->offline = false;\n\t/* Tell user space about the state change */\n\tkobject_uevent(&dev->kobj, KOBJ_ONLINE);\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/scs.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sched/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kobject_uevent",
          "args": [
            "&dev->kobj",
            "KOBJ_ONLINE"
          ],
          "line": 2209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_cpu_device",
          "args": [
            "cpu"
          ],
          "line": 2205
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstatic void cpuhp_online_cpu_device(unsigned int cpu)\n{\n\tstruct device *dev = get_cpu_device(cpu);\n\n\tdev->offline = false;\n\t/* Tell user space about the state change */\n\tkobject_uevent(&dev->kobj, KOBJ_ONLINE);\n}"
  },
  {
    "function_name": "cpuhp_offline_cpu_device",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
    "lines": "2194-2201",
    "snippet": "static void cpuhp_offline_cpu_device(unsigned int cpu)\n{\n\tstruct device *dev = get_cpu_device(cpu);\n\n\tdev->offline = true;\n\t/* Tell user space about the state change */\n\tkobject_uevent(&dev->kobj, KOBJ_OFFLINE);\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/scs.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sched/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kobject_uevent",
          "args": [
            "&dev->kobj",
            "KOBJ_OFFLINE"
          ],
          "line": 2200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_cpu_device",
          "args": [
            "cpu"
          ],
          "line": 2196
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstatic void cpuhp_offline_cpu_device(unsigned int cpu)\n{\n\tstruct device *dev = get_cpu_device(cpu);\n\n\tdev->offline = true;\n\t/* Tell user space about the state change */\n\tkobject_uevent(&dev->kobj, KOBJ_OFFLINE);\n}"
  },
  {
    "function_name": "__cpuhp_remove_state",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
    "lines": "2185-2190",
    "snippet": "void __cpuhp_remove_state(enum cpuhp_state state, bool invoke)\n{\n\tcpus_read_lock();\n\t__cpuhp_remove_state_cpuslocked(state, invoke);\n\tcpus_read_unlock();\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/scs.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sched/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpus_read_unlock",
          "args": [],
          "line": 2189
        },
        "resolved": true,
        "details": {
          "function_name": "cpus_read_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "319-322",
          "snippet": "void cpus_read_unlock(void)\n{\n\tpercpu_up_read(&cpu_hotplug_lock);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nvoid cpus_read_unlock(void)\n{\n\tpercpu_up_read(&cpu_hotplug_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__cpuhp_remove_state_cpuslocked",
          "args": [
            "state",
            "invoke"
          ],
          "line": 2188
        },
        "resolved": true,
        "details": {
          "function_name": "__cpuhp_remove_state_cpuslocked",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "2147-2182",
          "snippet": "void __cpuhp_remove_state_cpuslocked(enum cpuhp_state state, bool invoke)\n{\n\tstruct cpuhp_step *sp = cpuhp_get_step(state);\n\tint cpu;\n\n\tBUG_ON(cpuhp_cb_check(state));\n\n\tlockdep_assert_cpus_held();\n\n\tmutex_lock(&cpuhp_state_mutex);\n\tif (sp->multi_instance) {\n\t\tWARN(!hlist_empty(&sp->list),\n\t\t     \"Error: Removing state %d which has instances left.\\n\",\n\t\t     state);\n\t\tgoto remove;\n\t}\n\n\tif (!invoke || !cpuhp_get_teardown_cb(state))\n\t\tgoto remove;\n\n\t/*\n\t * Call the teardown callback for each present cpu depending\n\t * on the hotplug state of the cpu. This function is not\n\t * allowed to fail currently!\n\t */\n\tfor_each_present_cpu(cpu) {\n\t\tstruct cpuhp_cpu_state *st = per_cpu_ptr(&cpuhp_state, cpu);\n\t\tint cpustate = st->state;\n\n\t\tif (cpustate >= state)\n\t\t\tcpuhp_issue_call(cpu, state, false, NULL);\n\t}\nremove:\n\tcpuhp_store_callbacks(state, NULL, NULL, NULL, false);\n\tmutex_unlock(&cpuhp_state_mutex);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};",
            "static DEFINE_MUTEX(cpuhp_state_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\nstatic DEFINE_MUTEX(cpuhp_state_mutex);\n\nvoid __cpuhp_remove_state_cpuslocked(enum cpuhp_state state, bool invoke)\n{\n\tstruct cpuhp_step *sp = cpuhp_get_step(state);\n\tint cpu;\n\n\tBUG_ON(cpuhp_cb_check(state));\n\n\tlockdep_assert_cpus_held();\n\n\tmutex_lock(&cpuhp_state_mutex);\n\tif (sp->multi_instance) {\n\t\tWARN(!hlist_empty(&sp->list),\n\t\t     \"Error: Removing state %d which has instances left.\\n\",\n\t\t     state);\n\t\tgoto remove;\n\t}\n\n\tif (!invoke || !cpuhp_get_teardown_cb(state))\n\t\tgoto remove;\n\n\t/*\n\t * Call the teardown callback for each present cpu depending\n\t * on the hotplug state of the cpu. This function is not\n\t * allowed to fail currently!\n\t */\n\tfor_each_present_cpu(cpu) {\n\t\tstruct cpuhp_cpu_state *st = per_cpu_ptr(&cpuhp_state, cpu);\n\t\tint cpustate = st->state;\n\n\t\tif (cpustate >= state)\n\t\t\tcpuhp_issue_call(cpu, state, false, NULL);\n\t}\nremove:\n\tcpuhp_store_callbacks(state, NULL, NULL, NULL, false);\n\tmutex_unlock(&cpuhp_state_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpus_read_lock",
          "args": [],
          "line": 2187
        },
        "resolved": true,
        "details": {
          "function_name": "cpus_read_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "307-310",
          "snippet": "void cpus_read_lock(void)\n{\n\tpercpu_down_read(&cpu_hotplug_lock);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nvoid cpus_read_lock(void)\n{\n\tpercpu_down_read(&cpu_hotplug_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\n\nvoid __cpuhp_remove_state(enum cpuhp_state state, bool invoke)\n{\n\tcpus_read_lock();\n\t__cpuhp_remove_state_cpuslocked(state, invoke);\n\tcpus_read_unlock();\n}"
  },
  {
    "function_name": "__cpuhp_remove_state_cpuslocked",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
    "lines": "2147-2182",
    "snippet": "void __cpuhp_remove_state_cpuslocked(enum cpuhp_state state, bool invoke)\n{\n\tstruct cpuhp_step *sp = cpuhp_get_step(state);\n\tint cpu;\n\n\tBUG_ON(cpuhp_cb_check(state));\n\n\tlockdep_assert_cpus_held();\n\n\tmutex_lock(&cpuhp_state_mutex);\n\tif (sp->multi_instance) {\n\t\tWARN(!hlist_empty(&sp->list),\n\t\t     \"Error: Removing state %d which has instances left.\\n\",\n\t\t     state);\n\t\tgoto remove;\n\t}\n\n\tif (!invoke || !cpuhp_get_teardown_cb(state))\n\t\tgoto remove;\n\n\t/*\n\t * Call the teardown callback for each present cpu depending\n\t * on the hotplug state of the cpu. This function is not\n\t * allowed to fail currently!\n\t */\n\tfor_each_present_cpu(cpu) {\n\t\tstruct cpuhp_cpu_state *st = per_cpu_ptr(&cpuhp_state, cpu);\n\t\tint cpustate = st->state;\n\n\t\tif (cpustate >= state)\n\t\t\tcpuhp_issue_call(cpu, state, false, NULL);\n\t}\nremove:\n\tcpuhp_store_callbacks(state, NULL, NULL, NULL, false);\n\tmutex_unlock(&cpuhp_state_mutex);\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/scs.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sched/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};",
      "static DEFINE_MUTEX(cpuhp_state_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&cpuhp_state_mutex"
          ],
          "line": 2181
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpuhp_store_callbacks",
          "args": [
            "state",
            "NULL",
            "NULL",
            "NULL",
            "false"
          ],
          "line": 2180
        },
        "resolved": true,
        "details": {
          "function_name": "cpuhp_store_callbacks",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "1851-1886",
          "snippet": "static int cpuhp_store_callbacks(enum cpuhp_state state, const char *name,\n\t\t\t\t int (*startup)(unsigned int cpu),\n\t\t\t\t int (*teardown)(unsigned int cpu),\n\t\t\t\t bool multi_instance)\n{\n\t/* (Un)Install the callbacks for further cpu hotplug operations */\n\tstruct cpuhp_step *sp;\n\tint ret = 0;\n\n\t/*\n\t * If name is NULL, then the state gets removed.\n\t *\n\t * CPUHP_AP_ONLINE_DYN and CPUHP_BP_PREPARE_DYN are handed out on\n\t * the first allocation from these dynamic ranges, so the removal\n\t * would trigger a new allocation and clear the wrong (already\n\t * empty) state, leaving the callbacks of the to be cleared state\n\t * dangling, which causes wreckage on the next hotplug operation.\n\t */\n\tif (name && (state == CPUHP_AP_ONLINE_DYN ||\n\t\t     state == CPUHP_BP_PREPARE_DYN)) {\n\t\tret = cpuhp_reserve_state(state);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tstate = ret;\n\t}\n\tsp = cpuhp_get_step(state);\n\tif (name && sp->name)\n\t\treturn -EBUSY;\n\n\tsp->startup.single = startup;\n\tsp->teardown.single = teardown;\n\tsp->name = name;\n\tsp->multi_instance = multi_instance;\n\tINIT_HLIST_HEAD(&sp->list);\n\treturn ret;\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\n\nstatic int cpuhp_store_callbacks(enum cpuhp_state state, const char *name,\n\t\t\t\t int (*startup)(unsigned int cpu),\n\t\t\t\t int (*teardown)(unsigned int cpu),\n\t\t\t\t bool multi_instance)\n{\n\t/* (Un)Install the callbacks for further cpu hotplug operations */\n\tstruct cpuhp_step *sp;\n\tint ret = 0;\n\n\t/*\n\t * If name is NULL, then the state gets removed.\n\t *\n\t * CPUHP_AP_ONLINE_DYN and CPUHP_BP_PREPARE_DYN are handed out on\n\t * the first allocation from these dynamic ranges, so the removal\n\t * would trigger a new allocation and clear the wrong (already\n\t * empty) state, leaving the callbacks of the to be cleared state\n\t * dangling, which causes wreckage on the next hotplug operation.\n\t */\n\tif (name && (state == CPUHP_AP_ONLINE_DYN ||\n\t\t     state == CPUHP_BP_PREPARE_DYN)) {\n\t\tret = cpuhp_reserve_state(state);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tstate = ret;\n\t}\n\tsp = cpuhp_get_step(state);\n\tif (name && sp->name)\n\t\treturn -EBUSY;\n\n\tsp->startup.single = startup;\n\tsp->teardown.single = teardown;\n\tsp->name = name;\n\tsp->multi_instance = multi_instance;\n\tINIT_HLIST_HEAD(&sp->list);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpuhp_issue_call",
          "args": [
            "cpu",
            "state",
            "false",
            "NULL"
          ],
          "line": 2177
        },
        "resolved": true,
        "details": {
          "function_name": "cpuhp_issue_call",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "1897-1923",
          "snippet": "static int cpuhp_issue_call(int cpu, enum cpuhp_state state, bool bringup,\n\t\t\t    struct hlist_node *node)\n{\n\tstruct cpuhp_step *sp = cpuhp_get_step(state);\n\tint ret;\n\n\t/*\n\t * If there's nothing to do, we done.\n\t * Relies on the union for multi_instance.\n\t */\n\tif (cpuhp_step_empty(bringup, sp))\n\t\treturn 0;\n\t/*\n\t * The non AP bound callbacks can fail on bringup. On teardown\n\t * e.g. module removal we crash for now.\n\t */\n#ifdef CONFIG_SMP\n\tif (cpuhp_is_ap_state(state))\n\t\tret = cpuhp_invoke_ap_callback(cpu, state, bringup, node);\n\telse\n\t\tret = cpuhp_invoke_callback(cpu, state, bringup, node, NULL);\n#else\n\tret = cpuhp_invoke_callback(cpu, state, bringup, node, NULL);\n#endif\n\tBUG_ON(ret && !bringup);\n\treturn ret;\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\n\nstatic int cpuhp_issue_call(int cpu, enum cpuhp_state state, bool bringup,\n\t\t\t    struct hlist_node *node)\n{\n\tstruct cpuhp_step *sp = cpuhp_get_step(state);\n\tint ret;\n\n\t/*\n\t * If there's nothing to do, we done.\n\t * Relies on the union for multi_instance.\n\t */\n\tif (cpuhp_step_empty(bringup, sp))\n\t\treturn 0;\n\t/*\n\t * The non AP bound callbacks can fail on bringup. On teardown\n\t * e.g. module removal we crash for now.\n\t */\n#ifdef CONFIG_SMP\n\tif (cpuhp_is_ap_state(state))\n\t\tret = cpuhp_invoke_ap_callback(cpu, state, bringup, node);\n\telse\n\t\tret = cpuhp_invoke_callback(cpu, state, bringup, node, NULL);\n#else\n\tret = cpuhp_invoke_callback(cpu, state, bringup, node, NULL);\n#endif\n\tBUG_ON(ret && !bringup);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "&cpuhp_state",
            "cpu"
          ],
          "line": 2173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpuhp_get_teardown_cb",
          "args": [
            "state"
          ],
          "line": 2164
        },
        "resolved": true,
        "details": {
          "function_name": "cpuhp_get_teardown_cb",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "1888-1891",
          "snippet": "static void *cpuhp_get_teardown_cb(enum cpuhp_state state)\n{\n\treturn cpuhp_get_step(state)->teardown.single;\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\n\nstatic void *cpuhp_get_teardown_cb(enum cpuhp_state state)\n{\n\treturn cpuhp_get_step(state)->teardown.single;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "!hlist_empty(&sp->list)",
            "\"Error: Removing state %d which has instances left.\\n\"",
            "state"
          ],
          "line": 2158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_empty",
          "args": [
            "&sp->list"
          ],
          "line": 2158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&cpuhp_state_mutex"
          ],
          "line": 2156
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_assert_cpus_held",
          "args": [],
          "line": 2154
        },
        "resolved": true,
        "details": {
          "function_name": "lockdep_assert_cpus_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "335-347",
          "snippet": "void lockdep_assert_cpus_held(void)\n{\n\t/*\n\t * We can't have hotplug operations before userspace starts running,\n\t * and some init codepaths will knowingly not take the hotplug lock.\n\t * This is all valid, so mute lockdep until it makes sense to report\n\t * unheld locks.\n\t */\n\tif (system_state < SYSTEM_RUNNING)\n\t\treturn;\n\n\tpercpu_rwsem_assert_held(&cpu_hotplug_lock);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nvoid lockdep_assert_cpus_held(void)\n{\n\t/*\n\t * We can't have hotplug operations before userspace starts running,\n\t * and some init codepaths will knowingly not take the hotplug lock.\n\t * This is all valid, so mute lockdep until it makes sense to report\n\t * unheld locks.\n\t */\n\tif (system_state < SYSTEM_RUNNING)\n\t\treturn;\n\n\tpercpu_rwsem_assert_held(&cpu_hotplug_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "cpuhp_cb_check(state)"
          ],
          "line": 2152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpuhp_cb_check",
          "args": [
            "state"
          ],
          "line": 2152
        },
        "resolved": true,
        "details": {
          "function_name": "cpuhp_cb_check",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "1813-1818",
          "snippet": "static int cpuhp_cb_check(enum cpuhp_state state)\n{\n\tif (state <= CPUHP_OFFLINE || state >= CPUHP_ONLINE)\n\t\treturn -EINVAL;\n\treturn 0;\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\n\nstatic int cpuhp_cb_check(enum cpuhp_state state)\n{\n\tif (state <= CPUHP_OFFLINE || state >= CPUHP_ONLINE)\n\t\treturn -EINVAL;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpuhp_get_step",
          "args": [
            "state"
          ],
          "line": 2149
        },
        "resolved": true,
        "details": {
          "function_name": "cpuhp_get_step",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "144-147",
          "snippet": "static struct cpuhp_step *cpuhp_get_step(enum cpuhp_state state)\n{\n\treturn cpuhp_hp_states + state;\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};",
            "static struct cpuhp_step cpuhp_hp_states[];",
            "static struct cpuhp_step cpuhp_hp_states[] = {\n\t[CPUHP_OFFLINE] = {\n\t\t.name\t\t\t= \"offline\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= NULL,\n\t},\n#ifdef CONFIG_SMP\n\t[CPUHP_CREATE_THREADS]= {\n\t\t.name\t\t\t= \"threads:prepare\",\n\t\t.startup.single\t\t= smpboot_create_threads,\n\t\t.teardown.single\t= NULL,\n\t\t.cant_stop\t\t= true,\n\t},\n\t[CPUHP_PERF_PREPARE] = {\n\t\t.name\t\t\t= \"perf:prepare\",\n\t\t.startup.single\t\t= perf_event_init_cpu,\n\t\t.teardown.single\t= perf_event_exit_cpu,\n\t},\n\t[CPUHP_WORKQUEUE_PREP] = {\n\t\t.name\t\t\t= \"workqueue:prepare\",\n\t\t.startup.single\t\t= workqueue_prepare_cpu,\n\t\t.teardown.single\t= NULL,\n\t},\n\t[CPUHP_HRTIMERS_PREPARE] = {\n\t\t.name\t\t\t= \"hrtimers:prepare\",\n\t\t.startup.single\t\t= hrtimers_prepare_cpu,\n\t\t.teardown.single\t= hrtimers_dead_cpu,\n\t},\n\t[CPUHP_SMPCFD_PREPARE] = {\n\t\t.name\t\t\t= \"smpcfd:prepare\",\n\t\t.startup.single\t\t= smpcfd_prepare_cpu,\n\t\t.teardown.single\t= smpcfd_dead_cpu,\n\t},\n\t[CPUHP_RELAY_PREPARE] = {\n\t\t.name\t\t\t= \"relay:prepare\",\n\t\t.startup.single\t\t= relay_prepare_cpu,\n\t\t.teardown.single\t= NULL,\n\t},\n\t[CPUHP_SLAB_PREPARE] = {\n\t\t.name\t\t\t= \"slab:prepare\",\n\t\t.startup.single\t\t= slab_prepare_cpu,\n\t\t.teardown.single\t= slab_dead_cpu,\n\t},\n\t[CPUHP_RCUTREE_PREP] = {\n\t\t.name\t\t\t= \"RCU/tree:prepare\",\n\t\t.startup.single\t\t= rcutree_prepare_cpu,\n\t\t.teardown.single\t= rcutree_dead_cpu,\n\t},\n\t/*\n\t * On the tear-down path, timers_dead_cpu() must be invoked\n\t * before blk_mq_queue_reinit_notify() from notify_dead(),\n\t * otherwise a RCU stall occurs.\n\t */\n\t[CPUHP_TIMERS_PREPARE] = {\n\t\t.name\t\t\t= \"timers:prepare\",\n\t\t.startup.single\t\t= timers_prepare_cpu,\n\t\t.teardown.single\t= timers_dead_cpu,\n\t},\n\t/* Kicks the plugged cpu into life */\n\t[CPUHP_BRINGUP_CPU] = {\n\t\t.name\t\t\t= \"cpu:bringup\",\n\t\t.startup.single\t\t= bringup_cpu,\n\t\t.teardown.single\t= finish_cpu,\n\t\t.cant_stop\t\t= true,\n\t},\n\t/* Final state before CPU kills itself */\n\t[CPUHP_AP_IDLE_DEAD] = {\n\t\t.name\t\t\t= \"idle:dead\",\n\t},\n\t/*\n\t * Last state before CPU enters the idle loop to die. Transient state\n\t * for synchronization.\n\t */\n\t[CPUHP_AP_OFFLINE] = {\n\t\t.name\t\t\t= \"ap:offline\",\n\t\t.cant_stop\t\t= true,\n\t},\n\t/* First state is scheduler control. Interrupts are disabled */\n\t[CPUHP_AP_SCHED_STARTING] = {\n\t\t.name\t\t\t= \"sched:starting\",\n\t\t.startup.single\t\t= sched_cpu_starting,\n\t\t.teardown.single\t= sched_cpu_dying,\n\t},\n\t[CPUHP_AP_RCUTREE_DYING] = {\n\t\t.name\t\t\t= \"RCU/tree:dying\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= rcutree_dying_cpu,\n\t},\n\t[CPUHP_AP_SMPCFD_DYING] = {\n\t\t.name\t\t\t= \"smpcfd:dying\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= smpcfd_dying_cpu,\n\t},\n\t/* Entry state on starting. Interrupts enabled from here on. Transient\n\t * state for synchronsization */\n\t[CPUHP_AP_ONLINE] = {\n\t\t.name\t\t\t= \"ap:online\",\n\t},\n\t/*\n\t * Handled on control processor until the plugged processor manages\n\t * this itself.\n\t */\n\t[CPUHP_TEARDOWN_CPU] = {\n\t\t.name\t\t\t= \"cpu:teardown\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= takedown_cpu,\n\t\t.cant_stop\t\t= true,\n\t},\n\n\t[CPUHP_AP_SCHED_WAIT_EMPTY] = {\n\t\t.name\t\t\t= \"sched:waitempty\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= sched_cpu_wait_empty,\n\t},\n\n\t/* Handle smpboot threads park/unpark */\n\t[CPUHP_AP_SMPBOOT_THREADS] = {\n\t\t.name\t\t\t= \"smpboot/threads:online\",\n\t\t.startup.single\t\t= smpboot_unpark_threads,\n\t\t.teardown.single\t= smpboot_park_threads,\n\t},\n\t[CPUHP_AP_IRQ_AFFINITY_ONLINE] = {\n\t\t.name\t\t\t= \"irq/affinity:online\",\n\t\t.startup.single\t\t= irq_affinity_online_cpu,\n\t\t.teardown.single\t= NULL,\n\t},\n\t[CPUHP_AP_PERF_ONLINE] = {\n\t\t.name\t\t\t= \"perf:online\",\n\t\t.startup.single\t\t= perf_event_init_cpu,\n\t\t.teardown.single\t= perf_event_exit_cpu,\n\t},\n\t[CPUHP_AP_WATCHDOG_ONLINE] = {\n\t\t.name\t\t\t= \"lockup_detector:online\",\n\t\t.startup.single\t\t= lockup_detector_online_cpu,\n\t\t.teardown.single\t= lockup_detector_offline_cpu,\n\t},\n\t[CPUHP_AP_WORKQUEUE_ONLINE] = {\n\t\t.name\t\t\t= \"workqueue:online\",\n\t\t.startup.single\t\t= workqueue_online_cpu,\n\t\t.teardown.single\t= workqueue_offline_cpu,\n\t},\n\t[CPUHP_AP_RCUTREE_ONLINE] = {\n\t\t.name\t\t\t= \"RCU/tree:online\",\n\t\t.startup.single\t\t= rcutree_online_cpu,\n\t\t.teardown.single\t= rcutree_offline_cpu,\n\t},\n#endif\n\t/*\n\t * The dynamically registered state space is here\n\t */\n\n#ifdef CONFIG_SMP\n\t/* Last state is scheduler control setting the cpu active */\n\t[CPUHP_AP_ACTIVE] = {\n\t\t.name\t\t\t= \"sched:active\",\n\t\t.startup.single\t\t= sched_cpu_activate,\n\t\t.teardown.single\t= sched_cpu_deactivate,\n\t},\n#endif\n\n\t/* CPU is fully up and running. */\n\t[CPUHP_ONLINE] = {\n\t\t.name\t\t\t= \"online\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= NULL,\n\t},\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\nstatic struct cpuhp_step cpuhp_hp_states[];\nstatic struct cpuhp_step cpuhp_hp_states[] = {\n\t[CPUHP_OFFLINE] = {\n\t\t.name\t\t\t= \"offline\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= NULL,\n\t},\n#ifdef CONFIG_SMP\n\t[CPUHP_CREATE_THREADS]= {\n\t\t.name\t\t\t= \"threads:prepare\",\n\t\t.startup.single\t\t= smpboot_create_threads,\n\t\t.teardown.single\t= NULL,\n\t\t.cant_stop\t\t= true,\n\t},\n\t[CPUHP_PERF_PREPARE] = {\n\t\t.name\t\t\t= \"perf:prepare\",\n\t\t.startup.single\t\t= perf_event_init_cpu,\n\t\t.teardown.single\t= perf_event_exit_cpu,\n\t},\n\t[CPUHP_WORKQUEUE_PREP] = {\n\t\t.name\t\t\t= \"workqueue:prepare\",\n\t\t.startup.single\t\t= workqueue_prepare_cpu,\n\t\t.teardown.single\t= NULL,\n\t},\n\t[CPUHP_HRTIMERS_PREPARE] = {\n\t\t.name\t\t\t= \"hrtimers:prepare\",\n\t\t.startup.single\t\t= hrtimers_prepare_cpu,\n\t\t.teardown.single\t= hrtimers_dead_cpu,\n\t},\n\t[CPUHP_SMPCFD_PREPARE] = {\n\t\t.name\t\t\t= \"smpcfd:prepare\",\n\t\t.startup.single\t\t= smpcfd_prepare_cpu,\n\t\t.teardown.single\t= smpcfd_dead_cpu,\n\t},\n\t[CPUHP_RELAY_PREPARE] = {\n\t\t.name\t\t\t= \"relay:prepare\",\n\t\t.startup.single\t\t= relay_prepare_cpu,\n\t\t.teardown.single\t= NULL,\n\t},\n\t[CPUHP_SLAB_PREPARE] = {\n\t\t.name\t\t\t= \"slab:prepare\",\n\t\t.startup.single\t\t= slab_prepare_cpu,\n\t\t.teardown.single\t= slab_dead_cpu,\n\t},\n\t[CPUHP_RCUTREE_PREP] = {\n\t\t.name\t\t\t= \"RCU/tree:prepare\",\n\t\t.startup.single\t\t= rcutree_prepare_cpu,\n\t\t.teardown.single\t= rcutree_dead_cpu,\n\t},\n\t/*\n\t * On the tear-down path, timers_dead_cpu() must be invoked\n\t * before blk_mq_queue_reinit_notify() from notify_dead(),\n\t * otherwise a RCU stall occurs.\n\t */\n\t[CPUHP_TIMERS_PREPARE] = {\n\t\t.name\t\t\t= \"timers:prepare\",\n\t\t.startup.single\t\t= timers_prepare_cpu,\n\t\t.teardown.single\t= timers_dead_cpu,\n\t},\n\t/* Kicks the plugged cpu into life */\n\t[CPUHP_BRINGUP_CPU] = {\n\t\t.name\t\t\t= \"cpu:bringup\",\n\t\t.startup.single\t\t= bringup_cpu,\n\t\t.teardown.single\t= finish_cpu,\n\t\t.cant_stop\t\t= true,\n\t},\n\t/* Final state before CPU kills itself */\n\t[CPUHP_AP_IDLE_DEAD] = {\n\t\t.name\t\t\t= \"idle:dead\",\n\t},\n\t/*\n\t * Last state before CPU enters the idle loop to die. Transient state\n\t * for synchronization.\n\t */\n\t[CPUHP_AP_OFFLINE] = {\n\t\t.name\t\t\t= \"ap:offline\",\n\t\t.cant_stop\t\t= true,\n\t},\n\t/* First state is scheduler control. Interrupts are disabled */\n\t[CPUHP_AP_SCHED_STARTING] = {\n\t\t.name\t\t\t= \"sched:starting\",\n\t\t.startup.single\t\t= sched_cpu_starting,\n\t\t.teardown.single\t= sched_cpu_dying,\n\t},\n\t[CPUHP_AP_RCUTREE_DYING] = {\n\t\t.name\t\t\t= \"RCU/tree:dying\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= rcutree_dying_cpu,\n\t},\n\t[CPUHP_AP_SMPCFD_DYING] = {\n\t\t.name\t\t\t= \"smpcfd:dying\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= smpcfd_dying_cpu,\n\t},\n\t/* Entry state on starting. Interrupts enabled from here on. Transient\n\t * state for synchronsization */\n\t[CPUHP_AP_ONLINE] = {\n\t\t.name\t\t\t= \"ap:online\",\n\t},\n\t/*\n\t * Handled on control processor until the plugged processor manages\n\t * this itself.\n\t */\n\t[CPUHP_TEARDOWN_CPU] = {\n\t\t.name\t\t\t= \"cpu:teardown\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= takedown_cpu,\n\t\t.cant_stop\t\t= true,\n\t},\n\n\t[CPUHP_AP_SCHED_WAIT_EMPTY] = {\n\t\t.name\t\t\t= \"sched:waitempty\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= sched_cpu_wait_empty,\n\t},\n\n\t/* Handle smpboot threads park/unpark */\n\t[CPUHP_AP_SMPBOOT_THREADS] = {\n\t\t.name\t\t\t= \"smpboot/threads:online\",\n\t\t.startup.single\t\t= smpboot_unpark_threads,\n\t\t.teardown.single\t= smpboot_park_threads,\n\t},\n\t[CPUHP_AP_IRQ_AFFINITY_ONLINE] = {\n\t\t.name\t\t\t= \"irq/affinity:online\",\n\t\t.startup.single\t\t= irq_affinity_online_cpu,\n\t\t.teardown.single\t= NULL,\n\t},\n\t[CPUHP_AP_PERF_ONLINE] = {\n\t\t.name\t\t\t= \"perf:online\",\n\t\t.startup.single\t\t= perf_event_init_cpu,\n\t\t.teardown.single\t= perf_event_exit_cpu,\n\t},\n\t[CPUHP_AP_WATCHDOG_ONLINE] = {\n\t\t.name\t\t\t= \"lockup_detector:online\",\n\t\t.startup.single\t\t= lockup_detector_online_cpu,\n\t\t.teardown.single\t= lockup_detector_offline_cpu,\n\t},\n\t[CPUHP_AP_WORKQUEUE_ONLINE] = {\n\t\t.name\t\t\t= \"workqueue:online\",\n\t\t.startup.single\t\t= workqueue_online_cpu,\n\t\t.teardown.single\t= workqueue_offline_cpu,\n\t},\n\t[CPUHP_AP_RCUTREE_ONLINE] = {\n\t\t.name\t\t\t= \"RCU/tree:online\",\n\t\t.startup.single\t\t= rcutree_online_cpu,\n\t\t.teardown.single\t= rcutree_offline_cpu,\n\t},\n#endif\n\t/*\n\t * The dynamically registered state space is here\n\t */\n\n#ifdef CONFIG_SMP\n\t/* Last state is scheduler control setting the cpu active */\n\t[CPUHP_AP_ACTIVE] = {\n\t\t.name\t\t\t= \"sched:active\",\n\t\t.startup.single\t\t= sched_cpu_activate,\n\t\t.teardown.single\t= sched_cpu_deactivate,\n\t},\n#endif\n\n\t/* CPU is fully up and running. */\n\t[CPUHP_ONLINE] = {\n\t\t.name\t\t\t= \"online\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= NULL,\n\t},\n};\n\nstatic struct cpuhp_step *cpuhp_get_step(enum cpuhp_state state)\n{\n\treturn cpuhp_hp_states + state;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\nstatic DEFINE_MUTEX(cpuhp_state_mutex);\n\nvoid __cpuhp_remove_state_cpuslocked(enum cpuhp_state state, bool invoke)\n{\n\tstruct cpuhp_step *sp = cpuhp_get_step(state);\n\tint cpu;\n\n\tBUG_ON(cpuhp_cb_check(state));\n\n\tlockdep_assert_cpus_held();\n\n\tmutex_lock(&cpuhp_state_mutex);\n\tif (sp->multi_instance) {\n\t\tWARN(!hlist_empty(&sp->list),\n\t\t     \"Error: Removing state %d which has instances left.\\n\",\n\t\t     state);\n\t\tgoto remove;\n\t}\n\n\tif (!invoke || !cpuhp_get_teardown_cb(state))\n\t\tgoto remove;\n\n\t/*\n\t * Call the teardown callback for each present cpu depending\n\t * on the hotplug state of the cpu. This function is not\n\t * allowed to fail currently!\n\t */\n\tfor_each_present_cpu(cpu) {\n\t\tstruct cpuhp_cpu_state *st = per_cpu_ptr(&cpuhp_state, cpu);\n\t\tint cpustate = st->state;\n\n\t\tif (cpustate >= state)\n\t\t\tcpuhp_issue_call(cpu, state, false, NULL);\n\t}\nremove:\n\tcpuhp_store_callbacks(state, NULL, NULL, NULL, false);\n\tmutex_unlock(&cpuhp_state_mutex);\n}"
  },
  {
    "function_name": "__cpuhp_state_remove_instance",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
    "lines": "2099-2134",
    "snippet": "int __cpuhp_state_remove_instance(enum cpuhp_state state,\n\t\t\t\t  struct hlist_node *node, bool invoke)\n{\n\tstruct cpuhp_step *sp = cpuhp_get_step(state);\n\tint cpu;\n\n\tBUG_ON(cpuhp_cb_check(state));\n\n\tif (!sp->multi_instance)\n\t\treturn -EINVAL;\n\n\tcpus_read_lock();\n\tmutex_lock(&cpuhp_state_mutex);\n\n\tif (!invoke || !cpuhp_get_teardown_cb(state))\n\t\tgoto remove;\n\t/*\n\t * Call the teardown callback for each present cpu depending\n\t * on the hotplug state of the cpu. This function is not\n\t * allowed to fail currently!\n\t */\n\tfor_each_present_cpu(cpu) {\n\t\tstruct cpuhp_cpu_state *st = per_cpu_ptr(&cpuhp_state, cpu);\n\t\tint cpustate = st->state;\n\n\t\tif (cpustate >= state)\n\t\t\tcpuhp_issue_call(cpu, state, false, node);\n\t}\n\nremove:\n\thlist_del(node);\n\tmutex_unlock(&cpuhp_state_mutex);\n\tcpus_read_unlock();\n\n\treturn 0;\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/scs.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sched/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};",
      "static DEFINE_MUTEX(cpuhp_state_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpus_read_unlock",
          "args": [],
          "line": 2131
        },
        "resolved": true,
        "details": {
          "function_name": "cpus_read_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "319-322",
          "snippet": "void cpus_read_unlock(void)\n{\n\tpercpu_up_read(&cpu_hotplug_lock);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nvoid cpus_read_unlock(void)\n{\n\tpercpu_up_read(&cpu_hotplug_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&cpuhp_state_mutex"
          ],
          "line": 2130
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_del",
          "args": [
            "node"
          ],
          "line": 2129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpuhp_issue_call",
          "args": [
            "cpu",
            "state",
            "false",
            "node"
          ],
          "line": 2125
        },
        "resolved": true,
        "details": {
          "function_name": "cpuhp_issue_call",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "1897-1923",
          "snippet": "static int cpuhp_issue_call(int cpu, enum cpuhp_state state, bool bringup,\n\t\t\t    struct hlist_node *node)\n{\n\tstruct cpuhp_step *sp = cpuhp_get_step(state);\n\tint ret;\n\n\t/*\n\t * If there's nothing to do, we done.\n\t * Relies on the union for multi_instance.\n\t */\n\tif (cpuhp_step_empty(bringup, sp))\n\t\treturn 0;\n\t/*\n\t * The non AP bound callbacks can fail on bringup. On teardown\n\t * e.g. module removal we crash for now.\n\t */\n#ifdef CONFIG_SMP\n\tif (cpuhp_is_ap_state(state))\n\t\tret = cpuhp_invoke_ap_callback(cpu, state, bringup, node);\n\telse\n\t\tret = cpuhp_invoke_callback(cpu, state, bringup, node, NULL);\n#else\n\tret = cpuhp_invoke_callback(cpu, state, bringup, node, NULL);\n#endif\n\tBUG_ON(ret && !bringup);\n\treturn ret;\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\n\nstatic int cpuhp_issue_call(int cpu, enum cpuhp_state state, bool bringup,\n\t\t\t    struct hlist_node *node)\n{\n\tstruct cpuhp_step *sp = cpuhp_get_step(state);\n\tint ret;\n\n\t/*\n\t * If there's nothing to do, we done.\n\t * Relies on the union for multi_instance.\n\t */\n\tif (cpuhp_step_empty(bringup, sp))\n\t\treturn 0;\n\t/*\n\t * The non AP bound callbacks can fail on bringup. On teardown\n\t * e.g. module removal we crash for now.\n\t */\n#ifdef CONFIG_SMP\n\tif (cpuhp_is_ap_state(state))\n\t\tret = cpuhp_invoke_ap_callback(cpu, state, bringup, node);\n\telse\n\t\tret = cpuhp_invoke_callback(cpu, state, bringup, node, NULL);\n#else\n\tret = cpuhp_invoke_callback(cpu, state, bringup, node, NULL);\n#endif\n\tBUG_ON(ret && !bringup);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "&cpuhp_state",
            "cpu"
          ],
          "line": 2121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpuhp_get_teardown_cb",
          "args": [
            "state"
          ],
          "line": 2113
        },
        "resolved": true,
        "details": {
          "function_name": "cpuhp_get_teardown_cb",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "1888-1891",
          "snippet": "static void *cpuhp_get_teardown_cb(enum cpuhp_state state)\n{\n\treturn cpuhp_get_step(state)->teardown.single;\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\n\nstatic void *cpuhp_get_teardown_cb(enum cpuhp_state state)\n{\n\treturn cpuhp_get_step(state)->teardown.single;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&cpuhp_state_mutex"
          ],
          "line": 2111
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpus_read_lock",
          "args": [],
          "line": 2110
        },
        "resolved": true,
        "details": {
          "function_name": "cpus_read_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "307-310",
          "snippet": "void cpus_read_lock(void)\n{\n\tpercpu_down_read(&cpu_hotplug_lock);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nvoid cpus_read_lock(void)\n{\n\tpercpu_down_read(&cpu_hotplug_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "cpuhp_cb_check(state)"
          ],
          "line": 2105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpuhp_cb_check",
          "args": [
            "state"
          ],
          "line": 2105
        },
        "resolved": true,
        "details": {
          "function_name": "cpuhp_cb_check",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "1813-1818",
          "snippet": "static int cpuhp_cb_check(enum cpuhp_state state)\n{\n\tif (state <= CPUHP_OFFLINE || state >= CPUHP_ONLINE)\n\t\treturn -EINVAL;\n\treturn 0;\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\n\nstatic int cpuhp_cb_check(enum cpuhp_state state)\n{\n\tif (state <= CPUHP_OFFLINE || state >= CPUHP_ONLINE)\n\t\treturn -EINVAL;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpuhp_get_step",
          "args": [
            "state"
          ],
          "line": 2102
        },
        "resolved": true,
        "details": {
          "function_name": "cpuhp_get_step",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "144-147",
          "snippet": "static struct cpuhp_step *cpuhp_get_step(enum cpuhp_state state)\n{\n\treturn cpuhp_hp_states + state;\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};",
            "static struct cpuhp_step cpuhp_hp_states[];",
            "static struct cpuhp_step cpuhp_hp_states[] = {\n\t[CPUHP_OFFLINE] = {\n\t\t.name\t\t\t= \"offline\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= NULL,\n\t},\n#ifdef CONFIG_SMP\n\t[CPUHP_CREATE_THREADS]= {\n\t\t.name\t\t\t= \"threads:prepare\",\n\t\t.startup.single\t\t= smpboot_create_threads,\n\t\t.teardown.single\t= NULL,\n\t\t.cant_stop\t\t= true,\n\t},\n\t[CPUHP_PERF_PREPARE] = {\n\t\t.name\t\t\t= \"perf:prepare\",\n\t\t.startup.single\t\t= perf_event_init_cpu,\n\t\t.teardown.single\t= perf_event_exit_cpu,\n\t},\n\t[CPUHP_WORKQUEUE_PREP] = {\n\t\t.name\t\t\t= \"workqueue:prepare\",\n\t\t.startup.single\t\t= workqueue_prepare_cpu,\n\t\t.teardown.single\t= NULL,\n\t},\n\t[CPUHP_HRTIMERS_PREPARE] = {\n\t\t.name\t\t\t= \"hrtimers:prepare\",\n\t\t.startup.single\t\t= hrtimers_prepare_cpu,\n\t\t.teardown.single\t= hrtimers_dead_cpu,\n\t},\n\t[CPUHP_SMPCFD_PREPARE] = {\n\t\t.name\t\t\t= \"smpcfd:prepare\",\n\t\t.startup.single\t\t= smpcfd_prepare_cpu,\n\t\t.teardown.single\t= smpcfd_dead_cpu,\n\t},\n\t[CPUHP_RELAY_PREPARE] = {\n\t\t.name\t\t\t= \"relay:prepare\",\n\t\t.startup.single\t\t= relay_prepare_cpu,\n\t\t.teardown.single\t= NULL,\n\t},\n\t[CPUHP_SLAB_PREPARE] = {\n\t\t.name\t\t\t= \"slab:prepare\",\n\t\t.startup.single\t\t= slab_prepare_cpu,\n\t\t.teardown.single\t= slab_dead_cpu,\n\t},\n\t[CPUHP_RCUTREE_PREP] = {\n\t\t.name\t\t\t= \"RCU/tree:prepare\",\n\t\t.startup.single\t\t= rcutree_prepare_cpu,\n\t\t.teardown.single\t= rcutree_dead_cpu,\n\t},\n\t/*\n\t * On the tear-down path, timers_dead_cpu() must be invoked\n\t * before blk_mq_queue_reinit_notify() from notify_dead(),\n\t * otherwise a RCU stall occurs.\n\t */\n\t[CPUHP_TIMERS_PREPARE] = {\n\t\t.name\t\t\t= \"timers:prepare\",\n\t\t.startup.single\t\t= timers_prepare_cpu,\n\t\t.teardown.single\t= timers_dead_cpu,\n\t},\n\t/* Kicks the plugged cpu into life */\n\t[CPUHP_BRINGUP_CPU] = {\n\t\t.name\t\t\t= \"cpu:bringup\",\n\t\t.startup.single\t\t= bringup_cpu,\n\t\t.teardown.single\t= finish_cpu,\n\t\t.cant_stop\t\t= true,\n\t},\n\t/* Final state before CPU kills itself */\n\t[CPUHP_AP_IDLE_DEAD] = {\n\t\t.name\t\t\t= \"idle:dead\",\n\t},\n\t/*\n\t * Last state before CPU enters the idle loop to die. Transient state\n\t * for synchronization.\n\t */\n\t[CPUHP_AP_OFFLINE] = {\n\t\t.name\t\t\t= \"ap:offline\",\n\t\t.cant_stop\t\t= true,\n\t},\n\t/* First state is scheduler control. Interrupts are disabled */\n\t[CPUHP_AP_SCHED_STARTING] = {\n\t\t.name\t\t\t= \"sched:starting\",\n\t\t.startup.single\t\t= sched_cpu_starting,\n\t\t.teardown.single\t= sched_cpu_dying,\n\t},\n\t[CPUHP_AP_RCUTREE_DYING] = {\n\t\t.name\t\t\t= \"RCU/tree:dying\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= rcutree_dying_cpu,\n\t},\n\t[CPUHP_AP_SMPCFD_DYING] = {\n\t\t.name\t\t\t= \"smpcfd:dying\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= smpcfd_dying_cpu,\n\t},\n\t/* Entry state on starting. Interrupts enabled from here on. Transient\n\t * state for synchronsization */\n\t[CPUHP_AP_ONLINE] = {\n\t\t.name\t\t\t= \"ap:online\",\n\t},\n\t/*\n\t * Handled on control processor until the plugged processor manages\n\t * this itself.\n\t */\n\t[CPUHP_TEARDOWN_CPU] = {\n\t\t.name\t\t\t= \"cpu:teardown\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= takedown_cpu,\n\t\t.cant_stop\t\t= true,\n\t},\n\n\t[CPUHP_AP_SCHED_WAIT_EMPTY] = {\n\t\t.name\t\t\t= \"sched:waitempty\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= sched_cpu_wait_empty,\n\t},\n\n\t/* Handle smpboot threads park/unpark */\n\t[CPUHP_AP_SMPBOOT_THREADS] = {\n\t\t.name\t\t\t= \"smpboot/threads:online\",\n\t\t.startup.single\t\t= smpboot_unpark_threads,\n\t\t.teardown.single\t= smpboot_park_threads,\n\t},\n\t[CPUHP_AP_IRQ_AFFINITY_ONLINE] = {\n\t\t.name\t\t\t= \"irq/affinity:online\",\n\t\t.startup.single\t\t= irq_affinity_online_cpu,\n\t\t.teardown.single\t= NULL,\n\t},\n\t[CPUHP_AP_PERF_ONLINE] = {\n\t\t.name\t\t\t= \"perf:online\",\n\t\t.startup.single\t\t= perf_event_init_cpu,\n\t\t.teardown.single\t= perf_event_exit_cpu,\n\t},\n\t[CPUHP_AP_WATCHDOG_ONLINE] = {\n\t\t.name\t\t\t= \"lockup_detector:online\",\n\t\t.startup.single\t\t= lockup_detector_online_cpu,\n\t\t.teardown.single\t= lockup_detector_offline_cpu,\n\t},\n\t[CPUHP_AP_WORKQUEUE_ONLINE] = {\n\t\t.name\t\t\t= \"workqueue:online\",\n\t\t.startup.single\t\t= workqueue_online_cpu,\n\t\t.teardown.single\t= workqueue_offline_cpu,\n\t},\n\t[CPUHP_AP_RCUTREE_ONLINE] = {\n\t\t.name\t\t\t= \"RCU/tree:online\",\n\t\t.startup.single\t\t= rcutree_online_cpu,\n\t\t.teardown.single\t= rcutree_offline_cpu,\n\t},\n#endif\n\t/*\n\t * The dynamically registered state space is here\n\t */\n\n#ifdef CONFIG_SMP\n\t/* Last state is scheduler control setting the cpu active */\n\t[CPUHP_AP_ACTIVE] = {\n\t\t.name\t\t\t= \"sched:active\",\n\t\t.startup.single\t\t= sched_cpu_activate,\n\t\t.teardown.single\t= sched_cpu_deactivate,\n\t},\n#endif\n\n\t/* CPU is fully up and running. */\n\t[CPUHP_ONLINE] = {\n\t\t.name\t\t\t= \"online\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= NULL,\n\t},\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\nstatic struct cpuhp_step cpuhp_hp_states[];\nstatic struct cpuhp_step cpuhp_hp_states[] = {\n\t[CPUHP_OFFLINE] = {\n\t\t.name\t\t\t= \"offline\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= NULL,\n\t},\n#ifdef CONFIG_SMP\n\t[CPUHP_CREATE_THREADS]= {\n\t\t.name\t\t\t= \"threads:prepare\",\n\t\t.startup.single\t\t= smpboot_create_threads,\n\t\t.teardown.single\t= NULL,\n\t\t.cant_stop\t\t= true,\n\t},\n\t[CPUHP_PERF_PREPARE] = {\n\t\t.name\t\t\t= \"perf:prepare\",\n\t\t.startup.single\t\t= perf_event_init_cpu,\n\t\t.teardown.single\t= perf_event_exit_cpu,\n\t},\n\t[CPUHP_WORKQUEUE_PREP] = {\n\t\t.name\t\t\t= \"workqueue:prepare\",\n\t\t.startup.single\t\t= workqueue_prepare_cpu,\n\t\t.teardown.single\t= NULL,\n\t},\n\t[CPUHP_HRTIMERS_PREPARE] = {\n\t\t.name\t\t\t= \"hrtimers:prepare\",\n\t\t.startup.single\t\t= hrtimers_prepare_cpu,\n\t\t.teardown.single\t= hrtimers_dead_cpu,\n\t},\n\t[CPUHP_SMPCFD_PREPARE] = {\n\t\t.name\t\t\t= \"smpcfd:prepare\",\n\t\t.startup.single\t\t= smpcfd_prepare_cpu,\n\t\t.teardown.single\t= smpcfd_dead_cpu,\n\t},\n\t[CPUHP_RELAY_PREPARE] = {\n\t\t.name\t\t\t= \"relay:prepare\",\n\t\t.startup.single\t\t= relay_prepare_cpu,\n\t\t.teardown.single\t= NULL,\n\t},\n\t[CPUHP_SLAB_PREPARE] = {\n\t\t.name\t\t\t= \"slab:prepare\",\n\t\t.startup.single\t\t= slab_prepare_cpu,\n\t\t.teardown.single\t= slab_dead_cpu,\n\t},\n\t[CPUHP_RCUTREE_PREP] = {\n\t\t.name\t\t\t= \"RCU/tree:prepare\",\n\t\t.startup.single\t\t= rcutree_prepare_cpu,\n\t\t.teardown.single\t= rcutree_dead_cpu,\n\t},\n\t/*\n\t * On the tear-down path, timers_dead_cpu() must be invoked\n\t * before blk_mq_queue_reinit_notify() from notify_dead(),\n\t * otherwise a RCU stall occurs.\n\t */\n\t[CPUHP_TIMERS_PREPARE] = {\n\t\t.name\t\t\t= \"timers:prepare\",\n\t\t.startup.single\t\t= timers_prepare_cpu,\n\t\t.teardown.single\t= timers_dead_cpu,\n\t},\n\t/* Kicks the plugged cpu into life */\n\t[CPUHP_BRINGUP_CPU] = {\n\t\t.name\t\t\t= \"cpu:bringup\",\n\t\t.startup.single\t\t= bringup_cpu,\n\t\t.teardown.single\t= finish_cpu,\n\t\t.cant_stop\t\t= true,\n\t},\n\t/* Final state before CPU kills itself */\n\t[CPUHP_AP_IDLE_DEAD] = {\n\t\t.name\t\t\t= \"idle:dead\",\n\t},\n\t/*\n\t * Last state before CPU enters the idle loop to die. Transient state\n\t * for synchronization.\n\t */\n\t[CPUHP_AP_OFFLINE] = {\n\t\t.name\t\t\t= \"ap:offline\",\n\t\t.cant_stop\t\t= true,\n\t},\n\t/* First state is scheduler control. Interrupts are disabled */\n\t[CPUHP_AP_SCHED_STARTING] = {\n\t\t.name\t\t\t= \"sched:starting\",\n\t\t.startup.single\t\t= sched_cpu_starting,\n\t\t.teardown.single\t= sched_cpu_dying,\n\t},\n\t[CPUHP_AP_RCUTREE_DYING] = {\n\t\t.name\t\t\t= \"RCU/tree:dying\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= rcutree_dying_cpu,\n\t},\n\t[CPUHP_AP_SMPCFD_DYING] = {\n\t\t.name\t\t\t= \"smpcfd:dying\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= smpcfd_dying_cpu,\n\t},\n\t/* Entry state on starting. Interrupts enabled from here on. Transient\n\t * state for synchronsization */\n\t[CPUHP_AP_ONLINE] = {\n\t\t.name\t\t\t= \"ap:online\",\n\t},\n\t/*\n\t * Handled on control processor until the plugged processor manages\n\t * this itself.\n\t */\n\t[CPUHP_TEARDOWN_CPU] = {\n\t\t.name\t\t\t= \"cpu:teardown\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= takedown_cpu,\n\t\t.cant_stop\t\t= true,\n\t},\n\n\t[CPUHP_AP_SCHED_WAIT_EMPTY] = {\n\t\t.name\t\t\t= \"sched:waitempty\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= sched_cpu_wait_empty,\n\t},\n\n\t/* Handle smpboot threads park/unpark */\n\t[CPUHP_AP_SMPBOOT_THREADS] = {\n\t\t.name\t\t\t= \"smpboot/threads:online\",\n\t\t.startup.single\t\t= smpboot_unpark_threads,\n\t\t.teardown.single\t= smpboot_park_threads,\n\t},\n\t[CPUHP_AP_IRQ_AFFINITY_ONLINE] = {\n\t\t.name\t\t\t= \"irq/affinity:online\",\n\t\t.startup.single\t\t= irq_affinity_online_cpu,\n\t\t.teardown.single\t= NULL,\n\t},\n\t[CPUHP_AP_PERF_ONLINE] = {\n\t\t.name\t\t\t= \"perf:online\",\n\t\t.startup.single\t\t= perf_event_init_cpu,\n\t\t.teardown.single\t= perf_event_exit_cpu,\n\t},\n\t[CPUHP_AP_WATCHDOG_ONLINE] = {\n\t\t.name\t\t\t= \"lockup_detector:online\",\n\t\t.startup.single\t\t= lockup_detector_online_cpu,\n\t\t.teardown.single\t= lockup_detector_offline_cpu,\n\t},\n\t[CPUHP_AP_WORKQUEUE_ONLINE] = {\n\t\t.name\t\t\t= \"workqueue:online\",\n\t\t.startup.single\t\t= workqueue_online_cpu,\n\t\t.teardown.single\t= workqueue_offline_cpu,\n\t},\n\t[CPUHP_AP_RCUTREE_ONLINE] = {\n\t\t.name\t\t\t= \"RCU/tree:online\",\n\t\t.startup.single\t\t= rcutree_online_cpu,\n\t\t.teardown.single\t= rcutree_offline_cpu,\n\t},\n#endif\n\t/*\n\t * The dynamically registered state space is here\n\t */\n\n#ifdef CONFIG_SMP\n\t/* Last state is scheduler control setting the cpu active */\n\t[CPUHP_AP_ACTIVE] = {\n\t\t.name\t\t\t= \"sched:active\",\n\t\t.startup.single\t\t= sched_cpu_activate,\n\t\t.teardown.single\t= sched_cpu_deactivate,\n\t},\n#endif\n\n\t/* CPU is fully up and running. */\n\t[CPUHP_ONLINE] = {\n\t\t.name\t\t\t= \"online\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= NULL,\n\t},\n};\n\nstatic struct cpuhp_step *cpuhp_get_step(enum cpuhp_state state)\n{\n\treturn cpuhp_hp_states + state;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\nstatic DEFINE_MUTEX(cpuhp_state_mutex);\n\nint __cpuhp_state_remove_instance(enum cpuhp_state state,\n\t\t\t\t  struct hlist_node *node, bool invoke)\n{\n\tstruct cpuhp_step *sp = cpuhp_get_step(state);\n\tint cpu;\n\n\tBUG_ON(cpuhp_cb_check(state));\n\n\tif (!sp->multi_instance)\n\t\treturn -EINVAL;\n\n\tcpus_read_lock();\n\tmutex_lock(&cpuhp_state_mutex);\n\n\tif (!invoke || !cpuhp_get_teardown_cb(state))\n\t\tgoto remove;\n\t/*\n\t * Call the teardown callback for each present cpu depending\n\t * on the hotplug state of the cpu. This function is not\n\t * allowed to fail currently!\n\t */\n\tfor_each_present_cpu(cpu) {\n\t\tstruct cpuhp_cpu_state *st = per_cpu_ptr(&cpuhp_state, cpu);\n\t\tint cpustate = st->state;\n\n\t\tif (cpustate >= state)\n\t\t\tcpuhp_issue_call(cpu, state, false, node);\n\t}\n\nremove:\n\thlist_del(node);\n\tmutex_unlock(&cpuhp_state_mutex);\n\tcpus_read_unlock();\n\n\treturn 0;\n}"
  },
  {
    "function_name": "__cpuhp_setup_state",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
    "lines": "2083-2096",
    "snippet": "int __cpuhp_setup_state(enum cpuhp_state state,\n\t\t\tconst char *name, bool invoke,\n\t\t\tint (*startup)(unsigned int cpu),\n\t\t\tint (*teardown)(unsigned int cpu),\n\t\t\tbool multi_instance)\n{\n\tint ret;\n\n\tcpus_read_lock();\n\tret = __cpuhp_setup_state_cpuslocked(state, name, invoke, startup,\n\t\t\t\t\t     teardown, multi_instance);\n\tcpus_read_unlock();\n\treturn ret;\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/scs.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sched/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpus_read_unlock",
          "args": [],
          "line": 2094
        },
        "resolved": true,
        "details": {
          "function_name": "cpus_read_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "319-322",
          "snippet": "void cpus_read_unlock(void)\n{\n\tpercpu_up_read(&cpu_hotplug_lock);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nvoid cpus_read_unlock(void)\n{\n\tpercpu_up_read(&cpu_hotplug_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__cpuhp_setup_state_cpuslocked",
          "args": [
            "state",
            "name",
            "invoke",
            "startup",
            "teardown",
            "multi_instance"
          ],
          "line": 2092
        },
        "resolved": true,
        "details": {
          "function_name": "__cpuhp_setup_state_cpuslocked",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "2024-2080",
          "snippet": "int __cpuhp_setup_state_cpuslocked(enum cpuhp_state state,\n\t\t\t\t   const char *name, bool invoke,\n\t\t\t\t   int (*startup)(unsigned int cpu),\n\t\t\t\t   int (*teardown)(unsigned int cpu),\n\t\t\t\t   bool multi_instance)\n{\n\tint cpu, ret = 0;\n\tbool dynstate;\n\n\tlockdep_assert_cpus_held();\n\n\tif (cpuhp_cb_check(state) || !name)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&cpuhp_state_mutex);\n\n\tret = cpuhp_store_callbacks(state, name, startup, teardown,\n\t\t\t\t    multi_instance);\n\n\tdynstate = state == CPUHP_AP_ONLINE_DYN;\n\tif (ret > 0 && dynstate) {\n\t\tstate = ret;\n\t\tret = 0;\n\t}\n\n\tif (ret || !invoke || !startup)\n\t\tgoto out;\n\n\t/*\n\t * Try to call the startup callback for each present cpu\n\t * depending on the hotplug state of the cpu.\n\t */\n\tfor_each_present_cpu(cpu) {\n\t\tstruct cpuhp_cpu_state *st = per_cpu_ptr(&cpuhp_state, cpu);\n\t\tint cpustate = st->state;\n\n\t\tif (cpustate < state)\n\t\t\tcontinue;\n\n\t\tret = cpuhp_issue_call(cpu, state, true, NULL);\n\t\tif (ret) {\n\t\t\tif (teardown)\n\t\t\t\tcpuhp_rollback_install(cpu, state, NULL);\n\t\t\tcpuhp_store_callbacks(state, NULL, NULL, NULL, false);\n\t\t\tgoto out;\n\t\t}\n\t}\nout:\n\tmutex_unlock(&cpuhp_state_mutex);\n\t/*\n\t * If the requested state is CPUHP_AP_ONLINE_DYN, return the\n\t * dynamically allocated state in case of success.\n\t */\n\tif (!ret && dynstate)\n\t\treturn state;\n\treturn ret;\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};",
            "static DEFINE_MUTEX(cpuhp_state_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\nstatic DEFINE_MUTEX(cpuhp_state_mutex);\n\nint __cpuhp_setup_state_cpuslocked(enum cpuhp_state state,\n\t\t\t\t   const char *name, bool invoke,\n\t\t\t\t   int (*startup)(unsigned int cpu),\n\t\t\t\t   int (*teardown)(unsigned int cpu),\n\t\t\t\t   bool multi_instance)\n{\n\tint cpu, ret = 0;\n\tbool dynstate;\n\n\tlockdep_assert_cpus_held();\n\n\tif (cpuhp_cb_check(state) || !name)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&cpuhp_state_mutex);\n\n\tret = cpuhp_store_callbacks(state, name, startup, teardown,\n\t\t\t\t    multi_instance);\n\n\tdynstate = state == CPUHP_AP_ONLINE_DYN;\n\tif (ret > 0 && dynstate) {\n\t\tstate = ret;\n\t\tret = 0;\n\t}\n\n\tif (ret || !invoke || !startup)\n\t\tgoto out;\n\n\t/*\n\t * Try to call the startup callback for each present cpu\n\t * depending on the hotplug state of the cpu.\n\t */\n\tfor_each_present_cpu(cpu) {\n\t\tstruct cpuhp_cpu_state *st = per_cpu_ptr(&cpuhp_state, cpu);\n\t\tint cpustate = st->state;\n\n\t\tif (cpustate < state)\n\t\t\tcontinue;\n\n\t\tret = cpuhp_issue_call(cpu, state, true, NULL);\n\t\tif (ret) {\n\t\t\tif (teardown)\n\t\t\t\tcpuhp_rollback_install(cpu, state, NULL);\n\t\t\tcpuhp_store_callbacks(state, NULL, NULL, NULL, false);\n\t\t\tgoto out;\n\t\t}\n\t}\nout:\n\tmutex_unlock(&cpuhp_state_mutex);\n\t/*\n\t * If the requested state is CPUHP_AP_ONLINE_DYN, return the\n\t * dynamically allocated state in case of success.\n\t */\n\tif (!ret && dynstate)\n\t\treturn state;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpus_read_lock",
          "args": [],
          "line": 2091
        },
        "resolved": true,
        "details": {
          "function_name": "cpus_read_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "307-310",
          "snippet": "void cpus_read_lock(void)\n{\n\tpercpu_down_read(&cpu_hotplug_lock);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nvoid cpus_read_lock(void)\n{\n\tpercpu_down_read(&cpu_hotplug_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\n\nint __cpuhp_setup_state(enum cpuhp_state state,\n\t\t\tconst char *name, bool invoke,\n\t\t\tint (*startup)(unsigned int cpu),\n\t\t\tint (*teardown)(unsigned int cpu),\n\t\t\tbool multi_instance)\n{\n\tint ret;\n\n\tcpus_read_lock();\n\tret = __cpuhp_setup_state_cpuslocked(state, name, invoke, startup,\n\t\t\t\t\t     teardown, multi_instance);\n\tcpus_read_unlock();\n\treturn ret;\n}"
  },
  {
    "function_name": "__cpuhp_setup_state_cpuslocked",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
    "lines": "2024-2080",
    "snippet": "int __cpuhp_setup_state_cpuslocked(enum cpuhp_state state,\n\t\t\t\t   const char *name, bool invoke,\n\t\t\t\t   int (*startup)(unsigned int cpu),\n\t\t\t\t   int (*teardown)(unsigned int cpu),\n\t\t\t\t   bool multi_instance)\n{\n\tint cpu, ret = 0;\n\tbool dynstate;\n\n\tlockdep_assert_cpus_held();\n\n\tif (cpuhp_cb_check(state) || !name)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&cpuhp_state_mutex);\n\n\tret = cpuhp_store_callbacks(state, name, startup, teardown,\n\t\t\t\t    multi_instance);\n\n\tdynstate = state == CPUHP_AP_ONLINE_DYN;\n\tif (ret > 0 && dynstate) {\n\t\tstate = ret;\n\t\tret = 0;\n\t}\n\n\tif (ret || !invoke || !startup)\n\t\tgoto out;\n\n\t/*\n\t * Try to call the startup callback for each present cpu\n\t * depending on the hotplug state of the cpu.\n\t */\n\tfor_each_present_cpu(cpu) {\n\t\tstruct cpuhp_cpu_state *st = per_cpu_ptr(&cpuhp_state, cpu);\n\t\tint cpustate = st->state;\n\n\t\tif (cpustate < state)\n\t\t\tcontinue;\n\n\t\tret = cpuhp_issue_call(cpu, state, true, NULL);\n\t\tif (ret) {\n\t\t\tif (teardown)\n\t\t\t\tcpuhp_rollback_install(cpu, state, NULL);\n\t\t\tcpuhp_store_callbacks(state, NULL, NULL, NULL, false);\n\t\t\tgoto out;\n\t\t}\n\t}\nout:\n\tmutex_unlock(&cpuhp_state_mutex);\n\t/*\n\t * If the requested state is CPUHP_AP_ONLINE_DYN, return the\n\t * dynamically allocated state in case of success.\n\t */\n\tif (!ret && dynstate)\n\t\treturn state;\n\treturn ret;\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/scs.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sched/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};",
      "static DEFINE_MUTEX(cpuhp_state_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&cpuhp_state_mutex"
          ],
          "line": 2072
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpuhp_store_callbacks",
          "args": [
            "state",
            "NULL",
            "NULL",
            "NULL",
            "false"
          ],
          "line": 2067
        },
        "resolved": true,
        "details": {
          "function_name": "cpuhp_store_callbacks",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "1851-1886",
          "snippet": "static int cpuhp_store_callbacks(enum cpuhp_state state, const char *name,\n\t\t\t\t int (*startup)(unsigned int cpu),\n\t\t\t\t int (*teardown)(unsigned int cpu),\n\t\t\t\t bool multi_instance)\n{\n\t/* (Un)Install the callbacks for further cpu hotplug operations */\n\tstruct cpuhp_step *sp;\n\tint ret = 0;\n\n\t/*\n\t * If name is NULL, then the state gets removed.\n\t *\n\t * CPUHP_AP_ONLINE_DYN and CPUHP_BP_PREPARE_DYN are handed out on\n\t * the first allocation from these dynamic ranges, so the removal\n\t * would trigger a new allocation and clear the wrong (already\n\t * empty) state, leaving the callbacks of the to be cleared state\n\t * dangling, which causes wreckage on the next hotplug operation.\n\t */\n\tif (name && (state == CPUHP_AP_ONLINE_DYN ||\n\t\t     state == CPUHP_BP_PREPARE_DYN)) {\n\t\tret = cpuhp_reserve_state(state);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tstate = ret;\n\t}\n\tsp = cpuhp_get_step(state);\n\tif (name && sp->name)\n\t\treturn -EBUSY;\n\n\tsp->startup.single = startup;\n\tsp->teardown.single = teardown;\n\tsp->name = name;\n\tsp->multi_instance = multi_instance;\n\tINIT_HLIST_HEAD(&sp->list);\n\treturn ret;\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\n\nstatic int cpuhp_store_callbacks(enum cpuhp_state state, const char *name,\n\t\t\t\t int (*startup)(unsigned int cpu),\n\t\t\t\t int (*teardown)(unsigned int cpu),\n\t\t\t\t bool multi_instance)\n{\n\t/* (Un)Install the callbacks for further cpu hotplug operations */\n\tstruct cpuhp_step *sp;\n\tint ret = 0;\n\n\t/*\n\t * If name is NULL, then the state gets removed.\n\t *\n\t * CPUHP_AP_ONLINE_DYN and CPUHP_BP_PREPARE_DYN are handed out on\n\t * the first allocation from these dynamic ranges, so the removal\n\t * would trigger a new allocation and clear the wrong (already\n\t * empty) state, leaving the callbacks of the to be cleared state\n\t * dangling, which causes wreckage on the next hotplug operation.\n\t */\n\tif (name && (state == CPUHP_AP_ONLINE_DYN ||\n\t\t     state == CPUHP_BP_PREPARE_DYN)) {\n\t\tret = cpuhp_reserve_state(state);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tstate = ret;\n\t}\n\tsp = cpuhp_get_step(state);\n\tif (name && sp->name)\n\t\treturn -EBUSY;\n\n\tsp->startup.single = startup;\n\tsp->teardown.single = teardown;\n\tsp->name = name;\n\tsp->multi_instance = multi_instance;\n\tINIT_HLIST_HEAD(&sp->list);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpuhp_rollback_install",
          "args": [
            "cpu",
            "state",
            "NULL"
          ],
          "line": 2066
        },
        "resolved": true,
        "details": {
          "function_name": "cpuhp_rollback_install",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "1930-1947",
          "snippet": "static void cpuhp_rollback_install(int failedcpu, enum cpuhp_state state,\n\t\t\t\t   struct hlist_node *node)\n{\n\tint cpu;\n\n\t/* Roll back the already executed steps on the other cpus */\n\tfor_each_present_cpu(cpu) {\n\t\tstruct cpuhp_cpu_state *st = per_cpu_ptr(&cpuhp_state, cpu);\n\t\tint cpustate = st->state;\n\n\t\tif (cpu >= failedcpu)\n\t\t\tbreak;\n\n\t\t/* Did we invoke the startup call on that cpu ? */\n\t\tif (cpustate >= state)\n\t\t\tcpuhp_issue_call(cpu, state, false, node);\n\t}\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\n\nstatic void cpuhp_rollback_install(int failedcpu, enum cpuhp_state state,\n\t\t\t\t   struct hlist_node *node)\n{\n\tint cpu;\n\n\t/* Roll back the already executed steps on the other cpus */\n\tfor_each_present_cpu(cpu) {\n\t\tstruct cpuhp_cpu_state *st = per_cpu_ptr(&cpuhp_state, cpu);\n\t\tint cpustate = st->state;\n\n\t\tif (cpu >= failedcpu)\n\t\t\tbreak;\n\n\t\t/* Did we invoke the startup call on that cpu ? */\n\t\tif (cpustate >= state)\n\t\t\tcpuhp_issue_call(cpu, state, false, node);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpuhp_issue_call",
          "args": [
            "cpu",
            "state",
            "true",
            "NULL"
          ],
          "line": 2063
        },
        "resolved": true,
        "details": {
          "function_name": "cpuhp_issue_call",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "1897-1923",
          "snippet": "static int cpuhp_issue_call(int cpu, enum cpuhp_state state, bool bringup,\n\t\t\t    struct hlist_node *node)\n{\n\tstruct cpuhp_step *sp = cpuhp_get_step(state);\n\tint ret;\n\n\t/*\n\t * If there's nothing to do, we done.\n\t * Relies on the union for multi_instance.\n\t */\n\tif (cpuhp_step_empty(bringup, sp))\n\t\treturn 0;\n\t/*\n\t * The non AP bound callbacks can fail on bringup. On teardown\n\t * e.g. module removal we crash for now.\n\t */\n#ifdef CONFIG_SMP\n\tif (cpuhp_is_ap_state(state))\n\t\tret = cpuhp_invoke_ap_callback(cpu, state, bringup, node);\n\telse\n\t\tret = cpuhp_invoke_callback(cpu, state, bringup, node, NULL);\n#else\n\tret = cpuhp_invoke_callback(cpu, state, bringup, node, NULL);\n#endif\n\tBUG_ON(ret && !bringup);\n\treturn ret;\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\n\nstatic int cpuhp_issue_call(int cpu, enum cpuhp_state state, bool bringup,\n\t\t\t    struct hlist_node *node)\n{\n\tstruct cpuhp_step *sp = cpuhp_get_step(state);\n\tint ret;\n\n\t/*\n\t * If there's nothing to do, we done.\n\t * Relies on the union for multi_instance.\n\t */\n\tif (cpuhp_step_empty(bringup, sp))\n\t\treturn 0;\n\t/*\n\t * The non AP bound callbacks can fail on bringup. On teardown\n\t * e.g. module removal we crash for now.\n\t */\n#ifdef CONFIG_SMP\n\tif (cpuhp_is_ap_state(state))\n\t\tret = cpuhp_invoke_ap_callback(cpu, state, bringup, node);\n\telse\n\t\tret = cpuhp_invoke_callback(cpu, state, bringup, node, NULL);\n#else\n\tret = cpuhp_invoke_callback(cpu, state, bringup, node, NULL);\n#endif\n\tBUG_ON(ret && !bringup);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "&cpuhp_state",
            "cpu"
          ],
          "line": 2057
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&cpuhp_state_mutex"
          ],
          "line": 2038
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpuhp_cb_check",
          "args": [
            "state"
          ],
          "line": 2035
        },
        "resolved": true,
        "details": {
          "function_name": "cpuhp_cb_check",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "1813-1818",
          "snippet": "static int cpuhp_cb_check(enum cpuhp_state state)\n{\n\tif (state <= CPUHP_OFFLINE || state >= CPUHP_ONLINE)\n\t\treturn -EINVAL;\n\treturn 0;\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\n\nstatic int cpuhp_cb_check(enum cpuhp_state state)\n{\n\tif (state <= CPUHP_OFFLINE || state >= CPUHP_ONLINE)\n\t\treturn -EINVAL;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_assert_cpus_held",
          "args": [],
          "line": 2033
        },
        "resolved": true,
        "details": {
          "function_name": "lockdep_assert_cpus_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "335-347",
          "snippet": "void lockdep_assert_cpus_held(void)\n{\n\t/*\n\t * We can't have hotplug operations before userspace starts running,\n\t * and some init codepaths will knowingly not take the hotplug lock.\n\t * This is all valid, so mute lockdep until it makes sense to report\n\t * unheld locks.\n\t */\n\tif (system_state < SYSTEM_RUNNING)\n\t\treturn;\n\n\tpercpu_rwsem_assert_held(&cpu_hotplug_lock);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nvoid lockdep_assert_cpus_held(void)\n{\n\t/*\n\t * We can't have hotplug operations before userspace starts running,\n\t * and some init codepaths will knowingly not take the hotplug lock.\n\t * This is all valid, so mute lockdep until it makes sense to report\n\t * unheld locks.\n\t */\n\tif (system_state < SYSTEM_RUNNING)\n\t\treturn;\n\n\tpercpu_rwsem_assert_held(&cpu_hotplug_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\nstatic DEFINE_MUTEX(cpuhp_state_mutex);\n\nint __cpuhp_setup_state_cpuslocked(enum cpuhp_state state,\n\t\t\t\t   const char *name, bool invoke,\n\t\t\t\t   int (*startup)(unsigned int cpu),\n\t\t\t\t   int (*teardown)(unsigned int cpu),\n\t\t\t\t   bool multi_instance)\n{\n\tint cpu, ret = 0;\n\tbool dynstate;\n\n\tlockdep_assert_cpus_held();\n\n\tif (cpuhp_cb_check(state) || !name)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&cpuhp_state_mutex);\n\n\tret = cpuhp_store_callbacks(state, name, startup, teardown,\n\t\t\t\t    multi_instance);\n\n\tdynstate = state == CPUHP_AP_ONLINE_DYN;\n\tif (ret > 0 && dynstate) {\n\t\tstate = ret;\n\t\tret = 0;\n\t}\n\n\tif (ret || !invoke || !startup)\n\t\tgoto out;\n\n\t/*\n\t * Try to call the startup callback for each present cpu\n\t * depending on the hotplug state of the cpu.\n\t */\n\tfor_each_present_cpu(cpu) {\n\t\tstruct cpuhp_cpu_state *st = per_cpu_ptr(&cpuhp_state, cpu);\n\t\tint cpustate = st->state;\n\n\t\tif (cpustate < state)\n\t\t\tcontinue;\n\n\t\tret = cpuhp_issue_call(cpu, state, true, NULL);\n\t\tif (ret) {\n\t\t\tif (teardown)\n\t\t\t\tcpuhp_rollback_install(cpu, state, NULL);\n\t\t\tcpuhp_store_callbacks(state, NULL, NULL, NULL, false);\n\t\t\tgoto out;\n\t\t}\n\t}\nout:\n\tmutex_unlock(&cpuhp_state_mutex);\n\t/*\n\t * If the requested state is CPUHP_AP_ONLINE_DYN, return the\n\t * dynamically allocated state in case of success.\n\t */\n\tif (!ret && dynstate)\n\t\treturn state;\n\treturn ret;\n}"
  },
  {
    "function_name": "__cpuhp_state_add_instance",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
    "lines": "1994-2003",
    "snippet": "int __cpuhp_state_add_instance(enum cpuhp_state state, struct hlist_node *node,\n\t\t\t       bool invoke)\n{\n\tint ret;\n\n\tcpus_read_lock();\n\tret = __cpuhp_state_add_instance_cpuslocked(state, node, invoke);\n\tcpus_read_unlock();\n\treturn ret;\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/scs.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sched/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpus_read_unlock",
          "args": [],
          "line": 2001
        },
        "resolved": true,
        "details": {
          "function_name": "cpus_read_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "319-322",
          "snippet": "void cpus_read_unlock(void)\n{\n\tpercpu_up_read(&cpu_hotplug_lock);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nvoid cpus_read_unlock(void)\n{\n\tpercpu_up_read(&cpu_hotplug_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__cpuhp_state_add_instance_cpuslocked",
          "args": [
            "state",
            "node",
            "invoke"
          ],
          "line": 2000
        },
        "resolved": true,
        "details": {
          "function_name": "__cpuhp_state_add_instance_cpuslocked",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "1949-1992",
          "snippet": "int __cpuhp_state_add_instance_cpuslocked(enum cpuhp_state state,\n\t\t\t\t\t  struct hlist_node *node,\n\t\t\t\t\t  bool invoke)\n{\n\tstruct cpuhp_step *sp;\n\tint cpu;\n\tint ret;\n\n\tlockdep_assert_cpus_held();\n\n\tsp = cpuhp_get_step(state);\n\tif (sp->multi_instance == false)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&cpuhp_state_mutex);\n\n\tif (!invoke || !sp->startup.multi)\n\t\tgoto add_node;\n\n\t/*\n\t * Try to call the startup callback for each present cpu\n\t * depending on the hotplug state of the cpu.\n\t */\n\tfor_each_present_cpu(cpu) {\n\t\tstruct cpuhp_cpu_state *st = per_cpu_ptr(&cpuhp_state, cpu);\n\t\tint cpustate = st->state;\n\n\t\tif (cpustate < state)\n\t\t\tcontinue;\n\n\t\tret = cpuhp_issue_call(cpu, state, true, node);\n\t\tif (ret) {\n\t\t\tif (sp->teardown.multi)\n\t\t\t\tcpuhp_rollback_install(cpu, state, node);\n\t\t\tgoto unlock;\n\t\t}\n\t}\nadd_node:\n\tret = 0;\n\thlist_add_head(node, &sp->list);\nunlock:\n\tmutex_unlock(&cpuhp_state_mutex);\n\treturn ret;\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};",
            "static DEFINE_MUTEX(cpuhp_state_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\nstatic DEFINE_MUTEX(cpuhp_state_mutex);\n\nint __cpuhp_state_add_instance_cpuslocked(enum cpuhp_state state,\n\t\t\t\t\t  struct hlist_node *node,\n\t\t\t\t\t  bool invoke)\n{\n\tstruct cpuhp_step *sp;\n\tint cpu;\n\tint ret;\n\n\tlockdep_assert_cpus_held();\n\n\tsp = cpuhp_get_step(state);\n\tif (sp->multi_instance == false)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&cpuhp_state_mutex);\n\n\tif (!invoke || !sp->startup.multi)\n\t\tgoto add_node;\n\n\t/*\n\t * Try to call the startup callback for each present cpu\n\t * depending on the hotplug state of the cpu.\n\t */\n\tfor_each_present_cpu(cpu) {\n\t\tstruct cpuhp_cpu_state *st = per_cpu_ptr(&cpuhp_state, cpu);\n\t\tint cpustate = st->state;\n\n\t\tif (cpustate < state)\n\t\t\tcontinue;\n\n\t\tret = cpuhp_issue_call(cpu, state, true, node);\n\t\tif (ret) {\n\t\t\tif (sp->teardown.multi)\n\t\t\t\tcpuhp_rollback_install(cpu, state, node);\n\t\t\tgoto unlock;\n\t\t}\n\t}\nadd_node:\n\tret = 0;\n\thlist_add_head(node, &sp->list);\nunlock:\n\tmutex_unlock(&cpuhp_state_mutex);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpus_read_lock",
          "args": [],
          "line": 1999
        },
        "resolved": true,
        "details": {
          "function_name": "cpus_read_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "307-310",
          "snippet": "void cpus_read_lock(void)\n{\n\tpercpu_down_read(&cpu_hotplug_lock);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nvoid cpus_read_lock(void)\n{\n\tpercpu_down_read(&cpu_hotplug_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\n\nint __cpuhp_state_add_instance(enum cpuhp_state state, struct hlist_node *node,\n\t\t\t       bool invoke)\n{\n\tint ret;\n\n\tcpus_read_lock();\n\tret = __cpuhp_state_add_instance_cpuslocked(state, node, invoke);\n\tcpus_read_unlock();\n\treturn ret;\n}"
  },
  {
    "function_name": "__cpuhp_state_add_instance_cpuslocked",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
    "lines": "1949-1992",
    "snippet": "int __cpuhp_state_add_instance_cpuslocked(enum cpuhp_state state,\n\t\t\t\t\t  struct hlist_node *node,\n\t\t\t\t\t  bool invoke)\n{\n\tstruct cpuhp_step *sp;\n\tint cpu;\n\tint ret;\n\n\tlockdep_assert_cpus_held();\n\n\tsp = cpuhp_get_step(state);\n\tif (sp->multi_instance == false)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&cpuhp_state_mutex);\n\n\tif (!invoke || !sp->startup.multi)\n\t\tgoto add_node;\n\n\t/*\n\t * Try to call the startup callback for each present cpu\n\t * depending on the hotplug state of the cpu.\n\t */\n\tfor_each_present_cpu(cpu) {\n\t\tstruct cpuhp_cpu_state *st = per_cpu_ptr(&cpuhp_state, cpu);\n\t\tint cpustate = st->state;\n\n\t\tif (cpustate < state)\n\t\t\tcontinue;\n\n\t\tret = cpuhp_issue_call(cpu, state, true, node);\n\t\tif (ret) {\n\t\t\tif (sp->teardown.multi)\n\t\t\t\tcpuhp_rollback_install(cpu, state, node);\n\t\t\tgoto unlock;\n\t\t}\n\t}\nadd_node:\n\tret = 0;\n\thlist_add_head(node, &sp->list);\nunlock:\n\tmutex_unlock(&cpuhp_state_mutex);\n\treturn ret;\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/scs.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sched/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};",
      "static DEFINE_MUTEX(cpuhp_state_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&cpuhp_state_mutex"
          ],
          "line": 1990
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_add_head",
          "args": [
            "node",
            "&sp->list"
          ],
          "line": 1988
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpuhp_rollback_install",
          "args": [
            "cpu",
            "state",
            "node"
          ],
          "line": 1982
        },
        "resolved": true,
        "details": {
          "function_name": "cpuhp_rollback_install",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "1930-1947",
          "snippet": "static void cpuhp_rollback_install(int failedcpu, enum cpuhp_state state,\n\t\t\t\t   struct hlist_node *node)\n{\n\tint cpu;\n\n\t/* Roll back the already executed steps on the other cpus */\n\tfor_each_present_cpu(cpu) {\n\t\tstruct cpuhp_cpu_state *st = per_cpu_ptr(&cpuhp_state, cpu);\n\t\tint cpustate = st->state;\n\n\t\tif (cpu >= failedcpu)\n\t\t\tbreak;\n\n\t\t/* Did we invoke the startup call on that cpu ? */\n\t\tif (cpustate >= state)\n\t\t\tcpuhp_issue_call(cpu, state, false, node);\n\t}\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\n\nstatic void cpuhp_rollback_install(int failedcpu, enum cpuhp_state state,\n\t\t\t\t   struct hlist_node *node)\n{\n\tint cpu;\n\n\t/* Roll back the already executed steps on the other cpus */\n\tfor_each_present_cpu(cpu) {\n\t\tstruct cpuhp_cpu_state *st = per_cpu_ptr(&cpuhp_state, cpu);\n\t\tint cpustate = st->state;\n\n\t\tif (cpu >= failedcpu)\n\t\t\tbreak;\n\n\t\t/* Did we invoke the startup call on that cpu ? */\n\t\tif (cpustate >= state)\n\t\t\tcpuhp_issue_call(cpu, state, false, node);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpuhp_issue_call",
          "args": [
            "cpu",
            "state",
            "true",
            "node"
          ],
          "line": 1979
        },
        "resolved": true,
        "details": {
          "function_name": "cpuhp_issue_call",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "1897-1923",
          "snippet": "static int cpuhp_issue_call(int cpu, enum cpuhp_state state, bool bringup,\n\t\t\t    struct hlist_node *node)\n{\n\tstruct cpuhp_step *sp = cpuhp_get_step(state);\n\tint ret;\n\n\t/*\n\t * If there's nothing to do, we done.\n\t * Relies on the union for multi_instance.\n\t */\n\tif (cpuhp_step_empty(bringup, sp))\n\t\treturn 0;\n\t/*\n\t * The non AP bound callbacks can fail on bringup. On teardown\n\t * e.g. module removal we crash for now.\n\t */\n#ifdef CONFIG_SMP\n\tif (cpuhp_is_ap_state(state))\n\t\tret = cpuhp_invoke_ap_callback(cpu, state, bringup, node);\n\telse\n\t\tret = cpuhp_invoke_callback(cpu, state, bringup, node, NULL);\n#else\n\tret = cpuhp_invoke_callback(cpu, state, bringup, node, NULL);\n#endif\n\tBUG_ON(ret && !bringup);\n\treturn ret;\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\n\nstatic int cpuhp_issue_call(int cpu, enum cpuhp_state state, bool bringup,\n\t\t\t    struct hlist_node *node)\n{\n\tstruct cpuhp_step *sp = cpuhp_get_step(state);\n\tint ret;\n\n\t/*\n\t * If there's nothing to do, we done.\n\t * Relies on the union for multi_instance.\n\t */\n\tif (cpuhp_step_empty(bringup, sp))\n\t\treturn 0;\n\t/*\n\t * The non AP bound callbacks can fail on bringup. On teardown\n\t * e.g. module removal we crash for now.\n\t */\n#ifdef CONFIG_SMP\n\tif (cpuhp_is_ap_state(state))\n\t\tret = cpuhp_invoke_ap_callback(cpu, state, bringup, node);\n\telse\n\t\tret = cpuhp_invoke_callback(cpu, state, bringup, node, NULL);\n#else\n\tret = cpuhp_invoke_callback(cpu, state, bringup, node, NULL);\n#endif\n\tBUG_ON(ret && !bringup);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "&cpuhp_state",
            "cpu"
          ],
          "line": 1973
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&cpuhp_state_mutex"
          ],
          "line": 1963
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpuhp_get_step",
          "args": [
            "state"
          ],
          "line": 1959
        },
        "resolved": true,
        "details": {
          "function_name": "cpuhp_get_step",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "144-147",
          "snippet": "static struct cpuhp_step *cpuhp_get_step(enum cpuhp_state state)\n{\n\treturn cpuhp_hp_states + state;\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};",
            "static struct cpuhp_step cpuhp_hp_states[];",
            "static struct cpuhp_step cpuhp_hp_states[] = {\n\t[CPUHP_OFFLINE] = {\n\t\t.name\t\t\t= \"offline\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= NULL,\n\t},\n#ifdef CONFIG_SMP\n\t[CPUHP_CREATE_THREADS]= {\n\t\t.name\t\t\t= \"threads:prepare\",\n\t\t.startup.single\t\t= smpboot_create_threads,\n\t\t.teardown.single\t= NULL,\n\t\t.cant_stop\t\t= true,\n\t},\n\t[CPUHP_PERF_PREPARE] = {\n\t\t.name\t\t\t= \"perf:prepare\",\n\t\t.startup.single\t\t= perf_event_init_cpu,\n\t\t.teardown.single\t= perf_event_exit_cpu,\n\t},\n\t[CPUHP_WORKQUEUE_PREP] = {\n\t\t.name\t\t\t= \"workqueue:prepare\",\n\t\t.startup.single\t\t= workqueue_prepare_cpu,\n\t\t.teardown.single\t= NULL,\n\t},\n\t[CPUHP_HRTIMERS_PREPARE] = {\n\t\t.name\t\t\t= \"hrtimers:prepare\",\n\t\t.startup.single\t\t= hrtimers_prepare_cpu,\n\t\t.teardown.single\t= hrtimers_dead_cpu,\n\t},\n\t[CPUHP_SMPCFD_PREPARE] = {\n\t\t.name\t\t\t= \"smpcfd:prepare\",\n\t\t.startup.single\t\t= smpcfd_prepare_cpu,\n\t\t.teardown.single\t= smpcfd_dead_cpu,\n\t},\n\t[CPUHP_RELAY_PREPARE] = {\n\t\t.name\t\t\t= \"relay:prepare\",\n\t\t.startup.single\t\t= relay_prepare_cpu,\n\t\t.teardown.single\t= NULL,\n\t},\n\t[CPUHP_SLAB_PREPARE] = {\n\t\t.name\t\t\t= \"slab:prepare\",\n\t\t.startup.single\t\t= slab_prepare_cpu,\n\t\t.teardown.single\t= slab_dead_cpu,\n\t},\n\t[CPUHP_RCUTREE_PREP] = {\n\t\t.name\t\t\t= \"RCU/tree:prepare\",\n\t\t.startup.single\t\t= rcutree_prepare_cpu,\n\t\t.teardown.single\t= rcutree_dead_cpu,\n\t},\n\t/*\n\t * On the tear-down path, timers_dead_cpu() must be invoked\n\t * before blk_mq_queue_reinit_notify() from notify_dead(),\n\t * otherwise a RCU stall occurs.\n\t */\n\t[CPUHP_TIMERS_PREPARE] = {\n\t\t.name\t\t\t= \"timers:prepare\",\n\t\t.startup.single\t\t= timers_prepare_cpu,\n\t\t.teardown.single\t= timers_dead_cpu,\n\t},\n\t/* Kicks the plugged cpu into life */\n\t[CPUHP_BRINGUP_CPU] = {\n\t\t.name\t\t\t= \"cpu:bringup\",\n\t\t.startup.single\t\t= bringup_cpu,\n\t\t.teardown.single\t= finish_cpu,\n\t\t.cant_stop\t\t= true,\n\t},\n\t/* Final state before CPU kills itself */\n\t[CPUHP_AP_IDLE_DEAD] = {\n\t\t.name\t\t\t= \"idle:dead\",\n\t},\n\t/*\n\t * Last state before CPU enters the idle loop to die. Transient state\n\t * for synchronization.\n\t */\n\t[CPUHP_AP_OFFLINE] = {\n\t\t.name\t\t\t= \"ap:offline\",\n\t\t.cant_stop\t\t= true,\n\t},\n\t/* First state is scheduler control. Interrupts are disabled */\n\t[CPUHP_AP_SCHED_STARTING] = {\n\t\t.name\t\t\t= \"sched:starting\",\n\t\t.startup.single\t\t= sched_cpu_starting,\n\t\t.teardown.single\t= sched_cpu_dying,\n\t},\n\t[CPUHP_AP_RCUTREE_DYING] = {\n\t\t.name\t\t\t= \"RCU/tree:dying\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= rcutree_dying_cpu,\n\t},\n\t[CPUHP_AP_SMPCFD_DYING] = {\n\t\t.name\t\t\t= \"smpcfd:dying\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= smpcfd_dying_cpu,\n\t},\n\t/* Entry state on starting. Interrupts enabled from here on. Transient\n\t * state for synchronsization */\n\t[CPUHP_AP_ONLINE] = {\n\t\t.name\t\t\t= \"ap:online\",\n\t},\n\t/*\n\t * Handled on control processor until the plugged processor manages\n\t * this itself.\n\t */\n\t[CPUHP_TEARDOWN_CPU] = {\n\t\t.name\t\t\t= \"cpu:teardown\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= takedown_cpu,\n\t\t.cant_stop\t\t= true,\n\t},\n\n\t[CPUHP_AP_SCHED_WAIT_EMPTY] = {\n\t\t.name\t\t\t= \"sched:waitempty\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= sched_cpu_wait_empty,\n\t},\n\n\t/* Handle smpboot threads park/unpark */\n\t[CPUHP_AP_SMPBOOT_THREADS] = {\n\t\t.name\t\t\t= \"smpboot/threads:online\",\n\t\t.startup.single\t\t= smpboot_unpark_threads,\n\t\t.teardown.single\t= smpboot_park_threads,\n\t},\n\t[CPUHP_AP_IRQ_AFFINITY_ONLINE] = {\n\t\t.name\t\t\t= \"irq/affinity:online\",\n\t\t.startup.single\t\t= irq_affinity_online_cpu,\n\t\t.teardown.single\t= NULL,\n\t},\n\t[CPUHP_AP_PERF_ONLINE] = {\n\t\t.name\t\t\t= \"perf:online\",\n\t\t.startup.single\t\t= perf_event_init_cpu,\n\t\t.teardown.single\t= perf_event_exit_cpu,\n\t},\n\t[CPUHP_AP_WATCHDOG_ONLINE] = {\n\t\t.name\t\t\t= \"lockup_detector:online\",\n\t\t.startup.single\t\t= lockup_detector_online_cpu,\n\t\t.teardown.single\t= lockup_detector_offline_cpu,\n\t},\n\t[CPUHP_AP_WORKQUEUE_ONLINE] = {\n\t\t.name\t\t\t= \"workqueue:online\",\n\t\t.startup.single\t\t= workqueue_online_cpu,\n\t\t.teardown.single\t= workqueue_offline_cpu,\n\t},\n\t[CPUHP_AP_RCUTREE_ONLINE] = {\n\t\t.name\t\t\t= \"RCU/tree:online\",\n\t\t.startup.single\t\t= rcutree_online_cpu,\n\t\t.teardown.single\t= rcutree_offline_cpu,\n\t},\n#endif\n\t/*\n\t * The dynamically registered state space is here\n\t */\n\n#ifdef CONFIG_SMP\n\t/* Last state is scheduler control setting the cpu active */\n\t[CPUHP_AP_ACTIVE] = {\n\t\t.name\t\t\t= \"sched:active\",\n\t\t.startup.single\t\t= sched_cpu_activate,\n\t\t.teardown.single\t= sched_cpu_deactivate,\n\t},\n#endif\n\n\t/* CPU is fully up and running. */\n\t[CPUHP_ONLINE] = {\n\t\t.name\t\t\t= \"online\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= NULL,\n\t},\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\nstatic struct cpuhp_step cpuhp_hp_states[];\nstatic struct cpuhp_step cpuhp_hp_states[] = {\n\t[CPUHP_OFFLINE] = {\n\t\t.name\t\t\t= \"offline\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= NULL,\n\t},\n#ifdef CONFIG_SMP\n\t[CPUHP_CREATE_THREADS]= {\n\t\t.name\t\t\t= \"threads:prepare\",\n\t\t.startup.single\t\t= smpboot_create_threads,\n\t\t.teardown.single\t= NULL,\n\t\t.cant_stop\t\t= true,\n\t},\n\t[CPUHP_PERF_PREPARE] = {\n\t\t.name\t\t\t= \"perf:prepare\",\n\t\t.startup.single\t\t= perf_event_init_cpu,\n\t\t.teardown.single\t= perf_event_exit_cpu,\n\t},\n\t[CPUHP_WORKQUEUE_PREP] = {\n\t\t.name\t\t\t= \"workqueue:prepare\",\n\t\t.startup.single\t\t= workqueue_prepare_cpu,\n\t\t.teardown.single\t= NULL,\n\t},\n\t[CPUHP_HRTIMERS_PREPARE] = {\n\t\t.name\t\t\t= \"hrtimers:prepare\",\n\t\t.startup.single\t\t= hrtimers_prepare_cpu,\n\t\t.teardown.single\t= hrtimers_dead_cpu,\n\t},\n\t[CPUHP_SMPCFD_PREPARE] = {\n\t\t.name\t\t\t= \"smpcfd:prepare\",\n\t\t.startup.single\t\t= smpcfd_prepare_cpu,\n\t\t.teardown.single\t= smpcfd_dead_cpu,\n\t},\n\t[CPUHP_RELAY_PREPARE] = {\n\t\t.name\t\t\t= \"relay:prepare\",\n\t\t.startup.single\t\t= relay_prepare_cpu,\n\t\t.teardown.single\t= NULL,\n\t},\n\t[CPUHP_SLAB_PREPARE] = {\n\t\t.name\t\t\t= \"slab:prepare\",\n\t\t.startup.single\t\t= slab_prepare_cpu,\n\t\t.teardown.single\t= slab_dead_cpu,\n\t},\n\t[CPUHP_RCUTREE_PREP] = {\n\t\t.name\t\t\t= \"RCU/tree:prepare\",\n\t\t.startup.single\t\t= rcutree_prepare_cpu,\n\t\t.teardown.single\t= rcutree_dead_cpu,\n\t},\n\t/*\n\t * On the tear-down path, timers_dead_cpu() must be invoked\n\t * before blk_mq_queue_reinit_notify() from notify_dead(),\n\t * otherwise a RCU stall occurs.\n\t */\n\t[CPUHP_TIMERS_PREPARE] = {\n\t\t.name\t\t\t= \"timers:prepare\",\n\t\t.startup.single\t\t= timers_prepare_cpu,\n\t\t.teardown.single\t= timers_dead_cpu,\n\t},\n\t/* Kicks the plugged cpu into life */\n\t[CPUHP_BRINGUP_CPU] = {\n\t\t.name\t\t\t= \"cpu:bringup\",\n\t\t.startup.single\t\t= bringup_cpu,\n\t\t.teardown.single\t= finish_cpu,\n\t\t.cant_stop\t\t= true,\n\t},\n\t/* Final state before CPU kills itself */\n\t[CPUHP_AP_IDLE_DEAD] = {\n\t\t.name\t\t\t= \"idle:dead\",\n\t},\n\t/*\n\t * Last state before CPU enters the idle loop to die. Transient state\n\t * for synchronization.\n\t */\n\t[CPUHP_AP_OFFLINE] = {\n\t\t.name\t\t\t= \"ap:offline\",\n\t\t.cant_stop\t\t= true,\n\t},\n\t/* First state is scheduler control. Interrupts are disabled */\n\t[CPUHP_AP_SCHED_STARTING] = {\n\t\t.name\t\t\t= \"sched:starting\",\n\t\t.startup.single\t\t= sched_cpu_starting,\n\t\t.teardown.single\t= sched_cpu_dying,\n\t},\n\t[CPUHP_AP_RCUTREE_DYING] = {\n\t\t.name\t\t\t= \"RCU/tree:dying\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= rcutree_dying_cpu,\n\t},\n\t[CPUHP_AP_SMPCFD_DYING] = {\n\t\t.name\t\t\t= \"smpcfd:dying\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= smpcfd_dying_cpu,\n\t},\n\t/* Entry state on starting. Interrupts enabled from here on. Transient\n\t * state for synchronsization */\n\t[CPUHP_AP_ONLINE] = {\n\t\t.name\t\t\t= \"ap:online\",\n\t},\n\t/*\n\t * Handled on control processor until the plugged processor manages\n\t * this itself.\n\t */\n\t[CPUHP_TEARDOWN_CPU] = {\n\t\t.name\t\t\t= \"cpu:teardown\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= takedown_cpu,\n\t\t.cant_stop\t\t= true,\n\t},\n\n\t[CPUHP_AP_SCHED_WAIT_EMPTY] = {\n\t\t.name\t\t\t= \"sched:waitempty\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= sched_cpu_wait_empty,\n\t},\n\n\t/* Handle smpboot threads park/unpark */\n\t[CPUHP_AP_SMPBOOT_THREADS] = {\n\t\t.name\t\t\t= \"smpboot/threads:online\",\n\t\t.startup.single\t\t= smpboot_unpark_threads,\n\t\t.teardown.single\t= smpboot_park_threads,\n\t},\n\t[CPUHP_AP_IRQ_AFFINITY_ONLINE] = {\n\t\t.name\t\t\t= \"irq/affinity:online\",\n\t\t.startup.single\t\t= irq_affinity_online_cpu,\n\t\t.teardown.single\t= NULL,\n\t},\n\t[CPUHP_AP_PERF_ONLINE] = {\n\t\t.name\t\t\t= \"perf:online\",\n\t\t.startup.single\t\t= perf_event_init_cpu,\n\t\t.teardown.single\t= perf_event_exit_cpu,\n\t},\n\t[CPUHP_AP_WATCHDOG_ONLINE] = {\n\t\t.name\t\t\t= \"lockup_detector:online\",\n\t\t.startup.single\t\t= lockup_detector_online_cpu,\n\t\t.teardown.single\t= lockup_detector_offline_cpu,\n\t},\n\t[CPUHP_AP_WORKQUEUE_ONLINE] = {\n\t\t.name\t\t\t= \"workqueue:online\",\n\t\t.startup.single\t\t= workqueue_online_cpu,\n\t\t.teardown.single\t= workqueue_offline_cpu,\n\t},\n\t[CPUHP_AP_RCUTREE_ONLINE] = {\n\t\t.name\t\t\t= \"RCU/tree:online\",\n\t\t.startup.single\t\t= rcutree_online_cpu,\n\t\t.teardown.single\t= rcutree_offline_cpu,\n\t},\n#endif\n\t/*\n\t * The dynamically registered state space is here\n\t */\n\n#ifdef CONFIG_SMP\n\t/* Last state is scheduler control setting the cpu active */\n\t[CPUHP_AP_ACTIVE] = {\n\t\t.name\t\t\t= \"sched:active\",\n\t\t.startup.single\t\t= sched_cpu_activate,\n\t\t.teardown.single\t= sched_cpu_deactivate,\n\t},\n#endif\n\n\t/* CPU is fully up and running. */\n\t[CPUHP_ONLINE] = {\n\t\t.name\t\t\t= \"online\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= NULL,\n\t},\n};\n\nstatic struct cpuhp_step *cpuhp_get_step(enum cpuhp_state state)\n{\n\treturn cpuhp_hp_states + state;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_assert_cpus_held",
          "args": [],
          "line": 1957
        },
        "resolved": true,
        "details": {
          "function_name": "lockdep_assert_cpus_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "335-347",
          "snippet": "void lockdep_assert_cpus_held(void)\n{\n\t/*\n\t * We can't have hotplug operations before userspace starts running,\n\t * and some init codepaths will knowingly not take the hotplug lock.\n\t * This is all valid, so mute lockdep until it makes sense to report\n\t * unheld locks.\n\t */\n\tif (system_state < SYSTEM_RUNNING)\n\t\treturn;\n\n\tpercpu_rwsem_assert_held(&cpu_hotplug_lock);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nvoid lockdep_assert_cpus_held(void)\n{\n\t/*\n\t * We can't have hotplug operations before userspace starts running,\n\t * and some init codepaths will knowingly not take the hotplug lock.\n\t * This is all valid, so mute lockdep until it makes sense to report\n\t * unheld locks.\n\t */\n\tif (system_state < SYSTEM_RUNNING)\n\t\treturn;\n\n\tpercpu_rwsem_assert_held(&cpu_hotplug_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\nstatic DEFINE_MUTEX(cpuhp_state_mutex);\n\nint __cpuhp_state_add_instance_cpuslocked(enum cpuhp_state state,\n\t\t\t\t\t  struct hlist_node *node,\n\t\t\t\t\t  bool invoke)\n{\n\tstruct cpuhp_step *sp;\n\tint cpu;\n\tint ret;\n\n\tlockdep_assert_cpus_held();\n\n\tsp = cpuhp_get_step(state);\n\tif (sp->multi_instance == false)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&cpuhp_state_mutex);\n\n\tif (!invoke || !sp->startup.multi)\n\t\tgoto add_node;\n\n\t/*\n\t * Try to call the startup callback for each present cpu\n\t * depending on the hotplug state of the cpu.\n\t */\n\tfor_each_present_cpu(cpu) {\n\t\tstruct cpuhp_cpu_state *st = per_cpu_ptr(&cpuhp_state, cpu);\n\t\tint cpustate = st->state;\n\n\t\tif (cpustate < state)\n\t\t\tcontinue;\n\n\t\tret = cpuhp_issue_call(cpu, state, true, node);\n\t\tif (ret) {\n\t\t\tif (sp->teardown.multi)\n\t\t\t\tcpuhp_rollback_install(cpu, state, node);\n\t\t\tgoto unlock;\n\t\t}\n\t}\nadd_node:\n\tret = 0;\n\thlist_add_head(node, &sp->list);\nunlock:\n\tmutex_unlock(&cpuhp_state_mutex);\n\treturn ret;\n}"
  },
  {
    "function_name": "cpuhp_rollback_install",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
    "lines": "1930-1947",
    "snippet": "static void cpuhp_rollback_install(int failedcpu, enum cpuhp_state state,\n\t\t\t\t   struct hlist_node *node)\n{\n\tint cpu;\n\n\t/* Roll back the already executed steps on the other cpus */\n\tfor_each_present_cpu(cpu) {\n\t\tstruct cpuhp_cpu_state *st = per_cpu_ptr(&cpuhp_state, cpu);\n\t\tint cpustate = st->state;\n\n\t\tif (cpu >= failedcpu)\n\t\t\tbreak;\n\n\t\t/* Did we invoke the startup call on that cpu ? */\n\t\tif (cpustate >= state)\n\t\t\tcpuhp_issue_call(cpu, state, false, node);\n\t}\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/scs.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sched/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpuhp_issue_call",
          "args": [
            "cpu",
            "state",
            "false",
            "node"
          ],
          "line": 1945
        },
        "resolved": true,
        "details": {
          "function_name": "cpuhp_issue_call",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "1897-1923",
          "snippet": "static int cpuhp_issue_call(int cpu, enum cpuhp_state state, bool bringup,\n\t\t\t    struct hlist_node *node)\n{\n\tstruct cpuhp_step *sp = cpuhp_get_step(state);\n\tint ret;\n\n\t/*\n\t * If there's nothing to do, we done.\n\t * Relies on the union for multi_instance.\n\t */\n\tif (cpuhp_step_empty(bringup, sp))\n\t\treturn 0;\n\t/*\n\t * The non AP bound callbacks can fail on bringup. On teardown\n\t * e.g. module removal we crash for now.\n\t */\n#ifdef CONFIG_SMP\n\tif (cpuhp_is_ap_state(state))\n\t\tret = cpuhp_invoke_ap_callback(cpu, state, bringup, node);\n\telse\n\t\tret = cpuhp_invoke_callback(cpu, state, bringup, node, NULL);\n#else\n\tret = cpuhp_invoke_callback(cpu, state, bringup, node, NULL);\n#endif\n\tBUG_ON(ret && !bringup);\n\treturn ret;\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\n\nstatic int cpuhp_issue_call(int cpu, enum cpuhp_state state, bool bringup,\n\t\t\t    struct hlist_node *node)\n{\n\tstruct cpuhp_step *sp = cpuhp_get_step(state);\n\tint ret;\n\n\t/*\n\t * If there's nothing to do, we done.\n\t * Relies on the union for multi_instance.\n\t */\n\tif (cpuhp_step_empty(bringup, sp))\n\t\treturn 0;\n\t/*\n\t * The non AP bound callbacks can fail on bringup. On teardown\n\t * e.g. module removal we crash for now.\n\t */\n#ifdef CONFIG_SMP\n\tif (cpuhp_is_ap_state(state))\n\t\tret = cpuhp_invoke_ap_callback(cpu, state, bringup, node);\n\telse\n\t\tret = cpuhp_invoke_callback(cpu, state, bringup, node, NULL);\n#else\n\tret = cpuhp_invoke_callback(cpu, state, bringup, node, NULL);\n#endif\n\tBUG_ON(ret && !bringup);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "&cpuhp_state",
            "cpu"
          ],
          "line": 1937
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\n\nstatic void cpuhp_rollback_install(int failedcpu, enum cpuhp_state state,\n\t\t\t\t   struct hlist_node *node)\n{\n\tint cpu;\n\n\t/* Roll back the already executed steps on the other cpus */\n\tfor_each_present_cpu(cpu) {\n\t\tstruct cpuhp_cpu_state *st = per_cpu_ptr(&cpuhp_state, cpu);\n\t\tint cpustate = st->state;\n\n\t\tif (cpu >= failedcpu)\n\t\t\tbreak;\n\n\t\t/* Did we invoke the startup call on that cpu ? */\n\t\tif (cpustate >= state)\n\t\t\tcpuhp_issue_call(cpu, state, false, node);\n\t}\n}"
  },
  {
    "function_name": "cpuhp_issue_call",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
    "lines": "1897-1923",
    "snippet": "static int cpuhp_issue_call(int cpu, enum cpuhp_state state, bool bringup,\n\t\t\t    struct hlist_node *node)\n{\n\tstruct cpuhp_step *sp = cpuhp_get_step(state);\n\tint ret;\n\n\t/*\n\t * If there's nothing to do, we done.\n\t * Relies on the union for multi_instance.\n\t */\n\tif (cpuhp_step_empty(bringup, sp))\n\t\treturn 0;\n\t/*\n\t * The non AP bound callbacks can fail on bringup. On teardown\n\t * e.g. module removal we crash for now.\n\t */\n#ifdef CONFIG_SMP\n\tif (cpuhp_is_ap_state(state))\n\t\tret = cpuhp_invoke_ap_callback(cpu, state, bringup, node);\n\telse\n\t\tret = cpuhp_invoke_callback(cpu, state, bringup, node, NULL);\n#else\n\tret = cpuhp_invoke_callback(cpu, state, bringup, node, NULL);\n#endif\n\tBUG_ON(ret && !bringup);\n\treturn ret;\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/scs.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sched/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ret && !bringup"
          ],
          "line": 1921
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpuhp_invoke_callback",
          "args": [
            "cpu",
            "state",
            "bringup",
            "node",
            "NULL"
          ],
          "line": 1919
        },
        "resolved": true,
        "details": {
          "function_name": "cpuhp_invoke_callback",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "166-246",
          "snippet": "static int cpuhp_invoke_callback(unsigned int cpu, enum cpuhp_state state,\n\t\t\t\t bool bringup, struct hlist_node *node,\n\t\t\t\t struct hlist_node **lastp)\n{\n\tstruct cpuhp_cpu_state *st = per_cpu_ptr(&cpuhp_state, cpu);\n\tstruct cpuhp_step *step = cpuhp_get_step(state);\n\tint (*cbm)(unsigned int cpu, struct hlist_node *node);\n\tint (*cb)(unsigned int cpu);\n\tint ret, cnt;\n\n\tif (st->fail == state) {\n\t\tst->fail = CPUHP_INVALID;\n\t\treturn -EAGAIN;\n\t}\n\n\tif (cpuhp_step_empty(bringup, step)) {\n\t\tWARN_ON_ONCE(1);\n\t\treturn 0;\n\t}\n\n\tif (!step->multi_instance) {\n\t\tWARN_ON_ONCE(lastp && *lastp);\n\t\tcb = bringup ? step->startup.single : step->teardown.single;\n\n\t\ttrace_cpuhp_enter(cpu, st->target, state, cb);\n\t\tret = cb(cpu);\n\t\ttrace_cpuhp_exit(cpu, st->state, state, ret);\n\t\treturn ret;\n\t}\n\tcbm = bringup ? step->startup.multi : step->teardown.multi;\n\n\t/* Single invocation for instance add/remove */\n\tif (node) {\n\t\tWARN_ON_ONCE(lastp && *lastp);\n\t\ttrace_cpuhp_multi_enter(cpu, st->target, state, cbm, node);\n\t\tret = cbm(cpu, node);\n\t\ttrace_cpuhp_exit(cpu, st->state, state, ret);\n\t\treturn ret;\n\t}\n\n\t/* State transition. Invoke on all instances */\n\tcnt = 0;\n\thlist_for_each(node, &step->list) {\n\t\tif (lastp && node == *lastp)\n\t\t\tbreak;\n\n\t\ttrace_cpuhp_multi_enter(cpu, st->target, state, cbm, node);\n\t\tret = cbm(cpu, node);\n\t\ttrace_cpuhp_exit(cpu, st->state, state, ret);\n\t\tif (ret) {\n\t\t\tif (!lastp)\n\t\t\t\tgoto err;\n\n\t\t\t*lastp = node;\n\t\t\treturn ret;\n\t\t}\n\t\tcnt++;\n\t}\n\tif (lastp)\n\t\t*lastp = NULL;\n\treturn 0;\nerr:\n\t/* Rollback the instances if one failed */\n\tcbm = !bringup ? step->startup.multi : step->teardown.multi;\n\tif (!cbm)\n\t\treturn ret;\n\n\thlist_for_each(node, &step->list) {\n\t\tif (!cnt--)\n\t\t\tbreak;\n\n\t\ttrace_cpuhp_multi_enter(cpu, st->target, state, cbm, node);\n\t\tret = cbm(cpu, node);\n\t\ttrace_cpuhp_exit(cpu, st->state, state, ret);\n\t\t/*\n\t\t * Rollback must not fail,\n\t\t */\n\t\tWARN_ON_ONCE(ret);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\n\nstatic int cpuhp_invoke_callback(unsigned int cpu, enum cpuhp_state state,\n\t\t\t\t bool bringup, struct hlist_node *node,\n\t\t\t\t struct hlist_node **lastp)\n{\n\tstruct cpuhp_cpu_state *st = per_cpu_ptr(&cpuhp_state, cpu);\n\tstruct cpuhp_step *step = cpuhp_get_step(state);\n\tint (*cbm)(unsigned int cpu, struct hlist_node *node);\n\tint (*cb)(unsigned int cpu);\n\tint ret, cnt;\n\n\tif (st->fail == state) {\n\t\tst->fail = CPUHP_INVALID;\n\t\treturn -EAGAIN;\n\t}\n\n\tif (cpuhp_step_empty(bringup, step)) {\n\t\tWARN_ON_ONCE(1);\n\t\treturn 0;\n\t}\n\n\tif (!step->multi_instance) {\n\t\tWARN_ON_ONCE(lastp && *lastp);\n\t\tcb = bringup ? step->startup.single : step->teardown.single;\n\n\t\ttrace_cpuhp_enter(cpu, st->target, state, cb);\n\t\tret = cb(cpu);\n\t\ttrace_cpuhp_exit(cpu, st->state, state, ret);\n\t\treturn ret;\n\t}\n\tcbm = bringup ? step->startup.multi : step->teardown.multi;\n\n\t/* Single invocation for instance add/remove */\n\tif (node) {\n\t\tWARN_ON_ONCE(lastp && *lastp);\n\t\ttrace_cpuhp_multi_enter(cpu, st->target, state, cbm, node);\n\t\tret = cbm(cpu, node);\n\t\ttrace_cpuhp_exit(cpu, st->state, state, ret);\n\t\treturn ret;\n\t}\n\n\t/* State transition. Invoke on all instances */\n\tcnt = 0;\n\thlist_for_each(node, &step->list) {\n\t\tif (lastp && node == *lastp)\n\t\t\tbreak;\n\n\t\ttrace_cpuhp_multi_enter(cpu, st->target, state, cbm, node);\n\t\tret = cbm(cpu, node);\n\t\ttrace_cpuhp_exit(cpu, st->state, state, ret);\n\t\tif (ret) {\n\t\t\tif (!lastp)\n\t\t\t\tgoto err;\n\n\t\t\t*lastp = node;\n\t\t\treturn ret;\n\t\t}\n\t\tcnt++;\n\t}\n\tif (lastp)\n\t\t*lastp = NULL;\n\treturn 0;\nerr:\n\t/* Rollback the instances if one failed */\n\tcbm = !bringup ? step->startup.multi : step->teardown.multi;\n\tif (!cbm)\n\t\treturn ret;\n\n\thlist_for_each(node, &step->list) {\n\t\tif (!cnt--)\n\t\t\tbreak;\n\n\t\ttrace_cpuhp_multi_enter(cpu, st->target, state, cbm, node);\n\t\tret = cbm(cpu, node);\n\t\ttrace_cpuhp_exit(cpu, st->state, state, ret);\n\t\t/*\n\t\t * Rollback must not fail,\n\t\t */\n\t\tWARN_ON_ONCE(ret);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpuhp_invoke_ap_callback",
          "args": [
            "cpu",
            "state",
            "bringup",
            "node"
          ],
          "line": 1915
        },
        "resolved": true,
        "details": {
          "function_name": "cpuhp_invoke_ap_callback",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "813-862",
          "snippet": "static int\ncpuhp_invoke_ap_callback(int cpu, enum cpuhp_state state, bool bringup,\n\t\t\t struct hlist_node *node)\n{\n\tstruct cpuhp_cpu_state *st = per_cpu_ptr(&cpuhp_state, cpu);\n\tint ret;\n\n\tif (!cpu_online(cpu))\n\t\treturn 0;\n\n\tcpuhp_lock_acquire(false);\n\tcpuhp_lock_release(false);\n\n\tcpuhp_lock_acquire(true);\n\tcpuhp_lock_release(true);\n\n\t/*\n\t * If we are up and running, use the hotplug thread. For early calls\n\t * we invoke the thread function directly.\n\t */\n\tif (!st->thread)\n\t\treturn cpuhp_invoke_callback(cpu, state, bringup, node, NULL);\n\n\tst->rollback = false;\n\tst->last = NULL;\n\n\tst->node = node;\n\tst->bringup = bringup;\n\tst->cb_state = state;\n\tst->single = true;\n\n\t__cpuhp_kick_ap(st);\n\n\t/*\n\t * If we failed and did a partial, do a rollback.\n\t */\n\tif ((ret = st->result) && st->last) {\n\t\tst->rollback = true;\n\t\tst->bringup = !bringup;\n\n\t\t__cpuhp_kick_ap(st);\n\t}\n\n\t/*\n\t * Clean up the leftovers so the next hotplug operation wont use stale\n\t * data.\n\t */\n\tst->node = st->last = NULL;\n\treturn ret;\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\n\nstatic int\ncpuhp_invoke_ap_callback(int cpu, enum cpuhp_state state, bool bringup,\n\t\t\t struct hlist_node *node)\n{\n\tstruct cpuhp_cpu_state *st = per_cpu_ptr(&cpuhp_state, cpu);\n\tint ret;\n\n\tif (!cpu_online(cpu))\n\t\treturn 0;\n\n\tcpuhp_lock_acquire(false);\n\tcpuhp_lock_release(false);\n\n\tcpuhp_lock_acquire(true);\n\tcpuhp_lock_release(true);\n\n\t/*\n\t * If we are up and running, use the hotplug thread. For early calls\n\t * we invoke the thread function directly.\n\t */\n\tif (!st->thread)\n\t\treturn cpuhp_invoke_callback(cpu, state, bringup, node, NULL);\n\n\tst->rollback = false;\n\tst->last = NULL;\n\n\tst->node = node;\n\tst->bringup = bringup;\n\tst->cb_state = state;\n\tst->single = true;\n\n\t__cpuhp_kick_ap(st);\n\n\t/*\n\t * If we failed and did a partial, do a rollback.\n\t */\n\tif ((ret = st->result) && st->last) {\n\t\tst->rollback = true;\n\t\tst->bringup = !bringup;\n\n\t\t__cpuhp_kick_ap(st);\n\t}\n\n\t/*\n\t * Clean up the leftovers so the next hotplug operation wont use stale\n\t * data.\n\t */\n\tst->node = st->last = NULL;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpuhp_is_ap_state",
          "args": [
            "state"
          ],
          "line": 1914
        },
        "resolved": true,
        "details": {
          "function_name": "cpuhp_is_ap_state",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "249-256",
          "snippet": "static bool cpuhp_is_ap_state(enum cpuhp_state state)\n{\n\t/*\n\t * The extra check for CPUHP_TEARDOWN_CPU is only for documentation\n\t * purposes as that state is handled explicitly in cpu_down.\n\t */\n\treturn state > CPUHP_BRINGUP_CPU && state != CPUHP_TEARDOWN_CPU;\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\n\nstatic bool cpuhp_is_ap_state(enum cpuhp_state state)\n{\n\t/*\n\t * The extra check for CPUHP_TEARDOWN_CPU is only for documentation\n\t * purposes as that state is handled explicitly in cpu_down.\n\t */\n\treturn state > CPUHP_BRINGUP_CPU && state != CPUHP_TEARDOWN_CPU;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpuhp_step_empty",
          "args": [
            "bringup",
            "sp"
          ],
          "line": 1907
        },
        "resolved": true,
        "details": {
          "function_name": "cpuhp_step_empty",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "149-152",
          "snippet": "static bool cpuhp_step_empty(bool bringup, struct cpuhp_step *step)\n{\n\treturn bringup ? !step->startup.single : !step->teardown.single;\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstatic bool cpuhp_step_empty(bool bringup, struct cpuhp_step *step)\n{\n\treturn bringup ? !step->startup.single : !step->teardown.single;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpuhp_get_step",
          "args": [
            "state"
          ],
          "line": 1900
        },
        "resolved": true,
        "details": {
          "function_name": "cpuhp_get_step",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "144-147",
          "snippet": "static struct cpuhp_step *cpuhp_get_step(enum cpuhp_state state)\n{\n\treturn cpuhp_hp_states + state;\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};",
            "static struct cpuhp_step cpuhp_hp_states[];",
            "static struct cpuhp_step cpuhp_hp_states[] = {\n\t[CPUHP_OFFLINE] = {\n\t\t.name\t\t\t= \"offline\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= NULL,\n\t},\n#ifdef CONFIG_SMP\n\t[CPUHP_CREATE_THREADS]= {\n\t\t.name\t\t\t= \"threads:prepare\",\n\t\t.startup.single\t\t= smpboot_create_threads,\n\t\t.teardown.single\t= NULL,\n\t\t.cant_stop\t\t= true,\n\t},\n\t[CPUHP_PERF_PREPARE] = {\n\t\t.name\t\t\t= \"perf:prepare\",\n\t\t.startup.single\t\t= perf_event_init_cpu,\n\t\t.teardown.single\t= perf_event_exit_cpu,\n\t},\n\t[CPUHP_WORKQUEUE_PREP] = {\n\t\t.name\t\t\t= \"workqueue:prepare\",\n\t\t.startup.single\t\t= workqueue_prepare_cpu,\n\t\t.teardown.single\t= NULL,\n\t},\n\t[CPUHP_HRTIMERS_PREPARE] = {\n\t\t.name\t\t\t= \"hrtimers:prepare\",\n\t\t.startup.single\t\t= hrtimers_prepare_cpu,\n\t\t.teardown.single\t= hrtimers_dead_cpu,\n\t},\n\t[CPUHP_SMPCFD_PREPARE] = {\n\t\t.name\t\t\t= \"smpcfd:prepare\",\n\t\t.startup.single\t\t= smpcfd_prepare_cpu,\n\t\t.teardown.single\t= smpcfd_dead_cpu,\n\t},\n\t[CPUHP_RELAY_PREPARE] = {\n\t\t.name\t\t\t= \"relay:prepare\",\n\t\t.startup.single\t\t= relay_prepare_cpu,\n\t\t.teardown.single\t= NULL,\n\t},\n\t[CPUHP_SLAB_PREPARE] = {\n\t\t.name\t\t\t= \"slab:prepare\",\n\t\t.startup.single\t\t= slab_prepare_cpu,\n\t\t.teardown.single\t= slab_dead_cpu,\n\t},\n\t[CPUHP_RCUTREE_PREP] = {\n\t\t.name\t\t\t= \"RCU/tree:prepare\",\n\t\t.startup.single\t\t= rcutree_prepare_cpu,\n\t\t.teardown.single\t= rcutree_dead_cpu,\n\t},\n\t/*\n\t * On the tear-down path, timers_dead_cpu() must be invoked\n\t * before blk_mq_queue_reinit_notify() from notify_dead(),\n\t * otherwise a RCU stall occurs.\n\t */\n\t[CPUHP_TIMERS_PREPARE] = {\n\t\t.name\t\t\t= \"timers:prepare\",\n\t\t.startup.single\t\t= timers_prepare_cpu,\n\t\t.teardown.single\t= timers_dead_cpu,\n\t},\n\t/* Kicks the plugged cpu into life */\n\t[CPUHP_BRINGUP_CPU] = {\n\t\t.name\t\t\t= \"cpu:bringup\",\n\t\t.startup.single\t\t= bringup_cpu,\n\t\t.teardown.single\t= finish_cpu,\n\t\t.cant_stop\t\t= true,\n\t},\n\t/* Final state before CPU kills itself */\n\t[CPUHP_AP_IDLE_DEAD] = {\n\t\t.name\t\t\t= \"idle:dead\",\n\t},\n\t/*\n\t * Last state before CPU enters the idle loop to die. Transient state\n\t * for synchronization.\n\t */\n\t[CPUHP_AP_OFFLINE] = {\n\t\t.name\t\t\t= \"ap:offline\",\n\t\t.cant_stop\t\t= true,\n\t},\n\t/* First state is scheduler control. Interrupts are disabled */\n\t[CPUHP_AP_SCHED_STARTING] = {\n\t\t.name\t\t\t= \"sched:starting\",\n\t\t.startup.single\t\t= sched_cpu_starting,\n\t\t.teardown.single\t= sched_cpu_dying,\n\t},\n\t[CPUHP_AP_RCUTREE_DYING] = {\n\t\t.name\t\t\t= \"RCU/tree:dying\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= rcutree_dying_cpu,\n\t},\n\t[CPUHP_AP_SMPCFD_DYING] = {\n\t\t.name\t\t\t= \"smpcfd:dying\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= smpcfd_dying_cpu,\n\t},\n\t/* Entry state on starting. Interrupts enabled from here on. Transient\n\t * state for synchronsization */\n\t[CPUHP_AP_ONLINE] = {\n\t\t.name\t\t\t= \"ap:online\",\n\t},\n\t/*\n\t * Handled on control processor until the plugged processor manages\n\t * this itself.\n\t */\n\t[CPUHP_TEARDOWN_CPU] = {\n\t\t.name\t\t\t= \"cpu:teardown\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= takedown_cpu,\n\t\t.cant_stop\t\t= true,\n\t},\n\n\t[CPUHP_AP_SCHED_WAIT_EMPTY] = {\n\t\t.name\t\t\t= \"sched:waitempty\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= sched_cpu_wait_empty,\n\t},\n\n\t/* Handle smpboot threads park/unpark */\n\t[CPUHP_AP_SMPBOOT_THREADS] = {\n\t\t.name\t\t\t= \"smpboot/threads:online\",\n\t\t.startup.single\t\t= smpboot_unpark_threads,\n\t\t.teardown.single\t= smpboot_park_threads,\n\t},\n\t[CPUHP_AP_IRQ_AFFINITY_ONLINE] = {\n\t\t.name\t\t\t= \"irq/affinity:online\",\n\t\t.startup.single\t\t= irq_affinity_online_cpu,\n\t\t.teardown.single\t= NULL,\n\t},\n\t[CPUHP_AP_PERF_ONLINE] = {\n\t\t.name\t\t\t= \"perf:online\",\n\t\t.startup.single\t\t= perf_event_init_cpu,\n\t\t.teardown.single\t= perf_event_exit_cpu,\n\t},\n\t[CPUHP_AP_WATCHDOG_ONLINE] = {\n\t\t.name\t\t\t= \"lockup_detector:online\",\n\t\t.startup.single\t\t= lockup_detector_online_cpu,\n\t\t.teardown.single\t= lockup_detector_offline_cpu,\n\t},\n\t[CPUHP_AP_WORKQUEUE_ONLINE] = {\n\t\t.name\t\t\t= \"workqueue:online\",\n\t\t.startup.single\t\t= workqueue_online_cpu,\n\t\t.teardown.single\t= workqueue_offline_cpu,\n\t},\n\t[CPUHP_AP_RCUTREE_ONLINE] = {\n\t\t.name\t\t\t= \"RCU/tree:online\",\n\t\t.startup.single\t\t= rcutree_online_cpu,\n\t\t.teardown.single\t= rcutree_offline_cpu,\n\t},\n#endif\n\t/*\n\t * The dynamically registered state space is here\n\t */\n\n#ifdef CONFIG_SMP\n\t/* Last state is scheduler control setting the cpu active */\n\t[CPUHP_AP_ACTIVE] = {\n\t\t.name\t\t\t= \"sched:active\",\n\t\t.startup.single\t\t= sched_cpu_activate,\n\t\t.teardown.single\t= sched_cpu_deactivate,\n\t},\n#endif\n\n\t/* CPU is fully up and running. */\n\t[CPUHP_ONLINE] = {\n\t\t.name\t\t\t= \"online\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= NULL,\n\t},\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\nstatic struct cpuhp_step cpuhp_hp_states[];\nstatic struct cpuhp_step cpuhp_hp_states[] = {\n\t[CPUHP_OFFLINE] = {\n\t\t.name\t\t\t= \"offline\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= NULL,\n\t},\n#ifdef CONFIG_SMP\n\t[CPUHP_CREATE_THREADS]= {\n\t\t.name\t\t\t= \"threads:prepare\",\n\t\t.startup.single\t\t= smpboot_create_threads,\n\t\t.teardown.single\t= NULL,\n\t\t.cant_stop\t\t= true,\n\t},\n\t[CPUHP_PERF_PREPARE] = {\n\t\t.name\t\t\t= \"perf:prepare\",\n\t\t.startup.single\t\t= perf_event_init_cpu,\n\t\t.teardown.single\t= perf_event_exit_cpu,\n\t},\n\t[CPUHP_WORKQUEUE_PREP] = {\n\t\t.name\t\t\t= \"workqueue:prepare\",\n\t\t.startup.single\t\t= workqueue_prepare_cpu,\n\t\t.teardown.single\t= NULL,\n\t},\n\t[CPUHP_HRTIMERS_PREPARE] = {\n\t\t.name\t\t\t= \"hrtimers:prepare\",\n\t\t.startup.single\t\t= hrtimers_prepare_cpu,\n\t\t.teardown.single\t= hrtimers_dead_cpu,\n\t},\n\t[CPUHP_SMPCFD_PREPARE] = {\n\t\t.name\t\t\t= \"smpcfd:prepare\",\n\t\t.startup.single\t\t= smpcfd_prepare_cpu,\n\t\t.teardown.single\t= smpcfd_dead_cpu,\n\t},\n\t[CPUHP_RELAY_PREPARE] = {\n\t\t.name\t\t\t= \"relay:prepare\",\n\t\t.startup.single\t\t= relay_prepare_cpu,\n\t\t.teardown.single\t= NULL,\n\t},\n\t[CPUHP_SLAB_PREPARE] = {\n\t\t.name\t\t\t= \"slab:prepare\",\n\t\t.startup.single\t\t= slab_prepare_cpu,\n\t\t.teardown.single\t= slab_dead_cpu,\n\t},\n\t[CPUHP_RCUTREE_PREP] = {\n\t\t.name\t\t\t= \"RCU/tree:prepare\",\n\t\t.startup.single\t\t= rcutree_prepare_cpu,\n\t\t.teardown.single\t= rcutree_dead_cpu,\n\t},\n\t/*\n\t * On the tear-down path, timers_dead_cpu() must be invoked\n\t * before blk_mq_queue_reinit_notify() from notify_dead(),\n\t * otherwise a RCU stall occurs.\n\t */\n\t[CPUHP_TIMERS_PREPARE] = {\n\t\t.name\t\t\t= \"timers:prepare\",\n\t\t.startup.single\t\t= timers_prepare_cpu,\n\t\t.teardown.single\t= timers_dead_cpu,\n\t},\n\t/* Kicks the plugged cpu into life */\n\t[CPUHP_BRINGUP_CPU] = {\n\t\t.name\t\t\t= \"cpu:bringup\",\n\t\t.startup.single\t\t= bringup_cpu,\n\t\t.teardown.single\t= finish_cpu,\n\t\t.cant_stop\t\t= true,\n\t},\n\t/* Final state before CPU kills itself */\n\t[CPUHP_AP_IDLE_DEAD] = {\n\t\t.name\t\t\t= \"idle:dead\",\n\t},\n\t/*\n\t * Last state before CPU enters the idle loop to die. Transient state\n\t * for synchronization.\n\t */\n\t[CPUHP_AP_OFFLINE] = {\n\t\t.name\t\t\t= \"ap:offline\",\n\t\t.cant_stop\t\t= true,\n\t},\n\t/* First state is scheduler control. Interrupts are disabled */\n\t[CPUHP_AP_SCHED_STARTING] = {\n\t\t.name\t\t\t= \"sched:starting\",\n\t\t.startup.single\t\t= sched_cpu_starting,\n\t\t.teardown.single\t= sched_cpu_dying,\n\t},\n\t[CPUHP_AP_RCUTREE_DYING] = {\n\t\t.name\t\t\t= \"RCU/tree:dying\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= rcutree_dying_cpu,\n\t},\n\t[CPUHP_AP_SMPCFD_DYING] = {\n\t\t.name\t\t\t= \"smpcfd:dying\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= smpcfd_dying_cpu,\n\t},\n\t/* Entry state on starting. Interrupts enabled from here on. Transient\n\t * state for synchronsization */\n\t[CPUHP_AP_ONLINE] = {\n\t\t.name\t\t\t= \"ap:online\",\n\t},\n\t/*\n\t * Handled on control processor until the plugged processor manages\n\t * this itself.\n\t */\n\t[CPUHP_TEARDOWN_CPU] = {\n\t\t.name\t\t\t= \"cpu:teardown\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= takedown_cpu,\n\t\t.cant_stop\t\t= true,\n\t},\n\n\t[CPUHP_AP_SCHED_WAIT_EMPTY] = {\n\t\t.name\t\t\t= \"sched:waitempty\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= sched_cpu_wait_empty,\n\t},\n\n\t/* Handle smpboot threads park/unpark */\n\t[CPUHP_AP_SMPBOOT_THREADS] = {\n\t\t.name\t\t\t= \"smpboot/threads:online\",\n\t\t.startup.single\t\t= smpboot_unpark_threads,\n\t\t.teardown.single\t= smpboot_park_threads,\n\t},\n\t[CPUHP_AP_IRQ_AFFINITY_ONLINE] = {\n\t\t.name\t\t\t= \"irq/affinity:online\",\n\t\t.startup.single\t\t= irq_affinity_online_cpu,\n\t\t.teardown.single\t= NULL,\n\t},\n\t[CPUHP_AP_PERF_ONLINE] = {\n\t\t.name\t\t\t= \"perf:online\",\n\t\t.startup.single\t\t= perf_event_init_cpu,\n\t\t.teardown.single\t= perf_event_exit_cpu,\n\t},\n\t[CPUHP_AP_WATCHDOG_ONLINE] = {\n\t\t.name\t\t\t= \"lockup_detector:online\",\n\t\t.startup.single\t\t= lockup_detector_online_cpu,\n\t\t.teardown.single\t= lockup_detector_offline_cpu,\n\t},\n\t[CPUHP_AP_WORKQUEUE_ONLINE] = {\n\t\t.name\t\t\t= \"workqueue:online\",\n\t\t.startup.single\t\t= workqueue_online_cpu,\n\t\t.teardown.single\t= workqueue_offline_cpu,\n\t},\n\t[CPUHP_AP_RCUTREE_ONLINE] = {\n\t\t.name\t\t\t= \"RCU/tree:online\",\n\t\t.startup.single\t\t= rcutree_online_cpu,\n\t\t.teardown.single\t= rcutree_offline_cpu,\n\t},\n#endif\n\t/*\n\t * The dynamically registered state space is here\n\t */\n\n#ifdef CONFIG_SMP\n\t/* Last state is scheduler control setting the cpu active */\n\t[CPUHP_AP_ACTIVE] = {\n\t\t.name\t\t\t= \"sched:active\",\n\t\t.startup.single\t\t= sched_cpu_activate,\n\t\t.teardown.single\t= sched_cpu_deactivate,\n\t},\n#endif\n\n\t/* CPU is fully up and running. */\n\t[CPUHP_ONLINE] = {\n\t\t.name\t\t\t= \"online\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= NULL,\n\t},\n};\n\nstatic struct cpuhp_step *cpuhp_get_step(enum cpuhp_state state)\n{\n\treturn cpuhp_hp_states + state;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\n\nstatic int cpuhp_issue_call(int cpu, enum cpuhp_state state, bool bringup,\n\t\t\t    struct hlist_node *node)\n{\n\tstruct cpuhp_step *sp = cpuhp_get_step(state);\n\tint ret;\n\n\t/*\n\t * If there's nothing to do, we done.\n\t * Relies on the union for multi_instance.\n\t */\n\tif (cpuhp_step_empty(bringup, sp))\n\t\treturn 0;\n\t/*\n\t * The non AP bound callbacks can fail on bringup. On teardown\n\t * e.g. module removal we crash for now.\n\t */\n#ifdef CONFIG_SMP\n\tif (cpuhp_is_ap_state(state))\n\t\tret = cpuhp_invoke_ap_callback(cpu, state, bringup, node);\n\telse\n\t\tret = cpuhp_invoke_callback(cpu, state, bringup, node, NULL);\n#else\n\tret = cpuhp_invoke_callback(cpu, state, bringup, node, NULL);\n#endif\n\tBUG_ON(ret && !bringup);\n\treturn ret;\n}"
  },
  {
    "function_name": "cpuhp_get_teardown_cb",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
    "lines": "1888-1891",
    "snippet": "static void *cpuhp_get_teardown_cb(enum cpuhp_state state)\n{\n\treturn cpuhp_get_step(state)->teardown.single;\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/scs.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sched/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpuhp_get_step",
          "args": [
            "state"
          ],
          "line": 1890
        },
        "resolved": true,
        "details": {
          "function_name": "cpuhp_get_step",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "144-147",
          "snippet": "static struct cpuhp_step *cpuhp_get_step(enum cpuhp_state state)\n{\n\treturn cpuhp_hp_states + state;\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};",
            "static struct cpuhp_step cpuhp_hp_states[];",
            "static struct cpuhp_step cpuhp_hp_states[] = {\n\t[CPUHP_OFFLINE] = {\n\t\t.name\t\t\t= \"offline\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= NULL,\n\t},\n#ifdef CONFIG_SMP\n\t[CPUHP_CREATE_THREADS]= {\n\t\t.name\t\t\t= \"threads:prepare\",\n\t\t.startup.single\t\t= smpboot_create_threads,\n\t\t.teardown.single\t= NULL,\n\t\t.cant_stop\t\t= true,\n\t},\n\t[CPUHP_PERF_PREPARE] = {\n\t\t.name\t\t\t= \"perf:prepare\",\n\t\t.startup.single\t\t= perf_event_init_cpu,\n\t\t.teardown.single\t= perf_event_exit_cpu,\n\t},\n\t[CPUHP_WORKQUEUE_PREP] = {\n\t\t.name\t\t\t= \"workqueue:prepare\",\n\t\t.startup.single\t\t= workqueue_prepare_cpu,\n\t\t.teardown.single\t= NULL,\n\t},\n\t[CPUHP_HRTIMERS_PREPARE] = {\n\t\t.name\t\t\t= \"hrtimers:prepare\",\n\t\t.startup.single\t\t= hrtimers_prepare_cpu,\n\t\t.teardown.single\t= hrtimers_dead_cpu,\n\t},\n\t[CPUHP_SMPCFD_PREPARE] = {\n\t\t.name\t\t\t= \"smpcfd:prepare\",\n\t\t.startup.single\t\t= smpcfd_prepare_cpu,\n\t\t.teardown.single\t= smpcfd_dead_cpu,\n\t},\n\t[CPUHP_RELAY_PREPARE] = {\n\t\t.name\t\t\t= \"relay:prepare\",\n\t\t.startup.single\t\t= relay_prepare_cpu,\n\t\t.teardown.single\t= NULL,\n\t},\n\t[CPUHP_SLAB_PREPARE] = {\n\t\t.name\t\t\t= \"slab:prepare\",\n\t\t.startup.single\t\t= slab_prepare_cpu,\n\t\t.teardown.single\t= slab_dead_cpu,\n\t},\n\t[CPUHP_RCUTREE_PREP] = {\n\t\t.name\t\t\t= \"RCU/tree:prepare\",\n\t\t.startup.single\t\t= rcutree_prepare_cpu,\n\t\t.teardown.single\t= rcutree_dead_cpu,\n\t},\n\t/*\n\t * On the tear-down path, timers_dead_cpu() must be invoked\n\t * before blk_mq_queue_reinit_notify() from notify_dead(),\n\t * otherwise a RCU stall occurs.\n\t */\n\t[CPUHP_TIMERS_PREPARE] = {\n\t\t.name\t\t\t= \"timers:prepare\",\n\t\t.startup.single\t\t= timers_prepare_cpu,\n\t\t.teardown.single\t= timers_dead_cpu,\n\t},\n\t/* Kicks the plugged cpu into life */\n\t[CPUHP_BRINGUP_CPU] = {\n\t\t.name\t\t\t= \"cpu:bringup\",\n\t\t.startup.single\t\t= bringup_cpu,\n\t\t.teardown.single\t= finish_cpu,\n\t\t.cant_stop\t\t= true,\n\t},\n\t/* Final state before CPU kills itself */\n\t[CPUHP_AP_IDLE_DEAD] = {\n\t\t.name\t\t\t= \"idle:dead\",\n\t},\n\t/*\n\t * Last state before CPU enters the idle loop to die. Transient state\n\t * for synchronization.\n\t */\n\t[CPUHP_AP_OFFLINE] = {\n\t\t.name\t\t\t= \"ap:offline\",\n\t\t.cant_stop\t\t= true,\n\t},\n\t/* First state is scheduler control. Interrupts are disabled */\n\t[CPUHP_AP_SCHED_STARTING] = {\n\t\t.name\t\t\t= \"sched:starting\",\n\t\t.startup.single\t\t= sched_cpu_starting,\n\t\t.teardown.single\t= sched_cpu_dying,\n\t},\n\t[CPUHP_AP_RCUTREE_DYING] = {\n\t\t.name\t\t\t= \"RCU/tree:dying\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= rcutree_dying_cpu,\n\t},\n\t[CPUHP_AP_SMPCFD_DYING] = {\n\t\t.name\t\t\t= \"smpcfd:dying\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= smpcfd_dying_cpu,\n\t},\n\t/* Entry state on starting. Interrupts enabled from here on. Transient\n\t * state for synchronsization */\n\t[CPUHP_AP_ONLINE] = {\n\t\t.name\t\t\t= \"ap:online\",\n\t},\n\t/*\n\t * Handled on control processor until the plugged processor manages\n\t * this itself.\n\t */\n\t[CPUHP_TEARDOWN_CPU] = {\n\t\t.name\t\t\t= \"cpu:teardown\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= takedown_cpu,\n\t\t.cant_stop\t\t= true,\n\t},\n\n\t[CPUHP_AP_SCHED_WAIT_EMPTY] = {\n\t\t.name\t\t\t= \"sched:waitempty\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= sched_cpu_wait_empty,\n\t},\n\n\t/* Handle smpboot threads park/unpark */\n\t[CPUHP_AP_SMPBOOT_THREADS] = {\n\t\t.name\t\t\t= \"smpboot/threads:online\",\n\t\t.startup.single\t\t= smpboot_unpark_threads,\n\t\t.teardown.single\t= smpboot_park_threads,\n\t},\n\t[CPUHP_AP_IRQ_AFFINITY_ONLINE] = {\n\t\t.name\t\t\t= \"irq/affinity:online\",\n\t\t.startup.single\t\t= irq_affinity_online_cpu,\n\t\t.teardown.single\t= NULL,\n\t},\n\t[CPUHP_AP_PERF_ONLINE] = {\n\t\t.name\t\t\t= \"perf:online\",\n\t\t.startup.single\t\t= perf_event_init_cpu,\n\t\t.teardown.single\t= perf_event_exit_cpu,\n\t},\n\t[CPUHP_AP_WATCHDOG_ONLINE] = {\n\t\t.name\t\t\t= \"lockup_detector:online\",\n\t\t.startup.single\t\t= lockup_detector_online_cpu,\n\t\t.teardown.single\t= lockup_detector_offline_cpu,\n\t},\n\t[CPUHP_AP_WORKQUEUE_ONLINE] = {\n\t\t.name\t\t\t= \"workqueue:online\",\n\t\t.startup.single\t\t= workqueue_online_cpu,\n\t\t.teardown.single\t= workqueue_offline_cpu,\n\t},\n\t[CPUHP_AP_RCUTREE_ONLINE] = {\n\t\t.name\t\t\t= \"RCU/tree:online\",\n\t\t.startup.single\t\t= rcutree_online_cpu,\n\t\t.teardown.single\t= rcutree_offline_cpu,\n\t},\n#endif\n\t/*\n\t * The dynamically registered state space is here\n\t */\n\n#ifdef CONFIG_SMP\n\t/* Last state is scheduler control setting the cpu active */\n\t[CPUHP_AP_ACTIVE] = {\n\t\t.name\t\t\t= \"sched:active\",\n\t\t.startup.single\t\t= sched_cpu_activate,\n\t\t.teardown.single\t= sched_cpu_deactivate,\n\t},\n#endif\n\n\t/* CPU is fully up and running. */\n\t[CPUHP_ONLINE] = {\n\t\t.name\t\t\t= \"online\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= NULL,\n\t},\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\nstatic struct cpuhp_step cpuhp_hp_states[];\nstatic struct cpuhp_step cpuhp_hp_states[] = {\n\t[CPUHP_OFFLINE] = {\n\t\t.name\t\t\t= \"offline\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= NULL,\n\t},\n#ifdef CONFIG_SMP\n\t[CPUHP_CREATE_THREADS]= {\n\t\t.name\t\t\t= \"threads:prepare\",\n\t\t.startup.single\t\t= smpboot_create_threads,\n\t\t.teardown.single\t= NULL,\n\t\t.cant_stop\t\t= true,\n\t},\n\t[CPUHP_PERF_PREPARE] = {\n\t\t.name\t\t\t= \"perf:prepare\",\n\t\t.startup.single\t\t= perf_event_init_cpu,\n\t\t.teardown.single\t= perf_event_exit_cpu,\n\t},\n\t[CPUHP_WORKQUEUE_PREP] = {\n\t\t.name\t\t\t= \"workqueue:prepare\",\n\t\t.startup.single\t\t= workqueue_prepare_cpu,\n\t\t.teardown.single\t= NULL,\n\t},\n\t[CPUHP_HRTIMERS_PREPARE] = {\n\t\t.name\t\t\t= \"hrtimers:prepare\",\n\t\t.startup.single\t\t= hrtimers_prepare_cpu,\n\t\t.teardown.single\t= hrtimers_dead_cpu,\n\t},\n\t[CPUHP_SMPCFD_PREPARE] = {\n\t\t.name\t\t\t= \"smpcfd:prepare\",\n\t\t.startup.single\t\t= smpcfd_prepare_cpu,\n\t\t.teardown.single\t= smpcfd_dead_cpu,\n\t},\n\t[CPUHP_RELAY_PREPARE] = {\n\t\t.name\t\t\t= \"relay:prepare\",\n\t\t.startup.single\t\t= relay_prepare_cpu,\n\t\t.teardown.single\t= NULL,\n\t},\n\t[CPUHP_SLAB_PREPARE] = {\n\t\t.name\t\t\t= \"slab:prepare\",\n\t\t.startup.single\t\t= slab_prepare_cpu,\n\t\t.teardown.single\t= slab_dead_cpu,\n\t},\n\t[CPUHP_RCUTREE_PREP] = {\n\t\t.name\t\t\t= \"RCU/tree:prepare\",\n\t\t.startup.single\t\t= rcutree_prepare_cpu,\n\t\t.teardown.single\t= rcutree_dead_cpu,\n\t},\n\t/*\n\t * On the tear-down path, timers_dead_cpu() must be invoked\n\t * before blk_mq_queue_reinit_notify() from notify_dead(),\n\t * otherwise a RCU stall occurs.\n\t */\n\t[CPUHP_TIMERS_PREPARE] = {\n\t\t.name\t\t\t= \"timers:prepare\",\n\t\t.startup.single\t\t= timers_prepare_cpu,\n\t\t.teardown.single\t= timers_dead_cpu,\n\t},\n\t/* Kicks the plugged cpu into life */\n\t[CPUHP_BRINGUP_CPU] = {\n\t\t.name\t\t\t= \"cpu:bringup\",\n\t\t.startup.single\t\t= bringup_cpu,\n\t\t.teardown.single\t= finish_cpu,\n\t\t.cant_stop\t\t= true,\n\t},\n\t/* Final state before CPU kills itself */\n\t[CPUHP_AP_IDLE_DEAD] = {\n\t\t.name\t\t\t= \"idle:dead\",\n\t},\n\t/*\n\t * Last state before CPU enters the idle loop to die. Transient state\n\t * for synchronization.\n\t */\n\t[CPUHP_AP_OFFLINE] = {\n\t\t.name\t\t\t= \"ap:offline\",\n\t\t.cant_stop\t\t= true,\n\t},\n\t/* First state is scheduler control. Interrupts are disabled */\n\t[CPUHP_AP_SCHED_STARTING] = {\n\t\t.name\t\t\t= \"sched:starting\",\n\t\t.startup.single\t\t= sched_cpu_starting,\n\t\t.teardown.single\t= sched_cpu_dying,\n\t},\n\t[CPUHP_AP_RCUTREE_DYING] = {\n\t\t.name\t\t\t= \"RCU/tree:dying\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= rcutree_dying_cpu,\n\t},\n\t[CPUHP_AP_SMPCFD_DYING] = {\n\t\t.name\t\t\t= \"smpcfd:dying\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= smpcfd_dying_cpu,\n\t},\n\t/* Entry state on starting. Interrupts enabled from here on. Transient\n\t * state for synchronsization */\n\t[CPUHP_AP_ONLINE] = {\n\t\t.name\t\t\t= \"ap:online\",\n\t},\n\t/*\n\t * Handled on control processor until the plugged processor manages\n\t * this itself.\n\t */\n\t[CPUHP_TEARDOWN_CPU] = {\n\t\t.name\t\t\t= \"cpu:teardown\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= takedown_cpu,\n\t\t.cant_stop\t\t= true,\n\t},\n\n\t[CPUHP_AP_SCHED_WAIT_EMPTY] = {\n\t\t.name\t\t\t= \"sched:waitempty\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= sched_cpu_wait_empty,\n\t},\n\n\t/* Handle smpboot threads park/unpark */\n\t[CPUHP_AP_SMPBOOT_THREADS] = {\n\t\t.name\t\t\t= \"smpboot/threads:online\",\n\t\t.startup.single\t\t= smpboot_unpark_threads,\n\t\t.teardown.single\t= smpboot_park_threads,\n\t},\n\t[CPUHP_AP_IRQ_AFFINITY_ONLINE] = {\n\t\t.name\t\t\t= \"irq/affinity:online\",\n\t\t.startup.single\t\t= irq_affinity_online_cpu,\n\t\t.teardown.single\t= NULL,\n\t},\n\t[CPUHP_AP_PERF_ONLINE] = {\n\t\t.name\t\t\t= \"perf:online\",\n\t\t.startup.single\t\t= perf_event_init_cpu,\n\t\t.teardown.single\t= perf_event_exit_cpu,\n\t},\n\t[CPUHP_AP_WATCHDOG_ONLINE] = {\n\t\t.name\t\t\t= \"lockup_detector:online\",\n\t\t.startup.single\t\t= lockup_detector_online_cpu,\n\t\t.teardown.single\t= lockup_detector_offline_cpu,\n\t},\n\t[CPUHP_AP_WORKQUEUE_ONLINE] = {\n\t\t.name\t\t\t= \"workqueue:online\",\n\t\t.startup.single\t\t= workqueue_online_cpu,\n\t\t.teardown.single\t= workqueue_offline_cpu,\n\t},\n\t[CPUHP_AP_RCUTREE_ONLINE] = {\n\t\t.name\t\t\t= \"RCU/tree:online\",\n\t\t.startup.single\t\t= rcutree_online_cpu,\n\t\t.teardown.single\t= rcutree_offline_cpu,\n\t},\n#endif\n\t/*\n\t * The dynamically registered state space is here\n\t */\n\n#ifdef CONFIG_SMP\n\t/* Last state is scheduler control setting the cpu active */\n\t[CPUHP_AP_ACTIVE] = {\n\t\t.name\t\t\t= \"sched:active\",\n\t\t.startup.single\t\t= sched_cpu_activate,\n\t\t.teardown.single\t= sched_cpu_deactivate,\n\t},\n#endif\n\n\t/* CPU is fully up and running. */\n\t[CPUHP_ONLINE] = {\n\t\t.name\t\t\t= \"online\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= NULL,\n\t},\n};\n\nstatic struct cpuhp_step *cpuhp_get_step(enum cpuhp_state state)\n{\n\treturn cpuhp_hp_states + state;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\n\nstatic void *cpuhp_get_teardown_cb(enum cpuhp_state state)\n{\n\treturn cpuhp_get_step(state)->teardown.single;\n}"
  },
  {
    "function_name": "cpuhp_store_callbacks",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
    "lines": "1851-1886",
    "snippet": "static int cpuhp_store_callbacks(enum cpuhp_state state, const char *name,\n\t\t\t\t int (*startup)(unsigned int cpu),\n\t\t\t\t int (*teardown)(unsigned int cpu),\n\t\t\t\t bool multi_instance)\n{\n\t/* (Un)Install the callbacks for further cpu hotplug operations */\n\tstruct cpuhp_step *sp;\n\tint ret = 0;\n\n\t/*\n\t * If name is NULL, then the state gets removed.\n\t *\n\t * CPUHP_AP_ONLINE_DYN and CPUHP_BP_PREPARE_DYN are handed out on\n\t * the first allocation from these dynamic ranges, so the removal\n\t * would trigger a new allocation and clear the wrong (already\n\t * empty) state, leaving the callbacks of the to be cleared state\n\t * dangling, which causes wreckage on the next hotplug operation.\n\t */\n\tif (name && (state == CPUHP_AP_ONLINE_DYN ||\n\t\t     state == CPUHP_BP_PREPARE_DYN)) {\n\t\tret = cpuhp_reserve_state(state);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tstate = ret;\n\t}\n\tsp = cpuhp_get_step(state);\n\tif (name && sp->name)\n\t\treturn -EBUSY;\n\n\tsp->startup.single = startup;\n\tsp->teardown.single = teardown;\n\tsp->name = name;\n\tsp->multi_instance = multi_instance;\n\tINIT_HLIST_HEAD(&sp->list);\n\treturn ret;\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/scs.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sched/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "INIT_HLIST_HEAD",
          "args": [
            "&sp->list"
          ],
          "line": 1884
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpuhp_get_step",
          "args": [
            "state"
          ],
          "line": 1876
        },
        "resolved": true,
        "details": {
          "function_name": "cpuhp_get_step",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "144-147",
          "snippet": "static struct cpuhp_step *cpuhp_get_step(enum cpuhp_state state)\n{\n\treturn cpuhp_hp_states + state;\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};",
            "static struct cpuhp_step cpuhp_hp_states[];",
            "static struct cpuhp_step cpuhp_hp_states[] = {\n\t[CPUHP_OFFLINE] = {\n\t\t.name\t\t\t= \"offline\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= NULL,\n\t},\n#ifdef CONFIG_SMP\n\t[CPUHP_CREATE_THREADS]= {\n\t\t.name\t\t\t= \"threads:prepare\",\n\t\t.startup.single\t\t= smpboot_create_threads,\n\t\t.teardown.single\t= NULL,\n\t\t.cant_stop\t\t= true,\n\t},\n\t[CPUHP_PERF_PREPARE] = {\n\t\t.name\t\t\t= \"perf:prepare\",\n\t\t.startup.single\t\t= perf_event_init_cpu,\n\t\t.teardown.single\t= perf_event_exit_cpu,\n\t},\n\t[CPUHP_WORKQUEUE_PREP] = {\n\t\t.name\t\t\t= \"workqueue:prepare\",\n\t\t.startup.single\t\t= workqueue_prepare_cpu,\n\t\t.teardown.single\t= NULL,\n\t},\n\t[CPUHP_HRTIMERS_PREPARE] = {\n\t\t.name\t\t\t= \"hrtimers:prepare\",\n\t\t.startup.single\t\t= hrtimers_prepare_cpu,\n\t\t.teardown.single\t= hrtimers_dead_cpu,\n\t},\n\t[CPUHP_SMPCFD_PREPARE] = {\n\t\t.name\t\t\t= \"smpcfd:prepare\",\n\t\t.startup.single\t\t= smpcfd_prepare_cpu,\n\t\t.teardown.single\t= smpcfd_dead_cpu,\n\t},\n\t[CPUHP_RELAY_PREPARE] = {\n\t\t.name\t\t\t= \"relay:prepare\",\n\t\t.startup.single\t\t= relay_prepare_cpu,\n\t\t.teardown.single\t= NULL,\n\t},\n\t[CPUHP_SLAB_PREPARE] = {\n\t\t.name\t\t\t= \"slab:prepare\",\n\t\t.startup.single\t\t= slab_prepare_cpu,\n\t\t.teardown.single\t= slab_dead_cpu,\n\t},\n\t[CPUHP_RCUTREE_PREP] = {\n\t\t.name\t\t\t= \"RCU/tree:prepare\",\n\t\t.startup.single\t\t= rcutree_prepare_cpu,\n\t\t.teardown.single\t= rcutree_dead_cpu,\n\t},\n\t/*\n\t * On the tear-down path, timers_dead_cpu() must be invoked\n\t * before blk_mq_queue_reinit_notify() from notify_dead(),\n\t * otherwise a RCU stall occurs.\n\t */\n\t[CPUHP_TIMERS_PREPARE] = {\n\t\t.name\t\t\t= \"timers:prepare\",\n\t\t.startup.single\t\t= timers_prepare_cpu,\n\t\t.teardown.single\t= timers_dead_cpu,\n\t},\n\t/* Kicks the plugged cpu into life */\n\t[CPUHP_BRINGUP_CPU] = {\n\t\t.name\t\t\t= \"cpu:bringup\",\n\t\t.startup.single\t\t= bringup_cpu,\n\t\t.teardown.single\t= finish_cpu,\n\t\t.cant_stop\t\t= true,\n\t},\n\t/* Final state before CPU kills itself */\n\t[CPUHP_AP_IDLE_DEAD] = {\n\t\t.name\t\t\t= \"idle:dead\",\n\t},\n\t/*\n\t * Last state before CPU enters the idle loop to die. Transient state\n\t * for synchronization.\n\t */\n\t[CPUHP_AP_OFFLINE] = {\n\t\t.name\t\t\t= \"ap:offline\",\n\t\t.cant_stop\t\t= true,\n\t},\n\t/* First state is scheduler control. Interrupts are disabled */\n\t[CPUHP_AP_SCHED_STARTING] = {\n\t\t.name\t\t\t= \"sched:starting\",\n\t\t.startup.single\t\t= sched_cpu_starting,\n\t\t.teardown.single\t= sched_cpu_dying,\n\t},\n\t[CPUHP_AP_RCUTREE_DYING] = {\n\t\t.name\t\t\t= \"RCU/tree:dying\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= rcutree_dying_cpu,\n\t},\n\t[CPUHP_AP_SMPCFD_DYING] = {\n\t\t.name\t\t\t= \"smpcfd:dying\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= smpcfd_dying_cpu,\n\t},\n\t/* Entry state on starting. Interrupts enabled from here on. Transient\n\t * state for synchronsization */\n\t[CPUHP_AP_ONLINE] = {\n\t\t.name\t\t\t= \"ap:online\",\n\t},\n\t/*\n\t * Handled on control processor until the plugged processor manages\n\t * this itself.\n\t */\n\t[CPUHP_TEARDOWN_CPU] = {\n\t\t.name\t\t\t= \"cpu:teardown\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= takedown_cpu,\n\t\t.cant_stop\t\t= true,\n\t},\n\n\t[CPUHP_AP_SCHED_WAIT_EMPTY] = {\n\t\t.name\t\t\t= \"sched:waitempty\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= sched_cpu_wait_empty,\n\t},\n\n\t/* Handle smpboot threads park/unpark */\n\t[CPUHP_AP_SMPBOOT_THREADS] = {\n\t\t.name\t\t\t= \"smpboot/threads:online\",\n\t\t.startup.single\t\t= smpboot_unpark_threads,\n\t\t.teardown.single\t= smpboot_park_threads,\n\t},\n\t[CPUHP_AP_IRQ_AFFINITY_ONLINE] = {\n\t\t.name\t\t\t= \"irq/affinity:online\",\n\t\t.startup.single\t\t= irq_affinity_online_cpu,\n\t\t.teardown.single\t= NULL,\n\t},\n\t[CPUHP_AP_PERF_ONLINE] = {\n\t\t.name\t\t\t= \"perf:online\",\n\t\t.startup.single\t\t= perf_event_init_cpu,\n\t\t.teardown.single\t= perf_event_exit_cpu,\n\t},\n\t[CPUHP_AP_WATCHDOG_ONLINE] = {\n\t\t.name\t\t\t= \"lockup_detector:online\",\n\t\t.startup.single\t\t= lockup_detector_online_cpu,\n\t\t.teardown.single\t= lockup_detector_offline_cpu,\n\t},\n\t[CPUHP_AP_WORKQUEUE_ONLINE] = {\n\t\t.name\t\t\t= \"workqueue:online\",\n\t\t.startup.single\t\t= workqueue_online_cpu,\n\t\t.teardown.single\t= workqueue_offline_cpu,\n\t},\n\t[CPUHP_AP_RCUTREE_ONLINE] = {\n\t\t.name\t\t\t= \"RCU/tree:online\",\n\t\t.startup.single\t\t= rcutree_online_cpu,\n\t\t.teardown.single\t= rcutree_offline_cpu,\n\t},\n#endif\n\t/*\n\t * The dynamically registered state space is here\n\t */\n\n#ifdef CONFIG_SMP\n\t/* Last state is scheduler control setting the cpu active */\n\t[CPUHP_AP_ACTIVE] = {\n\t\t.name\t\t\t= \"sched:active\",\n\t\t.startup.single\t\t= sched_cpu_activate,\n\t\t.teardown.single\t= sched_cpu_deactivate,\n\t},\n#endif\n\n\t/* CPU is fully up and running. */\n\t[CPUHP_ONLINE] = {\n\t\t.name\t\t\t= \"online\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= NULL,\n\t},\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\nstatic struct cpuhp_step cpuhp_hp_states[];\nstatic struct cpuhp_step cpuhp_hp_states[] = {\n\t[CPUHP_OFFLINE] = {\n\t\t.name\t\t\t= \"offline\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= NULL,\n\t},\n#ifdef CONFIG_SMP\n\t[CPUHP_CREATE_THREADS]= {\n\t\t.name\t\t\t= \"threads:prepare\",\n\t\t.startup.single\t\t= smpboot_create_threads,\n\t\t.teardown.single\t= NULL,\n\t\t.cant_stop\t\t= true,\n\t},\n\t[CPUHP_PERF_PREPARE] = {\n\t\t.name\t\t\t= \"perf:prepare\",\n\t\t.startup.single\t\t= perf_event_init_cpu,\n\t\t.teardown.single\t= perf_event_exit_cpu,\n\t},\n\t[CPUHP_WORKQUEUE_PREP] = {\n\t\t.name\t\t\t= \"workqueue:prepare\",\n\t\t.startup.single\t\t= workqueue_prepare_cpu,\n\t\t.teardown.single\t= NULL,\n\t},\n\t[CPUHP_HRTIMERS_PREPARE] = {\n\t\t.name\t\t\t= \"hrtimers:prepare\",\n\t\t.startup.single\t\t= hrtimers_prepare_cpu,\n\t\t.teardown.single\t= hrtimers_dead_cpu,\n\t},\n\t[CPUHP_SMPCFD_PREPARE] = {\n\t\t.name\t\t\t= \"smpcfd:prepare\",\n\t\t.startup.single\t\t= smpcfd_prepare_cpu,\n\t\t.teardown.single\t= smpcfd_dead_cpu,\n\t},\n\t[CPUHP_RELAY_PREPARE] = {\n\t\t.name\t\t\t= \"relay:prepare\",\n\t\t.startup.single\t\t= relay_prepare_cpu,\n\t\t.teardown.single\t= NULL,\n\t},\n\t[CPUHP_SLAB_PREPARE] = {\n\t\t.name\t\t\t= \"slab:prepare\",\n\t\t.startup.single\t\t= slab_prepare_cpu,\n\t\t.teardown.single\t= slab_dead_cpu,\n\t},\n\t[CPUHP_RCUTREE_PREP] = {\n\t\t.name\t\t\t= \"RCU/tree:prepare\",\n\t\t.startup.single\t\t= rcutree_prepare_cpu,\n\t\t.teardown.single\t= rcutree_dead_cpu,\n\t},\n\t/*\n\t * On the tear-down path, timers_dead_cpu() must be invoked\n\t * before blk_mq_queue_reinit_notify() from notify_dead(),\n\t * otherwise a RCU stall occurs.\n\t */\n\t[CPUHP_TIMERS_PREPARE] = {\n\t\t.name\t\t\t= \"timers:prepare\",\n\t\t.startup.single\t\t= timers_prepare_cpu,\n\t\t.teardown.single\t= timers_dead_cpu,\n\t},\n\t/* Kicks the plugged cpu into life */\n\t[CPUHP_BRINGUP_CPU] = {\n\t\t.name\t\t\t= \"cpu:bringup\",\n\t\t.startup.single\t\t= bringup_cpu,\n\t\t.teardown.single\t= finish_cpu,\n\t\t.cant_stop\t\t= true,\n\t},\n\t/* Final state before CPU kills itself */\n\t[CPUHP_AP_IDLE_DEAD] = {\n\t\t.name\t\t\t= \"idle:dead\",\n\t},\n\t/*\n\t * Last state before CPU enters the idle loop to die. Transient state\n\t * for synchronization.\n\t */\n\t[CPUHP_AP_OFFLINE] = {\n\t\t.name\t\t\t= \"ap:offline\",\n\t\t.cant_stop\t\t= true,\n\t},\n\t/* First state is scheduler control. Interrupts are disabled */\n\t[CPUHP_AP_SCHED_STARTING] = {\n\t\t.name\t\t\t= \"sched:starting\",\n\t\t.startup.single\t\t= sched_cpu_starting,\n\t\t.teardown.single\t= sched_cpu_dying,\n\t},\n\t[CPUHP_AP_RCUTREE_DYING] = {\n\t\t.name\t\t\t= \"RCU/tree:dying\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= rcutree_dying_cpu,\n\t},\n\t[CPUHP_AP_SMPCFD_DYING] = {\n\t\t.name\t\t\t= \"smpcfd:dying\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= smpcfd_dying_cpu,\n\t},\n\t/* Entry state on starting. Interrupts enabled from here on. Transient\n\t * state for synchronsization */\n\t[CPUHP_AP_ONLINE] = {\n\t\t.name\t\t\t= \"ap:online\",\n\t},\n\t/*\n\t * Handled on control processor until the plugged processor manages\n\t * this itself.\n\t */\n\t[CPUHP_TEARDOWN_CPU] = {\n\t\t.name\t\t\t= \"cpu:teardown\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= takedown_cpu,\n\t\t.cant_stop\t\t= true,\n\t},\n\n\t[CPUHP_AP_SCHED_WAIT_EMPTY] = {\n\t\t.name\t\t\t= \"sched:waitempty\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= sched_cpu_wait_empty,\n\t},\n\n\t/* Handle smpboot threads park/unpark */\n\t[CPUHP_AP_SMPBOOT_THREADS] = {\n\t\t.name\t\t\t= \"smpboot/threads:online\",\n\t\t.startup.single\t\t= smpboot_unpark_threads,\n\t\t.teardown.single\t= smpboot_park_threads,\n\t},\n\t[CPUHP_AP_IRQ_AFFINITY_ONLINE] = {\n\t\t.name\t\t\t= \"irq/affinity:online\",\n\t\t.startup.single\t\t= irq_affinity_online_cpu,\n\t\t.teardown.single\t= NULL,\n\t},\n\t[CPUHP_AP_PERF_ONLINE] = {\n\t\t.name\t\t\t= \"perf:online\",\n\t\t.startup.single\t\t= perf_event_init_cpu,\n\t\t.teardown.single\t= perf_event_exit_cpu,\n\t},\n\t[CPUHP_AP_WATCHDOG_ONLINE] = {\n\t\t.name\t\t\t= \"lockup_detector:online\",\n\t\t.startup.single\t\t= lockup_detector_online_cpu,\n\t\t.teardown.single\t= lockup_detector_offline_cpu,\n\t},\n\t[CPUHP_AP_WORKQUEUE_ONLINE] = {\n\t\t.name\t\t\t= \"workqueue:online\",\n\t\t.startup.single\t\t= workqueue_online_cpu,\n\t\t.teardown.single\t= workqueue_offline_cpu,\n\t},\n\t[CPUHP_AP_RCUTREE_ONLINE] = {\n\t\t.name\t\t\t= \"RCU/tree:online\",\n\t\t.startup.single\t\t= rcutree_online_cpu,\n\t\t.teardown.single\t= rcutree_offline_cpu,\n\t},\n#endif\n\t/*\n\t * The dynamically registered state space is here\n\t */\n\n#ifdef CONFIG_SMP\n\t/* Last state is scheduler control setting the cpu active */\n\t[CPUHP_AP_ACTIVE] = {\n\t\t.name\t\t\t= \"sched:active\",\n\t\t.startup.single\t\t= sched_cpu_activate,\n\t\t.teardown.single\t= sched_cpu_deactivate,\n\t},\n#endif\n\n\t/* CPU is fully up and running. */\n\t[CPUHP_ONLINE] = {\n\t\t.name\t\t\t= \"online\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= NULL,\n\t},\n};\n\nstatic struct cpuhp_step *cpuhp_get_step(enum cpuhp_state state)\n{\n\treturn cpuhp_hp_states + state;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpuhp_reserve_state",
          "args": [
            "state"
          ],
          "line": 1871
        },
        "resolved": true,
        "details": {
          "function_name": "cpuhp_reserve_state",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "1825-1849",
          "snippet": "static int cpuhp_reserve_state(enum cpuhp_state state)\n{\n\tenum cpuhp_state i, end;\n\tstruct cpuhp_step *step;\n\n\tswitch (state) {\n\tcase CPUHP_AP_ONLINE_DYN:\n\t\tstep = cpuhp_hp_states + CPUHP_AP_ONLINE_DYN;\n\t\tend = CPUHP_AP_ONLINE_DYN_END;\n\t\tbreak;\n\tcase CPUHP_BP_PREPARE_DYN:\n\t\tstep = cpuhp_hp_states + CPUHP_BP_PREPARE_DYN;\n\t\tend = CPUHP_BP_PREPARE_DYN_END;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = state; i <= end; i++, step++) {\n\t\tif (!step->name)\n\t\t\treturn i;\n\t}\n\tWARN(1, \"No more dynamic states available for CPU hotplug\\n\");\n\treturn -ENOSPC;\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};",
            "static struct cpuhp_step cpuhp_hp_states[];",
            "static struct cpuhp_step cpuhp_hp_states[] = {\n\t[CPUHP_OFFLINE] = {\n\t\t.name\t\t\t= \"offline\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= NULL,\n\t},\n#ifdef CONFIG_SMP\n\t[CPUHP_CREATE_THREADS]= {\n\t\t.name\t\t\t= \"threads:prepare\",\n\t\t.startup.single\t\t= smpboot_create_threads,\n\t\t.teardown.single\t= NULL,\n\t\t.cant_stop\t\t= true,\n\t},\n\t[CPUHP_PERF_PREPARE] = {\n\t\t.name\t\t\t= \"perf:prepare\",\n\t\t.startup.single\t\t= perf_event_init_cpu,\n\t\t.teardown.single\t= perf_event_exit_cpu,\n\t},\n\t[CPUHP_WORKQUEUE_PREP] = {\n\t\t.name\t\t\t= \"workqueue:prepare\",\n\t\t.startup.single\t\t= workqueue_prepare_cpu,\n\t\t.teardown.single\t= NULL,\n\t},\n\t[CPUHP_HRTIMERS_PREPARE] = {\n\t\t.name\t\t\t= \"hrtimers:prepare\",\n\t\t.startup.single\t\t= hrtimers_prepare_cpu,\n\t\t.teardown.single\t= hrtimers_dead_cpu,\n\t},\n\t[CPUHP_SMPCFD_PREPARE] = {\n\t\t.name\t\t\t= \"smpcfd:prepare\",\n\t\t.startup.single\t\t= smpcfd_prepare_cpu,\n\t\t.teardown.single\t= smpcfd_dead_cpu,\n\t},\n\t[CPUHP_RELAY_PREPARE] = {\n\t\t.name\t\t\t= \"relay:prepare\",\n\t\t.startup.single\t\t= relay_prepare_cpu,\n\t\t.teardown.single\t= NULL,\n\t},\n\t[CPUHP_SLAB_PREPARE] = {\n\t\t.name\t\t\t= \"slab:prepare\",\n\t\t.startup.single\t\t= slab_prepare_cpu,\n\t\t.teardown.single\t= slab_dead_cpu,\n\t},\n\t[CPUHP_RCUTREE_PREP] = {\n\t\t.name\t\t\t= \"RCU/tree:prepare\",\n\t\t.startup.single\t\t= rcutree_prepare_cpu,\n\t\t.teardown.single\t= rcutree_dead_cpu,\n\t},\n\t/*\n\t * On the tear-down path, timers_dead_cpu() must be invoked\n\t * before blk_mq_queue_reinit_notify() from notify_dead(),\n\t * otherwise a RCU stall occurs.\n\t */\n\t[CPUHP_TIMERS_PREPARE] = {\n\t\t.name\t\t\t= \"timers:prepare\",\n\t\t.startup.single\t\t= timers_prepare_cpu,\n\t\t.teardown.single\t= timers_dead_cpu,\n\t},\n\t/* Kicks the plugged cpu into life */\n\t[CPUHP_BRINGUP_CPU] = {\n\t\t.name\t\t\t= \"cpu:bringup\",\n\t\t.startup.single\t\t= bringup_cpu,\n\t\t.teardown.single\t= finish_cpu,\n\t\t.cant_stop\t\t= true,\n\t},\n\t/* Final state before CPU kills itself */\n\t[CPUHP_AP_IDLE_DEAD] = {\n\t\t.name\t\t\t= \"idle:dead\",\n\t},\n\t/*\n\t * Last state before CPU enters the idle loop to die. Transient state\n\t * for synchronization.\n\t */\n\t[CPUHP_AP_OFFLINE] = {\n\t\t.name\t\t\t= \"ap:offline\",\n\t\t.cant_stop\t\t= true,\n\t},\n\t/* First state is scheduler control. Interrupts are disabled */\n\t[CPUHP_AP_SCHED_STARTING] = {\n\t\t.name\t\t\t= \"sched:starting\",\n\t\t.startup.single\t\t= sched_cpu_starting,\n\t\t.teardown.single\t= sched_cpu_dying,\n\t},\n\t[CPUHP_AP_RCUTREE_DYING] = {\n\t\t.name\t\t\t= \"RCU/tree:dying\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= rcutree_dying_cpu,\n\t},\n\t[CPUHP_AP_SMPCFD_DYING] = {\n\t\t.name\t\t\t= \"smpcfd:dying\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= smpcfd_dying_cpu,\n\t},\n\t/* Entry state on starting. Interrupts enabled from here on. Transient\n\t * state for synchronsization */\n\t[CPUHP_AP_ONLINE] = {\n\t\t.name\t\t\t= \"ap:online\",\n\t},\n\t/*\n\t * Handled on control processor until the plugged processor manages\n\t * this itself.\n\t */\n\t[CPUHP_TEARDOWN_CPU] = {\n\t\t.name\t\t\t= \"cpu:teardown\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= takedown_cpu,\n\t\t.cant_stop\t\t= true,\n\t},\n\n\t[CPUHP_AP_SCHED_WAIT_EMPTY] = {\n\t\t.name\t\t\t= \"sched:waitempty\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= sched_cpu_wait_empty,\n\t},\n\n\t/* Handle smpboot threads park/unpark */\n\t[CPUHP_AP_SMPBOOT_THREADS] = {\n\t\t.name\t\t\t= \"smpboot/threads:online\",\n\t\t.startup.single\t\t= smpboot_unpark_threads,\n\t\t.teardown.single\t= smpboot_park_threads,\n\t},\n\t[CPUHP_AP_IRQ_AFFINITY_ONLINE] = {\n\t\t.name\t\t\t= \"irq/affinity:online\",\n\t\t.startup.single\t\t= irq_affinity_online_cpu,\n\t\t.teardown.single\t= NULL,\n\t},\n\t[CPUHP_AP_PERF_ONLINE] = {\n\t\t.name\t\t\t= \"perf:online\",\n\t\t.startup.single\t\t= perf_event_init_cpu,\n\t\t.teardown.single\t= perf_event_exit_cpu,\n\t},\n\t[CPUHP_AP_WATCHDOG_ONLINE] = {\n\t\t.name\t\t\t= \"lockup_detector:online\",\n\t\t.startup.single\t\t= lockup_detector_online_cpu,\n\t\t.teardown.single\t= lockup_detector_offline_cpu,\n\t},\n\t[CPUHP_AP_WORKQUEUE_ONLINE] = {\n\t\t.name\t\t\t= \"workqueue:online\",\n\t\t.startup.single\t\t= workqueue_online_cpu,\n\t\t.teardown.single\t= workqueue_offline_cpu,\n\t},\n\t[CPUHP_AP_RCUTREE_ONLINE] = {\n\t\t.name\t\t\t= \"RCU/tree:online\",\n\t\t.startup.single\t\t= rcutree_online_cpu,\n\t\t.teardown.single\t= rcutree_offline_cpu,\n\t},\n#endif\n\t/*\n\t * The dynamically registered state space is here\n\t */\n\n#ifdef CONFIG_SMP\n\t/* Last state is scheduler control setting the cpu active */\n\t[CPUHP_AP_ACTIVE] = {\n\t\t.name\t\t\t= \"sched:active\",\n\t\t.startup.single\t\t= sched_cpu_activate,\n\t\t.teardown.single\t= sched_cpu_deactivate,\n\t},\n#endif\n\n\t/* CPU is fully up and running. */\n\t[CPUHP_ONLINE] = {\n\t\t.name\t\t\t= \"online\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= NULL,\n\t},\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\nstatic struct cpuhp_step cpuhp_hp_states[];\nstatic struct cpuhp_step cpuhp_hp_states[] = {\n\t[CPUHP_OFFLINE] = {\n\t\t.name\t\t\t= \"offline\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= NULL,\n\t},\n#ifdef CONFIG_SMP\n\t[CPUHP_CREATE_THREADS]= {\n\t\t.name\t\t\t= \"threads:prepare\",\n\t\t.startup.single\t\t= smpboot_create_threads,\n\t\t.teardown.single\t= NULL,\n\t\t.cant_stop\t\t= true,\n\t},\n\t[CPUHP_PERF_PREPARE] = {\n\t\t.name\t\t\t= \"perf:prepare\",\n\t\t.startup.single\t\t= perf_event_init_cpu,\n\t\t.teardown.single\t= perf_event_exit_cpu,\n\t},\n\t[CPUHP_WORKQUEUE_PREP] = {\n\t\t.name\t\t\t= \"workqueue:prepare\",\n\t\t.startup.single\t\t= workqueue_prepare_cpu,\n\t\t.teardown.single\t= NULL,\n\t},\n\t[CPUHP_HRTIMERS_PREPARE] = {\n\t\t.name\t\t\t= \"hrtimers:prepare\",\n\t\t.startup.single\t\t= hrtimers_prepare_cpu,\n\t\t.teardown.single\t= hrtimers_dead_cpu,\n\t},\n\t[CPUHP_SMPCFD_PREPARE] = {\n\t\t.name\t\t\t= \"smpcfd:prepare\",\n\t\t.startup.single\t\t= smpcfd_prepare_cpu,\n\t\t.teardown.single\t= smpcfd_dead_cpu,\n\t},\n\t[CPUHP_RELAY_PREPARE] = {\n\t\t.name\t\t\t= \"relay:prepare\",\n\t\t.startup.single\t\t= relay_prepare_cpu,\n\t\t.teardown.single\t= NULL,\n\t},\n\t[CPUHP_SLAB_PREPARE] = {\n\t\t.name\t\t\t= \"slab:prepare\",\n\t\t.startup.single\t\t= slab_prepare_cpu,\n\t\t.teardown.single\t= slab_dead_cpu,\n\t},\n\t[CPUHP_RCUTREE_PREP] = {\n\t\t.name\t\t\t= \"RCU/tree:prepare\",\n\t\t.startup.single\t\t= rcutree_prepare_cpu,\n\t\t.teardown.single\t= rcutree_dead_cpu,\n\t},\n\t/*\n\t * On the tear-down path, timers_dead_cpu() must be invoked\n\t * before blk_mq_queue_reinit_notify() from notify_dead(),\n\t * otherwise a RCU stall occurs.\n\t */\n\t[CPUHP_TIMERS_PREPARE] = {\n\t\t.name\t\t\t= \"timers:prepare\",\n\t\t.startup.single\t\t= timers_prepare_cpu,\n\t\t.teardown.single\t= timers_dead_cpu,\n\t},\n\t/* Kicks the plugged cpu into life */\n\t[CPUHP_BRINGUP_CPU] = {\n\t\t.name\t\t\t= \"cpu:bringup\",\n\t\t.startup.single\t\t= bringup_cpu,\n\t\t.teardown.single\t= finish_cpu,\n\t\t.cant_stop\t\t= true,\n\t},\n\t/* Final state before CPU kills itself */\n\t[CPUHP_AP_IDLE_DEAD] = {\n\t\t.name\t\t\t= \"idle:dead\",\n\t},\n\t/*\n\t * Last state before CPU enters the idle loop to die. Transient state\n\t * for synchronization.\n\t */\n\t[CPUHP_AP_OFFLINE] = {\n\t\t.name\t\t\t= \"ap:offline\",\n\t\t.cant_stop\t\t= true,\n\t},\n\t/* First state is scheduler control. Interrupts are disabled */\n\t[CPUHP_AP_SCHED_STARTING] = {\n\t\t.name\t\t\t= \"sched:starting\",\n\t\t.startup.single\t\t= sched_cpu_starting,\n\t\t.teardown.single\t= sched_cpu_dying,\n\t},\n\t[CPUHP_AP_RCUTREE_DYING] = {\n\t\t.name\t\t\t= \"RCU/tree:dying\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= rcutree_dying_cpu,\n\t},\n\t[CPUHP_AP_SMPCFD_DYING] = {\n\t\t.name\t\t\t= \"smpcfd:dying\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= smpcfd_dying_cpu,\n\t},\n\t/* Entry state on starting. Interrupts enabled from here on. Transient\n\t * state for synchronsization */\n\t[CPUHP_AP_ONLINE] = {\n\t\t.name\t\t\t= \"ap:online\",\n\t},\n\t/*\n\t * Handled on control processor until the plugged processor manages\n\t * this itself.\n\t */\n\t[CPUHP_TEARDOWN_CPU] = {\n\t\t.name\t\t\t= \"cpu:teardown\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= takedown_cpu,\n\t\t.cant_stop\t\t= true,\n\t},\n\n\t[CPUHP_AP_SCHED_WAIT_EMPTY] = {\n\t\t.name\t\t\t= \"sched:waitempty\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= sched_cpu_wait_empty,\n\t},\n\n\t/* Handle smpboot threads park/unpark */\n\t[CPUHP_AP_SMPBOOT_THREADS] = {\n\t\t.name\t\t\t= \"smpboot/threads:online\",\n\t\t.startup.single\t\t= smpboot_unpark_threads,\n\t\t.teardown.single\t= smpboot_park_threads,\n\t},\n\t[CPUHP_AP_IRQ_AFFINITY_ONLINE] = {\n\t\t.name\t\t\t= \"irq/affinity:online\",\n\t\t.startup.single\t\t= irq_affinity_online_cpu,\n\t\t.teardown.single\t= NULL,\n\t},\n\t[CPUHP_AP_PERF_ONLINE] = {\n\t\t.name\t\t\t= \"perf:online\",\n\t\t.startup.single\t\t= perf_event_init_cpu,\n\t\t.teardown.single\t= perf_event_exit_cpu,\n\t},\n\t[CPUHP_AP_WATCHDOG_ONLINE] = {\n\t\t.name\t\t\t= \"lockup_detector:online\",\n\t\t.startup.single\t\t= lockup_detector_online_cpu,\n\t\t.teardown.single\t= lockup_detector_offline_cpu,\n\t},\n\t[CPUHP_AP_WORKQUEUE_ONLINE] = {\n\t\t.name\t\t\t= \"workqueue:online\",\n\t\t.startup.single\t\t= workqueue_online_cpu,\n\t\t.teardown.single\t= workqueue_offline_cpu,\n\t},\n\t[CPUHP_AP_RCUTREE_ONLINE] = {\n\t\t.name\t\t\t= \"RCU/tree:online\",\n\t\t.startup.single\t\t= rcutree_online_cpu,\n\t\t.teardown.single\t= rcutree_offline_cpu,\n\t},\n#endif\n\t/*\n\t * The dynamically registered state space is here\n\t */\n\n#ifdef CONFIG_SMP\n\t/* Last state is scheduler control setting the cpu active */\n\t[CPUHP_AP_ACTIVE] = {\n\t\t.name\t\t\t= \"sched:active\",\n\t\t.startup.single\t\t= sched_cpu_activate,\n\t\t.teardown.single\t= sched_cpu_deactivate,\n\t},\n#endif\n\n\t/* CPU is fully up and running. */\n\t[CPUHP_ONLINE] = {\n\t\t.name\t\t\t= \"online\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= NULL,\n\t},\n};\n\nstatic int cpuhp_reserve_state(enum cpuhp_state state)\n{\n\tenum cpuhp_state i, end;\n\tstruct cpuhp_step *step;\n\n\tswitch (state) {\n\tcase CPUHP_AP_ONLINE_DYN:\n\t\tstep = cpuhp_hp_states + CPUHP_AP_ONLINE_DYN;\n\t\tend = CPUHP_AP_ONLINE_DYN_END;\n\t\tbreak;\n\tcase CPUHP_BP_PREPARE_DYN:\n\t\tstep = cpuhp_hp_states + CPUHP_BP_PREPARE_DYN;\n\t\tend = CPUHP_BP_PREPARE_DYN_END;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = state; i <= end; i++, step++) {\n\t\tif (!step->name)\n\t\t\treturn i;\n\t}\n\tWARN(1, \"No more dynamic states available for CPU hotplug\\n\");\n\treturn -ENOSPC;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\n\nstatic int cpuhp_store_callbacks(enum cpuhp_state state, const char *name,\n\t\t\t\t int (*startup)(unsigned int cpu),\n\t\t\t\t int (*teardown)(unsigned int cpu),\n\t\t\t\t bool multi_instance)\n{\n\t/* (Un)Install the callbacks for further cpu hotplug operations */\n\tstruct cpuhp_step *sp;\n\tint ret = 0;\n\n\t/*\n\t * If name is NULL, then the state gets removed.\n\t *\n\t * CPUHP_AP_ONLINE_DYN and CPUHP_BP_PREPARE_DYN are handed out on\n\t * the first allocation from these dynamic ranges, so the removal\n\t * would trigger a new allocation and clear the wrong (already\n\t * empty) state, leaving the callbacks of the to be cleared state\n\t * dangling, which causes wreckage on the next hotplug operation.\n\t */\n\tif (name && (state == CPUHP_AP_ONLINE_DYN ||\n\t\t     state == CPUHP_BP_PREPARE_DYN)) {\n\t\tret = cpuhp_reserve_state(state);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tstate = ret;\n\t}\n\tsp = cpuhp_get_step(state);\n\tif (name && sp->name)\n\t\treturn -EBUSY;\n\n\tsp->startup.single = startup;\n\tsp->teardown.single = teardown;\n\tsp->name = name;\n\tsp->multi_instance = multi_instance;\n\tINIT_HLIST_HEAD(&sp->list);\n\treturn ret;\n}"
  },
  {
    "function_name": "cpuhp_reserve_state",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
    "lines": "1825-1849",
    "snippet": "static int cpuhp_reserve_state(enum cpuhp_state state)\n{\n\tenum cpuhp_state i, end;\n\tstruct cpuhp_step *step;\n\n\tswitch (state) {\n\tcase CPUHP_AP_ONLINE_DYN:\n\t\tstep = cpuhp_hp_states + CPUHP_AP_ONLINE_DYN;\n\t\tend = CPUHP_AP_ONLINE_DYN_END;\n\t\tbreak;\n\tcase CPUHP_BP_PREPARE_DYN:\n\t\tstep = cpuhp_hp_states + CPUHP_BP_PREPARE_DYN;\n\t\tend = CPUHP_BP_PREPARE_DYN_END;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = state; i <= end; i++, step++) {\n\t\tif (!step->name)\n\t\t\treturn i;\n\t}\n\tWARN(1, \"No more dynamic states available for CPU hotplug\\n\");\n\treturn -ENOSPC;\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/scs.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sched/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};",
      "static struct cpuhp_step cpuhp_hp_states[];",
      "static struct cpuhp_step cpuhp_hp_states[] = {\n\t[CPUHP_OFFLINE] = {\n\t\t.name\t\t\t= \"offline\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= NULL,\n\t},\n#ifdef CONFIG_SMP\n\t[CPUHP_CREATE_THREADS]= {\n\t\t.name\t\t\t= \"threads:prepare\",\n\t\t.startup.single\t\t= smpboot_create_threads,\n\t\t.teardown.single\t= NULL,\n\t\t.cant_stop\t\t= true,\n\t},\n\t[CPUHP_PERF_PREPARE] = {\n\t\t.name\t\t\t= \"perf:prepare\",\n\t\t.startup.single\t\t= perf_event_init_cpu,\n\t\t.teardown.single\t= perf_event_exit_cpu,\n\t},\n\t[CPUHP_WORKQUEUE_PREP] = {\n\t\t.name\t\t\t= \"workqueue:prepare\",\n\t\t.startup.single\t\t= workqueue_prepare_cpu,\n\t\t.teardown.single\t= NULL,\n\t},\n\t[CPUHP_HRTIMERS_PREPARE] = {\n\t\t.name\t\t\t= \"hrtimers:prepare\",\n\t\t.startup.single\t\t= hrtimers_prepare_cpu,\n\t\t.teardown.single\t= hrtimers_dead_cpu,\n\t},\n\t[CPUHP_SMPCFD_PREPARE] = {\n\t\t.name\t\t\t= \"smpcfd:prepare\",\n\t\t.startup.single\t\t= smpcfd_prepare_cpu,\n\t\t.teardown.single\t= smpcfd_dead_cpu,\n\t},\n\t[CPUHP_RELAY_PREPARE] = {\n\t\t.name\t\t\t= \"relay:prepare\",\n\t\t.startup.single\t\t= relay_prepare_cpu,\n\t\t.teardown.single\t= NULL,\n\t},\n\t[CPUHP_SLAB_PREPARE] = {\n\t\t.name\t\t\t= \"slab:prepare\",\n\t\t.startup.single\t\t= slab_prepare_cpu,\n\t\t.teardown.single\t= slab_dead_cpu,\n\t},\n\t[CPUHP_RCUTREE_PREP] = {\n\t\t.name\t\t\t= \"RCU/tree:prepare\",\n\t\t.startup.single\t\t= rcutree_prepare_cpu,\n\t\t.teardown.single\t= rcutree_dead_cpu,\n\t},\n\t/*\n\t * On the tear-down path, timers_dead_cpu() must be invoked\n\t * before blk_mq_queue_reinit_notify() from notify_dead(),\n\t * otherwise a RCU stall occurs.\n\t */\n\t[CPUHP_TIMERS_PREPARE] = {\n\t\t.name\t\t\t= \"timers:prepare\",\n\t\t.startup.single\t\t= timers_prepare_cpu,\n\t\t.teardown.single\t= timers_dead_cpu,\n\t},\n\t/* Kicks the plugged cpu into life */\n\t[CPUHP_BRINGUP_CPU] = {\n\t\t.name\t\t\t= \"cpu:bringup\",\n\t\t.startup.single\t\t= bringup_cpu,\n\t\t.teardown.single\t= finish_cpu,\n\t\t.cant_stop\t\t= true,\n\t},\n\t/* Final state before CPU kills itself */\n\t[CPUHP_AP_IDLE_DEAD] = {\n\t\t.name\t\t\t= \"idle:dead\",\n\t},\n\t/*\n\t * Last state before CPU enters the idle loop to die. Transient state\n\t * for synchronization.\n\t */\n\t[CPUHP_AP_OFFLINE] = {\n\t\t.name\t\t\t= \"ap:offline\",\n\t\t.cant_stop\t\t= true,\n\t},\n\t/* First state is scheduler control. Interrupts are disabled */\n\t[CPUHP_AP_SCHED_STARTING] = {\n\t\t.name\t\t\t= \"sched:starting\",\n\t\t.startup.single\t\t= sched_cpu_starting,\n\t\t.teardown.single\t= sched_cpu_dying,\n\t},\n\t[CPUHP_AP_RCUTREE_DYING] = {\n\t\t.name\t\t\t= \"RCU/tree:dying\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= rcutree_dying_cpu,\n\t},\n\t[CPUHP_AP_SMPCFD_DYING] = {\n\t\t.name\t\t\t= \"smpcfd:dying\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= smpcfd_dying_cpu,\n\t},\n\t/* Entry state on starting. Interrupts enabled from here on. Transient\n\t * state for synchronsization */\n\t[CPUHP_AP_ONLINE] = {\n\t\t.name\t\t\t= \"ap:online\",\n\t},\n\t/*\n\t * Handled on control processor until the plugged processor manages\n\t * this itself.\n\t */\n\t[CPUHP_TEARDOWN_CPU] = {\n\t\t.name\t\t\t= \"cpu:teardown\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= takedown_cpu,\n\t\t.cant_stop\t\t= true,\n\t},\n\n\t[CPUHP_AP_SCHED_WAIT_EMPTY] = {\n\t\t.name\t\t\t= \"sched:waitempty\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= sched_cpu_wait_empty,\n\t},\n\n\t/* Handle smpboot threads park/unpark */\n\t[CPUHP_AP_SMPBOOT_THREADS] = {\n\t\t.name\t\t\t= \"smpboot/threads:online\",\n\t\t.startup.single\t\t= smpboot_unpark_threads,\n\t\t.teardown.single\t= smpboot_park_threads,\n\t},\n\t[CPUHP_AP_IRQ_AFFINITY_ONLINE] = {\n\t\t.name\t\t\t= \"irq/affinity:online\",\n\t\t.startup.single\t\t= irq_affinity_online_cpu,\n\t\t.teardown.single\t= NULL,\n\t},\n\t[CPUHP_AP_PERF_ONLINE] = {\n\t\t.name\t\t\t= \"perf:online\",\n\t\t.startup.single\t\t= perf_event_init_cpu,\n\t\t.teardown.single\t= perf_event_exit_cpu,\n\t},\n\t[CPUHP_AP_WATCHDOG_ONLINE] = {\n\t\t.name\t\t\t= \"lockup_detector:online\",\n\t\t.startup.single\t\t= lockup_detector_online_cpu,\n\t\t.teardown.single\t= lockup_detector_offline_cpu,\n\t},\n\t[CPUHP_AP_WORKQUEUE_ONLINE] = {\n\t\t.name\t\t\t= \"workqueue:online\",\n\t\t.startup.single\t\t= workqueue_online_cpu,\n\t\t.teardown.single\t= workqueue_offline_cpu,\n\t},\n\t[CPUHP_AP_RCUTREE_ONLINE] = {\n\t\t.name\t\t\t= \"RCU/tree:online\",\n\t\t.startup.single\t\t= rcutree_online_cpu,\n\t\t.teardown.single\t= rcutree_offline_cpu,\n\t},\n#endif\n\t/*\n\t * The dynamically registered state space is here\n\t */\n\n#ifdef CONFIG_SMP\n\t/* Last state is scheduler control setting the cpu active */\n\t[CPUHP_AP_ACTIVE] = {\n\t\t.name\t\t\t= \"sched:active\",\n\t\t.startup.single\t\t= sched_cpu_activate,\n\t\t.teardown.single\t= sched_cpu_deactivate,\n\t},\n#endif\n\n\t/* CPU is fully up and running. */\n\t[CPUHP_ONLINE] = {\n\t\t.name\t\t\t= \"online\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= NULL,\n\t},\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "1",
            "\"No more dynamic states available for CPU hotplug\\n\""
          ],
          "line": 1847
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\nstatic struct cpuhp_step cpuhp_hp_states[];\nstatic struct cpuhp_step cpuhp_hp_states[] = {\n\t[CPUHP_OFFLINE] = {\n\t\t.name\t\t\t= \"offline\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= NULL,\n\t},\n#ifdef CONFIG_SMP\n\t[CPUHP_CREATE_THREADS]= {\n\t\t.name\t\t\t= \"threads:prepare\",\n\t\t.startup.single\t\t= smpboot_create_threads,\n\t\t.teardown.single\t= NULL,\n\t\t.cant_stop\t\t= true,\n\t},\n\t[CPUHP_PERF_PREPARE] = {\n\t\t.name\t\t\t= \"perf:prepare\",\n\t\t.startup.single\t\t= perf_event_init_cpu,\n\t\t.teardown.single\t= perf_event_exit_cpu,\n\t},\n\t[CPUHP_WORKQUEUE_PREP] = {\n\t\t.name\t\t\t= \"workqueue:prepare\",\n\t\t.startup.single\t\t= workqueue_prepare_cpu,\n\t\t.teardown.single\t= NULL,\n\t},\n\t[CPUHP_HRTIMERS_PREPARE] = {\n\t\t.name\t\t\t= \"hrtimers:prepare\",\n\t\t.startup.single\t\t= hrtimers_prepare_cpu,\n\t\t.teardown.single\t= hrtimers_dead_cpu,\n\t},\n\t[CPUHP_SMPCFD_PREPARE] = {\n\t\t.name\t\t\t= \"smpcfd:prepare\",\n\t\t.startup.single\t\t= smpcfd_prepare_cpu,\n\t\t.teardown.single\t= smpcfd_dead_cpu,\n\t},\n\t[CPUHP_RELAY_PREPARE] = {\n\t\t.name\t\t\t= \"relay:prepare\",\n\t\t.startup.single\t\t= relay_prepare_cpu,\n\t\t.teardown.single\t= NULL,\n\t},\n\t[CPUHP_SLAB_PREPARE] = {\n\t\t.name\t\t\t= \"slab:prepare\",\n\t\t.startup.single\t\t= slab_prepare_cpu,\n\t\t.teardown.single\t= slab_dead_cpu,\n\t},\n\t[CPUHP_RCUTREE_PREP] = {\n\t\t.name\t\t\t= \"RCU/tree:prepare\",\n\t\t.startup.single\t\t= rcutree_prepare_cpu,\n\t\t.teardown.single\t= rcutree_dead_cpu,\n\t},\n\t/*\n\t * On the tear-down path, timers_dead_cpu() must be invoked\n\t * before blk_mq_queue_reinit_notify() from notify_dead(),\n\t * otherwise a RCU stall occurs.\n\t */\n\t[CPUHP_TIMERS_PREPARE] = {\n\t\t.name\t\t\t= \"timers:prepare\",\n\t\t.startup.single\t\t= timers_prepare_cpu,\n\t\t.teardown.single\t= timers_dead_cpu,\n\t},\n\t/* Kicks the plugged cpu into life */\n\t[CPUHP_BRINGUP_CPU] = {\n\t\t.name\t\t\t= \"cpu:bringup\",\n\t\t.startup.single\t\t= bringup_cpu,\n\t\t.teardown.single\t= finish_cpu,\n\t\t.cant_stop\t\t= true,\n\t},\n\t/* Final state before CPU kills itself */\n\t[CPUHP_AP_IDLE_DEAD] = {\n\t\t.name\t\t\t= \"idle:dead\",\n\t},\n\t/*\n\t * Last state before CPU enters the idle loop to die. Transient state\n\t * for synchronization.\n\t */\n\t[CPUHP_AP_OFFLINE] = {\n\t\t.name\t\t\t= \"ap:offline\",\n\t\t.cant_stop\t\t= true,\n\t},\n\t/* First state is scheduler control. Interrupts are disabled */\n\t[CPUHP_AP_SCHED_STARTING] = {\n\t\t.name\t\t\t= \"sched:starting\",\n\t\t.startup.single\t\t= sched_cpu_starting,\n\t\t.teardown.single\t= sched_cpu_dying,\n\t},\n\t[CPUHP_AP_RCUTREE_DYING] = {\n\t\t.name\t\t\t= \"RCU/tree:dying\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= rcutree_dying_cpu,\n\t},\n\t[CPUHP_AP_SMPCFD_DYING] = {\n\t\t.name\t\t\t= \"smpcfd:dying\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= smpcfd_dying_cpu,\n\t},\n\t/* Entry state on starting. Interrupts enabled from here on. Transient\n\t * state for synchronsization */\n\t[CPUHP_AP_ONLINE] = {\n\t\t.name\t\t\t= \"ap:online\",\n\t},\n\t/*\n\t * Handled on control processor until the plugged processor manages\n\t * this itself.\n\t */\n\t[CPUHP_TEARDOWN_CPU] = {\n\t\t.name\t\t\t= \"cpu:teardown\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= takedown_cpu,\n\t\t.cant_stop\t\t= true,\n\t},\n\n\t[CPUHP_AP_SCHED_WAIT_EMPTY] = {\n\t\t.name\t\t\t= \"sched:waitempty\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= sched_cpu_wait_empty,\n\t},\n\n\t/* Handle smpboot threads park/unpark */\n\t[CPUHP_AP_SMPBOOT_THREADS] = {\n\t\t.name\t\t\t= \"smpboot/threads:online\",\n\t\t.startup.single\t\t= smpboot_unpark_threads,\n\t\t.teardown.single\t= smpboot_park_threads,\n\t},\n\t[CPUHP_AP_IRQ_AFFINITY_ONLINE] = {\n\t\t.name\t\t\t= \"irq/affinity:online\",\n\t\t.startup.single\t\t= irq_affinity_online_cpu,\n\t\t.teardown.single\t= NULL,\n\t},\n\t[CPUHP_AP_PERF_ONLINE] = {\n\t\t.name\t\t\t= \"perf:online\",\n\t\t.startup.single\t\t= perf_event_init_cpu,\n\t\t.teardown.single\t= perf_event_exit_cpu,\n\t},\n\t[CPUHP_AP_WATCHDOG_ONLINE] = {\n\t\t.name\t\t\t= \"lockup_detector:online\",\n\t\t.startup.single\t\t= lockup_detector_online_cpu,\n\t\t.teardown.single\t= lockup_detector_offline_cpu,\n\t},\n\t[CPUHP_AP_WORKQUEUE_ONLINE] = {\n\t\t.name\t\t\t= \"workqueue:online\",\n\t\t.startup.single\t\t= workqueue_online_cpu,\n\t\t.teardown.single\t= workqueue_offline_cpu,\n\t},\n\t[CPUHP_AP_RCUTREE_ONLINE] = {\n\t\t.name\t\t\t= \"RCU/tree:online\",\n\t\t.startup.single\t\t= rcutree_online_cpu,\n\t\t.teardown.single\t= rcutree_offline_cpu,\n\t},\n#endif\n\t/*\n\t * The dynamically registered state space is here\n\t */\n\n#ifdef CONFIG_SMP\n\t/* Last state is scheduler control setting the cpu active */\n\t[CPUHP_AP_ACTIVE] = {\n\t\t.name\t\t\t= \"sched:active\",\n\t\t.startup.single\t\t= sched_cpu_activate,\n\t\t.teardown.single\t= sched_cpu_deactivate,\n\t},\n#endif\n\n\t/* CPU is fully up and running. */\n\t[CPUHP_ONLINE] = {\n\t\t.name\t\t\t= \"online\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= NULL,\n\t},\n};\n\nstatic int cpuhp_reserve_state(enum cpuhp_state state)\n{\n\tenum cpuhp_state i, end;\n\tstruct cpuhp_step *step;\n\n\tswitch (state) {\n\tcase CPUHP_AP_ONLINE_DYN:\n\t\tstep = cpuhp_hp_states + CPUHP_AP_ONLINE_DYN;\n\t\tend = CPUHP_AP_ONLINE_DYN_END;\n\t\tbreak;\n\tcase CPUHP_BP_PREPARE_DYN:\n\t\tstep = cpuhp_hp_states + CPUHP_BP_PREPARE_DYN;\n\t\tend = CPUHP_BP_PREPARE_DYN_END;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = state; i <= end; i++, step++) {\n\t\tif (!step->name)\n\t\t\treturn i;\n\t}\n\tWARN(1, \"No more dynamic states available for CPU hotplug\\n\");\n\treturn -ENOSPC;\n}"
  },
  {
    "function_name": "cpuhp_cb_check",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
    "lines": "1813-1818",
    "snippet": "static int cpuhp_cb_check(enum cpuhp_state state)\n{\n\tif (state <= CPUHP_OFFLINE || state >= CPUHP_ONLINE)\n\t\treturn -EINVAL;\n\treturn 0;\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/scs.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sched/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\n\nstatic int cpuhp_cb_check(enum cpuhp_state state)\n{\n\tif (state <= CPUHP_OFFLINE || state >= CPUHP_ONLINE)\n\t\treturn -EINVAL;\n\treturn 0;\n}"
  },
  {
    "function_name": "cpu_hotplug_pm_sync_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
    "lines": "1625-1634",
    "snippet": "static int __init cpu_hotplug_pm_sync_init(void)\n{\n\t/*\n\t * cpu_hotplug_pm_callback has higher priority than x86\n\t * bsp_pm_callback which depends on cpu_hotplug_pm_callback\n\t * to disable cpu hotplug to avoid cpu hotplug race.\n\t */\n\tpm_notifier(cpu_hotplug_pm_callback, 0);\n\treturn 0;\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/scs.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sched/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pm_notifier",
          "args": [
            "cpu_hotplug_pm_callback",
            "0"
          ],
          "line": 1632
        },
        "resolved": true,
        "details": {
          "function_name": "pm_notifier_call_chain_robust",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/main.c",
          "lines": "83-90",
          "snippet": "int pm_notifier_call_chain_robust(unsigned long val_up, unsigned long val_down)\n{\n\tint ret;\n\n\tret = blocking_notifier_call_chain_robust(&pm_chain_head, val_up, val_down, NULL);\n\n\treturn notifier_to_errno(ret);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/pm_runtime.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/pm-trace.h>",
            "#include <linux/string.h>",
            "#include <linux/kobject.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/pm_runtime.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/workqueue.h>\n#include <linux/pm-trace.h>\n#include <linux/string.h>\n#include <linux/kobject.h>\n#include <linux/export.h>\n\nint pm_notifier_call_chain_robust(unsigned long val_up, unsigned long val_down)\n{\n\tint ret;\n\n\tret = blocking_notifier_call_chain_robust(&pm_chain_head, val_up, val_down, NULL);\n\n\treturn notifier_to_errno(ret);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstatic int __init cpu_hotplug_pm_sync_init(void)\n{\n\t/*\n\t * cpu_hotplug_pm_callback has higher priority than x86\n\t * bsp_pm_callback which depends on cpu_hotplug_pm_callback\n\t * to disable cpu hotplug to avoid cpu hotplug race.\n\t */\n\tpm_notifier(cpu_hotplug_pm_callback, 0);\n\treturn 0;\n}"
  },
  {
    "function_name": "cpu_hotplug_pm_callback",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
    "lines": "1601-1622",
    "snippet": "static int\ncpu_hotplug_pm_callback(struct notifier_block *nb,\n\t\t\tunsigned long action, void *ptr)\n{\n\tswitch (action) {\n\n\tcase PM_SUSPEND_PREPARE:\n\tcase PM_HIBERNATION_PREPARE:\n\t\tcpu_hotplug_disable();\n\t\tbreak;\n\n\tcase PM_POST_SUSPEND:\n\tcase PM_POST_HIBERNATION:\n\t\tcpu_hotplug_enable();\n\t\tbreak;\n\n\tdefault:\n\t\treturn NOTIFY_DONE;\n\t}\n\n\treturn NOTIFY_OK;\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/scs.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sched/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_hotplug_enable",
          "args": [],
          "line": 1614
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_hotplug_enable",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "388-393",
          "snippet": "void cpu_hotplug_enable(void)\n{\n\tcpu_maps_update_begin();\n\t__cpu_hotplug_enable();\n\tcpu_maps_update_done();\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nvoid cpu_hotplug_enable(void)\n{\n\tcpu_maps_update_begin();\n\t__cpu_hotplug_enable();\n\tcpu_maps_update_done();\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_hotplug_disable",
          "args": [],
          "line": 1609
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_hotplug_disable",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "373-378",
          "snippet": "void cpu_hotplug_disable(void)\n{\n\tcpu_maps_update_begin();\n\tcpu_hotplug_disabled++;\n\tcpu_maps_update_done();\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nvoid cpu_hotplug_disable(void)\n{\n\tcpu_maps_update_begin();\n\tcpu_hotplug_disabled++;\n\tcpu_maps_update_done();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstatic int\ncpu_hotplug_pm_callback(struct notifier_block *nb,\n\t\t\tunsigned long action, void *ptr)\n{\n\tswitch (action) {\n\n\tcase PM_SUSPEND_PREPARE:\n\tcase PM_HIBERNATION_PREPARE:\n\t\tcpu_hotplug_disable();\n\t\tbreak;\n\n\tcase PM_POST_SUSPEND:\n\tcase PM_POST_HIBERNATION:\n\t\tcpu_hotplug_enable();\n\t\tbreak;\n\n\tdefault:\n\t\treturn NOTIFY_DONE;\n\t}\n\n\treturn NOTIFY_OK;\n}"
  },
  {
    "function_name": "alloc_frozen_cpus",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
    "lines": "1582-1587",
    "snippet": "static int __init alloc_frozen_cpus(void)\n{\n\tif (!alloc_cpumask_var(&frozen_cpus, GFP_KERNEL|__GFP_ZERO))\n\t\treturn -ENOMEM;\n\treturn 0;\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/scs.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sched/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "alloc_cpumask_var",
          "args": [
            "&frozen_cpus",
            "GFP_KERNEL|__GFP_ZERO"
          ],
          "line": 1584
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstatic int __init alloc_frozen_cpus(void)\n{\n\tif (!alloc_cpumask_var(&frozen_cpus, GFP_KERNEL|__GFP_ZERO))\n\t\treturn -ENOMEM;\n\treturn 0;\n}"
  },
  {
    "function_name": "thaw_secondary_cpus",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
    "lines": "1550-1580",
    "snippet": "void thaw_secondary_cpus(void)\n{\n\tint cpu, error;\n\n\t/* Allow everyone to use the CPU hotplug again */\n\tcpu_maps_update_begin();\n\t__cpu_hotplug_enable();\n\tif (cpumask_empty(frozen_cpus))\n\t\tgoto out;\n\n\tpr_info(\"Enabling non-boot CPUs ...\\n\");\n\n\tarch_thaw_secondary_cpus_begin();\n\n\tfor_each_cpu(cpu, frozen_cpus) {\n\t\ttrace_suspend_resume(TPS(\"CPU_ON\"), cpu, true);\n\t\terror = _cpu_up(cpu, 1, CPUHP_ONLINE);\n\t\ttrace_suspend_resume(TPS(\"CPU_ON\"), cpu, false);\n\t\tif (!error) {\n\t\t\tpr_info(\"CPU%d is up\\n\", cpu);\n\t\t\tcontinue;\n\t\t}\n\t\tpr_warn(\"Error taking CPU%d up: %d\\n\", cpu, error);\n\t}\n\n\tarch_thaw_secondary_cpus_end();\n\n\tcpumask_clear(frozen_cpus);\nout:\n\tcpu_maps_update_done();\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/scs.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sched/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_maps_update_done",
          "args": [],
          "line": 1579
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_maps_update_done",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "292-295",
          "snippet": "void cpu_maps_update_done(void)\n{\n\tmutex_unlock(&cpu_add_remove_lock);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nvoid cpu_maps_update_done(void)\n{\n\tmutex_unlock(&cpu_add_remove_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_clear",
          "args": [
            "frozen_cpus"
          ],
          "line": 1577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_thaw_secondary_cpus_end",
          "args": [],
          "line": 1575
        },
        "resolved": true,
        "details": {
          "function_name": "arch_thaw_secondary_cpus_end",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "1546-1548",
          "snippet": "void __weak arch_thaw_secondary_cpus_end(void)\n{\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nvoid __weak arch_thaw_secondary_cpus_end(void)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"Error taking CPU%d up: %d\\n\"",
            "cpu",
            "error"
          ],
          "line": 1572
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"CPU%d is up\\n\"",
            "cpu"
          ],
          "line": 1569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_suspend_resume",
          "args": [
            "TPS(\"CPU_ON\")",
            "cpu",
            "false"
          ],
          "line": 1567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPS",
          "args": [
            "\"CPU_ON\""
          ],
          "line": 1567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_cpu_up",
          "args": [
            "cpu",
            "1",
            "CPUHP_ONLINE"
          ],
          "line": 1566
        },
        "resolved": true,
        "details": {
          "function_name": "_cpu_up",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "1323-1381",
          "snippet": "static int _cpu_up(unsigned int cpu, int tasks_frozen, enum cpuhp_state target)\n{\n\tstruct cpuhp_cpu_state *st = per_cpu_ptr(&cpuhp_state, cpu);\n\tstruct task_struct *idle;\n\tint ret = 0;\n\n\tcpus_write_lock();\n\n\tif (!cpu_present(cpu)) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * The caller of cpu_up() might have raced with another\n\t * caller. Nothing to do.\n\t */\n\tif (st->state >= target)\n\t\tgoto out;\n\n\tif (st->state == CPUHP_OFFLINE) {\n\t\t/* Let it fail before we try to bring the cpu up */\n\t\tidle = idle_thread_get(cpu);\n\t\tif (IS_ERR(idle)) {\n\t\t\tret = PTR_ERR(idle);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tcpuhp_tasks_frozen = tasks_frozen;\n\n\tcpuhp_set_state(st, target);\n\t/*\n\t * If the current CPU state is in the range of the AP hotplug thread,\n\t * then we need to kick the thread once more.\n\t */\n\tif (st->state > CPUHP_BRINGUP_CPU) {\n\t\tret = cpuhp_kick_ap_work(cpu);\n\t\t/*\n\t\t * The AP side has done the error rollback already. Just\n\t\t * return the error code..\n\t\t */\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\t/*\n\t * Try to reach the target state. We max out on the BP at\n\t * CPUHP_BRINGUP_CPU. After that the AP hotplug thread is\n\t * responsible for bringing it up to the target state.\n\t */\n\ttarget = min((int)target, CPUHP_BRINGUP_CPU);\n\tret = cpuhp_up_callbacks(cpu, st, target);\nout:\n\tcpus_write_unlock();\n\tarch_smt_update();\n\tcpu_up_down_serialize_trainwrecks(tasks_frozen);\n\treturn ret;\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\n\nstatic int _cpu_up(unsigned int cpu, int tasks_frozen, enum cpuhp_state target)\n{\n\tstruct cpuhp_cpu_state *st = per_cpu_ptr(&cpuhp_state, cpu);\n\tstruct task_struct *idle;\n\tint ret = 0;\n\n\tcpus_write_lock();\n\n\tif (!cpu_present(cpu)) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * The caller of cpu_up() might have raced with another\n\t * caller. Nothing to do.\n\t */\n\tif (st->state >= target)\n\t\tgoto out;\n\n\tif (st->state == CPUHP_OFFLINE) {\n\t\t/* Let it fail before we try to bring the cpu up */\n\t\tidle = idle_thread_get(cpu);\n\t\tif (IS_ERR(idle)) {\n\t\t\tret = PTR_ERR(idle);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tcpuhp_tasks_frozen = tasks_frozen;\n\n\tcpuhp_set_state(st, target);\n\t/*\n\t * If the current CPU state is in the range of the AP hotplug thread,\n\t * then we need to kick the thread once more.\n\t */\n\tif (st->state > CPUHP_BRINGUP_CPU) {\n\t\tret = cpuhp_kick_ap_work(cpu);\n\t\t/*\n\t\t * The AP side has done the error rollback already. Just\n\t\t * return the error code..\n\t\t */\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\t/*\n\t * Try to reach the target state. We max out on the BP at\n\t * CPUHP_BRINGUP_CPU. After that the AP hotplug thread is\n\t * responsible for bringing it up to the target state.\n\t */\n\ttarget = min((int)target, CPUHP_BRINGUP_CPU);\n\tret = cpuhp_up_callbacks(cpu, st, target);\nout:\n\tcpus_write_unlock();\n\tarch_smt_update();\n\tcpu_up_down_serialize_trainwrecks(tasks_frozen);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_suspend_resume",
          "args": [
            "TPS(\"CPU_ON\")",
            "cpu",
            "true"
          ],
          "line": 1565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPS",
          "args": [
            "\"CPU_ON\""
          ],
          "line": 1565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_cpu",
          "args": [
            "cpu",
            "frozen_cpus"
          ],
          "line": 1564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_thaw_secondary_cpus_begin",
          "args": [],
          "line": 1562
        },
        "resolved": true,
        "details": {
          "function_name": "arch_thaw_secondary_cpus_begin",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "1542-1544",
          "snippet": "void __weak arch_thaw_secondary_cpus_begin(void)\n{\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nvoid __weak arch_thaw_secondary_cpus_begin(void)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Enabling non-boot CPUs ...\\n\""
          ],
          "line": 1560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_empty",
          "args": [
            "frozen_cpus"
          ],
          "line": 1557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__cpu_hotplug_enable",
          "args": [],
          "line": 1556
        },
        "resolved": true,
        "details": {
          "function_name": "__cpu_hotplug_enable",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "381-386",
          "snippet": "static void __cpu_hotplug_enable(void)\n{\n\tif (WARN_ONCE(!cpu_hotplug_disabled, \"Unbalanced cpu hotplug enable\\n\"))\n\t\treturn;\n\tcpu_hotplug_disabled--;\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstatic void __cpu_hotplug_enable(void)\n{\n\tif (WARN_ONCE(!cpu_hotplug_disabled, \"Unbalanced cpu hotplug enable\\n\"))\n\t\treturn;\n\tcpu_hotplug_disabled--;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_maps_update_begin",
          "args": [],
          "line": 1555
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_maps_update_begin",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "287-290",
          "snippet": "void cpu_maps_update_begin(void)\n{\n\tmutex_lock(&cpu_add_remove_lock);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nvoid cpu_maps_update_begin(void)\n{\n\tmutex_lock(&cpu_add_remove_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nvoid thaw_secondary_cpus(void)\n{\n\tint cpu, error;\n\n\t/* Allow everyone to use the CPU hotplug again */\n\tcpu_maps_update_begin();\n\t__cpu_hotplug_enable();\n\tif (cpumask_empty(frozen_cpus))\n\t\tgoto out;\n\n\tpr_info(\"Enabling non-boot CPUs ...\\n\");\n\n\tarch_thaw_secondary_cpus_begin();\n\n\tfor_each_cpu(cpu, frozen_cpus) {\n\t\ttrace_suspend_resume(TPS(\"CPU_ON\"), cpu, true);\n\t\terror = _cpu_up(cpu, 1, CPUHP_ONLINE);\n\t\ttrace_suspend_resume(TPS(\"CPU_ON\"), cpu, false);\n\t\tif (!error) {\n\t\t\tpr_info(\"CPU%d is up\\n\", cpu);\n\t\t\tcontinue;\n\t\t}\n\t\tpr_warn(\"Error taking CPU%d up: %d\\n\", cpu, error);\n\t}\n\n\tarch_thaw_secondary_cpus_end();\n\n\tcpumask_clear(frozen_cpus);\nout:\n\tcpu_maps_update_done();\n}"
  },
  {
    "function_name": "arch_thaw_secondary_cpus_end",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
    "lines": "1546-1548",
    "snippet": "void __weak arch_thaw_secondary_cpus_end(void)\n{\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/scs.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sched/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nvoid __weak arch_thaw_secondary_cpus_end(void)\n{\n}"
  },
  {
    "function_name": "arch_thaw_secondary_cpus_begin",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
    "lines": "1542-1544",
    "snippet": "void __weak arch_thaw_secondary_cpus_begin(void)\n{\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/scs.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sched/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nvoid __weak arch_thaw_secondary_cpus_begin(void)\n{\n}"
  },
  {
    "function_name": "freeze_secondary_cpus",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
    "lines": "1484-1540",
    "snippet": "int freeze_secondary_cpus(int primary)\n{\n\tint cpu, error = 0;\n\n\tcpu_maps_update_begin();\n\tif (primary == -1) {\n\t\tprimary = cpumask_first(cpu_online_mask);\n\t\tif (!housekeeping_cpu(primary, HK_FLAG_TIMER))\n\t\t\tprimary = housekeeping_any_cpu(HK_FLAG_TIMER);\n\t} else {\n\t\tif (!cpu_online(primary))\n\t\t\tprimary = cpumask_first(cpu_online_mask);\n\t}\n\n\t/*\n\t * We take down all of the non-boot CPUs in one shot to avoid races\n\t * with the userspace trying to use the CPU hotplug at the same time\n\t */\n\tcpumask_clear(frozen_cpus);\n\n\tpr_info(\"Disabling non-boot CPUs ...\\n\");\n\tfor_each_online_cpu(cpu) {\n\t\tif (cpu == primary)\n\t\t\tcontinue;\n\n\t\tif (pm_wakeup_pending()) {\n\t\t\tpr_info(\"Wakeup pending. Abort CPU freeze\\n\");\n\t\t\terror = -EBUSY;\n\t\t\tbreak;\n\t\t}\n\n\t\ttrace_suspend_resume(TPS(\"CPU_OFF\"), cpu, true);\n\t\terror = _cpu_down(cpu, 1, CPUHP_OFFLINE);\n\t\ttrace_suspend_resume(TPS(\"CPU_OFF\"), cpu, false);\n\t\tif (!error)\n\t\t\tcpumask_set_cpu(cpu, frozen_cpus);\n\t\telse {\n\t\t\tpr_err(\"Error taking CPU%d down: %d\\n\", cpu, error);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!error)\n\t\tBUG_ON(num_online_cpus() > 1);\n\telse\n\t\tpr_err(\"Non-boot CPUs are not disabled\\n\");\n\n\t/*\n\t * Make sure the CPUs won't be enabled by someone else. We need to do\n\t * this even in case of failure as all freeze_secondary_cpus() users are\n\t * supposed to do thaw_secondary_cpus() on the failure path.\n\t */\n\tcpu_hotplug_disabled++;\n\n\tcpu_maps_update_done();\n\treturn error;\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/scs.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sched/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_maps_update_done",
          "args": [],
          "line": 1538
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_maps_update_done",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "292-295",
          "snippet": "void cpu_maps_update_done(void)\n{\n\tmutex_unlock(&cpu_add_remove_lock);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nvoid cpu_maps_update_done(void)\n{\n\tmutex_unlock(&cpu_add_remove_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Non-boot CPUs are not disabled\\n\""
          ],
          "line": 1529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "num_online_cpus() > 1"
          ],
          "line": 1527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "num_online_cpus",
          "args": [],
          "line": 1527
        },
        "resolved": true,
        "details": {
          "function_name": "torture_num_online_cpus",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/torture.c",
          "lines": "185-188",
          "snippet": "int torture_num_online_cpus(void)\n{\n\treturn READ_ONCE(torture_online_cpus);\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint torture_num_online_cpus(void)\n{\n\treturn READ_ONCE(torture_online_cpus);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Error taking CPU%d down: %d\\n\"",
            "cpu",
            "error"
          ],
          "line": 1521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_set_cpu",
          "args": [
            "cpu",
            "frozen_cpus"
          ],
          "line": 1519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_suspend_resume",
          "args": [
            "TPS(\"CPU_OFF\")",
            "cpu",
            "false"
          ],
          "line": 1517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPS",
          "args": [
            "\"CPU_OFF\""
          ],
          "line": 1517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_cpu_down",
          "args": [
            "cpu",
            "1",
            "CPUHP_OFFLINE"
          ],
          "line": 1516
        },
        "resolved": true,
        "details": {
          "function_name": "_cpu_down",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "1120-1184",
          "snippet": "static int __ref _cpu_down(unsigned int cpu, int tasks_frozen,\n\t\t\t   enum cpuhp_state target)\n{\n\tstruct cpuhp_cpu_state *st = per_cpu_ptr(&cpuhp_state, cpu);\n\tint prev_state, ret = 0;\n\n\tif (num_online_cpus() == 1)\n\t\treturn -EBUSY;\n\n\tif (!cpu_present(cpu))\n\t\treturn -EINVAL;\n\n\tcpus_write_lock();\n\n\tcpuhp_tasks_frozen = tasks_frozen;\n\n\tprev_state = cpuhp_set_state(st, target);\n\t/*\n\t * If the current CPU state is in the range of the AP hotplug thread,\n\t * then we need to kick the thread.\n\t */\n\tif (st->state > CPUHP_TEARDOWN_CPU) {\n\t\tst->target = max((int)target, CPUHP_TEARDOWN_CPU);\n\t\tret = cpuhp_kick_ap_work(cpu);\n\t\t/*\n\t\t * The AP side has done the error rollback already. Just\n\t\t * return the error code..\n\t\t */\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\t/*\n\t\t * We might have stopped still in the range of the AP hotplug\n\t\t * thread. Nothing to do anymore.\n\t\t */\n\t\tif (st->state > CPUHP_TEARDOWN_CPU)\n\t\t\tgoto out;\n\n\t\tst->target = target;\n\t}\n\t/*\n\t * The AP brought itself down to CPUHP_TEARDOWN_CPU. So we need\n\t * to do the further cleanups.\n\t */\n\tret = cpuhp_down_callbacks(cpu, st, target);\n\tif (ret && st->state < prev_state) {\n\t\tif (st->state == CPUHP_TEARDOWN_CPU) {\n\t\t\tcpuhp_reset_state(st, prev_state);\n\t\t\t__cpuhp_kick_ap(st);\n\t\t} else {\n\t\t\tWARN(1, \"DEAD callback error for CPU%d\", cpu);\n\t\t}\n\t}\n\nout:\n\tcpus_write_unlock();\n\t/*\n\t * Do post unplug cleanup. This is still protected against\n\t * concurrent CPU hotplug via cpu_add_remove_lock.\n\t */\n\tlockup_detector_cleanup();\n\tarch_smt_update();\n\tcpu_up_down_serialize_trainwrecks(tasks_frozen);\n\treturn ret;\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\n\nstatic int __ref _cpu_down(unsigned int cpu, int tasks_frozen,\n\t\t\t   enum cpuhp_state target)\n{\n\tstruct cpuhp_cpu_state *st = per_cpu_ptr(&cpuhp_state, cpu);\n\tint prev_state, ret = 0;\n\n\tif (num_online_cpus() == 1)\n\t\treturn -EBUSY;\n\n\tif (!cpu_present(cpu))\n\t\treturn -EINVAL;\n\n\tcpus_write_lock();\n\n\tcpuhp_tasks_frozen = tasks_frozen;\n\n\tprev_state = cpuhp_set_state(st, target);\n\t/*\n\t * If the current CPU state is in the range of the AP hotplug thread,\n\t * then we need to kick the thread.\n\t */\n\tif (st->state > CPUHP_TEARDOWN_CPU) {\n\t\tst->target = max((int)target, CPUHP_TEARDOWN_CPU);\n\t\tret = cpuhp_kick_ap_work(cpu);\n\t\t/*\n\t\t * The AP side has done the error rollback already. Just\n\t\t * return the error code..\n\t\t */\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\t/*\n\t\t * We might have stopped still in the range of the AP hotplug\n\t\t * thread. Nothing to do anymore.\n\t\t */\n\t\tif (st->state > CPUHP_TEARDOWN_CPU)\n\t\t\tgoto out;\n\n\t\tst->target = target;\n\t}\n\t/*\n\t * The AP brought itself down to CPUHP_TEARDOWN_CPU. So we need\n\t * to do the further cleanups.\n\t */\n\tret = cpuhp_down_callbacks(cpu, st, target);\n\tif (ret && st->state < prev_state) {\n\t\tif (st->state == CPUHP_TEARDOWN_CPU) {\n\t\t\tcpuhp_reset_state(st, prev_state);\n\t\t\t__cpuhp_kick_ap(st);\n\t\t} else {\n\t\t\tWARN(1, \"DEAD callback error for CPU%d\", cpu);\n\t\t}\n\t}\n\nout:\n\tcpus_write_unlock();\n\t/*\n\t * Do post unplug cleanup. This is still protected against\n\t * concurrent CPU hotplug via cpu_add_remove_lock.\n\t */\n\tlockup_detector_cleanup();\n\tarch_smt_update();\n\tcpu_up_down_serialize_trainwrecks(tasks_frozen);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_suspend_resume",
          "args": [
            "TPS(\"CPU_OFF\")",
            "cpu",
            "true"
          ],
          "line": 1515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPS",
          "args": [
            "\"CPU_OFF\""
          ],
          "line": 1515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Wakeup pending. Abort CPU freeze\\n\""
          ],
          "line": 1510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pm_wakeup_pending",
          "args": [],
          "line": 1509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Disabling non-boot CPUs ...\\n\""
          ],
          "line": 1504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_clear",
          "args": [
            "frozen_cpus"
          ],
          "line": 1502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_first",
          "args": [
            "cpu_online_mask"
          ],
          "line": 1495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_online",
          "args": [
            "primary"
          ],
          "line": 1494
        },
        "resolved": true,
        "details": {
          "function_name": "init_cpu_online",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "2616-2619",
          "snippet": "void init_cpu_online(const struct cpumask *src)\n{\n\tcpumask_copy(&__cpu_online_mask, src);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct cpumask __cpu_online_mask"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstruct cpumask __cpu_online_mask;\n\nvoid init_cpu_online(const struct cpumask *src)\n{\n\tcpumask_copy(&__cpu_online_mask, src);\n}"
        }
      },
      {
        "call_info": {
          "callee": "housekeeping_any_cpu",
          "args": [
            "HK_FLAG_TIMER"
          ],
          "line": 1492
        },
        "resolved": true,
        "details": {
          "function_name": "housekeeping_any_cpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/isolation.c",
          "lines": "23-37",
          "snippet": "int housekeeping_any_cpu(enum hk_flags flags)\n{\n\tint cpu;\n\n\tif (static_branch_unlikely(&housekeeping_overridden)) {\n\t\tif (housekeeping_flags & flags) {\n\t\t\tcpu = sched_numa_find_closest(housekeeping_mask, smp_processor_id());\n\t\t\tif (cpu < nr_cpu_ids)\n\t\t\t\treturn cpu;\n\n\t\t\treturn cpumask_any_and(housekeeping_mask, cpu_online_mask);\n\t\t}\n\t}\n\treturn smp_processor_id();\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static cpumask_var_t housekeeping_mask;",
            "static unsigned int housekeeping_flags;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nstatic cpumask_var_t housekeeping_mask;\nstatic unsigned int housekeeping_flags;\n\nint housekeeping_any_cpu(enum hk_flags flags)\n{\n\tint cpu;\n\n\tif (static_branch_unlikely(&housekeeping_overridden)) {\n\t\tif (housekeeping_flags & flags) {\n\t\t\tcpu = sched_numa_find_closest(housekeeping_mask, smp_processor_id());\n\t\t\tif (cpu < nr_cpu_ids)\n\t\t\t\treturn cpu;\n\n\t\t\treturn cpumask_any_and(housekeeping_mask, cpu_online_mask);\n\t\t}\n\t}\n\treturn smp_processor_id();\n}"
        }
      },
      {
        "call_info": {
          "callee": "housekeeping_cpu",
          "args": [
            "primary",
            "HK_FLAG_TIMER"
          ],
          "line": 1491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_first",
          "args": [
            "cpu_online_mask"
          ],
          "line": 1490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_maps_update_begin",
          "args": [],
          "line": 1488
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_maps_update_begin",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "287-290",
          "snippet": "void cpu_maps_update_begin(void)\n{\n\tmutex_lock(&cpu_add_remove_lock);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nvoid cpu_maps_update_begin(void)\n{\n\tmutex_lock(&cpu_add_remove_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nint freeze_secondary_cpus(int primary)\n{\n\tint cpu, error = 0;\n\n\tcpu_maps_update_begin();\n\tif (primary == -1) {\n\t\tprimary = cpumask_first(cpu_online_mask);\n\t\tif (!housekeeping_cpu(primary, HK_FLAG_TIMER))\n\t\t\tprimary = housekeeping_any_cpu(HK_FLAG_TIMER);\n\t} else {\n\t\tif (!cpu_online(primary))\n\t\t\tprimary = cpumask_first(cpu_online_mask);\n\t}\n\n\t/*\n\t * We take down all of the non-boot CPUs in one shot to avoid races\n\t * with the userspace trying to use the CPU hotplug at the same time\n\t */\n\tcpumask_clear(frozen_cpus);\n\n\tpr_info(\"Disabling non-boot CPUs ...\\n\");\n\tfor_each_online_cpu(cpu) {\n\t\tif (cpu == primary)\n\t\t\tcontinue;\n\n\t\tif (pm_wakeup_pending()) {\n\t\t\tpr_info(\"Wakeup pending. Abort CPU freeze\\n\");\n\t\t\terror = -EBUSY;\n\t\t\tbreak;\n\t\t}\n\n\t\ttrace_suspend_resume(TPS(\"CPU_OFF\"), cpu, true);\n\t\terror = _cpu_down(cpu, 1, CPUHP_OFFLINE);\n\t\ttrace_suspend_resume(TPS(\"CPU_OFF\"), cpu, false);\n\t\tif (!error)\n\t\t\tcpumask_set_cpu(cpu, frozen_cpus);\n\t\telse {\n\t\t\tpr_err(\"Error taking CPU%d down: %d\\n\", cpu, error);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!error)\n\t\tBUG_ON(num_online_cpus() > 1);\n\telse\n\t\tpr_err(\"Non-boot CPUs are not disabled\\n\");\n\n\t/*\n\t * Make sure the CPUs won't be enabled by someone else. We need to do\n\t * this even in case of failure as all freeze_secondary_cpus() users are\n\t * supposed to do thaw_secondary_cpus() on the failure path.\n\t */\n\tcpu_hotplug_disabled++;\n\n\tcpu_maps_update_done();\n\treturn error;\n}"
  },
  {
    "function_name": "bringup_nonboot_cpus",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
    "lines": "1469-1479",
    "snippet": "void bringup_nonboot_cpus(unsigned int setup_max_cpus)\n{\n\tunsigned int cpu;\n\n\tfor_each_present_cpu(cpu) {\n\t\tif (num_online_cpus() >= setup_max_cpus)\n\t\t\tbreak;\n\t\tif (!cpu_online(cpu))\n\t\t\tcpu_up(cpu, CPUHP_ONLINE);\n\t}\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/scs.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sched/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_up",
          "args": [
            "cpu",
            "CPUHP_ONLINE"
          ],
          "line": 1477
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_up",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "1383-1415",
          "snippet": "static int cpu_up(unsigned int cpu, enum cpuhp_state target)\n{\n\tint err = 0;\n\n\tif (!cpu_possible(cpu)) {\n\t\tpr_err(\"can't online cpu %d because it is not configured as may-hotadd at boot time\\n\",\n\t\t       cpu);\n#if defined(CONFIG_IA64)\n\t\tpr_err(\"please check additional_cpus= boot parameter\\n\");\n#endif\n\t\treturn -EINVAL;\n\t}\n\n\terr = try_online_node(cpu_to_node(cpu));\n\tif (err)\n\t\treturn err;\n\n\tcpu_maps_update_begin();\n\n\tif (cpu_hotplug_disabled) {\n\t\terr = -EBUSY;\n\t\tgoto out;\n\t}\n\tif (!cpu_smt_allowed(cpu)) {\n\t\terr = -EPERM;\n\t\tgoto out;\n\t}\n\n\terr = _cpu_up(cpu, 0, target);\nout:\n\tcpu_maps_update_done();\n\treturn err;\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\n\nstatic int cpu_up(unsigned int cpu, enum cpuhp_state target)\n{\n\tint err = 0;\n\n\tif (!cpu_possible(cpu)) {\n\t\tpr_err(\"can't online cpu %d because it is not configured as may-hotadd at boot time\\n\",\n\t\t       cpu);\n#if defined(CONFIG_IA64)\n\t\tpr_err(\"please check additional_cpus= boot parameter\\n\");\n#endif\n\t\treturn -EINVAL;\n\t}\n\n\terr = try_online_node(cpu_to_node(cpu));\n\tif (err)\n\t\treturn err;\n\n\tcpu_maps_update_begin();\n\n\tif (cpu_hotplug_disabled) {\n\t\terr = -EBUSY;\n\t\tgoto out;\n\t}\n\tif (!cpu_smt_allowed(cpu)) {\n\t\terr = -EPERM;\n\t\tgoto out;\n\t}\n\n\terr = _cpu_up(cpu, 0, target);\nout:\n\tcpu_maps_update_done();\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_online",
          "args": [
            "cpu"
          ],
          "line": 1476
        },
        "resolved": true,
        "details": {
          "function_name": "init_cpu_online",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "2616-2619",
          "snippet": "void init_cpu_online(const struct cpumask *src)\n{\n\tcpumask_copy(&__cpu_online_mask, src);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct cpumask __cpu_online_mask"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstruct cpumask __cpu_online_mask;\n\nvoid init_cpu_online(const struct cpumask *src)\n{\n\tcpumask_copy(&__cpu_online_mask, src);\n}"
        }
      },
      {
        "call_info": {
          "callee": "num_online_cpus",
          "args": [],
          "line": 1474
        },
        "resolved": true,
        "details": {
          "function_name": "torture_num_online_cpus",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/torture.c",
          "lines": "185-188",
          "snippet": "int torture_num_online_cpus(void)\n{\n\treturn READ_ONCE(torture_online_cpus);\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint torture_num_online_cpus(void)\n{\n\treturn READ_ONCE(torture_online_cpus);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nvoid bringup_nonboot_cpus(unsigned int setup_max_cpus)\n{\n\tunsigned int cpu;\n\n\tfor_each_present_cpu(cpu) {\n\t\tif (num_online_cpus() >= setup_max_cpus)\n\t\t\tbreak;\n\t\tif (!cpu_online(cpu))\n\t\t\tcpu_up(cpu, CPUHP_ONLINE);\n\t}\n}"
  },
  {
    "function_name": "bringup_hibernate_cpu",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
    "lines": "1454-1467",
    "snippet": "int bringup_hibernate_cpu(unsigned int sleep_cpu)\n{\n\tint ret;\n\n\tif (!cpu_online(sleep_cpu)) {\n\t\tpr_info(\"Hibernated on a CPU that is offline! Bringing CPU up.\\n\");\n\t\tret = cpu_up(sleep_cpu, CPUHP_ONLINE);\n\t\tif (ret) {\n\t\t\tpr_err(\"Failed to bring hibernate-CPU up!\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/scs.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sched/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Failed to bring hibernate-CPU up!\\n\""
          ],
          "line": 1462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_up",
          "args": [
            "sleep_cpu",
            "CPUHP_ONLINE"
          ],
          "line": 1460
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_up",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "1383-1415",
          "snippet": "static int cpu_up(unsigned int cpu, enum cpuhp_state target)\n{\n\tint err = 0;\n\n\tif (!cpu_possible(cpu)) {\n\t\tpr_err(\"can't online cpu %d because it is not configured as may-hotadd at boot time\\n\",\n\t\t       cpu);\n#if defined(CONFIG_IA64)\n\t\tpr_err(\"please check additional_cpus= boot parameter\\n\");\n#endif\n\t\treturn -EINVAL;\n\t}\n\n\terr = try_online_node(cpu_to_node(cpu));\n\tif (err)\n\t\treturn err;\n\n\tcpu_maps_update_begin();\n\n\tif (cpu_hotplug_disabled) {\n\t\terr = -EBUSY;\n\t\tgoto out;\n\t}\n\tif (!cpu_smt_allowed(cpu)) {\n\t\terr = -EPERM;\n\t\tgoto out;\n\t}\n\n\terr = _cpu_up(cpu, 0, target);\nout:\n\tcpu_maps_update_done();\n\treturn err;\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\n\nstatic int cpu_up(unsigned int cpu, enum cpuhp_state target)\n{\n\tint err = 0;\n\n\tif (!cpu_possible(cpu)) {\n\t\tpr_err(\"can't online cpu %d because it is not configured as may-hotadd at boot time\\n\",\n\t\t       cpu);\n#if defined(CONFIG_IA64)\n\t\tpr_err(\"please check additional_cpus= boot parameter\\n\");\n#endif\n\t\treturn -EINVAL;\n\t}\n\n\terr = try_online_node(cpu_to_node(cpu));\n\tif (err)\n\t\treturn err;\n\n\tcpu_maps_update_begin();\n\n\tif (cpu_hotplug_disabled) {\n\t\terr = -EBUSY;\n\t\tgoto out;\n\t}\n\tif (!cpu_smt_allowed(cpu)) {\n\t\terr = -EPERM;\n\t\tgoto out;\n\t}\n\n\terr = _cpu_up(cpu, 0, target);\nout:\n\tcpu_maps_update_done();\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Hibernated on a CPU that is offline! Bringing CPU up.\\n\""
          ],
          "line": 1459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_online",
          "args": [
            "sleep_cpu"
          ],
          "line": 1458
        },
        "resolved": true,
        "details": {
          "function_name": "init_cpu_online",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "2616-2619",
          "snippet": "void init_cpu_online(const struct cpumask *src)\n{\n\tcpumask_copy(&__cpu_online_mask, src);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct cpumask __cpu_online_mask"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstruct cpumask __cpu_online_mask;\n\nvoid init_cpu_online(const struct cpumask *src)\n{\n\tcpumask_copy(&__cpu_online_mask, src);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nint bringup_hibernate_cpu(unsigned int sleep_cpu)\n{\n\tint ret;\n\n\tif (!cpu_online(sleep_cpu)) {\n\t\tpr_info(\"Hibernated on a CPU that is offline! Bringing CPU up.\\n\");\n\t\tret = cpu_up(sleep_cpu, CPUHP_ONLINE);\n\t\tif (ret) {\n\t\t\tpr_err(\"Failed to bring hibernate-CPU up!\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "add_cpu",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
    "lines": "1432-1441",
    "snippet": "int add_cpu(unsigned int cpu)\n{\n\tint ret;\n\n\tlock_device_hotplug();\n\tret = device_online(get_cpu_device(cpu));\n\tunlock_device_hotplug();\n\n\treturn ret;\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/scs.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sched/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_device_hotplug",
          "args": [],
          "line": 1438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "device_online",
          "args": [
            "get_cpu_device(cpu)"
          ],
          "line": 1437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_cpu_device",
          "args": [
            "cpu"
          ],
          "line": 1437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lock_device_hotplug",
          "args": [],
          "line": 1436
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nint add_cpu(unsigned int cpu)\n{\n\tint ret;\n\n\tlock_device_hotplug();\n\tret = device_online(get_cpu_device(cpu));\n\tunlock_device_hotplug();\n\n\treturn ret;\n}"
  },
  {
    "function_name": "cpu_device_up",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
    "lines": "1427-1430",
    "snippet": "int cpu_device_up(struct device *dev)\n{\n\treturn cpu_up(dev->id, CPUHP_ONLINE);\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/scs.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sched/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_up",
          "args": [
            "dev->id",
            "CPUHP_ONLINE"
          ],
          "line": 1429
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_up",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "1383-1415",
          "snippet": "static int cpu_up(unsigned int cpu, enum cpuhp_state target)\n{\n\tint err = 0;\n\n\tif (!cpu_possible(cpu)) {\n\t\tpr_err(\"can't online cpu %d because it is not configured as may-hotadd at boot time\\n\",\n\t\t       cpu);\n#if defined(CONFIG_IA64)\n\t\tpr_err(\"please check additional_cpus= boot parameter\\n\");\n#endif\n\t\treturn -EINVAL;\n\t}\n\n\terr = try_online_node(cpu_to_node(cpu));\n\tif (err)\n\t\treturn err;\n\n\tcpu_maps_update_begin();\n\n\tif (cpu_hotplug_disabled) {\n\t\terr = -EBUSY;\n\t\tgoto out;\n\t}\n\tif (!cpu_smt_allowed(cpu)) {\n\t\terr = -EPERM;\n\t\tgoto out;\n\t}\n\n\terr = _cpu_up(cpu, 0, target);\nout:\n\tcpu_maps_update_done();\n\treturn err;\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\n\nstatic int cpu_up(unsigned int cpu, enum cpuhp_state target)\n{\n\tint err = 0;\n\n\tif (!cpu_possible(cpu)) {\n\t\tpr_err(\"can't online cpu %d because it is not configured as may-hotadd at boot time\\n\",\n\t\t       cpu);\n#if defined(CONFIG_IA64)\n\t\tpr_err(\"please check additional_cpus= boot parameter\\n\");\n#endif\n\t\treturn -EINVAL;\n\t}\n\n\terr = try_online_node(cpu_to_node(cpu));\n\tif (err)\n\t\treturn err;\n\n\tcpu_maps_update_begin();\n\n\tif (cpu_hotplug_disabled) {\n\t\terr = -EBUSY;\n\t\tgoto out;\n\t}\n\tif (!cpu_smt_allowed(cpu)) {\n\t\terr = -EPERM;\n\t\tgoto out;\n\t}\n\n\terr = _cpu_up(cpu, 0, target);\nout:\n\tcpu_maps_update_done();\n\treturn err;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nint cpu_device_up(struct device *dev)\n{\n\treturn cpu_up(dev->id, CPUHP_ONLINE);\n}"
  },
  {
    "function_name": "cpu_up",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
    "lines": "1383-1415",
    "snippet": "static int cpu_up(unsigned int cpu, enum cpuhp_state target)\n{\n\tint err = 0;\n\n\tif (!cpu_possible(cpu)) {\n\t\tpr_err(\"can't online cpu %d because it is not configured as may-hotadd at boot time\\n\",\n\t\t       cpu);\n#if defined(CONFIG_IA64)\n\t\tpr_err(\"please check additional_cpus= boot parameter\\n\");\n#endif\n\t\treturn -EINVAL;\n\t}\n\n\terr = try_online_node(cpu_to_node(cpu));\n\tif (err)\n\t\treturn err;\n\n\tcpu_maps_update_begin();\n\n\tif (cpu_hotplug_disabled) {\n\t\terr = -EBUSY;\n\t\tgoto out;\n\t}\n\tif (!cpu_smt_allowed(cpu)) {\n\t\terr = -EPERM;\n\t\tgoto out;\n\t}\n\n\terr = _cpu_up(cpu, 0, target);\nout:\n\tcpu_maps_update_done();\n\treturn err;\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/scs.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sched/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_maps_update_done",
          "args": [],
          "line": 1413
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_maps_update_done",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "292-295",
          "snippet": "void cpu_maps_update_done(void)\n{\n\tmutex_unlock(&cpu_add_remove_lock);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nvoid cpu_maps_update_done(void)\n{\n\tmutex_unlock(&cpu_add_remove_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "_cpu_up",
          "args": [
            "cpu",
            "0",
            "target"
          ],
          "line": 1411
        },
        "resolved": true,
        "details": {
          "function_name": "_cpu_up",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "1323-1381",
          "snippet": "static int _cpu_up(unsigned int cpu, int tasks_frozen, enum cpuhp_state target)\n{\n\tstruct cpuhp_cpu_state *st = per_cpu_ptr(&cpuhp_state, cpu);\n\tstruct task_struct *idle;\n\tint ret = 0;\n\n\tcpus_write_lock();\n\n\tif (!cpu_present(cpu)) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * The caller of cpu_up() might have raced with another\n\t * caller. Nothing to do.\n\t */\n\tif (st->state >= target)\n\t\tgoto out;\n\n\tif (st->state == CPUHP_OFFLINE) {\n\t\t/* Let it fail before we try to bring the cpu up */\n\t\tidle = idle_thread_get(cpu);\n\t\tif (IS_ERR(idle)) {\n\t\t\tret = PTR_ERR(idle);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tcpuhp_tasks_frozen = tasks_frozen;\n\n\tcpuhp_set_state(st, target);\n\t/*\n\t * If the current CPU state is in the range of the AP hotplug thread,\n\t * then we need to kick the thread once more.\n\t */\n\tif (st->state > CPUHP_BRINGUP_CPU) {\n\t\tret = cpuhp_kick_ap_work(cpu);\n\t\t/*\n\t\t * The AP side has done the error rollback already. Just\n\t\t * return the error code..\n\t\t */\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\t/*\n\t * Try to reach the target state. We max out on the BP at\n\t * CPUHP_BRINGUP_CPU. After that the AP hotplug thread is\n\t * responsible for bringing it up to the target state.\n\t */\n\ttarget = min((int)target, CPUHP_BRINGUP_CPU);\n\tret = cpuhp_up_callbacks(cpu, st, target);\nout:\n\tcpus_write_unlock();\n\tarch_smt_update();\n\tcpu_up_down_serialize_trainwrecks(tasks_frozen);\n\treturn ret;\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\n\nstatic int _cpu_up(unsigned int cpu, int tasks_frozen, enum cpuhp_state target)\n{\n\tstruct cpuhp_cpu_state *st = per_cpu_ptr(&cpuhp_state, cpu);\n\tstruct task_struct *idle;\n\tint ret = 0;\n\n\tcpus_write_lock();\n\n\tif (!cpu_present(cpu)) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * The caller of cpu_up() might have raced with another\n\t * caller. Nothing to do.\n\t */\n\tif (st->state >= target)\n\t\tgoto out;\n\n\tif (st->state == CPUHP_OFFLINE) {\n\t\t/* Let it fail before we try to bring the cpu up */\n\t\tidle = idle_thread_get(cpu);\n\t\tif (IS_ERR(idle)) {\n\t\t\tret = PTR_ERR(idle);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tcpuhp_tasks_frozen = tasks_frozen;\n\n\tcpuhp_set_state(st, target);\n\t/*\n\t * If the current CPU state is in the range of the AP hotplug thread,\n\t * then we need to kick the thread once more.\n\t */\n\tif (st->state > CPUHP_BRINGUP_CPU) {\n\t\tret = cpuhp_kick_ap_work(cpu);\n\t\t/*\n\t\t * The AP side has done the error rollback already. Just\n\t\t * return the error code..\n\t\t */\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\t/*\n\t * Try to reach the target state. We max out on the BP at\n\t * CPUHP_BRINGUP_CPU. After that the AP hotplug thread is\n\t * responsible for bringing it up to the target state.\n\t */\n\ttarget = min((int)target, CPUHP_BRINGUP_CPU);\n\tret = cpuhp_up_callbacks(cpu, st, target);\nout:\n\tcpus_write_unlock();\n\tarch_smt_update();\n\tcpu_up_down_serialize_trainwrecks(tasks_frozen);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_smt_allowed",
          "args": [
            "cpu"
          ],
          "line": 1406
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_smt_allowed",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "473-473",
          "snippet": "static inline bool cpu_smt_allowed(unsigned int cpu) { return true; }",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstatic inline bool cpu_smt_allowed(unsigned int cpu) { return true; }"
        }
      },
      {
        "call_info": {
          "callee": "cpu_maps_update_begin",
          "args": [],
          "line": 1400
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_maps_update_begin",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "287-290",
          "snippet": "void cpu_maps_update_begin(void)\n{\n\tmutex_lock(&cpu_add_remove_lock);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nvoid cpu_maps_update_begin(void)\n{\n\tmutex_lock(&cpu_add_remove_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "try_online_node",
          "args": [
            "cpu_to_node(cpu)"
          ],
          "line": 1396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_node",
          "args": [
            "cpu"
          ],
          "line": 1396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"please check additional_cpus= boot parameter\\n\""
          ],
          "line": 1391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"can't online cpu %d because it is not configured as may-hotadd at boot time\\n\"",
            "cpu"
          ],
          "line": 1388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_possible",
          "args": [
            "cpu"
          ],
          "line": 1387
        },
        "resolved": true,
        "details": {
          "function_name": "init_cpu_possible",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "2611-2614",
          "snippet": "void init_cpu_possible(const struct cpumask *src)\n{\n\tcpumask_copy(&__cpu_possible_mask, src);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nvoid init_cpu_possible(const struct cpumask *src)\n{\n\tcpumask_copy(&__cpu_possible_mask, src);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\n\nstatic int cpu_up(unsigned int cpu, enum cpuhp_state target)\n{\n\tint err = 0;\n\n\tif (!cpu_possible(cpu)) {\n\t\tpr_err(\"can't online cpu %d because it is not configured as may-hotadd at boot time\\n\",\n\t\t       cpu);\n#if defined(CONFIG_IA64)\n\t\tpr_err(\"please check additional_cpus= boot parameter\\n\");\n#endif\n\t\treturn -EINVAL;\n\t}\n\n\terr = try_online_node(cpu_to_node(cpu));\n\tif (err)\n\t\treturn err;\n\n\tcpu_maps_update_begin();\n\n\tif (cpu_hotplug_disabled) {\n\t\terr = -EBUSY;\n\t\tgoto out;\n\t}\n\tif (!cpu_smt_allowed(cpu)) {\n\t\terr = -EPERM;\n\t\tgoto out;\n\t}\n\n\terr = _cpu_up(cpu, 0, target);\nout:\n\tcpu_maps_update_done();\n\treturn err;\n}"
  },
  {
    "function_name": "_cpu_up",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
    "lines": "1323-1381",
    "snippet": "static int _cpu_up(unsigned int cpu, int tasks_frozen, enum cpuhp_state target)\n{\n\tstruct cpuhp_cpu_state *st = per_cpu_ptr(&cpuhp_state, cpu);\n\tstruct task_struct *idle;\n\tint ret = 0;\n\n\tcpus_write_lock();\n\n\tif (!cpu_present(cpu)) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * The caller of cpu_up() might have raced with another\n\t * caller. Nothing to do.\n\t */\n\tif (st->state >= target)\n\t\tgoto out;\n\n\tif (st->state == CPUHP_OFFLINE) {\n\t\t/* Let it fail before we try to bring the cpu up */\n\t\tidle = idle_thread_get(cpu);\n\t\tif (IS_ERR(idle)) {\n\t\t\tret = PTR_ERR(idle);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tcpuhp_tasks_frozen = tasks_frozen;\n\n\tcpuhp_set_state(st, target);\n\t/*\n\t * If the current CPU state is in the range of the AP hotplug thread,\n\t * then we need to kick the thread once more.\n\t */\n\tif (st->state > CPUHP_BRINGUP_CPU) {\n\t\tret = cpuhp_kick_ap_work(cpu);\n\t\t/*\n\t\t * The AP side has done the error rollback already. Just\n\t\t * return the error code..\n\t\t */\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\t/*\n\t * Try to reach the target state. We max out on the BP at\n\t * CPUHP_BRINGUP_CPU. After that the AP hotplug thread is\n\t * responsible for bringing it up to the target state.\n\t */\n\ttarget = min((int)target, CPUHP_BRINGUP_CPU);\n\tret = cpuhp_up_callbacks(cpu, st, target);\nout:\n\tcpus_write_unlock();\n\tarch_smt_update();\n\tcpu_up_down_serialize_trainwrecks(tasks_frozen);\n\treturn ret;\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/scs.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sched/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_up_down_serialize_trainwrecks",
          "args": [
            "tasks_frozen"
          ],
          "line": 1379
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_up_down_serialize_trainwrecks",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "921-942",
          "snippet": "static void cpu_up_down_serialize_trainwrecks(bool tasks_frozen)\n{\n\t/*\n\t * cpusets delegate hotplug operations to a worker to \"solve\" the\n\t * lock order problems. Wait for the worker, but only if tasks are\n\t * _not_ frozen (suspend, hibernate) as that would wait forever.\n\t *\n\t * The wait is required because otherwise the hotplug operation\n\t * returns with inconsistent state, which could even be observed in\n\t * user space when a new CPU is brought up. The CPU plug uevent\n\t * would be delivered and user space reacting on it would fail to\n\t * move tasks to the newly plugged CPU up to the point where the\n\t * work has finished because up to that point the newly plugged CPU\n\t * is not assignable in cpusets/cgroups. On unplug that's not\n\t * necessarily a visible issue, but it is still inconsistent state,\n\t * which is the real problem which needs to be \"fixed\". This can't\n\t * prevent the transient state between scheduling the work and\n\t * returning from waiting for it.\n\t */\n\tif (!tasks_frozen)\n\t\tcpuset_wait_for_hotplug();\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstatic void cpu_up_down_serialize_trainwrecks(bool tasks_frozen)\n{\n\t/*\n\t * cpusets delegate hotplug operations to a worker to \"solve\" the\n\t * lock order problems. Wait for the worker, but only if tasks are\n\t * _not_ frozen (suspend, hibernate) as that would wait forever.\n\t *\n\t * The wait is required because otherwise the hotplug operation\n\t * returns with inconsistent state, which could even be observed in\n\t * user space when a new CPU is brought up. The CPU plug uevent\n\t * would be delivered and user space reacting on it would fail to\n\t * move tasks to the newly plugged CPU up to the point where the\n\t * work has finished because up to that point the newly plugged CPU\n\t * is not assignable in cpusets/cgroups. On unplug that's not\n\t * necessarily a visible issue, but it is still inconsistent state,\n\t * which is the real problem which needs to be \"fixed\". This can't\n\t * prevent the transient state between scheduling the work and\n\t * returning from waiting for it.\n\t */\n\tif (!tasks_frozen)\n\t\tcpuset_wait_for_hotplug();\n}"
        }
      },
      {
        "call_info": {
          "callee": "arch_smt_update",
          "args": [],
          "line": 1378
        },
        "resolved": true,
        "details": {
          "function_name": "arch_smt_update",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "412-412",
          "snippet": "void __weak arch_smt_update(void) { }",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nvoid __weak arch_smt_update(void) { }"
        }
      },
      {
        "call_info": {
          "callee": "cpus_write_unlock",
          "args": [],
          "line": 1377
        },
        "resolved": true,
        "details": {
          "function_name": "cpus_write_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "330-333",
          "snippet": "void cpus_write_unlock(void)\n{\n\tpercpu_up_write(&cpu_hotplug_lock);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nvoid cpus_write_unlock(void)\n{\n\tpercpu_up_write(&cpu_hotplug_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpuhp_up_callbacks",
          "args": [
            "cpu",
            "st",
            "target"
          ],
          "line": 1375
        },
        "resolved": true,
        "details": {
          "function_name": "cpuhp_up_callbacks",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "694-712",
          "snippet": "static int cpuhp_up_callbacks(unsigned int cpu, struct cpuhp_cpu_state *st,\n\t\t\t      enum cpuhp_state target)\n{\n\tenum cpuhp_state prev_state = st->state;\n\tint ret = 0;\n\n\tret = cpuhp_invoke_callback_range(true, cpu, st, target);\n\tif (ret) {\n\t\tpr_debug(\"CPU UP failed (%d) CPU %u state %s (%d)\\n\",\n\t\t\t ret, cpu, cpuhp_get_step(st->state)->name,\n\t\t\t st->state);\n\n\t\tcpuhp_reset_state(st, prev_state);\n\t\tif (can_rollback_cpu(st))\n\t\t\tWARN_ON(cpuhp_invoke_callback_range(false, cpu, st,\n\t\t\t\t\t\t\t    prev_state));\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\n\nstatic int cpuhp_up_callbacks(unsigned int cpu, struct cpuhp_cpu_state *st,\n\t\t\t      enum cpuhp_state target)\n{\n\tenum cpuhp_state prev_state = st->state;\n\tint ret = 0;\n\n\tret = cpuhp_invoke_callback_range(true, cpu, st, target);\n\tif (ret) {\n\t\tpr_debug(\"CPU UP failed (%d) CPU %u state %s (%d)\\n\",\n\t\t\t ret, cpu, cpuhp_get_step(st->state)->name,\n\t\t\t st->state);\n\n\t\tcpuhp_reset_state(st, prev_state);\n\t\tif (can_rollback_cpu(st))\n\t\t\tWARN_ON(cpuhp_invoke_callback_range(false, cpu, st,\n\t\t\t\t\t\t\t    prev_state));\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "(int)target",
            "CPUHP_BRINGUP_CPU"
          ],
          "line": 1374
        },
        "resolved": true,
        "details": {
          "function_name": "irq_setup_timings",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/internals.h",
          "lines": "388-389",
          "snippet": "static inline void irq_setup_timings(struct irq_desc *desc,\n\t\t\t\t     struct irqaction *act) {}",
          "includes": [
            "#include <linux/debugfs.h>",
            "#include \"settings.h\"",
            "#include \"debug.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/pm_runtime.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/irqdesc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void __disable_irq(struct irq_desc *desc);",
            "extern void __enable_irq(struct irq_desc *desc);",
            "extern int irq_activate(struct irq_desc *desc);",
            "extern void irq_shutdown(struct irq_desc *desc);",
            "extern void irq_shutdown_and_deactivate(struct irq_desc *desc);",
            "extern void irq_enable(struct irq_desc *desc);",
            "extern void irq_disable(struct irq_desc *desc);",
            "extern void mask_irq(struct irq_desc *desc);",
            "extern void unmask_irq(struct irq_desc *desc);",
            "extern void unmask_threaded_irq(struct irq_desc *desc);",
            "irqreturn_t __handle_irq_event_percpu(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event_percpu(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event(struct irq_desc *desc);",
            "bool irq_wait_for_poll(struct irq_desc *desc);",
            "extern void irq_set_thread_affinity(struct irq_desc *desc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/debugfs.h>\n#include \"settings.h\"\n#include \"debug.h\"\n#include <linux/sched/clock.h>\n#include <linux/pm_runtime.h>\n#include <linux/kernel_stat.h>\n#include <linux/irqdesc.h>\n\nextern void __disable_irq(struct irq_desc *desc);\nextern void __enable_irq(struct irq_desc *desc);\nextern int irq_activate(struct irq_desc *desc);\nextern void irq_shutdown(struct irq_desc *desc);\nextern void irq_shutdown_and_deactivate(struct irq_desc *desc);\nextern void irq_enable(struct irq_desc *desc);\nextern void irq_disable(struct irq_desc *desc);\nextern void mask_irq(struct irq_desc *desc);\nextern void unmask_irq(struct irq_desc *desc);\nextern void unmask_threaded_irq(struct irq_desc *desc);\nirqreturn_t __handle_irq_event_percpu(struct irq_desc *desc);\nirqreturn_t handle_irq_event_percpu(struct irq_desc *desc);\nirqreturn_t handle_irq_event(struct irq_desc *desc);\nbool irq_wait_for_poll(struct irq_desc *desc);\nextern void irq_set_thread_affinity(struct irq_desc *desc);\n\nstatic inline void irq_setup_timings(struct irq_desc *desc,\n\t\t\t\t     struct irqaction *act) {}"
        }
      },
      {
        "call_info": {
          "callee": "cpuhp_kick_ap_work",
          "args": [
            "cpu"
          ],
          "line": 1360
        },
        "resolved": true,
        "details": {
          "function_name": "cpuhp_kick_ap_work",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "864-881",
          "snippet": "static int cpuhp_kick_ap_work(unsigned int cpu)\n{\n\tstruct cpuhp_cpu_state *st = per_cpu_ptr(&cpuhp_state, cpu);\n\tenum cpuhp_state prev_state = st->state;\n\tint ret;\n\n\tcpuhp_lock_acquire(false);\n\tcpuhp_lock_release(false);\n\n\tcpuhp_lock_acquire(true);\n\tcpuhp_lock_release(true);\n\n\ttrace_cpuhp_enter(cpu, st->target, prev_state, cpuhp_kick_ap_work);\n\tret = cpuhp_kick_ap(st, st->target);\n\ttrace_cpuhp_exit(cpu, st->state, prev_state, ret);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\n\nstatic int cpuhp_kick_ap_work(unsigned int cpu)\n{\n\tstruct cpuhp_cpu_state *st = per_cpu_ptr(&cpuhp_state, cpu);\n\tenum cpuhp_state prev_state = st->state;\n\tint ret;\n\n\tcpuhp_lock_acquire(false);\n\tcpuhp_lock_release(false);\n\n\tcpuhp_lock_acquire(true);\n\tcpuhp_lock_release(true);\n\n\ttrace_cpuhp_enter(cpu, st->target, prev_state, cpuhp_kick_ap_work);\n\tret = cpuhp_kick_ap(st, st->target);\n\ttrace_cpuhp_exit(cpu, st->state, prev_state, ret);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpuhp_set_state",
          "args": [
            "st",
            "target"
          ],
          "line": 1354
        },
        "resolved": true,
        "details": {
          "function_name": "cpuhp_set_state",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "476-492",
          "snippet": "static inline enum cpuhp_state\ncpuhp_set_state(struct cpuhp_cpu_state *st, enum cpuhp_state target)\n{\n\tenum cpuhp_state prev_state = st->state;\n\tbool bringup = st->state < target;\n\n\tst->rollback = false;\n\tst->last = NULL;\n\n\tst->target = target;\n\tst->single = false;\n\tst->bringup = bringup;\n\tif (cpu_dying(st->cpu) != !bringup)\n\t\tset_cpu_dying(st->cpu, !bringup);\n\n\treturn prev_state;\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\n\nstatic inline enum cpuhp_state\ncpuhp_set_state(struct cpuhp_cpu_state *st, enum cpuhp_state target)\n{\n\tenum cpuhp_state prev_state = st->state;\n\tbool bringup = st->state < target;\n\n\tst->rollback = false;\n\tst->last = NULL;\n\n\tst->target = target;\n\tst->single = false;\n\tst->bringup = bringup;\n\tif (cpu_dying(st->cpu) != !bringup)\n\t\tset_cpu_dying(st->cpu, !bringup);\n\n\treturn prev_state;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "idle"
          ],
          "line": 1347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "idle"
          ],
          "line": 1346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "idle_thread_get",
          "args": [
            "cpu"
          ],
          "line": 1345
        },
        "resolved": true,
        "details": {
          "function_name": "idle_thread_get",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/smpboot.c",
          "lines": "30-37",
          "snippet": "struct task_struct *idle_thread_get(unsigned int cpu)\n{\n\tstruct task_struct *tsk = per_cpu(idle_threads, cpu);\n\n\tif (!tsk)\n\t\treturn ERR_PTR(-ENOMEM);\n\treturn tsk;\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <linux/smpboot.h>",
            "#include <linux/kthread.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/delay.h>",
            "#include <linux/smp.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <linux/smpboot.h>\n#include <linux/kthread.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstruct task_struct *idle_thread_get(unsigned int cpu)\n{\n\tstruct task_struct *tsk = per_cpu(idle_threads, cpu);\n\n\tif (!tsk)\n\t\treturn ERR_PTR(-ENOMEM);\n\treturn tsk;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_present",
          "args": [
            "cpu"
          ],
          "line": 1331
        },
        "resolved": true,
        "details": {
          "function_name": "init_cpu_present",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "2606-2609",
          "snippet": "void init_cpu_present(const struct cpumask *src)\n{\n\tcpumask_copy(&__cpu_present_mask, src);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct cpumask __cpu_present_mask"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstruct cpumask __cpu_present_mask;\n\nvoid init_cpu_present(const struct cpumask *src)\n{\n\tcpumask_copy(&__cpu_present_mask, src);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpus_write_lock",
          "args": [],
          "line": 1329
        },
        "resolved": true,
        "details": {
          "function_name": "cpus_write_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "325-328",
          "snippet": "void cpus_write_lock(void)\n{\n\tpercpu_down_write(&cpu_hotplug_lock);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nvoid cpus_write_lock(void)\n{\n\tpercpu_down_write(&cpu_hotplug_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "&cpuhp_state",
            "cpu"
          ],
          "line": 1325
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\n\nstatic int _cpu_up(unsigned int cpu, int tasks_frozen, enum cpuhp_state target)\n{\n\tstruct cpuhp_cpu_state *st = per_cpu_ptr(&cpuhp_state, cpu);\n\tstruct task_struct *idle;\n\tint ret = 0;\n\n\tcpus_write_lock();\n\n\tif (!cpu_present(cpu)) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * The caller of cpu_up() might have raced with another\n\t * caller. Nothing to do.\n\t */\n\tif (st->state >= target)\n\t\tgoto out;\n\n\tif (st->state == CPUHP_OFFLINE) {\n\t\t/* Let it fail before we try to bring the cpu up */\n\t\tidle = idle_thread_get(cpu);\n\t\tif (IS_ERR(idle)) {\n\t\t\tret = PTR_ERR(idle);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tcpuhp_tasks_frozen = tasks_frozen;\n\n\tcpuhp_set_state(st, target);\n\t/*\n\t * If the current CPU state is in the range of the AP hotplug thread,\n\t * then we need to kick the thread once more.\n\t */\n\tif (st->state > CPUHP_BRINGUP_CPU) {\n\t\tret = cpuhp_kick_ap_work(cpu);\n\t\t/*\n\t\t * The AP side has done the error rollback already. Just\n\t\t * return the error code..\n\t\t */\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\t/*\n\t * Try to reach the target state. We max out on the BP at\n\t * CPUHP_BRINGUP_CPU. After that the AP hotplug thread is\n\t * responsible for bringing it up to the target state.\n\t */\n\ttarget = min((int)target, CPUHP_BRINGUP_CPU);\n\tret = cpuhp_up_callbacks(cpu, st, target);\nout:\n\tcpus_write_unlock();\n\tarch_smt_update();\n\tcpu_up_down_serialize_trainwrecks(tasks_frozen);\n\treturn ret;\n}"
  },
  {
    "function_name": "cpuhp_online_idle",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
    "lines": "1304-1320",
    "snippet": "void cpuhp_online_idle(enum cpuhp_state state)\n{\n\tstruct cpuhp_cpu_state *st = this_cpu_ptr(&cpuhp_state);\n\n\t/* Happens for the boot cpu */\n\tif (state != CPUHP_AP_ONLINE_IDLE)\n\t\treturn;\n\n\t/*\n\t * Unpart the stopper thread before we start the idle loop (and start\n\t * scheduling); this ensures the stopper task is always available.\n\t */\n\tstop_machine_unpark(smp_processor_id());\n\n\tst->state = CPUHP_AP_ONLINE_IDLE;\n\tcomplete_ap_thread(st, true);\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/scs.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sched/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "complete_ap_thread",
          "args": [
            "st",
            "true"
          ],
          "line": 1319
        },
        "resolved": true,
        "details": {
          "function_name": "complete_ap_thread",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "264-268",
          "snippet": "static inline void complete_ap_thread(struct cpuhp_cpu_state *st, bool bringup)\n{\n\tstruct completion *done = bringup ? &st->done_up : &st->done_down;\n\tcomplete(done);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstatic inline void complete_ap_thread(struct cpuhp_cpu_state *st, bool bringup)\n{\n\tstruct completion *done = bringup ? &st->done_up : &st->done_down;\n\tcomplete(done);\n}"
        }
      },
      {
        "call_info": {
          "callee": "stop_machine_unpark",
          "args": [
            "smp_processor_id()"
          ],
          "line": 1316
        },
        "resolved": true,
        "details": {
          "function_name": "stop_machine_unpark",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/stop_machine.c",
          "lines": "552-558",
          "snippet": "void stop_machine_unpark(int cpu)\n{\n\tstruct cpu_stopper *stopper = &per_cpu(cpu_stopper, cpu);\n\n\tstopper->enabled = true;\n\tkthread_unpark(stopper->thread);\n}",
          "includes": [
            "#include <linux/sched/wake_q.h>",
            "#include <linux/nmi.h>",
            "#include <linux/atomic.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/sched.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/kthread.h>",
            "#include <linux/init.h>",
            "#include <linux/cpu.h>",
            "#include <linux/completion.h>",
            "#include <linux/compiler.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct cpu_stopper, cpu_stopper);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/wake_q.h>\n#include <linux/nmi.h>\n#include <linux/atomic.h>\n#include <linux/smpboot.h>\n#include <linux/kallsyms.h>\n#include <linux/interrupt.h>\n#include <linux/stop_machine.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kthread.h>\n#include <linux/init.h>\n#include <linux/cpu.h>\n#include <linux/completion.h>\n#include <linux/compiler.h>\n\nstatic DEFINE_PER_CPU(struct cpu_stopper, cpu_stopper);\n\nvoid stop_machine_unpark(int cpu)\n{\n\tstruct cpu_stopper *stopper = &per_cpu(cpu_stopper, cpu);\n\n\tstopper->enabled = true;\n\tkthread_unpark(stopper->thread);\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 1316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&cpuhp_state"
          ],
          "line": 1306
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\n\nvoid cpuhp_online_idle(enum cpuhp_state state)\n{\n\tstruct cpuhp_cpu_state *st = this_cpu_ptr(&cpuhp_state);\n\n\t/* Happens for the boot cpu */\n\tif (state != CPUHP_AP_ONLINE_IDLE)\n\t\treturn;\n\n\t/*\n\t * Unpart the stopper thread before we start the idle loop (and start\n\t * scheduling); this ensures the stopper task is always available.\n\t */\n\tstop_machine_unpark(smp_processor_id());\n\n\tst->state = CPUHP_AP_ONLINE_IDLE;\n\tcomplete_ap_thread(st, true);\n}"
  },
  {
    "function_name": "notify_cpu_starting",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
    "lines": "1283-1297",
    "snippet": "void notify_cpu_starting(unsigned int cpu)\n{\n\tstruct cpuhp_cpu_state *st = per_cpu_ptr(&cpuhp_state, cpu);\n\tenum cpuhp_state target = min((int)st->target, CPUHP_AP_ONLINE);\n\tint ret;\n\n\trcu_cpu_starting(cpu);\t/* Enables RCU usage on this CPU. */\n\tcpumask_set_cpu(cpu, &cpus_booted_once_mask);\n\tret = cpuhp_invoke_callback_range(true, cpu, st, target);\n\n\t/*\n\t * STARTING must not fail!\n\t */\n\tWARN_ON_ONCE(ret);\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/scs.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sched/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "ret"
          ],
          "line": 1296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpuhp_invoke_callback_range",
          "args": [
            "true",
            "cpu",
            "st",
            "target"
          ],
          "line": 1291
        },
        "resolved": true,
        "details": {
          "function_name": "cpuhp_invoke_callback_range",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "663-678",
          "snippet": "static int cpuhp_invoke_callback_range(bool bringup,\n\t\t\t\t       unsigned int cpu,\n\t\t\t\t       struct cpuhp_cpu_state *st,\n\t\t\t\t       enum cpuhp_state target)\n{\n\tenum cpuhp_state state;\n\tint err = 0;\n\n\twhile (cpuhp_next_state(bringup, &state, st, target)) {\n\t\terr = cpuhp_invoke_callback(cpu, state, bringup, NULL, NULL);\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\n\treturn err;\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\n\nstatic int cpuhp_invoke_callback_range(bool bringup,\n\t\t\t\t       unsigned int cpu,\n\t\t\t\t       struct cpuhp_cpu_state *st,\n\t\t\t\t       enum cpuhp_state target)\n{\n\tenum cpuhp_state state;\n\tint err = 0;\n\n\twhile (cpuhp_next_state(bringup, &state, st, target)) {\n\t\terr = cpuhp_invoke_callback(cpu, state, bringup, NULL, NULL);\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_set_cpu",
          "args": [
            "cpu",
            "&cpus_booted_once_mask"
          ],
          "line": 1290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_cpu_starting",
          "args": [
            "cpu"
          ],
          "line": 1289
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_cpu_starting",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "4275-4317",
          "snippet": "void rcu_cpu_starting(unsigned int cpu)\n{\n\tunsigned long flags;\n\tunsigned long mask;\n\tstruct rcu_data *rdp;\n\tstruct rcu_node *rnp;\n\tbool newcpu;\n\n\trdp = per_cpu_ptr(&rcu_data, cpu);\n\tif (rdp->cpu_started)\n\t\treturn;\n\trdp->cpu_started = true;\n\n\trnp = rdp->mynode;\n\tmask = rdp->grpmask;\n\tWRITE_ONCE(rnp->ofl_seq, rnp->ofl_seq + 1);\n\tWARN_ON_ONCE(!(rnp->ofl_seq & 0x1));\n\trcu_dynticks_eqs_online();\n\tsmp_mb(); // Pair with rcu_gp_cleanup()'s ->ofl_seq barrier().\n\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\tWRITE_ONCE(rnp->qsmaskinitnext, rnp->qsmaskinitnext | mask);\n\tnewcpu = !(rnp->expmaskinitnext & mask);\n\trnp->expmaskinitnext |= mask;\n\t/* Allow lockless access for expedited grace periods. */\n\tsmp_store_release(&rcu_state.ncpus, rcu_state.ncpus + newcpu); /* ^^^ */\n\tASSERT_EXCLUSIVE_WRITER(rcu_state.ncpus);\n\trcu_gpnum_ovf(rnp, rdp); /* Offline-induced counter wrap? */\n\trdp->rcu_onl_gp_seq = READ_ONCE(rcu_state.gp_seq);\n\trdp->rcu_onl_gp_flags = READ_ONCE(rcu_state.gp_flags);\n\n\t/* An incoming CPU should never be blocking a grace period. */\n\tif (WARN_ON_ONCE(rnp->qsmask & mask)) { /* RCU waiting on incoming CPU? */\n\t\trcu_disable_urgency_upon_qs(rdp);\n\t\t/* Report QS -after- changing ->qsmaskinitnext! */\n\t\trcu_report_qs_rnp(mask, rnp, rnp->gp_seq, flags);\n\t} else {\n\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t}\n\tsmp_mb(); // Pair with rcu_gp_cleanup()'s ->ofl_seq barrier().\n\tWRITE_ONCE(rnp->ofl_seq, rnp->ofl_seq + 1);\n\tWARN_ON_ONCE(rnp->ofl_seq & 0x1);\n\tsmp_mb(); /* Ensure RCU read-side usage follows above initialization. */\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};",
            "static struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};",
            "static void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);",
            "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
            "static void sync_sched_exp_online_cleanup(int cpu);",
            "static void check_cb_ovld_locked(struct rcu_data *rdp, struct rcu_node *rnp);",
            "static bool rcu_rdp_is_offloaded(struct rcu_data *rdp);",
            "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};\nstatic struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\nstatic void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void sync_sched_exp_online_cleanup(int cpu);\nstatic void check_cb_ovld_locked(struct rcu_data *rdp, struct rcu_node *rnp);\nstatic bool rcu_rdp_is_offloaded(struct rcu_data *rdp);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nvoid rcu_cpu_starting(unsigned int cpu)\n{\n\tunsigned long flags;\n\tunsigned long mask;\n\tstruct rcu_data *rdp;\n\tstruct rcu_node *rnp;\n\tbool newcpu;\n\n\trdp = per_cpu_ptr(&rcu_data, cpu);\n\tif (rdp->cpu_started)\n\t\treturn;\n\trdp->cpu_started = true;\n\n\trnp = rdp->mynode;\n\tmask = rdp->grpmask;\n\tWRITE_ONCE(rnp->ofl_seq, rnp->ofl_seq + 1);\n\tWARN_ON_ONCE(!(rnp->ofl_seq & 0x1));\n\trcu_dynticks_eqs_online();\n\tsmp_mb(); // Pair with rcu_gp_cleanup()'s ->ofl_seq barrier().\n\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\tWRITE_ONCE(rnp->qsmaskinitnext, rnp->qsmaskinitnext | mask);\n\tnewcpu = !(rnp->expmaskinitnext & mask);\n\trnp->expmaskinitnext |= mask;\n\t/* Allow lockless access for expedited grace periods. */\n\tsmp_store_release(&rcu_state.ncpus, rcu_state.ncpus + newcpu); /* ^^^ */\n\tASSERT_EXCLUSIVE_WRITER(rcu_state.ncpus);\n\trcu_gpnum_ovf(rnp, rdp); /* Offline-induced counter wrap? */\n\trdp->rcu_onl_gp_seq = READ_ONCE(rcu_state.gp_seq);\n\trdp->rcu_onl_gp_flags = READ_ONCE(rcu_state.gp_flags);\n\n\t/* An incoming CPU should never be blocking a grace period. */\n\tif (WARN_ON_ONCE(rnp->qsmask & mask)) { /* RCU waiting on incoming CPU? */\n\t\trcu_disable_urgency_upon_qs(rdp);\n\t\t/* Report QS -after- changing ->qsmaskinitnext! */\n\t\trcu_report_qs_rnp(mask, rnp, rnp->gp_seq, flags);\n\t} else {\n\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t}\n\tsmp_mb(); // Pair with rcu_gp_cleanup()'s ->ofl_seq barrier().\n\tWRITE_ONCE(rnp->ofl_seq, rnp->ofl_seq + 1);\n\tWARN_ON_ONCE(rnp->ofl_seq & 0x1);\n\tsmp_mb(); /* Ensure RCU read-side usage follows above initialization. */\n}"
        }
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "(int)st->target",
            "CPUHP_AP_ONLINE"
          ],
          "line": 1286
        },
        "resolved": true,
        "details": {
          "function_name": "irq_setup_timings",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/internals.h",
          "lines": "388-389",
          "snippet": "static inline void irq_setup_timings(struct irq_desc *desc,\n\t\t\t\t     struct irqaction *act) {}",
          "includes": [
            "#include <linux/debugfs.h>",
            "#include \"settings.h\"",
            "#include \"debug.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/pm_runtime.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/irqdesc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void __disable_irq(struct irq_desc *desc);",
            "extern void __enable_irq(struct irq_desc *desc);",
            "extern int irq_activate(struct irq_desc *desc);",
            "extern void irq_shutdown(struct irq_desc *desc);",
            "extern void irq_shutdown_and_deactivate(struct irq_desc *desc);",
            "extern void irq_enable(struct irq_desc *desc);",
            "extern void irq_disable(struct irq_desc *desc);",
            "extern void mask_irq(struct irq_desc *desc);",
            "extern void unmask_irq(struct irq_desc *desc);",
            "extern void unmask_threaded_irq(struct irq_desc *desc);",
            "irqreturn_t __handle_irq_event_percpu(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event_percpu(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event(struct irq_desc *desc);",
            "bool irq_wait_for_poll(struct irq_desc *desc);",
            "extern void irq_set_thread_affinity(struct irq_desc *desc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/debugfs.h>\n#include \"settings.h\"\n#include \"debug.h\"\n#include <linux/sched/clock.h>\n#include <linux/pm_runtime.h>\n#include <linux/kernel_stat.h>\n#include <linux/irqdesc.h>\n\nextern void __disable_irq(struct irq_desc *desc);\nextern void __enable_irq(struct irq_desc *desc);\nextern int irq_activate(struct irq_desc *desc);\nextern void irq_shutdown(struct irq_desc *desc);\nextern void irq_shutdown_and_deactivate(struct irq_desc *desc);\nextern void irq_enable(struct irq_desc *desc);\nextern void irq_disable(struct irq_desc *desc);\nextern void mask_irq(struct irq_desc *desc);\nextern void unmask_irq(struct irq_desc *desc);\nextern void unmask_threaded_irq(struct irq_desc *desc);\nirqreturn_t __handle_irq_event_percpu(struct irq_desc *desc);\nirqreturn_t handle_irq_event_percpu(struct irq_desc *desc);\nirqreturn_t handle_irq_event(struct irq_desc *desc);\nbool irq_wait_for_poll(struct irq_desc *desc);\nextern void irq_set_thread_affinity(struct irq_desc *desc);\n\nstatic inline void irq_setup_timings(struct irq_desc *desc,\n\t\t\t\t     struct irqaction *act) {}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "&cpuhp_state",
            "cpu"
          ],
          "line": 1285
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\n\nvoid notify_cpu_starting(unsigned int cpu)\n{\n\tstruct cpuhp_cpu_state *st = per_cpu_ptr(&cpuhp_state, cpu);\n\tenum cpuhp_state target = min((int)st->target, CPUHP_AP_ONLINE);\n\tint ret;\n\n\trcu_cpu_starting(cpu);\t/* Enables RCU usage on this CPU. */\n\tcpumask_set_cpu(cpu, &cpus_booted_once_mask);\n\tret = cpuhp_invoke_callback_range(true, cpu, st, target);\n\n\t/*\n\t * STARTING must not fail!\n\t */\n\tWARN_ON_ONCE(ret);\n}"
  },
  {
    "function_name": "smp_shutdown_nonboot_cpus",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
    "lines": "1230-1270",
    "snippet": "void smp_shutdown_nonboot_cpus(unsigned int primary_cpu)\n{\n\tunsigned int cpu;\n\tint error;\n\n\tcpu_maps_update_begin();\n\n\t/*\n\t * Make certain the cpu I'm about to reboot on is online.\n\t *\n\t * This is inline to what migrate_to_reboot_cpu() already do.\n\t */\n\tif (!cpu_online(primary_cpu))\n\t\tprimary_cpu = cpumask_first(cpu_online_mask);\n\n\tfor_each_online_cpu(cpu) {\n\t\tif (cpu == primary_cpu)\n\t\t\tcontinue;\n\n\t\terror = cpu_down_maps_locked(cpu, CPUHP_OFFLINE);\n\t\tif (error) {\n\t\t\tpr_err(\"Failed to offline CPU%d - error=%d\",\n\t\t\t\tcpu, error);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/*\n\t * Ensure all but the reboot CPU are offline.\n\t */\n\tBUG_ON(num_online_cpus() > 1);\n\n\t/*\n\t * Make sure the CPUs won't be enabled by someone else after this\n\t * point. Kexec will reboot to a new kernel shortly resetting\n\t * everything along the way.\n\t */\n\tcpu_hotplug_disabled++;\n\n\tcpu_maps_update_done();\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/scs.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sched/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_maps_update_done",
          "args": [],
          "line": 1269
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_maps_update_done",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "292-295",
          "snippet": "void cpu_maps_update_done(void)\n{\n\tmutex_unlock(&cpu_add_remove_lock);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nvoid cpu_maps_update_done(void)\n{\n\tmutex_unlock(&cpu_add_remove_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "num_online_cpus() > 1"
          ],
          "line": 1260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "num_online_cpus",
          "args": [],
          "line": 1260
        },
        "resolved": true,
        "details": {
          "function_name": "torture_num_online_cpus",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/torture.c",
          "lines": "185-188",
          "snippet": "int torture_num_online_cpus(void)\n{\n\treturn READ_ONCE(torture_online_cpus);\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint torture_num_online_cpus(void)\n{\n\treturn READ_ONCE(torture_online_cpus);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Failed to offline CPU%d - error=%d\"",
            "cpu",
            "error"
          ],
          "line": 1251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_down_maps_locked",
          "args": [
            "cpu",
            "CPUHP_OFFLINE"
          ],
          "line": 1249
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_down_maps_locked",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "1186-1191",
          "snippet": "static int cpu_down_maps_locked(unsigned int cpu, enum cpuhp_state target)\n{\n\tif (cpu_hotplug_disabled)\n\t\treturn -EBUSY;\n\treturn _cpu_down(cpu, 0, target);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\n\nstatic int cpu_down_maps_locked(unsigned int cpu, enum cpuhp_state target)\n{\n\tif (cpu_hotplug_disabled)\n\t\treturn -EBUSY;\n\treturn _cpu_down(cpu, 0, target);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_first",
          "args": [
            "cpu_online_mask"
          ],
          "line": 1243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_online",
          "args": [
            "primary_cpu"
          ],
          "line": 1242
        },
        "resolved": true,
        "details": {
          "function_name": "init_cpu_online",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "2616-2619",
          "snippet": "void init_cpu_online(const struct cpumask *src)\n{\n\tcpumask_copy(&__cpu_online_mask, src);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct cpumask __cpu_online_mask"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstruct cpumask __cpu_online_mask;\n\nvoid init_cpu_online(const struct cpumask *src)\n{\n\tcpumask_copy(&__cpu_online_mask, src);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_maps_update_begin",
          "args": [],
          "line": 1235
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_maps_update_begin",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "287-290",
          "snippet": "void cpu_maps_update_begin(void)\n{\n\tmutex_lock(&cpu_add_remove_lock);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nvoid cpu_maps_update_begin(void)\n{\n\tmutex_lock(&cpu_add_remove_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nvoid smp_shutdown_nonboot_cpus(unsigned int primary_cpu)\n{\n\tunsigned int cpu;\n\tint error;\n\n\tcpu_maps_update_begin();\n\n\t/*\n\t * Make certain the cpu I'm about to reboot on is online.\n\t *\n\t * This is inline to what migrate_to_reboot_cpu() already do.\n\t */\n\tif (!cpu_online(primary_cpu))\n\t\tprimary_cpu = cpumask_first(cpu_online_mask);\n\n\tfor_each_online_cpu(cpu) {\n\t\tif (cpu == primary_cpu)\n\t\t\tcontinue;\n\n\t\terror = cpu_down_maps_locked(cpu, CPUHP_OFFLINE);\n\t\tif (error) {\n\t\t\tpr_err(\"Failed to offline CPU%d - error=%d\",\n\t\t\t\tcpu, error);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/*\n\t * Ensure all but the reboot CPU are offline.\n\t */\n\tBUG_ON(num_online_cpus() > 1);\n\n\t/*\n\t * Make sure the CPUs won't be enabled by someone else after this\n\t * point. Kexec will reboot to a new kernel shortly resetting\n\t * everything along the way.\n\t */\n\tcpu_hotplug_disabled++;\n\n\tcpu_maps_update_done();\n}"
  },
  {
    "function_name": "remove_cpu",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
    "lines": "1218-1227",
    "snippet": "int remove_cpu(unsigned int cpu)\n{\n\tint ret;\n\n\tlock_device_hotplug();\n\tret = device_offline(get_cpu_device(cpu));\n\tunlock_device_hotplug();\n\n\treturn ret;\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/scs.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sched/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_device_hotplug",
          "args": [],
          "line": 1224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "device_offline",
          "args": [
            "get_cpu_device(cpu)"
          ],
          "line": 1223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_cpu_device",
          "args": [
            "cpu"
          ],
          "line": 1223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lock_device_hotplug",
          "args": [],
          "line": 1222
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nint remove_cpu(unsigned int cpu)\n{\n\tint ret;\n\n\tlock_device_hotplug();\n\tret = device_offline(get_cpu_device(cpu));\n\tunlock_device_hotplug();\n\n\treturn ret;\n}"
  },
  {
    "function_name": "cpu_device_down",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
    "lines": "1213-1216",
    "snippet": "int cpu_device_down(struct device *dev)\n{\n\treturn cpu_down(dev->id, CPUHP_OFFLINE);\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/scs.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sched/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_down",
          "args": [
            "dev->id",
            "CPUHP_OFFLINE"
          ],
          "line": 1215
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_down",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "1193-1201",
          "snippet": "static int cpu_down(unsigned int cpu, enum cpuhp_state target)\n{\n\tint err;\n\n\tcpu_maps_update_begin();\n\terr = cpu_down_maps_locked(cpu, target);\n\tcpu_maps_update_done();\n\treturn err;\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\n\nstatic int cpu_down(unsigned int cpu, enum cpuhp_state target)\n{\n\tint err;\n\n\tcpu_maps_update_begin();\n\terr = cpu_down_maps_locked(cpu, target);\n\tcpu_maps_update_done();\n\treturn err;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nint cpu_device_down(struct device *dev)\n{\n\treturn cpu_down(dev->id, CPUHP_OFFLINE);\n}"
  },
  {
    "function_name": "cpu_down",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
    "lines": "1193-1201",
    "snippet": "static int cpu_down(unsigned int cpu, enum cpuhp_state target)\n{\n\tint err;\n\n\tcpu_maps_update_begin();\n\terr = cpu_down_maps_locked(cpu, target);\n\tcpu_maps_update_done();\n\treturn err;\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/scs.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sched/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_maps_update_done",
          "args": [],
          "line": 1199
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_maps_update_done",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "292-295",
          "snippet": "void cpu_maps_update_done(void)\n{\n\tmutex_unlock(&cpu_add_remove_lock);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nvoid cpu_maps_update_done(void)\n{\n\tmutex_unlock(&cpu_add_remove_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_down_maps_locked",
          "args": [
            "cpu",
            "target"
          ],
          "line": 1198
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_down_maps_locked",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "1186-1191",
          "snippet": "static int cpu_down_maps_locked(unsigned int cpu, enum cpuhp_state target)\n{\n\tif (cpu_hotplug_disabled)\n\t\treturn -EBUSY;\n\treturn _cpu_down(cpu, 0, target);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\n\nstatic int cpu_down_maps_locked(unsigned int cpu, enum cpuhp_state target)\n{\n\tif (cpu_hotplug_disabled)\n\t\treturn -EBUSY;\n\treturn _cpu_down(cpu, 0, target);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_maps_update_begin",
          "args": [],
          "line": 1197
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_maps_update_begin",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "287-290",
          "snippet": "void cpu_maps_update_begin(void)\n{\n\tmutex_lock(&cpu_add_remove_lock);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nvoid cpu_maps_update_begin(void)\n{\n\tmutex_lock(&cpu_add_remove_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\n\nstatic int cpu_down(unsigned int cpu, enum cpuhp_state target)\n{\n\tint err;\n\n\tcpu_maps_update_begin();\n\terr = cpu_down_maps_locked(cpu, target);\n\tcpu_maps_update_done();\n\treturn err;\n}"
  },
  {
    "function_name": "cpu_down_maps_locked",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
    "lines": "1186-1191",
    "snippet": "static int cpu_down_maps_locked(unsigned int cpu, enum cpuhp_state target)\n{\n\tif (cpu_hotplug_disabled)\n\t\treturn -EBUSY;\n\treturn _cpu_down(cpu, 0, target);\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/scs.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sched/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "_cpu_down",
          "args": [
            "cpu",
            "0",
            "target"
          ],
          "line": 1190
        },
        "resolved": true,
        "details": {
          "function_name": "_cpu_down",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "1120-1184",
          "snippet": "static int __ref _cpu_down(unsigned int cpu, int tasks_frozen,\n\t\t\t   enum cpuhp_state target)\n{\n\tstruct cpuhp_cpu_state *st = per_cpu_ptr(&cpuhp_state, cpu);\n\tint prev_state, ret = 0;\n\n\tif (num_online_cpus() == 1)\n\t\treturn -EBUSY;\n\n\tif (!cpu_present(cpu))\n\t\treturn -EINVAL;\n\n\tcpus_write_lock();\n\n\tcpuhp_tasks_frozen = tasks_frozen;\n\n\tprev_state = cpuhp_set_state(st, target);\n\t/*\n\t * If the current CPU state is in the range of the AP hotplug thread,\n\t * then we need to kick the thread.\n\t */\n\tif (st->state > CPUHP_TEARDOWN_CPU) {\n\t\tst->target = max((int)target, CPUHP_TEARDOWN_CPU);\n\t\tret = cpuhp_kick_ap_work(cpu);\n\t\t/*\n\t\t * The AP side has done the error rollback already. Just\n\t\t * return the error code..\n\t\t */\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\t/*\n\t\t * We might have stopped still in the range of the AP hotplug\n\t\t * thread. Nothing to do anymore.\n\t\t */\n\t\tif (st->state > CPUHP_TEARDOWN_CPU)\n\t\t\tgoto out;\n\n\t\tst->target = target;\n\t}\n\t/*\n\t * The AP brought itself down to CPUHP_TEARDOWN_CPU. So we need\n\t * to do the further cleanups.\n\t */\n\tret = cpuhp_down_callbacks(cpu, st, target);\n\tif (ret && st->state < prev_state) {\n\t\tif (st->state == CPUHP_TEARDOWN_CPU) {\n\t\t\tcpuhp_reset_state(st, prev_state);\n\t\t\t__cpuhp_kick_ap(st);\n\t\t} else {\n\t\t\tWARN(1, \"DEAD callback error for CPU%d\", cpu);\n\t\t}\n\t}\n\nout:\n\tcpus_write_unlock();\n\t/*\n\t * Do post unplug cleanup. This is still protected against\n\t * concurrent CPU hotplug via cpu_add_remove_lock.\n\t */\n\tlockup_detector_cleanup();\n\tarch_smt_update();\n\tcpu_up_down_serialize_trainwrecks(tasks_frozen);\n\treturn ret;\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\n\nstatic int __ref _cpu_down(unsigned int cpu, int tasks_frozen,\n\t\t\t   enum cpuhp_state target)\n{\n\tstruct cpuhp_cpu_state *st = per_cpu_ptr(&cpuhp_state, cpu);\n\tint prev_state, ret = 0;\n\n\tif (num_online_cpus() == 1)\n\t\treturn -EBUSY;\n\n\tif (!cpu_present(cpu))\n\t\treturn -EINVAL;\n\n\tcpus_write_lock();\n\n\tcpuhp_tasks_frozen = tasks_frozen;\n\n\tprev_state = cpuhp_set_state(st, target);\n\t/*\n\t * If the current CPU state is in the range of the AP hotplug thread,\n\t * then we need to kick the thread.\n\t */\n\tif (st->state > CPUHP_TEARDOWN_CPU) {\n\t\tst->target = max((int)target, CPUHP_TEARDOWN_CPU);\n\t\tret = cpuhp_kick_ap_work(cpu);\n\t\t/*\n\t\t * The AP side has done the error rollback already. Just\n\t\t * return the error code..\n\t\t */\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\t/*\n\t\t * We might have stopped still in the range of the AP hotplug\n\t\t * thread. Nothing to do anymore.\n\t\t */\n\t\tif (st->state > CPUHP_TEARDOWN_CPU)\n\t\t\tgoto out;\n\n\t\tst->target = target;\n\t}\n\t/*\n\t * The AP brought itself down to CPUHP_TEARDOWN_CPU. So we need\n\t * to do the further cleanups.\n\t */\n\tret = cpuhp_down_callbacks(cpu, st, target);\n\tif (ret && st->state < prev_state) {\n\t\tif (st->state == CPUHP_TEARDOWN_CPU) {\n\t\t\tcpuhp_reset_state(st, prev_state);\n\t\t\t__cpuhp_kick_ap(st);\n\t\t} else {\n\t\t\tWARN(1, \"DEAD callback error for CPU%d\", cpu);\n\t\t}\n\t}\n\nout:\n\tcpus_write_unlock();\n\t/*\n\t * Do post unplug cleanup. This is still protected against\n\t * concurrent CPU hotplug via cpu_add_remove_lock.\n\t */\n\tlockup_detector_cleanup();\n\tarch_smt_update();\n\tcpu_up_down_serialize_trainwrecks(tasks_frozen);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\n\nstatic int cpu_down_maps_locked(unsigned int cpu, enum cpuhp_state target)\n{\n\tif (cpu_hotplug_disabled)\n\t\treturn -EBUSY;\n\treturn _cpu_down(cpu, 0, target);\n}"
  },
  {
    "function_name": "_cpu_down",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
    "lines": "1120-1184",
    "snippet": "static int __ref _cpu_down(unsigned int cpu, int tasks_frozen,\n\t\t\t   enum cpuhp_state target)\n{\n\tstruct cpuhp_cpu_state *st = per_cpu_ptr(&cpuhp_state, cpu);\n\tint prev_state, ret = 0;\n\n\tif (num_online_cpus() == 1)\n\t\treturn -EBUSY;\n\n\tif (!cpu_present(cpu))\n\t\treturn -EINVAL;\n\n\tcpus_write_lock();\n\n\tcpuhp_tasks_frozen = tasks_frozen;\n\n\tprev_state = cpuhp_set_state(st, target);\n\t/*\n\t * If the current CPU state is in the range of the AP hotplug thread,\n\t * then we need to kick the thread.\n\t */\n\tif (st->state > CPUHP_TEARDOWN_CPU) {\n\t\tst->target = max((int)target, CPUHP_TEARDOWN_CPU);\n\t\tret = cpuhp_kick_ap_work(cpu);\n\t\t/*\n\t\t * The AP side has done the error rollback already. Just\n\t\t * return the error code..\n\t\t */\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\t/*\n\t\t * We might have stopped still in the range of the AP hotplug\n\t\t * thread. Nothing to do anymore.\n\t\t */\n\t\tif (st->state > CPUHP_TEARDOWN_CPU)\n\t\t\tgoto out;\n\n\t\tst->target = target;\n\t}\n\t/*\n\t * The AP brought itself down to CPUHP_TEARDOWN_CPU. So we need\n\t * to do the further cleanups.\n\t */\n\tret = cpuhp_down_callbacks(cpu, st, target);\n\tif (ret && st->state < prev_state) {\n\t\tif (st->state == CPUHP_TEARDOWN_CPU) {\n\t\t\tcpuhp_reset_state(st, prev_state);\n\t\t\t__cpuhp_kick_ap(st);\n\t\t} else {\n\t\t\tWARN(1, \"DEAD callback error for CPU%d\", cpu);\n\t\t}\n\t}\n\nout:\n\tcpus_write_unlock();\n\t/*\n\t * Do post unplug cleanup. This is still protected against\n\t * concurrent CPU hotplug via cpu_add_remove_lock.\n\t */\n\tlockup_detector_cleanup();\n\tarch_smt_update();\n\tcpu_up_down_serialize_trainwrecks(tasks_frozen);\n\treturn ret;\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/scs.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sched/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_up_down_serialize_trainwrecks",
          "args": [
            "tasks_frozen"
          ],
          "line": 1182
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_up_down_serialize_trainwrecks",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "921-942",
          "snippet": "static void cpu_up_down_serialize_trainwrecks(bool tasks_frozen)\n{\n\t/*\n\t * cpusets delegate hotplug operations to a worker to \"solve\" the\n\t * lock order problems. Wait for the worker, but only if tasks are\n\t * _not_ frozen (suspend, hibernate) as that would wait forever.\n\t *\n\t * The wait is required because otherwise the hotplug operation\n\t * returns with inconsistent state, which could even be observed in\n\t * user space when a new CPU is brought up. The CPU plug uevent\n\t * would be delivered and user space reacting on it would fail to\n\t * move tasks to the newly plugged CPU up to the point where the\n\t * work has finished because up to that point the newly plugged CPU\n\t * is not assignable in cpusets/cgroups. On unplug that's not\n\t * necessarily a visible issue, but it is still inconsistent state,\n\t * which is the real problem which needs to be \"fixed\". This can't\n\t * prevent the transient state between scheduling the work and\n\t * returning from waiting for it.\n\t */\n\tif (!tasks_frozen)\n\t\tcpuset_wait_for_hotplug();\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstatic void cpu_up_down_serialize_trainwrecks(bool tasks_frozen)\n{\n\t/*\n\t * cpusets delegate hotplug operations to a worker to \"solve\" the\n\t * lock order problems. Wait for the worker, but only if tasks are\n\t * _not_ frozen (suspend, hibernate) as that would wait forever.\n\t *\n\t * The wait is required because otherwise the hotplug operation\n\t * returns with inconsistent state, which could even be observed in\n\t * user space when a new CPU is brought up. The CPU plug uevent\n\t * would be delivered and user space reacting on it would fail to\n\t * move tasks to the newly plugged CPU up to the point where the\n\t * work has finished because up to that point the newly plugged CPU\n\t * is not assignable in cpusets/cgroups. On unplug that's not\n\t * necessarily a visible issue, but it is still inconsistent state,\n\t * which is the real problem which needs to be \"fixed\". This can't\n\t * prevent the transient state between scheduling the work and\n\t * returning from waiting for it.\n\t */\n\tif (!tasks_frozen)\n\t\tcpuset_wait_for_hotplug();\n}"
        }
      },
      {
        "call_info": {
          "callee": "arch_smt_update",
          "args": [],
          "line": 1181
        },
        "resolved": true,
        "details": {
          "function_name": "arch_smt_update",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "412-412",
          "snippet": "void __weak arch_smt_update(void) { }",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nvoid __weak arch_smt_update(void) { }"
        }
      },
      {
        "call_info": {
          "callee": "lockup_detector_cleanup",
          "args": [],
          "line": 1180
        },
        "resolved": true,
        "details": {
          "function_name": "lockup_detector_cleanup",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/watchdog.c",
          "lines": "607-612",
          "snippet": "void lockup_detector_cleanup(void)\n{\n\tmutex_lock(&watchdog_mutex);\n\t__lockup_detector_cleanup();\n\tmutex_unlock(&watchdog_mutex);\n}",
          "includes": [
            "#include <linux/kvm_para.h>",
            "#include <asm/irq_regs.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/tick.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/nmi.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(watchdog_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nstatic DEFINE_MUTEX(watchdog_mutex);\n\nvoid lockup_detector_cleanup(void)\n{\n\tmutex_lock(&watchdog_mutex);\n\t__lockup_detector_cleanup();\n\tmutex_unlock(&watchdog_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpus_write_unlock",
          "args": [],
          "line": 1175
        },
        "resolved": true,
        "details": {
          "function_name": "cpus_write_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "330-333",
          "snippet": "void cpus_write_unlock(void)\n{\n\tpercpu_up_write(&cpu_hotplug_lock);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nvoid cpus_write_unlock(void)\n{\n\tpercpu_up_write(&cpu_hotplug_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "1",
            "\"DEAD callback error for CPU%d\"",
            "cpu"
          ],
          "line": 1170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__cpuhp_kick_ap",
          "args": [
            "st"
          ],
          "line": 1168
        },
        "resolved": true,
        "details": {
          "function_name": "__cpuhp_kick_ap",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "527-541",
          "snippet": "static void __cpuhp_kick_ap(struct cpuhp_cpu_state *st)\n{\n\tif (!st->single && st->state == st->target)\n\t\treturn;\n\n\tst->result = 0;\n\t/*\n\t * Make sure the above stores are visible before should_run becomes\n\t * true. Paired with the mb() above in cpuhp_thread_fun()\n\t */\n\tsmp_mb();\n\tst->should_run = true;\n\twake_up_process(st->thread);\n\twait_for_ap_thread(st, st->bringup);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstatic void __cpuhp_kick_ap(struct cpuhp_cpu_state *st)\n{\n\tif (!st->single && st->state == st->target)\n\t\treturn;\n\n\tst->result = 0;\n\t/*\n\t * Make sure the above stores are visible before should_run becomes\n\t * true. Paired with the mb() above in cpuhp_thread_fun()\n\t */\n\tsmp_mb();\n\tst->should_run = true;\n\twake_up_process(st->thread);\n\twait_for_ap_thread(st, st->bringup);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpuhp_reset_state",
          "args": [
            "st",
            "prev_state"
          ],
          "line": 1167
        },
        "resolved": true,
        "details": {
          "function_name": "cpuhp_reset_state",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "494-524",
          "snippet": "static inline void\ncpuhp_reset_state(struct cpuhp_cpu_state *st, enum cpuhp_state prev_state)\n{\n\tbool bringup = !st->bringup;\n\n\tst->target = prev_state;\n\n\t/*\n\t * Already rolling back. No need invert the bringup value or to change\n\t * the current state.\n\t */\n\tif (st->rollback)\n\t\treturn;\n\n\tst->rollback = true;\n\n\t/*\n\t * If we have st->last we need to undo partial multi_instance of this\n\t * state first. Otherwise start undo at the previous state.\n\t */\n\tif (!st->last) {\n\t\tif (st->bringup)\n\t\t\tst->state--;\n\t\telse\n\t\t\tst->state++;\n\t}\n\n\tst->bringup = bringup;\n\tif (cpu_dying(st->cpu) != !bringup)\n\t\tset_cpu_dying(st->cpu, !bringup);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\n\nstatic inline void\ncpuhp_reset_state(struct cpuhp_cpu_state *st, enum cpuhp_state prev_state)\n{\n\tbool bringup = !st->bringup;\n\n\tst->target = prev_state;\n\n\t/*\n\t * Already rolling back. No need invert the bringup value or to change\n\t * the current state.\n\t */\n\tif (st->rollback)\n\t\treturn;\n\n\tst->rollback = true;\n\n\t/*\n\t * If we have st->last we need to undo partial multi_instance of this\n\t * state first. Otherwise start undo at the previous state.\n\t */\n\tif (!st->last) {\n\t\tif (st->bringup)\n\t\t\tst->state--;\n\t\telse\n\t\t\tst->state++;\n\t}\n\n\tst->bringup = bringup;\n\tif (cpu_dying(st->cpu) != !bringup)\n\t\tset_cpu_dying(st->cpu, !bringup);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpuhp_down_callbacks",
          "args": [
            "cpu",
            "st",
            "target"
          ],
          "line": 1164
        },
        "resolved": true,
        "details": {
          "function_name": "cpuhp_down_callbacks",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "1097-1117",
          "snippet": "static int cpuhp_down_callbacks(unsigned int cpu, struct cpuhp_cpu_state *st,\n\t\t\t\tenum cpuhp_state target)\n{\n\tenum cpuhp_state prev_state = st->state;\n\tint ret = 0;\n\n\tret = cpuhp_invoke_callback_range(false, cpu, st, target);\n\tif (ret) {\n\t\tpr_debug(\"CPU DOWN failed (%d) CPU %u state %s (%d)\\n\",\n\t\t\t ret, cpu, cpuhp_get_step(st->state)->name,\n\t\t\t st->state);\n\n\t\tcpuhp_reset_state(st, prev_state);\n\n\t\tif (st->state < prev_state)\n\t\t\tWARN_ON(cpuhp_invoke_callback_range(true, cpu, st,\n\t\t\t\t\t\t\t    prev_state));\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\n\nstatic int cpuhp_down_callbacks(unsigned int cpu, struct cpuhp_cpu_state *st,\n\t\t\t\tenum cpuhp_state target)\n{\n\tenum cpuhp_state prev_state = st->state;\n\tint ret = 0;\n\n\tret = cpuhp_invoke_callback_range(false, cpu, st, target);\n\tif (ret) {\n\t\tpr_debug(\"CPU DOWN failed (%d) CPU %u state %s (%d)\\n\",\n\t\t\t ret, cpu, cpuhp_get_step(st->state)->name,\n\t\t\t st->state);\n\n\t\tcpuhp_reset_state(st, prev_state);\n\n\t\tif (st->state < prev_state)\n\t\t\tWARN_ON(cpuhp_invoke_callback_range(true, cpu, st,\n\t\t\t\t\t\t\t    prev_state));\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpuhp_kick_ap_work",
          "args": [
            "cpu"
          ],
          "line": 1143
        },
        "resolved": true,
        "details": {
          "function_name": "cpuhp_kick_ap_work",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "864-881",
          "snippet": "static int cpuhp_kick_ap_work(unsigned int cpu)\n{\n\tstruct cpuhp_cpu_state *st = per_cpu_ptr(&cpuhp_state, cpu);\n\tenum cpuhp_state prev_state = st->state;\n\tint ret;\n\n\tcpuhp_lock_acquire(false);\n\tcpuhp_lock_release(false);\n\n\tcpuhp_lock_acquire(true);\n\tcpuhp_lock_release(true);\n\n\ttrace_cpuhp_enter(cpu, st->target, prev_state, cpuhp_kick_ap_work);\n\tret = cpuhp_kick_ap(st, st->target);\n\ttrace_cpuhp_exit(cpu, st->state, prev_state, ret);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\n\nstatic int cpuhp_kick_ap_work(unsigned int cpu)\n{\n\tstruct cpuhp_cpu_state *st = per_cpu_ptr(&cpuhp_state, cpu);\n\tenum cpuhp_state prev_state = st->state;\n\tint ret;\n\n\tcpuhp_lock_acquire(false);\n\tcpuhp_lock_release(false);\n\n\tcpuhp_lock_acquire(true);\n\tcpuhp_lock_release(true);\n\n\ttrace_cpuhp_enter(cpu, st->target, prev_state, cpuhp_kick_ap_work);\n\tret = cpuhp_kick_ap(st, st->target);\n\ttrace_cpuhp_exit(cpu, st->state, prev_state, ret);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "max",
          "args": [
            "(int)target",
            "CPUHP_TEARDOWN_CPU"
          ],
          "line": 1142
        },
        "resolved": true,
        "details": {
          "function_name": "module_extend_max_pages",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/module_decompress.c",
          "lines": "17-32",
          "snippet": "static int module_extend_max_pages(struct load_info *info, unsigned int extent)\n{\n\tstruct page **new_pages;\n\n\tnew_pages = kvmalloc_array(info->max_pages + extent,\n\t\t\t\t   sizeof(info->pages), GFP_KERNEL);\n\tif (!new_pages)\n\t\treturn -ENOMEM;\n\n\tmemcpy(new_pages, info->pages, info->max_pages * sizeof(info->pages));\n\tkvfree(info->pages);\n\tinfo->pages = new_pages;\n\tinfo->max_pages += extent;\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/xz.h>",
            "#include <linux/zlib.h>",
            "#include \"module-internal.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/kobject.h>",
            "#include <linux/highmem.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/xz.h>\n#include <linux/zlib.h>\n#include \"module-internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/sysfs.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/kobject.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n\nstatic int module_extend_max_pages(struct load_info *info, unsigned int extent)\n{\n\tstruct page **new_pages;\n\n\tnew_pages = kvmalloc_array(info->max_pages + extent,\n\t\t\t\t   sizeof(info->pages), GFP_KERNEL);\n\tif (!new_pages)\n\t\treturn -ENOMEM;\n\n\tmemcpy(new_pages, info->pages, info->max_pages * sizeof(info->pages));\n\tkvfree(info->pages);\n\tinfo->pages = new_pages;\n\tinfo->max_pages += extent;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpuhp_set_state",
          "args": [
            "st",
            "target"
          ],
          "line": 1136
        },
        "resolved": true,
        "details": {
          "function_name": "cpuhp_set_state",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "476-492",
          "snippet": "static inline enum cpuhp_state\ncpuhp_set_state(struct cpuhp_cpu_state *st, enum cpuhp_state target)\n{\n\tenum cpuhp_state prev_state = st->state;\n\tbool bringup = st->state < target;\n\n\tst->rollback = false;\n\tst->last = NULL;\n\n\tst->target = target;\n\tst->single = false;\n\tst->bringup = bringup;\n\tif (cpu_dying(st->cpu) != !bringup)\n\t\tset_cpu_dying(st->cpu, !bringup);\n\n\treturn prev_state;\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\n\nstatic inline enum cpuhp_state\ncpuhp_set_state(struct cpuhp_cpu_state *st, enum cpuhp_state target)\n{\n\tenum cpuhp_state prev_state = st->state;\n\tbool bringup = st->state < target;\n\n\tst->rollback = false;\n\tst->last = NULL;\n\n\tst->target = target;\n\tst->single = false;\n\tst->bringup = bringup;\n\tif (cpu_dying(st->cpu) != !bringup)\n\t\tset_cpu_dying(st->cpu, !bringup);\n\n\treturn prev_state;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpus_write_lock",
          "args": [],
          "line": 1132
        },
        "resolved": true,
        "details": {
          "function_name": "cpus_write_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "325-328",
          "snippet": "void cpus_write_lock(void)\n{\n\tpercpu_down_write(&cpu_hotplug_lock);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nvoid cpus_write_lock(void)\n{\n\tpercpu_down_write(&cpu_hotplug_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_present",
          "args": [
            "cpu"
          ],
          "line": 1129
        },
        "resolved": true,
        "details": {
          "function_name": "init_cpu_present",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "2606-2609",
          "snippet": "void init_cpu_present(const struct cpumask *src)\n{\n\tcpumask_copy(&__cpu_present_mask, src);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct cpumask __cpu_present_mask"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstruct cpumask __cpu_present_mask;\n\nvoid init_cpu_present(const struct cpumask *src)\n{\n\tcpumask_copy(&__cpu_present_mask, src);\n}"
        }
      },
      {
        "call_info": {
          "callee": "num_online_cpus",
          "args": [],
          "line": 1126
        },
        "resolved": true,
        "details": {
          "function_name": "torture_num_online_cpus",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/torture.c",
          "lines": "185-188",
          "snippet": "int torture_num_online_cpus(void)\n{\n\treturn READ_ONCE(torture_online_cpus);\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint torture_num_online_cpus(void)\n{\n\treturn READ_ONCE(torture_online_cpus);\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "&cpuhp_state",
            "cpu"
          ],
          "line": 1123
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\n\nstatic int __ref _cpu_down(unsigned int cpu, int tasks_frozen,\n\t\t\t   enum cpuhp_state target)\n{\n\tstruct cpuhp_cpu_state *st = per_cpu_ptr(&cpuhp_state, cpu);\n\tint prev_state, ret = 0;\n\n\tif (num_online_cpus() == 1)\n\t\treturn -EBUSY;\n\n\tif (!cpu_present(cpu))\n\t\treturn -EINVAL;\n\n\tcpus_write_lock();\n\n\tcpuhp_tasks_frozen = tasks_frozen;\n\n\tprev_state = cpuhp_set_state(st, target);\n\t/*\n\t * If the current CPU state is in the range of the AP hotplug thread,\n\t * then we need to kick the thread.\n\t */\n\tif (st->state > CPUHP_TEARDOWN_CPU) {\n\t\tst->target = max((int)target, CPUHP_TEARDOWN_CPU);\n\t\tret = cpuhp_kick_ap_work(cpu);\n\t\t/*\n\t\t * The AP side has done the error rollback already. Just\n\t\t * return the error code..\n\t\t */\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\t/*\n\t\t * We might have stopped still in the range of the AP hotplug\n\t\t * thread. Nothing to do anymore.\n\t\t */\n\t\tif (st->state > CPUHP_TEARDOWN_CPU)\n\t\t\tgoto out;\n\n\t\tst->target = target;\n\t}\n\t/*\n\t * The AP brought itself down to CPUHP_TEARDOWN_CPU. So we need\n\t * to do the further cleanups.\n\t */\n\tret = cpuhp_down_callbacks(cpu, st, target);\n\tif (ret && st->state < prev_state) {\n\t\tif (st->state == CPUHP_TEARDOWN_CPU) {\n\t\t\tcpuhp_reset_state(st, prev_state);\n\t\t\t__cpuhp_kick_ap(st);\n\t\t} else {\n\t\t\tWARN(1, \"DEAD callback error for CPU%d\", cpu);\n\t\t}\n\t}\n\nout:\n\tcpus_write_unlock();\n\t/*\n\t * Do post unplug cleanup. This is still protected against\n\t * concurrent CPU hotplug via cpu_add_remove_lock.\n\t */\n\tlockup_detector_cleanup();\n\tarch_smt_update();\n\tcpu_up_down_serialize_trainwrecks(tasks_frozen);\n\treturn ret;\n}"
  },
  {
    "function_name": "cpuhp_down_callbacks",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
    "lines": "1097-1117",
    "snippet": "static int cpuhp_down_callbacks(unsigned int cpu, struct cpuhp_cpu_state *st,\n\t\t\t\tenum cpuhp_state target)\n{\n\tenum cpuhp_state prev_state = st->state;\n\tint ret = 0;\n\n\tret = cpuhp_invoke_callback_range(false, cpu, st, target);\n\tif (ret) {\n\t\tpr_debug(\"CPU DOWN failed (%d) CPU %u state %s (%d)\\n\",\n\t\t\t ret, cpu, cpuhp_get_step(st->state)->name,\n\t\t\t st->state);\n\n\t\tcpuhp_reset_state(st, prev_state);\n\n\t\tif (st->state < prev_state)\n\t\t\tWARN_ON(cpuhp_invoke_callback_range(true, cpu, st,\n\t\t\t\t\t\t\t    prev_state));\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/scs.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sched/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "cpuhp_invoke_callback_range(true, cpu, st,\n\t\t\t\t\t\t\t    prev_state)"
          ],
          "line": 1112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpuhp_invoke_callback_range",
          "args": [
            "true",
            "cpu",
            "st",
            "prev_state"
          ],
          "line": 1112
        },
        "resolved": true,
        "details": {
          "function_name": "cpuhp_invoke_callback_range",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "663-678",
          "snippet": "static int cpuhp_invoke_callback_range(bool bringup,\n\t\t\t\t       unsigned int cpu,\n\t\t\t\t       struct cpuhp_cpu_state *st,\n\t\t\t\t       enum cpuhp_state target)\n{\n\tenum cpuhp_state state;\n\tint err = 0;\n\n\twhile (cpuhp_next_state(bringup, &state, st, target)) {\n\t\terr = cpuhp_invoke_callback(cpu, state, bringup, NULL, NULL);\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\n\treturn err;\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\n\nstatic int cpuhp_invoke_callback_range(bool bringup,\n\t\t\t\t       unsigned int cpu,\n\t\t\t\t       struct cpuhp_cpu_state *st,\n\t\t\t\t       enum cpuhp_state target)\n{\n\tenum cpuhp_state state;\n\tint err = 0;\n\n\twhile (cpuhp_next_state(bringup, &state, st, target)) {\n\t\terr = cpuhp_invoke_callback(cpu, state, bringup, NULL, NULL);\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpuhp_reset_state",
          "args": [
            "st",
            "prev_state"
          ],
          "line": 1109
        },
        "resolved": true,
        "details": {
          "function_name": "cpuhp_reset_state",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "494-524",
          "snippet": "static inline void\ncpuhp_reset_state(struct cpuhp_cpu_state *st, enum cpuhp_state prev_state)\n{\n\tbool bringup = !st->bringup;\n\n\tst->target = prev_state;\n\n\t/*\n\t * Already rolling back. No need invert the bringup value or to change\n\t * the current state.\n\t */\n\tif (st->rollback)\n\t\treturn;\n\n\tst->rollback = true;\n\n\t/*\n\t * If we have st->last we need to undo partial multi_instance of this\n\t * state first. Otherwise start undo at the previous state.\n\t */\n\tif (!st->last) {\n\t\tif (st->bringup)\n\t\t\tst->state--;\n\t\telse\n\t\t\tst->state++;\n\t}\n\n\tst->bringup = bringup;\n\tif (cpu_dying(st->cpu) != !bringup)\n\t\tset_cpu_dying(st->cpu, !bringup);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\n\nstatic inline void\ncpuhp_reset_state(struct cpuhp_cpu_state *st, enum cpuhp_state prev_state)\n{\n\tbool bringup = !st->bringup;\n\n\tst->target = prev_state;\n\n\t/*\n\t * Already rolling back. No need invert the bringup value or to change\n\t * the current state.\n\t */\n\tif (st->rollback)\n\t\treturn;\n\n\tst->rollback = true;\n\n\t/*\n\t * If we have st->last we need to undo partial multi_instance of this\n\t * state first. Otherwise start undo at the previous state.\n\t */\n\tif (!st->last) {\n\t\tif (st->bringup)\n\t\t\tst->state--;\n\t\telse\n\t\t\tst->state++;\n\t}\n\n\tst->bringup = bringup;\n\tif (cpu_dying(st->cpu) != !bringup)\n\t\tset_cpu_dying(st->cpu, !bringup);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"CPU DOWN failed (%d) CPU %u state %s (%d)\\n\"",
            "ret",
            "cpu",
            "cpuhp_get_step(st->state)->name",
            "st->state"
          ],
          "line": 1105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpuhp_get_step",
          "args": [
            "st->state"
          ],
          "line": 1106
        },
        "resolved": true,
        "details": {
          "function_name": "cpuhp_get_step",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "144-147",
          "snippet": "static struct cpuhp_step *cpuhp_get_step(enum cpuhp_state state)\n{\n\treturn cpuhp_hp_states + state;\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};",
            "static struct cpuhp_step cpuhp_hp_states[];",
            "static struct cpuhp_step cpuhp_hp_states[] = {\n\t[CPUHP_OFFLINE] = {\n\t\t.name\t\t\t= \"offline\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= NULL,\n\t},\n#ifdef CONFIG_SMP\n\t[CPUHP_CREATE_THREADS]= {\n\t\t.name\t\t\t= \"threads:prepare\",\n\t\t.startup.single\t\t= smpboot_create_threads,\n\t\t.teardown.single\t= NULL,\n\t\t.cant_stop\t\t= true,\n\t},\n\t[CPUHP_PERF_PREPARE] = {\n\t\t.name\t\t\t= \"perf:prepare\",\n\t\t.startup.single\t\t= perf_event_init_cpu,\n\t\t.teardown.single\t= perf_event_exit_cpu,\n\t},\n\t[CPUHP_WORKQUEUE_PREP] = {\n\t\t.name\t\t\t= \"workqueue:prepare\",\n\t\t.startup.single\t\t= workqueue_prepare_cpu,\n\t\t.teardown.single\t= NULL,\n\t},\n\t[CPUHP_HRTIMERS_PREPARE] = {\n\t\t.name\t\t\t= \"hrtimers:prepare\",\n\t\t.startup.single\t\t= hrtimers_prepare_cpu,\n\t\t.teardown.single\t= hrtimers_dead_cpu,\n\t},\n\t[CPUHP_SMPCFD_PREPARE] = {\n\t\t.name\t\t\t= \"smpcfd:prepare\",\n\t\t.startup.single\t\t= smpcfd_prepare_cpu,\n\t\t.teardown.single\t= smpcfd_dead_cpu,\n\t},\n\t[CPUHP_RELAY_PREPARE] = {\n\t\t.name\t\t\t= \"relay:prepare\",\n\t\t.startup.single\t\t= relay_prepare_cpu,\n\t\t.teardown.single\t= NULL,\n\t},\n\t[CPUHP_SLAB_PREPARE] = {\n\t\t.name\t\t\t= \"slab:prepare\",\n\t\t.startup.single\t\t= slab_prepare_cpu,\n\t\t.teardown.single\t= slab_dead_cpu,\n\t},\n\t[CPUHP_RCUTREE_PREP] = {\n\t\t.name\t\t\t= \"RCU/tree:prepare\",\n\t\t.startup.single\t\t= rcutree_prepare_cpu,\n\t\t.teardown.single\t= rcutree_dead_cpu,\n\t},\n\t/*\n\t * On the tear-down path, timers_dead_cpu() must be invoked\n\t * before blk_mq_queue_reinit_notify() from notify_dead(),\n\t * otherwise a RCU stall occurs.\n\t */\n\t[CPUHP_TIMERS_PREPARE] = {\n\t\t.name\t\t\t= \"timers:prepare\",\n\t\t.startup.single\t\t= timers_prepare_cpu,\n\t\t.teardown.single\t= timers_dead_cpu,\n\t},\n\t/* Kicks the plugged cpu into life */\n\t[CPUHP_BRINGUP_CPU] = {\n\t\t.name\t\t\t= \"cpu:bringup\",\n\t\t.startup.single\t\t= bringup_cpu,\n\t\t.teardown.single\t= finish_cpu,\n\t\t.cant_stop\t\t= true,\n\t},\n\t/* Final state before CPU kills itself */\n\t[CPUHP_AP_IDLE_DEAD] = {\n\t\t.name\t\t\t= \"idle:dead\",\n\t},\n\t/*\n\t * Last state before CPU enters the idle loop to die. Transient state\n\t * for synchronization.\n\t */\n\t[CPUHP_AP_OFFLINE] = {\n\t\t.name\t\t\t= \"ap:offline\",\n\t\t.cant_stop\t\t= true,\n\t},\n\t/* First state is scheduler control. Interrupts are disabled */\n\t[CPUHP_AP_SCHED_STARTING] = {\n\t\t.name\t\t\t= \"sched:starting\",\n\t\t.startup.single\t\t= sched_cpu_starting,\n\t\t.teardown.single\t= sched_cpu_dying,\n\t},\n\t[CPUHP_AP_RCUTREE_DYING] = {\n\t\t.name\t\t\t= \"RCU/tree:dying\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= rcutree_dying_cpu,\n\t},\n\t[CPUHP_AP_SMPCFD_DYING] = {\n\t\t.name\t\t\t= \"smpcfd:dying\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= smpcfd_dying_cpu,\n\t},\n\t/* Entry state on starting. Interrupts enabled from here on. Transient\n\t * state for synchronsization */\n\t[CPUHP_AP_ONLINE] = {\n\t\t.name\t\t\t= \"ap:online\",\n\t},\n\t/*\n\t * Handled on control processor until the plugged processor manages\n\t * this itself.\n\t */\n\t[CPUHP_TEARDOWN_CPU] = {\n\t\t.name\t\t\t= \"cpu:teardown\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= takedown_cpu,\n\t\t.cant_stop\t\t= true,\n\t},\n\n\t[CPUHP_AP_SCHED_WAIT_EMPTY] = {\n\t\t.name\t\t\t= \"sched:waitempty\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= sched_cpu_wait_empty,\n\t},\n\n\t/* Handle smpboot threads park/unpark */\n\t[CPUHP_AP_SMPBOOT_THREADS] = {\n\t\t.name\t\t\t= \"smpboot/threads:online\",\n\t\t.startup.single\t\t= smpboot_unpark_threads,\n\t\t.teardown.single\t= smpboot_park_threads,\n\t},\n\t[CPUHP_AP_IRQ_AFFINITY_ONLINE] = {\n\t\t.name\t\t\t= \"irq/affinity:online\",\n\t\t.startup.single\t\t= irq_affinity_online_cpu,\n\t\t.teardown.single\t= NULL,\n\t},\n\t[CPUHP_AP_PERF_ONLINE] = {\n\t\t.name\t\t\t= \"perf:online\",\n\t\t.startup.single\t\t= perf_event_init_cpu,\n\t\t.teardown.single\t= perf_event_exit_cpu,\n\t},\n\t[CPUHP_AP_WATCHDOG_ONLINE] = {\n\t\t.name\t\t\t= \"lockup_detector:online\",\n\t\t.startup.single\t\t= lockup_detector_online_cpu,\n\t\t.teardown.single\t= lockup_detector_offline_cpu,\n\t},\n\t[CPUHP_AP_WORKQUEUE_ONLINE] = {\n\t\t.name\t\t\t= \"workqueue:online\",\n\t\t.startup.single\t\t= workqueue_online_cpu,\n\t\t.teardown.single\t= workqueue_offline_cpu,\n\t},\n\t[CPUHP_AP_RCUTREE_ONLINE] = {\n\t\t.name\t\t\t= \"RCU/tree:online\",\n\t\t.startup.single\t\t= rcutree_online_cpu,\n\t\t.teardown.single\t= rcutree_offline_cpu,\n\t},\n#endif\n\t/*\n\t * The dynamically registered state space is here\n\t */\n\n#ifdef CONFIG_SMP\n\t/* Last state is scheduler control setting the cpu active */\n\t[CPUHP_AP_ACTIVE] = {\n\t\t.name\t\t\t= \"sched:active\",\n\t\t.startup.single\t\t= sched_cpu_activate,\n\t\t.teardown.single\t= sched_cpu_deactivate,\n\t},\n#endif\n\n\t/* CPU is fully up and running. */\n\t[CPUHP_ONLINE] = {\n\t\t.name\t\t\t= \"online\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= NULL,\n\t},\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\nstatic struct cpuhp_step cpuhp_hp_states[];\nstatic struct cpuhp_step cpuhp_hp_states[] = {\n\t[CPUHP_OFFLINE] = {\n\t\t.name\t\t\t= \"offline\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= NULL,\n\t},\n#ifdef CONFIG_SMP\n\t[CPUHP_CREATE_THREADS]= {\n\t\t.name\t\t\t= \"threads:prepare\",\n\t\t.startup.single\t\t= smpboot_create_threads,\n\t\t.teardown.single\t= NULL,\n\t\t.cant_stop\t\t= true,\n\t},\n\t[CPUHP_PERF_PREPARE] = {\n\t\t.name\t\t\t= \"perf:prepare\",\n\t\t.startup.single\t\t= perf_event_init_cpu,\n\t\t.teardown.single\t= perf_event_exit_cpu,\n\t},\n\t[CPUHP_WORKQUEUE_PREP] = {\n\t\t.name\t\t\t= \"workqueue:prepare\",\n\t\t.startup.single\t\t= workqueue_prepare_cpu,\n\t\t.teardown.single\t= NULL,\n\t},\n\t[CPUHP_HRTIMERS_PREPARE] = {\n\t\t.name\t\t\t= \"hrtimers:prepare\",\n\t\t.startup.single\t\t= hrtimers_prepare_cpu,\n\t\t.teardown.single\t= hrtimers_dead_cpu,\n\t},\n\t[CPUHP_SMPCFD_PREPARE] = {\n\t\t.name\t\t\t= \"smpcfd:prepare\",\n\t\t.startup.single\t\t= smpcfd_prepare_cpu,\n\t\t.teardown.single\t= smpcfd_dead_cpu,\n\t},\n\t[CPUHP_RELAY_PREPARE] = {\n\t\t.name\t\t\t= \"relay:prepare\",\n\t\t.startup.single\t\t= relay_prepare_cpu,\n\t\t.teardown.single\t= NULL,\n\t},\n\t[CPUHP_SLAB_PREPARE] = {\n\t\t.name\t\t\t= \"slab:prepare\",\n\t\t.startup.single\t\t= slab_prepare_cpu,\n\t\t.teardown.single\t= slab_dead_cpu,\n\t},\n\t[CPUHP_RCUTREE_PREP] = {\n\t\t.name\t\t\t= \"RCU/tree:prepare\",\n\t\t.startup.single\t\t= rcutree_prepare_cpu,\n\t\t.teardown.single\t= rcutree_dead_cpu,\n\t},\n\t/*\n\t * On the tear-down path, timers_dead_cpu() must be invoked\n\t * before blk_mq_queue_reinit_notify() from notify_dead(),\n\t * otherwise a RCU stall occurs.\n\t */\n\t[CPUHP_TIMERS_PREPARE] = {\n\t\t.name\t\t\t= \"timers:prepare\",\n\t\t.startup.single\t\t= timers_prepare_cpu,\n\t\t.teardown.single\t= timers_dead_cpu,\n\t},\n\t/* Kicks the plugged cpu into life */\n\t[CPUHP_BRINGUP_CPU] = {\n\t\t.name\t\t\t= \"cpu:bringup\",\n\t\t.startup.single\t\t= bringup_cpu,\n\t\t.teardown.single\t= finish_cpu,\n\t\t.cant_stop\t\t= true,\n\t},\n\t/* Final state before CPU kills itself */\n\t[CPUHP_AP_IDLE_DEAD] = {\n\t\t.name\t\t\t= \"idle:dead\",\n\t},\n\t/*\n\t * Last state before CPU enters the idle loop to die. Transient state\n\t * for synchronization.\n\t */\n\t[CPUHP_AP_OFFLINE] = {\n\t\t.name\t\t\t= \"ap:offline\",\n\t\t.cant_stop\t\t= true,\n\t},\n\t/* First state is scheduler control. Interrupts are disabled */\n\t[CPUHP_AP_SCHED_STARTING] = {\n\t\t.name\t\t\t= \"sched:starting\",\n\t\t.startup.single\t\t= sched_cpu_starting,\n\t\t.teardown.single\t= sched_cpu_dying,\n\t},\n\t[CPUHP_AP_RCUTREE_DYING] = {\n\t\t.name\t\t\t= \"RCU/tree:dying\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= rcutree_dying_cpu,\n\t},\n\t[CPUHP_AP_SMPCFD_DYING] = {\n\t\t.name\t\t\t= \"smpcfd:dying\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= smpcfd_dying_cpu,\n\t},\n\t/* Entry state on starting. Interrupts enabled from here on. Transient\n\t * state for synchronsization */\n\t[CPUHP_AP_ONLINE] = {\n\t\t.name\t\t\t= \"ap:online\",\n\t},\n\t/*\n\t * Handled on control processor until the plugged processor manages\n\t * this itself.\n\t */\n\t[CPUHP_TEARDOWN_CPU] = {\n\t\t.name\t\t\t= \"cpu:teardown\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= takedown_cpu,\n\t\t.cant_stop\t\t= true,\n\t},\n\n\t[CPUHP_AP_SCHED_WAIT_EMPTY] = {\n\t\t.name\t\t\t= \"sched:waitempty\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= sched_cpu_wait_empty,\n\t},\n\n\t/* Handle smpboot threads park/unpark */\n\t[CPUHP_AP_SMPBOOT_THREADS] = {\n\t\t.name\t\t\t= \"smpboot/threads:online\",\n\t\t.startup.single\t\t= smpboot_unpark_threads,\n\t\t.teardown.single\t= smpboot_park_threads,\n\t},\n\t[CPUHP_AP_IRQ_AFFINITY_ONLINE] = {\n\t\t.name\t\t\t= \"irq/affinity:online\",\n\t\t.startup.single\t\t= irq_affinity_online_cpu,\n\t\t.teardown.single\t= NULL,\n\t},\n\t[CPUHP_AP_PERF_ONLINE] = {\n\t\t.name\t\t\t= \"perf:online\",\n\t\t.startup.single\t\t= perf_event_init_cpu,\n\t\t.teardown.single\t= perf_event_exit_cpu,\n\t},\n\t[CPUHP_AP_WATCHDOG_ONLINE] = {\n\t\t.name\t\t\t= \"lockup_detector:online\",\n\t\t.startup.single\t\t= lockup_detector_online_cpu,\n\t\t.teardown.single\t= lockup_detector_offline_cpu,\n\t},\n\t[CPUHP_AP_WORKQUEUE_ONLINE] = {\n\t\t.name\t\t\t= \"workqueue:online\",\n\t\t.startup.single\t\t= workqueue_online_cpu,\n\t\t.teardown.single\t= workqueue_offline_cpu,\n\t},\n\t[CPUHP_AP_RCUTREE_ONLINE] = {\n\t\t.name\t\t\t= \"RCU/tree:online\",\n\t\t.startup.single\t\t= rcutree_online_cpu,\n\t\t.teardown.single\t= rcutree_offline_cpu,\n\t},\n#endif\n\t/*\n\t * The dynamically registered state space is here\n\t */\n\n#ifdef CONFIG_SMP\n\t/* Last state is scheduler control setting the cpu active */\n\t[CPUHP_AP_ACTIVE] = {\n\t\t.name\t\t\t= \"sched:active\",\n\t\t.startup.single\t\t= sched_cpu_activate,\n\t\t.teardown.single\t= sched_cpu_deactivate,\n\t},\n#endif\n\n\t/* CPU is fully up and running. */\n\t[CPUHP_ONLINE] = {\n\t\t.name\t\t\t= \"online\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= NULL,\n\t},\n};\n\nstatic struct cpuhp_step *cpuhp_get_step(enum cpuhp_state state)\n{\n\treturn cpuhp_hp_states + state;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\n\nstatic int cpuhp_down_callbacks(unsigned int cpu, struct cpuhp_cpu_state *st,\n\t\t\t\tenum cpuhp_state target)\n{\n\tenum cpuhp_state prev_state = st->state;\n\tint ret = 0;\n\n\tret = cpuhp_invoke_callback_range(false, cpu, st, target);\n\tif (ret) {\n\t\tpr_debug(\"CPU DOWN failed (%d) CPU %u state %s (%d)\\n\",\n\t\t\t ret, cpu, cpuhp_get_step(st->state)->name,\n\t\t\t st->state);\n\n\t\tcpuhp_reset_state(st, prev_state);\n\n\t\tif (st->state < prev_state)\n\t\t\tWARN_ON(cpuhp_invoke_callback_range(true, cpu, st,\n\t\t\t\t\t\t\t    prev_state));\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "cpuhp_report_idle_dead",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
    "lines": "1082-1095",
    "snippet": "void cpuhp_report_idle_dead(void)\n{\n\tstruct cpuhp_cpu_state *st = this_cpu_ptr(&cpuhp_state);\n\n\tBUG_ON(st->state != CPUHP_AP_OFFLINE);\n\trcu_report_dead(smp_processor_id());\n\tst->state = CPUHP_AP_IDLE_DEAD;\n\t/*\n\t * We cannot call complete after rcu_report_dead() so we delegate it\n\t * to an online cpu.\n\t */\n\tsmp_call_function_single(cpumask_first(cpu_online_mask),\n\t\t\t\t cpuhp_complete_idle_dead, st, 0);\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/scs.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sched/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "smp_call_function_single",
          "args": [
            "cpumask_first(cpu_online_mask)",
            "cpuhp_complete_idle_dead",
            "st",
            "0"
          ],
          "line": 1093
        },
        "resolved": true,
        "details": {
          "function_name": "smp_call_function_single",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/up.c",
          "lines": "12-25",
          "snippet": "int smp_call_function_single(int cpu, void (*func) (void *info), void *info,\n\t\t\t\tint wait)\n{\n\tunsigned long flags;\n\n\tif (cpu != 0)\n\t\treturn -ENXIO;\n\n\tlocal_irq_save(flags);\n\tfunc(info);\n\tlocal_irq_restore(flags);\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/hypervisor.h>",
            "#include <linux/smp.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hypervisor.h>\n#include <linux/smp.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n\nint smp_call_function_single(int cpu, void (*func) (void *info), void *info,\n\t\t\t\tint wait)\n{\n\tunsigned long flags;\n\n\tif (cpu != 0)\n\t\treturn -ENXIO;\n\n\tlocal_irq_save(flags);\n\tfunc(info);\n\tlocal_irq_restore(flags);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_first",
          "args": [
            "cpu_online_mask"
          ],
          "line": 1093
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_report_dead",
          "args": [
            "smp_processor_id()"
          ],
          "line": 1087
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_report_dead",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "4327-4363",
          "snippet": "void rcu_report_dead(unsigned int cpu)\n{\n\tunsigned long flags;\n\tunsigned long mask;\n\tstruct rcu_data *rdp = per_cpu_ptr(&rcu_data, cpu);\n\tstruct rcu_node *rnp = rdp->mynode;  /* Outgoing CPU's rdp & rnp. */\n\n\t// Do any dangling deferred wakeups.\n\tdo_nocb_deferred_wakeup(rdp);\n\n\t/* QS for any half-done expedited grace period. */\n\trcu_report_exp_rdp(rdp);\n\trcu_preempt_deferred_qs(current);\n\n\t/* Remove outgoing CPU from mask in the leaf rcu_node structure. */\n\tmask = rdp->grpmask;\n\tWRITE_ONCE(rnp->ofl_seq, rnp->ofl_seq + 1);\n\tWARN_ON_ONCE(!(rnp->ofl_seq & 0x1));\n\tsmp_mb(); // Pair with rcu_gp_cleanup()'s ->ofl_seq barrier().\n\traw_spin_lock(&rcu_state.ofl_lock);\n\traw_spin_lock_irqsave_rcu_node(rnp, flags); /* Enforce GP memory-order guarantee. */\n\trdp->rcu_ofl_gp_seq = READ_ONCE(rcu_state.gp_seq);\n\trdp->rcu_ofl_gp_flags = READ_ONCE(rcu_state.gp_flags);\n\tif (rnp->qsmask & mask) { /* RCU waiting on outgoing CPU? */\n\t\t/* Report quiescent state -before- changing ->qsmaskinitnext! */\n\t\trcu_report_qs_rnp(mask, rnp, rnp->gp_seq, flags);\n\t\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\t}\n\tWRITE_ONCE(rnp->qsmaskinitnext, rnp->qsmaskinitnext & ~mask);\n\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\traw_spin_unlock(&rcu_state.ofl_lock);\n\tsmp_mb(); // Pair with rcu_gp_cleanup()'s ->ofl_seq barrier().\n\tWRITE_ONCE(rnp->ofl_seq, rnp->ofl_seq + 1);\n\tWARN_ON_ONCE(rnp->ofl_seq & 0x1);\n\n\trdp->cpu_started = false;\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};",
            "static struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};",
            "static void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);",
            "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
            "static void sync_sched_exp_online_cleanup(int cpu);",
            "static void check_cb_ovld_locked(struct rcu_data *rdp, struct rcu_node *rnp);",
            "static bool rcu_rdp_is_offloaded(struct rcu_data *rdp);",
            "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};\nstatic struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\nstatic void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void sync_sched_exp_online_cleanup(int cpu);\nstatic void check_cb_ovld_locked(struct rcu_data *rdp, struct rcu_node *rnp);\nstatic bool rcu_rdp_is_offloaded(struct rcu_data *rdp);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nvoid rcu_report_dead(unsigned int cpu)\n{\n\tunsigned long flags;\n\tunsigned long mask;\n\tstruct rcu_data *rdp = per_cpu_ptr(&rcu_data, cpu);\n\tstruct rcu_node *rnp = rdp->mynode;  /* Outgoing CPU's rdp & rnp. */\n\n\t// Do any dangling deferred wakeups.\n\tdo_nocb_deferred_wakeup(rdp);\n\n\t/* QS for any half-done expedited grace period. */\n\trcu_report_exp_rdp(rdp);\n\trcu_preempt_deferred_qs(current);\n\n\t/* Remove outgoing CPU from mask in the leaf rcu_node structure. */\n\tmask = rdp->grpmask;\n\tWRITE_ONCE(rnp->ofl_seq, rnp->ofl_seq + 1);\n\tWARN_ON_ONCE(!(rnp->ofl_seq & 0x1));\n\tsmp_mb(); // Pair with rcu_gp_cleanup()'s ->ofl_seq barrier().\n\traw_spin_lock(&rcu_state.ofl_lock);\n\traw_spin_lock_irqsave_rcu_node(rnp, flags); /* Enforce GP memory-order guarantee. */\n\trdp->rcu_ofl_gp_seq = READ_ONCE(rcu_state.gp_seq);\n\trdp->rcu_ofl_gp_flags = READ_ONCE(rcu_state.gp_flags);\n\tif (rnp->qsmask & mask) { /* RCU waiting on outgoing CPU? */\n\t\t/* Report quiescent state -before- changing ->qsmaskinitnext! */\n\t\trcu_report_qs_rnp(mask, rnp, rnp->gp_seq, flags);\n\t\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\t}\n\tWRITE_ONCE(rnp->qsmaskinitnext, rnp->qsmaskinitnext & ~mask);\n\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\traw_spin_unlock(&rcu_state.ofl_lock);\n\tsmp_mb(); // Pair with rcu_gp_cleanup()'s ->ofl_seq barrier().\n\tWRITE_ONCE(rnp->ofl_seq, rnp->ofl_seq + 1);\n\tWARN_ON_ONCE(rnp->ofl_seq & 0x1);\n\n\trdp->cpu_started = false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 1087
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "st->state != CPUHP_AP_OFFLINE"
          ],
          "line": 1086
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&cpuhp_state"
          ],
          "line": 1084
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\n\nvoid cpuhp_report_idle_dead(void)\n{\n\tstruct cpuhp_cpu_state *st = this_cpu_ptr(&cpuhp_state);\n\n\tBUG_ON(st->state != CPUHP_AP_OFFLINE);\n\trcu_report_dead(smp_processor_id());\n\tst->state = CPUHP_AP_IDLE_DEAD;\n\t/*\n\t * We cannot call complete after rcu_report_dead() so we delegate it\n\t * to an online cpu.\n\t */\n\tsmp_call_function_single(cpumask_first(cpu_online_mask),\n\t\t\t\t cpuhp_complete_idle_dead, st, 0);\n}"
  },
  {
    "function_name": "cpuhp_complete_idle_dead",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
    "lines": "1075-1080",
    "snippet": "static void cpuhp_complete_idle_dead(void *arg)\n{\n\tstruct cpuhp_cpu_state *st = arg;\n\n\tcomplete_ap_thread(st, false);\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/scs.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sched/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "complete_ap_thread",
          "args": [
            "st",
            "false"
          ],
          "line": 1079
        },
        "resolved": true,
        "details": {
          "function_name": "complete_ap_thread",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "264-268",
          "snippet": "static inline void complete_ap_thread(struct cpuhp_cpu_state *st, bool bringup)\n{\n\tstruct completion *done = bringup ? &st->done_up : &st->done_down;\n\tcomplete(done);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstatic inline void complete_ap_thread(struct cpuhp_cpu_state *st, bool bringup)\n{\n\tstruct completion *done = bringup ? &st->done_up : &st->done_down;\n\tcomplete(done);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstatic void cpuhp_complete_idle_dead(void *arg)\n{\n\tstruct cpuhp_cpu_state *st = arg;\n\n\tcomplete_ap_thread(st, false);\n}"
  },
  {
    "function_name": "takedown_cpu",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
    "lines": "1026-1073",
    "snippet": "static int takedown_cpu(unsigned int cpu)\n{\n\tstruct cpuhp_cpu_state *st = per_cpu_ptr(&cpuhp_state, cpu);\n\tint err;\n\n\t/* Park the smpboot threads */\n\tkthread_park(st->thread);\n\n\t/*\n\t * Prevent irq alloc/free while the dying cpu reorganizes the\n\t * interrupt affinities.\n\t */\n\tirq_lock_sparse();\n\n\t/*\n\t * So now all preempt/rcu users must observe !cpu_active().\n\t */\n\terr = stop_machine_cpuslocked(take_cpu_down, NULL, cpumask_of(cpu));\n\tif (err) {\n\t\t/* CPU refused to die */\n\t\tirq_unlock_sparse();\n\t\t/* Unpark the hotplug thread so we can rollback there */\n\t\tkthread_unpark(st->thread);\n\t\treturn err;\n\t}\n\tBUG_ON(cpu_online(cpu));\n\n\t/*\n\t * The teardown callback for CPUHP_AP_SCHED_STARTING will have removed\n\t * all runnable tasks from the CPU, there's only the idle task left now\n\t * that the migration thread is done doing the stop_machine thing.\n\t *\n\t * Wait for the stop thread to go away.\n\t */\n\twait_for_ap_thread(st, false);\n\tBUG_ON(st->state != CPUHP_AP_IDLE_DEAD);\n\n\t/* Interrupts are moved away from the dying cpu, reenable alloc/free */\n\tirq_unlock_sparse();\n\n\thotplug_cpu__broadcast_tick_pull(cpu);\n\t/* This actually kills the CPU. */\n\t__cpu_die(cpu);\n\n\ttick_cleanup_dead_cpu(cpu);\n\trcutree_migrate_callbacks(cpu);\n\treturn 0;\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/scs.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sched/mm.h>"
    ],
    "macros_used": [
      "#define takedown_cpu\t\tNULL"
    ],
    "globals_used": [
      "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcutree_migrate_callbacks",
          "args": [
            "cpu"
          ],
          "line": 1071
        },
        "resolved": true,
        "details": {
          "function_name": "rcutree_migrate_callbacks",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "4371-4412",
          "snippet": "void rcutree_migrate_callbacks(int cpu)\n{\n\tunsigned long flags;\n\tstruct rcu_data *my_rdp;\n\tstruct rcu_node *my_rnp;\n\tstruct rcu_data *rdp = per_cpu_ptr(&rcu_data, cpu);\n\tbool needwake;\n\n\tif (rcu_rdp_is_offloaded(rdp) ||\n\t    rcu_segcblist_empty(&rdp->cblist))\n\t\treturn;  /* No callbacks to migrate. */\n\n\tlocal_irq_save(flags);\n\tmy_rdp = this_cpu_ptr(&rcu_data);\n\tmy_rnp = my_rdp->mynode;\n\trcu_nocb_lock(my_rdp); /* irqs already disabled. */\n\tWARN_ON_ONCE(!rcu_nocb_flush_bypass(my_rdp, NULL, jiffies));\n\traw_spin_lock_rcu_node(my_rnp); /* irqs already disabled. */\n\t/* Leverage recent GPs and set GP for new callbacks. */\n\tneedwake = rcu_advance_cbs(my_rnp, rdp) ||\n\t\t   rcu_advance_cbs(my_rnp, my_rdp);\n\trcu_segcblist_merge(&my_rdp->cblist, &rdp->cblist);\n\tneedwake = needwake || rcu_advance_cbs(my_rnp, my_rdp);\n\trcu_segcblist_disable(&rdp->cblist);\n\tWARN_ON_ONCE(rcu_segcblist_empty(&my_rdp->cblist) !=\n\t\t     !rcu_segcblist_n_cbs(&my_rdp->cblist));\n\tif (rcu_rdp_is_offloaded(my_rdp)) {\n\t\traw_spin_unlock_rcu_node(my_rnp); /* irqs remain disabled. */\n\t\t__call_rcu_nocb_wake(my_rdp, true, flags);\n\t} else {\n\t\trcu_nocb_unlock(my_rdp); /* irqs remain disabled. */\n\t\traw_spin_unlock_irqrestore_rcu_node(my_rnp, flags);\n\t}\n\tif (needwake)\n\t\trcu_gp_kthread_wake();\n\tlockdep_assert_irqs_enabled();\n\tWARN_ONCE(rcu_segcblist_n_cbs(&rdp->cblist) != 0 ||\n\t\t  !rcu_segcblist_empty(&rdp->cblist),\n\t\t  \"rcu_cleanup_dead_cpu: Callbacks on offline CPU %d: qlen=%lu, 1stCB=%p\\n\",\n\t\t  cpu, rcu_segcblist_n_cbs(&rdp->cblist),\n\t\t  rcu_segcblist_first_cb(&rdp->cblist));\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};",
            "static void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);",
            "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
            "static void sync_sched_exp_online_cleanup(int cpu);",
            "static bool rcu_rdp_is_offloaded(struct rcu_data *rdp);",
            "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};\nstatic void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void sync_sched_exp_online_cleanup(int cpu);\nstatic bool rcu_rdp_is_offloaded(struct rcu_data *rdp);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nvoid rcutree_migrate_callbacks(int cpu)\n{\n\tunsigned long flags;\n\tstruct rcu_data *my_rdp;\n\tstruct rcu_node *my_rnp;\n\tstruct rcu_data *rdp = per_cpu_ptr(&rcu_data, cpu);\n\tbool needwake;\n\n\tif (rcu_rdp_is_offloaded(rdp) ||\n\t    rcu_segcblist_empty(&rdp->cblist))\n\t\treturn;  /* No callbacks to migrate. */\n\n\tlocal_irq_save(flags);\n\tmy_rdp = this_cpu_ptr(&rcu_data);\n\tmy_rnp = my_rdp->mynode;\n\trcu_nocb_lock(my_rdp); /* irqs already disabled. */\n\tWARN_ON_ONCE(!rcu_nocb_flush_bypass(my_rdp, NULL, jiffies));\n\traw_spin_lock_rcu_node(my_rnp); /* irqs already disabled. */\n\t/* Leverage recent GPs and set GP for new callbacks. */\n\tneedwake = rcu_advance_cbs(my_rnp, rdp) ||\n\t\t   rcu_advance_cbs(my_rnp, my_rdp);\n\trcu_segcblist_merge(&my_rdp->cblist, &rdp->cblist);\n\tneedwake = needwake || rcu_advance_cbs(my_rnp, my_rdp);\n\trcu_segcblist_disable(&rdp->cblist);\n\tWARN_ON_ONCE(rcu_segcblist_empty(&my_rdp->cblist) !=\n\t\t     !rcu_segcblist_n_cbs(&my_rdp->cblist));\n\tif (rcu_rdp_is_offloaded(my_rdp)) {\n\t\traw_spin_unlock_rcu_node(my_rnp); /* irqs remain disabled. */\n\t\t__call_rcu_nocb_wake(my_rdp, true, flags);\n\t} else {\n\t\trcu_nocb_unlock(my_rdp); /* irqs remain disabled. */\n\t\traw_spin_unlock_irqrestore_rcu_node(my_rnp, flags);\n\t}\n\tif (needwake)\n\t\trcu_gp_kthread_wake();\n\tlockdep_assert_irqs_enabled();\n\tWARN_ONCE(rcu_segcblist_n_cbs(&rdp->cblist) != 0 ||\n\t\t  !rcu_segcblist_empty(&rdp->cblist),\n\t\t  \"rcu_cleanup_dead_cpu: Callbacks on offline CPU %d: qlen=%lu, 1stCB=%p\\n\",\n\t\t  cpu, rcu_segcblist_n_cbs(&rdp->cblist),\n\t\t  rcu_segcblist_first_cb(&rdp->cblist));\n}"
        }
      },
      {
        "call_info": {
          "callee": "tick_cleanup_dead_cpu",
          "args": [
            "cpu"
          ],
          "line": 1070
        },
        "resolved": true,
        "details": {
          "function_name": "tick_cleanup_dead_cpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clockevents.c",
          "lines": "632-658",
          "snippet": "void tick_cleanup_dead_cpu(int cpu)\n{\n\tstruct clock_event_device *dev, *tmp;\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&clockevents_lock, flags);\n\n\ttick_shutdown(cpu);\n\t/*\n\t * Unregister the clock event devices which were\n\t * released from the users in the notify chain.\n\t */\n\tlist_for_each_entry_safe(dev, tmp, &clockevents_released, list)\n\t\tlist_del(&dev->list);\n\t/*\n\t * Now check whether the CPU has left unused per cpu devices\n\t */\n\tlist_for_each_entry_safe(dev, tmp, &clockevent_devices, list) {\n\t\tif (cpumask_test_cpu(cpu, dev->cpumask) &&\n\t\t    cpumask_weight(dev->cpumask) == 1 &&\n\t\t    !tick_is_broadcast_device(dev)) {\n\t\t\tBUG_ON(!clockevent_state_detached(dev));\n\t\t\tlist_del(&dev->list);\n\t\t}\n\t}\n\traw_spin_unlock_irqrestore(&clockevents_lock, flags);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/smp.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/clockchips.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(clockevent_devices);",
            "static LIST_HEAD(clockevents_released);",
            "static DEFINE_RAW_SPINLOCK(clockevents_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/device.h>\n#include <linux/smp.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/hrtimer.h>\n#include <linux/clockchips.h>\n\nstatic LIST_HEAD(clockevent_devices);\nstatic LIST_HEAD(clockevents_released);\nstatic DEFINE_RAW_SPINLOCK(clockevents_lock);\n\nvoid tick_cleanup_dead_cpu(int cpu)\n{\n\tstruct clock_event_device *dev, *tmp;\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&clockevents_lock, flags);\n\n\ttick_shutdown(cpu);\n\t/*\n\t * Unregister the clock event devices which were\n\t * released from the users in the notify chain.\n\t */\n\tlist_for_each_entry_safe(dev, tmp, &clockevents_released, list)\n\t\tlist_del(&dev->list);\n\t/*\n\t * Now check whether the CPU has left unused per cpu devices\n\t */\n\tlist_for_each_entry_safe(dev, tmp, &clockevent_devices, list) {\n\t\tif (cpumask_test_cpu(cpu, dev->cpumask) &&\n\t\t    cpumask_weight(dev->cpumask) == 1 &&\n\t\t    !tick_is_broadcast_device(dev)) {\n\t\t\tBUG_ON(!clockevent_state_detached(dev));\n\t\t\tlist_del(&dev->list);\n\t\t}\n\t}\n\traw_spin_unlock_irqrestore(&clockevents_lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__cpu_die",
          "args": [
            "cpu"
          ],
          "line": 1068
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hotplug_cpu__broadcast_tick_pull",
          "args": [
            "cpu"
          ],
          "line": 1066
        },
        "resolved": true,
        "details": {
          "function_name": "hotplug_cpu__broadcast_tick_pull",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-broadcast.c",
          "lines": "1082-1095",
          "snippet": "void hotplug_cpu__broadcast_tick_pull(int deadcpu)\n{\n\tstruct clock_event_device *bc;\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&tick_broadcast_lock, flags);\n\tbc = tick_broadcast_device.evtdev;\n\n\tif (bc && broadcast_needs_cpu(bc, deadcpu)) {\n\t\t/* This moves the broadcast assignment to this CPU: */\n\t\tclockevents_program_event(bc, bc->next_event, 1);\n\t}\n\traw_spin_unlock_irqrestore(&tick_broadcast_lock, flags);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/profile.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct tick_device tick_broadcast_device;",
            "static __cacheline_aligned_in_smp DEFINE_RAW_SPINLOCK(tick_broadcast_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/module.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic struct tick_device tick_broadcast_device;\nstatic __cacheline_aligned_in_smp DEFINE_RAW_SPINLOCK(tick_broadcast_lock);\n\nvoid hotplug_cpu__broadcast_tick_pull(int deadcpu)\n{\n\tstruct clock_event_device *bc;\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&tick_broadcast_lock, flags);\n\tbc = tick_broadcast_device.evtdev;\n\n\tif (bc && broadcast_needs_cpu(bc, deadcpu)) {\n\t\t/* This moves the broadcast assignment to this CPU: */\n\t\tclockevents_program_event(bc, bc->next_event, 1);\n\t}\n\traw_spin_unlock_irqrestore(&tick_broadcast_lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_unlock_sparse",
          "args": [],
          "line": 1064
        },
        "resolved": true,
        "details": {
          "function_name": "irq_unlock_sparse",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/irqdesc.c",
          "lines": "384-387",
          "snippet": "void irq_unlock_sparse(void)\n{\n\tmutex_unlock(&sparse_irq_lock);\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/sysfs.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(sparse_irq_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/sysfs.h>\n#include <linux/irqdomain.h>\n#include <linux/bitmap.h>\n#include <linux/radix-tree.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/irq.h>\n\nstatic DEFINE_MUTEX(sparse_irq_lock);\n\nvoid irq_unlock_sparse(void)\n{\n\tmutex_unlock(&sparse_irq_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "st->state != CPUHP_AP_IDLE_DEAD"
          ],
          "line": 1061
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_for_ap_thread",
          "args": [
            "st",
            "false"
          ],
          "line": 1060
        },
        "resolved": true,
        "details": {
          "function_name": "wait_for_ap_thread",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "258-262",
          "snippet": "static inline void wait_for_ap_thread(struct cpuhp_cpu_state *st, bool bringup)\n{\n\tstruct completion *done = bringup ? &st->done_up : &st->done_down;\n\twait_for_completion(done);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstatic inline void wait_for_ap_thread(struct cpuhp_cpu_state *st, bool bringup)\n{\n\tstruct completion *done = bringup ? &st->done_up : &st->done_down;\n\twait_for_completion(done);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "cpu_online(cpu)"
          ],
          "line": 1051
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_online",
          "args": [
            "cpu"
          ],
          "line": 1051
        },
        "resolved": true,
        "details": {
          "function_name": "init_cpu_online",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "2616-2619",
          "snippet": "void init_cpu_online(const struct cpumask *src)\n{\n\tcpumask_copy(&__cpu_online_mask, src);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct cpumask __cpu_online_mask"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstruct cpumask __cpu_online_mask;\n\nvoid init_cpu_online(const struct cpumask *src)\n{\n\tcpumask_copy(&__cpu_online_mask, src);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kthread_unpark",
          "args": [
            "st->thread"
          ],
          "line": 1048
        },
        "resolved": true,
        "details": {
          "function_name": "kthread_unpark",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
          "lines": "622-638",
          "snippet": "void kthread_unpark(struct task_struct *k)\n{\n\tstruct kthread *kthread = to_kthread(k);\n\n\t/*\n\t * Newly created kthread was parked when the CPU was offline.\n\t * The binding was lost and we need to set it again.\n\t */\n\tif (test_bit(KTHREAD_IS_PER_CPU, &kthread->flags))\n\t\t__kthread_bind(k, kthread->cpu, TASK_PARKED);\n\n\tclear_bit(KTHREAD_SHOULD_PARK, &kthread->flags);\n\t/*\n\t * __kthread_parkme() will either see !SHOULD_PARK or get the wakeup.\n\t */\n\twake_up_state(k, TASK_PARKED);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/numa.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mm.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nvoid kthread_unpark(struct task_struct *k)\n{\n\tstruct kthread *kthread = to_kthread(k);\n\n\t/*\n\t * Newly created kthread was parked when the CPU was offline.\n\t * The binding was lost and we need to set it again.\n\t */\n\tif (test_bit(KTHREAD_IS_PER_CPU, &kthread->flags))\n\t\t__kthread_bind(k, kthread->cpu, TASK_PARKED);\n\n\tclear_bit(KTHREAD_SHOULD_PARK, &kthread->flags);\n\t/*\n\t * __kthread_parkme() will either see !SHOULD_PARK or get the wakeup.\n\t */\n\twake_up_state(k, TASK_PARKED);\n}"
        }
      },
      {
        "call_info": {
          "callee": "stop_machine_cpuslocked",
          "args": [
            "take_cpu_down",
            "NULL",
            "cpumask_of(cpu)"
          ],
          "line": 1043
        },
        "resolved": true,
        "details": {
          "function_name": "stop_machine_cpuslocked",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/stop_machine.c",
          "lines": "588-622",
          "snippet": "int stop_machine_cpuslocked(cpu_stop_fn_t fn, void *data,\n\t\t\t    const struct cpumask *cpus)\n{\n\tstruct multi_stop_data msdata = {\n\t\t.fn = fn,\n\t\t.data = data,\n\t\t.num_threads = num_online_cpus(),\n\t\t.active_cpus = cpus,\n\t};\n\n\tlockdep_assert_cpus_held();\n\n\tif (!stop_machine_initialized) {\n\t\t/*\n\t\t * Handle the case where stop_machine() is called\n\t\t * early in boot before stop_machine() has been\n\t\t * initialized.\n\t\t */\n\t\tunsigned long flags;\n\t\tint ret;\n\n\t\tWARN_ON_ONCE(msdata.num_threads != 1);\n\n\t\tlocal_irq_save(flags);\n\t\thard_irq_disable();\n\t\tret = (*fn)(data);\n\t\tlocal_irq_restore(flags);\n\n\t\treturn ret;\n\t}\n\n\t/* Set the initial state and stop all online cpus. */\n\tset_state(&msdata, MULTI_STOP_PREPARE);\n\treturn stop_cpus(cpu_online_mask, multi_cpu_stop, &msdata);\n}",
          "includes": [
            "#include <linux/sched/wake_q.h>",
            "#include <linux/nmi.h>",
            "#include <linux/atomic.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/sched.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/kthread.h>",
            "#include <linux/init.h>",
            "#include <linux/cpu.h>",
            "#include <linux/completion.h>",
            "#include <linux/compiler.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool stop_machine_initialized = false;",
            "extern void sched_set_stop_task(int cpu, struct task_struct *stop);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/wake_q.h>\n#include <linux/nmi.h>\n#include <linux/atomic.h>\n#include <linux/smpboot.h>\n#include <linux/kallsyms.h>\n#include <linux/interrupt.h>\n#include <linux/stop_machine.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kthread.h>\n#include <linux/init.h>\n#include <linux/cpu.h>\n#include <linux/completion.h>\n#include <linux/compiler.h>\n\nstatic bool stop_machine_initialized = false;\nextern void sched_set_stop_task(int cpu, struct task_struct *stop);\n\nint stop_machine_cpuslocked(cpu_stop_fn_t fn, void *data,\n\t\t\t    const struct cpumask *cpus)\n{\n\tstruct multi_stop_data msdata = {\n\t\t.fn = fn,\n\t\t.data = data,\n\t\t.num_threads = num_online_cpus(),\n\t\t.active_cpus = cpus,\n\t};\n\n\tlockdep_assert_cpus_held();\n\n\tif (!stop_machine_initialized) {\n\t\t/*\n\t\t * Handle the case where stop_machine() is called\n\t\t * early in boot before stop_machine() has been\n\t\t * initialized.\n\t\t */\n\t\tunsigned long flags;\n\t\tint ret;\n\n\t\tWARN_ON_ONCE(msdata.num_threads != 1);\n\n\t\tlocal_irq_save(flags);\n\t\thard_irq_disable();\n\t\tret = (*fn)(data);\n\t\tlocal_irq_restore(flags);\n\n\t\treturn ret;\n\t}\n\n\t/* Set the initial state and stop all online cpus. */\n\tset_state(&msdata, MULTI_STOP_PREPARE);\n\treturn stop_cpus(cpu_online_mask, multi_cpu_stop, &msdata);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_of",
          "args": [
            "cpu"
          ],
          "line": 1043
        },
        "resolved": true,
        "details": {
          "function_name": "cpumask_of_bp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/hw_breakpoint.c",
          "lines": "121-126",
          "snippet": "static const struct cpumask *cpumask_of_bp(struct perf_event *bp)\n{\n\tif (bp->cpu >= 0)\n\t\treturn cpumask_of(bp->cpu);\n\treturn cpu_possible_mask;\n}",
          "includes": [
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/bug.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/irqflags.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hw_breakpoint.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/irqflags.h>\n\nstatic const struct cpumask *cpumask_of_bp(struct perf_event *bp)\n{\n\tif (bp->cpu >= 0)\n\t\treturn cpumask_of(bp->cpu);\n\treturn cpu_possible_mask;\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_lock_sparse",
          "args": [],
          "line": 1038
        },
        "resolved": true,
        "details": {
          "function_name": "irq_lock_sparse",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/irqdesc.c",
          "lines": "379-382",
          "snippet": "void irq_lock_sparse(void)\n{\n\tmutex_lock(&sparse_irq_lock);\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/sysfs.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(sparse_irq_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/sysfs.h>\n#include <linux/irqdomain.h>\n#include <linux/bitmap.h>\n#include <linux/radix-tree.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/irq.h>\n\nstatic DEFINE_MUTEX(sparse_irq_lock);\n\nvoid irq_lock_sparse(void)\n{\n\tmutex_lock(&sparse_irq_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kthread_park",
          "args": [
            "st->thread"
          ],
          "line": 1032
        },
        "resolved": true,
        "details": {
          "function_name": "kthread_park",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
          "lines": "653-679",
          "snippet": "int kthread_park(struct task_struct *k)\n{\n\tstruct kthread *kthread = to_kthread(k);\n\n\tif (WARN_ON(k->flags & PF_EXITING))\n\t\treturn -ENOSYS;\n\n\tif (WARN_ON_ONCE(test_bit(KTHREAD_SHOULD_PARK, &kthread->flags)))\n\t\treturn -EBUSY;\n\n\tset_bit(KTHREAD_SHOULD_PARK, &kthread->flags);\n\tif (k != current) {\n\t\twake_up_process(k);\n\t\t/*\n\t\t * Wait for __kthread_parkme() to complete(), this means we\n\t\t * _will_ have TASK_PARKED and are about to call schedule().\n\t\t */\n\t\twait_for_completion(&kthread->parked);\n\t\t/*\n\t\t * Now wait for that schedule() to complete and the task to\n\t\t * get scheduled out.\n\t\t */\n\t\tWARN_ON_ONCE(!wait_task_inactive(k, TASK_PARKED));\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/numa.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mm.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct task_struct *task;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nstruct task_struct *task;\n\nint kthread_park(struct task_struct *k)\n{\n\tstruct kthread *kthread = to_kthread(k);\n\n\tif (WARN_ON(k->flags & PF_EXITING))\n\t\treturn -ENOSYS;\n\n\tif (WARN_ON_ONCE(test_bit(KTHREAD_SHOULD_PARK, &kthread->flags)))\n\t\treturn -EBUSY;\n\n\tset_bit(KTHREAD_SHOULD_PARK, &kthread->flags);\n\tif (k != current) {\n\t\twake_up_process(k);\n\t\t/*\n\t\t * Wait for __kthread_parkme() to complete(), this means we\n\t\t * _will_ have TASK_PARKED and are about to call schedule().\n\t\t */\n\t\twait_for_completion(&kthread->parked);\n\t\t/*\n\t\t * Now wait for that schedule() to complete and the task to\n\t\t * get scheduled out.\n\t\t */\n\t\tWARN_ON_ONCE(!wait_task_inactive(k, TASK_PARKED));\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "&cpuhp_state",
            "cpu"
          ],
          "line": 1028
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\n#define takedown_cpu\t\tNULL\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\n\nstatic int takedown_cpu(unsigned int cpu)\n{\n\tstruct cpuhp_cpu_state *st = per_cpu_ptr(&cpuhp_state, cpu);\n\tint err;\n\n\t/* Park the smpboot threads */\n\tkthread_park(st->thread);\n\n\t/*\n\t * Prevent irq alloc/free while the dying cpu reorganizes the\n\t * interrupt affinities.\n\t */\n\tirq_lock_sparse();\n\n\t/*\n\t * So now all preempt/rcu users must observe !cpu_active().\n\t */\n\terr = stop_machine_cpuslocked(take_cpu_down, NULL, cpumask_of(cpu));\n\tif (err) {\n\t\t/* CPU refused to die */\n\t\tirq_unlock_sparse();\n\t\t/* Unpark the hotplug thread so we can rollback there */\n\t\tkthread_unpark(st->thread);\n\t\treturn err;\n\t}\n\tBUG_ON(cpu_online(cpu));\n\n\t/*\n\t * The teardown callback for CPUHP_AP_SCHED_STARTING will have removed\n\t * all runnable tasks from the CPU, there's only the idle task left now\n\t * that the migration thread is done doing the stop_machine thing.\n\t *\n\t * Wait for the stop thread to go away.\n\t */\n\twait_for_ap_thread(st, false);\n\tBUG_ON(st->state != CPUHP_AP_IDLE_DEAD);\n\n\t/* Interrupts are moved away from the dying cpu, reenable alloc/free */\n\tirq_unlock_sparse();\n\n\thotplug_cpu__broadcast_tick_pull(cpu);\n\t/* This actually kills the CPU. */\n\t__cpu_die(cpu);\n\n\ttick_cleanup_dead_cpu(cpu);\n\trcutree_migrate_callbacks(cpu);\n\treturn 0;\n}"
  },
  {
    "function_name": "take_cpu_down",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
    "lines": "991-1024",
    "snippet": "static int take_cpu_down(void *_param)\n{\n\tstruct cpuhp_cpu_state *st = this_cpu_ptr(&cpuhp_state);\n\tenum cpuhp_state target = max((int)st->target, CPUHP_AP_OFFLINE);\n\tint err, cpu = smp_processor_id();\n\tint ret;\n\n\t/* Ensure this CPU doesn't handle any more interrupts. */\n\terr = __cpu_disable();\n\tif (err < 0)\n\t\treturn err;\n\n\t/*\n\t * Must be called from CPUHP_TEARDOWN_CPU, which means, as we are going\n\t * down, that the current state is CPUHP_TEARDOWN_CPU - 1.\n\t */\n\tWARN_ON(st->state != (CPUHP_TEARDOWN_CPU - 1));\n\n\t/* Invoke the former CPU_DYING callbacks */\n\tret = cpuhp_invoke_callback_range(false, cpu, st, target);\n\n\t/*\n\t * DYING must not fail!\n\t */\n\tWARN_ON_ONCE(ret);\n\n\t/* Give up timekeeping duties */\n\ttick_handover_do_timer();\n\t/* Remove CPU from timer broadcasting */\n\ttick_offline_cpu(cpu);\n\t/* Park the stopper thread */\n\tstop_machine_park(cpu);\n\treturn 0;\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/scs.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sched/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "stop_machine_park",
          "args": [
            "cpu"
          ],
          "line": 1022
        },
        "resolved": true,
        "details": {
          "function_name": "stop_machine_park",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/stop_machine.c",
          "lines": "526-536",
          "snippet": "void stop_machine_park(int cpu)\n{\n\tstruct cpu_stopper *stopper = &per_cpu(cpu_stopper, cpu);\n\t/*\n\t * Lockless. cpu_stopper_thread() will take stopper->lock and flush\n\t * the pending works before it parks, until then it is fine to queue\n\t * the new works.\n\t */\n\tstopper->enabled = false;\n\tkthread_park(stopper->thread);\n}",
          "includes": [
            "#include <linux/sched/wake_q.h>",
            "#include <linux/nmi.h>",
            "#include <linux/atomic.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/sched.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/kthread.h>",
            "#include <linux/init.h>",
            "#include <linux/cpu.h>",
            "#include <linux/completion.h>",
            "#include <linux/compiler.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct cpu_stopper, cpu_stopper);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/wake_q.h>\n#include <linux/nmi.h>\n#include <linux/atomic.h>\n#include <linux/smpboot.h>\n#include <linux/kallsyms.h>\n#include <linux/interrupt.h>\n#include <linux/stop_machine.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kthread.h>\n#include <linux/init.h>\n#include <linux/cpu.h>\n#include <linux/completion.h>\n#include <linux/compiler.h>\n\nstatic DEFINE_PER_CPU(struct cpu_stopper, cpu_stopper);\n\nvoid stop_machine_park(int cpu)\n{\n\tstruct cpu_stopper *stopper = &per_cpu(cpu_stopper, cpu);\n\t/*\n\t * Lockless. cpu_stopper_thread() will take stopper->lock and flush\n\t * the pending works before it parks, until then it is fine to queue\n\t * the new works.\n\t */\n\tstopper->enabled = false;\n\tkthread_park(stopper->thread);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tick_offline_cpu",
          "args": [
            "cpu"
          ],
          "line": 1020
        },
        "resolved": true,
        "details": {
          "function_name": "tick_offline_cpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clockevents.c",
          "lines": "620-625",
          "snippet": "void tick_offline_cpu(unsigned int cpu)\n{\n\traw_spin_lock(&clockevents_lock);\n\ttick_broadcast_offline(cpu);\n\traw_spin_unlock(&clockevents_lock);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/smp.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/clockchips.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_RAW_SPINLOCK(clockevents_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/device.h>\n#include <linux/smp.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/hrtimer.h>\n#include <linux/clockchips.h>\n\nstatic DEFINE_RAW_SPINLOCK(clockevents_lock);\n\nvoid tick_offline_cpu(unsigned int cpu)\n{\n\traw_spin_lock(&clockevents_lock);\n\ttick_broadcast_offline(cpu);\n\traw_spin_unlock(&clockevents_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tick_handover_do_timer",
          "args": [],
          "line": 1018
        },
        "resolved": true,
        "details": {
          "function_name": "tick_handover_do_timer",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-common.c",
          "lines": "408-412",
          "snippet": "void tick_handover_do_timer(void)\n{\n\tif (tick_do_timer_cpu == smp_processor_id())\n\t\ttick_do_timer_cpu = cpumask_first(cpu_online_mask);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <asm/irq_regs.h>",
            "#include <trace/events/power.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/profile.h>",
            "#include <linux/percpu.h>",
            "#include <linux/nmi.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int tick_do_timer_cpu"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <trace/events/power.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/nmi.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nint tick_do_timer_cpu;\n\nvoid tick_handover_do_timer(void)\n{\n\tif (tick_do_timer_cpu == smp_processor_id())\n\t\ttick_do_timer_cpu = cpumask_first(cpu_online_mask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "ret"
          ],
          "line": 1015
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpuhp_invoke_callback_range",
          "args": [
            "false",
            "cpu",
            "st",
            "target"
          ],
          "line": 1010
        },
        "resolved": true,
        "details": {
          "function_name": "cpuhp_invoke_callback_range",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "663-678",
          "snippet": "static int cpuhp_invoke_callback_range(bool bringup,\n\t\t\t\t       unsigned int cpu,\n\t\t\t\t       struct cpuhp_cpu_state *st,\n\t\t\t\t       enum cpuhp_state target)\n{\n\tenum cpuhp_state state;\n\tint err = 0;\n\n\twhile (cpuhp_next_state(bringup, &state, st, target)) {\n\t\terr = cpuhp_invoke_callback(cpu, state, bringup, NULL, NULL);\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\n\treturn err;\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\n\nstatic int cpuhp_invoke_callback_range(bool bringup,\n\t\t\t\t       unsigned int cpu,\n\t\t\t\t       struct cpuhp_cpu_state *st,\n\t\t\t\t       enum cpuhp_state target)\n{\n\tenum cpuhp_state state;\n\tint err = 0;\n\n\twhile (cpuhp_next_state(bringup, &state, st, target)) {\n\t\terr = cpuhp_invoke_callback(cpu, state, bringup, NULL, NULL);\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "st->state != (CPUHP_TEARDOWN_CPU - 1)"
          ],
          "line": 1007
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__cpu_disable",
          "args": [],
          "line": 999
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 995
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "max",
          "args": [
            "(int)st->target",
            "CPUHP_AP_OFFLINE"
          ],
          "line": 994
        },
        "resolved": true,
        "details": {
          "function_name": "module_extend_max_pages",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/module_decompress.c",
          "lines": "17-32",
          "snippet": "static int module_extend_max_pages(struct load_info *info, unsigned int extent)\n{\n\tstruct page **new_pages;\n\n\tnew_pages = kvmalloc_array(info->max_pages + extent,\n\t\t\t\t   sizeof(info->pages), GFP_KERNEL);\n\tif (!new_pages)\n\t\treturn -ENOMEM;\n\n\tmemcpy(new_pages, info->pages, info->max_pages * sizeof(info->pages));\n\tkvfree(info->pages);\n\tinfo->pages = new_pages;\n\tinfo->max_pages += extent;\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/xz.h>",
            "#include <linux/zlib.h>",
            "#include \"module-internal.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/kobject.h>",
            "#include <linux/highmem.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/xz.h>\n#include <linux/zlib.h>\n#include \"module-internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/sysfs.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/kobject.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n\nstatic int module_extend_max_pages(struct load_info *info, unsigned int extent)\n{\n\tstruct page **new_pages;\n\n\tnew_pages = kvmalloc_array(info->max_pages + extent,\n\t\t\t\t   sizeof(info->pages), GFP_KERNEL);\n\tif (!new_pages)\n\t\treturn -ENOMEM;\n\n\tmemcpy(new_pages, info->pages, info->max_pages * sizeof(info->pages));\n\tkvfree(info->pages);\n\tinfo->pages = new_pages;\n\tinfo->max_pages += extent;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&cpuhp_state"
          ],
          "line": 993
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\n\nstatic int take_cpu_down(void *_param)\n{\n\tstruct cpuhp_cpu_state *st = this_cpu_ptr(&cpuhp_state);\n\tenum cpuhp_state target = max((int)st->target, CPUHP_AP_OFFLINE);\n\tint err, cpu = smp_processor_id();\n\tint ret;\n\n\t/* Ensure this CPU doesn't handle any more interrupts. */\n\terr = __cpu_disable();\n\tif (err < 0)\n\t\treturn err;\n\n\t/*\n\t * Must be called from CPUHP_TEARDOWN_CPU, which means, as we are going\n\t * down, that the current state is CPUHP_TEARDOWN_CPU - 1.\n\t */\n\tWARN_ON(st->state != (CPUHP_TEARDOWN_CPU - 1));\n\n\t/* Invoke the former CPU_DYING callbacks */\n\tret = cpuhp_invoke_callback_range(false, cpu, st, target);\n\n\t/*\n\t * DYING must not fail!\n\t */\n\tWARN_ON_ONCE(ret);\n\n\t/* Give up timekeeping duties */\n\ttick_handover_do_timer();\n\t/* Remove CPU from timer broadcasting */\n\ttick_offline_cpu(cpu);\n\t/* Park the stopper thread */\n\tstop_machine_park(cpu);\n\treturn 0;\n}"
  },
  {
    "function_name": "clear_tasks_mm_cpumask",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
    "lines": "961-988",
    "snippet": "void clear_tasks_mm_cpumask(int cpu)\n{\n\tstruct task_struct *p;\n\n\t/*\n\t * This function is called after the cpu is taken down and marked\n\t * offline, so its not like new tasks will ever get this cpu set in\n\t * their mm mask. -- Peter Zijlstra\n\t * Thus, we may use rcu_read_lock() here, instead of grabbing\n\t * full-fledged tasklist_lock.\n\t */\n\tWARN_ON(cpu_online(cpu));\n\trcu_read_lock();\n\tfor_each_process(p) {\n\t\tstruct task_struct *t;\n\n\t\t/*\n\t\t * Main thread might exit, but other threads may still have\n\t\t * a valid mm. Find one.\n\t\t */\n\t\tt = find_lock_task_mm(p);\n\t\tif (!t)\n\t\t\tcontinue;\n\t\tarch_clear_mm_cpumask_cpu(cpu, t->mm);\n\t\ttask_unlock(t);\n\t}\n\trcu_read_unlock();\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/scs.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sched/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 987
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_unlock_strict",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "815-824",
          "snippet": "void rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nvoid rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_unlock",
          "args": [
            "t"
          ],
          "line": 985
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_clear_mm_cpumask_cpu",
          "args": [
            "cpu",
            "t->mm"
          ],
          "line": 984
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_lock_task_mm",
          "args": [
            "p"
          ],
          "line": 981
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 973
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_any_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "340-351",
          "snippet": "int rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "cpu_online(cpu)"
          ],
          "line": 972
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_online",
          "args": [
            "cpu"
          ],
          "line": 972
        },
        "resolved": true,
        "details": {
          "function_name": "init_cpu_online",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "2616-2619",
          "snippet": "void init_cpu_online(const struct cpumask *src)\n{\n\tcpumask_copy(&__cpu_online_mask, src);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct cpumask __cpu_online_mask"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstruct cpumask __cpu_online_mask;\n\nvoid init_cpu_online(const struct cpumask *src)\n{\n\tcpumask_copy(&__cpu_online_mask, src);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nvoid clear_tasks_mm_cpumask(int cpu)\n{\n\tstruct task_struct *p;\n\n\t/*\n\t * This function is called after the cpu is taken down and marked\n\t * offline, so its not like new tasks will ever get this cpu set in\n\t * their mm mask. -- Peter Zijlstra\n\t * Thus, we may use rcu_read_lock() here, instead of grabbing\n\t * full-fledged tasklist_lock.\n\t */\n\tWARN_ON(cpu_online(cpu));\n\trcu_read_lock();\n\tfor_each_process(p) {\n\t\tstruct task_struct *t;\n\n\t\t/*\n\t\t * Main thread might exit, but other threads may still have\n\t\t * a valid mm. Find one.\n\t\t */\n\t\tt = find_lock_task_mm(p);\n\t\tif (!t)\n\t\t\tcontinue;\n\t\tarch_clear_mm_cpumask_cpu(cpu, t->mm);\n\t\ttask_unlock(t);\n\t}\n\trcu_read_unlock();\n}"
  },
  {
    "function_name": "cpu_up_down_serialize_trainwrecks",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
    "lines": "921-942",
    "snippet": "static void cpu_up_down_serialize_trainwrecks(bool tasks_frozen)\n{\n\t/*\n\t * cpusets delegate hotplug operations to a worker to \"solve\" the\n\t * lock order problems. Wait for the worker, but only if tasks are\n\t * _not_ frozen (suspend, hibernate) as that would wait forever.\n\t *\n\t * The wait is required because otherwise the hotplug operation\n\t * returns with inconsistent state, which could even be observed in\n\t * user space when a new CPU is brought up. The CPU plug uevent\n\t * would be delivered and user space reacting on it would fail to\n\t * move tasks to the newly plugged CPU up to the point where the\n\t * work has finished because up to that point the newly plugged CPU\n\t * is not assignable in cpusets/cgroups. On unplug that's not\n\t * necessarily a visible issue, but it is still inconsistent state,\n\t * which is the real problem which needs to be \"fixed\". This can't\n\t * prevent the transient state between scheduling the work and\n\t * returning from waiting for it.\n\t */\n\tif (!tasks_frozen)\n\t\tcpuset_wait_for_hotplug();\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/scs.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sched/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpuset_wait_for_hotplug",
          "args": [],
          "line": 941
        },
        "resolved": true,
        "details": {
          "function_name": "cpuset_wait_for_hotplug",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
          "lines": "3325-3328",
          "snippet": "void cpuset_wait_for_hotplug(void)\n{\n\tflush_work(&cpuset_hotplug_work);\n}",
          "includes": [
            "#include <linux/wait.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/mutex.h>",
            "#include <linux/atomic.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/oom.h>",
            "#include <linux/sort.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/time64.h>",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/memory.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/list.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nvoid cpuset_wait_for_hotplug(void)\n{\n\tflush_work(&cpuset_hotplug_work);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstatic void cpu_up_down_serialize_trainwrecks(bool tasks_frozen)\n{\n\t/*\n\t * cpusets delegate hotplug operations to a worker to \"solve\" the\n\t * lock order problems. Wait for the worker, but only if tasks are\n\t * _not_ frozen (suspend, hibernate) as that would wait forever.\n\t *\n\t * The wait is required because otherwise the hotplug operation\n\t * returns with inconsistent state, which could even be observed in\n\t * user space when a new CPU is brought up. The CPU plug uevent\n\t * would be delivered and user space reacting on it would fail to\n\t * move tasks to the newly plugged CPU up to the point where the\n\t * work has finished because up to that point the newly plugged CPU\n\t * is not assignable in cpusets/cgroups. On unplug that's not\n\t * necessarily a visible issue, but it is still inconsistent state,\n\t * which is the real problem which needs to be \"fixed\". This can't\n\t * prevent the transient state between scheduling the work and\n\t * returning from waiting for it.\n\t */\n\tif (!tasks_frozen)\n\t\tcpuset_wait_for_hotplug();\n}"
  },
  {
    "function_name": "cpuhp_threads_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
    "lines": "892-896",
    "snippet": "void __init cpuhp_threads_init(void)\n{\n\tBUG_ON(smpboot_register_percpu_thread(&cpuhp_threads));\n\tkthread_unpark(this_cpu_read(cpuhp_state.thread));\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/scs.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sched/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kthread_unpark",
          "args": [
            "this_cpu_read(cpuhp_state.thread)"
          ],
          "line": 895
        },
        "resolved": true,
        "details": {
          "function_name": "kthread_unpark",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
          "lines": "622-638",
          "snippet": "void kthread_unpark(struct task_struct *k)\n{\n\tstruct kthread *kthread = to_kthread(k);\n\n\t/*\n\t * Newly created kthread was parked when the CPU was offline.\n\t * The binding was lost and we need to set it again.\n\t */\n\tif (test_bit(KTHREAD_IS_PER_CPU, &kthread->flags))\n\t\t__kthread_bind(k, kthread->cpu, TASK_PARKED);\n\n\tclear_bit(KTHREAD_SHOULD_PARK, &kthread->flags);\n\t/*\n\t * __kthread_parkme() will either see !SHOULD_PARK or get the wakeup.\n\t */\n\twake_up_state(k, TASK_PARKED);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/numa.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mm.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nvoid kthread_unpark(struct task_struct *k)\n{\n\tstruct kthread *kthread = to_kthread(k);\n\n\t/*\n\t * Newly created kthread was parked when the CPU was offline.\n\t * The binding was lost and we need to set it again.\n\t */\n\tif (test_bit(KTHREAD_IS_PER_CPU, &kthread->flags))\n\t\t__kthread_bind(k, kthread->cpu, TASK_PARKED);\n\n\tclear_bit(KTHREAD_SHOULD_PARK, &kthread->flags);\n\t/*\n\t * __kthread_parkme() will either see !SHOULD_PARK or get the wakeup.\n\t */\n\twake_up_state(k, TASK_PARKED);\n}"
        }
      },
      {
        "call_info": {
          "callee": "this_cpu_read",
          "args": [
            "cpuhp_state.thread"
          ],
          "line": 895
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "smpboot_register_percpu_thread(&cpuhp_threads)"
          ],
          "line": 894
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smpboot_register_percpu_thread",
          "args": [
            "&cpuhp_threads"
          ],
          "line": 894
        },
        "resolved": true,
        "details": {
          "function_name": "smpboot_register_percpu_thread",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/smpboot.c",
          "lines": "289-309",
          "snippet": "int smpboot_register_percpu_thread(struct smp_hotplug_thread *plug_thread)\n{\n\tunsigned int cpu;\n\tint ret = 0;\n\n\tcpus_read_lock();\n\tmutex_lock(&smpboot_threads_lock);\n\tfor_each_online_cpu(cpu) {\n\t\tret = __smpboot_create_thread(plug_thread, cpu);\n\t\tif (ret) {\n\t\t\tsmpboot_destroy_threads(plug_thread);\n\t\t\tgoto out;\n\t\t}\n\t\tsmpboot_unpark_thread(plug_thread, cpu);\n\t}\n\tlist_add(&plug_thread->list, &hotplug_threads);\nout:\n\tmutex_unlock(&smpboot_threads_lock);\n\tcpus_read_unlock();\n\treturn ret;\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <linux/smpboot.h>",
            "#include <linux/kthread.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/delay.h>",
            "#include <linux/smp.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(hotplug_threads);",
            "static DEFINE_MUTEX(smpboot_threads_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <linux/smpboot.h>\n#include <linux/kthread.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic LIST_HEAD(hotplug_threads);\nstatic DEFINE_MUTEX(smpboot_threads_lock);\n\nint smpboot_register_percpu_thread(struct smp_hotplug_thread *plug_thread)\n{\n\tunsigned int cpu;\n\tint ret = 0;\n\n\tcpus_read_lock();\n\tmutex_lock(&smpboot_threads_lock);\n\tfor_each_online_cpu(cpu) {\n\t\tret = __smpboot_create_thread(plug_thread, cpu);\n\t\tif (ret) {\n\t\t\tsmpboot_destroy_threads(plug_thread);\n\t\t\tgoto out;\n\t\t}\n\t\tsmpboot_unpark_thread(plug_thread, cpu);\n\t}\n\tlist_add(&plug_thread->list, &hotplug_threads);\nout:\n\tmutex_unlock(&smpboot_threads_lock);\n\tcpus_read_unlock();\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\n\nvoid __init cpuhp_threads_init(void)\n{\n\tBUG_ON(smpboot_register_percpu_thread(&cpuhp_threads));\n\tkthread_unpark(this_cpu_read(cpuhp_state.thread));\n}"
  },
  {
    "function_name": "cpuhp_kick_ap_work",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
    "lines": "864-881",
    "snippet": "static int cpuhp_kick_ap_work(unsigned int cpu)\n{\n\tstruct cpuhp_cpu_state *st = per_cpu_ptr(&cpuhp_state, cpu);\n\tenum cpuhp_state prev_state = st->state;\n\tint ret;\n\n\tcpuhp_lock_acquire(false);\n\tcpuhp_lock_release(false);\n\n\tcpuhp_lock_acquire(true);\n\tcpuhp_lock_release(true);\n\n\ttrace_cpuhp_enter(cpu, st->target, prev_state, cpuhp_kick_ap_work);\n\tret = cpuhp_kick_ap(st, st->target);\n\ttrace_cpuhp_exit(cpu, st->state, prev_state, ret);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/scs.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sched/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_cpuhp_exit",
          "args": [
            "cpu",
            "st->state",
            "prev_state",
            "ret"
          ],
          "line": 878
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpuhp_kick_ap",
          "args": [
            "st",
            "st->target"
          ],
          "line": 877
        },
        "resolved": true,
        "details": {
          "function_name": "cpuhp_kick_ap",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "543-556",
          "snippet": "static int cpuhp_kick_ap(struct cpuhp_cpu_state *st, enum cpuhp_state target)\n{\n\tenum cpuhp_state prev_state;\n\tint ret;\n\n\tprev_state = cpuhp_set_state(st, target);\n\t__cpuhp_kick_ap(st);\n\tif ((ret = st->result)) {\n\t\tcpuhp_reset_state(st, prev_state);\n\t\t__cpuhp_kick_ap(st);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\n\nstatic int cpuhp_kick_ap(struct cpuhp_cpu_state *st, enum cpuhp_state target)\n{\n\tenum cpuhp_state prev_state;\n\tint ret;\n\n\tprev_state = cpuhp_set_state(st, target);\n\t__cpuhp_kick_ap(st);\n\tif ((ret = st->result)) {\n\t\tcpuhp_reset_state(st, prev_state);\n\t\t__cpuhp_kick_ap(st);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_cpuhp_enter",
          "args": [
            "cpu",
            "st->target",
            "prev_state",
            "cpuhp_kick_ap_work"
          ],
          "line": 876
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpuhp_lock_release",
          "args": [
            "true"
          ],
          "line": 874
        },
        "resolved": true,
        "details": {
          "function_name": "cpuhp_lock_release",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "110-110",
          "snippet": "static inline void cpuhp_lock_release(bool bringup) { }",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstatic inline void cpuhp_lock_release(bool bringup) { }"
        }
      },
      {
        "call_info": {
          "callee": "cpuhp_lock_acquire",
          "args": [
            "true"
          ],
          "line": 873
        },
        "resolved": true,
        "details": {
          "function_name": "cpuhp_lock_acquire",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "109-109",
          "snippet": "static inline void cpuhp_lock_acquire(bool bringup) { }",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstatic inline void cpuhp_lock_acquire(bool bringup) { }"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "&cpuhp_state",
            "cpu"
          ],
          "line": 866
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\n\nstatic int cpuhp_kick_ap_work(unsigned int cpu)\n{\n\tstruct cpuhp_cpu_state *st = per_cpu_ptr(&cpuhp_state, cpu);\n\tenum cpuhp_state prev_state = st->state;\n\tint ret;\n\n\tcpuhp_lock_acquire(false);\n\tcpuhp_lock_release(false);\n\n\tcpuhp_lock_acquire(true);\n\tcpuhp_lock_release(true);\n\n\ttrace_cpuhp_enter(cpu, st->target, prev_state, cpuhp_kick_ap_work);\n\tret = cpuhp_kick_ap(st, st->target);\n\ttrace_cpuhp_exit(cpu, st->state, prev_state, ret);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "cpuhp_invoke_ap_callback",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
    "lines": "813-862",
    "snippet": "static int\ncpuhp_invoke_ap_callback(int cpu, enum cpuhp_state state, bool bringup,\n\t\t\t struct hlist_node *node)\n{\n\tstruct cpuhp_cpu_state *st = per_cpu_ptr(&cpuhp_state, cpu);\n\tint ret;\n\n\tif (!cpu_online(cpu))\n\t\treturn 0;\n\n\tcpuhp_lock_acquire(false);\n\tcpuhp_lock_release(false);\n\n\tcpuhp_lock_acquire(true);\n\tcpuhp_lock_release(true);\n\n\t/*\n\t * If we are up and running, use the hotplug thread. For early calls\n\t * we invoke the thread function directly.\n\t */\n\tif (!st->thread)\n\t\treturn cpuhp_invoke_callback(cpu, state, bringup, node, NULL);\n\n\tst->rollback = false;\n\tst->last = NULL;\n\n\tst->node = node;\n\tst->bringup = bringup;\n\tst->cb_state = state;\n\tst->single = true;\n\n\t__cpuhp_kick_ap(st);\n\n\t/*\n\t * If we failed and did a partial, do a rollback.\n\t */\n\tif ((ret = st->result) && st->last) {\n\t\tst->rollback = true;\n\t\tst->bringup = !bringup;\n\n\t\t__cpuhp_kick_ap(st);\n\t}\n\n\t/*\n\t * Clean up the leftovers so the next hotplug operation wont use stale\n\t * data.\n\t */\n\tst->node = st->last = NULL;\n\treturn ret;\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/scs.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sched/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__cpuhp_kick_ap",
          "args": [
            "st"
          ],
          "line": 853
        },
        "resolved": true,
        "details": {
          "function_name": "__cpuhp_kick_ap",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "527-541",
          "snippet": "static void __cpuhp_kick_ap(struct cpuhp_cpu_state *st)\n{\n\tif (!st->single && st->state == st->target)\n\t\treturn;\n\n\tst->result = 0;\n\t/*\n\t * Make sure the above stores are visible before should_run becomes\n\t * true. Paired with the mb() above in cpuhp_thread_fun()\n\t */\n\tsmp_mb();\n\tst->should_run = true;\n\twake_up_process(st->thread);\n\twait_for_ap_thread(st, st->bringup);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstatic void __cpuhp_kick_ap(struct cpuhp_cpu_state *st)\n{\n\tif (!st->single && st->state == st->target)\n\t\treturn;\n\n\tst->result = 0;\n\t/*\n\t * Make sure the above stores are visible before should_run becomes\n\t * true. Paired with the mb() above in cpuhp_thread_fun()\n\t */\n\tsmp_mb();\n\tst->should_run = true;\n\twake_up_process(st->thread);\n\twait_for_ap_thread(st, st->bringup);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpuhp_invoke_callback",
          "args": [
            "cpu",
            "state",
            "bringup",
            "node",
            "NULL"
          ],
          "line": 834
        },
        "resolved": true,
        "details": {
          "function_name": "cpuhp_invoke_callback",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "166-246",
          "snippet": "static int cpuhp_invoke_callback(unsigned int cpu, enum cpuhp_state state,\n\t\t\t\t bool bringup, struct hlist_node *node,\n\t\t\t\t struct hlist_node **lastp)\n{\n\tstruct cpuhp_cpu_state *st = per_cpu_ptr(&cpuhp_state, cpu);\n\tstruct cpuhp_step *step = cpuhp_get_step(state);\n\tint (*cbm)(unsigned int cpu, struct hlist_node *node);\n\tint (*cb)(unsigned int cpu);\n\tint ret, cnt;\n\n\tif (st->fail == state) {\n\t\tst->fail = CPUHP_INVALID;\n\t\treturn -EAGAIN;\n\t}\n\n\tif (cpuhp_step_empty(bringup, step)) {\n\t\tWARN_ON_ONCE(1);\n\t\treturn 0;\n\t}\n\n\tif (!step->multi_instance) {\n\t\tWARN_ON_ONCE(lastp && *lastp);\n\t\tcb = bringup ? step->startup.single : step->teardown.single;\n\n\t\ttrace_cpuhp_enter(cpu, st->target, state, cb);\n\t\tret = cb(cpu);\n\t\ttrace_cpuhp_exit(cpu, st->state, state, ret);\n\t\treturn ret;\n\t}\n\tcbm = bringup ? step->startup.multi : step->teardown.multi;\n\n\t/* Single invocation for instance add/remove */\n\tif (node) {\n\t\tWARN_ON_ONCE(lastp && *lastp);\n\t\ttrace_cpuhp_multi_enter(cpu, st->target, state, cbm, node);\n\t\tret = cbm(cpu, node);\n\t\ttrace_cpuhp_exit(cpu, st->state, state, ret);\n\t\treturn ret;\n\t}\n\n\t/* State transition. Invoke on all instances */\n\tcnt = 0;\n\thlist_for_each(node, &step->list) {\n\t\tif (lastp && node == *lastp)\n\t\t\tbreak;\n\n\t\ttrace_cpuhp_multi_enter(cpu, st->target, state, cbm, node);\n\t\tret = cbm(cpu, node);\n\t\ttrace_cpuhp_exit(cpu, st->state, state, ret);\n\t\tif (ret) {\n\t\t\tif (!lastp)\n\t\t\t\tgoto err;\n\n\t\t\t*lastp = node;\n\t\t\treturn ret;\n\t\t}\n\t\tcnt++;\n\t}\n\tif (lastp)\n\t\t*lastp = NULL;\n\treturn 0;\nerr:\n\t/* Rollback the instances if one failed */\n\tcbm = !bringup ? step->startup.multi : step->teardown.multi;\n\tif (!cbm)\n\t\treturn ret;\n\n\thlist_for_each(node, &step->list) {\n\t\tif (!cnt--)\n\t\t\tbreak;\n\n\t\ttrace_cpuhp_multi_enter(cpu, st->target, state, cbm, node);\n\t\tret = cbm(cpu, node);\n\t\ttrace_cpuhp_exit(cpu, st->state, state, ret);\n\t\t/*\n\t\t * Rollback must not fail,\n\t\t */\n\t\tWARN_ON_ONCE(ret);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\n\nstatic int cpuhp_invoke_callback(unsigned int cpu, enum cpuhp_state state,\n\t\t\t\t bool bringup, struct hlist_node *node,\n\t\t\t\t struct hlist_node **lastp)\n{\n\tstruct cpuhp_cpu_state *st = per_cpu_ptr(&cpuhp_state, cpu);\n\tstruct cpuhp_step *step = cpuhp_get_step(state);\n\tint (*cbm)(unsigned int cpu, struct hlist_node *node);\n\tint (*cb)(unsigned int cpu);\n\tint ret, cnt;\n\n\tif (st->fail == state) {\n\t\tst->fail = CPUHP_INVALID;\n\t\treturn -EAGAIN;\n\t}\n\n\tif (cpuhp_step_empty(bringup, step)) {\n\t\tWARN_ON_ONCE(1);\n\t\treturn 0;\n\t}\n\n\tif (!step->multi_instance) {\n\t\tWARN_ON_ONCE(lastp && *lastp);\n\t\tcb = bringup ? step->startup.single : step->teardown.single;\n\n\t\ttrace_cpuhp_enter(cpu, st->target, state, cb);\n\t\tret = cb(cpu);\n\t\ttrace_cpuhp_exit(cpu, st->state, state, ret);\n\t\treturn ret;\n\t}\n\tcbm = bringup ? step->startup.multi : step->teardown.multi;\n\n\t/* Single invocation for instance add/remove */\n\tif (node) {\n\t\tWARN_ON_ONCE(lastp && *lastp);\n\t\ttrace_cpuhp_multi_enter(cpu, st->target, state, cbm, node);\n\t\tret = cbm(cpu, node);\n\t\ttrace_cpuhp_exit(cpu, st->state, state, ret);\n\t\treturn ret;\n\t}\n\n\t/* State transition. Invoke on all instances */\n\tcnt = 0;\n\thlist_for_each(node, &step->list) {\n\t\tif (lastp && node == *lastp)\n\t\t\tbreak;\n\n\t\ttrace_cpuhp_multi_enter(cpu, st->target, state, cbm, node);\n\t\tret = cbm(cpu, node);\n\t\ttrace_cpuhp_exit(cpu, st->state, state, ret);\n\t\tif (ret) {\n\t\t\tif (!lastp)\n\t\t\t\tgoto err;\n\n\t\t\t*lastp = node;\n\t\t\treturn ret;\n\t\t}\n\t\tcnt++;\n\t}\n\tif (lastp)\n\t\t*lastp = NULL;\n\treturn 0;\nerr:\n\t/* Rollback the instances if one failed */\n\tcbm = !bringup ? step->startup.multi : step->teardown.multi;\n\tif (!cbm)\n\t\treturn ret;\n\n\thlist_for_each(node, &step->list) {\n\t\tif (!cnt--)\n\t\t\tbreak;\n\n\t\ttrace_cpuhp_multi_enter(cpu, st->target, state, cbm, node);\n\t\tret = cbm(cpu, node);\n\t\ttrace_cpuhp_exit(cpu, st->state, state, ret);\n\t\t/*\n\t\t * Rollback must not fail,\n\t\t */\n\t\tWARN_ON_ONCE(ret);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpuhp_lock_release",
          "args": [
            "true"
          ],
          "line": 827
        },
        "resolved": true,
        "details": {
          "function_name": "cpuhp_lock_release",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "110-110",
          "snippet": "static inline void cpuhp_lock_release(bool bringup) { }",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstatic inline void cpuhp_lock_release(bool bringup) { }"
        }
      },
      {
        "call_info": {
          "callee": "cpuhp_lock_acquire",
          "args": [
            "true"
          ],
          "line": 826
        },
        "resolved": true,
        "details": {
          "function_name": "cpuhp_lock_acquire",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "109-109",
          "snippet": "static inline void cpuhp_lock_acquire(bool bringup) { }",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstatic inline void cpuhp_lock_acquire(bool bringup) { }"
        }
      },
      {
        "call_info": {
          "callee": "cpu_online",
          "args": [
            "cpu"
          ],
          "line": 820
        },
        "resolved": true,
        "details": {
          "function_name": "init_cpu_online",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "2616-2619",
          "snippet": "void init_cpu_online(const struct cpumask *src)\n{\n\tcpumask_copy(&__cpu_online_mask, src);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct cpumask __cpu_online_mask"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstruct cpumask __cpu_online_mask;\n\nvoid init_cpu_online(const struct cpumask *src)\n{\n\tcpumask_copy(&__cpu_online_mask, src);\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "&cpuhp_state",
            "cpu"
          ],
          "line": 817
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\n\nstatic int\ncpuhp_invoke_ap_callback(int cpu, enum cpuhp_state state, bool bringup,\n\t\t\t struct hlist_node *node)\n{\n\tstruct cpuhp_cpu_state *st = per_cpu_ptr(&cpuhp_state, cpu);\n\tint ret;\n\n\tif (!cpu_online(cpu))\n\t\treturn 0;\n\n\tcpuhp_lock_acquire(false);\n\tcpuhp_lock_release(false);\n\n\tcpuhp_lock_acquire(true);\n\tcpuhp_lock_release(true);\n\n\t/*\n\t * If we are up and running, use the hotplug thread. For early calls\n\t * we invoke the thread function directly.\n\t */\n\tif (!st->thread)\n\t\treturn cpuhp_invoke_callback(cpu, state, bringup, node, NULL);\n\n\tst->rollback = false;\n\tst->last = NULL;\n\n\tst->node = node;\n\tst->bringup = bringup;\n\tst->cb_state = state;\n\tst->single = true;\n\n\t__cpuhp_kick_ap(st);\n\n\t/*\n\t * If we failed and did a partial, do a rollback.\n\t */\n\tif ((ret = st->result) && st->last) {\n\t\tst->rollback = true;\n\t\tst->bringup = !bringup;\n\n\t\t__cpuhp_kick_ap(st);\n\t}\n\n\t/*\n\t * Clean up the leftovers so the next hotplug operation wont use stale\n\t * data.\n\t */\n\tst->node = st->last = NULL;\n\treturn ret;\n}"
  },
  {
    "function_name": "cpuhp_thread_fun",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
    "lines": "747-810",
    "snippet": "static void cpuhp_thread_fun(unsigned int cpu)\n{\n\tstruct cpuhp_cpu_state *st = this_cpu_ptr(&cpuhp_state);\n\tbool bringup = st->bringup;\n\tenum cpuhp_state state;\n\n\tif (WARN_ON_ONCE(!st->should_run))\n\t\treturn;\n\n\t/*\n\t * ACQUIRE for the cpuhp_should_run() load of ->should_run. Ensures\n\t * that if we see ->should_run we also see the rest of the state.\n\t */\n\tsmp_mb();\n\n\t/*\n\t * The BP holds the hotplug lock, but we're now running on the AP,\n\t * ensure that anybody asserting the lock is held, will actually find\n\t * it so.\n\t */\n\tlockdep_acquire_cpus_lock();\n\tcpuhp_lock_acquire(bringup);\n\n\tif (st->single) {\n\t\tstate = st->cb_state;\n\t\tst->should_run = false;\n\t} else {\n\t\tst->should_run = cpuhp_next_state(bringup, &state, st, st->target);\n\t\tif (!st->should_run)\n\t\t\tgoto end;\n\t}\n\n\tWARN_ON_ONCE(!cpuhp_is_ap_state(state));\n\n\tif (cpuhp_is_atomic_state(state)) {\n\t\tlocal_irq_disable();\n\t\tst->result = cpuhp_invoke_callback(cpu, state, bringup, st->node, &st->last);\n\t\tlocal_irq_enable();\n\n\t\t/*\n\t\t * STARTING/DYING must not fail!\n\t\t */\n\t\tWARN_ON_ONCE(st->result);\n\t} else {\n\t\tst->result = cpuhp_invoke_callback(cpu, state, bringup, st->node, &st->last);\n\t}\n\n\tif (st->result) {\n\t\t/*\n\t\t * If we fail on a rollback, we're up a creek without no\n\t\t * paddle, no way forward, no way back. We loose, thanks for\n\t\t * playing.\n\t\t */\n\t\tWARN_ON_ONCE(st->rollback);\n\t\tst->should_run = false;\n\t}\n\nend:\n\tcpuhp_lock_release(bringup);\n\tlockdep_release_cpus_lock();\n\n\tif (!st->should_run)\n\t\tcomplete_ap_thread(st, bringup);\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/scs.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sched/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "complete_ap_thread",
          "args": [
            "st",
            "bringup"
          ],
          "line": 809
        },
        "resolved": true,
        "details": {
          "function_name": "complete_ap_thread",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "264-268",
          "snippet": "static inline void complete_ap_thread(struct cpuhp_cpu_state *st, bool bringup)\n{\n\tstruct completion *done = bringup ? &st->done_up : &st->done_down;\n\tcomplete(done);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstatic inline void complete_ap_thread(struct cpuhp_cpu_state *st, bool bringup)\n{\n\tstruct completion *done = bringup ? &st->done_up : &st->done_down;\n\tcomplete(done);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_release_cpus_lock",
          "args": [],
          "line": 806
        },
        "resolved": true,
        "details": {
          "function_name": "lockdep_release_cpus_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "402-404",
          "snippet": "static void lockdep_release_cpus_lock(void)\n{\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstatic void lockdep_release_cpus_lock(void)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpuhp_lock_release",
          "args": [
            "bringup"
          ],
          "line": 805
        },
        "resolved": true,
        "details": {
          "function_name": "cpuhp_lock_release",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "110-110",
          "snippet": "static inline void cpuhp_lock_release(bool bringup) { }",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstatic inline void cpuhp_lock_release(bool bringup) { }"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "st->rollback"
          ],
          "line": 800
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpuhp_invoke_callback",
          "args": [
            "cpu",
            "state",
            "bringup",
            "st->node",
            "&st->last"
          ],
          "line": 791
        },
        "resolved": true,
        "details": {
          "function_name": "cpuhp_invoke_callback",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "166-246",
          "snippet": "static int cpuhp_invoke_callback(unsigned int cpu, enum cpuhp_state state,\n\t\t\t\t bool bringup, struct hlist_node *node,\n\t\t\t\t struct hlist_node **lastp)\n{\n\tstruct cpuhp_cpu_state *st = per_cpu_ptr(&cpuhp_state, cpu);\n\tstruct cpuhp_step *step = cpuhp_get_step(state);\n\tint (*cbm)(unsigned int cpu, struct hlist_node *node);\n\tint (*cb)(unsigned int cpu);\n\tint ret, cnt;\n\n\tif (st->fail == state) {\n\t\tst->fail = CPUHP_INVALID;\n\t\treturn -EAGAIN;\n\t}\n\n\tif (cpuhp_step_empty(bringup, step)) {\n\t\tWARN_ON_ONCE(1);\n\t\treturn 0;\n\t}\n\n\tif (!step->multi_instance) {\n\t\tWARN_ON_ONCE(lastp && *lastp);\n\t\tcb = bringup ? step->startup.single : step->teardown.single;\n\n\t\ttrace_cpuhp_enter(cpu, st->target, state, cb);\n\t\tret = cb(cpu);\n\t\ttrace_cpuhp_exit(cpu, st->state, state, ret);\n\t\treturn ret;\n\t}\n\tcbm = bringup ? step->startup.multi : step->teardown.multi;\n\n\t/* Single invocation for instance add/remove */\n\tif (node) {\n\t\tWARN_ON_ONCE(lastp && *lastp);\n\t\ttrace_cpuhp_multi_enter(cpu, st->target, state, cbm, node);\n\t\tret = cbm(cpu, node);\n\t\ttrace_cpuhp_exit(cpu, st->state, state, ret);\n\t\treturn ret;\n\t}\n\n\t/* State transition. Invoke on all instances */\n\tcnt = 0;\n\thlist_for_each(node, &step->list) {\n\t\tif (lastp && node == *lastp)\n\t\t\tbreak;\n\n\t\ttrace_cpuhp_multi_enter(cpu, st->target, state, cbm, node);\n\t\tret = cbm(cpu, node);\n\t\ttrace_cpuhp_exit(cpu, st->state, state, ret);\n\t\tif (ret) {\n\t\t\tif (!lastp)\n\t\t\t\tgoto err;\n\n\t\t\t*lastp = node;\n\t\t\treturn ret;\n\t\t}\n\t\tcnt++;\n\t}\n\tif (lastp)\n\t\t*lastp = NULL;\n\treturn 0;\nerr:\n\t/* Rollback the instances if one failed */\n\tcbm = !bringup ? step->startup.multi : step->teardown.multi;\n\tif (!cbm)\n\t\treturn ret;\n\n\thlist_for_each(node, &step->list) {\n\t\tif (!cnt--)\n\t\t\tbreak;\n\n\t\ttrace_cpuhp_multi_enter(cpu, st->target, state, cbm, node);\n\t\tret = cbm(cpu, node);\n\t\ttrace_cpuhp_exit(cpu, st->state, state, ret);\n\t\t/*\n\t\t * Rollback must not fail,\n\t\t */\n\t\tWARN_ON_ONCE(ret);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\n\nstatic int cpuhp_invoke_callback(unsigned int cpu, enum cpuhp_state state,\n\t\t\t\t bool bringup, struct hlist_node *node,\n\t\t\t\t struct hlist_node **lastp)\n{\n\tstruct cpuhp_cpu_state *st = per_cpu_ptr(&cpuhp_state, cpu);\n\tstruct cpuhp_step *step = cpuhp_get_step(state);\n\tint (*cbm)(unsigned int cpu, struct hlist_node *node);\n\tint (*cb)(unsigned int cpu);\n\tint ret, cnt;\n\n\tif (st->fail == state) {\n\t\tst->fail = CPUHP_INVALID;\n\t\treturn -EAGAIN;\n\t}\n\n\tif (cpuhp_step_empty(bringup, step)) {\n\t\tWARN_ON_ONCE(1);\n\t\treturn 0;\n\t}\n\n\tif (!step->multi_instance) {\n\t\tWARN_ON_ONCE(lastp && *lastp);\n\t\tcb = bringup ? step->startup.single : step->teardown.single;\n\n\t\ttrace_cpuhp_enter(cpu, st->target, state, cb);\n\t\tret = cb(cpu);\n\t\ttrace_cpuhp_exit(cpu, st->state, state, ret);\n\t\treturn ret;\n\t}\n\tcbm = bringup ? step->startup.multi : step->teardown.multi;\n\n\t/* Single invocation for instance add/remove */\n\tif (node) {\n\t\tWARN_ON_ONCE(lastp && *lastp);\n\t\ttrace_cpuhp_multi_enter(cpu, st->target, state, cbm, node);\n\t\tret = cbm(cpu, node);\n\t\ttrace_cpuhp_exit(cpu, st->state, state, ret);\n\t\treturn ret;\n\t}\n\n\t/* State transition. Invoke on all instances */\n\tcnt = 0;\n\thlist_for_each(node, &step->list) {\n\t\tif (lastp && node == *lastp)\n\t\t\tbreak;\n\n\t\ttrace_cpuhp_multi_enter(cpu, st->target, state, cbm, node);\n\t\tret = cbm(cpu, node);\n\t\ttrace_cpuhp_exit(cpu, st->state, state, ret);\n\t\tif (ret) {\n\t\t\tif (!lastp)\n\t\t\t\tgoto err;\n\n\t\t\t*lastp = node;\n\t\t\treturn ret;\n\t\t}\n\t\tcnt++;\n\t}\n\tif (lastp)\n\t\t*lastp = NULL;\n\treturn 0;\nerr:\n\t/* Rollback the instances if one failed */\n\tcbm = !bringup ? step->startup.multi : step->teardown.multi;\n\tif (!cbm)\n\t\treturn ret;\n\n\thlist_for_each(node, &step->list) {\n\t\tif (!cnt--)\n\t\t\tbreak;\n\n\t\ttrace_cpuhp_multi_enter(cpu, st->target, state, cbm, node);\n\t\tret = cbm(cpu, node);\n\t\ttrace_cpuhp_exit(cpu, st->state, state, ret);\n\t\t/*\n\t\t * Rollback must not fail,\n\t\t */\n\t\tWARN_ON_ONCE(ret);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "st->result"
          ],
          "line": 789
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_enable",
          "args": [],
          "line": 784
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_disable",
          "args": [],
          "line": 782
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpuhp_is_atomic_state",
          "args": [
            "state"
          ],
          "line": 781
        },
        "resolved": true,
        "details": {
          "function_name": "cpuhp_is_atomic_state",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "273-276",
          "snippet": "static bool cpuhp_is_atomic_state(enum cpuhp_state state)\n{\n\treturn CPUHP_AP_IDLE_DEAD <= state && state < CPUHP_AP_ONLINE;\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\n\nstatic bool cpuhp_is_atomic_state(enum cpuhp_state state)\n{\n\treturn CPUHP_AP_IDLE_DEAD <= state && state < CPUHP_AP_ONLINE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!cpuhp_is_ap_state(state)"
          ],
          "line": 779
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpuhp_is_ap_state",
          "args": [
            "state"
          ],
          "line": 779
        },
        "resolved": true,
        "details": {
          "function_name": "cpuhp_is_ap_state",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "249-256",
          "snippet": "static bool cpuhp_is_ap_state(enum cpuhp_state state)\n{\n\t/*\n\t * The extra check for CPUHP_TEARDOWN_CPU is only for documentation\n\t * purposes as that state is handled explicitly in cpu_down.\n\t */\n\treturn state > CPUHP_BRINGUP_CPU && state != CPUHP_TEARDOWN_CPU;\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\n\nstatic bool cpuhp_is_ap_state(enum cpuhp_state state)\n{\n\t/*\n\t * The extra check for CPUHP_TEARDOWN_CPU is only for documentation\n\t * purposes as that state is handled explicitly in cpu_down.\n\t */\n\treturn state > CPUHP_BRINGUP_CPU && state != CPUHP_TEARDOWN_CPU;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpuhp_next_state",
          "args": [
            "bringup",
            "&state",
            "st",
            "st->target"
          ],
          "line": 774
        },
        "resolved": true,
        "details": {
          "function_name": "cpuhp_next_state",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "638-661",
          "snippet": "static bool cpuhp_next_state(bool bringup,\n\t\t\t     enum cpuhp_state *state_to_run,\n\t\t\t     struct cpuhp_cpu_state *st,\n\t\t\t     enum cpuhp_state target)\n{\n\tdo {\n\t\tif (bringup) {\n\t\t\tif (st->state >= target)\n\t\t\t\treturn false;\n\n\t\t\t*state_to_run = ++st->state;\n\t\t} else {\n\t\t\tif (st->state <= target)\n\t\t\t\treturn false;\n\n\t\t\t*state_to_run = st->state--;\n\t\t}\n\n\t\tif (!cpuhp_step_empty(bringup, cpuhp_get_step(*state_to_run)))\n\t\t\tbreak;\n\t} while (true);\n\n\treturn true;\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\n\nstatic bool cpuhp_next_state(bool bringup,\n\t\t\t     enum cpuhp_state *state_to_run,\n\t\t\t     struct cpuhp_cpu_state *st,\n\t\t\t     enum cpuhp_state target)\n{\n\tdo {\n\t\tif (bringup) {\n\t\t\tif (st->state >= target)\n\t\t\t\treturn false;\n\n\t\t\t*state_to_run = ++st->state;\n\t\t} else {\n\t\t\tif (st->state <= target)\n\t\t\t\treturn false;\n\n\t\t\t*state_to_run = st->state--;\n\t\t}\n\n\t\tif (!cpuhp_step_empty(bringup, cpuhp_get_step(*state_to_run)))\n\t\t\tbreak;\n\t} while (true);\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpuhp_lock_acquire",
          "args": [
            "bringup"
          ],
          "line": 768
        },
        "resolved": true,
        "details": {
          "function_name": "cpuhp_lock_acquire",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "109-109",
          "snippet": "static inline void cpuhp_lock_acquire(bool bringup) { }",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstatic inline void cpuhp_lock_acquire(bool bringup) { }"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_acquire_cpus_lock",
          "args": [],
          "line": 767
        },
        "resolved": true,
        "details": {
          "function_name": "lockdep_acquire_cpus_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "398-400",
          "snippet": "static void lockdep_acquire_cpus_lock(void)\n{\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstatic void lockdep_acquire_cpus_lock(void)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_mb",
          "args": [],
          "line": 760
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!st->should_run"
          ],
          "line": 753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&cpuhp_state"
          ],
          "line": 749
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\n\nstatic void cpuhp_thread_fun(unsigned int cpu)\n{\n\tstruct cpuhp_cpu_state *st = this_cpu_ptr(&cpuhp_state);\n\tbool bringup = st->bringup;\n\tenum cpuhp_state state;\n\n\tif (WARN_ON_ONCE(!st->should_run))\n\t\treturn;\n\n\t/*\n\t * ACQUIRE for the cpuhp_should_run() load of ->should_run. Ensures\n\t * that if we see ->should_run we also see the rest of the state.\n\t */\n\tsmp_mb();\n\n\t/*\n\t * The BP holds the hotplug lock, but we're now running on the AP,\n\t * ensure that anybody asserting the lock is held, will actually find\n\t * it so.\n\t */\n\tlockdep_acquire_cpus_lock();\n\tcpuhp_lock_acquire(bringup);\n\n\tif (st->single) {\n\t\tstate = st->cb_state;\n\t\tst->should_run = false;\n\t} else {\n\t\tst->should_run = cpuhp_next_state(bringup, &state, st, st->target);\n\t\tif (!st->should_run)\n\t\t\tgoto end;\n\t}\n\n\tWARN_ON_ONCE(!cpuhp_is_ap_state(state));\n\n\tif (cpuhp_is_atomic_state(state)) {\n\t\tlocal_irq_disable();\n\t\tst->result = cpuhp_invoke_callback(cpu, state, bringup, st->node, &st->last);\n\t\tlocal_irq_enable();\n\n\t\t/*\n\t\t * STARTING/DYING must not fail!\n\t\t */\n\t\tWARN_ON_ONCE(st->result);\n\t} else {\n\t\tst->result = cpuhp_invoke_callback(cpu, state, bringup, st->node, &st->last);\n\t}\n\n\tif (st->result) {\n\t\t/*\n\t\t * If we fail on a rollback, we're up a creek without no\n\t\t * paddle, no way forward, no way back. We loose, thanks for\n\t\t * playing.\n\t\t */\n\t\tWARN_ON_ONCE(st->rollback);\n\t\tst->should_run = false;\n\t}\n\nend:\n\tcpuhp_lock_release(bringup);\n\tlockdep_release_cpus_lock();\n\n\tif (!st->should_run)\n\t\tcomplete_ap_thread(st, bringup);\n}"
  },
  {
    "function_name": "cpuhp_should_run",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
    "lines": "726-731",
    "snippet": "static int cpuhp_should_run(unsigned int cpu)\n{\n\tstruct cpuhp_cpu_state *st = this_cpu_ptr(&cpuhp_state);\n\n\treturn st->should_run;\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/scs.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sched/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&cpuhp_state"
          ],
          "line": 728
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\n\nstatic int cpuhp_should_run(unsigned int cpu)\n{\n\tstruct cpuhp_cpu_state *st = this_cpu_ptr(&cpuhp_state);\n\n\treturn st->should_run;\n}"
  },
  {
    "function_name": "cpuhp_create",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
    "lines": "717-724",
    "snippet": "static void cpuhp_create(unsigned int cpu)\n{\n\tstruct cpuhp_cpu_state *st = per_cpu_ptr(&cpuhp_state, cpu);\n\n\tinit_completion(&st->done_up);\n\tinit_completion(&st->done_down);\n\tst->cpu = cpu;\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/scs.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sched/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "init_completion",
          "args": [
            "&st->done_down"
          ],
          "line": 722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_completion",
          "args": [
            "&st->done_up"
          ],
          "line": 721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "&cpuhp_state",
            "cpu"
          ],
          "line": 719
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\n\nstatic void cpuhp_create(unsigned int cpu)\n{\n\tstruct cpuhp_cpu_state *st = per_cpu_ptr(&cpuhp_state, cpu);\n\n\tinit_completion(&st->done_up);\n\tinit_completion(&st->done_down);\n\tst->cpu = cpu;\n}"
  },
  {
    "function_name": "cpuhp_up_callbacks",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
    "lines": "694-712",
    "snippet": "static int cpuhp_up_callbacks(unsigned int cpu, struct cpuhp_cpu_state *st,\n\t\t\t      enum cpuhp_state target)\n{\n\tenum cpuhp_state prev_state = st->state;\n\tint ret = 0;\n\n\tret = cpuhp_invoke_callback_range(true, cpu, st, target);\n\tif (ret) {\n\t\tpr_debug(\"CPU UP failed (%d) CPU %u state %s (%d)\\n\",\n\t\t\t ret, cpu, cpuhp_get_step(st->state)->name,\n\t\t\t st->state);\n\n\t\tcpuhp_reset_state(st, prev_state);\n\t\tif (can_rollback_cpu(st))\n\t\t\tWARN_ON(cpuhp_invoke_callback_range(false, cpu, st,\n\t\t\t\t\t\t\t    prev_state));\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/scs.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sched/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "cpuhp_invoke_callback_range(false, cpu, st,\n\t\t\t\t\t\t\t    prev_state)"
          ],
          "line": 708
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpuhp_invoke_callback_range",
          "args": [
            "false",
            "cpu",
            "st",
            "prev_state"
          ],
          "line": 708
        },
        "resolved": true,
        "details": {
          "function_name": "cpuhp_invoke_callback_range",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "663-678",
          "snippet": "static int cpuhp_invoke_callback_range(bool bringup,\n\t\t\t\t       unsigned int cpu,\n\t\t\t\t       struct cpuhp_cpu_state *st,\n\t\t\t\t       enum cpuhp_state target)\n{\n\tenum cpuhp_state state;\n\tint err = 0;\n\n\twhile (cpuhp_next_state(bringup, &state, st, target)) {\n\t\terr = cpuhp_invoke_callback(cpu, state, bringup, NULL, NULL);\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\n\treturn err;\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\n\nstatic int cpuhp_invoke_callback_range(bool bringup,\n\t\t\t\t       unsigned int cpu,\n\t\t\t\t       struct cpuhp_cpu_state *st,\n\t\t\t\t       enum cpuhp_state target)\n{\n\tenum cpuhp_state state;\n\tint err = 0;\n\n\twhile (cpuhp_next_state(bringup, &state, st, target)) {\n\t\terr = cpuhp_invoke_callback(cpu, state, bringup, NULL, NULL);\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "can_rollback_cpu",
          "args": [
            "st"
          ],
          "line": 707
        },
        "resolved": true,
        "details": {
          "function_name": "can_rollback_cpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "680-692",
          "snippet": "static inline bool can_rollback_cpu(struct cpuhp_cpu_state *st)\n{\n\tif (IS_ENABLED(CONFIG_HOTPLUG_CPU))\n\t\treturn true;\n\t/*\n\t * When CPU hotplug is disabled, then taking the CPU down is not\n\t * possible because takedown_cpu() and the architecture and\n\t * subsystem specific mechanisms are not available. So the CPU\n\t * which would be completely unplugged again needs to stay around\n\t * in the current state.\n\t */\n\treturn st->state <= CPUHP_BRINGUP_CPU;\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [
            "#define takedown_cpu\t\tNULL"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\n#define takedown_cpu\t\tNULL\n\nstatic inline bool can_rollback_cpu(struct cpuhp_cpu_state *st)\n{\n\tif (IS_ENABLED(CONFIG_HOTPLUG_CPU))\n\t\treturn true;\n\t/*\n\t * When CPU hotplug is disabled, then taking the CPU down is not\n\t * possible because takedown_cpu() and the architecture and\n\t * subsystem specific mechanisms are not available. So the CPU\n\t * which would be completely unplugged again needs to stay around\n\t * in the current state.\n\t */\n\treturn st->state <= CPUHP_BRINGUP_CPU;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpuhp_reset_state",
          "args": [
            "st",
            "prev_state"
          ],
          "line": 706
        },
        "resolved": true,
        "details": {
          "function_name": "cpuhp_reset_state",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "494-524",
          "snippet": "static inline void\ncpuhp_reset_state(struct cpuhp_cpu_state *st, enum cpuhp_state prev_state)\n{\n\tbool bringup = !st->bringup;\n\n\tst->target = prev_state;\n\n\t/*\n\t * Already rolling back. No need invert the bringup value or to change\n\t * the current state.\n\t */\n\tif (st->rollback)\n\t\treturn;\n\n\tst->rollback = true;\n\n\t/*\n\t * If we have st->last we need to undo partial multi_instance of this\n\t * state first. Otherwise start undo at the previous state.\n\t */\n\tif (!st->last) {\n\t\tif (st->bringup)\n\t\t\tst->state--;\n\t\telse\n\t\t\tst->state++;\n\t}\n\n\tst->bringup = bringup;\n\tif (cpu_dying(st->cpu) != !bringup)\n\t\tset_cpu_dying(st->cpu, !bringup);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\n\nstatic inline void\ncpuhp_reset_state(struct cpuhp_cpu_state *st, enum cpuhp_state prev_state)\n{\n\tbool bringup = !st->bringup;\n\n\tst->target = prev_state;\n\n\t/*\n\t * Already rolling back. No need invert the bringup value or to change\n\t * the current state.\n\t */\n\tif (st->rollback)\n\t\treturn;\n\n\tst->rollback = true;\n\n\t/*\n\t * If we have st->last we need to undo partial multi_instance of this\n\t * state first. Otherwise start undo at the previous state.\n\t */\n\tif (!st->last) {\n\t\tif (st->bringup)\n\t\t\tst->state--;\n\t\telse\n\t\t\tst->state++;\n\t}\n\n\tst->bringup = bringup;\n\tif (cpu_dying(st->cpu) != !bringup)\n\t\tset_cpu_dying(st->cpu, !bringup);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"CPU UP failed (%d) CPU %u state %s (%d)\\n\"",
            "ret",
            "cpu",
            "cpuhp_get_step(st->state)->name",
            "st->state"
          ],
          "line": 702
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpuhp_get_step",
          "args": [
            "st->state"
          ],
          "line": 703
        },
        "resolved": true,
        "details": {
          "function_name": "cpuhp_get_step",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "144-147",
          "snippet": "static struct cpuhp_step *cpuhp_get_step(enum cpuhp_state state)\n{\n\treturn cpuhp_hp_states + state;\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};",
            "static struct cpuhp_step cpuhp_hp_states[];",
            "static struct cpuhp_step cpuhp_hp_states[] = {\n\t[CPUHP_OFFLINE] = {\n\t\t.name\t\t\t= \"offline\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= NULL,\n\t},\n#ifdef CONFIG_SMP\n\t[CPUHP_CREATE_THREADS]= {\n\t\t.name\t\t\t= \"threads:prepare\",\n\t\t.startup.single\t\t= smpboot_create_threads,\n\t\t.teardown.single\t= NULL,\n\t\t.cant_stop\t\t= true,\n\t},\n\t[CPUHP_PERF_PREPARE] = {\n\t\t.name\t\t\t= \"perf:prepare\",\n\t\t.startup.single\t\t= perf_event_init_cpu,\n\t\t.teardown.single\t= perf_event_exit_cpu,\n\t},\n\t[CPUHP_WORKQUEUE_PREP] = {\n\t\t.name\t\t\t= \"workqueue:prepare\",\n\t\t.startup.single\t\t= workqueue_prepare_cpu,\n\t\t.teardown.single\t= NULL,\n\t},\n\t[CPUHP_HRTIMERS_PREPARE] = {\n\t\t.name\t\t\t= \"hrtimers:prepare\",\n\t\t.startup.single\t\t= hrtimers_prepare_cpu,\n\t\t.teardown.single\t= hrtimers_dead_cpu,\n\t},\n\t[CPUHP_SMPCFD_PREPARE] = {\n\t\t.name\t\t\t= \"smpcfd:prepare\",\n\t\t.startup.single\t\t= smpcfd_prepare_cpu,\n\t\t.teardown.single\t= smpcfd_dead_cpu,\n\t},\n\t[CPUHP_RELAY_PREPARE] = {\n\t\t.name\t\t\t= \"relay:prepare\",\n\t\t.startup.single\t\t= relay_prepare_cpu,\n\t\t.teardown.single\t= NULL,\n\t},\n\t[CPUHP_SLAB_PREPARE] = {\n\t\t.name\t\t\t= \"slab:prepare\",\n\t\t.startup.single\t\t= slab_prepare_cpu,\n\t\t.teardown.single\t= slab_dead_cpu,\n\t},\n\t[CPUHP_RCUTREE_PREP] = {\n\t\t.name\t\t\t= \"RCU/tree:prepare\",\n\t\t.startup.single\t\t= rcutree_prepare_cpu,\n\t\t.teardown.single\t= rcutree_dead_cpu,\n\t},\n\t/*\n\t * On the tear-down path, timers_dead_cpu() must be invoked\n\t * before blk_mq_queue_reinit_notify() from notify_dead(),\n\t * otherwise a RCU stall occurs.\n\t */\n\t[CPUHP_TIMERS_PREPARE] = {\n\t\t.name\t\t\t= \"timers:prepare\",\n\t\t.startup.single\t\t= timers_prepare_cpu,\n\t\t.teardown.single\t= timers_dead_cpu,\n\t},\n\t/* Kicks the plugged cpu into life */\n\t[CPUHP_BRINGUP_CPU] = {\n\t\t.name\t\t\t= \"cpu:bringup\",\n\t\t.startup.single\t\t= bringup_cpu,\n\t\t.teardown.single\t= finish_cpu,\n\t\t.cant_stop\t\t= true,\n\t},\n\t/* Final state before CPU kills itself */\n\t[CPUHP_AP_IDLE_DEAD] = {\n\t\t.name\t\t\t= \"idle:dead\",\n\t},\n\t/*\n\t * Last state before CPU enters the idle loop to die. Transient state\n\t * for synchronization.\n\t */\n\t[CPUHP_AP_OFFLINE] = {\n\t\t.name\t\t\t= \"ap:offline\",\n\t\t.cant_stop\t\t= true,\n\t},\n\t/* First state is scheduler control. Interrupts are disabled */\n\t[CPUHP_AP_SCHED_STARTING] = {\n\t\t.name\t\t\t= \"sched:starting\",\n\t\t.startup.single\t\t= sched_cpu_starting,\n\t\t.teardown.single\t= sched_cpu_dying,\n\t},\n\t[CPUHP_AP_RCUTREE_DYING] = {\n\t\t.name\t\t\t= \"RCU/tree:dying\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= rcutree_dying_cpu,\n\t},\n\t[CPUHP_AP_SMPCFD_DYING] = {\n\t\t.name\t\t\t= \"smpcfd:dying\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= smpcfd_dying_cpu,\n\t},\n\t/* Entry state on starting. Interrupts enabled from here on. Transient\n\t * state for synchronsization */\n\t[CPUHP_AP_ONLINE] = {\n\t\t.name\t\t\t= \"ap:online\",\n\t},\n\t/*\n\t * Handled on control processor until the plugged processor manages\n\t * this itself.\n\t */\n\t[CPUHP_TEARDOWN_CPU] = {\n\t\t.name\t\t\t= \"cpu:teardown\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= takedown_cpu,\n\t\t.cant_stop\t\t= true,\n\t},\n\n\t[CPUHP_AP_SCHED_WAIT_EMPTY] = {\n\t\t.name\t\t\t= \"sched:waitempty\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= sched_cpu_wait_empty,\n\t},\n\n\t/* Handle smpboot threads park/unpark */\n\t[CPUHP_AP_SMPBOOT_THREADS] = {\n\t\t.name\t\t\t= \"smpboot/threads:online\",\n\t\t.startup.single\t\t= smpboot_unpark_threads,\n\t\t.teardown.single\t= smpboot_park_threads,\n\t},\n\t[CPUHP_AP_IRQ_AFFINITY_ONLINE] = {\n\t\t.name\t\t\t= \"irq/affinity:online\",\n\t\t.startup.single\t\t= irq_affinity_online_cpu,\n\t\t.teardown.single\t= NULL,\n\t},\n\t[CPUHP_AP_PERF_ONLINE] = {\n\t\t.name\t\t\t= \"perf:online\",\n\t\t.startup.single\t\t= perf_event_init_cpu,\n\t\t.teardown.single\t= perf_event_exit_cpu,\n\t},\n\t[CPUHP_AP_WATCHDOG_ONLINE] = {\n\t\t.name\t\t\t= \"lockup_detector:online\",\n\t\t.startup.single\t\t= lockup_detector_online_cpu,\n\t\t.teardown.single\t= lockup_detector_offline_cpu,\n\t},\n\t[CPUHP_AP_WORKQUEUE_ONLINE] = {\n\t\t.name\t\t\t= \"workqueue:online\",\n\t\t.startup.single\t\t= workqueue_online_cpu,\n\t\t.teardown.single\t= workqueue_offline_cpu,\n\t},\n\t[CPUHP_AP_RCUTREE_ONLINE] = {\n\t\t.name\t\t\t= \"RCU/tree:online\",\n\t\t.startup.single\t\t= rcutree_online_cpu,\n\t\t.teardown.single\t= rcutree_offline_cpu,\n\t},\n#endif\n\t/*\n\t * The dynamically registered state space is here\n\t */\n\n#ifdef CONFIG_SMP\n\t/* Last state is scheduler control setting the cpu active */\n\t[CPUHP_AP_ACTIVE] = {\n\t\t.name\t\t\t= \"sched:active\",\n\t\t.startup.single\t\t= sched_cpu_activate,\n\t\t.teardown.single\t= sched_cpu_deactivate,\n\t},\n#endif\n\n\t/* CPU is fully up and running. */\n\t[CPUHP_ONLINE] = {\n\t\t.name\t\t\t= \"online\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= NULL,\n\t},\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\nstatic struct cpuhp_step cpuhp_hp_states[];\nstatic struct cpuhp_step cpuhp_hp_states[] = {\n\t[CPUHP_OFFLINE] = {\n\t\t.name\t\t\t= \"offline\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= NULL,\n\t},\n#ifdef CONFIG_SMP\n\t[CPUHP_CREATE_THREADS]= {\n\t\t.name\t\t\t= \"threads:prepare\",\n\t\t.startup.single\t\t= smpboot_create_threads,\n\t\t.teardown.single\t= NULL,\n\t\t.cant_stop\t\t= true,\n\t},\n\t[CPUHP_PERF_PREPARE] = {\n\t\t.name\t\t\t= \"perf:prepare\",\n\t\t.startup.single\t\t= perf_event_init_cpu,\n\t\t.teardown.single\t= perf_event_exit_cpu,\n\t},\n\t[CPUHP_WORKQUEUE_PREP] = {\n\t\t.name\t\t\t= \"workqueue:prepare\",\n\t\t.startup.single\t\t= workqueue_prepare_cpu,\n\t\t.teardown.single\t= NULL,\n\t},\n\t[CPUHP_HRTIMERS_PREPARE] = {\n\t\t.name\t\t\t= \"hrtimers:prepare\",\n\t\t.startup.single\t\t= hrtimers_prepare_cpu,\n\t\t.teardown.single\t= hrtimers_dead_cpu,\n\t},\n\t[CPUHP_SMPCFD_PREPARE] = {\n\t\t.name\t\t\t= \"smpcfd:prepare\",\n\t\t.startup.single\t\t= smpcfd_prepare_cpu,\n\t\t.teardown.single\t= smpcfd_dead_cpu,\n\t},\n\t[CPUHP_RELAY_PREPARE] = {\n\t\t.name\t\t\t= \"relay:prepare\",\n\t\t.startup.single\t\t= relay_prepare_cpu,\n\t\t.teardown.single\t= NULL,\n\t},\n\t[CPUHP_SLAB_PREPARE] = {\n\t\t.name\t\t\t= \"slab:prepare\",\n\t\t.startup.single\t\t= slab_prepare_cpu,\n\t\t.teardown.single\t= slab_dead_cpu,\n\t},\n\t[CPUHP_RCUTREE_PREP] = {\n\t\t.name\t\t\t= \"RCU/tree:prepare\",\n\t\t.startup.single\t\t= rcutree_prepare_cpu,\n\t\t.teardown.single\t= rcutree_dead_cpu,\n\t},\n\t/*\n\t * On the tear-down path, timers_dead_cpu() must be invoked\n\t * before blk_mq_queue_reinit_notify() from notify_dead(),\n\t * otherwise a RCU stall occurs.\n\t */\n\t[CPUHP_TIMERS_PREPARE] = {\n\t\t.name\t\t\t= \"timers:prepare\",\n\t\t.startup.single\t\t= timers_prepare_cpu,\n\t\t.teardown.single\t= timers_dead_cpu,\n\t},\n\t/* Kicks the plugged cpu into life */\n\t[CPUHP_BRINGUP_CPU] = {\n\t\t.name\t\t\t= \"cpu:bringup\",\n\t\t.startup.single\t\t= bringup_cpu,\n\t\t.teardown.single\t= finish_cpu,\n\t\t.cant_stop\t\t= true,\n\t},\n\t/* Final state before CPU kills itself */\n\t[CPUHP_AP_IDLE_DEAD] = {\n\t\t.name\t\t\t= \"idle:dead\",\n\t},\n\t/*\n\t * Last state before CPU enters the idle loop to die. Transient state\n\t * for synchronization.\n\t */\n\t[CPUHP_AP_OFFLINE] = {\n\t\t.name\t\t\t= \"ap:offline\",\n\t\t.cant_stop\t\t= true,\n\t},\n\t/* First state is scheduler control. Interrupts are disabled */\n\t[CPUHP_AP_SCHED_STARTING] = {\n\t\t.name\t\t\t= \"sched:starting\",\n\t\t.startup.single\t\t= sched_cpu_starting,\n\t\t.teardown.single\t= sched_cpu_dying,\n\t},\n\t[CPUHP_AP_RCUTREE_DYING] = {\n\t\t.name\t\t\t= \"RCU/tree:dying\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= rcutree_dying_cpu,\n\t},\n\t[CPUHP_AP_SMPCFD_DYING] = {\n\t\t.name\t\t\t= \"smpcfd:dying\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= smpcfd_dying_cpu,\n\t},\n\t/* Entry state on starting. Interrupts enabled from here on. Transient\n\t * state for synchronsization */\n\t[CPUHP_AP_ONLINE] = {\n\t\t.name\t\t\t= \"ap:online\",\n\t},\n\t/*\n\t * Handled on control processor until the plugged processor manages\n\t * this itself.\n\t */\n\t[CPUHP_TEARDOWN_CPU] = {\n\t\t.name\t\t\t= \"cpu:teardown\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= takedown_cpu,\n\t\t.cant_stop\t\t= true,\n\t},\n\n\t[CPUHP_AP_SCHED_WAIT_EMPTY] = {\n\t\t.name\t\t\t= \"sched:waitempty\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= sched_cpu_wait_empty,\n\t},\n\n\t/* Handle smpboot threads park/unpark */\n\t[CPUHP_AP_SMPBOOT_THREADS] = {\n\t\t.name\t\t\t= \"smpboot/threads:online\",\n\t\t.startup.single\t\t= smpboot_unpark_threads,\n\t\t.teardown.single\t= smpboot_park_threads,\n\t},\n\t[CPUHP_AP_IRQ_AFFINITY_ONLINE] = {\n\t\t.name\t\t\t= \"irq/affinity:online\",\n\t\t.startup.single\t\t= irq_affinity_online_cpu,\n\t\t.teardown.single\t= NULL,\n\t},\n\t[CPUHP_AP_PERF_ONLINE] = {\n\t\t.name\t\t\t= \"perf:online\",\n\t\t.startup.single\t\t= perf_event_init_cpu,\n\t\t.teardown.single\t= perf_event_exit_cpu,\n\t},\n\t[CPUHP_AP_WATCHDOG_ONLINE] = {\n\t\t.name\t\t\t= \"lockup_detector:online\",\n\t\t.startup.single\t\t= lockup_detector_online_cpu,\n\t\t.teardown.single\t= lockup_detector_offline_cpu,\n\t},\n\t[CPUHP_AP_WORKQUEUE_ONLINE] = {\n\t\t.name\t\t\t= \"workqueue:online\",\n\t\t.startup.single\t\t= workqueue_online_cpu,\n\t\t.teardown.single\t= workqueue_offline_cpu,\n\t},\n\t[CPUHP_AP_RCUTREE_ONLINE] = {\n\t\t.name\t\t\t= \"RCU/tree:online\",\n\t\t.startup.single\t\t= rcutree_online_cpu,\n\t\t.teardown.single\t= rcutree_offline_cpu,\n\t},\n#endif\n\t/*\n\t * The dynamically registered state space is here\n\t */\n\n#ifdef CONFIG_SMP\n\t/* Last state is scheduler control setting the cpu active */\n\t[CPUHP_AP_ACTIVE] = {\n\t\t.name\t\t\t= \"sched:active\",\n\t\t.startup.single\t\t= sched_cpu_activate,\n\t\t.teardown.single\t= sched_cpu_deactivate,\n\t},\n#endif\n\n\t/* CPU is fully up and running. */\n\t[CPUHP_ONLINE] = {\n\t\t.name\t\t\t= \"online\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= NULL,\n\t},\n};\n\nstatic struct cpuhp_step *cpuhp_get_step(enum cpuhp_state state)\n{\n\treturn cpuhp_hp_states + state;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\n\nstatic int cpuhp_up_callbacks(unsigned int cpu, struct cpuhp_cpu_state *st,\n\t\t\t      enum cpuhp_state target)\n{\n\tenum cpuhp_state prev_state = st->state;\n\tint ret = 0;\n\n\tret = cpuhp_invoke_callback_range(true, cpu, st, target);\n\tif (ret) {\n\t\tpr_debug(\"CPU UP failed (%d) CPU %u state %s (%d)\\n\",\n\t\t\t ret, cpu, cpuhp_get_step(st->state)->name,\n\t\t\t st->state);\n\n\t\tcpuhp_reset_state(st, prev_state);\n\t\tif (can_rollback_cpu(st))\n\t\t\tWARN_ON(cpuhp_invoke_callback_range(false, cpu, st,\n\t\t\t\t\t\t\t    prev_state));\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "can_rollback_cpu",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
    "lines": "680-692",
    "snippet": "static inline bool can_rollback_cpu(struct cpuhp_cpu_state *st)\n{\n\tif (IS_ENABLED(CONFIG_HOTPLUG_CPU))\n\t\treturn true;\n\t/*\n\t * When CPU hotplug is disabled, then taking the CPU down is not\n\t * possible because takedown_cpu() and the architecture and\n\t * subsystem specific mechanisms are not available. So the CPU\n\t * which would be completely unplugged again needs to stay around\n\t * in the current state.\n\t */\n\treturn st->state <= CPUHP_BRINGUP_CPU;\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/scs.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sched/mm.h>"
    ],
    "macros_used": [
      "#define takedown_cpu\t\tNULL"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_HOTPLUG_CPU"
          ],
          "line": 682
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\n#define takedown_cpu\t\tNULL\n\nstatic inline bool can_rollback_cpu(struct cpuhp_cpu_state *st)\n{\n\tif (IS_ENABLED(CONFIG_HOTPLUG_CPU))\n\t\treturn true;\n\t/*\n\t * When CPU hotplug is disabled, then taking the CPU down is not\n\t * possible because takedown_cpu() and the architecture and\n\t * subsystem specific mechanisms are not available. So the CPU\n\t * which would be completely unplugged again needs to stay around\n\t * in the current state.\n\t */\n\treturn st->state <= CPUHP_BRINGUP_CPU;\n}"
  },
  {
    "function_name": "cpuhp_invoke_callback_range",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
    "lines": "663-678",
    "snippet": "static int cpuhp_invoke_callback_range(bool bringup,\n\t\t\t\t       unsigned int cpu,\n\t\t\t\t       struct cpuhp_cpu_state *st,\n\t\t\t\t       enum cpuhp_state target)\n{\n\tenum cpuhp_state state;\n\tint err = 0;\n\n\twhile (cpuhp_next_state(bringup, &state, st, target)) {\n\t\terr = cpuhp_invoke_callback(cpu, state, bringup, NULL, NULL);\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\n\treturn err;\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/scs.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sched/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpuhp_invoke_callback",
          "args": [
            "cpu",
            "state",
            "bringup",
            "NULL",
            "NULL"
          ],
          "line": 672
        },
        "resolved": true,
        "details": {
          "function_name": "cpuhp_invoke_callback",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "166-246",
          "snippet": "static int cpuhp_invoke_callback(unsigned int cpu, enum cpuhp_state state,\n\t\t\t\t bool bringup, struct hlist_node *node,\n\t\t\t\t struct hlist_node **lastp)\n{\n\tstruct cpuhp_cpu_state *st = per_cpu_ptr(&cpuhp_state, cpu);\n\tstruct cpuhp_step *step = cpuhp_get_step(state);\n\tint (*cbm)(unsigned int cpu, struct hlist_node *node);\n\tint (*cb)(unsigned int cpu);\n\tint ret, cnt;\n\n\tif (st->fail == state) {\n\t\tst->fail = CPUHP_INVALID;\n\t\treturn -EAGAIN;\n\t}\n\n\tif (cpuhp_step_empty(bringup, step)) {\n\t\tWARN_ON_ONCE(1);\n\t\treturn 0;\n\t}\n\n\tif (!step->multi_instance) {\n\t\tWARN_ON_ONCE(lastp && *lastp);\n\t\tcb = bringup ? step->startup.single : step->teardown.single;\n\n\t\ttrace_cpuhp_enter(cpu, st->target, state, cb);\n\t\tret = cb(cpu);\n\t\ttrace_cpuhp_exit(cpu, st->state, state, ret);\n\t\treturn ret;\n\t}\n\tcbm = bringup ? step->startup.multi : step->teardown.multi;\n\n\t/* Single invocation for instance add/remove */\n\tif (node) {\n\t\tWARN_ON_ONCE(lastp && *lastp);\n\t\ttrace_cpuhp_multi_enter(cpu, st->target, state, cbm, node);\n\t\tret = cbm(cpu, node);\n\t\ttrace_cpuhp_exit(cpu, st->state, state, ret);\n\t\treturn ret;\n\t}\n\n\t/* State transition. Invoke on all instances */\n\tcnt = 0;\n\thlist_for_each(node, &step->list) {\n\t\tif (lastp && node == *lastp)\n\t\t\tbreak;\n\n\t\ttrace_cpuhp_multi_enter(cpu, st->target, state, cbm, node);\n\t\tret = cbm(cpu, node);\n\t\ttrace_cpuhp_exit(cpu, st->state, state, ret);\n\t\tif (ret) {\n\t\t\tif (!lastp)\n\t\t\t\tgoto err;\n\n\t\t\t*lastp = node;\n\t\t\treturn ret;\n\t\t}\n\t\tcnt++;\n\t}\n\tif (lastp)\n\t\t*lastp = NULL;\n\treturn 0;\nerr:\n\t/* Rollback the instances if one failed */\n\tcbm = !bringup ? step->startup.multi : step->teardown.multi;\n\tif (!cbm)\n\t\treturn ret;\n\n\thlist_for_each(node, &step->list) {\n\t\tif (!cnt--)\n\t\t\tbreak;\n\n\t\ttrace_cpuhp_multi_enter(cpu, st->target, state, cbm, node);\n\t\tret = cbm(cpu, node);\n\t\ttrace_cpuhp_exit(cpu, st->state, state, ret);\n\t\t/*\n\t\t * Rollback must not fail,\n\t\t */\n\t\tWARN_ON_ONCE(ret);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\n\nstatic int cpuhp_invoke_callback(unsigned int cpu, enum cpuhp_state state,\n\t\t\t\t bool bringup, struct hlist_node *node,\n\t\t\t\t struct hlist_node **lastp)\n{\n\tstruct cpuhp_cpu_state *st = per_cpu_ptr(&cpuhp_state, cpu);\n\tstruct cpuhp_step *step = cpuhp_get_step(state);\n\tint (*cbm)(unsigned int cpu, struct hlist_node *node);\n\tint (*cb)(unsigned int cpu);\n\tint ret, cnt;\n\n\tif (st->fail == state) {\n\t\tst->fail = CPUHP_INVALID;\n\t\treturn -EAGAIN;\n\t}\n\n\tif (cpuhp_step_empty(bringup, step)) {\n\t\tWARN_ON_ONCE(1);\n\t\treturn 0;\n\t}\n\n\tif (!step->multi_instance) {\n\t\tWARN_ON_ONCE(lastp && *lastp);\n\t\tcb = bringup ? step->startup.single : step->teardown.single;\n\n\t\ttrace_cpuhp_enter(cpu, st->target, state, cb);\n\t\tret = cb(cpu);\n\t\ttrace_cpuhp_exit(cpu, st->state, state, ret);\n\t\treturn ret;\n\t}\n\tcbm = bringup ? step->startup.multi : step->teardown.multi;\n\n\t/* Single invocation for instance add/remove */\n\tif (node) {\n\t\tWARN_ON_ONCE(lastp && *lastp);\n\t\ttrace_cpuhp_multi_enter(cpu, st->target, state, cbm, node);\n\t\tret = cbm(cpu, node);\n\t\ttrace_cpuhp_exit(cpu, st->state, state, ret);\n\t\treturn ret;\n\t}\n\n\t/* State transition. Invoke on all instances */\n\tcnt = 0;\n\thlist_for_each(node, &step->list) {\n\t\tif (lastp && node == *lastp)\n\t\t\tbreak;\n\n\t\ttrace_cpuhp_multi_enter(cpu, st->target, state, cbm, node);\n\t\tret = cbm(cpu, node);\n\t\ttrace_cpuhp_exit(cpu, st->state, state, ret);\n\t\tif (ret) {\n\t\t\tif (!lastp)\n\t\t\t\tgoto err;\n\n\t\t\t*lastp = node;\n\t\t\treturn ret;\n\t\t}\n\t\tcnt++;\n\t}\n\tif (lastp)\n\t\t*lastp = NULL;\n\treturn 0;\nerr:\n\t/* Rollback the instances if one failed */\n\tcbm = !bringup ? step->startup.multi : step->teardown.multi;\n\tif (!cbm)\n\t\treturn ret;\n\n\thlist_for_each(node, &step->list) {\n\t\tif (!cnt--)\n\t\t\tbreak;\n\n\t\ttrace_cpuhp_multi_enter(cpu, st->target, state, cbm, node);\n\t\tret = cbm(cpu, node);\n\t\ttrace_cpuhp_exit(cpu, st->state, state, ret);\n\t\t/*\n\t\t * Rollback must not fail,\n\t\t */\n\t\tWARN_ON_ONCE(ret);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpuhp_next_state",
          "args": [
            "bringup",
            "&state",
            "st",
            "target"
          ],
          "line": 671
        },
        "resolved": true,
        "details": {
          "function_name": "cpuhp_next_state",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "638-661",
          "snippet": "static bool cpuhp_next_state(bool bringup,\n\t\t\t     enum cpuhp_state *state_to_run,\n\t\t\t     struct cpuhp_cpu_state *st,\n\t\t\t     enum cpuhp_state target)\n{\n\tdo {\n\t\tif (bringup) {\n\t\t\tif (st->state >= target)\n\t\t\t\treturn false;\n\n\t\t\t*state_to_run = ++st->state;\n\t\t} else {\n\t\t\tif (st->state <= target)\n\t\t\t\treturn false;\n\n\t\t\t*state_to_run = st->state--;\n\t\t}\n\n\t\tif (!cpuhp_step_empty(bringup, cpuhp_get_step(*state_to_run)))\n\t\t\tbreak;\n\t} while (true);\n\n\treturn true;\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\n\nstatic bool cpuhp_next_state(bool bringup,\n\t\t\t     enum cpuhp_state *state_to_run,\n\t\t\t     struct cpuhp_cpu_state *st,\n\t\t\t     enum cpuhp_state target)\n{\n\tdo {\n\t\tif (bringup) {\n\t\t\tif (st->state >= target)\n\t\t\t\treturn false;\n\n\t\t\t*state_to_run = ++st->state;\n\t\t} else {\n\t\t\tif (st->state <= target)\n\t\t\t\treturn false;\n\n\t\t\t*state_to_run = st->state--;\n\t\t}\n\n\t\tif (!cpuhp_step_empty(bringup, cpuhp_get_step(*state_to_run)))\n\t\t\tbreak;\n\t} while (true);\n\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\n\nstatic int cpuhp_invoke_callback_range(bool bringup,\n\t\t\t\t       unsigned int cpu,\n\t\t\t\t       struct cpuhp_cpu_state *st,\n\t\t\t\t       enum cpuhp_state target)\n{\n\tenum cpuhp_state state;\n\tint err = 0;\n\n\twhile (cpuhp_next_state(bringup, &state, st, target)) {\n\t\terr = cpuhp_invoke_callback(cpu, state, bringup, NULL, NULL);\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\n\treturn err;\n}"
  },
  {
    "function_name": "cpuhp_next_state",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
    "lines": "638-661",
    "snippet": "static bool cpuhp_next_state(bool bringup,\n\t\t\t     enum cpuhp_state *state_to_run,\n\t\t\t     struct cpuhp_cpu_state *st,\n\t\t\t     enum cpuhp_state target)\n{\n\tdo {\n\t\tif (bringup) {\n\t\t\tif (st->state >= target)\n\t\t\t\treturn false;\n\n\t\t\t*state_to_run = ++st->state;\n\t\t} else {\n\t\t\tif (st->state <= target)\n\t\t\t\treturn false;\n\n\t\t\t*state_to_run = st->state--;\n\t\t}\n\n\t\tif (!cpuhp_step_empty(bringup, cpuhp_get_step(*state_to_run)))\n\t\t\tbreak;\n\t} while (true);\n\n\treturn true;\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/scs.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sched/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpuhp_step_empty",
          "args": [
            "bringup",
            "cpuhp_get_step(*state_to_run)"
          ],
          "line": 656
        },
        "resolved": true,
        "details": {
          "function_name": "cpuhp_step_empty",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "149-152",
          "snippet": "static bool cpuhp_step_empty(bool bringup, struct cpuhp_step *step)\n{\n\treturn bringup ? !step->startup.single : !step->teardown.single;\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstatic bool cpuhp_step_empty(bool bringup, struct cpuhp_step *step)\n{\n\treturn bringup ? !step->startup.single : !step->teardown.single;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpuhp_get_step",
          "args": [
            "*state_to_run"
          ],
          "line": 656
        },
        "resolved": true,
        "details": {
          "function_name": "cpuhp_get_step",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "144-147",
          "snippet": "static struct cpuhp_step *cpuhp_get_step(enum cpuhp_state state)\n{\n\treturn cpuhp_hp_states + state;\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};",
            "static struct cpuhp_step cpuhp_hp_states[];",
            "static struct cpuhp_step cpuhp_hp_states[] = {\n\t[CPUHP_OFFLINE] = {\n\t\t.name\t\t\t= \"offline\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= NULL,\n\t},\n#ifdef CONFIG_SMP\n\t[CPUHP_CREATE_THREADS]= {\n\t\t.name\t\t\t= \"threads:prepare\",\n\t\t.startup.single\t\t= smpboot_create_threads,\n\t\t.teardown.single\t= NULL,\n\t\t.cant_stop\t\t= true,\n\t},\n\t[CPUHP_PERF_PREPARE] = {\n\t\t.name\t\t\t= \"perf:prepare\",\n\t\t.startup.single\t\t= perf_event_init_cpu,\n\t\t.teardown.single\t= perf_event_exit_cpu,\n\t},\n\t[CPUHP_WORKQUEUE_PREP] = {\n\t\t.name\t\t\t= \"workqueue:prepare\",\n\t\t.startup.single\t\t= workqueue_prepare_cpu,\n\t\t.teardown.single\t= NULL,\n\t},\n\t[CPUHP_HRTIMERS_PREPARE] = {\n\t\t.name\t\t\t= \"hrtimers:prepare\",\n\t\t.startup.single\t\t= hrtimers_prepare_cpu,\n\t\t.teardown.single\t= hrtimers_dead_cpu,\n\t},\n\t[CPUHP_SMPCFD_PREPARE] = {\n\t\t.name\t\t\t= \"smpcfd:prepare\",\n\t\t.startup.single\t\t= smpcfd_prepare_cpu,\n\t\t.teardown.single\t= smpcfd_dead_cpu,\n\t},\n\t[CPUHP_RELAY_PREPARE] = {\n\t\t.name\t\t\t= \"relay:prepare\",\n\t\t.startup.single\t\t= relay_prepare_cpu,\n\t\t.teardown.single\t= NULL,\n\t},\n\t[CPUHP_SLAB_PREPARE] = {\n\t\t.name\t\t\t= \"slab:prepare\",\n\t\t.startup.single\t\t= slab_prepare_cpu,\n\t\t.teardown.single\t= slab_dead_cpu,\n\t},\n\t[CPUHP_RCUTREE_PREP] = {\n\t\t.name\t\t\t= \"RCU/tree:prepare\",\n\t\t.startup.single\t\t= rcutree_prepare_cpu,\n\t\t.teardown.single\t= rcutree_dead_cpu,\n\t},\n\t/*\n\t * On the tear-down path, timers_dead_cpu() must be invoked\n\t * before blk_mq_queue_reinit_notify() from notify_dead(),\n\t * otherwise a RCU stall occurs.\n\t */\n\t[CPUHP_TIMERS_PREPARE] = {\n\t\t.name\t\t\t= \"timers:prepare\",\n\t\t.startup.single\t\t= timers_prepare_cpu,\n\t\t.teardown.single\t= timers_dead_cpu,\n\t},\n\t/* Kicks the plugged cpu into life */\n\t[CPUHP_BRINGUP_CPU] = {\n\t\t.name\t\t\t= \"cpu:bringup\",\n\t\t.startup.single\t\t= bringup_cpu,\n\t\t.teardown.single\t= finish_cpu,\n\t\t.cant_stop\t\t= true,\n\t},\n\t/* Final state before CPU kills itself */\n\t[CPUHP_AP_IDLE_DEAD] = {\n\t\t.name\t\t\t= \"idle:dead\",\n\t},\n\t/*\n\t * Last state before CPU enters the idle loop to die. Transient state\n\t * for synchronization.\n\t */\n\t[CPUHP_AP_OFFLINE] = {\n\t\t.name\t\t\t= \"ap:offline\",\n\t\t.cant_stop\t\t= true,\n\t},\n\t/* First state is scheduler control. Interrupts are disabled */\n\t[CPUHP_AP_SCHED_STARTING] = {\n\t\t.name\t\t\t= \"sched:starting\",\n\t\t.startup.single\t\t= sched_cpu_starting,\n\t\t.teardown.single\t= sched_cpu_dying,\n\t},\n\t[CPUHP_AP_RCUTREE_DYING] = {\n\t\t.name\t\t\t= \"RCU/tree:dying\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= rcutree_dying_cpu,\n\t},\n\t[CPUHP_AP_SMPCFD_DYING] = {\n\t\t.name\t\t\t= \"smpcfd:dying\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= smpcfd_dying_cpu,\n\t},\n\t/* Entry state on starting. Interrupts enabled from here on. Transient\n\t * state for synchronsization */\n\t[CPUHP_AP_ONLINE] = {\n\t\t.name\t\t\t= \"ap:online\",\n\t},\n\t/*\n\t * Handled on control processor until the plugged processor manages\n\t * this itself.\n\t */\n\t[CPUHP_TEARDOWN_CPU] = {\n\t\t.name\t\t\t= \"cpu:teardown\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= takedown_cpu,\n\t\t.cant_stop\t\t= true,\n\t},\n\n\t[CPUHP_AP_SCHED_WAIT_EMPTY] = {\n\t\t.name\t\t\t= \"sched:waitempty\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= sched_cpu_wait_empty,\n\t},\n\n\t/* Handle smpboot threads park/unpark */\n\t[CPUHP_AP_SMPBOOT_THREADS] = {\n\t\t.name\t\t\t= \"smpboot/threads:online\",\n\t\t.startup.single\t\t= smpboot_unpark_threads,\n\t\t.teardown.single\t= smpboot_park_threads,\n\t},\n\t[CPUHP_AP_IRQ_AFFINITY_ONLINE] = {\n\t\t.name\t\t\t= \"irq/affinity:online\",\n\t\t.startup.single\t\t= irq_affinity_online_cpu,\n\t\t.teardown.single\t= NULL,\n\t},\n\t[CPUHP_AP_PERF_ONLINE] = {\n\t\t.name\t\t\t= \"perf:online\",\n\t\t.startup.single\t\t= perf_event_init_cpu,\n\t\t.teardown.single\t= perf_event_exit_cpu,\n\t},\n\t[CPUHP_AP_WATCHDOG_ONLINE] = {\n\t\t.name\t\t\t= \"lockup_detector:online\",\n\t\t.startup.single\t\t= lockup_detector_online_cpu,\n\t\t.teardown.single\t= lockup_detector_offline_cpu,\n\t},\n\t[CPUHP_AP_WORKQUEUE_ONLINE] = {\n\t\t.name\t\t\t= \"workqueue:online\",\n\t\t.startup.single\t\t= workqueue_online_cpu,\n\t\t.teardown.single\t= workqueue_offline_cpu,\n\t},\n\t[CPUHP_AP_RCUTREE_ONLINE] = {\n\t\t.name\t\t\t= \"RCU/tree:online\",\n\t\t.startup.single\t\t= rcutree_online_cpu,\n\t\t.teardown.single\t= rcutree_offline_cpu,\n\t},\n#endif\n\t/*\n\t * The dynamically registered state space is here\n\t */\n\n#ifdef CONFIG_SMP\n\t/* Last state is scheduler control setting the cpu active */\n\t[CPUHP_AP_ACTIVE] = {\n\t\t.name\t\t\t= \"sched:active\",\n\t\t.startup.single\t\t= sched_cpu_activate,\n\t\t.teardown.single\t= sched_cpu_deactivate,\n\t},\n#endif\n\n\t/* CPU is fully up and running. */\n\t[CPUHP_ONLINE] = {\n\t\t.name\t\t\t= \"online\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= NULL,\n\t},\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\nstatic struct cpuhp_step cpuhp_hp_states[];\nstatic struct cpuhp_step cpuhp_hp_states[] = {\n\t[CPUHP_OFFLINE] = {\n\t\t.name\t\t\t= \"offline\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= NULL,\n\t},\n#ifdef CONFIG_SMP\n\t[CPUHP_CREATE_THREADS]= {\n\t\t.name\t\t\t= \"threads:prepare\",\n\t\t.startup.single\t\t= smpboot_create_threads,\n\t\t.teardown.single\t= NULL,\n\t\t.cant_stop\t\t= true,\n\t},\n\t[CPUHP_PERF_PREPARE] = {\n\t\t.name\t\t\t= \"perf:prepare\",\n\t\t.startup.single\t\t= perf_event_init_cpu,\n\t\t.teardown.single\t= perf_event_exit_cpu,\n\t},\n\t[CPUHP_WORKQUEUE_PREP] = {\n\t\t.name\t\t\t= \"workqueue:prepare\",\n\t\t.startup.single\t\t= workqueue_prepare_cpu,\n\t\t.teardown.single\t= NULL,\n\t},\n\t[CPUHP_HRTIMERS_PREPARE] = {\n\t\t.name\t\t\t= \"hrtimers:prepare\",\n\t\t.startup.single\t\t= hrtimers_prepare_cpu,\n\t\t.teardown.single\t= hrtimers_dead_cpu,\n\t},\n\t[CPUHP_SMPCFD_PREPARE] = {\n\t\t.name\t\t\t= \"smpcfd:prepare\",\n\t\t.startup.single\t\t= smpcfd_prepare_cpu,\n\t\t.teardown.single\t= smpcfd_dead_cpu,\n\t},\n\t[CPUHP_RELAY_PREPARE] = {\n\t\t.name\t\t\t= \"relay:prepare\",\n\t\t.startup.single\t\t= relay_prepare_cpu,\n\t\t.teardown.single\t= NULL,\n\t},\n\t[CPUHP_SLAB_PREPARE] = {\n\t\t.name\t\t\t= \"slab:prepare\",\n\t\t.startup.single\t\t= slab_prepare_cpu,\n\t\t.teardown.single\t= slab_dead_cpu,\n\t},\n\t[CPUHP_RCUTREE_PREP] = {\n\t\t.name\t\t\t= \"RCU/tree:prepare\",\n\t\t.startup.single\t\t= rcutree_prepare_cpu,\n\t\t.teardown.single\t= rcutree_dead_cpu,\n\t},\n\t/*\n\t * On the tear-down path, timers_dead_cpu() must be invoked\n\t * before blk_mq_queue_reinit_notify() from notify_dead(),\n\t * otherwise a RCU stall occurs.\n\t */\n\t[CPUHP_TIMERS_PREPARE] = {\n\t\t.name\t\t\t= \"timers:prepare\",\n\t\t.startup.single\t\t= timers_prepare_cpu,\n\t\t.teardown.single\t= timers_dead_cpu,\n\t},\n\t/* Kicks the plugged cpu into life */\n\t[CPUHP_BRINGUP_CPU] = {\n\t\t.name\t\t\t= \"cpu:bringup\",\n\t\t.startup.single\t\t= bringup_cpu,\n\t\t.teardown.single\t= finish_cpu,\n\t\t.cant_stop\t\t= true,\n\t},\n\t/* Final state before CPU kills itself */\n\t[CPUHP_AP_IDLE_DEAD] = {\n\t\t.name\t\t\t= \"idle:dead\",\n\t},\n\t/*\n\t * Last state before CPU enters the idle loop to die. Transient state\n\t * for synchronization.\n\t */\n\t[CPUHP_AP_OFFLINE] = {\n\t\t.name\t\t\t= \"ap:offline\",\n\t\t.cant_stop\t\t= true,\n\t},\n\t/* First state is scheduler control. Interrupts are disabled */\n\t[CPUHP_AP_SCHED_STARTING] = {\n\t\t.name\t\t\t= \"sched:starting\",\n\t\t.startup.single\t\t= sched_cpu_starting,\n\t\t.teardown.single\t= sched_cpu_dying,\n\t},\n\t[CPUHP_AP_RCUTREE_DYING] = {\n\t\t.name\t\t\t= \"RCU/tree:dying\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= rcutree_dying_cpu,\n\t},\n\t[CPUHP_AP_SMPCFD_DYING] = {\n\t\t.name\t\t\t= \"smpcfd:dying\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= smpcfd_dying_cpu,\n\t},\n\t/* Entry state on starting. Interrupts enabled from here on. Transient\n\t * state for synchronsization */\n\t[CPUHP_AP_ONLINE] = {\n\t\t.name\t\t\t= \"ap:online\",\n\t},\n\t/*\n\t * Handled on control processor until the plugged processor manages\n\t * this itself.\n\t */\n\t[CPUHP_TEARDOWN_CPU] = {\n\t\t.name\t\t\t= \"cpu:teardown\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= takedown_cpu,\n\t\t.cant_stop\t\t= true,\n\t},\n\n\t[CPUHP_AP_SCHED_WAIT_EMPTY] = {\n\t\t.name\t\t\t= \"sched:waitempty\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= sched_cpu_wait_empty,\n\t},\n\n\t/* Handle smpboot threads park/unpark */\n\t[CPUHP_AP_SMPBOOT_THREADS] = {\n\t\t.name\t\t\t= \"smpboot/threads:online\",\n\t\t.startup.single\t\t= smpboot_unpark_threads,\n\t\t.teardown.single\t= smpboot_park_threads,\n\t},\n\t[CPUHP_AP_IRQ_AFFINITY_ONLINE] = {\n\t\t.name\t\t\t= \"irq/affinity:online\",\n\t\t.startup.single\t\t= irq_affinity_online_cpu,\n\t\t.teardown.single\t= NULL,\n\t},\n\t[CPUHP_AP_PERF_ONLINE] = {\n\t\t.name\t\t\t= \"perf:online\",\n\t\t.startup.single\t\t= perf_event_init_cpu,\n\t\t.teardown.single\t= perf_event_exit_cpu,\n\t},\n\t[CPUHP_AP_WATCHDOG_ONLINE] = {\n\t\t.name\t\t\t= \"lockup_detector:online\",\n\t\t.startup.single\t\t= lockup_detector_online_cpu,\n\t\t.teardown.single\t= lockup_detector_offline_cpu,\n\t},\n\t[CPUHP_AP_WORKQUEUE_ONLINE] = {\n\t\t.name\t\t\t= \"workqueue:online\",\n\t\t.startup.single\t\t= workqueue_online_cpu,\n\t\t.teardown.single\t= workqueue_offline_cpu,\n\t},\n\t[CPUHP_AP_RCUTREE_ONLINE] = {\n\t\t.name\t\t\t= \"RCU/tree:online\",\n\t\t.startup.single\t\t= rcutree_online_cpu,\n\t\t.teardown.single\t= rcutree_offline_cpu,\n\t},\n#endif\n\t/*\n\t * The dynamically registered state space is here\n\t */\n\n#ifdef CONFIG_SMP\n\t/* Last state is scheduler control setting the cpu active */\n\t[CPUHP_AP_ACTIVE] = {\n\t\t.name\t\t\t= \"sched:active\",\n\t\t.startup.single\t\t= sched_cpu_activate,\n\t\t.teardown.single\t= sched_cpu_deactivate,\n\t},\n#endif\n\n\t/* CPU is fully up and running. */\n\t[CPUHP_ONLINE] = {\n\t\t.name\t\t\t= \"online\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= NULL,\n\t},\n};\n\nstatic struct cpuhp_step *cpuhp_get_step(enum cpuhp_state state)\n{\n\treturn cpuhp_hp_states + state;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\n\nstatic bool cpuhp_next_state(bool bringup,\n\t\t\t     enum cpuhp_state *state_to_run,\n\t\t\t     struct cpuhp_cpu_state *st,\n\t\t\t     enum cpuhp_state target)\n{\n\tdo {\n\t\tif (bringup) {\n\t\t\tif (st->state >= target)\n\t\t\t\treturn false;\n\n\t\t\t*state_to_run = ++st->state;\n\t\t} else {\n\t\t\tif (st->state <= target)\n\t\t\t\treturn false;\n\n\t\t\t*state_to_run = st->state--;\n\t\t}\n\n\t\tif (!cpuhp_step_empty(bringup, cpuhp_get_step(*state_to_run)))\n\t\t\tbreak;\n\t} while (true);\n\n\treturn true;\n}"
  },
  {
    "function_name": "finish_cpu",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
    "lines": "612-625",
    "snippet": "static int finish_cpu(unsigned int cpu)\n{\n\tstruct task_struct *idle = idle_thread_get(cpu);\n\tstruct mm_struct *mm = idle->active_mm;\n\n\t/*\n\t * idle_task_exit() will have switched to &init_mm, now\n\t * clean up any remaining active_mm state.\n\t */\n\tif (mm != &init_mm)\n\t\tidle->active_mm = &init_mm;\n\tmmdrop(mm);\n\treturn 0;\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/scs.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sched/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mmdrop",
          "args": [
            "mm"
          ],
          "line": 623
        },
        "resolved": true,
        "details": {
          "function_name": "mmdrop_async",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/fork.c",
          "lines": "718-724",
          "snippet": "static void mmdrop_async(struct mm_struct *mm)\n{\n\tif (unlikely(atomic_dec_and_test(&mm->mm_count))) {\n\t\tINIT_WORK(&mm->async_put_work, mmdrop_async_fn);\n\t\tschedule_work(&mm->async_put_work);\n\t}\n}",
          "includes": [
            "#include <linux/init_task.h>",
            "#include <trace/events/task.h>",
            "#include <trace/events/sched.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <linux/bpf.h>",
            "#include <linux/io_uring.h>",
            "#include <linux/scs.h>",
            "#include <linux/kasan.h>",
            "#include <linux/stackleak.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/kcov.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/compiler.h>",
            "#include <linux/aio.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/oom.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/magic.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/tty.h>",
            "#include <linux/random.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/acct.h>",
            "#include <linux/ksm.h>",
            "#include <linux/rmap.h>",
            "#include <linux/profile.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/kthread.h>",
            "#include <linux/compat.h>",
            "#include <linux/futex.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mman.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/sem.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>",
            "#include <linux/unistd.h>",
            "#include <linux/init.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/anon_inodes.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __latent_entropy struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/init_task.h>\n#include <trace/events/task.h>\n#include <trace/events/sched.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <linux/bpf.h>\n#include <linux/io_uring.h>\n#include <linux/scs.h>\n#include <linux/kasan.h>\n#include <linux/stackleak.h>\n#include <linux/thread_info.h>\n#include <linux/livepatch.h>\n#include <linux/kcov.h>\n#include <linux/sysctl.h>\n#include <linux/compiler.h>\n#include <linux/aio.h>\n#include <linux/uprobes.h>\n#include <linux/signalfd.h>\n#include <linux/khugepaged.h>\n#include <linux/oom.h>\n#include <linux/user-return-notifier.h>\n#include <linux/posix-timers.h>\n#include <linux/perf_event.h>\n#include <linux/magic.h>\n#include <linux/fs_struct.h>\n#include <linux/tty.h>\n#include <linux/random.h>\n#include <linux/taskstats_kern.h>\n#include <linux/delayacct.h>\n#include <linux/freezer.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/acct.h>\n#include <linux/ksm.h>\n#include <linux/rmap.h>\n#include <linux/profile.h>\n#include <linux/proc_fs.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/ptrace.h>\n#include <linux/rcupdate.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/kthread.h>\n#include <linux/compat.h>\n#include <linux/futex.h>\n#include <linux/jiffies.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/seccomp.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/cgroup.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/nsproxy.h>\n#include <linux/vmacache.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mman.h>\n#include <linux/binfmts.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/sem.h>\n#include <linux/mempolicy.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/unistd.h>\n#include <linux/init.h>\n#include <linux/rtmutex.h>\n#include <linux/seq_file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/user.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/anon_inodes.h>\n\nstatic __latent_entropy struct;\n\nstatic void mmdrop_async(struct mm_struct *mm)\n{\n\tif (unlikely(atomic_dec_and_test(&mm->mm_count))) {\n\t\tINIT_WORK(&mm->async_put_work, mmdrop_async_fn);\n\t\tschedule_work(&mm->async_put_work);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "idle_thread_get",
          "args": [
            "cpu"
          ],
          "line": 614
        },
        "resolved": true,
        "details": {
          "function_name": "idle_thread_get",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/smpboot.c",
          "lines": "30-37",
          "snippet": "struct task_struct *idle_thread_get(unsigned int cpu)\n{\n\tstruct task_struct *tsk = per_cpu(idle_threads, cpu);\n\n\tif (!tsk)\n\t\treturn ERR_PTR(-ENOMEM);\n\treturn tsk;\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <linux/smpboot.h>",
            "#include <linux/kthread.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/delay.h>",
            "#include <linux/smp.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <linux/smpboot.h>\n#include <linux/kthread.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstruct task_struct *idle_thread_get(unsigned int cpu)\n{\n\tstruct task_struct *tsk = per_cpu(idle_threads, cpu);\n\n\tif (!tsk)\n\t\treturn ERR_PTR(-ENOMEM);\n\treturn tsk;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstatic int finish_cpu(unsigned int cpu)\n{\n\tstruct task_struct *idle = idle_thread_get(cpu);\n\tstruct mm_struct *mm = idle->active_mm;\n\n\t/*\n\t * idle_task_exit() will have switched to &init_mm, now\n\t * clean up any remaining active_mm state.\n\t */\n\tif (mm != &init_mm)\n\t\tidle->active_mm = &init_mm;\n\tmmdrop(mm);\n\treturn 0;\n}"
  },
  {
    "function_name": "bringup_cpu",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
    "lines": "586-610",
    "snippet": "static int bringup_cpu(unsigned int cpu)\n{\n\tstruct task_struct *idle = idle_thread_get(cpu);\n\tint ret;\n\n\t/*\n\t * Reset stale stack state from the last time this CPU was online.\n\t */\n\tscs_task_reset(idle);\n\tkasan_unpoison_task_stack(idle);\n\n\t/*\n\t * Some architectures have to walk the irq descriptors to\n\t * setup the vector space for the cpu which comes online.\n\t * Prevent irq alloc/free across the bringup.\n\t */\n\tirq_lock_sparse();\n\n\t/* Arch-specific enabling code. */\n\tret = __cpu_up(cpu, idle);\n\tirq_unlock_sparse();\n\tif (ret)\n\t\treturn ret;\n\treturn bringup_wait_for_ap(cpu);\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/scs.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sched/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bringup_wait_for_ap",
          "args": [
            "cpu"
          ],
          "line": 609
        },
        "resolved": true,
        "details": {
          "function_name": "bringup_wait_for_ap",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "558-584",
          "snippet": "static int bringup_wait_for_ap(unsigned int cpu)\n{\n\tstruct cpuhp_cpu_state *st = per_cpu_ptr(&cpuhp_state, cpu);\n\n\t/* Wait for the CPU to reach CPUHP_AP_ONLINE_IDLE */\n\twait_for_ap_thread(st, true);\n\tif (WARN_ON_ONCE((!cpu_online(cpu))))\n\t\treturn -ECANCELED;\n\n\t/* Unpark the hotplug thread of the target cpu */\n\tkthread_unpark(st->thread);\n\n\t/*\n\t * SMT soft disabling on X86 requires to bring the CPU out of the\n\t * BIOS 'wait for SIPI' state in order to set the CR4.MCE bit.  The\n\t * CPU marked itself as booted_once in notify_cpu_starting() so the\n\t * cpu_smt_allowed() check will now return false if this is not the\n\t * primary sibling.\n\t */\n\tif (!cpu_smt_allowed(cpu))\n\t\treturn -ECANCELED;\n\n\tif (st->target <= CPUHP_AP_ONLINE_IDLE)\n\t\treturn 0;\n\n\treturn cpuhp_kick_ap(st, st->target);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\n\nstatic int bringup_wait_for_ap(unsigned int cpu)\n{\n\tstruct cpuhp_cpu_state *st = per_cpu_ptr(&cpuhp_state, cpu);\n\n\t/* Wait for the CPU to reach CPUHP_AP_ONLINE_IDLE */\n\twait_for_ap_thread(st, true);\n\tif (WARN_ON_ONCE((!cpu_online(cpu))))\n\t\treturn -ECANCELED;\n\n\t/* Unpark the hotplug thread of the target cpu */\n\tkthread_unpark(st->thread);\n\n\t/*\n\t * SMT soft disabling on X86 requires to bring the CPU out of the\n\t * BIOS 'wait for SIPI' state in order to set the CR4.MCE bit.  The\n\t * CPU marked itself as booted_once in notify_cpu_starting() so the\n\t * cpu_smt_allowed() check will now return false if this is not the\n\t * primary sibling.\n\t */\n\tif (!cpu_smt_allowed(cpu))\n\t\treturn -ECANCELED;\n\n\tif (st->target <= CPUHP_AP_ONLINE_IDLE)\n\t\treturn 0;\n\n\treturn cpuhp_kick_ap(st, st->target);\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_unlock_sparse",
          "args": [],
          "line": 606
        },
        "resolved": true,
        "details": {
          "function_name": "irq_unlock_sparse",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/irqdesc.c",
          "lines": "384-387",
          "snippet": "void irq_unlock_sparse(void)\n{\n\tmutex_unlock(&sparse_irq_lock);\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/sysfs.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(sparse_irq_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/sysfs.h>\n#include <linux/irqdomain.h>\n#include <linux/bitmap.h>\n#include <linux/radix-tree.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/irq.h>\n\nstatic DEFINE_MUTEX(sparse_irq_lock);\n\nvoid irq_unlock_sparse(void)\n{\n\tmutex_unlock(&sparse_irq_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__cpu_up",
          "args": [
            "cpu",
            "idle"
          ],
          "line": 605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_lock_sparse",
          "args": [],
          "line": 602
        },
        "resolved": true,
        "details": {
          "function_name": "irq_lock_sparse",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/irqdesc.c",
          "lines": "379-382",
          "snippet": "void irq_lock_sparse(void)\n{\n\tmutex_lock(&sparse_irq_lock);\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/sysfs.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(sparse_irq_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/sysfs.h>\n#include <linux/irqdomain.h>\n#include <linux/bitmap.h>\n#include <linux/radix-tree.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/irq.h>\n\nstatic DEFINE_MUTEX(sparse_irq_lock);\n\nvoid irq_lock_sparse(void)\n{\n\tmutex_lock(&sparse_irq_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kasan_unpoison_task_stack",
          "args": [
            "idle"
          ],
          "line": 595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scs_task_reset",
          "args": [
            "idle"
          ],
          "line": 594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "idle_thread_get",
          "args": [
            "cpu"
          ],
          "line": 588
        },
        "resolved": true,
        "details": {
          "function_name": "idle_thread_get",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/smpboot.c",
          "lines": "30-37",
          "snippet": "struct task_struct *idle_thread_get(unsigned int cpu)\n{\n\tstruct task_struct *tsk = per_cpu(idle_threads, cpu);\n\n\tif (!tsk)\n\t\treturn ERR_PTR(-ENOMEM);\n\treturn tsk;\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <linux/smpboot.h>",
            "#include <linux/kthread.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/delay.h>",
            "#include <linux/smp.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <linux/smpboot.h>\n#include <linux/kthread.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstruct task_struct *idle_thread_get(unsigned int cpu)\n{\n\tstruct task_struct *tsk = per_cpu(idle_threads, cpu);\n\n\tif (!tsk)\n\t\treturn ERR_PTR(-ENOMEM);\n\treturn tsk;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstatic int bringup_cpu(unsigned int cpu)\n{\n\tstruct task_struct *idle = idle_thread_get(cpu);\n\tint ret;\n\n\t/*\n\t * Reset stale stack state from the last time this CPU was online.\n\t */\n\tscs_task_reset(idle);\n\tkasan_unpoison_task_stack(idle);\n\n\t/*\n\t * Some architectures have to walk the irq descriptors to\n\t * setup the vector space for the cpu which comes online.\n\t * Prevent irq alloc/free across the bringup.\n\t */\n\tirq_lock_sparse();\n\n\t/* Arch-specific enabling code. */\n\tret = __cpu_up(cpu, idle);\n\tirq_unlock_sparse();\n\tif (ret)\n\t\treturn ret;\n\treturn bringup_wait_for_ap(cpu);\n}"
  },
  {
    "function_name": "bringup_wait_for_ap",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
    "lines": "558-584",
    "snippet": "static int bringup_wait_for_ap(unsigned int cpu)\n{\n\tstruct cpuhp_cpu_state *st = per_cpu_ptr(&cpuhp_state, cpu);\n\n\t/* Wait for the CPU to reach CPUHP_AP_ONLINE_IDLE */\n\twait_for_ap_thread(st, true);\n\tif (WARN_ON_ONCE((!cpu_online(cpu))))\n\t\treturn -ECANCELED;\n\n\t/* Unpark the hotplug thread of the target cpu */\n\tkthread_unpark(st->thread);\n\n\t/*\n\t * SMT soft disabling on X86 requires to bring the CPU out of the\n\t * BIOS 'wait for SIPI' state in order to set the CR4.MCE bit.  The\n\t * CPU marked itself as booted_once in notify_cpu_starting() so the\n\t * cpu_smt_allowed() check will now return false if this is not the\n\t * primary sibling.\n\t */\n\tif (!cpu_smt_allowed(cpu))\n\t\treturn -ECANCELED;\n\n\tif (st->target <= CPUHP_AP_ONLINE_IDLE)\n\t\treturn 0;\n\n\treturn cpuhp_kick_ap(st, st->target);\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/scs.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sched/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpuhp_kick_ap",
          "args": [
            "st",
            "st->target"
          ],
          "line": 583
        },
        "resolved": true,
        "details": {
          "function_name": "cpuhp_kick_ap",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "543-556",
          "snippet": "static int cpuhp_kick_ap(struct cpuhp_cpu_state *st, enum cpuhp_state target)\n{\n\tenum cpuhp_state prev_state;\n\tint ret;\n\n\tprev_state = cpuhp_set_state(st, target);\n\t__cpuhp_kick_ap(st);\n\tif ((ret = st->result)) {\n\t\tcpuhp_reset_state(st, prev_state);\n\t\t__cpuhp_kick_ap(st);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\n\nstatic int cpuhp_kick_ap(struct cpuhp_cpu_state *st, enum cpuhp_state target)\n{\n\tenum cpuhp_state prev_state;\n\tint ret;\n\n\tprev_state = cpuhp_set_state(st, target);\n\t__cpuhp_kick_ap(st);\n\tif ((ret = st->result)) {\n\t\tcpuhp_reset_state(st, prev_state);\n\t\t__cpuhp_kick_ap(st);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_smt_allowed",
          "args": [
            "cpu"
          ],
          "line": 577
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_smt_allowed",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "473-473",
          "snippet": "static inline bool cpu_smt_allowed(unsigned int cpu) { return true; }",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstatic inline bool cpu_smt_allowed(unsigned int cpu) { return true; }"
        }
      },
      {
        "call_info": {
          "callee": "kthread_unpark",
          "args": [
            "st->thread"
          ],
          "line": 568
        },
        "resolved": true,
        "details": {
          "function_name": "kthread_unpark",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
          "lines": "622-638",
          "snippet": "void kthread_unpark(struct task_struct *k)\n{\n\tstruct kthread *kthread = to_kthread(k);\n\n\t/*\n\t * Newly created kthread was parked when the CPU was offline.\n\t * The binding was lost and we need to set it again.\n\t */\n\tif (test_bit(KTHREAD_IS_PER_CPU, &kthread->flags))\n\t\t__kthread_bind(k, kthread->cpu, TASK_PARKED);\n\n\tclear_bit(KTHREAD_SHOULD_PARK, &kthread->flags);\n\t/*\n\t * __kthread_parkme() will either see !SHOULD_PARK or get the wakeup.\n\t */\n\twake_up_state(k, TASK_PARKED);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/numa.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mm.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nvoid kthread_unpark(struct task_struct *k)\n{\n\tstruct kthread *kthread = to_kthread(k);\n\n\t/*\n\t * Newly created kthread was parked when the CPU was offline.\n\t * The binding was lost and we need to set it again.\n\t */\n\tif (test_bit(KTHREAD_IS_PER_CPU, &kthread->flags))\n\t\t__kthread_bind(k, kthread->cpu, TASK_PARKED);\n\n\tclear_bit(KTHREAD_SHOULD_PARK, &kthread->flags);\n\t/*\n\t * __kthread_parkme() will either see !SHOULD_PARK or get the wakeup.\n\t */\n\twake_up_state(k, TASK_PARKED);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "(!cpu_online(cpu))"
          ],
          "line": 564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_online",
          "args": [
            "cpu"
          ],
          "line": 564
        },
        "resolved": true,
        "details": {
          "function_name": "init_cpu_online",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "2616-2619",
          "snippet": "void init_cpu_online(const struct cpumask *src)\n{\n\tcpumask_copy(&__cpu_online_mask, src);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct cpumask __cpu_online_mask"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstruct cpumask __cpu_online_mask;\n\nvoid init_cpu_online(const struct cpumask *src)\n{\n\tcpumask_copy(&__cpu_online_mask, src);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_for_ap_thread",
          "args": [
            "st",
            "true"
          ],
          "line": 563
        },
        "resolved": true,
        "details": {
          "function_name": "wait_for_ap_thread",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "258-262",
          "snippet": "static inline void wait_for_ap_thread(struct cpuhp_cpu_state *st, bool bringup)\n{\n\tstruct completion *done = bringup ? &st->done_up : &st->done_down;\n\twait_for_completion(done);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstatic inline void wait_for_ap_thread(struct cpuhp_cpu_state *st, bool bringup)\n{\n\tstruct completion *done = bringup ? &st->done_up : &st->done_down;\n\twait_for_completion(done);\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "&cpuhp_state",
            "cpu"
          ],
          "line": 560
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\n\nstatic int bringup_wait_for_ap(unsigned int cpu)\n{\n\tstruct cpuhp_cpu_state *st = per_cpu_ptr(&cpuhp_state, cpu);\n\n\t/* Wait for the CPU to reach CPUHP_AP_ONLINE_IDLE */\n\twait_for_ap_thread(st, true);\n\tif (WARN_ON_ONCE((!cpu_online(cpu))))\n\t\treturn -ECANCELED;\n\n\t/* Unpark the hotplug thread of the target cpu */\n\tkthread_unpark(st->thread);\n\n\t/*\n\t * SMT soft disabling on X86 requires to bring the CPU out of the\n\t * BIOS 'wait for SIPI' state in order to set the CR4.MCE bit.  The\n\t * CPU marked itself as booted_once in notify_cpu_starting() so the\n\t * cpu_smt_allowed() check will now return false if this is not the\n\t * primary sibling.\n\t */\n\tif (!cpu_smt_allowed(cpu))\n\t\treturn -ECANCELED;\n\n\tif (st->target <= CPUHP_AP_ONLINE_IDLE)\n\t\treturn 0;\n\n\treturn cpuhp_kick_ap(st, st->target);\n}"
  },
  {
    "function_name": "cpuhp_kick_ap",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
    "lines": "543-556",
    "snippet": "static int cpuhp_kick_ap(struct cpuhp_cpu_state *st, enum cpuhp_state target)\n{\n\tenum cpuhp_state prev_state;\n\tint ret;\n\n\tprev_state = cpuhp_set_state(st, target);\n\t__cpuhp_kick_ap(st);\n\tif ((ret = st->result)) {\n\t\tcpuhp_reset_state(st, prev_state);\n\t\t__cpuhp_kick_ap(st);\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/scs.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sched/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__cpuhp_kick_ap",
          "args": [
            "st"
          ],
          "line": 552
        },
        "resolved": true,
        "details": {
          "function_name": "__cpuhp_kick_ap",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "527-541",
          "snippet": "static void __cpuhp_kick_ap(struct cpuhp_cpu_state *st)\n{\n\tif (!st->single && st->state == st->target)\n\t\treturn;\n\n\tst->result = 0;\n\t/*\n\t * Make sure the above stores are visible before should_run becomes\n\t * true. Paired with the mb() above in cpuhp_thread_fun()\n\t */\n\tsmp_mb();\n\tst->should_run = true;\n\twake_up_process(st->thread);\n\twait_for_ap_thread(st, st->bringup);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstatic void __cpuhp_kick_ap(struct cpuhp_cpu_state *st)\n{\n\tif (!st->single && st->state == st->target)\n\t\treturn;\n\n\tst->result = 0;\n\t/*\n\t * Make sure the above stores are visible before should_run becomes\n\t * true. Paired with the mb() above in cpuhp_thread_fun()\n\t */\n\tsmp_mb();\n\tst->should_run = true;\n\twake_up_process(st->thread);\n\twait_for_ap_thread(st, st->bringup);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpuhp_reset_state",
          "args": [
            "st",
            "prev_state"
          ],
          "line": 551
        },
        "resolved": true,
        "details": {
          "function_name": "cpuhp_reset_state",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "494-524",
          "snippet": "static inline void\ncpuhp_reset_state(struct cpuhp_cpu_state *st, enum cpuhp_state prev_state)\n{\n\tbool bringup = !st->bringup;\n\n\tst->target = prev_state;\n\n\t/*\n\t * Already rolling back. No need invert the bringup value or to change\n\t * the current state.\n\t */\n\tif (st->rollback)\n\t\treturn;\n\n\tst->rollback = true;\n\n\t/*\n\t * If we have st->last we need to undo partial multi_instance of this\n\t * state first. Otherwise start undo at the previous state.\n\t */\n\tif (!st->last) {\n\t\tif (st->bringup)\n\t\t\tst->state--;\n\t\telse\n\t\t\tst->state++;\n\t}\n\n\tst->bringup = bringup;\n\tif (cpu_dying(st->cpu) != !bringup)\n\t\tset_cpu_dying(st->cpu, !bringup);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\n\nstatic inline void\ncpuhp_reset_state(struct cpuhp_cpu_state *st, enum cpuhp_state prev_state)\n{\n\tbool bringup = !st->bringup;\n\n\tst->target = prev_state;\n\n\t/*\n\t * Already rolling back. No need invert the bringup value or to change\n\t * the current state.\n\t */\n\tif (st->rollback)\n\t\treturn;\n\n\tst->rollback = true;\n\n\t/*\n\t * If we have st->last we need to undo partial multi_instance of this\n\t * state first. Otherwise start undo at the previous state.\n\t */\n\tif (!st->last) {\n\t\tif (st->bringup)\n\t\t\tst->state--;\n\t\telse\n\t\t\tst->state++;\n\t}\n\n\tst->bringup = bringup;\n\tif (cpu_dying(st->cpu) != !bringup)\n\t\tset_cpu_dying(st->cpu, !bringup);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpuhp_set_state",
          "args": [
            "st",
            "target"
          ],
          "line": 548
        },
        "resolved": true,
        "details": {
          "function_name": "cpuhp_set_state",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "476-492",
          "snippet": "static inline enum cpuhp_state\ncpuhp_set_state(struct cpuhp_cpu_state *st, enum cpuhp_state target)\n{\n\tenum cpuhp_state prev_state = st->state;\n\tbool bringup = st->state < target;\n\n\tst->rollback = false;\n\tst->last = NULL;\n\n\tst->target = target;\n\tst->single = false;\n\tst->bringup = bringup;\n\tif (cpu_dying(st->cpu) != !bringup)\n\t\tset_cpu_dying(st->cpu, !bringup);\n\n\treturn prev_state;\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\n\nstatic inline enum cpuhp_state\ncpuhp_set_state(struct cpuhp_cpu_state *st, enum cpuhp_state target)\n{\n\tenum cpuhp_state prev_state = st->state;\n\tbool bringup = st->state < target;\n\n\tst->rollback = false;\n\tst->last = NULL;\n\n\tst->target = target;\n\tst->single = false;\n\tst->bringup = bringup;\n\tif (cpu_dying(st->cpu) != !bringup)\n\t\tset_cpu_dying(st->cpu, !bringup);\n\n\treturn prev_state;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\n\nstatic int cpuhp_kick_ap(struct cpuhp_cpu_state *st, enum cpuhp_state target)\n{\n\tenum cpuhp_state prev_state;\n\tint ret;\n\n\tprev_state = cpuhp_set_state(st, target);\n\t__cpuhp_kick_ap(st);\n\tif ((ret = st->result)) {\n\t\tcpuhp_reset_state(st, prev_state);\n\t\t__cpuhp_kick_ap(st);\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "__cpuhp_kick_ap",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
    "lines": "527-541",
    "snippet": "static void __cpuhp_kick_ap(struct cpuhp_cpu_state *st)\n{\n\tif (!st->single && st->state == st->target)\n\t\treturn;\n\n\tst->result = 0;\n\t/*\n\t * Make sure the above stores are visible before should_run becomes\n\t * true. Paired with the mb() above in cpuhp_thread_fun()\n\t */\n\tsmp_mb();\n\tst->should_run = true;\n\twake_up_process(st->thread);\n\twait_for_ap_thread(st, st->bringup);\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/scs.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sched/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wait_for_ap_thread",
          "args": [
            "st",
            "st->bringup"
          ],
          "line": 540
        },
        "resolved": true,
        "details": {
          "function_name": "wait_for_ap_thread",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "258-262",
          "snippet": "static inline void wait_for_ap_thread(struct cpuhp_cpu_state *st, bool bringup)\n{\n\tstruct completion *done = bringup ? &st->done_up : &st->done_down;\n\twait_for_completion(done);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstatic inline void wait_for_ap_thread(struct cpuhp_cpu_state *st, bool bringup)\n{\n\tstruct completion *done = bringup ? &st->done_up : &st->done_down;\n\twait_for_completion(done);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wake_up_process",
          "args": [
            "st->thread"
          ],
          "line": 539
        },
        "resolved": true,
        "details": {
          "function_name": "wake_up_process",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "4215-4218",
          "snippet": "int wake_up_process(struct task_struct *p)\n{\n\treturn try_to_wake_up(p, TASK_NORMAL, 0);\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\nint wake_up_process(struct task_struct *p)\n{\n\treturn try_to_wake_up(p, TASK_NORMAL, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_mb",
          "args": [],
          "line": 537
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstatic void __cpuhp_kick_ap(struct cpuhp_cpu_state *st)\n{\n\tif (!st->single && st->state == st->target)\n\t\treturn;\n\n\tst->result = 0;\n\t/*\n\t * Make sure the above stores are visible before should_run becomes\n\t * true. Paired with the mb() above in cpuhp_thread_fun()\n\t */\n\tsmp_mb();\n\tst->should_run = true;\n\twake_up_process(st->thread);\n\twait_for_ap_thread(st, st->bringup);\n}"
  },
  {
    "function_name": "cpuhp_reset_state",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
    "lines": "494-524",
    "snippet": "static inline void\ncpuhp_reset_state(struct cpuhp_cpu_state *st, enum cpuhp_state prev_state)\n{\n\tbool bringup = !st->bringup;\n\n\tst->target = prev_state;\n\n\t/*\n\t * Already rolling back. No need invert the bringup value or to change\n\t * the current state.\n\t */\n\tif (st->rollback)\n\t\treturn;\n\n\tst->rollback = true;\n\n\t/*\n\t * If we have st->last we need to undo partial multi_instance of this\n\t * state first. Otherwise start undo at the previous state.\n\t */\n\tif (!st->last) {\n\t\tif (st->bringup)\n\t\t\tst->state--;\n\t\telse\n\t\t\tst->state++;\n\t}\n\n\tst->bringup = bringup;\n\tif (cpu_dying(st->cpu) != !bringup)\n\t\tset_cpu_dying(st->cpu, !bringup);\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/scs.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sched/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_cpu_dying",
          "args": [
            "st->cpu",
            "!bringup"
          ],
          "line": 523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_dying",
          "args": [
            "st->cpu"
          ],
          "line": 522
        },
        "resolved": true,
        "details": {
          "function_name": "sched_cpu_dying",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "9213-9233",
          "snippet": "int sched_cpu_dying(unsigned int cpu)\n{\n\tstruct rq *rq = cpu_rq(cpu);\n\tstruct rq_flags rf;\n\n\t/* Handle pending wakeups and then migrate everything off */\n\tsched_tick_stop(cpu);\n\n\trq_lock_irqsave(rq, &rf);\n\tif (rq->nr_running != 1 || rq_has_pinned_tasks(rq)) {\n\t\tWARN(true, \"Dying CPU not properly vacated!\");\n\t\tdump_rq_tasks(rq, KERN_WARNING);\n\t}\n\trq_unlock_irqrestore(rq, &rf);\n\n\tcalc_load_migrate(rq);\n\tupdate_max_interval();\n\thrtick_clear(rq);\n\tsched_core_cpu_dying(cpu);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\nint sched_cpu_dying(unsigned int cpu)\n{\n\tstruct rq *rq = cpu_rq(cpu);\n\tstruct rq_flags rf;\n\n\t/* Handle pending wakeups and then migrate everything off */\n\tsched_tick_stop(cpu);\n\n\trq_lock_irqsave(rq, &rf);\n\tif (rq->nr_running != 1 || rq_has_pinned_tasks(rq)) {\n\t\tWARN(true, \"Dying CPU not properly vacated!\");\n\t\tdump_rq_tasks(rq, KERN_WARNING);\n\t}\n\trq_unlock_irqrestore(rq, &rf);\n\n\tcalc_load_migrate(rq);\n\tupdate_max_interval();\n\thrtick_clear(rq);\n\tsched_core_cpu_dying(cpu);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\n\nstatic inline void\ncpuhp_reset_state(struct cpuhp_cpu_state *st, enum cpuhp_state prev_state)\n{\n\tbool bringup = !st->bringup;\n\n\tst->target = prev_state;\n\n\t/*\n\t * Already rolling back. No need invert the bringup value or to change\n\t * the current state.\n\t */\n\tif (st->rollback)\n\t\treturn;\n\n\tst->rollback = true;\n\n\t/*\n\t * If we have st->last we need to undo partial multi_instance of this\n\t * state first. Otherwise start undo at the previous state.\n\t */\n\tif (!st->last) {\n\t\tif (st->bringup)\n\t\t\tst->state--;\n\t\telse\n\t\t\tst->state++;\n\t}\n\n\tst->bringup = bringup;\n\tif (cpu_dying(st->cpu) != !bringup)\n\t\tset_cpu_dying(st->cpu, !bringup);\n}"
  },
  {
    "function_name": "cpuhp_set_state",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
    "lines": "476-492",
    "snippet": "static inline enum cpuhp_state\ncpuhp_set_state(struct cpuhp_cpu_state *st, enum cpuhp_state target)\n{\n\tenum cpuhp_state prev_state = st->state;\n\tbool bringup = st->state < target;\n\n\tst->rollback = false;\n\tst->last = NULL;\n\n\tst->target = target;\n\tst->single = false;\n\tst->bringup = bringup;\n\tif (cpu_dying(st->cpu) != !bringup)\n\t\tset_cpu_dying(st->cpu, !bringup);\n\n\treturn prev_state;\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/scs.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sched/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_cpu_dying",
          "args": [
            "st->cpu",
            "!bringup"
          ],
          "line": 489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_dying",
          "args": [
            "st->cpu"
          ],
          "line": 488
        },
        "resolved": true,
        "details": {
          "function_name": "sched_cpu_dying",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "9213-9233",
          "snippet": "int sched_cpu_dying(unsigned int cpu)\n{\n\tstruct rq *rq = cpu_rq(cpu);\n\tstruct rq_flags rf;\n\n\t/* Handle pending wakeups and then migrate everything off */\n\tsched_tick_stop(cpu);\n\n\trq_lock_irqsave(rq, &rf);\n\tif (rq->nr_running != 1 || rq_has_pinned_tasks(rq)) {\n\t\tWARN(true, \"Dying CPU not properly vacated!\");\n\t\tdump_rq_tasks(rq, KERN_WARNING);\n\t}\n\trq_unlock_irqrestore(rq, &rf);\n\n\tcalc_load_migrate(rq);\n\tupdate_max_interval();\n\thrtick_clear(rq);\n\tsched_core_cpu_dying(cpu);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\nint sched_cpu_dying(unsigned int cpu)\n{\n\tstruct rq *rq = cpu_rq(cpu);\n\tstruct rq_flags rf;\n\n\t/* Handle pending wakeups and then migrate everything off */\n\tsched_tick_stop(cpu);\n\n\trq_lock_irqsave(rq, &rf);\n\tif (rq->nr_running != 1 || rq_has_pinned_tasks(rq)) {\n\t\tWARN(true, \"Dying CPU not properly vacated!\");\n\t\tdump_rq_tasks(rq, KERN_WARNING);\n\t}\n\trq_unlock_irqrestore(rq, &rf);\n\n\tcalc_load_migrate(rq);\n\tupdate_max_interval();\n\thrtick_clear(rq);\n\tsched_core_cpu_dying(cpu);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\n\nstatic inline enum cpuhp_state\ncpuhp_set_state(struct cpuhp_cpu_state *st, enum cpuhp_state target)\n{\n\tenum cpuhp_state prev_state = st->state;\n\tbool bringup = st->state < target;\n\n\tst->rollback = false;\n\tst->last = NULL;\n\n\tst->target = target;\n\tst->single = false;\n\tst->bringup = bringup;\n\tif (cpu_dying(st->cpu) != !bringup)\n\t\tset_cpu_dying(st->cpu, !bringup);\n\n\treturn prev_state;\n}"
  },
  {
    "function_name": "cpu_smt_allowed",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
    "lines": "473-473",
    "snippet": "static inline bool cpu_smt_allowed(unsigned int cpu) { return true; }",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/scs.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sched/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstatic inline bool cpu_smt_allowed(unsigned int cpu) { return true; }"
  },
  {
    "function_name": "cpu_smt_possible",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
    "lines": "466-470",
    "snippet": "bool cpu_smt_possible(void)\n{\n\treturn cpu_smt_control != CPU_SMT_FORCE_DISABLED &&\n\t\tcpu_smt_control != CPU_SMT_NOT_SUPPORTED;\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/scs.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sched/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nbool cpu_smt_possible(void)\n{\n\treturn cpu_smt_control != CPU_SMT_FORCE_DISABLED &&\n\t\tcpu_smt_control != CPU_SMT_NOT_SUPPORTED;\n}"
  },
  {
    "function_name": "cpu_smt_allowed",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
    "lines": "448-463",
    "snippet": "static inline bool cpu_smt_allowed(unsigned int cpu)\n{\n\tif (cpu_smt_control == CPU_SMT_ENABLED)\n\t\treturn true;\n\n\tif (topology_is_primary_thread(cpu))\n\t\treturn true;\n\n\t/*\n\t * On x86 it's required to boot all logical CPUs at least once so\n\t * that the init code can get a chance to set CR4.MCE on each\n\t * CPU. Otherwise, a broadcasted MCE observing CR4.MCE=0b on any\n\t * core will shutdown the machine.\n\t */\n\treturn !cpumask_test_cpu(cpu, &cpus_booted_once_mask);\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/scs.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sched/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpumask_test_cpu",
          "args": [
            "cpu",
            "&cpus_booted_once_mask"
          ],
          "line": 462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "topology_is_primary_thread",
          "args": [
            "cpu"
          ],
          "line": 453
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstatic inline bool cpu_smt_allowed(unsigned int cpu)\n{\n\tif (cpu_smt_control == CPU_SMT_ENABLED)\n\t\treturn true;\n\n\tif (topology_is_primary_thread(cpu))\n\t\treturn true;\n\n\t/*\n\t * On x86 it's required to boot all logical CPUs at least once so\n\t * that the init code can get a chance to set CR4.MCE on each\n\t * CPU. Otherwise, a broadcasted MCE observing CR4.MCE=0b on any\n\t * core will shutdown the machine.\n\t */\n\treturn !cpumask_test_cpu(cpu, &cpus_booted_once_mask);\n}"
  },
  {
    "function_name": "smt_cmdline_disable",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
    "lines": "441-445",
    "snippet": "static int __init smt_cmdline_disable(char *str)\n{\n\tcpu_smt_disable(str && !strcmp(str, \"force\"));\n\treturn 0;\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/scs.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sched/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_smt_disable",
          "args": [
            "str && !strcmp(str, \"force\")"
          ],
          "line": 443
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_smt_disable",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "417-429",
          "snippet": "void __init cpu_smt_disable(bool force)\n{\n\tif (!cpu_smt_possible())\n\t\treturn;\n\n\tif (force) {\n\t\tpr_info(\"SMT: Force disabled\\n\");\n\t\tcpu_smt_control = CPU_SMT_FORCE_DISABLED;\n\t} else {\n\t\tpr_info(\"SMT: disabled\\n\");\n\t\tcpu_smt_control = CPU_SMT_DISABLED;\n\t}\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nvoid __init cpu_smt_disable(bool force)\n{\n\tif (!cpu_smt_possible())\n\t\treturn;\n\n\tif (force) {\n\t\tpr_info(\"SMT: Force disabled\\n\");\n\t\tcpu_smt_control = CPU_SMT_FORCE_DISABLED;\n\t} else {\n\t\tpr_info(\"SMT: disabled\\n\");\n\t\tcpu_smt_control = CPU_SMT_DISABLED;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "str",
            "\"force\""
          ],
          "line": 443
        },
        "resolved": true,
        "details": {
          "function_name": "sym_strcmp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/report.c",
          "lines": "356-365",
          "snippet": "static int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}",
          "includes": [
            "#include \"encoding.h\"",
            "#include \"kcsan.h\"",
            "#include <linux/stacktrace.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/delay.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"encoding.h\"\n#include \"kcsan.h\"\n#include <linux/stacktrace.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/lockdep.h>\n#include <linux/kernel.h>\n#include <linux/kallsyms.h>\n#include <linux/jiffies.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n\nstatic int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstatic int __init smt_cmdline_disable(char *str)\n{\n\tcpu_smt_disable(str && !strcmp(str, \"force\"));\n\treturn 0;\n}"
  },
  {
    "function_name": "cpu_smt_check_topology",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
    "lines": "435-439",
    "snippet": "void __init cpu_smt_check_topology(void)\n{\n\tif (!topology_smt_supported())\n\t\tcpu_smt_control = CPU_SMT_NOT_SUPPORTED;\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/scs.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sched/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "topology_smt_supported",
          "args": [],
          "line": 437
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nvoid __init cpu_smt_check_topology(void)\n{\n\tif (!topology_smt_supported())\n\t\tcpu_smt_control = CPU_SMT_NOT_SUPPORTED;\n}"
  },
  {
    "function_name": "cpu_smt_disable",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
    "lines": "417-429",
    "snippet": "void __init cpu_smt_disable(bool force)\n{\n\tif (!cpu_smt_possible())\n\t\treturn;\n\n\tif (force) {\n\t\tpr_info(\"SMT: Force disabled\\n\");\n\t\tcpu_smt_control = CPU_SMT_FORCE_DISABLED;\n\t} else {\n\t\tpr_info(\"SMT: disabled\\n\");\n\t\tcpu_smt_control = CPU_SMT_DISABLED;\n\t}\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/scs.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sched/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"SMT: disabled\\n\""
          ],
          "line": 426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"SMT: Force disabled\\n\""
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_smt_possible",
          "args": [],
          "line": 419
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_smt_possible",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "466-470",
          "snippet": "bool cpu_smt_possible(void)\n{\n\treturn cpu_smt_control != CPU_SMT_FORCE_DISABLED &&\n\t\tcpu_smt_control != CPU_SMT_NOT_SUPPORTED;\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nbool cpu_smt_possible(void)\n{\n\treturn cpu_smt_control != CPU_SMT_FORCE_DISABLED &&\n\t\tcpu_smt_control != CPU_SMT_NOT_SUPPORTED;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nvoid __init cpu_smt_disable(bool force)\n{\n\tif (!cpu_smt_possible())\n\t\treturn;\n\n\tif (force) {\n\t\tpr_info(\"SMT: Force disabled\\n\");\n\t\tcpu_smt_control = CPU_SMT_FORCE_DISABLED;\n\t} else {\n\t\tpr_info(\"SMT: disabled\\n\");\n\t\tcpu_smt_control = CPU_SMT_DISABLED;\n\t}\n}"
  },
  {
    "function_name": "arch_smt_update",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
    "lines": "412-412",
    "snippet": "void __weak arch_smt_update(void) { }",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/scs.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sched/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nvoid __weak arch_smt_update(void) { }"
  },
  {
    "function_name": "lockdep_release_cpus_lock",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
    "lines": "402-404",
    "snippet": "static void lockdep_release_cpus_lock(void)\n{\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/scs.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sched/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstatic void lockdep_release_cpus_lock(void)\n{\n}"
  },
  {
    "function_name": "lockdep_acquire_cpus_lock",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
    "lines": "398-400",
    "snippet": "static void lockdep_acquire_cpus_lock(void)\n{\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/scs.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sched/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstatic void lockdep_acquire_cpus_lock(void)\n{\n}"
  },
  {
    "function_name": "cpu_hotplug_enable",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
    "lines": "388-393",
    "snippet": "void cpu_hotplug_enable(void)\n{\n\tcpu_maps_update_begin();\n\t__cpu_hotplug_enable();\n\tcpu_maps_update_done();\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/scs.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sched/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_maps_update_done",
          "args": [],
          "line": 392
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_maps_update_done",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "292-295",
          "snippet": "void cpu_maps_update_done(void)\n{\n\tmutex_unlock(&cpu_add_remove_lock);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nvoid cpu_maps_update_done(void)\n{\n\tmutex_unlock(&cpu_add_remove_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__cpu_hotplug_enable",
          "args": [],
          "line": 391
        },
        "resolved": true,
        "details": {
          "function_name": "__cpu_hotplug_enable",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "381-386",
          "snippet": "static void __cpu_hotplug_enable(void)\n{\n\tif (WARN_ONCE(!cpu_hotplug_disabled, \"Unbalanced cpu hotplug enable\\n\"))\n\t\treturn;\n\tcpu_hotplug_disabled--;\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstatic void __cpu_hotplug_enable(void)\n{\n\tif (WARN_ONCE(!cpu_hotplug_disabled, \"Unbalanced cpu hotplug enable\\n\"))\n\t\treturn;\n\tcpu_hotplug_disabled--;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_maps_update_begin",
          "args": [],
          "line": 390
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_maps_update_begin",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "287-290",
          "snippet": "void cpu_maps_update_begin(void)\n{\n\tmutex_lock(&cpu_add_remove_lock);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nvoid cpu_maps_update_begin(void)\n{\n\tmutex_lock(&cpu_add_remove_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nvoid cpu_hotplug_enable(void)\n{\n\tcpu_maps_update_begin();\n\t__cpu_hotplug_enable();\n\tcpu_maps_update_done();\n}"
  },
  {
    "function_name": "__cpu_hotplug_enable",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
    "lines": "381-386",
    "snippet": "static void __cpu_hotplug_enable(void)\n{\n\tif (WARN_ONCE(!cpu_hotplug_disabled, \"Unbalanced cpu hotplug enable\\n\"))\n\t\treturn;\n\tcpu_hotplug_disabled--;\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/scs.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sched/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ONCE",
          "args": [
            "!cpu_hotplug_disabled",
            "\"Unbalanced cpu hotplug enable\\n\""
          ],
          "line": 383
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstatic void __cpu_hotplug_enable(void)\n{\n\tif (WARN_ONCE(!cpu_hotplug_disabled, \"Unbalanced cpu hotplug enable\\n\"))\n\t\treturn;\n\tcpu_hotplug_disabled--;\n}"
  },
  {
    "function_name": "cpu_hotplug_disable",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
    "lines": "373-378",
    "snippet": "void cpu_hotplug_disable(void)\n{\n\tcpu_maps_update_begin();\n\tcpu_hotplug_disabled++;\n\tcpu_maps_update_done();\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/scs.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sched/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_maps_update_done",
          "args": [],
          "line": 377
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_maps_update_done",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "292-295",
          "snippet": "void cpu_maps_update_done(void)\n{\n\tmutex_unlock(&cpu_add_remove_lock);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nvoid cpu_maps_update_done(void)\n{\n\tmutex_unlock(&cpu_add_remove_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_maps_update_begin",
          "args": [],
          "line": 375
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_maps_update_begin",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "287-290",
          "snippet": "void cpu_maps_update_begin(void)\n{\n\tmutex_lock(&cpu_add_remove_lock);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nvoid cpu_maps_update_begin(void)\n{\n\tmutex_lock(&cpu_add_remove_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nvoid cpu_hotplug_disable(void)\n{\n\tcpu_maps_update_begin();\n\tcpu_hotplug_disabled++;\n\tcpu_maps_update_done();\n}"
  },
  {
    "function_name": "lockdep_release_cpus_lock",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
    "lines": "361-364",
    "snippet": "static void lockdep_release_cpus_lock(void)\n{\n\trwsem_release(&cpu_hotplug_lock.dep_map, _THIS_IP_);\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/scs.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sched/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rwsem_release",
          "args": [
            "&cpu_hotplug_lock.dep_map",
            "_THIS_IP_"
          ],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstatic void lockdep_release_cpus_lock(void)\n{\n\trwsem_release(&cpu_hotplug_lock.dep_map, _THIS_IP_);\n}"
  },
  {
    "function_name": "lockdep_acquire_cpus_lock",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
    "lines": "356-359",
    "snippet": "static void lockdep_acquire_cpus_lock(void)\n{\n\trwsem_acquire(&cpu_hotplug_lock.dep_map, 0, 0, _THIS_IP_);\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/scs.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sched/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rwsem_acquire",
          "args": [
            "&cpu_hotplug_lock.dep_map",
            "0",
            "0",
            "_THIS_IP_"
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstatic void lockdep_acquire_cpus_lock(void)\n{\n\trwsem_acquire(&cpu_hotplug_lock.dep_map, 0, 0, _THIS_IP_);\n}"
  },
  {
    "function_name": "lockdep_is_cpus_held",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
    "lines": "350-353",
    "snippet": "int lockdep_is_cpus_held(void)\n{\n\treturn percpu_rwsem_is_held(&cpu_hotplug_lock);\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/scs.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sched/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "percpu_rwsem_is_held",
          "args": [
            "&cpu_hotplug_lock"
          ],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nint lockdep_is_cpus_held(void)\n{\n\treturn percpu_rwsem_is_held(&cpu_hotplug_lock);\n}"
  },
  {
    "function_name": "lockdep_assert_cpus_held",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
    "lines": "335-347",
    "snippet": "void lockdep_assert_cpus_held(void)\n{\n\t/*\n\t * We can't have hotplug operations before userspace starts running,\n\t * and some init codepaths will knowingly not take the hotplug lock.\n\t * This is all valid, so mute lockdep until it makes sense to report\n\t * unheld locks.\n\t */\n\tif (system_state < SYSTEM_RUNNING)\n\t\treturn;\n\n\tpercpu_rwsem_assert_held(&cpu_hotplug_lock);\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/scs.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sched/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "percpu_rwsem_assert_held",
          "args": [
            "&cpu_hotplug_lock"
          ],
          "line": 346
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nvoid lockdep_assert_cpus_held(void)\n{\n\t/*\n\t * We can't have hotplug operations before userspace starts running,\n\t * and some init codepaths will knowingly not take the hotplug lock.\n\t * This is all valid, so mute lockdep until it makes sense to report\n\t * unheld locks.\n\t */\n\tif (system_state < SYSTEM_RUNNING)\n\t\treturn;\n\n\tpercpu_rwsem_assert_held(&cpu_hotplug_lock);\n}"
  },
  {
    "function_name": "cpus_write_unlock",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
    "lines": "330-333",
    "snippet": "void cpus_write_unlock(void)\n{\n\tpercpu_up_write(&cpu_hotplug_lock);\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/scs.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sched/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "percpu_up_write",
          "args": [
            "&cpu_hotplug_lock"
          ],
          "line": 332
        },
        "resolved": true,
        "details": {
          "function_name": "percpu_up_write",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/percpu-rwsem.c",
          "lines": "242-269",
          "snippet": "void percpu_up_write(struct percpu_rw_semaphore *sem)\n{\n\trwsem_release(&sem->dep_map, _RET_IP_);\n\n\t/*\n\t * Signal the writer is done, no fast path yet.\n\t *\n\t * One reason that we cannot just immediately flip to readers_fast is\n\t * that new readers might fail to see the results of this writer's\n\t * critical section.\n\t *\n\t * Therefore we force it through the slow path which guarantees an\n\t * acquire and thereby guarantees the critical section's consistency.\n\t */\n\tatomic_set_release(&sem->block, 0);\n\n\t/*\n\t * Prod any pending reader/writer to make progress.\n\t */\n\t__wake_up(&sem->waiters, TASK_NORMAL, 1, sem);\n\n\t/*\n\t * Once this completes (at least one RCU-sched grace period hence) the\n\t * reader fast path will be available again. Safe to use outside the\n\t * exclusive write lock because its counting.\n\t */\n\trcu_sync_exit(&sem->rss);\n}",
          "includes": [
            "#include <linux/errno.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/wait.h>",
            "#include <linux/percpu.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/errno.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/lockdep.h>\n#include <linux/wait.h>\n#include <linux/percpu.h>\n#include <linux/atomic.h>\n\nvoid percpu_up_write(struct percpu_rw_semaphore *sem)\n{\n\trwsem_release(&sem->dep_map, _RET_IP_);\n\n\t/*\n\t * Signal the writer is done, no fast path yet.\n\t *\n\t * One reason that we cannot just immediately flip to readers_fast is\n\t * that new readers might fail to see the results of this writer's\n\t * critical section.\n\t *\n\t * Therefore we force it through the slow path which guarantees an\n\t * acquire and thereby guarantees the critical section's consistency.\n\t */\n\tatomic_set_release(&sem->block, 0);\n\n\t/*\n\t * Prod any pending reader/writer to make progress.\n\t */\n\t__wake_up(&sem->waiters, TASK_NORMAL, 1, sem);\n\n\t/*\n\t * Once this completes (at least one RCU-sched grace period hence) the\n\t * reader fast path will be available again. Safe to use outside the\n\t * exclusive write lock because its counting.\n\t */\n\trcu_sync_exit(&sem->rss);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nvoid cpus_write_unlock(void)\n{\n\tpercpu_up_write(&cpu_hotplug_lock);\n}"
  },
  {
    "function_name": "cpus_write_lock",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
    "lines": "325-328",
    "snippet": "void cpus_write_lock(void)\n{\n\tpercpu_down_write(&cpu_hotplug_lock);\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/scs.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sched/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "percpu_down_write",
          "args": [
            "&cpu_hotplug_lock"
          ],
          "line": 327
        },
        "resolved": true,
        "details": {
          "function_name": "percpu_down_write",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/percpu-rwsem.c",
          "lines": "214-239",
          "snippet": "void percpu_down_write(struct percpu_rw_semaphore *sem)\n{\n\tmight_sleep();\n\trwsem_acquire(&sem->dep_map, 0, 0, _RET_IP_);\n\n\t/* Notify readers to take the slow path. */\n\trcu_sync_enter(&sem->rss);\n\n\t/*\n\t * Try set sem->block; this provides writer-writer exclusion.\n\t * Having sem->block set makes new readers block.\n\t */\n\tif (!__percpu_down_write_trylock(sem))\n\t\tpercpu_rwsem_wait(sem, /* .reader = */ false);\n\n\t/* smp_mb() implied by __percpu_down_write_trylock() on success -- D matches A */\n\n\t/*\n\t * If they don't see our store of sem->block, then we are guaranteed to\n\t * see their sem->read_count increment, and therefore will wait for\n\t * them.\n\t */\n\n\t/* Wait for all active readers to complete. */\n\trcuwait_wait_event(&sem->writer, readers_active_check(sem), TASK_UNINTERRUPTIBLE);\n}",
          "includes": [
            "#include <linux/errno.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/wait.h>",
            "#include <linux/percpu.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/errno.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/lockdep.h>\n#include <linux/wait.h>\n#include <linux/percpu.h>\n#include <linux/atomic.h>\n\nvoid percpu_down_write(struct percpu_rw_semaphore *sem)\n{\n\tmight_sleep();\n\trwsem_acquire(&sem->dep_map, 0, 0, _RET_IP_);\n\n\t/* Notify readers to take the slow path. */\n\trcu_sync_enter(&sem->rss);\n\n\t/*\n\t * Try set sem->block; this provides writer-writer exclusion.\n\t * Having sem->block set makes new readers block.\n\t */\n\tif (!__percpu_down_write_trylock(sem))\n\t\tpercpu_rwsem_wait(sem, /* .reader = */ false);\n\n\t/* smp_mb() implied by __percpu_down_write_trylock() on success -- D matches A */\n\n\t/*\n\t * If they don't see our store of sem->block, then we are guaranteed to\n\t * see their sem->read_count increment, and therefore will wait for\n\t * them.\n\t */\n\n\t/* Wait for all active readers to complete. */\n\trcuwait_wait_event(&sem->writer, readers_active_check(sem), TASK_UNINTERRUPTIBLE);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nvoid cpus_write_lock(void)\n{\n\tpercpu_down_write(&cpu_hotplug_lock);\n}"
  },
  {
    "function_name": "cpus_read_unlock",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
    "lines": "319-322",
    "snippet": "void cpus_read_unlock(void)\n{\n\tpercpu_up_read(&cpu_hotplug_lock);\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/scs.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sched/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "percpu_up_read",
          "args": [
            "&cpu_hotplug_lock"
          ],
          "line": 321
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nvoid cpus_read_unlock(void)\n{\n\tpercpu_up_read(&cpu_hotplug_lock);\n}"
  },
  {
    "function_name": "cpus_read_trylock",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
    "lines": "313-316",
    "snippet": "int cpus_read_trylock(void)\n{\n\treturn percpu_down_read_trylock(&cpu_hotplug_lock);\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/scs.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sched/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "percpu_down_read_trylock",
          "args": [
            "&cpu_hotplug_lock"
          ],
          "line": 315
        },
        "resolved": true,
        "details": {
          "function_name": "__percpu_down_read_trylock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/percpu-rwsem.c",
          "lines": "46-80",
          "snippet": "static bool __percpu_down_read_trylock(struct percpu_rw_semaphore *sem)\n{\n\tthis_cpu_inc(*sem->read_count);\n\n\t/*\n\t * Due to having preemption disabled the decrement happens on\n\t * the same CPU as the increment, avoiding the\n\t * increment-on-one-CPU-and-decrement-on-another problem.\n\t *\n\t * If the reader misses the writer's assignment of sem->block, then the\n\t * writer is guaranteed to see the reader's increment.\n\t *\n\t * Conversely, any readers that increment their sem->read_count after\n\t * the writer looks are guaranteed to see the sem->block value, which\n\t * in turn means that they are guaranteed to immediately decrement\n\t * their sem->read_count, so that it doesn't matter that the writer\n\t * missed them.\n\t */\n\n\tsmp_mb(); /* A matches D */\n\n\t/*\n\t * If !sem->block the critical section starts here, matched by the\n\t * release in percpu_up_write().\n\t */\n\tif (likely(!atomic_read_acquire(&sem->block)))\n\t\treturn true;\n\n\tthis_cpu_dec(*sem->read_count);\n\n\t/* Prod writer to re-evaluate readers_active_check() */\n\trcuwait_wake_up(&sem->writer);\n\n\treturn false;\n}",
          "includes": [
            "#include <linux/errno.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/wait.h>",
            "#include <linux/percpu.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/errno.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/lockdep.h>\n#include <linux/wait.h>\n#include <linux/percpu.h>\n#include <linux/atomic.h>\n\nstatic bool __percpu_down_read_trylock(struct percpu_rw_semaphore *sem)\n{\n\tthis_cpu_inc(*sem->read_count);\n\n\t/*\n\t * Due to having preemption disabled the decrement happens on\n\t * the same CPU as the increment, avoiding the\n\t * increment-on-one-CPU-and-decrement-on-another problem.\n\t *\n\t * If the reader misses the writer's assignment of sem->block, then the\n\t * writer is guaranteed to see the reader's increment.\n\t *\n\t * Conversely, any readers that increment their sem->read_count after\n\t * the writer looks are guaranteed to see the sem->block value, which\n\t * in turn means that they are guaranteed to immediately decrement\n\t * their sem->read_count, so that it doesn't matter that the writer\n\t * missed them.\n\t */\n\n\tsmp_mb(); /* A matches D */\n\n\t/*\n\t * If !sem->block the critical section starts here, matched by the\n\t * release in percpu_up_write().\n\t */\n\tif (likely(!atomic_read_acquire(&sem->block)))\n\t\treturn true;\n\n\tthis_cpu_dec(*sem->read_count);\n\n\t/* Prod writer to re-evaluate readers_active_check() */\n\trcuwait_wake_up(&sem->writer);\n\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nint cpus_read_trylock(void)\n{\n\treturn percpu_down_read_trylock(&cpu_hotplug_lock);\n}"
  },
  {
    "function_name": "cpus_read_lock",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
    "lines": "307-310",
    "snippet": "void cpus_read_lock(void)\n{\n\tpercpu_down_read(&cpu_hotplug_lock);\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/scs.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sched/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "percpu_down_read",
          "args": [
            "&cpu_hotplug_lock"
          ],
          "line": 309
        },
        "resolved": true,
        "details": {
          "function_name": "__percpu_down_read_trylock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/percpu-rwsem.c",
          "lines": "46-80",
          "snippet": "static bool __percpu_down_read_trylock(struct percpu_rw_semaphore *sem)\n{\n\tthis_cpu_inc(*sem->read_count);\n\n\t/*\n\t * Due to having preemption disabled the decrement happens on\n\t * the same CPU as the increment, avoiding the\n\t * increment-on-one-CPU-and-decrement-on-another problem.\n\t *\n\t * If the reader misses the writer's assignment of sem->block, then the\n\t * writer is guaranteed to see the reader's increment.\n\t *\n\t * Conversely, any readers that increment their sem->read_count after\n\t * the writer looks are guaranteed to see the sem->block value, which\n\t * in turn means that they are guaranteed to immediately decrement\n\t * their sem->read_count, so that it doesn't matter that the writer\n\t * missed them.\n\t */\n\n\tsmp_mb(); /* A matches D */\n\n\t/*\n\t * If !sem->block the critical section starts here, matched by the\n\t * release in percpu_up_write().\n\t */\n\tif (likely(!atomic_read_acquire(&sem->block)))\n\t\treturn true;\n\n\tthis_cpu_dec(*sem->read_count);\n\n\t/* Prod writer to re-evaluate readers_active_check() */\n\trcuwait_wake_up(&sem->writer);\n\n\treturn false;\n}",
          "includes": [
            "#include <linux/errno.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/wait.h>",
            "#include <linux/percpu.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/errno.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/lockdep.h>\n#include <linux/wait.h>\n#include <linux/percpu.h>\n#include <linux/atomic.h>\n\nstatic bool __percpu_down_read_trylock(struct percpu_rw_semaphore *sem)\n{\n\tthis_cpu_inc(*sem->read_count);\n\n\t/*\n\t * Due to having preemption disabled the decrement happens on\n\t * the same CPU as the increment, avoiding the\n\t * increment-on-one-CPU-and-decrement-on-another problem.\n\t *\n\t * If the reader misses the writer's assignment of sem->block, then the\n\t * writer is guaranteed to see the reader's increment.\n\t *\n\t * Conversely, any readers that increment their sem->read_count after\n\t * the writer looks are guaranteed to see the sem->block value, which\n\t * in turn means that they are guaranteed to immediately decrement\n\t * their sem->read_count, so that it doesn't matter that the writer\n\t * missed them.\n\t */\n\n\tsmp_mb(); /* A matches D */\n\n\t/*\n\t * If !sem->block the critical section starts here, matched by the\n\t * release in percpu_up_write().\n\t */\n\tif (likely(!atomic_read_acquire(&sem->block)))\n\t\treturn true;\n\n\tthis_cpu_dec(*sem->read_count);\n\n\t/* Prod writer to re-evaluate readers_active_check() */\n\trcuwait_wake_up(&sem->writer);\n\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nvoid cpus_read_lock(void)\n{\n\tpercpu_down_read(&cpu_hotplug_lock);\n}"
  },
  {
    "function_name": "cpu_maps_update_done",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
    "lines": "292-295",
    "snippet": "void cpu_maps_update_done(void)\n{\n\tmutex_unlock(&cpu_add_remove_lock);\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/scs.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sched/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&cpu_add_remove_lock"
          ],
          "line": 294
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nvoid cpu_maps_update_done(void)\n{\n\tmutex_unlock(&cpu_add_remove_lock);\n}"
  },
  {
    "function_name": "cpu_maps_update_begin",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
    "lines": "287-290",
    "snippet": "void cpu_maps_update_begin(void)\n{\n\tmutex_lock(&cpu_add_remove_lock);\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/scs.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sched/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&cpu_add_remove_lock"
          ],
          "line": 289
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nvoid cpu_maps_update_begin(void)\n{\n\tmutex_lock(&cpu_add_remove_lock);\n}"
  },
  {
    "function_name": "cpuhp_is_atomic_state",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
    "lines": "273-276",
    "snippet": "static bool cpuhp_is_atomic_state(enum cpuhp_state state)\n{\n\treturn CPUHP_AP_IDLE_DEAD <= state && state < CPUHP_AP_ONLINE;\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/scs.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sched/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\n\nstatic bool cpuhp_is_atomic_state(enum cpuhp_state state)\n{\n\treturn CPUHP_AP_IDLE_DEAD <= state && state < CPUHP_AP_ONLINE;\n}"
  },
  {
    "function_name": "complete_ap_thread",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
    "lines": "264-268",
    "snippet": "static inline void complete_ap_thread(struct cpuhp_cpu_state *st, bool bringup)\n{\n\tstruct completion *done = bringup ? &st->done_up : &st->done_down;\n\tcomplete(done);\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/scs.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sched/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "complete",
          "args": [
            "done"
          ],
          "line": 267
        },
        "resolved": true,
        "details": {
          "function_name": "cpuhp_complete_idle_dead",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "1075-1080",
          "snippet": "static void cpuhp_complete_idle_dead(void *arg)\n{\n\tstruct cpuhp_cpu_state *st = arg;\n\n\tcomplete_ap_thread(st, false);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstatic void cpuhp_complete_idle_dead(void *arg)\n{\n\tstruct cpuhp_cpu_state *st = arg;\n\n\tcomplete_ap_thread(st, false);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstatic inline void complete_ap_thread(struct cpuhp_cpu_state *st, bool bringup)\n{\n\tstruct completion *done = bringup ? &st->done_up : &st->done_down;\n\tcomplete(done);\n}"
  },
  {
    "function_name": "wait_for_ap_thread",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
    "lines": "258-262",
    "snippet": "static inline void wait_for_ap_thread(struct cpuhp_cpu_state *st, bool bringup)\n{\n\tstruct completion *done = bringup ? &st->done_up : &st->done_down;\n\twait_for_completion(done);\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/scs.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sched/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wait_for_completion",
          "args": [
            "done"
          ],
          "line": 261
        },
        "resolved": true,
        "details": {
          "function_name": "try_wait_for_completion",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/completion.c",
          "lines": "282-303",
          "snippet": "bool try_wait_for_completion(struct completion *x)\n{\n\tunsigned long flags;\n\tbool ret = true;\n\n\t/*\n\t * Since x->done will need to be locked only\n\t * in the non-blocking case, we check x->done\n\t * first without taking the lock so we can\n\t * return early in the blocking case.\n\t */\n\tif (!READ_ONCE(x->done))\n\t\treturn false;\n\n\traw_spin_lock_irqsave(&x->wait.lock, flags);\n\tif (!x->done)\n\t\tret = false;\n\telse if (x->done != UINT_MAX)\n\t\tx->done--;\n\traw_spin_unlock_irqrestore(&x->wait.lock, flags);\n\treturn ret;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nbool try_wait_for_completion(struct completion *x)\n{\n\tunsigned long flags;\n\tbool ret = true;\n\n\t/*\n\t * Since x->done will need to be locked only\n\t * in the non-blocking case, we check x->done\n\t * first without taking the lock so we can\n\t * return early in the blocking case.\n\t */\n\tif (!READ_ONCE(x->done))\n\t\treturn false;\n\n\traw_spin_lock_irqsave(&x->wait.lock, flags);\n\tif (!x->done)\n\t\tret = false;\n\telse if (x->done != UINT_MAX)\n\t\tx->done--;\n\traw_spin_unlock_irqrestore(&x->wait.lock, flags);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstatic inline void wait_for_ap_thread(struct cpuhp_cpu_state *st, bool bringup)\n{\n\tstruct completion *done = bringup ? &st->done_up : &st->done_down;\n\twait_for_completion(done);\n}"
  },
  {
    "function_name": "cpuhp_is_ap_state",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
    "lines": "249-256",
    "snippet": "static bool cpuhp_is_ap_state(enum cpuhp_state state)\n{\n\t/*\n\t * The extra check for CPUHP_TEARDOWN_CPU is only for documentation\n\t * purposes as that state is handled explicitly in cpu_down.\n\t */\n\treturn state > CPUHP_BRINGUP_CPU && state != CPUHP_TEARDOWN_CPU;\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/scs.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sched/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\n\nstatic bool cpuhp_is_ap_state(enum cpuhp_state state)\n{\n\t/*\n\t * The extra check for CPUHP_TEARDOWN_CPU is only for documentation\n\t * purposes as that state is handled explicitly in cpu_down.\n\t */\n\treturn state > CPUHP_BRINGUP_CPU && state != CPUHP_TEARDOWN_CPU;\n}"
  },
  {
    "function_name": "cpuhp_invoke_callback",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
    "lines": "166-246",
    "snippet": "static int cpuhp_invoke_callback(unsigned int cpu, enum cpuhp_state state,\n\t\t\t\t bool bringup, struct hlist_node *node,\n\t\t\t\t struct hlist_node **lastp)\n{\n\tstruct cpuhp_cpu_state *st = per_cpu_ptr(&cpuhp_state, cpu);\n\tstruct cpuhp_step *step = cpuhp_get_step(state);\n\tint (*cbm)(unsigned int cpu, struct hlist_node *node);\n\tint (*cb)(unsigned int cpu);\n\tint ret, cnt;\n\n\tif (st->fail == state) {\n\t\tst->fail = CPUHP_INVALID;\n\t\treturn -EAGAIN;\n\t}\n\n\tif (cpuhp_step_empty(bringup, step)) {\n\t\tWARN_ON_ONCE(1);\n\t\treturn 0;\n\t}\n\n\tif (!step->multi_instance) {\n\t\tWARN_ON_ONCE(lastp && *lastp);\n\t\tcb = bringup ? step->startup.single : step->teardown.single;\n\n\t\ttrace_cpuhp_enter(cpu, st->target, state, cb);\n\t\tret = cb(cpu);\n\t\ttrace_cpuhp_exit(cpu, st->state, state, ret);\n\t\treturn ret;\n\t}\n\tcbm = bringup ? step->startup.multi : step->teardown.multi;\n\n\t/* Single invocation for instance add/remove */\n\tif (node) {\n\t\tWARN_ON_ONCE(lastp && *lastp);\n\t\ttrace_cpuhp_multi_enter(cpu, st->target, state, cbm, node);\n\t\tret = cbm(cpu, node);\n\t\ttrace_cpuhp_exit(cpu, st->state, state, ret);\n\t\treturn ret;\n\t}\n\n\t/* State transition. Invoke on all instances */\n\tcnt = 0;\n\thlist_for_each(node, &step->list) {\n\t\tif (lastp && node == *lastp)\n\t\t\tbreak;\n\n\t\ttrace_cpuhp_multi_enter(cpu, st->target, state, cbm, node);\n\t\tret = cbm(cpu, node);\n\t\ttrace_cpuhp_exit(cpu, st->state, state, ret);\n\t\tif (ret) {\n\t\t\tif (!lastp)\n\t\t\t\tgoto err;\n\n\t\t\t*lastp = node;\n\t\t\treturn ret;\n\t\t}\n\t\tcnt++;\n\t}\n\tif (lastp)\n\t\t*lastp = NULL;\n\treturn 0;\nerr:\n\t/* Rollback the instances if one failed */\n\tcbm = !bringup ? step->startup.multi : step->teardown.multi;\n\tif (!cbm)\n\t\treturn ret;\n\n\thlist_for_each(node, &step->list) {\n\t\tif (!cnt--)\n\t\t\tbreak;\n\n\t\ttrace_cpuhp_multi_enter(cpu, st->target, state, cbm, node);\n\t\tret = cbm(cpu, node);\n\t\ttrace_cpuhp_exit(cpu, st->state, state, ret);\n\t\t/*\n\t\t * Rollback must not fail,\n\t\t */\n\t\tWARN_ON_ONCE(ret);\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/scs.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sched/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "ret"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_cpuhp_exit",
          "args": [
            "cpu",
            "st->state",
            "state",
            "ret"
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cbm",
          "args": [
            "cpu",
            "node"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_cpuhp_multi_enter",
          "args": [
            "cpu",
            "st->target",
            "state",
            "cbm",
            "node"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_for_each",
          "args": [
            "node",
            "&step->list"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_cpuhp_exit",
          "args": [
            "cpu",
            "st->state",
            "state",
            "ret"
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cbm",
          "args": [
            "cpu",
            "node"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_cpuhp_multi_enter",
          "args": [
            "cpu",
            "st->target",
            "state",
            "cbm",
            "node"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_for_each",
          "args": [
            "node",
            "&step->list"
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_cpuhp_exit",
          "args": [
            "cpu",
            "st->state",
            "state",
            "ret"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cbm",
          "args": [
            "cpu",
            "node"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_cpuhp_multi_enter",
          "args": [
            "cpu",
            "st->target",
            "state",
            "cbm",
            "node"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "lastp && *lastp"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_cpuhp_exit",
          "args": [
            "cpu",
            "st->state",
            "state",
            "ret"
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cb",
          "args": [
            "cpu"
          ],
          "line": 191
        },
        "resolved": true,
        "details": {
          "function_name": "cpuhp_get_teardown_cb",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "1888-1891",
          "snippet": "static void *cpuhp_get_teardown_cb(enum cpuhp_state state)\n{\n\treturn cpuhp_get_step(state)->teardown.single;\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\n\nstatic void *cpuhp_get_teardown_cb(enum cpuhp_state state)\n{\n\treturn cpuhp_get_step(state)->teardown.single;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_cpuhp_enter",
          "args": [
            "cpu",
            "st->target",
            "state",
            "cb"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "lastp && *lastp"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "1"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpuhp_step_empty",
          "args": [
            "bringup",
            "step"
          ],
          "line": 181
        },
        "resolved": true,
        "details": {
          "function_name": "cpuhp_step_empty",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "149-152",
          "snippet": "static bool cpuhp_step_empty(bool bringup, struct cpuhp_step *step)\n{\n\treturn bringup ? !step->startup.single : !step->teardown.single;\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstatic bool cpuhp_step_empty(bool bringup, struct cpuhp_step *step)\n{\n\treturn bringup ? !step->startup.single : !step->teardown.single;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpuhp_get_step",
          "args": [
            "state"
          ],
          "line": 171
        },
        "resolved": true,
        "details": {
          "function_name": "cpuhp_get_step",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "144-147",
          "snippet": "static struct cpuhp_step *cpuhp_get_step(enum cpuhp_state state)\n{\n\treturn cpuhp_hp_states + state;\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};",
            "static struct cpuhp_step cpuhp_hp_states[];",
            "static struct cpuhp_step cpuhp_hp_states[] = {\n\t[CPUHP_OFFLINE] = {\n\t\t.name\t\t\t= \"offline\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= NULL,\n\t},\n#ifdef CONFIG_SMP\n\t[CPUHP_CREATE_THREADS]= {\n\t\t.name\t\t\t= \"threads:prepare\",\n\t\t.startup.single\t\t= smpboot_create_threads,\n\t\t.teardown.single\t= NULL,\n\t\t.cant_stop\t\t= true,\n\t},\n\t[CPUHP_PERF_PREPARE] = {\n\t\t.name\t\t\t= \"perf:prepare\",\n\t\t.startup.single\t\t= perf_event_init_cpu,\n\t\t.teardown.single\t= perf_event_exit_cpu,\n\t},\n\t[CPUHP_WORKQUEUE_PREP] = {\n\t\t.name\t\t\t= \"workqueue:prepare\",\n\t\t.startup.single\t\t= workqueue_prepare_cpu,\n\t\t.teardown.single\t= NULL,\n\t},\n\t[CPUHP_HRTIMERS_PREPARE] = {\n\t\t.name\t\t\t= \"hrtimers:prepare\",\n\t\t.startup.single\t\t= hrtimers_prepare_cpu,\n\t\t.teardown.single\t= hrtimers_dead_cpu,\n\t},\n\t[CPUHP_SMPCFD_PREPARE] = {\n\t\t.name\t\t\t= \"smpcfd:prepare\",\n\t\t.startup.single\t\t= smpcfd_prepare_cpu,\n\t\t.teardown.single\t= smpcfd_dead_cpu,\n\t},\n\t[CPUHP_RELAY_PREPARE] = {\n\t\t.name\t\t\t= \"relay:prepare\",\n\t\t.startup.single\t\t= relay_prepare_cpu,\n\t\t.teardown.single\t= NULL,\n\t},\n\t[CPUHP_SLAB_PREPARE] = {\n\t\t.name\t\t\t= \"slab:prepare\",\n\t\t.startup.single\t\t= slab_prepare_cpu,\n\t\t.teardown.single\t= slab_dead_cpu,\n\t},\n\t[CPUHP_RCUTREE_PREP] = {\n\t\t.name\t\t\t= \"RCU/tree:prepare\",\n\t\t.startup.single\t\t= rcutree_prepare_cpu,\n\t\t.teardown.single\t= rcutree_dead_cpu,\n\t},\n\t/*\n\t * On the tear-down path, timers_dead_cpu() must be invoked\n\t * before blk_mq_queue_reinit_notify() from notify_dead(),\n\t * otherwise a RCU stall occurs.\n\t */\n\t[CPUHP_TIMERS_PREPARE] = {\n\t\t.name\t\t\t= \"timers:prepare\",\n\t\t.startup.single\t\t= timers_prepare_cpu,\n\t\t.teardown.single\t= timers_dead_cpu,\n\t},\n\t/* Kicks the plugged cpu into life */\n\t[CPUHP_BRINGUP_CPU] = {\n\t\t.name\t\t\t= \"cpu:bringup\",\n\t\t.startup.single\t\t= bringup_cpu,\n\t\t.teardown.single\t= finish_cpu,\n\t\t.cant_stop\t\t= true,\n\t},\n\t/* Final state before CPU kills itself */\n\t[CPUHP_AP_IDLE_DEAD] = {\n\t\t.name\t\t\t= \"idle:dead\",\n\t},\n\t/*\n\t * Last state before CPU enters the idle loop to die. Transient state\n\t * for synchronization.\n\t */\n\t[CPUHP_AP_OFFLINE] = {\n\t\t.name\t\t\t= \"ap:offline\",\n\t\t.cant_stop\t\t= true,\n\t},\n\t/* First state is scheduler control. Interrupts are disabled */\n\t[CPUHP_AP_SCHED_STARTING] = {\n\t\t.name\t\t\t= \"sched:starting\",\n\t\t.startup.single\t\t= sched_cpu_starting,\n\t\t.teardown.single\t= sched_cpu_dying,\n\t},\n\t[CPUHP_AP_RCUTREE_DYING] = {\n\t\t.name\t\t\t= \"RCU/tree:dying\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= rcutree_dying_cpu,\n\t},\n\t[CPUHP_AP_SMPCFD_DYING] = {\n\t\t.name\t\t\t= \"smpcfd:dying\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= smpcfd_dying_cpu,\n\t},\n\t/* Entry state on starting. Interrupts enabled from here on. Transient\n\t * state for synchronsization */\n\t[CPUHP_AP_ONLINE] = {\n\t\t.name\t\t\t= \"ap:online\",\n\t},\n\t/*\n\t * Handled on control processor until the plugged processor manages\n\t * this itself.\n\t */\n\t[CPUHP_TEARDOWN_CPU] = {\n\t\t.name\t\t\t= \"cpu:teardown\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= takedown_cpu,\n\t\t.cant_stop\t\t= true,\n\t},\n\n\t[CPUHP_AP_SCHED_WAIT_EMPTY] = {\n\t\t.name\t\t\t= \"sched:waitempty\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= sched_cpu_wait_empty,\n\t},\n\n\t/* Handle smpboot threads park/unpark */\n\t[CPUHP_AP_SMPBOOT_THREADS] = {\n\t\t.name\t\t\t= \"smpboot/threads:online\",\n\t\t.startup.single\t\t= smpboot_unpark_threads,\n\t\t.teardown.single\t= smpboot_park_threads,\n\t},\n\t[CPUHP_AP_IRQ_AFFINITY_ONLINE] = {\n\t\t.name\t\t\t= \"irq/affinity:online\",\n\t\t.startup.single\t\t= irq_affinity_online_cpu,\n\t\t.teardown.single\t= NULL,\n\t},\n\t[CPUHP_AP_PERF_ONLINE] = {\n\t\t.name\t\t\t= \"perf:online\",\n\t\t.startup.single\t\t= perf_event_init_cpu,\n\t\t.teardown.single\t= perf_event_exit_cpu,\n\t},\n\t[CPUHP_AP_WATCHDOG_ONLINE] = {\n\t\t.name\t\t\t= \"lockup_detector:online\",\n\t\t.startup.single\t\t= lockup_detector_online_cpu,\n\t\t.teardown.single\t= lockup_detector_offline_cpu,\n\t},\n\t[CPUHP_AP_WORKQUEUE_ONLINE] = {\n\t\t.name\t\t\t= \"workqueue:online\",\n\t\t.startup.single\t\t= workqueue_online_cpu,\n\t\t.teardown.single\t= workqueue_offline_cpu,\n\t},\n\t[CPUHP_AP_RCUTREE_ONLINE] = {\n\t\t.name\t\t\t= \"RCU/tree:online\",\n\t\t.startup.single\t\t= rcutree_online_cpu,\n\t\t.teardown.single\t= rcutree_offline_cpu,\n\t},\n#endif\n\t/*\n\t * The dynamically registered state space is here\n\t */\n\n#ifdef CONFIG_SMP\n\t/* Last state is scheduler control setting the cpu active */\n\t[CPUHP_AP_ACTIVE] = {\n\t\t.name\t\t\t= \"sched:active\",\n\t\t.startup.single\t\t= sched_cpu_activate,\n\t\t.teardown.single\t= sched_cpu_deactivate,\n\t},\n#endif\n\n\t/* CPU is fully up and running. */\n\t[CPUHP_ONLINE] = {\n\t\t.name\t\t\t= \"online\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= NULL,\n\t},\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\nstatic struct cpuhp_step cpuhp_hp_states[];\nstatic struct cpuhp_step cpuhp_hp_states[] = {\n\t[CPUHP_OFFLINE] = {\n\t\t.name\t\t\t= \"offline\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= NULL,\n\t},\n#ifdef CONFIG_SMP\n\t[CPUHP_CREATE_THREADS]= {\n\t\t.name\t\t\t= \"threads:prepare\",\n\t\t.startup.single\t\t= smpboot_create_threads,\n\t\t.teardown.single\t= NULL,\n\t\t.cant_stop\t\t= true,\n\t},\n\t[CPUHP_PERF_PREPARE] = {\n\t\t.name\t\t\t= \"perf:prepare\",\n\t\t.startup.single\t\t= perf_event_init_cpu,\n\t\t.teardown.single\t= perf_event_exit_cpu,\n\t},\n\t[CPUHP_WORKQUEUE_PREP] = {\n\t\t.name\t\t\t= \"workqueue:prepare\",\n\t\t.startup.single\t\t= workqueue_prepare_cpu,\n\t\t.teardown.single\t= NULL,\n\t},\n\t[CPUHP_HRTIMERS_PREPARE] = {\n\t\t.name\t\t\t= \"hrtimers:prepare\",\n\t\t.startup.single\t\t= hrtimers_prepare_cpu,\n\t\t.teardown.single\t= hrtimers_dead_cpu,\n\t},\n\t[CPUHP_SMPCFD_PREPARE] = {\n\t\t.name\t\t\t= \"smpcfd:prepare\",\n\t\t.startup.single\t\t= smpcfd_prepare_cpu,\n\t\t.teardown.single\t= smpcfd_dead_cpu,\n\t},\n\t[CPUHP_RELAY_PREPARE] = {\n\t\t.name\t\t\t= \"relay:prepare\",\n\t\t.startup.single\t\t= relay_prepare_cpu,\n\t\t.teardown.single\t= NULL,\n\t},\n\t[CPUHP_SLAB_PREPARE] = {\n\t\t.name\t\t\t= \"slab:prepare\",\n\t\t.startup.single\t\t= slab_prepare_cpu,\n\t\t.teardown.single\t= slab_dead_cpu,\n\t},\n\t[CPUHP_RCUTREE_PREP] = {\n\t\t.name\t\t\t= \"RCU/tree:prepare\",\n\t\t.startup.single\t\t= rcutree_prepare_cpu,\n\t\t.teardown.single\t= rcutree_dead_cpu,\n\t},\n\t/*\n\t * On the tear-down path, timers_dead_cpu() must be invoked\n\t * before blk_mq_queue_reinit_notify() from notify_dead(),\n\t * otherwise a RCU stall occurs.\n\t */\n\t[CPUHP_TIMERS_PREPARE] = {\n\t\t.name\t\t\t= \"timers:prepare\",\n\t\t.startup.single\t\t= timers_prepare_cpu,\n\t\t.teardown.single\t= timers_dead_cpu,\n\t},\n\t/* Kicks the plugged cpu into life */\n\t[CPUHP_BRINGUP_CPU] = {\n\t\t.name\t\t\t= \"cpu:bringup\",\n\t\t.startup.single\t\t= bringup_cpu,\n\t\t.teardown.single\t= finish_cpu,\n\t\t.cant_stop\t\t= true,\n\t},\n\t/* Final state before CPU kills itself */\n\t[CPUHP_AP_IDLE_DEAD] = {\n\t\t.name\t\t\t= \"idle:dead\",\n\t},\n\t/*\n\t * Last state before CPU enters the idle loop to die. Transient state\n\t * for synchronization.\n\t */\n\t[CPUHP_AP_OFFLINE] = {\n\t\t.name\t\t\t= \"ap:offline\",\n\t\t.cant_stop\t\t= true,\n\t},\n\t/* First state is scheduler control. Interrupts are disabled */\n\t[CPUHP_AP_SCHED_STARTING] = {\n\t\t.name\t\t\t= \"sched:starting\",\n\t\t.startup.single\t\t= sched_cpu_starting,\n\t\t.teardown.single\t= sched_cpu_dying,\n\t},\n\t[CPUHP_AP_RCUTREE_DYING] = {\n\t\t.name\t\t\t= \"RCU/tree:dying\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= rcutree_dying_cpu,\n\t},\n\t[CPUHP_AP_SMPCFD_DYING] = {\n\t\t.name\t\t\t= \"smpcfd:dying\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= smpcfd_dying_cpu,\n\t},\n\t/* Entry state on starting. Interrupts enabled from here on. Transient\n\t * state for synchronsization */\n\t[CPUHP_AP_ONLINE] = {\n\t\t.name\t\t\t= \"ap:online\",\n\t},\n\t/*\n\t * Handled on control processor until the plugged processor manages\n\t * this itself.\n\t */\n\t[CPUHP_TEARDOWN_CPU] = {\n\t\t.name\t\t\t= \"cpu:teardown\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= takedown_cpu,\n\t\t.cant_stop\t\t= true,\n\t},\n\n\t[CPUHP_AP_SCHED_WAIT_EMPTY] = {\n\t\t.name\t\t\t= \"sched:waitempty\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= sched_cpu_wait_empty,\n\t},\n\n\t/* Handle smpboot threads park/unpark */\n\t[CPUHP_AP_SMPBOOT_THREADS] = {\n\t\t.name\t\t\t= \"smpboot/threads:online\",\n\t\t.startup.single\t\t= smpboot_unpark_threads,\n\t\t.teardown.single\t= smpboot_park_threads,\n\t},\n\t[CPUHP_AP_IRQ_AFFINITY_ONLINE] = {\n\t\t.name\t\t\t= \"irq/affinity:online\",\n\t\t.startup.single\t\t= irq_affinity_online_cpu,\n\t\t.teardown.single\t= NULL,\n\t},\n\t[CPUHP_AP_PERF_ONLINE] = {\n\t\t.name\t\t\t= \"perf:online\",\n\t\t.startup.single\t\t= perf_event_init_cpu,\n\t\t.teardown.single\t= perf_event_exit_cpu,\n\t},\n\t[CPUHP_AP_WATCHDOG_ONLINE] = {\n\t\t.name\t\t\t= \"lockup_detector:online\",\n\t\t.startup.single\t\t= lockup_detector_online_cpu,\n\t\t.teardown.single\t= lockup_detector_offline_cpu,\n\t},\n\t[CPUHP_AP_WORKQUEUE_ONLINE] = {\n\t\t.name\t\t\t= \"workqueue:online\",\n\t\t.startup.single\t\t= workqueue_online_cpu,\n\t\t.teardown.single\t= workqueue_offline_cpu,\n\t},\n\t[CPUHP_AP_RCUTREE_ONLINE] = {\n\t\t.name\t\t\t= \"RCU/tree:online\",\n\t\t.startup.single\t\t= rcutree_online_cpu,\n\t\t.teardown.single\t= rcutree_offline_cpu,\n\t},\n#endif\n\t/*\n\t * The dynamically registered state space is here\n\t */\n\n#ifdef CONFIG_SMP\n\t/* Last state is scheduler control setting the cpu active */\n\t[CPUHP_AP_ACTIVE] = {\n\t\t.name\t\t\t= \"sched:active\",\n\t\t.startup.single\t\t= sched_cpu_activate,\n\t\t.teardown.single\t= sched_cpu_deactivate,\n\t},\n#endif\n\n\t/* CPU is fully up and running. */\n\t[CPUHP_ONLINE] = {\n\t\t.name\t\t\t= \"online\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= NULL,\n\t},\n};\n\nstatic struct cpuhp_step *cpuhp_get_step(enum cpuhp_state state)\n{\n\treturn cpuhp_hp_states + state;\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "&cpuhp_state",
            "cpu"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\n\nstatic int cpuhp_invoke_callback(unsigned int cpu, enum cpuhp_state state,\n\t\t\t\t bool bringup, struct hlist_node *node,\n\t\t\t\t struct hlist_node **lastp)\n{\n\tstruct cpuhp_cpu_state *st = per_cpu_ptr(&cpuhp_state, cpu);\n\tstruct cpuhp_step *step = cpuhp_get_step(state);\n\tint (*cbm)(unsigned int cpu, struct hlist_node *node);\n\tint (*cb)(unsigned int cpu);\n\tint ret, cnt;\n\n\tif (st->fail == state) {\n\t\tst->fail = CPUHP_INVALID;\n\t\treturn -EAGAIN;\n\t}\n\n\tif (cpuhp_step_empty(bringup, step)) {\n\t\tWARN_ON_ONCE(1);\n\t\treturn 0;\n\t}\n\n\tif (!step->multi_instance) {\n\t\tWARN_ON_ONCE(lastp && *lastp);\n\t\tcb = bringup ? step->startup.single : step->teardown.single;\n\n\t\ttrace_cpuhp_enter(cpu, st->target, state, cb);\n\t\tret = cb(cpu);\n\t\ttrace_cpuhp_exit(cpu, st->state, state, ret);\n\t\treturn ret;\n\t}\n\tcbm = bringup ? step->startup.multi : step->teardown.multi;\n\n\t/* Single invocation for instance add/remove */\n\tif (node) {\n\t\tWARN_ON_ONCE(lastp && *lastp);\n\t\ttrace_cpuhp_multi_enter(cpu, st->target, state, cbm, node);\n\t\tret = cbm(cpu, node);\n\t\ttrace_cpuhp_exit(cpu, st->state, state, ret);\n\t\treturn ret;\n\t}\n\n\t/* State transition. Invoke on all instances */\n\tcnt = 0;\n\thlist_for_each(node, &step->list) {\n\t\tif (lastp && node == *lastp)\n\t\t\tbreak;\n\n\t\ttrace_cpuhp_multi_enter(cpu, st->target, state, cbm, node);\n\t\tret = cbm(cpu, node);\n\t\ttrace_cpuhp_exit(cpu, st->state, state, ret);\n\t\tif (ret) {\n\t\t\tif (!lastp)\n\t\t\t\tgoto err;\n\n\t\t\t*lastp = node;\n\t\t\treturn ret;\n\t\t}\n\t\tcnt++;\n\t}\n\tif (lastp)\n\t\t*lastp = NULL;\n\treturn 0;\nerr:\n\t/* Rollback the instances if one failed */\n\tcbm = !bringup ? step->startup.multi : step->teardown.multi;\n\tif (!cbm)\n\t\treturn ret;\n\n\thlist_for_each(node, &step->list) {\n\t\tif (!cnt--)\n\t\t\tbreak;\n\n\t\ttrace_cpuhp_multi_enter(cpu, st->target, state, cbm, node);\n\t\tret = cbm(cpu, node);\n\t\ttrace_cpuhp_exit(cpu, st->state, state, ret);\n\t\t/*\n\t\t * Rollback must not fail,\n\t\t */\n\t\tWARN_ON_ONCE(ret);\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "cpuhp_step_empty",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
    "lines": "149-152",
    "snippet": "static bool cpuhp_step_empty(bool bringup, struct cpuhp_step *step)\n{\n\treturn bringup ? !step->startup.single : !step->teardown.single;\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/scs.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sched/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstatic bool cpuhp_step_empty(bool bringup, struct cpuhp_step *step)\n{\n\treturn bringup ? !step->startup.single : !step->teardown.single;\n}"
  },
  {
    "function_name": "cpuhp_get_step",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
    "lines": "144-147",
    "snippet": "static struct cpuhp_step *cpuhp_get_step(enum cpuhp_state state)\n{\n\treturn cpuhp_hp_states + state;\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/scs.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sched/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};",
      "static struct cpuhp_step cpuhp_hp_states[];",
      "static struct cpuhp_step cpuhp_hp_states[] = {\n\t[CPUHP_OFFLINE] = {\n\t\t.name\t\t\t= \"offline\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= NULL,\n\t},\n#ifdef CONFIG_SMP\n\t[CPUHP_CREATE_THREADS]= {\n\t\t.name\t\t\t= \"threads:prepare\",\n\t\t.startup.single\t\t= smpboot_create_threads,\n\t\t.teardown.single\t= NULL,\n\t\t.cant_stop\t\t= true,\n\t},\n\t[CPUHP_PERF_PREPARE] = {\n\t\t.name\t\t\t= \"perf:prepare\",\n\t\t.startup.single\t\t= perf_event_init_cpu,\n\t\t.teardown.single\t= perf_event_exit_cpu,\n\t},\n\t[CPUHP_WORKQUEUE_PREP] = {\n\t\t.name\t\t\t= \"workqueue:prepare\",\n\t\t.startup.single\t\t= workqueue_prepare_cpu,\n\t\t.teardown.single\t= NULL,\n\t},\n\t[CPUHP_HRTIMERS_PREPARE] = {\n\t\t.name\t\t\t= \"hrtimers:prepare\",\n\t\t.startup.single\t\t= hrtimers_prepare_cpu,\n\t\t.teardown.single\t= hrtimers_dead_cpu,\n\t},\n\t[CPUHP_SMPCFD_PREPARE] = {\n\t\t.name\t\t\t= \"smpcfd:prepare\",\n\t\t.startup.single\t\t= smpcfd_prepare_cpu,\n\t\t.teardown.single\t= smpcfd_dead_cpu,\n\t},\n\t[CPUHP_RELAY_PREPARE] = {\n\t\t.name\t\t\t= \"relay:prepare\",\n\t\t.startup.single\t\t= relay_prepare_cpu,\n\t\t.teardown.single\t= NULL,\n\t},\n\t[CPUHP_SLAB_PREPARE] = {\n\t\t.name\t\t\t= \"slab:prepare\",\n\t\t.startup.single\t\t= slab_prepare_cpu,\n\t\t.teardown.single\t= slab_dead_cpu,\n\t},\n\t[CPUHP_RCUTREE_PREP] = {\n\t\t.name\t\t\t= \"RCU/tree:prepare\",\n\t\t.startup.single\t\t= rcutree_prepare_cpu,\n\t\t.teardown.single\t= rcutree_dead_cpu,\n\t},\n\t/*\n\t * On the tear-down path, timers_dead_cpu() must be invoked\n\t * before blk_mq_queue_reinit_notify() from notify_dead(),\n\t * otherwise a RCU stall occurs.\n\t */\n\t[CPUHP_TIMERS_PREPARE] = {\n\t\t.name\t\t\t= \"timers:prepare\",\n\t\t.startup.single\t\t= timers_prepare_cpu,\n\t\t.teardown.single\t= timers_dead_cpu,\n\t},\n\t/* Kicks the plugged cpu into life */\n\t[CPUHP_BRINGUP_CPU] = {\n\t\t.name\t\t\t= \"cpu:bringup\",\n\t\t.startup.single\t\t= bringup_cpu,\n\t\t.teardown.single\t= finish_cpu,\n\t\t.cant_stop\t\t= true,\n\t},\n\t/* Final state before CPU kills itself */\n\t[CPUHP_AP_IDLE_DEAD] = {\n\t\t.name\t\t\t= \"idle:dead\",\n\t},\n\t/*\n\t * Last state before CPU enters the idle loop to die. Transient state\n\t * for synchronization.\n\t */\n\t[CPUHP_AP_OFFLINE] = {\n\t\t.name\t\t\t= \"ap:offline\",\n\t\t.cant_stop\t\t= true,\n\t},\n\t/* First state is scheduler control. Interrupts are disabled */\n\t[CPUHP_AP_SCHED_STARTING] = {\n\t\t.name\t\t\t= \"sched:starting\",\n\t\t.startup.single\t\t= sched_cpu_starting,\n\t\t.teardown.single\t= sched_cpu_dying,\n\t},\n\t[CPUHP_AP_RCUTREE_DYING] = {\n\t\t.name\t\t\t= \"RCU/tree:dying\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= rcutree_dying_cpu,\n\t},\n\t[CPUHP_AP_SMPCFD_DYING] = {\n\t\t.name\t\t\t= \"smpcfd:dying\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= smpcfd_dying_cpu,\n\t},\n\t/* Entry state on starting. Interrupts enabled from here on. Transient\n\t * state for synchronsization */\n\t[CPUHP_AP_ONLINE] = {\n\t\t.name\t\t\t= \"ap:online\",\n\t},\n\t/*\n\t * Handled on control processor until the plugged processor manages\n\t * this itself.\n\t */\n\t[CPUHP_TEARDOWN_CPU] = {\n\t\t.name\t\t\t= \"cpu:teardown\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= takedown_cpu,\n\t\t.cant_stop\t\t= true,\n\t},\n\n\t[CPUHP_AP_SCHED_WAIT_EMPTY] = {\n\t\t.name\t\t\t= \"sched:waitempty\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= sched_cpu_wait_empty,\n\t},\n\n\t/* Handle smpboot threads park/unpark */\n\t[CPUHP_AP_SMPBOOT_THREADS] = {\n\t\t.name\t\t\t= \"smpboot/threads:online\",\n\t\t.startup.single\t\t= smpboot_unpark_threads,\n\t\t.teardown.single\t= smpboot_park_threads,\n\t},\n\t[CPUHP_AP_IRQ_AFFINITY_ONLINE] = {\n\t\t.name\t\t\t= \"irq/affinity:online\",\n\t\t.startup.single\t\t= irq_affinity_online_cpu,\n\t\t.teardown.single\t= NULL,\n\t},\n\t[CPUHP_AP_PERF_ONLINE] = {\n\t\t.name\t\t\t= \"perf:online\",\n\t\t.startup.single\t\t= perf_event_init_cpu,\n\t\t.teardown.single\t= perf_event_exit_cpu,\n\t},\n\t[CPUHP_AP_WATCHDOG_ONLINE] = {\n\t\t.name\t\t\t= \"lockup_detector:online\",\n\t\t.startup.single\t\t= lockup_detector_online_cpu,\n\t\t.teardown.single\t= lockup_detector_offline_cpu,\n\t},\n\t[CPUHP_AP_WORKQUEUE_ONLINE] = {\n\t\t.name\t\t\t= \"workqueue:online\",\n\t\t.startup.single\t\t= workqueue_online_cpu,\n\t\t.teardown.single\t= workqueue_offline_cpu,\n\t},\n\t[CPUHP_AP_RCUTREE_ONLINE] = {\n\t\t.name\t\t\t= \"RCU/tree:online\",\n\t\t.startup.single\t\t= rcutree_online_cpu,\n\t\t.teardown.single\t= rcutree_offline_cpu,\n\t},\n#endif\n\t/*\n\t * The dynamically registered state space is here\n\t */\n\n#ifdef CONFIG_SMP\n\t/* Last state is scheduler control setting the cpu active */\n\t[CPUHP_AP_ACTIVE] = {\n\t\t.name\t\t\t= \"sched:active\",\n\t\t.startup.single\t\t= sched_cpu_activate,\n\t\t.teardown.single\t= sched_cpu_deactivate,\n\t},\n#endif\n\n\t/* CPU is fully up and running. */\n\t[CPUHP_ONLINE] = {\n\t\t.name\t\t\t= \"online\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= NULL,\n\t},\n};"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\nstatic struct cpuhp_step cpuhp_hp_states[];\nstatic struct cpuhp_step cpuhp_hp_states[] = {\n\t[CPUHP_OFFLINE] = {\n\t\t.name\t\t\t= \"offline\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= NULL,\n\t},\n#ifdef CONFIG_SMP\n\t[CPUHP_CREATE_THREADS]= {\n\t\t.name\t\t\t= \"threads:prepare\",\n\t\t.startup.single\t\t= smpboot_create_threads,\n\t\t.teardown.single\t= NULL,\n\t\t.cant_stop\t\t= true,\n\t},\n\t[CPUHP_PERF_PREPARE] = {\n\t\t.name\t\t\t= \"perf:prepare\",\n\t\t.startup.single\t\t= perf_event_init_cpu,\n\t\t.teardown.single\t= perf_event_exit_cpu,\n\t},\n\t[CPUHP_WORKQUEUE_PREP] = {\n\t\t.name\t\t\t= \"workqueue:prepare\",\n\t\t.startup.single\t\t= workqueue_prepare_cpu,\n\t\t.teardown.single\t= NULL,\n\t},\n\t[CPUHP_HRTIMERS_PREPARE] = {\n\t\t.name\t\t\t= \"hrtimers:prepare\",\n\t\t.startup.single\t\t= hrtimers_prepare_cpu,\n\t\t.teardown.single\t= hrtimers_dead_cpu,\n\t},\n\t[CPUHP_SMPCFD_PREPARE] = {\n\t\t.name\t\t\t= \"smpcfd:prepare\",\n\t\t.startup.single\t\t= smpcfd_prepare_cpu,\n\t\t.teardown.single\t= smpcfd_dead_cpu,\n\t},\n\t[CPUHP_RELAY_PREPARE] = {\n\t\t.name\t\t\t= \"relay:prepare\",\n\t\t.startup.single\t\t= relay_prepare_cpu,\n\t\t.teardown.single\t= NULL,\n\t},\n\t[CPUHP_SLAB_PREPARE] = {\n\t\t.name\t\t\t= \"slab:prepare\",\n\t\t.startup.single\t\t= slab_prepare_cpu,\n\t\t.teardown.single\t= slab_dead_cpu,\n\t},\n\t[CPUHP_RCUTREE_PREP] = {\n\t\t.name\t\t\t= \"RCU/tree:prepare\",\n\t\t.startup.single\t\t= rcutree_prepare_cpu,\n\t\t.teardown.single\t= rcutree_dead_cpu,\n\t},\n\t/*\n\t * On the tear-down path, timers_dead_cpu() must be invoked\n\t * before blk_mq_queue_reinit_notify() from notify_dead(),\n\t * otherwise a RCU stall occurs.\n\t */\n\t[CPUHP_TIMERS_PREPARE] = {\n\t\t.name\t\t\t= \"timers:prepare\",\n\t\t.startup.single\t\t= timers_prepare_cpu,\n\t\t.teardown.single\t= timers_dead_cpu,\n\t},\n\t/* Kicks the plugged cpu into life */\n\t[CPUHP_BRINGUP_CPU] = {\n\t\t.name\t\t\t= \"cpu:bringup\",\n\t\t.startup.single\t\t= bringup_cpu,\n\t\t.teardown.single\t= finish_cpu,\n\t\t.cant_stop\t\t= true,\n\t},\n\t/* Final state before CPU kills itself */\n\t[CPUHP_AP_IDLE_DEAD] = {\n\t\t.name\t\t\t= \"idle:dead\",\n\t},\n\t/*\n\t * Last state before CPU enters the idle loop to die. Transient state\n\t * for synchronization.\n\t */\n\t[CPUHP_AP_OFFLINE] = {\n\t\t.name\t\t\t= \"ap:offline\",\n\t\t.cant_stop\t\t= true,\n\t},\n\t/* First state is scheduler control. Interrupts are disabled */\n\t[CPUHP_AP_SCHED_STARTING] = {\n\t\t.name\t\t\t= \"sched:starting\",\n\t\t.startup.single\t\t= sched_cpu_starting,\n\t\t.teardown.single\t= sched_cpu_dying,\n\t},\n\t[CPUHP_AP_RCUTREE_DYING] = {\n\t\t.name\t\t\t= \"RCU/tree:dying\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= rcutree_dying_cpu,\n\t},\n\t[CPUHP_AP_SMPCFD_DYING] = {\n\t\t.name\t\t\t= \"smpcfd:dying\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= smpcfd_dying_cpu,\n\t},\n\t/* Entry state on starting. Interrupts enabled from here on. Transient\n\t * state for synchronsization */\n\t[CPUHP_AP_ONLINE] = {\n\t\t.name\t\t\t= \"ap:online\",\n\t},\n\t/*\n\t * Handled on control processor until the plugged processor manages\n\t * this itself.\n\t */\n\t[CPUHP_TEARDOWN_CPU] = {\n\t\t.name\t\t\t= \"cpu:teardown\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= takedown_cpu,\n\t\t.cant_stop\t\t= true,\n\t},\n\n\t[CPUHP_AP_SCHED_WAIT_EMPTY] = {\n\t\t.name\t\t\t= \"sched:waitempty\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= sched_cpu_wait_empty,\n\t},\n\n\t/* Handle smpboot threads park/unpark */\n\t[CPUHP_AP_SMPBOOT_THREADS] = {\n\t\t.name\t\t\t= \"smpboot/threads:online\",\n\t\t.startup.single\t\t= smpboot_unpark_threads,\n\t\t.teardown.single\t= smpboot_park_threads,\n\t},\n\t[CPUHP_AP_IRQ_AFFINITY_ONLINE] = {\n\t\t.name\t\t\t= \"irq/affinity:online\",\n\t\t.startup.single\t\t= irq_affinity_online_cpu,\n\t\t.teardown.single\t= NULL,\n\t},\n\t[CPUHP_AP_PERF_ONLINE] = {\n\t\t.name\t\t\t= \"perf:online\",\n\t\t.startup.single\t\t= perf_event_init_cpu,\n\t\t.teardown.single\t= perf_event_exit_cpu,\n\t},\n\t[CPUHP_AP_WATCHDOG_ONLINE] = {\n\t\t.name\t\t\t= \"lockup_detector:online\",\n\t\t.startup.single\t\t= lockup_detector_online_cpu,\n\t\t.teardown.single\t= lockup_detector_offline_cpu,\n\t},\n\t[CPUHP_AP_WORKQUEUE_ONLINE] = {\n\t\t.name\t\t\t= \"workqueue:online\",\n\t\t.startup.single\t\t= workqueue_online_cpu,\n\t\t.teardown.single\t= workqueue_offline_cpu,\n\t},\n\t[CPUHP_AP_RCUTREE_ONLINE] = {\n\t\t.name\t\t\t= \"RCU/tree:online\",\n\t\t.startup.single\t\t= rcutree_online_cpu,\n\t\t.teardown.single\t= rcutree_offline_cpu,\n\t},\n#endif\n\t/*\n\t * The dynamically registered state space is here\n\t */\n\n#ifdef CONFIG_SMP\n\t/* Last state is scheduler control setting the cpu active */\n\t[CPUHP_AP_ACTIVE] = {\n\t\t.name\t\t\t= \"sched:active\",\n\t\t.startup.single\t\t= sched_cpu_activate,\n\t\t.teardown.single\t= sched_cpu_deactivate,\n\t},\n#endif\n\n\t/* CPU is fully up and running. */\n\t[CPUHP_ONLINE] = {\n\t\t.name\t\t\t= \"online\",\n\t\t.startup.single\t\t= NULL,\n\t\t.teardown.single\t= NULL,\n\t},\n};\n\nstatic struct cpuhp_step *cpuhp_get_step(enum cpuhp_state state)\n{\n\treturn cpuhp_hp_states + state;\n}"
  },
  {
    "function_name": "cpuhp_lock_release",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
    "lines": "110-110",
    "snippet": "static inline void cpuhp_lock_release(bool bringup) { }",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/scs.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sched/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstatic inline void cpuhp_lock_release(bool bringup) { }"
  },
  {
    "function_name": "cpuhp_lock_acquire",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
    "lines": "109-109",
    "snippet": "static inline void cpuhp_lock_acquire(bool bringup) { }",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/scs.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sched/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstatic inline void cpuhp_lock_acquire(bool bringup) { }"
  },
  {
    "function_name": "cpuhp_lock_release",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
    "lines": "103-106",
    "snippet": "static inline void cpuhp_lock_release(bool bringup)\n{\n\tlock_map_release(bringup ? &cpuhp_state_up_map : &cpuhp_state_down_map);\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/scs.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sched/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lock_map_release",
          "args": [
            "bringup ? &cpuhp_state_up_map : &cpuhp_state_down_map"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstatic inline void cpuhp_lock_release(bool bringup)\n{\n\tlock_map_release(bringup ? &cpuhp_state_up_map : &cpuhp_state_down_map);\n}"
  },
  {
    "function_name": "cpuhp_lock_acquire",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
    "lines": "98-101",
    "snippet": "static inline void cpuhp_lock_acquire(bool bringup)\n{\n\tlock_map_acquire(bringup ? &cpuhp_state_up_map : &cpuhp_state_down_map);\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <trace/events/cpuhp.h>",
      "#include <trace/events/power.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/scs.h>",
      "#include <linux/slab.h>",
      "#include <linux/relay.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/nmi.h>",
      "#include <linux/irq.h>",
      "#include <linux/tick.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/suspend.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/kthread.h>",
      "#include <linux/bug.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/oom.h>",
      "#include <linux/cpu.h>",
      "#include <linux/unistd.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/hotplug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/smp.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sched/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lock_map_acquire",
          "args": [
            "bringup ? &cpuhp_state_up_map : &cpuhp_state_down_map"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstatic inline void cpuhp_lock_acquire(bool bringup)\n{\n\tlock_map_acquire(bringup ? &cpuhp_state_up_map : &cpuhp_state_down_map);\n}"
  }
]