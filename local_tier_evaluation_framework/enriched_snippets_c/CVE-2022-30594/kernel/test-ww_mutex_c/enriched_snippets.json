[
  {
    "function_name": "test_ww_mutex_exit",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/test-ww_mutex.c",
    "lines": "670-673",
    "snippet": "static void __exit test_ww_mutex_exit(void)\n{\n\tdestroy_workqueue(wq);\n}",
    "includes": [
      "#include <linux/ww_mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/completion.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct workqueue_struct *wq;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "destroy_workqueue",
          "args": [
            "wq"
          ],
          "line": 672
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_workqueue",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "4417-4501",
          "snippet": "void destroy_workqueue(struct workqueue_struct *wq)\n{\n\tstruct pool_workqueue *pwq;\n\tint node;\n\n\t/*\n\t * Remove it from sysfs first so that sanity check failure doesn't\n\t * lead to sysfs name conflicts.\n\t */\n\tworkqueue_sysfs_unregister(wq);\n\n\t/* drain it before proceeding with destruction */\n\tdrain_workqueue(wq);\n\n\t/* kill rescuer, if sanity checks fail, leave it w/o rescuer */\n\tif (wq->rescuer) {\n\t\tstruct worker *rescuer = wq->rescuer;\n\n\t\t/* this prevents new queueing */\n\t\traw_spin_lock_irq(&wq_mayday_lock);\n\t\twq->rescuer = NULL;\n\t\traw_spin_unlock_irq(&wq_mayday_lock);\n\n\t\t/* rescuer will empty maydays list before exiting */\n\t\tkthread_stop(rescuer->task);\n\t\tkfree(rescuer);\n\t}\n\n\t/*\n\t * Sanity checks - grab all the locks so that we wait for all\n\t * in-flight operations which may do put_pwq().\n\t */\n\tmutex_lock(&wq_pool_mutex);\n\tmutex_lock(&wq->mutex);\n\tfor_each_pwq(pwq, wq) {\n\t\traw_spin_lock_irq(&pwq->pool->lock);\n\t\tif (WARN_ON(pwq_busy(pwq))) {\n\t\t\tpr_warn(\"%s: %s has the following busy pwq\\n\",\n\t\t\t\t__func__, wq->name);\n\t\t\tshow_pwq(pwq);\n\t\t\traw_spin_unlock_irq(&pwq->pool->lock);\n\t\t\tmutex_unlock(&wq->mutex);\n\t\t\tmutex_unlock(&wq_pool_mutex);\n\t\t\tshow_one_workqueue(wq);\n\t\t\treturn;\n\t\t}\n\t\traw_spin_unlock_irq(&pwq->pool->lock);\n\t}\n\tmutex_unlock(&wq->mutex);\n\n\t/*\n\t * wq list is used to freeze wq, remove from list after\n\t * flushing is complete in case freeze races us.\n\t */\n\tlist_del_rcu(&wq->list);\n\tmutex_unlock(&wq_pool_mutex);\n\n\tif (!(wq->flags & WQ_UNBOUND)) {\n\t\twq_unregister_lockdep(wq);\n\t\t/*\n\t\t * The base ref is never dropped on per-cpu pwqs.  Directly\n\t\t * schedule RCU free.\n\t\t */\n\t\tcall_rcu(&wq->rcu, rcu_free_wq);\n\t} else {\n\t\t/*\n\t\t * We're the sole accessor of @wq at this point.  Directly\n\t\t * access numa_pwq_tbl[] and dfl_pwq to put the base refs.\n\t\t * @wq will be freed when the last pwq is released.\n\t\t */\n\t\tfor_each_node(node) {\n\t\t\tpwq = rcu_access_pointer(wq->numa_pwq_tbl[node]);\n\t\t\tRCU_INIT_POINTER(wq->numa_pwq_tbl[node], NULL);\n\t\t\tput_pwq_unlocked(pwq);\n\t\t}\n\n\t\t/*\n\t\t * Put dfl_pwq.  @wq may be freed any time after dfl_pwq is\n\t\t * put.  Don't access it afterwards.\n\t\t */\n\t\tpwq = wq->dfl_pwq;\n\t\twq->dfl_pwq = NULL;\n\t\tput_pwq_unlocked(pwq);\n\t}\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(wq_pool_mutex);",
            "static DEFINE_RAW_SPINLOCK(wq_mayday_lock);",
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);",
            "static void show_pwq(struct pool_workqueue *pwq);",
            "static void show_one_worker_pool(struct worker_pool *pool);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_MUTEX(wq_pool_mutex);\nstatic DEFINE_RAW_SPINLOCK(wq_mayday_lock);\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\nstatic void show_pwq(struct pool_workqueue *pwq);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nvoid destroy_workqueue(struct workqueue_struct *wq)\n{\n\tstruct pool_workqueue *pwq;\n\tint node;\n\n\t/*\n\t * Remove it from sysfs first so that sanity check failure doesn't\n\t * lead to sysfs name conflicts.\n\t */\n\tworkqueue_sysfs_unregister(wq);\n\n\t/* drain it before proceeding with destruction */\n\tdrain_workqueue(wq);\n\n\t/* kill rescuer, if sanity checks fail, leave it w/o rescuer */\n\tif (wq->rescuer) {\n\t\tstruct worker *rescuer = wq->rescuer;\n\n\t\t/* this prevents new queueing */\n\t\traw_spin_lock_irq(&wq_mayday_lock);\n\t\twq->rescuer = NULL;\n\t\traw_spin_unlock_irq(&wq_mayday_lock);\n\n\t\t/* rescuer will empty maydays list before exiting */\n\t\tkthread_stop(rescuer->task);\n\t\tkfree(rescuer);\n\t}\n\n\t/*\n\t * Sanity checks - grab all the locks so that we wait for all\n\t * in-flight operations which may do put_pwq().\n\t */\n\tmutex_lock(&wq_pool_mutex);\n\tmutex_lock(&wq->mutex);\n\tfor_each_pwq(pwq, wq) {\n\t\traw_spin_lock_irq(&pwq->pool->lock);\n\t\tif (WARN_ON(pwq_busy(pwq))) {\n\t\t\tpr_warn(\"%s: %s has the following busy pwq\\n\",\n\t\t\t\t__func__, wq->name);\n\t\t\tshow_pwq(pwq);\n\t\t\traw_spin_unlock_irq(&pwq->pool->lock);\n\t\t\tmutex_unlock(&wq->mutex);\n\t\t\tmutex_unlock(&wq_pool_mutex);\n\t\t\tshow_one_workqueue(wq);\n\t\t\treturn;\n\t\t}\n\t\traw_spin_unlock_irq(&pwq->pool->lock);\n\t}\n\tmutex_unlock(&wq->mutex);\n\n\t/*\n\t * wq list is used to freeze wq, remove from list after\n\t * flushing is complete in case freeze races us.\n\t */\n\tlist_del_rcu(&wq->list);\n\tmutex_unlock(&wq_pool_mutex);\n\n\tif (!(wq->flags & WQ_UNBOUND)) {\n\t\twq_unregister_lockdep(wq);\n\t\t/*\n\t\t * The base ref is never dropped on per-cpu pwqs.  Directly\n\t\t * schedule RCU free.\n\t\t */\n\t\tcall_rcu(&wq->rcu, rcu_free_wq);\n\t} else {\n\t\t/*\n\t\t * We're the sole accessor of @wq at this point.  Directly\n\t\t * access numa_pwq_tbl[] and dfl_pwq to put the base refs.\n\t\t * @wq will be freed when the last pwq is released.\n\t\t */\n\t\tfor_each_node(node) {\n\t\t\tpwq = rcu_access_pointer(wq->numa_pwq_tbl[node]);\n\t\t\tRCU_INIT_POINTER(wq->numa_pwq_tbl[node], NULL);\n\t\t\tput_pwq_unlocked(pwq);\n\t\t}\n\n\t\t/*\n\t\t * Put dfl_pwq.  @wq may be freed any time after dfl_pwq is\n\t\t * put.  Don't access it afterwards.\n\t\t */\n\t\tpwq = wq->dfl_pwq;\n\t\twq->dfl_pwq = NULL;\n\t\tput_pwq_unlocked(pwq);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/ww_mutex.h>\n#include <linux/slab.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/completion.h>\n#include <linux/kernel.h>\n\nstruct workqueue_struct *wq;\n\nstatic void __exit test_ww_mutex_exit(void)\n{\n\tdestroy_workqueue(wq);\n}"
  },
  {
    "function_name": "test_ww_mutex_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/test-ww_mutex.c",
    "lines": "621-668",
    "snippet": "static int __init test_ww_mutex_init(void)\n{\n\tint ncpus = num_online_cpus();\n\tint ret, i;\n\n\tprintk(KERN_INFO \"Beginning ww mutex selftests\\n\");\n\n\twq = alloc_workqueue(\"test-ww_mutex\", WQ_UNBOUND, 0);\n\tif (!wq)\n\t\treturn -ENOMEM;\n\n\tret = test_mutex();\n\tif (ret)\n\t\treturn ret;\n\n\tret = test_aa(false);\n\tif (ret)\n\t\treturn ret;\n\n\tret = test_aa(true);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = 0; i < 4; i++) {\n\t\tret = test_abba(i & 1, i & 2);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tret = test_cycle(ncpus);\n\tif (ret)\n\t\treturn ret;\n\n\tret = stress(16, 2*ncpus, STRESS_INORDER);\n\tif (ret)\n\t\treturn ret;\n\n\tret = stress(16, 2*ncpus, STRESS_REORDER);\n\tif (ret)\n\t\treturn ret;\n\n\tret = stress(4095, hweight32(STRESS_ALL)*ncpus, STRESS_ALL);\n\tif (ret)\n\t\treturn ret;\n\n\tprintk(KERN_INFO \"All ww mutex selftests passed\\n\");\n\treturn 0;\n}",
    "includes": [
      "#include <linux/ww_mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/completion.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define STRESS_ALL (STRESS_INORDER | STRESS_REORDER | STRESS_ONE)",
      "#define STRESS_REORDER BIT(1)",
      "#define STRESS_INORDER BIT(0)"
    ],
    "globals_used": [
      "struct workqueue_struct *wq;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_INFO \"All ww mutex selftests passed\\n\""
          ],
          "line": 666
        },
        "resolved": true,
        "details": {
          "function_name": "kauditd_printk_skb",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "532-539",
          "snippet": "static void kauditd_printk_skb(struct sk_buff *skb)\n{\n\tstruct nlmsghdr *nlh = nlmsg_hdr(skb);\n\tchar *data = nlmsg_data(nlh);\n\n\tif (nlh->nlmsg_type != AUDIT_EOE && printk_ratelimit())\n\t\tpr_notice(\"type=%d %s\\n\", nlh->nlmsg_type, data);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic void kauditd_printk_skb(struct sk_buff *skb)\n{\n\tstruct nlmsghdr *nlh = nlmsg_hdr(skb);\n\tchar *data = nlmsg_data(nlh);\n\n\tif (nlh->nlmsg_type != AUDIT_EOE && printk_ratelimit())\n\t\tpr_notice(\"type=%d %s\\n\", nlh->nlmsg_type, data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "stress",
          "args": [
            "4095",
            "hweight32(STRESS_ALL)*ncpus",
            "STRESS_ALL"
          ],
          "line": 662
        },
        "resolved": true,
        "details": {
          "function_name": "stress",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/test-ww_mutex.c",
          "lines": "564-619",
          "snippet": "static int stress(int nlocks, int nthreads, unsigned int flags)\n{\n\tstruct ww_mutex *locks;\n\tint n;\n\n\tlocks = kmalloc_array(nlocks, sizeof(*locks), GFP_KERNEL);\n\tif (!locks)\n\t\treturn -ENOMEM;\n\n\tfor (n = 0; n < nlocks; n++)\n\t\tww_mutex_init(&locks[n], &ww_class);\n\n\tfor (n = 0; nthreads; n++) {\n\t\tstruct stress *stress;\n\t\tvoid (*fn)(struct work_struct *work);\n\n\t\tfn = NULL;\n\t\tswitch (n & 3) {\n\t\tcase 0:\n\t\t\tif (flags & STRESS_INORDER)\n\t\t\t\tfn = stress_inorder_work;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tif (flags & STRESS_REORDER)\n\t\t\t\tfn = stress_reorder_work;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tif (flags & STRESS_ONE)\n\t\t\t\tfn = stress_one_work;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!fn)\n\t\t\tcontinue;\n\n\t\tstress = kmalloc(sizeof(*stress), GFP_KERNEL);\n\t\tif (!stress)\n\t\t\tbreak;\n\n\t\tINIT_WORK(&stress->work, fn);\n\t\tstress->locks = locks;\n\t\tstress->nlocks = nlocks;\n\t\tstress->timeout = jiffies + 2*HZ;\n\n\t\tqueue_work(wq, &stress->work);\n\t\tnthreads--;\n\t}\n\n\tflush_workqueue(wq);\n\n\tfor (n = 0; n < nlocks; n++)\n\t\tww_mutex_destroy(&locks[n]);\n\tkfree(locks);\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/ww_mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/completion.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define STRESS_ONE BIT(2)",
            "#define STRESS_REORDER BIT(1)",
            "#define STRESS_INORDER BIT(0)"
          ],
          "globals_used": [
            "static DEFINE_WD_CLASS(ww_class);",
            "struct workqueue_struct *wq;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ww_mutex.h>\n#include <linux/slab.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/completion.h>\n#include <linux/kernel.h>\n\n#define STRESS_ONE BIT(2)\n#define STRESS_REORDER BIT(1)\n#define STRESS_INORDER BIT(0)\n\nstatic DEFINE_WD_CLASS(ww_class);\nstruct workqueue_struct *wq;\n\nstatic int stress(int nlocks, int nthreads, unsigned int flags)\n{\n\tstruct ww_mutex *locks;\n\tint n;\n\n\tlocks = kmalloc_array(nlocks, sizeof(*locks), GFP_KERNEL);\n\tif (!locks)\n\t\treturn -ENOMEM;\n\n\tfor (n = 0; n < nlocks; n++)\n\t\tww_mutex_init(&locks[n], &ww_class);\n\n\tfor (n = 0; nthreads; n++) {\n\t\tstruct stress *stress;\n\t\tvoid (*fn)(struct work_struct *work);\n\n\t\tfn = NULL;\n\t\tswitch (n & 3) {\n\t\tcase 0:\n\t\t\tif (flags & STRESS_INORDER)\n\t\t\t\tfn = stress_inorder_work;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tif (flags & STRESS_REORDER)\n\t\t\t\tfn = stress_reorder_work;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tif (flags & STRESS_ONE)\n\t\t\t\tfn = stress_one_work;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!fn)\n\t\t\tcontinue;\n\n\t\tstress = kmalloc(sizeof(*stress), GFP_KERNEL);\n\t\tif (!stress)\n\t\t\tbreak;\n\n\t\tINIT_WORK(&stress->work, fn);\n\t\tstress->locks = locks;\n\t\tstress->nlocks = nlocks;\n\t\tstress->timeout = jiffies + 2*HZ;\n\n\t\tqueue_work(wq, &stress->work);\n\t\tnthreads--;\n\t}\n\n\tflush_workqueue(wq);\n\n\tfor (n = 0; n < nlocks; n++)\n\t\tww_mutex_destroy(&locks[n]);\n\tkfree(locks);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hweight32",
          "args": [
            "STRESS_ALL"
          ],
          "line": 662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_cycle",
          "args": [
            "ncpus"
          ],
          "line": 650
        },
        "resolved": true,
        "details": {
          "function_name": "test_cycle",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/test-ww_mutex.c",
          "lines": "368-380",
          "snippet": "static int test_cycle(unsigned int ncpus)\n{\n\tunsigned int n;\n\tint ret;\n\n\tfor (n = 2; n <= ncpus + 1; n++) {\n\t\tret = __test_cycle(n);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/ww_mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/completion.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ww_mutex.h>\n#include <linux/slab.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/completion.h>\n#include <linux/kernel.h>\n\nstatic int test_cycle(unsigned int ncpus)\n{\n\tunsigned int n;\n\tint ret;\n\n\tfor (n = 2; n <= ncpus + 1; n++) {\n\t\tret = __test_cycle(n);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_abba",
          "args": [
            "i & 1",
            "i & 2"
          ],
          "line": 645
        },
        "resolved": true,
        "details": {
          "function_name": "test_abba",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/test-ww_mutex.c",
          "lines": "218-275",
          "snippet": "static int test_abba(bool trylock, bool resolve)\n{\n\tstruct test_abba abba;\n\tstruct ww_acquire_ctx ctx;\n\tint err, ret;\n\n\tww_mutex_init(&abba.a_mutex, &ww_class);\n\tww_mutex_init(&abba.b_mutex, &ww_class);\n\tINIT_WORK_ONSTACK(&abba.work, test_abba_work);\n\tinit_completion(&abba.a_ready);\n\tinit_completion(&abba.b_ready);\n\tabba.trylock = trylock;\n\tabba.resolve = resolve;\n\n\tschedule_work(&abba.work);\n\n\tww_acquire_init_noinject(&ctx, &ww_class);\n\tif (!trylock)\n\t\tww_mutex_lock(&abba.a_mutex, &ctx);\n\telse\n\t\tWARN_ON(!ww_mutex_trylock(&abba.a_mutex, &ctx));\n\n\tWARN_ON(READ_ONCE(abba.a_mutex.ctx) != &ctx);\n\n\tcomplete(&abba.a_ready);\n\twait_for_completion(&abba.b_ready);\n\n\terr = ww_mutex_lock(&abba.b_mutex, &ctx);\n\tif (resolve && err == -EDEADLK) {\n\t\tww_mutex_unlock(&abba.a_mutex);\n\t\tww_mutex_lock_slow(&abba.b_mutex, &ctx);\n\t\terr = ww_mutex_lock(&abba.a_mutex, &ctx);\n\t}\n\n\tif (!err)\n\t\tww_mutex_unlock(&abba.b_mutex);\n\tww_mutex_unlock(&abba.a_mutex);\n\tww_acquire_fini(&ctx);\n\n\tflush_work(&abba.work);\n\tdestroy_work_on_stack(&abba.work);\n\n\tret = 0;\n\tif (resolve) {\n\t\tif (err || abba.result) {\n\t\t\tpr_err(\"%s: failed to resolve ABBA deadlock, A err=%d, B err=%d\\n\",\n\t\t\t       __func__, err, abba.result);\n\t\t\tret = -EINVAL;\n\t\t}\n\t} else {\n\t\tif (err != -EDEADLK && abba.result != -EDEADLK) {\n\t\t\tpr_err(\"%s: missed ABBA deadlock, A err=%d, B err=%d\\n\",\n\t\t\t       __func__, err, abba.result);\n\t\t\tret = -EINVAL;\n\t\t}\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include <linux/ww_mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/completion.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_WD_CLASS(ww_class);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ww_mutex.h>\n#include <linux/slab.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/completion.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_WD_CLASS(ww_class);\n\nstatic int test_abba(bool trylock, bool resolve)\n{\n\tstruct test_abba abba;\n\tstruct ww_acquire_ctx ctx;\n\tint err, ret;\n\n\tww_mutex_init(&abba.a_mutex, &ww_class);\n\tww_mutex_init(&abba.b_mutex, &ww_class);\n\tINIT_WORK_ONSTACK(&abba.work, test_abba_work);\n\tinit_completion(&abba.a_ready);\n\tinit_completion(&abba.b_ready);\n\tabba.trylock = trylock;\n\tabba.resolve = resolve;\n\n\tschedule_work(&abba.work);\n\n\tww_acquire_init_noinject(&ctx, &ww_class);\n\tif (!trylock)\n\t\tww_mutex_lock(&abba.a_mutex, &ctx);\n\telse\n\t\tWARN_ON(!ww_mutex_trylock(&abba.a_mutex, &ctx));\n\n\tWARN_ON(READ_ONCE(abba.a_mutex.ctx) != &ctx);\n\n\tcomplete(&abba.a_ready);\n\twait_for_completion(&abba.b_ready);\n\n\terr = ww_mutex_lock(&abba.b_mutex, &ctx);\n\tif (resolve && err == -EDEADLK) {\n\t\tww_mutex_unlock(&abba.a_mutex);\n\t\tww_mutex_lock_slow(&abba.b_mutex, &ctx);\n\t\terr = ww_mutex_lock(&abba.a_mutex, &ctx);\n\t}\n\n\tif (!err)\n\t\tww_mutex_unlock(&abba.b_mutex);\n\tww_mutex_unlock(&abba.a_mutex);\n\tww_acquire_fini(&ctx);\n\n\tflush_work(&abba.work);\n\tdestroy_work_on_stack(&abba.work);\n\n\tret = 0;\n\tif (resolve) {\n\t\tif (err || abba.result) {\n\t\t\tpr_err(\"%s: failed to resolve ABBA deadlock, A err=%d, B err=%d\\n\",\n\t\t\t       __func__, err, abba.result);\n\t\t\tret = -EINVAL;\n\t\t}\n\t} else {\n\t\tif (err != -EDEADLK && abba.result != -EDEADLK) {\n\t\t\tpr_err(\"%s: missed ABBA deadlock, A err=%d, B err=%d\\n\",\n\t\t\t       __func__, err, abba.result);\n\t\t\tret = -EINVAL;\n\t\t}\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_aa",
          "args": [
            "true"
          ],
          "line": 640
        },
        "resolved": true,
        "details": {
          "function_name": "test_aa",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/test-ww_mutex.c",
          "lines": "121-174",
          "snippet": "static int test_aa(bool trylock)\n{\n\tstruct ww_mutex mutex;\n\tstruct ww_acquire_ctx ctx;\n\tint ret;\n\tconst char *from = trylock ? \"trylock\" : \"lock\";\n\n\tww_mutex_init(&mutex, &ww_class);\n\tww_acquire_init(&ctx, &ww_class);\n\n\tif (!trylock) {\n\t\tret = ww_mutex_lock(&mutex, &ctx);\n\t\tif (ret) {\n\t\t\tpr_err(\"%s: initial lock failed!\\n\", __func__);\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\tret = !ww_mutex_trylock(&mutex, &ctx);\n\t\tif (ret) {\n\t\t\tpr_err(\"%s: initial trylock failed!\\n\", __func__);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (ww_mutex_trylock(&mutex, NULL))  {\n\t\tpr_err(\"%s: trylocked itself without context from %s!\\n\", __func__, from);\n\t\tww_mutex_unlock(&mutex);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (ww_mutex_trylock(&mutex, &ctx))  {\n\t\tpr_err(\"%s: trylocked itself with context from %s!\\n\", __func__, from);\n\t\tww_mutex_unlock(&mutex);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tret = ww_mutex_lock(&mutex, &ctx);\n\tif (ret != -EALREADY) {\n\t\tpr_err(\"%s: missed deadlock for recursing, ret=%d from %s\\n\",\n\t\t       __func__, ret, from);\n\t\tif (!ret)\n\t\t\tww_mutex_unlock(&mutex);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tww_mutex_unlock(&mutex);\n\tret = 0;\nout:\n\tww_acquire_fini(&ctx);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/ww_mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/completion.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_WD_CLASS(ww_class);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ww_mutex.h>\n#include <linux/slab.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/completion.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_WD_CLASS(ww_class);\n\nstatic int test_aa(bool trylock)\n{\n\tstruct ww_mutex mutex;\n\tstruct ww_acquire_ctx ctx;\n\tint ret;\n\tconst char *from = trylock ? \"trylock\" : \"lock\";\n\n\tww_mutex_init(&mutex, &ww_class);\n\tww_acquire_init(&ctx, &ww_class);\n\n\tif (!trylock) {\n\t\tret = ww_mutex_lock(&mutex, &ctx);\n\t\tif (ret) {\n\t\t\tpr_err(\"%s: initial lock failed!\\n\", __func__);\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\tret = !ww_mutex_trylock(&mutex, &ctx);\n\t\tif (ret) {\n\t\t\tpr_err(\"%s: initial trylock failed!\\n\", __func__);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (ww_mutex_trylock(&mutex, NULL))  {\n\t\tpr_err(\"%s: trylocked itself without context from %s!\\n\", __func__, from);\n\t\tww_mutex_unlock(&mutex);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (ww_mutex_trylock(&mutex, &ctx))  {\n\t\tpr_err(\"%s: trylocked itself with context from %s!\\n\", __func__, from);\n\t\tww_mutex_unlock(&mutex);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tret = ww_mutex_lock(&mutex, &ctx);\n\tif (ret != -EALREADY) {\n\t\tpr_err(\"%s: missed deadlock for recursing, ret=%d from %s\\n\",\n\t\t       __func__, ret, from);\n\t\tif (!ret)\n\t\t\tww_mutex_unlock(&mutex);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tww_mutex_unlock(&mutex);\n\tret = 0;\nout:\n\tww_acquire_fini(&ctx);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_mutex",
          "args": [],
          "line": 632
        },
        "resolved": true,
        "details": {
          "function_name": "test_mutex",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/test-ww_mutex.c",
          "lines": "107-119",
          "snippet": "static int test_mutex(void)\n{\n\tint ret;\n\tint i;\n\n\tfor (i = 0; i < __TEST_MTX_LAST; i++) {\n\t\tret = __test_mutex(i);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/ww_mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/completion.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define __TEST_MTX_LAST BIT(3)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ww_mutex.h>\n#include <linux/slab.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/completion.h>\n#include <linux/kernel.h>\n\n#define __TEST_MTX_LAST BIT(3)\n\nstatic int test_mutex(void)\n{\n\tint ret;\n\tint i;\n\n\tfor (i = 0; i < __TEST_MTX_LAST; i++) {\n\t\tret = __test_mutex(i);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_workqueue",
          "args": [
            "\"test-ww_mutex\"",
            "WQ_UNBOUND",
            "0"
          ],
          "line": 628
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_workqueue",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "4298-4392",
          "snippet": "struct workqueue_struct *alloc_workqueue(const char *fmt,\n\t\t\t\t\t unsigned int flags,\n\t\t\t\t\t int max_active, ...)\n{\n\tsize_t tbl_size = 0;\n\tva_list args;\n\tstruct workqueue_struct *wq;\n\tstruct pool_workqueue *pwq;\n\n\t/*\n\t * Unbound && max_active == 1 used to imply ordered, which is no\n\t * longer the case on NUMA machines due to per-node pools.  While\n\t * alloc_ordered_workqueue() is the right way to create an ordered\n\t * workqueue, keep the previous behavior to avoid subtle breakages\n\t * on NUMA.\n\t */\n\tif ((flags & WQ_UNBOUND) && max_active == 1)\n\t\tflags |= __WQ_ORDERED;\n\n\t/* see the comment above the definition of WQ_POWER_EFFICIENT */\n\tif ((flags & WQ_POWER_EFFICIENT) && wq_power_efficient)\n\t\tflags |= WQ_UNBOUND;\n\n\t/* allocate wq and format name */\n\tif (flags & WQ_UNBOUND)\n\t\ttbl_size = nr_node_ids * sizeof(wq->numa_pwq_tbl[0]);\n\n\twq = kzalloc(sizeof(*wq) + tbl_size, GFP_KERNEL);\n\tif (!wq)\n\t\treturn NULL;\n\n\tif (flags & WQ_UNBOUND) {\n\t\twq->unbound_attrs = alloc_workqueue_attrs();\n\t\tif (!wq->unbound_attrs)\n\t\t\tgoto err_free_wq;\n\t}\n\n\tva_start(args, max_active);\n\tvsnprintf(wq->name, sizeof(wq->name), fmt, args);\n\tva_end(args);\n\n\tmax_active = max_active ?: WQ_DFL_ACTIVE;\n\tmax_active = wq_clamp_max_active(max_active, flags, wq->name);\n\n\t/* init wq */\n\twq->flags = flags;\n\twq->saved_max_active = max_active;\n\tmutex_init(&wq->mutex);\n\tatomic_set(&wq->nr_pwqs_to_flush, 0);\n\tINIT_LIST_HEAD(&wq->pwqs);\n\tINIT_LIST_HEAD(&wq->flusher_queue);\n\tINIT_LIST_HEAD(&wq->flusher_overflow);\n\tINIT_LIST_HEAD(&wq->maydays);\n\n\twq_init_lockdep(wq);\n\tINIT_LIST_HEAD(&wq->list);\n\n\tif (alloc_and_link_pwqs(wq) < 0)\n\t\tgoto err_unreg_lockdep;\n\n\tif (wq_online && init_rescuer(wq) < 0)\n\t\tgoto err_destroy;\n\n\tif ((wq->flags & WQ_SYSFS) && workqueue_sysfs_register(wq))\n\t\tgoto err_destroy;\n\n\t/*\n\t * wq_pool_mutex protects global freeze state and workqueues list.\n\t * Grab it, adjust max_active and add the new @wq to workqueues\n\t * list.\n\t */\n\tmutex_lock(&wq_pool_mutex);\n\n\tmutex_lock(&wq->mutex);\n\tfor_each_pwq(pwq, wq)\n\t\tpwq_adjust_max_active(pwq);\n\tmutex_unlock(&wq->mutex);\n\n\tlist_add_tail_rcu(&wq->list, &workqueues);\n\n\tmutex_unlock(&wq_pool_mutex);\n\n\treturn wq;\n\nerr_unreg_lockdep:\n\twq_unregister_lockdep(wq);\n\twq_free_lockdep(wq);\nerr_free_wq:\n\tfree_workqueue_attrs(wq->unbound_attrs);\n\tkfree(wq);\n\treturn NULL;\nerr_destroy:\n\tdestroy_workqueue(wq);\n\treturn NULL;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool wq_power_efficient = IS_ENABLED(CONFIG_WQ_POWER_EFFICIENT_DEFAULT);",
            "static bool wq_online;",
            "static DEFINE_MUTEX(wq_pool_mutex);",
            "static LIST_HEAD(workqueues);",
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);",
            "static void show_pwq(struct pool_workqueue *pwq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic bool wq_power_efficient = IS_ENABLED(CONFIG_WQ_POWER_EFFICIENT_DEFAULT);\nstatic bool wq_online;\nstatic DEFINE_MUTEX(wq_pool_mutex);\nstatic LIST_HEAD(workqueues);\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\nstatic void show_pwq(struct pool_workqueue *pwq);\n\nstruct workqueue_struct *alloc_workqueue(const char *fmt,\n\t\t\t\t\t unsigned int flags,\n\t\t\t\t\t int max_active, ...)\n{\n\tsize_t tbl_size = 0;\n\tva_list args;\n\tstruct workqueue_struct *wq;\n\tstruct pool_workqueue *pwq;\n\n\t/*\n\t * Unbound && max_active == 1 used to imply ordered, which is no\n\t * longer the case on NUMA machines due to per-node pools.  While\n\t * alloc_ordered_workqueue() is the right way to create an ordered\n\t * workqueue, keep the previous behavior to avoid subtle breakages\n\t * on NUMA.\n\t */\n\tif ((flags & WQ_UNBOUND) && max_active == 1)\n\t\tflags |= __WQ_ORDERED;\n\n\t/* see the comment above the definition of WQ_POWER_EFFICIENT */\n\tif ((flags & WQ_POWER_EFFICIENT) && wq_power_efficient)\n\t\tflags |= WQ_UNBOUND;\n\n\t/* allocate wq and format name */\n\tif (flags & WQ_UNBOUND)\n\t\ttbl_size = nr_node_ids * sizeof(wq->numa_pwq_tbl[0]);\n\n\twq = kzalloc(sizeof(*wq) + tbl_size, GFP_KERNEL);\n\tif (!wq)\n\t\treturn NULL;\n\n\tif (flags & WQ_UNBOUND) {\n\t\twq->unbound_attrs = alloc_workqueue_attrs();\n\t\tif (!wq->unbound_attrs)\n\t\t\tgoto err_free_wq;\n\t}\n\n\tva_start(args, max_active);\n\tvsnprintf(wq->name, sizeof(wq->name), fmt, args);\n\tva_end(args);\n\n\tmax_active = max_active ?: WQ_DFL_ACTIVE;\n\tmax_active = wq_clamp_max_active(max_active, flags, wq->name);\n\n\t/* init wq */\n\twq->flags = flags;\n\twq->saved_max_active = max_active;\n\tmutex_init(&wq->mutex);\n\tatomic_set(&wq->nr_pwqs_to_flush, 0);\n\tINIT_LIST_HEAD(&wq->pwqs);\n\tINIT_LIST_HEAD(&wq->flusher_queue);\n\tINIT_LIST_HEAD(&wq->flusher_overflow);\n\tINIT_LIST_HEAD(&wq->maydays);\n\n\twq_init_lockdep(wq);\n\tINIT_LIST_HEAD(&wq->list);\n\n\tif (alloc_and_link_pwqs(wq) < 0)\n\t\tgoto err_unreg_lockdep;\n\n\tif (wq_online && init_rescuer(wq) < 0)\n\t\tgoto err_destroy;\n\n\tif ((wq->flags & WQ_SYSFS) && workqueue_sysfs_register(wq))\n\t\tgoto err_destroy;\n\n\t/*\n\t * wq_pool_mutex protects global freeze state and workqueues list.\n\t * Grab it, adjust max_active and add the new @wq to workqueues\n\t * list.\n\t */\n\tmutex_lock(&wq_pool_mutex);\n\n\tmutex_lock(&wq->mutex);\n\tfor_each_pwq(pwq, wq)\n\t\tpwq_adjust_max_active(pwq);\n\tmutex_unlock(&wq->mutex);\n\n\tlist_add_tail_rcu(&wq->list, &workqueues);\n\n\tmutex_unlock(&wq_pool_mutex);\n\n\treturn wq;\n\nerr_unreg_lockdep:\n\twq_unregister_lockdep(wq);\n\twq_free_lockdep(wq);\nerr_free_wq:\n\tfree_workqueue_attrs(wq->unbound_attrs);\n\tkfree(wq);\n\treturn NULL;\nerr_destroy:\n\tdestroy_workqueue(wq);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "num_online_cpus",
          "args": [],
          "line": 623
        },
        "resolved": true,
        "details": {
          "function_name": "torture_num_online_cpus",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/torture.c",
          "lines": "185-188",
          "snippet": "int torture_num_online_cpus(void)\n{\n\treturn READ_ONCE(torture_online_cpus);\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint torture_num_online_cpus(void)\n{\n\treturn READ_ONCE(torture_online_cpus);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/ww_mutex.h>\n#include <linux/slab.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/completion.h>\n#include <linux/kernel.h>\n\n#define STRESS_ALL (STRESS_INORDER | STRESS_REORDER | STRESS_ONE)\n#define STRESS_REORDER BIT(1)\n#define STRESS_INORDER BIT(0)\n\nstruct workqueue_struct *wq;\n\nstatic int __init test_ww_mutex_init(void)\n{\n\tint ncpus = num_online_cpus();\n\tint ret, i;\n\n\tprintk(KERN_INFO \"Beginning ww mutex selftests\\n\");\n\n\twq = alloc_workqueue(\"test-ww_mutex\", WQ_UNBOUND, 0);\n\tif (!wq)\n\t\treturn -ENOMEM;\n\n\tret = test_mutex();\n\tif (ret)\n\t\treturn ret;\n\n\tret = test_aa(false);\n\tif (ret)\n\t\treturn ret;\n\n\tret = test_aa(true);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = 0; i < 4; i++) {\n\t\tret = test_abba(i & 1, i & 2);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tret = test_cycle(ncpus);\n\tif (ret)\n\t\treturn ret;\n\n\tret = stress(16, 2*ncpus, STRESS_INORDER);\n\tif (ret)\n\t\treturn ret;\n\n\tret = stress(16, 2*ncpus, STRESS_REORDER);\n\tif (ret)\n\t\treturn ret;\n\n\tret = stress(4095, hweight32(STRESS_ALL)*ncpus, STRESS_ALL);\n\tif (ret)\n\t\treturn ret;\n\n\tprintk(KERN_INFO \"All ww mutex selftests passed\\n\");\n\treturn 0;\n}"
  },
  {
    "function_name": "stress",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/test-ww_mutex.c",
    "lines": "564-619",
    "snippet": "static int stress(int nlocks, int nthreads, unsigned int flags)\n{\n\tstruct ww_mutex *locks;\n\tint n;\n\n\tlocks = kmalloc_array(nlocks, sizeof(*locks), GFP_KERNEL);\n\tif (!locks)\n\t\treturn -ENOMEM;\n\n\tfor (n = 0; n < nlocks; n++)\n\t\tww_mutex_init(&locks[n], &ww_class);\n\n\tfor (n = 0; nthreads; n++) {\n\t\tstruct stress *stress;\n\t\tvoid (*fn)(struct work_struct *work);\n\n\t\tfn = NULL;\n\t\tswitch (n & 3) {\n\t\tcase 0:\n\t\t\tif (flags & STRESS_INORDER)\n\t\t\t\tfn = stress_inorder_work;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tif (flags & STRESS_REORDER)\n\t\t\t\tfn = stress_reorder_work;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tif (flags & STRESS_ONE)\n\t\t\t\tfn = stress_one_work;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!fn)\n\t\t\tcontinue;\n\n\t\tstress = kmalloc(sizeof(*stress), GFP_KERNEL);\n\t\tif (!stress)\n\t\t\tbreak;\n\n\t\tINIT_WORK(&stress->work, fn);\n\t\tstress->locks = locks;\n\t\tstress->nlocks = nlocks;\n\t\tstress->timeout = jiffies + 2*HZ;\n\n\t\tqueue_work(wq, &stress->work);\n\t\tnthreads--;\n\t}\n\n\tflush_workqueue(wq);\n\n\tfor (n = 0; n < nlocks; n++)\n\t\tww_mutex_destroy(&locks[n]);\n\tkfree(locks);\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/ww_mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/completion.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define STRESS_ONE BIT(2)",
      "#define STRESS_REORDER BIT(1)",
      "#define STRESS_INORDER BIT(0)"
    ],
    "globals_used": [
      "static DEFINE_WD_CLASS(ww_class);",
      "struct workqueue_struct *wq;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "locks"
          ],
          "line": 616
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ww_mutex_destroy",
          "args": [
            "&locks[n]"
          ],
          "line": 615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_workqueue",
          "args": [
            "wq"
          ],
          "line": 612
        },
        "resolved": true,
        "details": {
          "function_name": "flush_workqueue",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "2815-2963",
          "snippet": "void flush_workqueue(struct workqueue_struct *wq)\n{\n\tstruct wq_flusher this_flusher = {\n\t\t.list = LIST_HEAD_INIT(this_flusher.list),\n\t\t.flush_color = -1,\n\t\t.done = COMPLETION_INITIALIZER_ONSTACK_MAP(this_flusher.done, wq->lockdep_map),\n\t};\n\tint next_color;\n\n\tif (WARN_ON(!wq_online))\n\t\treturn;\n\n\tlock_map_acquire(&wq->lockdep_map);\n\tlock_map_release(&wq->lockdep_map);\n\n\tmutex_lock(&wq->mutex);\n\n\t/*\n\t * Start-to-wait phase\n\t */\n\tnext_color = work_next_color(wq->work_color);\n\n\tif (next_color != wq->flush_color) {\n\t\t/*\n\t\t * Color space is not full.  The current work_color\n\t\t * becomes our flush_color and work_color is advanced\n\t\t * by one.\n\t\t */\n\t\tWARN_ON_ONCE(!list_empty(&wq->flusher_overflow));\n\t\tthis_flusher.flush_color = wq->work_color;\n\t\twq->work_color = next_color;\n\n\t\tif (!wq->first_flusher) {\n\t\t\t/* no flush in progress, become the first flusher */\n\t\t\tWARN_ON_ONCE(wq->flush_color != this_flusher.flush_color);\n\n\t\t\twq->first_flusher = &this_flusher;\n\n\t\t\tif (!flush_workqueue_prep_pwqs(wq, wq->flush_color,\n\t\t\t\t\t\t       wq->work_color)) {\n\t\t\t\t/* nothing to flush, done */\n\t\t\t\twq->flush_color = next_color;\n\t\t\t\twq->first_flusher = NULL;\n\t\t\t\tgoto out_unlock;\n\t\t\t}\n\t\t} else {\n\t\t\t/* wait in queue */\n\t\t\tWARN_ON_ONCE(wq->flush_color == this_flusher.flush_color);\n\t\t\tlist_add_tail(&this_flusher.list, &wq->flusher_queue);\n\t\t\tflush_workqueue_prep_pwqs(wq, -1, wq->work_color);\n\t\t}\n\t} else {\n\t\t/*\n\t\t * Oops, color space is full, wait on overflow queue.\n\t\t * The next flush completion will assign us\n\t\t * flush_color and transfer to flusher_queue.\n\t\t */\n\t\tlist_add_tail(&this_flusher.list, &wq->flusher_overflow);\n\t}\n\n\tcheck_flush_dependency(wq, NULL);\n\n\tmutex_unlock(&wq->mutex);\n\n\twait_for_completion(&this_flusher.done);\n\n\t/*\n\t * Wake-up-and-cascade phase\n\t *\n\t * First flushers are responsible for cascading flushes and\n\t * handling overflow.  Non-first flushers can simply return.\n\t */\n\tif (READ_ONCE(wq->first_flusher) != &this_flusher)\n\t\treturn;\n\n\tmutex_lock(&wq->mutex);\n\n\t/* we might have raced, check again with mutex held */\n\tif (wq->first_flusher != &this_flusher)\n\t\tgoto out_unlock;\n\n\tWRITE_ONCE(wq->first_flusher, NULL);\n\n\tWARN_ON_ONCE(!list_empty(&this_flusher.list));\n\tWARN_ON_ONCE(wq->flush_color != this_flusher.flush_color);\n\n\twhile (true) {\n\t\tstruct wq_flusher *next, *tmp;\n\n\t\t/* complete all the flushers sharing the current flush color */\n\t\tlist_for_each_entry_safe(next, tmp, &wq->flusher_queue, list) {\n\t\t\tif (next->flush_color != wq->flush_color)\n\t\t\t\tbreak;\n\t\t\tlist_del_init(&next->list);\n\t\t\tcomplete(&next->done);\n\t\t}\n\n\t\tWARN_ON_ONCE(!list_empty(&wq->flusher_overflow) &&\n\t\t\t     wq->flush_color != work_next_color(wq->work_color));\n\n\t\t/* this flush_color is finished, advance by one */\n\t\twq->flush_color = work_next_color(wq->flush_color);\n\n\t\t/* one color has been freed, handle overflow queue */\n\t\tif (!list_empty(&wq->flusher_overflow)) {\n\t\t\t/*\n\t\t\t * Assign the same color to all overflowed\n\t\t\t * flushers, advance work_color and append to\n\t\t\t * flusher_queue.  This is the start-to-wait\n\t\t\t * phase for these overflowed flushers.\n\t\t\t */\n\t\t\tlist_for_each_entry(tmp, &wq->flusher_overflow, list)\n\t\t\t\ttmp->flush_color = wq->work_color;\n\n\t\t\twq->work_color = work_next_color(wq->work_color);\n\n\t\t\tlist_splice_tail_init(&wq->flusher_overflow,\n\t\t\t\t\t      &wq->flusher_queue);\n\t\t\tflush_workqueue_prep_pwqs(wq, -1, wq->work_color);\n\t\t}\n\n\t\tif (list_empty(&wq->flusher_queue)) {\n\t\t\tWARN_ON_ONCE(wq->flush_color != wq->work_color);\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Need to flush more colors.  Make the next flusher\n\t\t * the new first flusher and arm pwqs.\n\t\t */\n\t\tWARN_ON_ONCE(wq->flush_color == wq->work_color);\n\t\tWARN_ON_ONCE(wq->flush_color != next->flush_color);\n\n\t\tlist_del_init(&next->list);\n\t\twq->first_flusher = next;\n\n\t\tif (flush_workqueue_prep_pwqs(wq, wq->flush_color, -1))\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Meh... this color is already done, clear first\n\t\t * flusher and repeat cascading.\n\t\t */\n\t\twq->first_flusher = NULL;\n\t}\n\nout_unlock:\n\tmutex_unlock(&wq->mutex);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool wq_online;",
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic bool wq_online;\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nvoid flush_workqueue(struct workqueue_struct *wq)\n{\n\tstruct wq_flusher this_flusher = {\n\t\t.list = LIST_HEAD_INIT(this_flusher.list),\n\t\t.flush_color = -1,\n\t\t.done = COMPLETION_INITIALIZER_ONSTACK_MAP(this_flusher.done, wq->lockdep_map),\n\t};\n\tint next_color;\n\n\tif (WARN_ON(!wq_online))\n\t\treturn;\n\n\tlock_map_acquire(&wq->lockdep_map);\n\tlock_map_release(&wq->lockdep_map);\n\n\tmutex_lock(&wq->mutex);\n\n\t/*\n\t * Start-to-wait phase\n\t */\n\tnext_color = work_next_color(wq->work_color);\n\n\tif (next_color != wq->flush_color) {\n\t\t/*\n\t\t * Color space is not full.  The current work_color\n\t\t * becomes our flush_color and work_color is advanced\n\t\t * by one.\n\t\t */\n\t\tWARN_ON_ONCE(!list_empty(&wq->flusher_overflow));\n\t\tthis_flusher.flush_color = wq->work_color;\n\t\twq->work_color = next_color;\n\n\t\tif (!wq->first_flusher) {\n\t\t\t/* no flush in progress, become the first flusher */\n\t\t\tWARN_ON_ONCE(wq->flush_color != this_flusher.flush_color);\n\n\t\t\twq->first_flusher = &this_flusher;\n\n\t\t\tif (!flush_workqueue_prep_pwqs(wq, wq->flush_color,\n\t\t\t\t\t\t       wq->work_color)) {\n\t\t\t\t/* nothing to flush, done */\n\t\t\t\twq->flush_color = next_color;\n\t\t\t\twq->first_flusher = NULL;\n\t\t\t\tgoto out_unlock;\n\t\t\t}\n\t\t} else {\n\t\t\t/* wait in queue */\n\t\t\tWARN_ON_ONCE(wq->flush_color == this_flusher.flush_color);\n\t\t\tlist_add_tail(&this_flusher.list, &wq->flusher_queue);\n\t\t\tflush_workqueue_prep_pwqs(wq, -1, wq->work_color);\n\t\t}\n\t} else {\n\t\t/*\n\t\t * Oops, color space is full, wait on overflow queue.\n\t\t * The next flush completion will assign us\n\t\t * flush_color and transfer to flusher_queue.\n\t\t */\n\t\tlist_add_tail(&this_flusher.list, &wq->flusher_overflow);\n\t}\n\n\tcheck_flush_dependency(wq, NULL);\n\n\tmutex_unlock(&wq->mutex);\n\n\twait_for_completion(&this_flusher.done);\n\n\t/*\n\t * Wake-up-and-cascade phase\n\t *\n\t * First flushers are responsible for cascading flushes and\n\t * handling overflow.  Non-first flushers can simply return.\n\t */\n\tif (READ_ONCE(wq->first_flusher) != &this_flusher)\n\t\treturn;\n\n\tmutex_lock(&wq->mutex);\n\n\t/* we might have raced, check again with mutex held */\n\tif (wq->first_flusher != &this_flusher)\n\t\tgoto out_unlock;\n\n\tWRITE_ONCE(wq->first_flusher, NULL);\n\n\tWARN_ON_ONCE(!list_empty(&this_flusher.list));\n\tWARN_ON_ONCE(wq->flush_color != this_flusher.flush_color);\n\n\twhile (true) {\n\t\tstruct wq_flusher *next, *tmp;\n\n\t\t/* complete all the flushers sharing the current flush color */\n\t\tlist_for_each_entry_safe(next, tmp, &wq->flusher_queue, list) {\n\t\t\tif (next->flush_color != wq->flush_color)\n\t\t\t\tbreak;\n\t\t\tlist_del_init(&next->list);\n\t\t\tcomplete(&next->done);\n\t\t}\n\n\t\tWARN_ON_ONCE(!list_empty(&wq->flusher_overflow) &&\n\t\t\t     wq->flush_color != work_next_color(wq->work_color));\n\n\t\t/* this flush_color is finished, advance by one */\n\t\twq->flush_color = work_next_color(wq->flush_color);\n\n\t\t/* one color has been freed, handle overflow queue */\n\t\tif (!list_empty(&wq->flusher_overflow)) {\n\t\t\t/*\n\t\t\t * Assign the same color to all overflowed\n\t\t\t * flushers, advance work_color and append to\n\t\t\t * flusher_queue.  This is the start-to-wait\n\t\t\t * phase for these overflowed flushers.\n\t\t\t */\n\t\t\tlist_for_each_entry(tmp, &wq->flusher_overflow, list)\n\t\t\t\ttmp->flush_color = wq->work_color;\n\n\t\t\twq->work_color = work_next_color(wq->work_color);\n\n\t\t\tlist_splice_tail_init(&wq->flusher_overflow,\n\t\t\t\t\t      &wq->flusher_queue);\n\t\t\tflush_workqueue_prep_pwqs(wq, -1, wq->work_color);\n\t\t}\n\n\t\tif (list_empty(&wq->flusher_queue)) {\n\t\t\tWARN_ON_ONCE(wq->flush_color != wq->work_color);\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Need to flush more colors.  Make the next flusher\n\t\t * the new first flusher and arm pwqs.\n\t\t */\n\t\tWARN_ON_ONCE(wq->flush_color == wq->work_color);\n\t\tWARN_ON_ONCE(wq->flush_color != next->flush_color);\n\n\t\tlist_del_init(&next->list);\n\t\twq->first_flusher = next;\n\n\t\tif (flush_workqueue_prep_pwqs(wq, wq->flush_color, -1))\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Meh... this color is already done, clear first\n\t\t * flusher and repeat cascading.\n\t\t */\n\t\twq->first_flusher = NULL;\n\t}\n\nout_unlock:\n\tmutex_unlock(&wq->mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "queue_work",
          "args": [
            "wq",
            "&stress->work"
          ],
          "line": 608
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_stop_queue_work",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/stop_machine.c",
          "lines": "93-113",
          "snippet": "static bool cpu_stop_queue_work(unsigned int cpu, struct cpu_stop_work *work)\n{\n\tstruct cpu_stopper *stopper = &per_cpu(cpu_stopper, cpu);\n\tDEFINE_WAKE_Q(wakeq);\n\tunsigned long flags;\n\tbool enabled;\n\n\tpreempt_disable();\n\traw_spin_lock_irqsave(&stopper->lock, flags);\n\tenabled = stopper->enabled;\n\tif (enabled)\n\t\t__cpu_stop_queue_work(stopper, work, &wakeq);\n\telse if (work->done)\n\t\tcpu_stop_signal_done(work->done);\n\traw_spin_unlock_irqrestore(&stopper->lock, flags);\n\n\twake_up_q(&wakeq);\n\tpreempt_enable();\n\n\treturn enabled;\n}",
          "includes": [
            "#include <linux/sched/wake_q.h>",
            "#include <linux/nmi.h>",
            "#include <linux/atomic.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/sched.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/kthread.h>",
            "#include <linux/init.h>",
            "#include <linux/cpu.h>",
            "#include <linux/completion.h>",
            "#include <linux/compiler.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct cpu_stopper, cpu_stopper);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/wake_q.h>\n#include <linux/nmi.h>\n#include <linux/atomic.h>\n#include <linux/smpboot.h>\n#include <linux/kallsyms.h>\n#include <linux/interrupt.h>\n#include <linux/stop_machine.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kthread.h>\n#include <linux/init.h>\n#include <linux/cpu.h>\n#include <linux/completion.h>\n#include <linux/compiler.h>\n\nstatic DEFINE_PER_CPU(struct cpu_stopper, cpu_stopper);\n\nstatic bool cpu_stop_queue_work(unsigned int cpu, struct cpu_stop_work *work)\n{\n\tstruct cpu_stopper *stopper = &per_cpu(cpu_stopper, cpu);\n\tDEFINE_WAKE_Q(wakeq);\n\tunsigned long flags;\n\tbool enabled;\n\n\tpreempt_disable();\n\traw_spin_lock_irqsave(&stopper->lock, flags);\n\tenabled = stopper->enabled;\n\tif (enabled)\n\t\t__cpu_stop_queue_work(stopper, work, &wakeq);\n\telse if (work->done)\n\t\tcpu_stop_signal_done(work->done);\n\traw_spin_unlock_irqrestore(&stopper->lock, flags);\n\n\twake_up_q(&wakeq);\n\tpreempt_enable();\n\n\treturn enabled;\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_WORK",
          "args": [
            "&stress->work",
            "fn"
          ],
          "line": 603
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(*stress)",
            "GFP_KERNEL"
          ],
          "line": 599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ww_mutex_init",
          "args": [
            "&locks[n]",
            "&ww_class"
          ],
          "line": 574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc_array",
          "args": [
            "nlocks",
            "sizeof(*locks)",
            "GFP_KERNEL"
          ],
          "line": 569
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ww_mutex.h>\n#include <linux/slab.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/completion.h>\n#include <linux/kernel.h>\n\n#define STRESS_ONE BIT(2)\n#define STRESS_REORDER BIT(1)\n#define STRESS_INORDER BIT(0)\n\nstatic DEFINE_WD_CLASS(ww_class);\nstruct workqueue_struct *wq;\n\nstatic int stress(int nlocks, int nthreads, unsigned int flags)\n{\n\tstruct ww_mutex *locks;\n\tint n;\n\n\tlocks = kmalloc_array(nlocks, sizeof(*locks), GFP_KERNEL);\n\tif (!locks)\n\t\treturn -ENOMEM;\n\n\tfor (n = 0; n < nlocks; n++)\n\t\tww_mutex_init(&locks[n], &ww_class);\n\n\tfor (n = 0; nthreads; n++) {\n\t\tstruct stress *stress;\n\t\tvoid (*fn)(struct work_struct *work);\n\n\t\tfn = NULL;\n\t\tswitch (n & 3) {\n\t\tcase 0:\n\t\t\tif (flags & STRESS_INORDER)\n\t\t\t\tfn = stress_inorder_work;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tif (flags & STRESS_REORDER)\n\t\t\t\tfn = stress_reorder_work;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tif (flags & STRESS_ONE)\n\t\t\t\tfn = stress_one_work;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!fn)\n\t\t\tcontinue;\n\n\t\tstress = kmalloc(sizeof(*stress), GFP_KERNEL);\n\t\tif (!stress)\n\t\t\tbreak;\n\n\t\tINIT_WORK(&stress->work, fn);\n\t\tstress->locks = locks;\n\t\tstress->nlocks = nlocks;\n\t\tstress->timeout = jiffies + 2*HZ;\n\n\t\tqueue_work(wq, &stress->work);\n\t\tnthreads--;\n\t}\n\n\tflush_workqueue(wq);\n\n\tfor (n = 0; n < nlocks; n++)\n\t\tww_mutex_destroy(&locks[n]);\n\tkfree(locks);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "stress_one_work",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/test-ww_mutex.c",
    "lines": "537-557",
    "snippet": "static void stress_one_work(struct work_struct *work)\n{\n\tstruct stress *stress = container_of(work, typeof(*stress), work);\n\tconst int nlocks = stress->nlocks;\n\tstruct ww_mutex *lock = stress->locks + (get_random_int() % nlocks);\n\tint err;\n\n\tdo {\n\t\terr = ww_mutex_lock(lock, NULL);\n\t\tif (!err) {\n\t\t\tdummy_load(stress);\n\t\t\tww_mutex_unlock(lock);\n\t\t} else {\n\t\t\tpr_err_once(\"stress (%s) failed with %d\\n\",\n\t\t\t\t    __func__, err);\n\t\t\tbreak;\n\t\t}\n\t} while (!time_after(jiffies, stress->timeout));\n\n\tkfree(stress);\n}",
    "includes": [
      "#include <linux/ww_mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/completion.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "stress"
          ],
          "line": 556
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "time_after",
          "args": [
            "jiffies",
            "stress->timeout"
          ],
          "line": 554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err_once",
          "args": [
            "\"stress (%s) failed with %d\\n\"",
            "__func__",
            "err"
          ],
          "line": 550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ww_mutex_unlock",
          "args": [
            "lock"
          ],
          "line": 548
        },
        "resolved": true,
        "details": {
          "function_name": "__ww_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/ww_mutex.h",
          "lines": "559-569",
          "snippet": "static inline void __ww_mutex_unlock(struct ww_mutex *lock)\n{\n\tif (lock->ctx) {\n#ifdef DEBUG_WW_MUTEXES\n\t\tDEBUG_LOCKS_WARN_ON(!lock->ctx->acquired);\n#endif\n\t\tif (lock->ctx->acquired > 0)\n\t\t\tlock->ctx->acquired--;\n\t\tlock->ctx = NULL;\n\t}\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void __ww_mutex_unlock(struct ww_mutex *lock)\n{\n\tif (lock->ctx) {\n#ifdef DEBUG_WW_MUTEXES\n\t\tDEBUG_LOCKS_WARN_ON(!lock->ctx->acquired);\n#endif\n\t\tif (lock->ctx->acquired > 0)\n\t\t\tlock->ctx->acquired--;\n\t\tlock->ctx = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "dummy_load",
          "args": [
            "stress"
          ],
          "line": 547
        },
        "resolved": true,
        "details": {
          "function_name": "dummy_load",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/test-ww_mutex.c",
          "lines": "413-416",
          "snippet": "static void dummy_load(struct stress *stress)\n{\n\tusleep_range(1000, 2000);\n}",
          "includes": [
            "#include <linux/ww_mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/completion.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ww_mutex.h>\n#include <linux/slab.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/completion.h>\n#include <linux/kernel.h>\n\nstatic void dummy_load(struct stress *stress)\n{\n\tusleep_range(1000, 2000);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ww_mutex_lock",
          "args": [
            "lock",
            "NULL"
          ],
          "line": 545
        },
        "resolved": true,
        "details": {
          "function_name": "ww_mutex_lock_acquired",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "45-48",
          "snippet": "static inline void ww_mutex_lock_acquired(struct ww_mutex *lock,\n\t\t\t\t\t  struct ww_acquire_ctx *ww_ctx)\n{\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic inline void ww_mutex_lock_acquired(struct ww_mutex *lock,\n\t\t\t\t\t  struct ww_acquire_ctx *ww_ctx)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_random_int",
          "args": [],
          "line": 541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "work",
            "typeof(*stress)",
            "work"
          ],
          "line": 539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "typeof",
          "args": [
            "*stress"
          ],
          "line": 539
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ww_mutex.h>\n#include <linux/slab.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/completion.h>\n#include <linux/kernel.h>\n\nstatic void stress_one_work(struct work_struct *work)\n{\n\tstruct stress *stress = container_of(work, typeof(*stress), work);\n\tconst int nlocks = stress->nlocks;\n\tstruct ww_mutex *lock = stress->locks + (get_random_int() % nlocks);\n\tint err;\n\n\tdo {\n\t\terr = ww_mutex_lock(lock, NULL);\n\t\tif (!err) {\n\t\t\tdummy_load(stress);\n\t\t\tww_mutex_unlock(lock);\n\t\t} else {\n\t\t\tpr_err_once(\"stress (%s) failed with %d\\n\",\n\t\t\t\t    __func__, err);\n\t\t\tbreak;\n\t\t}\n\t} while (!time_after(jiffies, stress->timeout));\n\n\tkfree(stress);\n}"
  },
  {
    "function_name": "stress_reorder_work",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/test-ww_mutex.c",
    "lines": "477-535",
    "snippet": "static void stress_reorder_work(struct work_struct *work)\n{\n\tstruct stress *stress = container_of(work, typeof(*stress), work);\n\tLIST_HEAD(locks);\n\tstruct ww_acquire_ctx ctx;\n\tstruct reorder_lock *ll, *ln;\n\tint *order;\n\tint n, err;\n\n\torder = get_random_order(stress->nlocks);\n\tif (!order)\n\t\treturn;\n\n\tfor (n = 0; n < stress->nlocks; n++) {\n\t\tll = kmalloc(sizeof(*ll), GFP_KERNEL);\n\t\tif (!ll)\n\t\t\tgoto out;\n\n\t\tll->lock = &stress->locks[order[n]];\n\t\tlist_add(&ll->link, &locks);\n\t}\n\tkfree(order);\n\torder = NULL;\n\n\tdo {\n\t\tww_acquire_init(&ctx, &ww_class);\n\n\t\tlist_for_each_entry(ll, &locks, link) {\n\t\t\terr = ww_mutex_lock(ll->lock, &ctx);\n\t\t\tif (!err)\n\t\t\t\tcontinue;\n\n\t\t\tln = ll;\n\t\t\tlist_for_each_entry_continue_reverse(ln, &locks, link)\n\t\t\t\tww_mutex_unlock(ln->lock);\n\n\t\t\tif (err != -EDEADLK) {\n\t\t\t\tpr_err_once(\"stress (%s) failed with %d\\n\",\n\t\t\t\t\t    __func__, err);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tww_mutex_lock_slow(ll->lock, &ctx);\n\t\t\tlist_move(&ll->link, &locks); /* restarts iteration */\n\t\t}\n\n\t\tdummy_load(stress);\n\t\tlist_for_each_entry(ll, &locks, link)\n\t\t\tww_mutex_unlock(ll->lock);\n\n\t\tww_acquire_fini(&ctx);\n\t} while (!time_after(jiffies, stress->timeout));\n\nout:\n\tlist_for_each_entry_safe(ll, ln, &locks, link)\n\t\tkfree(ll);\n\tkfree(order);\n\tkfree(stress);\n}",
    "includes": [
      "#include <linux/ww_mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/completion.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_WD_CLASS(ww_class);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "stress"
          ],
          "line": 534
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "ll",
            "ln",
            "&locks",
            "link"
          ],
          "line": 531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time_after",
          "args": [
            "jiffies",
            "stress->timeout"
          ],
          "line": 528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ww_acquire_fini",
          "args": [
            "&ctx"
          ],
          "line": 527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ww_mutex_unlock",
          "args": [
            "ll->lock"
          ],
          "line": 525
        },
        "resolved": true,
        "details": {
          "function_name": "__ww_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/ww_mutex.h",
          "lines": "559-569",
          "snippet": "static inline void __ww_mutex_unlock(struct ww_mutex *lock)\n{\n\tif (lock->ctx) {\n#ifdef DEBUG_WW_MUTEXES\n\t\tDEBUG_LOCKS_WARN_ON(!lock->ctx->acquired);\n#endif\n\t\tif (lock->ctx->acquired > 0)\n\t\t\tlock->ctx->acquired--;\n\t\tlock->ctx = NULL;\n\t}\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void __ww_mutex_unlock(struct ww_mutex *lock)\n{\n\tif (lock->ctx) {\n#ifdef DEBUG_WW_MUTEXES\n\t\tDEBUG_LOCKS_WARN_ON(!lock->ctx->acquired);\n#endif\n\t\tif (lock->ctx->acquired > 0)\n\t\t\tlock->ctx->acquired--;\n\t\tlock->ctx = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "ll",
            "&locks",
            "link"
          ],
          "line": 524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dummy_load",
          "args": [
            "stress"
          ],
          "line": 523
        },
        "resolved": true,
        "details": {
          "function_name": "dummy_load",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/test-ww_mutex.c",
          "lines": "413-416",
          "snippet": "static void dummy_load(struct stress *stress)\n{\n\tusleep_range(1000, 2000);\n}",
          "includes": [
            "#include <linux/ww_mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/completion.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ww_mutex.h>\n#include <linux/slab.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/completion.h>\n#include <linux/kernel.h>\n\nstatic void dummy_load(struct stress *stress)\n{\n\tusleep_range(1000, 2000);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_move",
          "args": [
            "&ll->link",
            "&locks"
          ],
          "line": 520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ww_mutex_lock_slow",
          "args": [
            "ll->lock",
            "&ctx"
          ],
          "line": 519
        },
        "resolved": true,
        "details": {
          "function_name": "__ww_mutex_lock_slowpath",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/mutex.c",
          "lines": "1036-1041",
          "snippet": "__sched\n__ww_mutex_lock_slowpath(struct ww_mutex *lock, struct ww_acquire_ctx *ctx)\n{\n\treturn __ww_mutex_lock(&lock->base, TASK_UNINTERRUPTIBLE, 0,\n\t\t\t       _RET_IP_, ctx);\n}",
          "includes": [
            "#include \"ww_mutex.h\"",
            "#include \"mutex.h\"",
            "#include <linux/osq_lock.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/ww_mutex.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ww_mutex.h\"\n#include \"mutex.h\"\n#include <linux/osq_lock.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/ww_mutex.h>\n#include <linux/mutex.h>\n\n__sched\n__ww_mutex_lock_slowpath(struct ww_mutex *lock, struct ww_acquire_ctx *ctx)\n{\n\treturn __ww_mutex_lock(&lock->base, TASK_UNINTERRUPTIBLE, 0,\n\t\t\t       _RET_IP_, ctx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err_once",
          "args": [
            "\"stress (%s) failed with %d\\n\"",
            "__func__",
            "err"
          ],
          "line": 514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_continue_reverse",
          "args": [
            "ln",
            "&locks",
            "link"
          ],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ww_mutex_lock",
          "args": [
            "ll->lock",
            "&ctx"
          ],
          "line": 505
        },
        "resolved": true,
        "details": {
          "function_name": "ww_mutex_lock_acquired",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "45-48",
          "snippet": "static inline void ww_mutex_lock_acquired(struct ww_mutex *lock,\n\t\t\t\t\t  struct ww_acquire_ctx *ww_ctx)\n{\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic inline void ww_mutex_lock_acquired(struct ww_mutex *lock,\n\t\t\t\t\t  struct ww_acquire_ctx *ww_ctx)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "ll",
            "&locks",
            "link"
          ],
          "line": 504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ww_acquire_init",
          "args": [
            "&ctx",
            "&ww_class"
          ],
          "line": 502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&ll->link",
            "&locks"
          ],
          "line": 496
        },
        "resolved": true,
        "details": {
          "function_name": "cmp_filterlist_addrs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/debugfs.c",
          "lines": "95-101",
          "snippet": "static int cmp_filterlist_addrs(const void *rhs, const void *lhs)\n{\n\tconst unsigned long a = *(const unsigned long *)rhs;\n\tconst unsigned long b = *(const unsigned long *)lhs;\n\n\treturn a < b ? -1 : a == b ? 0 : 1;\n}",
          "includes": [
            "#include \"kcsan.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/bug.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kcsan.h\"\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/debugfs.h>\n#include <linux/bug.h>\n#include <linux/bsearch.h>\n#include <linux/atomic.h>\n\nstatic int cmp_filterlist_addrs(const void *rhs, const void *lhs)\n{\n\tconst unsigned long a = *(const unsigned long *)rhs;\n\tconst unsigned long b = *(const unsigned long *)lhs;\n\n\treturn a < b ? -1 : a == b ? 0 : 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(*ll)",
            "GFP_KERNEL"
          ],
          "line": 491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_random_order",
          "args": [
            "stress->nlocks"
          ],
          "line": 486
        },
        "resolved": true,
        "details": {
          "function_name": "get_random_order",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/test-ww_mutex.c",
          "lines": "389-411",
          "snippet": "static int *get_random_order(int count)\n{\n\tint *order;\n\tint n, r, tmp;\n\n\torder = kmalloc_array(count, sizeof(*order), GFP_KERNEL);\n\tif (!order)\n\t\treturn order;\n\n\tfor (n = 0; n < count; n++)\n\t\torder[n] = n;\n\n\tfor (n = count - 1; n > 1; n--) {\n\t\tr = get_random_int() % (n + 1);\n\t\tif (r != n) {\n\t\t\ttmp = order[n];\n\t\t\torder[n] = order[r];\n\t\t\torder[r] = tmp;\n\t\t}\n\t}\n\n\treturn order;\n}",
          "includes": [
            "#include <linux/ww_mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/completion.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ww_mutex.h>\n#include <linux/slab.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/completion.h>\n#include <linux/kernel.h>\n\nstatic int *get_random_order(int count)\n{\n\tint *order;\n\tint n, r, tmp;\n\n\torder = kmalloc_array(count, sizeof(*order), GFP_KERNEL);\n\tif (!order)\n\t\treturn order;\n\n\tfor (n = 0; n < count; n++)\n\t\torder[n] = n;\n\n\tfor (n = count - 1; n > 1; n--) {\n\t\tr = get_random_int() % (n + 1);\n\t\tif (r != n) {\n\t\t\ttmp = order[n];\n\t\t\torder[n] = order[r];\n\t\t\torder[r] = tmp;\n\t\t}\n\t}\n\n\treturn order;\n}"
        }
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "locks"
          ],
          "line": 480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "work",
            "typeof(*stress)",
            "work"
          ],
          "line": 479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "typeof",
          "args": [
            "*stress"
          ],
          "line": 479
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ww_mutex.h>\n#include <linux/slab.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/completion.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_WD_CLASS(ww_class);\n\nstatic void stress_reorder_work(struct work_struct *work)\n{\n\tstruct stress *stress = container_of(work, typeof(*stress), work);\n\tLIST_HEAD(locks);\n\tstruct ww_acquire_ctx ctx;\n\tstruct reorder_lock *ll, *ln;\n\tint *order;\n\tint n, err;\n\n\torder = get_random_order(stress->nlocks);\n\tif (!order)\n\t\treturn;\n\n\tfor (n = 0; n < stress->nlocks; n++) {\n\t\tll = kmalloc(sizeof(*ll), GFP_KERNEL);\n\t\tif (!ll)\n\t\t\tgoto out;\n\n\t\tll->lock = &stress->locks[order[n]];\n\t\tlist_add(&ll->link, &locks);\n\t}\n\tkfree(order);\n\torder = NULL;\n\n\tdo {\n\t\tww_acquire_init(&ctx, &ww_class);\n\n\t\tlist_for_each_entry(ll, &locks, link) {\n\t\t\terr = ww_mutex_lock(ll->lock, &ctx);\n\t\t\tif (!err)\n\t\t\t\tcontinue;\n\n\t\t\tln = ll;\n\t\t\tlist_for_each_entry_continue_reverse(ln, &locks, link)\n\t\t\t\tww_mutex_unlock(ln->lock);\n\n\t\t\tif (err != -EDEADLK) {\n\t\t\t\tpr_err_once(\"stress (%s) failed with %d\\n\",\n\t\t\t\t\t    __func__, err);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tww_mutex_lock_slow(ll->lock, &ctx);\n\t\t\tlist_move(&ll->link, &locks); /* restarts iteration */\n\t\t}\n\n\t\tdummy_load(stress);\n\t\tlist_for_each_entry(ll, &locks, link)\n\t\t\tww_mutex_unlock(ll->lock);\n\n\t\tww_acquire_fini(&ctx);\n\t} while (!time_after(jiffies, stress->timeout));\n\nout:\n\tlist_for_each_entry_safe(ll, ln, &locks, link)\n\t\tkfree(ll);\n\tkfree(order);\n\tkfree(stress);\n}"
  },
  {
    "function_name": "stress_inorder_work",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/test-ww_mutex.c",
    "lines": "418-470",
    "snippet": "static void stress_inorder_work(struct work_struct *work)\n{\n\tstruct stress *stress = container_of(work, typeof(*stress), work);\n\tconst int nlocks = stress->nlocks;\n\tstruct ww_mutex *locks = stress->locks;\n\tstruct ww_acquire_ctx ctx;\n\tint *order;\n\n\torder = get_random_order(nlocks);\n\tif (!order)\n\t\treturn;\n\n\tdo {\n\t\tint contended = -1;\n\t\tint n, err;\n\n\t\tww_acquire_init(&ctx, &ww_class);\nretry:\n\t\terr = 0;\n\t\tfor (n = 0; n < nlocks; n++) {\n\t\t\tif (n == contended)\n\t\t\t\tcontinue;\n\n\t\t\terr = ww_mutex_lock(&locks[order[n]], &ctx);\n\t\t\tif (err < 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (!err)\n\t\t\tdummy_load(stress);\n\n\t\tif (contended > n)\n\t\t\tww_mutex_unlock(&locks[order[contended]]);\n\t\tcontended = n;\n\t\twhile (n--)\n\t\t\tww_mutex_unlock(&locks[order[n]]);\n\n\t\tif (err == -EDEADLK) {\n\t\t\tww_mutex_lock_slow(&locks[order[contended]], &ctx);\n\t\t\tgoto retry;\n\t\t}\n\n\t\tif (err) {\n\t\t\tpr_err_once(\"stress (%s) failed with %d\\n\",\n\t\t\t\t    __func__, err);\n\t\t\tbreak;\n\t\t}\n\n\t\tww_acquire_fini(&ctx);\n\t} while (!time_after(jiffies, stress->timeout));\n\n\tkfree(order);\n\tkfree(stress);\n}",
    "includes": [
      "#include <linux/ww_mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/completion.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_WD_CLASS(ww_class);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "stress"
          ],
          "line": 469
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "time_after",
          "args": [
            "jiffies",
            "stress->timeout"
          ],
          "line": 466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ww_acquire_fini",
          "args": [
            "&ctx"
          ],
          "line": 465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err_once",
          "args": [
            "\"stress (%s) failed with %d\\n\"",
            "__func__",
            "err"
          ],
          "line": 460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ww_mutex_lock_slow",
          "args": [
            "&locks[order[contended]]",
            "&ctx"
          ],
          "line": 455
        },
        "resolved": true,
        "details": {
          "function_name": "__ww_mutex_lock_slowpath",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/mutex.c",
          "lines": "1036-1041",
          "snippet": "__sched\n__ww_mutex_lock_slowpath(struct ww_mutex *lock, struct ww_acquire_ctx *ctx)\n{\n\treturn __ww_mutex_lock(&lock->base, TASK_UNINTERRUPTIBLE, 0,\n\t\t\t       _RET_IP_, ctx);\n}",
          "includes": [
            "#include \"ww_mutex.h\"",
            "#include \"mutex.h\"",
            "#include <linux/osq_lock.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/ww_mutex.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ww_mutex.h\"\n#include \"mutex.h\"\n#include <linux/osq_lock.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/ww_mutex.h>\n#include <linux/mutex.h>\n\n__sched\n__ww_mutex_lock_slowpath(struct ww_mutex *lock, struct ww_acquire_ctx *ctx)\n{\n\treturn __ww_mutex_lock(&lock->base, TASK_UNINTERRUPTIBLE, 0,\n\t\t\t       _RET_IP_, ctx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ww_mutex_unlock",
          "args": [
            "&locks[order[n]]"
          ],
          "line": 452
        },
        "resolved": true,
        "details": {
          "function_name": "__ww_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/ww_mutex.h",
          "lines": "559-569",
          "snippet": "static inline void __ww_mutex_unlock(struct ww_mutex *lock)\n{\n\tif (lock->ctx) {\n#ifdef DEBUG_WW_MUTEXES\n\t\tDEBUG_LOCKS_WARN_ON(!lock->ctx->acquired);\n#endif\n\t\tif (lock->ctx->acquired > 0)\n\t\t\tlock->ctx->acquired--;\n\t\tlock->ctx = NULL;\n\t}\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void __ww_mutex_unlock(struct ww_mutex *lock)\n{\n\tif (lock->ctx) {\n#ifdef DEBUG_WW_MUTEXES\n\t\tDEBUG_LOCKS_WARN_ON(!lock->ctx->acquired);\n#endif\n\t\tif (lock->ctx->acquired > 0)\n\t\t\tlock->ctx->acquired--;\n\t\tlock->ctx = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "dummy_load",
          "args": [
            "stress"
          ],
          "line": 446
        },
        "resolved": true,
        "details": {
          "function_name": "dummy_load",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/test-ww_mutex.c",
          "lines": "413-416",
          "snippet": "static void dummy_load(struct stress *stress)\n{\n\tusleep_range(1000, 2000);\n}",
          "includes": [
            "#include <linux/ww_mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/completion.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ww_mutex.h>\n#include <linux/slab.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/completion.h>\n#include <linux/kernel.h>\n\nstatic void dummy_load(struct stress *stress)\n{\n\tusleep_range(1000, 2000);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ww_mutex_lock",
          "args": [
            "&locks[order[n]]",
            "&ctx"
          ],
          "line": 441
        },
        "resolved": true,
        "details": {
          "function_name": "ww_mutex_lock_acquired",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "45-48",
          "snippet": "static inline void ww_mutex_lock_acquired(struct ww_mutex *lock,\n\t\t\t\t\t  struct ww_acquire_ctx *ww_ctx)\n{\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic inline void ww_mutex_lock_acquired(struct ww_mutex *lock,\n\t\t\t\t\t  struct ww_acquire_ctx *ww_ctx)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "ww_acquire_init",
          "args": [
            "&ctx",
            "&ww_class"
          ],
          "line": 434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_random_order",
          "args": [
            "nlocks"
          ],
          "line": 426
        },
        "resolved": true,
        "details": {
          "function_name": "get_random_order",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/test-ww_mutex.c",
          "lines": "389-411",
          "snippet": "static int *get_random_order(int count)\n{\n\tint *order;\n\tint n, r, tmp;\n\n\torder = kmalloc_array(count, sizeof(*order), GFP_KERNEL);\n\tif (!order)\n\t\treturn order;\n\n\tfor (n = 0; n < count; n++)\n\t\torder[n] = n;\n\n\tfor (n = count - 1; n > 1; n--) {\n\t\tr = get_random_int() % (n + 1);\n\t\tif (r != n) {\n\t\t\ttmp = order[n];\n\t\t\torder[n] = order[r];\n\t\t\torder[r] = tmp;\n\t\t}\n\t}\n\n\treturn order;\n}",
          "includes": [
            "#include <linux/ww_mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/completion.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ww_mutex.h>\n#include <linux/slab.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/completion.h>\n#include <linux/kernel.h>\n\nstatic int *get_random_order(int count)\n{\n\tint *order;\n\tint n, r, tmp;\n\n\torder = kmalloc_array(count, sizeof(*order), GFP_KERNEL);\n\tif (!order)\n\t\treturn order;\n\n\tfor (n = 0; n < count; n++)\n\t\torder[n] = n;\n\n\tfor (n = count - 1; n > 1; n--) {\n\t\tr = get_random_int() % (n + 1);\n\t\tif (r != n) {\n\t\t\ttmp = order[n];\n\t\t\torder[n] = order[r];\n\t\t\torder[r] = tmp;\n\t\t}\n\t}\n\n\treturn order;\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "work",
            "typeof(*stress)",
            "work"
          ],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "typeof",
          "args": [
            "*stress"
          ],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ww_mutex.h>\n#include <linux/slab.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/completion.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_WD_CLASS(ww_class);\n\nstatic void stress_inorder_work(struct work_struct *work)\n{\n\tstruct stress *stress = container_of(work, typeof(*stress), work);\n\tconst int nlocks = stress->nlocks;\n\tstruct ww_mutex *locks = stress->locks;\n\tstruct ww_acquire_ctx ctx;\n\tint *order;\n\n\torder = get_random_order(nlocks);\n\tif (!order)\n\t\treturn;\n\n\tdo {\n\t\tint contended = -1;\n\t\tint n, err;\n\n\t\tww_acquire_init(&ctx, &ww_class);\nretry:\n\t\terr = 0;\n\t\tfor (n = 0; n < nlocks; n++) {\n\t\t\tif (n == contended)\n\t\t\t\tcontinue;\n\n\t\t\terr = ww_mutex_lock(&locks[order[n]], &ctx);\n\t\t\tif (err < 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (!err)\n\t\t\tdummy_load(stress);\n\n\t\tif (contended > n)\n\t\t\tww_mutex_unlock(&locks[order[contended]]);\n\t\tcontended = n;\n\t\twhile (n--)\n\t\t\tww_mutex_unlock(&locks[order[n]]);\n\n\t\tif (err == -EDEADLK) {\n\t\t\tww_mutex_lock_slow(&locks[order[contended]], &ctx);\n\t\t\tgoto retry;\n\t\t}\n\n\t\tif (err) {\n\t\t\tpr_err_once(\"stress (%s) failed with %d\\n\",\n\t\t\t\t    __func__, err);\n\t\t\tbreak;\n\t\t}\n\n\t\tww_acquire_fini(&ctx);\n\t} while (!time_after(jiffies, stress->timeout));\n\n\tkfree(order);\n\tkfree(stress);\n}"
  },
  {
    "function_name": "dummy_load",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/test-ww_mutex.c",
    "lines": "413-416",
    "snippet": "static void dummy_load(struct stress *stress)\n{\n\tusleep_range(1000, 2000);\n}",
    "includes": [
      "#include <linux/ww_mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/completion.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "usleep_range",
          "args": [
            "1000",
            "2000"
          ],
          "line": 415
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ww_mutex.h>\n#include <linux/slab.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/completion.h>\n#include <linux/kernel.h>\n\nstatic void dummy_load(struct stress *stress)\n{\n\tusleep_range(1000, 2000);\n}"
  },
  {
    "function_name": "get_random_order",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/test-ww_mutex.c",
    "lines": "389-411",
    "snippet": "static int *get_random_order(int count)\n{\n\tint *order;\n\tint n, r, tmp;\n\n\torder = kmalloc_array(count, sizeof(*order), GFP_KERNEL);\n\tif (!order)\n\t\treturn order;\n\n\tfor (n = 0; n < count; n++)\n\t\torder[n] = n;\n\n\tfor (n = count - 1; n > 1; n--) {\n\t\tr = get_random_int() % (n + 1);\n\t\tif (r != n) {\n\t\t\ttmp = order[n];\n\t\t\torder[n] = order[r];\n\t\t\torder[r] = tmp;\n\t\t}\n\t}\n\n\treturn order;\n}",
    "includes": [
      "#include <linux/ww_mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/completion.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_random_int",
          "args": [],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc_array",
          "args": [
            "count",
            "sizeof(*order)",
            "GFP_KERNEL"
          ],
          "line": 394
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ww_mutex.h>\n#include <linux/slab.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/completion.h>\n#include <linux/kernel.h>\n\nstatic int *get_random_order(int count)\n{\n\tint *order;\n\tint n, r, tmp;\n\n\torder = kmalloc_array(count, sizeof(*order), GFP_KERNEL);\n\tif (!order)\n\t\treturn order;\n\n\tfor (n = 0; n < count; n++)\n\t\torder[n] = n;\n\n\tfor (n = count - 1; n > 1; n--) {\n\t\tr = get_random_int() % (n + 1);\n\t\tif (r != n) {\n\t\t\ttmp = order[n];\n\t\t\torder[n] = order[r];\n\t\t\torder[r] = tmp;\n\t\t}\n\t}\n\n\treturn order;\n}"
  },
  {
    "function_name": "test_cycle",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/test-ww_mutex.c",
    "lines": "368-380",
    "snippet": "static int test_cycle(unsigned int ncpus)\n{\n\tunsigned int n;\n\tint ret;\n\n\tfor (n = 2; n <= ncpus + 1; n++) {\n\t\tret = __test_cycle(n);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/ww_mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/completion.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__test_cycle",
          "args": [
            "n"
          ],
          "line": 374
        },
        "resolved": true,
        "details": {
          "function_name": "__test_cycle",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/test-ww_mutex.c",
          "lines": "315-366",
          "snippet": "static int __test_cycle(unsigned int nthreads)\n{\n\tstruct test_cycle *cycles;\n\tunsigned int n, last = nthreads - 1;\n\tint ret;\n\n\tcycles = kmalloc_array(nthreads, sizeof(*cycles), GFP_KERNEL);\n\tif (!cycles)\n\t\treturn -ENOMEM;\n\n\tfor (n = 0; n < nthreads; n++) {\n\t\tstruct test_cycle *cycle = &cycles[n];\n\n\t\tww_mutex_init(&cycle->a_mutex, &ww_class);\n\t\tif (n == last)\n\t\t\tcycle->b_mutex = &cycles[0].a_mutex;\n\t\telse\n\t\t\tcycle->b_mutex = &cycles[n + 1].a_mutex;\n\n\t\tif (n == 0)\n\t\t\tcycle->a_signal = &cycles[last].b_signal;\n\t\telse\n\t\t\tcycle->a_signal = &cycles[n - 1].b_signal;\n\t\tinit_completion(&cycle->b_signal);\n\n\t\tINIT_WORK(&cycle->work, test_cycle_work);\n\t\tcycle->result = 0;\n\t}\n\n\tfor (n = 0; n < nthreads; n++)\n\t\tqueue_work(wq, &cycles[n].work);\n\n\tflush_workqueue(wq);\n\n\tret = 0;\n\tfor (n = 0; n < nthreads; n++) {\n\t\tstruct test_cycle *cycle = &cycles[n];\n\n\t\tif (!cycle->result)\n\t\t\tcontinue;\n\n\t\tpr_err(\"cyclic deadlock not resolved, ret[%d/%d] = %d\\n\",\n\t\t       n, nthreads, cycle->result);\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\tfor (n = 0; n < nthreads; n++)\n\t\tww_mutex_destroy(&cycles[n].a_mutex);\n\tkfree(cycles);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/ww_mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/completion.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_WD_CLASS(ww_class);",
            "struct workqueue_struct *wq;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ww_mutex.h>\n#include <linux/slab.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/completion.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_WD_CLASS(ww_class);\nstruct workqueue_struct *wq;\n\nstatic int __test_cycle(unsigned int nthreads)\n{\n\tstruct test_cycle *cycles;\n\tunsigned int n, last = nthreads - 1;\n\tint ret;\n\n\tcycles = kmalloc_array(nthreads, sizeof(*cycles), GFP_KERNEL);\n\tif (!cycles)\n\t\treturn -ENOMEM;\n\n\tfor (n = 0; n < nthreads; n++) {\n\t\tstruct test_cycle *cycle = &cycles[n];\n\n\t\tww_mutex_init(&cycle->a_mutex, &ww_class);\n\t\tif (n == last)\n\t\t\tcycle->b_mutex = &cycles[0].a_mutex;\n\t\telse\n\t\t\tcycle->b_mutex = &cycles[n + 1].a_mutex;\n\n\t\tif (n == 0)\n\t\t\tcycle->a_signal = &cycles[last].b_signal;\n\t\telse\n\t\t\tcycle->a_signal = &cycles[n - 1].b_signal;\n\t\tinit_completion(&cycle->b_signal);\n\n\t\tINIT_WORK(&cycle->work, test_cycle_work);\n\t\tcycle->result = 0;\n\t}\n\n\tfor (n = 0; n < nthreads; n++)\n\t\tqueue_work(wq, &cycles[n].work);\n\n\tflush_workqueue(wq);\n\n\tret = 0;\n\tfor (n = 0; n < nthreads; n++) {\n\t\tstruct test_cycle *cycle = &cycles[n];\n\n\t\tif (!cycle->result)\n\t\t\tcontinue;\n\n\t\tpr_err(\"cyclic deadlock not resolved, ret[%d/%d] = %d\\n\",\n\t\t       n, nthreads, cycle->result);\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\tfor (n = 0; n < nthreads; n++)\n\t\tww_mutex_destroy(&cycles[n].a_mutex);\n\tkfree(cycles);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/ww_mutex.h>\n#include <linux/slab.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/completion.h>\n#include <linux/kernel.h>\n\nstatic int test_cycle(unsigned int ncpus)\n{\n\tunsigned int n;\n\tint ret;\n\n\tfor (n = 2; n <= ncpus + 1; n++) {\n\t\tret = __test_cycle(n);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "__test_cycle",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/test-ww_mutex.c",
    "lines": "315-366",
    "snippet": "static int __test_cycle(unsigned int nthreads)\n{\n\tstruct test_cycle *cycles;\n\tunsigned int n, last = nthreads - 1;\n\tint ret;\n\n\tcycles = kmalloc_array(nthreads, sizeof(*cycles), GFP_KERNEL);\n\tif (!cycles)\n\t\treturn -ENOMEM;\n\n\tfor (n = 0; n < nthreads; n++) {\n\t\tstruct test_cycle *cycle = &cycles[n];\n\n\t\tww_mutex_init(&cycle->a_mutex, &ww_class);\n\t\tif (n == last)\n\t\t\tcycle->b_mutex = &cycles[0].a_mutex;\n\t\telse\n\t\t\tcycle->b_mutex = &cycles[n + 1].a_mutex;\n\n\t\tif (n == 0)\n\t\t\tcycle->a_signal = &cycles[last].b_signal;\n\t\telse\n\t\t\tcycle->a_signal = &cycles[n - 1].b_signal;\n\t\tinit_completion(&cycle->b_signal);\n\n\t\tINIT_WORK(&cycle->work, test_cycle_work);\n\t\tcycle->result = 0;\n\t}\n\n\tfor (n = 0; n < nthreads; n++)\n\t\tqueue_work(wq, &cycles[n].work);\n\n\tflush_workqueue(wq);\n\n\tret = 0;\n\tfor (n = 0; n < nthreads; n++) {\n\t\tstruct test_cycle *cycle = &cycles[n];\n\n\t\tif (!cycle->result)\n\t\t\tcontinue;\n\n\t\tpr_err(\"cyclic deadlock not resolved, ret[%d/%d] = %d\\n\",\n\t\t       n, nthreads, cycle->result);\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\tfor (n = 0; n < nthreads; n++)\n\t\tww_mutex_destroy(&cycles[n].a_mutex);\n\tkfree(cycles);\n\treturn ret;\n}",
    "includes": [
      "#include <linux/ww_mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/completion.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_WD_CLASS(ww_class);",
      "struct workqueue_struct *wq;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "cycles"
          ],
          "line": 364
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ww_mutex_destroy",
          "args": [
            "&cycles[n].a_mutex"
          ],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"cyclic deadlock not resolved, ret[%d/%d] = %d\\n\"",
            "n",
            "nthreads",
            "cycle->result"
          ],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_workqueue",
          "args": [
            "wq"
          ],
          "line": 347
        },
        "resolved": true,
        "details": {
          "function_name": "flush_workqueue",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "2815-2963",
          "snippet": "void flush_workqueue(struct workqueue_struct *wq)\n{\n\tstruct wq_flusher this_flusher = {\n\t\t.list = LIST_HEAD_INIT(this_flusher.list),\n\t\t.flush_color = -1,\n\t\t.done = COMPLETION_INITIALIZER_ONSTACK_MAP(this_flusher.done, wq->lockdep_map),\n\t};\n\tint next_color;\n\n\tif (WARN_ON(!wq_online))\n\t\treturn;\n\n\tlock_map_acquire(&wq->lockdep_map);\n\tlock_map_release(&wq->lockdep_map);\n\n\tmutex_lock(&wq->mutex);\n\n\t/*\n\t * Start-to-wait phase\n\t */\n\tnext_color = work_next_color(wq->work_color);\n\n\tif (next_color != wq->flush_color) {\n\t\t/*\n\t\t * Color space is not full.  The current work_color\n\t\t * becomes our flush_color and work_color is advanced\n\t\t * by one.\n\t\t */\n\t\tWARN_ON_ONCE(!list_empty(&wq->flusher_overflow));\n\t\tthis_flusher.flush_color = wq->work_color;\n\t\twq->work_color = next_color;\n\n\t\tif (!wq->first_flusher) {\n\t\t\t/* no flush in progress, become the first flusher */\n\t\t\tWARN_ON_ONCE(wq->flush_color != this_flusher.flush_color);\n\n\t\t\twq->first_flusher = &this_flusher;\n\n\t\t\tif (!flush_workqueue_prep_pwqs(wq, wq->flush_color,\n\t\t\t\t\t\t       wq->work_color)) {\n\t\t\t\t/* nothing to flush, done */\n\t\t\t\twq->flush_color = next_color;\n\t\t\t\twq->first_flusher = NULL;\n\t\t\t\tgoto out_unlock;\n\t\t\t}\n\t\t} else {\n\t\t\t/* wait in queue */\n\t\t\tWARN_ON_ONCE(wq->flush_color == this_flusher.flush_color);\n\t\t\tlist_add_tail(&this_flusher.list, &wq->flusher_queue);\n\t\t\tflush_workqueue_prep_pwqs(wq, -1, wq->work_color);\n\t\t}\n\t} else {\n\t\t/*\n\t\t * Oops, color space is full, wait on overflow queue.\n\t\t * The next flush completion will assign us\n\t\t * flush_color and transfer to flusher_queue.\n\t\t */\n\t\tlist_add_tail(&this_flusher.list, &wq->flusher_overflow);\n\t}\n\n\tcheck_flush_dependency(wq, NULL);\n\n\tmutex_unlock(&wq->mutex);\n\n\twait_for_completion(&this_flusher.done);\n\n\t/*\n\t * Wake-up-and-cascade phase\n\t *\n\t * First flushers are responsible for cascading flushes and\n\t * handling overflow.  Non-first flushers can simply return.\n\t */\n\tif (READ_ONCE(wq->first_flusher) != &this_flusher)\n\t\treturn;\n\n\tmutex_lock(&wq->mutex);\n\n\t/* we might have raced, check again with mutex held */\n\tif (wq->first_flusher != &this_flusher)\n\t\tgoto out_unlock;\n\n\tWRITE_ONCE(wq->first_flusher, NULL);\n\n\tWARN_ON_ONCE(!list_empty(&this_flusher.list));\n\tWARN_ON_ONCE(wq->flush_color != this_flusher.flush_color);\n\n\twhile (true) {\n\t\tstruct wq_flusher *next, *tmp;\n\n\t\t/* complete all the flushers sharing the current flush color */\n\t\tlist_for_each_entry_safe(next, tmp, &wq->flusher_queue, list) {\n\t\t\tif (next->flush_color != wq->flush_color)\n\t\t\t\tbreak;\n\t\t\tlist_del_init(&next->list);\n\t\t\tcomplete(&next->done);\n\t\t}\n\n\t\tWARN_ON_ONCE(!list_empty(&wq->flusher_overflow) &&\n\t\t\t     wq->flush_color != work_next_color(wq->work_color));\n\n\t\t/* this flush_color is finished, advance by one */\n\t\twq->flush_color = work_next_color(wq->flush_color);\n\n\t\t/* one color has been freed, handle overflow queue */\n\t\tif (!list_empty(&wq->flusher_overflow)) {\n\t\t\t/*\n\t\t\t * Assign the same color to all overflowed\n\t\t\t * flushers, advance work_color and append to\n\t\t\t * flusher_queue.  This is the start-to-wait\n\t\t\t * phase for these overflowed flushers.\n\t\t\t */\n\t\t\tlist_for_each_entry(tmp, &wq->flusher_overflow, list)\n\t\t\t\ttmp->flush_color = wq->work_color;\n\n\t\t\twq->work_color = work_next_color(wq->work_color);\n\n\t\t\tlist_splice_tail_init(&wq->flusher_overflow,\n\t\t\t\t\t      &wq->flusher_queue);\n\t\t\tflush_workqueue_prep_pwqs(wq, -1, wq->work_color);\n\t\t}\n\n\t\tif (list_empty(&wq->flusher_queue)) {\n\t\t\tWARN_ON_ONCE(wq->flush_color != wq->work_color);\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Need to flush more colors.  Make the next flusher\n\t\t * the new first flusher and arm pwqs.\n\t\t */\n\t\tWARN_ON_ONCE(wq->flush_color == wq->work_color);\n\t\tWARN_ON_ONCE(wq->flush_color != next->flush_color);\n\n\t\tlist_del_init(&next->list);\n\t\twq->first_flusher = next;\n\n\t\tif (flush_workqueue_prep_pwqs(wq, wq->flush_color, -1))\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Meh... this color is already done, clear first\n\t\t * flusher and repeat cascading.\n\t\t */\n\t\twq->first_flusher = NULL;\n\t}\n\nout_unlock:\n\tmutex_unlock(&wq->mutex);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool wq_online;",
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic bool wq_online;\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nvoid flush_workqueue(struct workqueue_struct *wq)\n{\n\tstruct wq_flusher this_flusher = {\n\t\t.list = LIST_HEAD_INIT(this_flusher.list),\n\t\t.flush_color = -1,\n\t\t.done = COMPLETION_INITIALIZER_ONSTACK_MAP(this_flusher.done, wq->lockdep_map),\n\t};\n\tint next_color;\n\n\tif (WARN_ON(!wq_online))\n\t\treturn;\n\n\tlock_map_acquire(&wq->lockdep_map);\n\tlock_map_release(&wq->lockdep_map);\n\n\tmutex_lock(&wq->mutex);\n\n\t/*\n\t * Start-to-wait phase\n\t */\n\tnext_color = work_next_color(wq->work_color);\n\n\tif (next_color != wq->flush_color) {\n\t\t/*\n\t\t * Color space is not full.  The current work_color\n\t\t * becomes our flush_color and work_color is advanced\n\t\t * by one.\n\t\t */\n\t\tWARN_ON_ONCE(!list_empty(&wq->flusher_overflow));\n\t\tthis_flusher.flush_color = wq->work_color;\n\t\twq->work_color = next_color;\n\n\t\tif (!wq->first_flusher) {\n\t\t\t/* no flush in progress, become the first flusher */\n\t\t\tWARN_ON_ONCE(wq->flush_color != this_flusher.flush_color);\n\n\t\t\twq->first_flusher = &this_flusher;\n\n\t\t\tif (!flush_workqueue_prep_pwqs(wq, wq->flush_color,\n\t\t\t\t\t\t       wq->work_color)) {\n\t\t\t\t/* nothing to flush, done */\n\t\t\t\twq->flush_color = next_color;\n\t\t\t\twq->first_flusher = NULL;\n\t\t\t\tgoto out_unlock;\n\t\t\t}\n\t\t} else {\n\t\t\t/* wait in queue */\n\t\t\tWARN_ON_ONCE(wq->flush_color == this_flusher.flush_color);\n\t\t\tlist_add_tail(&this_flusher.list, &wq->flusher_queue);\n\t\t\tflush_workqueue_prep_pwqs(wq, -1, wq->work_color);\n\t\t}\n\t} else {\n\t\t/*\n\t\t * Oops, color space is full, wait on overflow queue.\n\t\t * The next flush completion will assign us\n\t\t * flush_color and transfer to flusher_queue.\n\t\t */\n\t\tlist_add_tail(&this_flusher.list, &wq->flusher_overflow);\n\t}\n\n\tcheck_flush_dependency(wq, NULL);\n\n\tmutex_unlock(&wq->mutex);\n\n\twait_for_completion(&this_flusher.done);\n\n\t/*\n\t * Wake-up-and-cascade phase\n\t *\n\t * First flushers are responsible for cascading flushes and\n\t * handling overflow.  Non-first flushers can simply return.\n\t */\n\tif (READ_ONCE(wq->first_flusher) != &this_flusher)\n\t\treturn;\n\n\tmutex_lock(&wq->mutex);\n\n\t/* we might have raced, check again with mutex held */\n\tif (wq->first_flusher != &this_flusher)\n\t\tgoto out_unlock;\n\n\tWRITE_ONCE(wq->first_flusher, NULL);\n\n\tWARN_ON_ONCE(!list_empty(&this_flusher.list));\n\tWARN_ON_ONCE(wq->flush_color != this_flusher.flush_color);\n\n\twhile (true) {\n\t\tstruct wq_flusher *next, *tmp;\n\n\t\t/* complete all the flushers sharing the current flush color */\n\t\tlist_for_each_entry_safe(next, tmp, &wq->flusher_queue, list) {\n\t\t\tif (next->flush_color != wq->flush_color)\n\t\t\t\tbreak;\n\t\t\tlist_del_init(&next->list);\n\t\t\tcomplete(&next->done);\n\t\t}\n\n\t\tWARN_ON_ONCE(!list_empty(&wq->flusher_overflow) &&\n\t\t\t     wq->flush_color != work_next_color(wq->work_color));\n\n\t\t/* this flush_color is finished, advance by one */\n\t\twq->flush_color = work_next_color(wq->flush_color);\n\n\t\t/* one color has been freed, handle overflow queue */\n\t\tif (!list_empty(&wq->flusher_overflow)) {\n\t\t\t/*\n\t\t\t * Assign the same color to all overflowed\n\t\t\t * flushers, advance work_color and append to\n\t\t\t * flusher_queue.  This is the start-to-wait\n\t\t\t * phase for these overflowed flushers.\n\t\t\t */\n\t\t\tlist_for_each_entry(tmp, &wq->flusher_overflow, list)\n\t\t\t\ttmp->flush_color = wq->work_color;\n\n\t\t\twq->work_color = work_next_color(wq->work_color);\n\n\t\t\tlist_splice_tail_init(&wq->flusher_overflow,\n\t\t\t\t\t      &wq->flusher_queue);\n\t\t\tflush_workqueue_prep_pwqs(wq, -1, wq->work_color);\n\t\t}\n\n\t\tif (list_empty(&wq->flusher_queue)) {\n\t\t\tWARN_ON_ONCE(wq->flush_color != wq->work_color);\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Need to flush more colors.  Make the next flusher\n\t\t * the new first flusher and arm pwqs.\n\t\t */\n\t\tWARN_ON_ONCE(wq->flush_color == wq->work_color);\n\t\tWARN_ON_ONCE(wq->flush_color != next->flush_color);\n\n\t\tlist_del_init(&next->list);\n\t\twq->first_flusher = next;\n\n\t\tif (flush_workqueue_prep_pwqs(wq, wq->flush_color, -1))\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Meh... this color is already done, clear first\n\t\t * flusher and repeat cascading.\n\t\t */\n\t\twq->first_flusher = NULL;\n\t}\n\nout_unlock:\n\tmutex_unlock(&wq->mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "queue_work",
          "args": [
            "wq",
            "&cycles[n].work"
          ],
          "line": 345
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_stop_queue_work",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/stop_machine.c",
          "lines": "93-113",
          "snippet": "static bool cpu_stop_queue_work(unsigned int cpu, struct cpu_stop_work *work)\n{\n\tstruct cpu_stopper *stopper = &per_cpu(cpu_stopper, cpu);\n\tDEFINE_WAKE_Q(wakeq);\n\tunsigned long flags;\n\tbool enabled;\n\n\tpreempt_disable();\n\traw_spin_lock_irqsave(&stopper->lock, flags);\n\tenabled = stopper->enabled;\n\tif (enabled)\n\t\t__cpu_stop_queue_work(stopper, work, &wakeq);\n\telse if (work->done)\n\t\tcpu_stop_signal_done(work->done);\n\traw_spin_unlock_irqrestore(&stopper->lock, flags);\n\n\twake_up_q(&wakeq);\n\tpreempt_enable();\n\n\treturn enabled;\n}",
          "includes": [
            "#include <linux/sched/wake_q.h>",
            "#include <linux/nmi.h>",
            "#include <linux/atomic.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/sched.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/kthread.h>",
            "#include <linux/init.h>",
            "#include <linux/cpu.h>",
            "#include <linux/completion.h>",
            "#include <linux/compiler.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct cpu_stopper, cpu_stopper);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/wake_q.h>\n#include <linux/nmi.h>\n#include <linux/atomic.h>\n#include <linux/smpboot.h>\n#include <linux/kallsyms.h>\n#include <linux/interrupt.h>\n#include <linux/stop_machine.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kthread.h>\n#include <linux/init.h>\n#include <linux/cpu.h>\n#include <linux/completion.h>\n#include <linux/compiler.h>\n\nstatic DEFINE_PER_CPU(struct cpu_stopper, cpu_stopper);\n\nstatic bool cpu_stop_queue_work(unsigned int cpu, struct cpu_stop_work *work)\n{\n\tstruct cpu_stopper *stopper = &per_cpu(cpu_stopper, cpu);\n\tDEFINE_WAKE_Q(wakeq);\n\tunsigned long flags;\n\tbool enabled;\n\n\tpreempt_disable();\n\traw_spin_lock_irqsave(&stopper->lock, flags);\n\tenabled = stopper->enabled;\n\tif (enabled)\n\t\t__cpu_stop_queue_work(stopper, work, &wakeq);\n\telse if (work->done)\n\t\tcpu_stop_signal_done(work->done);\n\traw_spin_unlock_irqrestore(&stopper->lock, flags);\n\n\twake_up_q(&wakeq);\n\tpreempt_enable();\n\n\treturn enabled;\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_WORK",
          "args": [
            "&cycle->work",
            "test_cycle_work"
          ],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_completion",
          "args": [
            "&cycle->b_signal"
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ww_mutex_init",
          "args": [
            "&cycle->a_mutex",
            "&ww_class"
          ],
          "line": 328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc_array",
          "args": [
            "nthreads",
            "sizeof(*cycles)",
            "GFP_KERNEL"
          ],
          "line": 321
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ww_mutex.h>\n#include <linux/slab.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/completion.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_WD_CLASS(ww_class);\nstruct workqueue_struct *wq;\n\nstatic int __test_cycle(unsigned int nthreads)\n{\n\tstruct test_cycle *cycles;\n\tunsigned int n, last = nthreads - 1;\n\tint ret;\n\n\tcycles = kmalloc_array(nthreads, sizeof(*cycles), GFP_KERNEL);\n\tif (!cycles)\n\t\treturn -ENOMEM;\n\n\tfor (n = 0; n < nthreads; n++) {\n\t\tstruct test_cycle *cycle = &cycles[n];\n\n\t\tww_mutex_init(&cycle->a_mutex, &ww_class);\n\t\tif (n == last)\n\t\t\tcycle->b_mutex = &cycles[0].a_mutex;\n\t\telse\n\t\t\tcycle->b_mutex = &cycles[n + 1].a_mutex;\n\n\t\tif (n == 0)\n\t\t\tcycle->a_signal = &cycles[last].b_signal;\n\t\telse\n\t\t\tcycle->a_signal = &cycles[n - 1].b_signal;\n\t\tinit_completion(&cycle->b_signal);\n\n\t\tINIT_WORK(&cycle->work, test_cycle_work);\n\t\tcycle->result = 0;\n\t}\n\n\tfor (n = 0; n < nthreads; n++)\n\t\tqueue_work(wq, &cycles[n].work);\n\n\tflush_workqueue(wq);\n\n\tret = 0;\n\tfor (n = 0; n < nthreads; n++) {\n\t\tstruct test_cycle *cycle = &cycles[n];\n\n\t\tif (!cycle->result)\n\t\t\tcontinue;\n\n\t\tpr_err(\"cyclic deadlock not resolved, ret[%d/%d] = %d\\n\",\n\t\t       n, nthreads, cycle->result);\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\tfor (n = 0; n < nthreads; n++)\n\t\tww_mutex_destroy(&cycles[n].a_mutex);\n\tkfree(cycles);\n\treturn ret;\n}"
  },
  {
    "function_name": "test_cycle_work",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/test-ww_mutex.c",
    "lines": "286-313",
    "snippet": "static void test_cycle_work(struct work_struct *work)\n{\n\tstruct test_cycle *cycle = container_of(work, typeof(*cycle), work);\n\tstruct ww_acquire_ctx ctx;\n\tint err, erra = 0;\n\n\tww_acquire_init_noinject(&ctx, &ww_class);\n\tww_mutex_lock(&cycle->a_mutex, &ctx);\n\n\tcomplete(cycle->a_signal);\n\twait_for_completion(&cycle->b_signal);\n\n\terr = ww_mutex_lock(cycle->b_mutex, &ctx);\n\tif (err == -EDEADLK) {\n\t\terr = 0;\n\t\tww_mutex_unlock(&cycle->a_mutex);\n\t\tww_mutex_lock_slow(cycle->b_mutex, &ctx);\n\t\terra = ww_mutex_lock(&cycle->a_mutex, &ctx);\n\t}\n\n\tif (!err)\n\t\tww_mutex_unlock(cycle->b_mutex);\n\tif (!erra)\n\t\tww_mutex_unlock(&cycle->a_mutex);\n\tww_acquire_fini(&ctx);\n\n\tcycle->result = err ?: erra;\n}",
    "includes": [
      "#include <linux/ww_mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/completion.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_WD_CLASS(ww_class);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ww_acquire_fini",
          "args": [
            "&ctx"
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ww_mutex_unlock",
          "args": [
            "&cycle->a_mutex"
          ],
          "line": 309
        },
        "resolved": true,
        "details": {
          "function_name": "__ww_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/ww_mutex.h",
          "lines": "559-569",
          "snippet": "static inline void __ww_mutex_unlock(struct ww_mutex *lock)\n{\n\tif (lock->ctx) {\n#ifdef DEBUG_WW_MUTEXES\n\t\tDEBUG_LOCKS_WARN_ON(!lock->ctx->acquired);\n#endif\n\t\tif (lock->ctx->acquired > 0)\n\t\t\tlock->ctx->acquired--;\n\t\tlock->ctx = NULL;\n\t}\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void __ww_mutex_unlock(struct ww_mutex *lock)\n{\n\tif (lock->ctx) {\n#ifdef DEBUG_WW_MUTEXES\n\t\tDEBUG_LOCKS_WARN_ON(!lock->ctx->acquired);\n#endif\n\t\tif (lock->ctx->acquired > 0)\n\t\t\tlock->ctx->acquired--;\n\t\tlock->ctx = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ww_mutex_lock",
          "args": [
            "&cycle->a_mutex",
            "&ctx"
          ],
          "line": 303
        },
        "resolved": true,
        "details": {
          "function_name": "ww_mutex_lock_acquired",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "45-48",
          "snippet": "static inline void ww_mutex_lock_acquired(struct ww_mutex *lock,\n\t\t\t\t\t  struct ww_acquire_ctx *ww_ctx)\n{\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic inline void ww_mutex_lock_acquired(struct ww_mutex *lock,\n\t\t\t\t\t  struct ww_acquire_ctx *ww_ctx)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "ww_mutex_lock_slow",
          "args": [
            "cycle->b_mutex",
            "&ctx"
          ],
          "line": 302
        },
        "resolved": true,
        "details": {
          "function_name": "__ww_mutex_lock_slowpath",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/mutex.c",
          "lines": "1036-1041",
          "snippet": "__sched\n__ww_mutex_lock_slowpath(struct ww_mutex *lock, struct ww_acquire_ctx *ctx)\n{\n\treturn __ww_mutex_lock(&lock->base, TASK_UNINTERRUPTIBLE, 0,\n\t\t\t       _RET_IP_, ctx);\n}",
          "includes": [
            "#include \"ww_mutex.h\"",
            "#include \"mutex.h\"",
            "#include <linux/osq_lock.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/ww_mutex.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ww_mutex.h\"\n#include \"mutex.h\"\n#include <linux/osq_lock.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/ww_mutex.h>\n#include <linux/mutex.h>\n\n__sched\n__ww_mutex_lock_slowpath(struct ww_mutex *lock, struct ww_acquire_ctx *ctx)\n{\n\treturn __ww_mutex_lock(&lock->base, TASK_UNINTERRUPTIBLE, 0,\n\t\t\t       _RET_IP_, ctx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_for_completion",
          "args": [
            "&cycle->b_signal"
          ],
          "line": 296
        },
        "resolved": true,
        "details": {
          "function_name": "try_wait_for_completion",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/completion.c",
          "lines": "282-303",
          "snippet": "bool try_wait_for_completion(struct completion *x)\n{\n\tunsigned long flags;\n\tbool ret = true;\n\n\t/*\n\t * Since x->done will need to be locked only\n\t * in the non-blocking case, we check x->done\n\t * first without taking the lock so we can\n\t * return early in the blocking case.\n\t */\n\tif (!READ_ONCE(x->done))\n\t\treturn false;\n\n\traw_spin_lock_irqsave(&x->wait.lock, flags);\n\tif (!x->done)\n\t\tret = false;\n\telse if (x->done != UINT_MAX)\n\t\tx->done--;\n\traw_spin_unlock_irqrestore(&x->wait.lock, flags);\n\treturn ret;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nbool try_wait_for_completion(struct completion *x)\n{\n\tunsigned long flags;\n\tbool ret = true;\n\n\t/*\n\t * Since x->done will need to be locked only\n\t * in the non-blocking case, we check x->done\n\t * first without taking the lock so we can\n\t * return early in the blocking case.\n\t */\n\tif (!READ_ONCE(x->done))\n\t\treturn false;\n\n\traw_spin_lock_irqsave(&x->wait.lock, flags);\n\tif (!x->done)\n\t\tret = false;\n\telse if (x->done != UINT_MAX)\n\t\tx->done--;\n\traw_spin_unlock_irqrestore(&x->wait.lock, flags);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "complete",
          "args": [
            "cycle->a_signal"
          ],
          "line": 295
        },
        "resolved": true,
        "details": {
          "function_name": "complete_vfork_done",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/fork.c",
          "lines": "1334-1345",
          "snippet": "static void complete_vfork_done(struct task_struct *tsk)\n{\n\tstruct completion *vfork;\n\n\ttask_lock(tsk);\n\tvfork = tsk->vfork_done;\n\tif (likely(vfork)) {\n\t\ttsk->vfork_done = NULL;\n\t\tcomplete(vfork);\n\t}\n\ttask_unlock(tsk);\n}",
          "includes": [
            "#include <linux/init_task.h>",
            "#include <trace/events/task.h>",
            "#include <trace/events/sched.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <linux/bpf.h>",
            "#include <linux/io_uring.h>",
            "#include <linux/scs.h>",
            "#include <linux/kasan.h>",
            "#include <linux/stackleak.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/kcov.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/compiler.h>",
            "#include <linux/aio.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/oom.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/magic.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/tty.h>",
            "#include <linux/random.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/acct.h>",
            "#include <linux/ksm.h>",
            "#include <linux/rmap.h>",
            "#include <linux/profile.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/kthread.h>",
            "#include <linux/compat.h>",
            "#include <linux/futex.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mman.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/sem.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>",
            "#include <linux/unistd.h>",
            "#include <linux/init.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/anon_inodes.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __latent_entropy struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/init_task.h>\n#include <trace/events/task.h>\n#include <trace/events/sched.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <linux/bpf.h>\n#include <linux/io_uring.h>\n#include <linux/scs.h>\n#include <linux/kasan.h>\n#include <linux/stackleak.h>\n#include <linux/thread_info.h>\n#include <linux/livepatch.h>\n#include <linux/kcov.h>\n#include <linux/sysctl.h>\n#include <linux/compiler.h>\n#include <linux/aio.h>\n#include <linux/uprobes.h>\n#include <linux/signalfd.h>\n#include <linux/khugepaged.h>\n#include <linux/oom.h>\n#include <linux/user-return-notifier.h>\n#include <linux/posix-timers.h>\n#include <linux/perf_event.h>\n#include <linux/magic.h>\n#include <linux/fs_struct.h>\n#include <linux/tty.h>\n#include <linux/random.h>\n#include <linux/taskstats_kern.h>\n#include <linux/delayacct.h>\n#include <linux/freezer.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/acct.h>\n#include <linux/ksm.h>\n#include <linux/rmap.h>\n#include <linux/profile.h>\n#include <linux/proc_fs.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/ptrace.h>\n#include <linux/rcupdate.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/kthread.h>\n#include <linux/compat.h>\n#include <linux/futex.h>\n#include <linux/jiffies.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/seccomp.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/cgroup.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/nsproxy.h>\n#include <linux/vmacache.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mman.h>\n#include <linux/binfmts.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/sem.h>\n#include <linux/mempolicy.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/unistd.h>\n#include <linux/init.h>\n#include <linux/rtmutex.h>\n#include <linux/seq_file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/user.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/anon_inodes.h>\n\nstatic __latent_entropy struct;\n\nstatic void complete_vfork_done(struct task_struct *tsk)\n{\n\tstruct completion *vfork;\n\n\ttask_lock(tsk);\n\tvfork = tsk->vfork_done;\n\tif (likely(vfork)) {\n\t\ttsk->vfork_done = NULL;\n\t\tcomplete(vfork);\n\t}\n\ttask_unlock(tsk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ww_acquire_init_noinject",
          "args": [
            "&ctx",
            "&ww_class"
          ],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "work",
            "typeof(*cycle)",
            "work"
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "typeof",
          "args": [
            "*cycle"
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ww_mutex.h>\n#include <linux/slab.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/completion.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_WD_CLASS(ww_class);\n\nstatic void test_cycle_work(struct work_struct *work)\n{\n\tstruct test_cycle *cycle = container_of(work, typeof(*cycle), work);\n\tstruct ww_acquire_ctx ctx;\n\tint err, erra = 0;\n\n\tww_acquire_init_noinject(&ctx, &ww_class);\n\tww_mutex_lock(&cycle->a_mutex, &ctx);\n\n\tcomplete(cycle->a_signal);\n\twait_for_completion(&cycle->b_signal);\n\n\terr = ww_mutex_lock(cycle->b_mutex, &ctx);\n\tif (err == -EDEADLK) {\n\t\terr = 0;\n\t\tww_mutex_unlock(&cycle->a_mutex);\n\t\tww_mutex_lock_slow(cycle->b_mutex, &ctx);\n\t\terra = ww_mutex_lock(&cycle->a_mutex, &ctx);\n\t}\n\n\tif (!err)\n\t\tww_mutex_unlock(cycle->b_mutex);\n\tif (!erra)\n\t\tww_mutex_unlock(&cycle->a_mutex);\n\tww_acquire_fini(&ctx);\n\n\tcycle->result = err ?: erra;\n}"
  },
  {
    "function_name": "test_abba",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/test-ww_mutex.c",
    "lines": "218-275",
    "snippet": "static int test_abba(bool trylock, bool resolve)\n{\n\tstruct test_abba abba;\n\tstruct ww_acquire_ctx ctx;\n\tint err, ret;\n\n\tww_mutex_init(&abba.a_mutex, &ww_class);\n\tww_mutex_init(&abba.b_mutex, &ww_class);\n\tINIT_WORK_ONSTACK(&abba.work, test_abba_work);\n\tinit_completion(&abba.a_ready);\n\tinit_completion(&abba.b_ready);\n\tabba.trylock = trylock;\n\tabba.resolve = resolve;\n\n\tschedule_work(&abba.work);\n\n\tww_acquire_init_noinject(&ctx, &ww_class);\n\tif (!trylock)\n\t\tww_mutex_lock(&abba.a_mutex, &ctx);\n\telse\n\t\tWARN_ON(!ww_mutex_trylock(&abba.a_mutex, &ctx));\n\n\tWARN_ON(READ_ONCE(abba.a_mutex.ctx) != &ctx);\n\n\tcomplete(&abba.a_ready);\n\twait_for_completion(&abba.b_ready);\n\n\terr = ww_mutex_lock(&abba.b_mutex, &ctx);\n\tif (resolve && err == -EDEADLK) {\n\t\tww_mutex_unlock(&abba.a_mutex);\n\t\tww_mutex_lock_slow(&abba.b_mutex, &ctx);\n\t\terr = ww_mutex_lock(&abba.a_mutex, &ctx);\n\t}\n\n\tif (!err)\n\t\tww_mutex_unlock(&abba.b_mutex);\n\tww_mutex_unlock(&abba.a_mutex);\n\tww_acquire_fini(&ctx);\n\n\tflush_work(&abba.work);\n\tdestroy_work_on_stack(&abba.work);\n\n\tret = 0;\n\tif (resolve) {\n\t\tif (err || abba.result) {\n\t\t\tpr_err(\"%s: failed to resolve ABBA deadlock, A err=%d, B err=%d\\n\",\n\t\t\t       __func__, err, abba.result);\n\t\t\tret = -EINVAL;\n\t\t}\n\t} else {\n\t\tif (err != -EDEADLK && abba.result != -EDEADLK) {\n\t\t\tpr_err(\"%s: missed ABBA deadlock, A err=%d, B err=%d\\n\",\n\t\t\t       __func__, err, abba.result);\n\t\t\tret = -EINVAL;\n\t\t}\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include <linux/ww_mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/completion.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_WD_CLASS(ww_class);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%s: missed ABBA deadlock, A err=%d, B err=%d\\n\"",
            "__func__",
            "err",
            "abba.result"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%s: failed to resolve ABBA deadlock, A err=%d, B err=%d\\n\"",
            "__func__",
            "err",
            "abba.result"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "destroy_work_on_stack",
          "args": [
            "&abba.work"
          ],
          "line": 258
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_work_on_stack",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "522-525",
          "snippet": "void destroy_work_on_stack(struct work_struct *work)\n{\n\tdebug_object_free(work, &work_debug_descr);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nvoid destroy_work_on_stack(struct work_struct *work)\n{\n\tdebug_object_free(work, &work_debug_descr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "flush_work",
          "args": [
            "&abba.work"
          ],
          "line": 257
        },
        "resolved": true,
        "details": {
          "function_name": "flush_work",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "3112-3115",
          "snippet": "bool flush_work(struct work_struct *work)\n{\n\treturn __flush_work(work, false);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nbool flush_work(struct work_struct *work)\n{\n\treturn __flush_work(work, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ww_acquire_fini",
          "args": [
            "&ctx"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ww_mutex_unlock",
          "args": [
            "&abba.a_mutex"
          ],
          "line": 254
        },
        "resolved": true,
        "details": {
          "function_name": "__ww_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/ww_mutex.h",
          "lines": "559-569",
          "snippet": "static inline void __ww_mutex_unlock(struct ww_mutex *lock)\n{\n\tif (lock->ctx) {\n#ifdef DEBUG_WW_MUTEXES\n\t\tDEBUG_LOCKS_WARN_ON(!lock->ctx->acquired);\n#endif\n\t\tif (lock->ctx->acquired > 0)\n\t\t\tlock->ctx->acquired--;\n\t\tlock->ctx = NULL;\n\t}\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void __ww_mutex_unlock(struct ww_mutex *lock)\n{\n\tif (lock->ctx) {\n#ifdef DEBUG_WW_MUTEXES\n\t\tDEBUG_LOCKS_WARN_ON(!lock->ctx->acquired);\n#endif\n\t\tif (lock->ctx->acquired > 0)\n\t\t\tlock->ctx->acquired--;\n\t\tlock->ctx = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ww_mutex_lock",
          "args": [
            "&abba.a_mutex",
            "&ctx"
          ],
          "line": 249
        },
        "resolved": true,
        "details": {
          "function_name": "ww_mutex_lock_acquired",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "45-48",
          "snippet": "static inline void ww_mutex_lock_acquired(struct ww_mutex *lock,\n\t\t\t\t\t  struct ww_acquire_ctx *ww_ctx)\n{\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic inline void ww_mutex_lock_acquired(struct ww_mutex *lock,\n\t\t\t\t\t  struct ww_acquire_ctx *ww_ctx)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "ww_mutex_lock_slow",
          "args": [
            "&abba.b_mutex",
            "&ctx"
          ],
          "line": 248
        },
        "resolved": true,
        "details": {
          "function_name": "__ww_mutex_lock_slowpath",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/mutex.c",
          "lines": "1036-1041",
          "snippet": "__sched\n__ww_mutex_lock_slowpath(struct ww_mutex *lock, struct ww_acquire_ctx *ctx)\n{\n\treturn __ww_mutex_lock(&lock->base, TASK_UNINTERRUPTIBLE, 0,\n\t\t\t       _RET_IP_, ctx);\n}",
          "includes": [
            "#include \"ww_mutex.h\"",
            "#include \"mutex.h\"",
            "#include <linux/osq_lock.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/ww_mutex.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ww_mutex.h\"\n#include \"mutex.h\"\n#include <linux/osq_lock.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/ww_mutex.h>\n#include <linux/mutex.h>\n\n__sched\n__ww_mutex_lock_slowpath(struct ww_mutex *lock, struct ww_acquire_ctx *ctx)\n{\n\treturn __ww_mutex_lock(&lock->base, TASK_UNINTERRUPTIBLE, 0,\n\t\t\t       _RET_IP_, ctx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_for_completion",
          "args": [
            "&abba.b_ready"
          ],
          "line": 243
        },
        "resolved": true,
        "details": {
          "function_name": "try_wait_for_completion",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/completion.c",
          "lines": "282-303",
          "snippet": "bool try_wait_for_completion(struct completion *x)\n{\n\tunsigned long flags;\n\tbool ret = true;\n\n\t/*\n\t * Since x->done will need to be locked only\n\t * in the non-blocking case, we check x->done\n\t * first without taking the lock so we can\n\t * return early in the blocking case.\n\t */\n\tif (!READ_ONCE(x->done))\n\t\treturn false;\n\n\traw_spin_lock_irqsave(&x->wait.lock, flags);\n\tif (!x->done)\n\t\tret = false;\n\telse if (x->done != UINT_MAX)\n\t\tx->done--;\n\traw_spin_unlock_irqrestore(&x->wait.lock, flags);\n\treturn ret;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nbool try_wait_for_completion(struct completion *x)\n{\n\tunsigned long flags;\n\tbool ret = true;\n\n\t/*\n\t * Since x->done will need to be locked only\n\t * in the non-blocking case, we check x->done\n\t * first without taking the lock so we can\n\t * return early in the blocking case.\n\t */\n\tif (!READ_ONCE(x->done))\n\t\treturn false;\n\n\traw_spin_lock_irqsave(&x->wait.lock, flags);\n\tif (!x->done)\n\t\tret = false;\n\telse if (x->done != UINT_MAX)\n\t\tx->done--;\n\traw_spin_unlock_irqrestore(&x->wait.lock, flags);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "complete",
          "args": [
            "&abba.a_ready"
          ],
          "line": 242
        },
        "resolved": true,
        "details": {
          "function_name": "complete_vfork_done",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/fork.c",
          "lines": "1334-1345",
          "snippet": "static void complete_vfork_done(struct task_struct *tsk)\n{\n\tstruct completion *vfork;\n\n\ttask_lock(tsk);\n\tvfork = tsk->vfork_done;\n\tif (likely(vfork)) {\n\t\ttsk->vfork_done = NULL;\n\t\tcomplete(vfork);\n\t}\n\ttask_unlock(tsk);\n}",
          "includes": [
            "#include <linux/init_task.h>",
            "#include <trace/events/task.h>",
            "#include <trace/events/sched.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <linux/bpf.h>",
            "#include <linux/io_uring.h>",
            "#include <linux/scs.h>",
            "#include <linux/kasan.h>",
            "#include <linux/stackleak.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/kcov.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/compiler.h>",
            "#include <linux/aio.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/oom.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/magic.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/tty.h>",
            "#include <linux/random.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/acct.h>",
            "#include <linux/ksm.h>",
            "#include <linux/rmap.h>",
            "#include <linux/profile.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/kthread.h>",
            "#include <linux/compat.h>",
            "#include <linux/futex.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mman.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/sem.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>",
            "#include <linux/unistd.h>",
            "#include <linux/init.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/anon_inodes.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __latent_entropy struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/init_task.h>\n#include <trace/events/task.h>\n#include <trace/events/sched.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <linux/bpf.h>\n#include <linux/io_uring.h>\n#include <linux/scs.h>\n#include <linux/kasan.h>\n#include <linux/stackleak.h>\n#include <linux/thread_info.h>\n#include <linux/livepatch.h>\n#include <linux/kcov.h>\n#include <linux/sysctl.h>\n#include <linux/compiler.h>\n#include <linux/aio.h>\n#include <linux/uprobes.h>\n#include <linux/signalfd.h>\n#include <linux/khugepaged.h>\n#include <linux/oom.h>\n#include <linux/user-return-notifier.h>\n#include <linux/posix-timers.h>\n#include <linux/perf_event.h>\n#include <linux/magic.h>\n#include <linux/fs_struct.h>\n#include <linux/tty.h>\n#include <linux/random.h>\n#include <linux/taskstats_kern.h>\n#include <linux/delayacct.h>\n#include <linux/freezer.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/acct.h>\n#include <linux/ksm.h>\n#include <linux/rmap.h>\n#include <linux/profile.h>\n#include <linux/proc_fs.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/ptrace.h>\n#include <linux/rcupdate.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/kthread.h>\n#include <linux/compat.h>\n#include <linux/futex.h>\n#include <linux/jiffies.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/seccomp.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/cgroup.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/nsproxy.h>\n#include <linux/vmacache.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mman.h>\n#include <linux/binfmts.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/sem.h>\n#include <linux/mempolicy.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/unistd.h>\n#include <linux/init.h>\n#include <linux/rtmutex.h>\n#include <linux/seq_file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/user.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/anon_inodes.h>\n\nstatic __latent_entropy struct;\n\nstatic void complete_vfork_done(struct task_struct *tsk)\n{\n\tstruct completion *vfork;\n\n\ttask_lock(tsk);\n\tvfork = tsk->vfork_done;\n\tif (likely(vfork)) {\n\t\ttsk->vfork_done = NULL;\n\t\tcomplete(vfork);\n\t}\n\ttask_unlock(tsk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "READ_ONCE(abba.a_mutex.ctx) != &ctx"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "abba.a_mutex.ctx"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!ww_mutex_trylock(&abba.a_mutex, &ctx)"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ww_mutex_trylock",
          "args": [
            "&abba.a_mutex",
            "&ctx"
          ],
          "line": 238
        },
        "resolved": true,
        "details": {
          "function_name": "ww_mutex_trylock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/ww_rt_mutex.c",
          "lines": "12-34",
          "snippet": "int ww_mutex_trylock(struct ww_mutex *lock, struct ww_acquire_ctx *ww_ctx)\n{\n\tstruct rt_mutex *rtm = &lock->base;\n\n\tif (!ww_ctx)\n\t\treturn rt_mutex_trylock(rtm);\n\n\t/*\n\t * Reset the wounded flag after a kill. No other process can\n\t * race and wound us here, since they can't have a valid owner\n\t * pointer if we don't have any locks held.\n\t */\n\tif (ww_ctx->acquired == 0)\n\t\tww_ctx->wounded = 0;\n\n\tif (__rt_mutex_trylock(&rtm->rtmutex)) {\n\t\tww_mutex_set_context_fastpath(lock, ww_ctx);\n\t\tmutex_acquire_nest(&rtm->dep_map, 0, 1, &ww_ctx->dep_map, _RET_IP_);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint ww_mutex_trylock(struct ww_mutex *lock, struct ww_acquire_ctx *ww_ctx)\n{\n\tstruct rt_mutex *rtm = &lock->base;\n\n\tif (!ww_ctx)\n\t\treturn rt_mutex_trylock(rtm);\n\n\t/*\n\t * Reset the wounded flag after a kill. No other process can\n\t * race and wound us here, since they can't have a valid owner\n\t * pointer if we don't have any locks held.\n\t */\n\tif (ww_ctx->acquired == 0)\n\t\tww_ctx->wounded = 0;\n\n\tif (__rt_mutex_trylock(&rtm->rtmutex)) {\n\t\tww_mutex_set_context_fastpath(lock, ww_ctx);\n\t\tmutex_acquire_nest(&rtm->dep_map, 0, 1, &ww_ctx->dep_map, _RET_IP_);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ww_acquire_init_noinject",
          "args": [
            "&ctx",
            "&ww_class"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schedule_work",
          "args": [
            "&abba.work"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_completion",
          "args": [
            "&abba.b_ready"
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_completion",
          "args": [
            "&abba.a_ready"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_WORK_ONSTACK",
          "args": [
            "&abba.work",
            "test_abba_work"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ww_mutex_init",
          "args": [
            "&abba.b_mutex",
            "&ww_class"
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ww_mutex_init",
          "args": [
            "&abba.a_mutex",
            "&ww_class"
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ww_mutex.h>\n#include <linux/slab.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/completion.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_WD_CLASS(ww_class);\n\nstatic int test_abba(bool trylock, bool resolve)\n{\n\tstruct test_abba abba;\n\tstruct ww_acquire_ctx ctx;\n\tint err, ret;\n\n\tww_mutex_init(&abba.a_mutex, &ww_class);\n\tww_mutex_init(&abba.b_mutex, &ww_class);\n\tINIT_WORK_ONSTACK(&abba.work, test_abba_work);\n\tinit_completion(&abba.a_ready);\n\tinit_completion(&abba.b_ready);\n\tabba.trylock = trylock;\n\tabba.resolve = resolve;\n\n\tschedule_work(&abba.work);\n\n\tww_acquire_init_noinject(&ctx, &ww_class);\n\tif (!trylock)\n\t\tww_mutex_lock(&abba.a_mutex, &ctx);\n\telse\n\t\tWARN_ON(!ww_mutex_trylock(&abba.a_mutex, &ctx));\n\n\tWARN_ON(READ_ONCE(abba.a_mutex.ctx) != &ctx);\n\n\tcomplete(&abba.a_ready);\n\twait_for_completion(&abba.b_ready);\n\n\terr = ww_mutex_lock(&abba.b_mutex, &ctx);\n\tif (resolve && err == -EDEADLK) {\n\t\tww_mutex_unlock(&abba.a_mutex);\n\t\tww_mutex_lock_slow(&abba.b_mutex, &ctx);\n\t\terr = ww_mutex_lock(&abba.a_mutex, &ctx);\n\t}\n\n\tif (!err)\n\t\tww_mutex_unlock(&abba.b_mutex);\n\tww_mutex_unlock(&abba.a_mutex);\n\tww_acquire_fini(&ctx);\n\n\tflush_work(&abba.work);\n\tdestroy_work_on_stack(&abba.work);\n\n\tret = 0;\n\tif (resolve) {\n\t\tif (err || abba.result) {\n\t\t\tpr_err(\"%s: failed to resolve ABBA deadlock, A err=%d, B err=%d\\n\",\n\t\t\t       __func__, err, abba.result);\n\t\t\tret = -EINVAL;\n\t\t}\n\t} else {\n\t\tif (err != -EDEADLK && abba.result != -EDEADLK) {\n\t\t\tpr_err(\"%s: missed ABBA deadlock, A err=%d, B err=%d\\n\",\n\t\t\t       __func__, err, abba.result);\n\t\t\tret = -EINVAL;\n\t\t}\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "test_abba_work",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/test-ww_mutex.c",
    "lines": "186-216",
    "snippet": "static void test_abba_work(struct work_struct *work)\n{\n\tstruct test_abba *abba = container_of(work, typeof(*abba), work);\n\tstruct ww_acquire_ctx ctx;\n\tint err;\n\n\tww_acquire_init_noinject(&ctx, &ww_class);\n\tif (!abba->trylock)\n\t\tww_mutex_lock(&abba->b_mutex, &ctx);\n\telse\n\t\tWARN_ON(!ww_mutex_trylock(&abba->b_mutex, &ctx));\n\n\tWARN_ON(READ_ONCE(abba->b_mutex.ctx) != &ctx);\n\n\tcomplete(&abba->b_ready);\n\twait_for_completion(&abba->a_ready);\n\n\terr = ww_mutex_lock(&abba->a_mutex, &ctx);\n\tif (abba->resolve && err == -EDEADLK) {\n\t\tww_mutex_unlock(&abba->b_mutex);\n\t\tww_mutex_lock_slow(&abba->a_mutex, &ctx);\n\t\terr = ww_mutex_lock(&abba->b_mutex, &ctx);\n\t}\n\n\tif (!err)\n\t\tww_mutex_unlock(&abba->a_mutex);\n\tww_mutex_unlock(&abba->b_mutex);\n\tww_acquire_fini(&ctx);\n\n\tabba->result = err;\n}",
    "includes": [
      "#include <linux/ww_mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/completion.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_WD_CLASS(ww_class);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ww_acquire_fini",
          "args": [
            "&ctx"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ww_mutex_unlock",
          "args": [
            "&abba->b_mutex"
          ],
          "line": 212
        },
        "resolved": true,
        "details": {
          "function_name": "__ww_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/ww_mutex.h",
          "lines": "559-569",
          "snippet": "static inline void __ww_mutex_unlock(struct ww_mutex *lock)\n{\n\tif (lock->ctx) {\n#ifdef DEBUG_WW_MUTEXES\n\t\tDEBUG_LOCKS_WARN_ON(!lock->ctx->acquired);\n#endif\n\t\tif (lock->ctx->acquired > 0)\n\t\t\tlock->ctx->acquired--;\n\t\tlock->ctx = NULL;\n\t}\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void __ww_mutex_unlock(struct ww_mutex *lock)\n{\n\tif (lock->ctx) {\n#ifdef DEBUG_WW_MUTEXES\n\t\tDEBUG_LOCKS_WARN_ON(!lock->ctx->acquired);\n#endif\n\t\tif (lock->ctx->acquired > 0)\n\t\t\tlock->ctx->acquired--;\n\t\tlock->ctx = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ww_mutex_lock",
          "args": [
            "&abba->b_mutex",
            "&ctx"
          ],
          "line": 207
        },
        "resolved": true,
        "details": {
          "function_name": "ww_mutex_lock_acquired",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "45-48",
          "snippet": "static inline void ww_mutex_lock_acquired(struct ww_mutex *lock,\n\t\t\t\t\t  struct ww_acquire_ctx *ww_ctx)\n{\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic inline void ww_mutex_lock_acquired(struct ww_mutex *lock,\n\t\t\t\t\t  struct ww_acquire_ctx *ww_ctx)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "ww_mutex_lock_slow",
          "args": [
            "&abba->a_mutex",
            "&ctx"
          ],
          "line": 206
        },
        "resolved": true,
        "details": {
          "function_name": "__ww_mutex_lock_slowpath",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/mutex.c",
          "lines": "1036-1041",
          "snippet": "__sched\n__ww_mutex_lock_slowpath(struct ww_mutex *lock, struct ww_acquire_ctx *ctx)\n{\n\treturn __ww_mutex_lock(&lock->base, TASK_UNINTERRUPTIBLE, 0,\n\t\t\t       _RET_IP_, ctx);\n}",
          "includes": [
            "#include \"ww_mutex.h\"",
            "#include \"mutex.h\"",
            "#include <linux/osq_lock.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/ww_mutex.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ww_mutex.h\"\n#include \"mutex.h\"\n#include <linux/osq_lock.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/ww_mutex.h>\n#include <linux/mutex.h>\n\n__sched\n__ww_mutex_lock_slowpath(struct ww_mutex *lock, struct ww_acquire_ctx *ctx)\n{\n\treturn __ww_mutex_lock(&lock->base, TASK_UNINTERRUPTIBLE, 0,\n\t\t\t       _RET_IP_, ctx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_for_completion",
          "args": [
            "&abba->a_ready"
          ],
          "line": 201
        },
        "resolved": true,
        "details": {
          "function_name": "try_wait_for_completion",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/completion.c",
          "lines": "282-303",
          "snippet": "bool try_wait_for_completion(struct completion *x)\n{\n\tunsigned long flags;\n\tbool ret = true;\n\n\t/*\n\t * Since x->done will need to be locked only\n\t * in the non-blocking case, we check x->done\n\t * first without taking the lock so we can\n\t * return early in the blocking case.\n\t */\n\tif (!READ_ONCE(x->done))\n\t\treturn false;\n\n\traw_spin_lock_irqsave(&x->wait.lock, flags);\n\tif (!x->done)\n\t\tret = false;\n\telse if (x->done != UINT_MAX)\n\t\tx->done--;\n\traw_spin_unlock_irqrestore(&x->wait.lock, flags);\n\treturn ret;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nbool try_wait_for_completion(struct completion *x)\n{\n\tunsigned long flags;\n\tbool ret = true;\n\n\t/*\n\t * Since x->done will need to be locked only\n\t * in the non-blocking case, we check x->done\n\t * first without taking the lock so we can\n\t * return early in the blocking case.\n\t */\n\tif (!READ_ONCE(x->done))\n\t\treturn false;\n\n\traw_spin_lock_irqsave(&x->wait.lock, flags);\n\tif (!x->done)\n\t\tret = false;\n\telse if (x->done != UINT_MAX)\n\t\tx->done--;\n\traw_spin_unlock_irqrestore(&x->wait.lock, flags);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "complete",
          "args": [
            "&abba->b_ready"
          ],
          "line": 200
        },
        "resolved": true,
        "details": {
          "function_name": "complete_vfork_done",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/fork.c",
          "lines": "1334-1345",
          "snippet": "static void complete_vfork_done(struct task_struct *tsk)\n{\n\tstruct completion *vfork;\n\n\ttask_lock(tsk);\n\tvfork = tsk->vfork_done;\n\tif (likely(vfork)) {\n\t\ttsk->vfork_done = NULL;\n\t\tcomplete(vfork);\n\t}\n\ttask_unlock(tsk);\n}",
          "includes": [
            "#include <linux/init_task.h>",
            "#include <trace/events/task.h>",
            "#include <trace/events/sched.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <linux/bpf.h>",
            "#include <linux/io_uring.h>",
            "#include <linux/scs.h>",
            "#include <linux/kasan.h>",
            "#include <linux/stackleak.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/kcov.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/compiler.h>",
            "#include <linux/aio.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/oom.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/magic.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/tty.h>",
            "#include <linux/random.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/acct.h>",
            "#include <linux/ksm.h>",
            "#include <linux/rmap.h>",
            "#include <linux/profile.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/kthread.h>",
            "#include <linux/compat.h>",
            "#include <linux/futex.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mman.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/sem.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>",
            "#include <linux/unistd.h>",
            "#include <linux/init.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/anon_inodes.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __latent_entropy struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/init_task.h>\n#include <trace/events/task.h>\n#include <trace/events/sched.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <linux/bpf.h>\n#include <linux/io_uring.h>\n#include <linux/scs.h>\n#include <linux/kasan.h>\n#include <linux/stackleak.h>\n#include <linux/thread_info.h>\n#include <linux/livepatch.h>\n#include <linux/kcov.h>\n#include <linux/sysctl.h>\n#include <linux/compiler.h>\n#include <linux/aio.h>\n#include <linux/uprobes.h>\n#include <linux/signalfd.h>\n#include <linux/khugepaged.h>\n#include <linux/oom.h>\n#include <linux/user-return-notifier.h>\n#include <linux/posix-timers.h>\n#include <linux/perf_event.h>\n#include <linux/magic.h>\n#include <linux/fs_struct.h>\n#include <linux/tty.h>\n#include <linux/random.h>\n#include <linux/taskstats_kern.h>\n#include <linux/delayacct.h>\n#include <linux/freezer.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/acct.h>\n#include <linux/ksm.h>\n#include <linux/rmap.h>\n#include <linux/profile.h>\n#include <linux/proc_fs.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/ptrace.h>\n#include <linux/rcupdate.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/kthread.h>\n#include <linux/compat.h>\n#include <linux/futex.h>\n#include <linux/jiffies.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/seccomp.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/cgroup.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/nsproxy.h>\n#include <linux/vmacache.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mman.h>\n#include <linux/binfmts.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/sem.h>\n#include <linux/mempolicy.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/unistd.h>\n#include <linux/init.h>\n#include <linux/rtmutex.h>\n#include <linux/seq_file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/user.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/anon_inodes.h>\n\nstatic __latent_entropy struct;\n\nstatic void complete_vfork_done(struct task_struct *tsk)\n{\n\tstruct completion *vfork;\n\n\ttask_lock(tsk);\n\tvfork = tsk->vfork_done;\n\tif (likely(vfork)) {\n\t\ttsk->vfork_done = NULL;\n\t\tcomplete(vfork);\n\t}\n\ttask_unlock(tsk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "READ_ONCE(abba->b_mutex.ctx) != &ctx"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "abba->b_mutex.ctx"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!ww_mutex_trylock(&abba->b_mutex, &ctx)"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ww_mutex_trylock",
          "args": [
            "&abba->b_mutex",
            "&ctx"
          ],
          "line": 196
        },
        "resolved": true,
        "details": {
          "function_name": "ww_mutex_trylock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/ww_rt_mutex.c",
          "lines": "12-34",
          "snippet": "int ww_mutex_trylock(struct ww_mutex *lock, struct ww_acquire_ctx *ww_ctx)\n{\n\tstruct rt_mutex *rtm = &lock->base;\n\n\tif (!ww_ctx)\n\t\treturn rt_mutex_trylock(rtm);\n\n\t/*\n\t * Reset the wounded flag after a kill. No other process can\n\t * race and wound us here, since they can't have a valid owner\n\t * pointer if we don't have any locks held.\n\t */\n\tif (ww_ctx->acquired == 0)\n\t\tww_ctx->wounded = 0;\n\n\tif (__rt_mutex_trylock(&rtm->rtmutex)) {\n\t\tww_mutex_set_context_fastpath(lock, ww_ctx);\n\t\tmutex_acquire_nest(&rtm->dep_map, 0, 1, &ww_ctx->dep_map, _RET_IP_);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint ww_mutex_trylock(struct ww_mutex *lock, struct ww_acquire_ctx *ww_ctx)\n{\n\tstruct rt_mutex *rtm = &lock->base;\n\n\tif (!ww_ctx)\n\t\treturn rt_mutex_trylock(rtm);\n\n\t/*\n\t * Reset the wounded flag after a kill. No other process can\n\t * race and wound us here, since they can't have a valid owner\n\t * pointer if we don't have any locks held.\n\t */\n\tif (ww_ctx->acquired == 0)\n\t\tww_ctx->wounded = 0;\n\n\tif (__rt_mutex_trylock(&rtm->rtmutex)) {\n\t\tww_mutex_set_context_fastpath(lock, ww_ctx);\n\t\tmutex_acquire_nest(&rtm->dep_map, 0, 1, &ww_ctx->dep_map, _RET_IP_);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ww_acquire_init_noinject",
          "args": [
            "&ctx",
            "&ww_class"
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "work",
            "typeof(*abba)",
            "work"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "typeof",
          "args": [
            "*abba"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ww_mutex.h>\n#include <linux/slab.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/completion.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_WD_CLASS(ww_class);\n\nstatic void test_abba_work(struct work_struct *work)\n{\n\tstruct test_abba *abba = container_of(work, typeof(*abba), work);\n\tstruct ww_acquire_ctx ctx;\n\tint err;\n\n\tww_acquire_init_noinject(&ctx, &ww_class);\n\tif (!abba->trylock)\n\t\tww_mutex_lock(&abba->b_mutex, &ctx);\n\telse\n\t\tWARN_ON(!ww_mutex_trylock(&abba->b_mutex, &ctx));\n\n\tWARN_ON(READ_ONCE(abba->b_mutex.ctx) != &ctx);\n\n\tcomplete(&abba->b_ready);\n\twait_for_completion(&abba->a_ready);\n\n\terr = ww_mutex_lock(&abba->a_mutex, &ctx);\n\tif (abba->resolve && err == -EDEADLK) {\n\t\tww_mutex_unlock(&abba->b_mutex);\n\t\tww_mutex_lock_slow(&abba->a_mutex, &ctx);\n\t\terr = ww_mutex_lock(&abba->b_mutex, &ctx);\n\t}\n\n\tif (!err)\n\t\tww_mutex_unlock(&abba->a_mutex);\n\tww_mutex_unlock(&abba->b_mutex);\n\tww_acquire_fini(&ctx);\n\n\tabba->result = err;\n}"
  },
  {
    "function_name": "test_aa",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/test-ww_mutex.c",
    "lines": "121-174",
    "snippet": "static int test_aa(bool trylock)\n{\n\tstruct ww_mutex mutex;\n\tstruct ww_acquire_ctx ctx;\n\tint ret;\n\tconst char *from = trylock ? \"trylock\" : \"lock\";\n\n\tww_mutex_init(&mutex, &ww_class);\n\tww_acquire_init(&ctx, &ww_class);\n\n\tif (!trylock) {\n\t\tret = ww_mutex_lock(&mutex, &ctx);\n\t\tif (ret) {\n\t\t\tpr_err(\"%s: initial lock failed!\\n\", __func__);\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\tret = !ww_mutex_trylock(&mutex, &ctx);\n\t\tif (ret) {\n\t\t\tpr_err(\"%s: initial trylock failed!\\n\", __func__);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (ww_mutex_trylock(&mutex, NULL))  {\n\t\tpr_err(\"%s: trylocked itself without context from %s!\\n\", __func__, from);\n\t\tww_mutex_unlock(&mutex);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (ww_mutex_trylock(&mutex, &ctx))  {\n\t\tpr_err(\"%s: trylocked itself with context from %s!\\n\", __func__, from);\n\t\tww_mutex_unlock(&mutex);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tret = ww_mutex_lock(&mutex, &ctx);\n\tif (ret != -EALREADY) {\n\t\tpr_err(\"%s: missed deadlock for recursing, ret=%d from %s\\n\",\n\t\t       __func__, ret, from);\n\t\tif (!ret)\n\t\t\tww_mutex_unlock(&mutex);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tww_mutex_unlock(&mutex);\n\tret = 0;\nout:\n\tww_acquire_fini(&ctx);\n\treturn ret;\n}",
    "includes": [
      "#include <linux/ww_mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/completion.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_WD_CLASS(ww_class);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ww_acquire_fini",
          "args": [
            "&ctx"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ww_mutex_unlock",
          "args": [
            "&mutex"
          ],
          "line": 169
        },
        "resolved": true,
        "details": {
          "function_name": "__ww_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/ww_mutex.h",
          "lines": "559-569",
          "snippet": "static inline void __ww_mutex_unlock(struct ww_mutex *lock)\n{\n\tif (lock->ctx) {\n#ifdef DEBUG_WW_MUTEXES\n\t\tDEBUG_LOCKS_WARN_ON(!lock->ctx->acquired);\n#endif\n\t\tif (lock->ctx->acquired > 0)\n\t\t\tlock->ctx->acquired--;\n\t\tlock->ctx = NULL;\n\t}\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void __ww_mutex_unlock(struct ww_mutex *lock)\n{\n\tif (lock->ctx) {\n#ifdef DEBUG_WW_MUTEXES\n\t\tDEBUG_LOCKS_WARN_ON(!lock->ctx->acquired);\n#endif\n\t\tif (lock->ctx->acquired > 0)\n\t\t\tlock->ctx->acquired--;\n\t\tlock->ctx = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%s: missed deadlock for recursing, ret=%d from %s\\n\"",
            "__func__",
            "ret",
            "from"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ww_mutex_lock",
          "args": [
            "&mutex",
            "&ctx"
          ],
          "line": 159
        },
        "resolved": true,
        "details": {
          "function_name": "ww_mutex_lock_acquired",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "45-48",
          "snippet": "static inline void ww_mutex_lock_acquired(struct ww_mutex *lock,\n\t\t\t\t\t  struct ww_acquire_ctx *ww_ctx)\n{\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic inline void ww_mutex_lock_acquired(struct ww_mutex *lock,\n\t\t\t\t\t  struct ww_acquire_ctx *ww_ctx)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%s: trylocked itself with context from %s!\\n\"",
            "__func__",
            "from"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ww_mutex_trylock",
          "args": [
            "&mutex",
            "&ctx"
          ],
          "line": 152
        },
        "resolved": true,
        "details": {
          "function_name": "ww_mutex_trylock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/ww_rt_mutex.c",
          "lines": "12-34",
          "snippet": "int ww_mutex_trylock(struct ww_mutex *lock, struct ww_acquire_ctx *ww_ctx)\n{\n\tstruct rt_mutex *rtm = &lock->base;\n\n\tif (!ww_ctx)\n\t\treturn rt_mutex_trylock(rtm);\n\n\t/*\n\t * Reset the wounded flag after a kill. No other process can\n\t * race and wound us here, since they can't have a valid owner\n\t * pointer if we don't have any locks held.\n\t */\n\tif (ww_ctx->acquired == 0)\n\t\tww_ctx->wounded = 0;\n\n\tif (__rt_mutex_trylock(&rtm->rtmutex)) {\n\t\tww_mutex_set_context_fastpath(lock, ww_ctx);\n\t\tmutex_acquire_nest(&rtm->dep_map, 0, 1, &ww_ctx->dep_map, _RET_IP_);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint ww_mutex_trylock(struct ww_mutex *lock, struct ww_acquire_ctx *ww_ctx)\n{\n\tstruct rt_mutex *rtm = &lock->base;\n\n\tif (!ww_ctx)\n\t\treturn rt_mutex_trylock(rtm);\n\n\t/*\n\t * Reset the wounded flag after a kill. No other process can\n\t * race and wound us here, since they can't have a valid owner\n\t * pointer if we don't have any locks held.\n\t */\n\tif (ww_ctx->acquired == 0)\n\t\tww_ctx->wounded = 0;\n\n\tif (__rt_mutex_trylock(&rtm->rtmutex)) {\n\t\tww_mutex_set_context_fastpath(lock, ww_ctx);\n\t\tmutex_acquire_nest(&rtm->dep_map, 0, 1, &ww_ctx->dep_map, _RET_IP_);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%s: trylocked itself without context from %s!\\n\"",
            "__func__",
            "from"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%s: initial trylock failed!\\n\"",
            "__func__"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%s: initial lock failed!\\n\"",
            "__func__"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ww_acquire_init",
          "args": [
            "&ctx",
            "&ww_class"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ww_mutex_init",
          "args": [
            "&mutex",
            "&ww_class"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ww_mutex.h>\n#include <linux/slab.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/completion.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_WD_CLASS(ww_class);\n\nstatic int test_aa(bool trylock)\n{\n\tstruct ww_mutex mutex;\n\tstruct ww_acquire_ctx ctx;\n\tint ret;\n\tconst char *from = trylock ? \"trylock\" : \"lock\";\n\n\tww_mutex_init(&mutex, &ww_class);\n\tww_acquire_init(&ctx, &ww_class);\n\n\tif (!trylock) {\n\t\tret = ww_mutex_lock(&mutex, &ctx);\n\t\tif (ret) {\n\t\t\tpr_err(\"%s: initial lock failed!\\n\", __func__);\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\tret = !ww_mutex_trylock(&mutex, &ctx);\n\t\tif (ret) {\n\t\t\tpr_err(\"%s: initial trylock failed!\\n\", __func__);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (ww_mutex_trylock(&mutex, NULL))  {\n\t\tpr_err(\"%s: trylocked itself without context from %s!\\n\", __func__, from);\n\t\tww_mutex_unlock(&mutex);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (ww_mutex_trylock(&mutex, &ctx))  {\n\t\tpr_err(\"%s: trylocked itself with context from %s!\\n\", __func__, from);\n\t\tww_mutex_unlock(&mutex);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tret = ww_mutex_lock(&mutex, &ctx);\n\tif (ret != -EALREADY) {\n\t\tpr_err(\"%s: missed deadlock for recursing, ret=%d from %s\\n\",\n\t\t       __func__, ret, from);\n\t\tif (!ret)\n\t\t\tww_mutex_unlock(&mutex);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tww_mutex_unlock(&mutex);\n\tret = 0;\nout:\n\tww_acquire_fini(&ctx);\n\treturn ret;\n}"
  },
  {
    "function_name": "test_mutex",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/test-ww_mutex.c",
    "lines": "107-119",
    "snippet": "static int test_mutex(void)\n{\n\tint ret;\n\tint i;\n\n\tfor (i = 0; i < __TEST_MTX_LAST; i++) {\n\t\tret = __test_mutex(i);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/ww_mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/completion.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define __TEST_MTX_LAST BIT(3)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__test_mutex",
          "args": [
            "i"
          ],
          "line": 113
        },
        "resolved": true,
        "details": {
          "function_name": "__test_mutex",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/test-ww_mutex.c",
          "lines": "57-105",
          "snippet": "static int __test_mutex(unsigned int flags)\n{\n#define TIMEOUT (HZ / 16)\n\tstruct test_mutex mtx;\n\tstruct ww_acquire_ctx ctx;\n\tint ret;\n\n\tww_mutex_init(&mtx.mutex, &ww_class);\n\tww_acquire_init(&ctx, &ww_class);\n\n\tINIT_WORK_ONSTACK(&mtx.work, test_mutex_work);\n\tinit_completion(&mtx.ready);\n\tinit_completion(&mtx.go);\n\tinit_completion(&mtx.done);\n\tmtx.flags = flags;\n\n\tschedule_work(&mtx.work);\n\n\twait_for_completion(&mtx.ready);\n\tww_mutex_lock(&mtx.mutex, (flags & TEST_MTX_CTX) ? &ctx : NULL);\n\tcomplete(&mtx.go);\n\tif (flags & TEST_MTX_SPIN) {\n\t\tunsigned long timeout = jiffies + TIMEOUT;\n\n\t\tret = 0;\n\t\tdo {\n\t\t\tif (completion_done(&mtx.done)) {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcond_resched();\n\t\t} while (time_before(jiffies, timeout));\n\t} else {\n\t\tret = wait_for_completion_timeout(&mtx.done, TIMEOUT);\n\t}\n\tww_mutex_unlock(&mtx.mutex);\n\tww_acquire_fini(&ctx);\n\n\tif (ret) {\n\t\tpr_err(\"%s(flags=%x): mutual exclusion failure\\n\",\n\t\t       __func__, flags);\n\t\tret = -EINVAL;\n\t}\n\n\tflush_work(&mtx.work);\n\tdestroy_work_on_stack(&mtx.work);\n\treturn ret;\n#undef TIMEOUT\n}",
          "includes": [
            "#include <linux/ww_mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/completion.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define TIMEOUT (HZ / 16)",
            "#define TEST_MTX_CTX BIT(2)",
            "#define TEST_MTX_SPIN BIT(0)"
          ],
          "globals_used": [
            "static DEFINE_WD_CLASS(ww_class);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ww_mutex.h>\n#include <linux/slab.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/completion.h>\n#include <linux/kernel.h>\n\n#define TIMEOUT (HZ / 16)\n#define TEST_MTX_CTX BIT(2)\n#define TEST_MTX_SPIN BIT(0)\n\nstatic DEFINE_WD_CLASS(ww_class);\n\nstatic int __test_mutex(unsigned int flags)\n{\n#define TIMEOUT (HZ / 16)\n\tstruct test_mutex mtx;\n\tstruct ww_acquire_ctx ctx;\n\tint ret;\n\n\tww_mutex_init(&mtx.mutex, &ww_class);\n\tww_acquire_init(&ctx, &ww_class);\n\n\tINIT_WORK_ONSTACK(&mtx.work, test_mutex_work);\n\tinit_completion(&mtx.ready);\n\tinit_completion(&mtx.go);\n\tinit_completion(&mtx.done);\n\tmtx.flags = flags;\n\n\tschedule_work(&mtx.work);\n\n\twait_for_completion(&mtx.ready);\n\tww_mutex_lock(&mtx.mutex, (flags & TEST_MTX_CTX) ? &ctx : NULL);\n\tcomplete(&mtx.go);\n\tif (flags & TEST_MTX_SPIN) {\n\t\tunsigned long timeout = jiffies + TIMEOUT;\n\n\t\tret = 0;\n\t\tdo {\n\t\t\tif (completion_done(&mtx.done)) {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcond_resched();\n\t\t} while (time_before(jiffies, timeout));\n\t} else {\n\t\tret = wait_for_completion_timeout(&mtx.done, TIMEOUT);\n\t}\n\tww_mutex_unlock(&mtx.mutex);\n\tww_acquire_fini(&ctx);\n\n\tif (ret) {\n\t\tpr_err(\"%s(flags=%x): mutual exclusion failure\\n\",\n\t\t       __func__, flags);\n\t\tret = -EINVAL;\n\t}\n\n\tflush_work(&mtx.work);\n\tdestroy_work_on_stack(&mtx.work);\n\treturn ret;\n#undef TIMEOUT\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/ww_mutex.h>\n#include <linux/slab.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/completion.h>\n#include <linux/kernel.h>\n\n#define __TEST_MTX_LAST BIT(3)\n\nstatic int test_mutex(void)\n{\n\tint ret;\n\tint i;\n\n\tfor (i = 0; i < __TEST_MTX_LAST; i++) {\n\t\tret = __test_mutex(i);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "__test_mutex",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/test-ww_mutex.c",
    "lines": "57-105",
    "snippet": "static int __test_mutex(unsigned int flags)\n{\n#define TIMEOUT (HZ / 16)\n\tstruct test_mutex mtx;\n\tstruct ww_acquire_ctx ctx;\n\tint ret;\n\n\tww_mutex_init(&mtx.mutex, &ww_class);\n\tww_acquire_init(&ctx, &ww_class);\n\n\tINIT_WORK_ONSTACK(&mtx.work, test_mutex_work);\n\tinit_completion(&mtx.ready);\n\tinit_completion(&mtx.go);\n\tinit_completion(&mtx.done);\n\tmtx.flags = flags;\n\n\tschedule_work(&mtx.work);\n\n\twait_for_completion(&mtx.ready);\n\tww_mutex_lock(&mtx.mutex, (flags & TEST_MTX_CTX) ? &ctx : NULL);\n\tcomplete(&mtx.go);\n\tif (flags & TEST_MTX_SPIN) {\n\t\tunsigned long timeout = jiffies + TIMEOUT;\n\n\t\tret = 0;\n\t\tdo {\n\t\t\tif (completion_done(&mtx.done)) {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcond_resched();\n\t\t} while (time_before(jiffies, timeout));\n\t} else {\n\t\tret = wait_for_completion_timeout(&mtx.done, TIMEOUT);\n\t}\n\tww_mutex_unlock(&mtx.mutex);\n\tww_acquire_fini(&ctx);\n\n\tif (ret) {\n\t\tpr_err(\"%s(flags=%x): mutual exclusion failure\\n\",\n\t\t       __func__, flags);\n\t\tret = -EINVAL;\n\t}\n\n\tflush_work(&mtx.work);\n\tdestroy_work_on_stack(&mtx.work);\n\treturn ret;\n#undef TIMEOUT\n}",
    "includes": [
      "#include <linux/ww_mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/completion.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define TIMEOUT (HZ / 16)",
      "#define TEST_MTX_CTX BIT(2)",
      "#define TEST_MTX_SPIN BIT(0)"
    ],
    "globals_used": [
      "static DEFINE_WD_CLASS(ww_class);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "destroy_work_on_stack",
          "args": [
            "&mtx.work"
          ],
          "line": 102
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_work_on_stack",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "522-525",
          "snippet": "void destroy_work_on_stack(struct work_struct *work)\n{\n\tdebug_object_free(work, &work_debug_descr);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nvoid destroy_work_on_stack(struct work_struct *work)\n{\n\tdebug_object_free(work, &work_debug_descr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "flush_work",
          "args": [
            "&mtx.work"
          ],
          "line": 101
        },
        "resolved": true,
        "details": {
          "function_name": "flush_work",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "3112-3115",
          "snippet": "bool flush_work(struct work_struct *work)\n{\n\treturn __flush_work(work, false);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nbool flush_work(struct work_struct *work)\n{\n\treturn __flush_work(work, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%s(flags=%x): mutual exclusion failure\\n\"",
            "__func__",
            "flags"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ww_acquire_fini",
          "args": [
            "&ctx"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ww_mutex_unlock",
          "args": [
            "&mtx.mutex"
          ],
          "line": 92
        },
        "resolved": true,
        "details": {
          "function_name": "__ww_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/ww_mutex.h",
          "lines": "559-569",
          "snippet": "static inline void __ww_mutex_unlock(struct ww_mutex *lock)\n{\n\tif (lock->ctx) {\n#ifdef DEBUG_WW_MUTEXES\n\t\tDEBUG_LOCKS_WARN_ON(!lock->ctx->acquired);\n#endif\n\t\tif (lock->ctx->acquired > 0)\n\t\t\tlock->ctx->acquired--;\n\t\tlock->ctx = NULL;\n\t}\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void __ww_mutex_unlock(struct ww_mutex *lock)\n{\n\tif (lock->ctx) {\n#ifdef DEBUG_WW_MUTEXES\n\t\tDEBUG_LOCKS_WARN_ON(!lock->ctx->acquired);\n#endif\n\t\tif (lock->ctx->acquired > 0)\n\t\t\tlock->ctx->acquired--;\n\t\tlock->ctx = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_for_completion_timeout",
          "args": [
            "&mtx.done",
            "TIMEOUT"
          ],
          "line": 90
        },
        "resolved": true,
        "details": {
          "function_name": "wait_for_completion_timeout",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/completion.c",
          "lines": "154-158",
          "snippet": "unsigned long __sched\nwait_for_completion_timeout(struct completion *x, unsigned long timeout)\n{\n\treturn wait_for_common(x, timeout, TASK_UNINTERRUPTIBLE);\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nunsigned long __sched\nwait_for_completion_timeout(struct completion *x, unsigned long timeout)\n{\n\treturn wait_for_common(x, timeout, TASK_UNINTERRUPTIBLE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "time_before",
          "args": [
            "jiffies",
            "timeout"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 87
        },
        "resolved": true,
        "details": {
          "function_name": "__cond_resched",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "8172-8193",
          "snippet": "int __sched __cond_resched(void)\n{\n\tif (should_resched(0)) {\n\t\tpreempt_schedule_common();\n\t\treturn 1;\n\t}\n\t/*\n\t * In preemptible kernels, ->rcu_read_lock_nesting tells the tick\n\t * whether the current CPU is in an RCU read-side critical section,\n\t * so the tick can report quiescent states even for CPUs looping\n\t * in kernel context.  In contrast, in non-preemptible kernels,\n\t * RCU readers leave no in-memory hints, which means that CPU-bound\n\t * processes executing in kernel context might never report an\n\t * RCU quiescent state.  Therefore, the following code causes\n\t * cond_resched() to report a quiescent state, but only when RCU\n\t * is in urgent need of one.\n\t */\n#ifndef CONFIG_PREEMPT_RCU\n\trcu_all_qs();\n#endif\n\treturn 0;\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __sched",
            "static void __sched"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic void __sched;\nstatic void __sched;\n\nint __sched __cond_resched(void)\n{\n\tif (should_resched(0)) {\n\t\tpreempt_schedule_common();\n\t\treturn 1;\n\t}\n\t/*\n\t * In preemptible kernels, ->rcu_read_lock_nesting tells the tick\n\t * whether the current CPU is in an RCU read-side critical section,\n\t * so the tick can report quiescent states even for CPUs looping\n\t * in kernel context.  In contrast, in non-preemptible kernels,\n\t * RCU readers leave no in-memory hints, which means that CPU-bound\n\t * processes executing in kernel context might never report an\n\t * RCU quiescent state.  Therefore, the following code causes\n\t * cond_resched() to report a quiescent state, but only when RCU\n\t * is in urgent need of one.\n\t */\n#ifndef CONFIG_PREEMPT_RCU\n\trcu_all_qs();\n#endif\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "completion_done",
          "args": [
            "&mtx.done"
          ],
          "line": 83
        },
        "resolved": true,
        "details": {
          "function_name": "completion_done",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/completion.c",
          "lines": "315-330",
          "snippet": "bool completion_done(struct completion *x)\n{\n\tunsigned long flags;\n\n\tif (!READ_ONCE(x->done))\n\t\treturn false;\n\n\t/*\n\t * If ->done, we need to wait for complete() to release ->wait.lock\n\t * otherwise we can end up freeing the completion before complete()\n\t * is done referencing it.\n\t */\n\traw_spin_lock_irqsave(&x->wait.lock, flags);\n\traw_spin_unlock_irqrestore(&x->wait.lock, flags);\n\treturn true;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nbool completion_done(struct completion *x)\n{\n\tunsigned long flags;\n\n\tif (!READ_ONCE(x->done))\n\t\treturn false;\n\n\t/*\n\t * If ->done, we need to wait for complete() to release ->wait.lock\n\t * otherwise we can end up freeing the completion before complete()\n\t * is done referencing it.\n\t */\n\traw_spin_lock_irqsave(&x->wait.lock, flags);\n\traw_spin_unlock_irqrestore(&x->wait.lock, flags);\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "complete",
          "args": [
            "&mtx.go"
          ],
          "line": 77
        },
        "resolved": true,
        "details": {
          "function_name": "complete_vfork_done",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/fork.c",
          "lines": "1334-1345",
          "snippet": "static void complete_vfork_done(struct task_struct *tsk)\n{\n\tstruct completion *vfork;\n\n\ttask_lock(tsk);\n\tvfork = tsk->vfork_done;\n\tif (likely(vfork)) {\n\t\ttsk->vfork_done = NULL;\n\t\tcomplete(vfork);\n\t}\n\ttask_unlock(tsk);\n}",
          "includes": [
            "#include <linux/init_task.h>",
            "#include <trace/events/task.h>",
            "#include <trace/events/sched.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <linux/bpf.h>",
            "#include <linux/io_uring.h>",
            "#include <linux/scs.h>",
            "#include <linux/kasan.h>",
            "#include <linux/stackleak.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/kcov.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/compiler.h>",
            "#include <linux/aio.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/oom.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/magic.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/tty.h>",
            "#include <linux/random.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/acct.h>",
            "#include <linux/ksm.h>",
            "#include <linux/rmap.h>",
            "#include <linux/profile.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/kthread.h>",
            "#include <linux/compat.h>",
            "#include <linux/futex.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mman.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/sem.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>",
            "#include <linux/unistd.h>",
            "#include <linux/init.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/anon_inodes.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __latent_entropy struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/init_task.h>\n#include <trace/events/task.h>\n#include <trace/events/sched.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <linux/bpf.h>\n#include <linux/io_uring.h>\n#include <linux/scs.h>\n#include <linux/kasan.h>\n#include <linux/stackleak.h>\n#include <linux/thread_info.h>\n#include <linux/livepatch.h>\n#include <linux/kcov.h>\n#include <linux/sysctl.h>\n#include <linux/compiler.h>\n#include <linux/aio.h>\n#include <linux/uprobes.h>\n#include <linux/signalfd.h>\n#include <linux/khugepaged.h>\n#include <linux/oom.h>\n#include <linux/user-return-notifier.h>\n#include <linux/posix-timers.h>\n#include <linux/perf_event.h>\n#include <linux/magic.h>\n#include <linux/fs_struct.h>\n#include <linux/tty.h>\n#include <linux/random.h>\n#include <linux/taskstats_kern.h>\n#include <linux/delayacct.h>\n#include <linux/freezer.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/acct.h>\n#include <linux/ksm.h>\n#include <linux/rmap.h>\n#include <linux/profile.h>\n#include <linux/proc_fs.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/ptrace.h>\n#include <linux/rcupdate.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/kthread.h>\n#include <linux/compat.h>\n#include <linux/futex.h>\n#include <linux/jiffies.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/seccomp.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/cgroup.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/nsproxy.h>\n#include <linux/vmacache.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mman.h>\n#include <linux/binfmts.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/sem.h>\n#include <linux/mempolicy.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/unistd.h>\n#include <linux/init.h>\n#include <linux/rtmutex.h>\n#include <linux/seq_file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/user.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/anon_inodes.h>\n\nstatic __latent_entropy struct;\n\nstatic void complete_vfork_done(struct task_struct *tsk)\n{\n\tstruct completion *vfork;\n\n\ttask_lock(tsk);\n\tvfork = tsk->vfork_done;\n\tif (likely(vfork)) {\n\t\ttsk->vfork_done = NULL;\n\t\tcomplete(vfork);\n\t}\n\ttask_unlock(tsk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ww_mutex_lock",
          "args": [
            "&mtx.mutex",
            "(flags & TEST_MTX_CTX) ? &ctx : NULL"
          ],
          "line": 76
        },
        "resolved": true,
        "details": {
          "function_name": "ww_mutex_lock_acquired",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "45-48",
          "snippet": "static inline void ww_mutex_lock_acquired(struct ww_mutex *lock,\n\t\t\t\t\t  struct ww_acquire_ctx *ww_ctx)\n{\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic inline void ww_mutex_lock_acquired(struct ww_mutex *lock,\n\t\t\t\t\t  struct ww_acquire_ctx *ww_ctx)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_for_completion",
          "args": [
            "&mtx.ready"
          ],
          "line": 75
        },
        "resolved": true,
        "details": {
          "function_name": "try_wait_for_completion",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/completion.c",
          "lines": "282-303",
          "snippet": "bool try_wait_for_completion(struct completion *x)\n{\n\tunsigned long flags;\n\tbool ret = true;\n\n\t/*\n\t * Since x->done will need to be locked only\n\t * in the non-blocking case, we check x->done\n\t * first without taking the lock so we can\n\t * return early in the blocking case.\n\t */\n\tif (!READ_ONCE(x->done))\n\t\treturn false;\n\n\traw_spin_lock_irqsave(&x->wait.lock, flags);\n\tif (!x->done)\n\t\tret = false;\n\telse if (x->done != UINT_MAX)\n\t\tx->done--;\n\traw_spin_unlock_irqrestore(&x->wait.lock, flags);\n\treturn ret;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nbool try_wait_for_completion(struct completion *x)\n{\n\tunsigned long flags;\n\tbool ret = true;\n\n\t/*\n\t * Since x->done will need to be locked only\n\t * in the non-blocking case, we check x->done\n\t * first without taking the lock so we can\n\t * return early in the blocking case.\n\t */\n\tif (!READ_ONCE(x->done))\n\t\treturn false;\n\n\traw_spin_lock_irqsave(&x->wait.lock, flags);\n\tif (!x->done)\n\t\tret = false;\n\telse if (x->done != UINT_MAX)\n\t\tx->done--;\n\traw_spin_unlock_irqrestore(&x->wait.lock, flags);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "schedule_work",
          "args": [
            "&mtx.work"
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_completion",
          "args": [
            "&mtx.done"
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_completion",
          "args": [
            "&mtx.go"
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_completion",
          "args": [
            "&mtx.ready"
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_WORK_ONSTACK",
          "args": [
            "&mtx.work",
            "test_mutex_work"
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ww_acquire_init",
          "args": [
            "&ctx",
            "&ww_class"
          ],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ww_mutex_init",
          "args": [
            "&mtx.mutex",
            "&ww_class"
          ],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ww_mutex.h>\n#include <linux/slab.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/completion.h>\n#include <linux/kernel.h>\n\n#define TIMEOUT (HZ / 16)\n#define TEST_MTX_CTX BIT(2)\n#define TEST_MTX_SPIN BIT(0)\n\nstatic DEFINE_WD_CLASS(ww_class);\n\nstatic int __test_mutex(unsigned int flags)\n{\n#define TIMEOUT (HZ / 16)\n\tstruct test_mutex mtx;\n\tstruct ww_acquire_ctx ctx;\n\tint ret;\n\n\tww_mutex_init(&mtx.mutex, &ww_class);\n\tww_acquire_init(&ctx, &ww_class);\n\n\tINIT_WORK_ONSTACK(&mtx.work, test_mutex_work);\n\tinit_completion(&mtx.ready);\n\tinit_completion(&mtx.go);\n\tinit_completion(&mtx.done);\n\tmtx.flags = flags;\n\n\tschedule_work(&mtx.work);\n\n\twait_for_completion(&mtx.ready);\n\tww_mutex_lock(&mtx.mutex, (flags & TEST_MTX_CTX) ? &ctx : NULL);\n\tcomplete(&mtx.go);\n\tif (flags & TEST_MTX_SPIN) {\n\t\tunsigned long timeout = jiffies + TIMEOUT;\n\n\t\tret = 0;\n\t\tdo {\n\t\t\tif (completion_done(&mtx.done)) {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcond_resched();\n\t\t} while (time_before(jiffies, timeout));\n\t} else {\n\t\tret = wait_for_completion_timeout(&mtx.done, TIMEOUT);\n\t}\n\tww_mutex_unlock(&mtx.mutex);\n\tww_acquire_fini(&ctx);\n\n\tif (ret) {\n\t\tpr_err(\"%s(flags=%x): mutual exclusion failure\\n\",\n\t\t       __func__, flags);\n\t\tret = -EINVAL;\n\t}\n\n\tflush_work(&mtx.work);\n\tdestroy_work_on_stack(&mtx.work);\n\treturn ret;\n#undef TIMEOUT\n}"
  },
  {
    "function_name": "test_mutex_work",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/test-ww_mutex.c",
    "lines": "40-55",
    "snippet": "static void test_mutex_work(struct work_struct *work)\n{\n\tstruct test_mutex *mtx = container_of(work, typeof(*mtx), work);\n\n\tcomplete(&mtx->ready);\n\twait_for_completion(&mtx->go);\n\n\tif (mtx->flags & TEST_MTX_TRY) {\n\t\twhile (!ww_mutex_trylock(&mtx->mutex, NULL))\n\t\t\tcond_resched();\n\t} else {\n\t\tww_mutex_lock(&mtx->mutex, NULL);\n\t}\n\tcomplete(&mtx->done);\n\tww_mutex_unlock(&mtx->mutex);\n}",
    "includes": [
      "#include <linux/ww_mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/completion.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define TEST_MTX_TRY BIT(1)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ww_mutex_unlock",
          "args": [
            "&mtx->mutex"
          ],
          "line": 54
        },
        "resolved": true,
        "details": {
          "function_name": "__ww_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/ww_mutex.h",
          "lines": "559-569",
          "snippet": "static inline void __ww_mutex_unlock(struct ww_mutex *lock)\n{\n\tif (lock->ctx) {\n#ifdef DEBUG_WW_MUTEXES\n\t\tDEBUG_LOCKS_WARN_ON(!lock->ctx->acquired);\n#endif\n\t\tif (lock->ctx->acquired > 0)\n\t\t\tlock->ctx->acquired--;\n\t\tlock->ctx = NULL;\n\t}\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void __ww_mutex_unlock(struct ww_mutex *lock)\n{\n\tif (lock->ctx) {\n#ifdef DEBUG_WW_MUTEXES\n\t\tDEBUG_LOCKS_WARN_ON(!lock->ctx->acquired);\n#endif\n\t\tif (lock->ctx->acquired > 0)\n\t\t\tlock->ctx->acquired--;\n\t\tlock->ctx = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "complete",
          "args": [
            "&mtx->done"
          ],
          "line": 53
        },
        "resolved": true,
        "details": {
          "function_name": "complete_vfork_done",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/fork.c",
          "lines": "1334-1345",
          "snippet": "static void complete_vfork_done(struct task_struct *tsk)\n{\n\tstruct completion *vfork;\n\n\ttask_lock(tsk);\n\tvfork = tsk->vfork_done;\n\tif (likely(vfork)) {\n\t\ttsk->vfork_done = NULL;\n\t\tcomplete(vfork);\n\t}\n\ttask_unlock(tsk);\n}",
          "includes": [
            "#include <linux/init_task.h>",
            "#include <trace/events/task.h>",
            "#include <trace/events/sched.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <linux/bpf.h>",
            "#include <linux/io_uring.h>",
            "#include <linux/scs.h>",
            "#include <linux/kasan.h>",
            "#include <linux/stackleak.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/kcov.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/compiler.h>",
            "#include <linux/aio.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/oom.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/magic.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/tty.h>",
            "#include <linux/random.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/acct.h>",
            "#include <linux/ksm.h>",
            "#include <linux/rmap.h>",
            "#include <linux/profile.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/kthread.h>",
            "#include <linux/compat.h>",
            "#include <linux/futex.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mman.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/sem.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>",
            "#include <linux/unistd.h>",
            "#include <linux/init.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/anon_inodes.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __latent_entropy struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/init_task.h>\n#include <trace/events/task.h>\n#include <trace/events/sched.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <linux/bpf.h>\n#include <linux/io_uring.h>\n#include <linux/scs.h>\n#include <linux/kasan.h>\n#include <linux/stackleak.h>\n#include <linux/thread_info.h>\n#include <linux/livepatch.h>\n#include <linux/kcov.h>\n#include <linux/sysctl.h>\n#include <linux/compiler.h>\n#include <linux/aio.h>\n#include <linux/uprobes.h>\n#include <linux/signalfd.h>\n#include <linux/khugepaged.h>\n#include <linux/oom.h>\n#include <linux/user-return-notifier.h>\n#include <linux/posix-timers.h>\n#include <linux/perf_event.h>\n#include <linux/magic.h>\n#include <linux/fs_struct.h>\n#include <linux/tty.h>\n#include <linux/random.h>\n#include <linux/taskstats_kern.h>\n#include <linux/delayacct.h>\n#include <linux/freezer.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/acct.h>\n#include <linux/ksm.h>\n#include <linux/rmap.h>\n#include <linux/profile.h>\n#include <linux/proc_fs.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/ptrace.h>\n#include <linux/rcupdate.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/kthread.h>\n#include <linux/compat.h>\n#include <linux/futex.h>\n#include <linux/jiffies.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/seccomp.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/cgroup.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/nsproxy.h>\n#include <linux/vmacache.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mman.h>\n#include <linux/binfmts.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/sem.h>\n#include <linux/mempolicy.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/unistd.h>\n#include <linux/init.h>\n#include <linux/rtmutex.h>\n#include <linux/seq_file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/user.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/anon_inodes.h>\n\nstatic __latent_entropy struct;\n\nstatic void complete_vfork_done(struct task_struct *tsk)\n{\n\tstruct completion *vfork;\n\n\ttask_lock(tsk);\n\tvfork = tsk->vfork_done;\n\tif (likely(vfork)) {\n\t\ttsk->vfork_done = NULL;\n\t\tcomplete(vfork);\n\t}\n\ttask_unlock(tsk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ww_mutex_lock",
          "args": [
            "&mtx->mutex",
            "NULL"
          ],
          "line": 51
        },
        "resolved": true,
        "details": {
          "function_name": "ww_mutex_lock_acquired",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "45-48",
          "snippet": "static inline void ww_mutex_lock_acquired(struct ww_mutex *lock,\n\t\t\t\t\t  struct ww_acquire_ctx *ww_ctx)\n{\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic inline void ww_mutex_lock_acquired(struct ww_mutex *lock,\n\t\t\t\t\t  struct ww_acquire_ctx *ww_ctx)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 49
        },
        "resolved": true,
        "details": {
          "function_name": "__cond_resched",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "8172-8193",
          "snippet": "int __sched __cond_resched(void)\n{\n\tif (should_resched(0)) {\n\t\tpreempt_schedule_common();\n\t\treturn 1;\n\t}\n\t/*\n\t * In preemptible kernels, ->rcu_read_lock_nesting tells the tick\n\t * whether the current CPU is in an RCU read-side critical section,\n\t * so the tick can report quiescent states even for CPUs looping\n\t * in kernel context.  In contrast, in non-preemptible kernels,\n\t * RCU readers leave no in-memory hints, which means that CPU-bound\n\t * processes executing in kernel context might never report an\n\t * RCU quiescent state.  Therefore, the following code causes\n\t * cond_resched() to report a quiescent state, but only when RCU\n\t * is in urgent need of one.\n\t */\n#ifndef CONFIG_PREEMPT_RCU\n\trcu_all_qs();\n#endif\n\treturn 0;\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __sched",
            "static void __sched"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic void __sched;\nstatic void __sched;\n\nint __sched __cond_resched(void)\n{\n\tif (should_resched(0)) {\n\t\tpreempt_schedule_common();\n\t\treturn 1;\n\t}\n\t/*\n\t * In preemptible kernels, ->rcu_read_lock_nesting tells the tick\n\t * whether the current CPU is in an RCU read-side critical section,\n\t * so the tick can report quiescent states even for CPUs looping\n\t * in kernel context.  In contrast, in non-preemptible kernels,\n\t * RCU readers leave no in-memory hints, which means that CPU-bound\n\t * processes executing in kernel context might never report an\n\t * RCU quiescent state.  Therefore, the following code causes\n\t * cond_resched() to report a quiescent state, but only when RCU\n\t * is in urgent need of one.\n\t */\n#ifndef CONFIG_PREEMPT_RCU\n\trcu_all_qs();\n#endif\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ww_mutex_trylock",
          "args": [
            "&mtx->mutex",
            "NULL"
          ],
          "line": 48
        },
        "resolved": true,
        "details": {
          "function_name": "ww_mutex_trylock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/ww_rt_mutex.c",
          "lines": "12-34",
          "snippet": "int ww_mutex_trylock(struct ww_mutex *lock, struct ww_acquire_ctx *ww_ctx)\n{\n\tstruct rt_mutex *rtm = &lock->base;\n\n\tif (!ww_ctx)\n\t\treturn rt_mutex_trylock(rtm);\n\n\t/*\n\t * Reset the wounded flag after a kill. No other process can\n\t * race and wound us here, since they can't have a valid owner\n\t * pointer if we don't have any locks held.\n\t */\n\tif (ww_ctx->acquired == 0)\n\t\tww_ctx->wounded = 0;\n\n\tif (__rt_mutex_trylock(&rtm->rtmutex)) {\n\t\tww_mutex_set_context_fastpath(lock, ww_ctx);\n\t\tmutex_acquire_nest(&rtm->dep_map, 0, 1, &ww_ctx->dep_map, _RET_IP_);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint ww_mutex_trylock(struct ww_mutex *lock, struct ww_acquire_ctx *ww_ctx)\n{\n\tstruct rt_mutex *rtm = &lock->base;\n\n\tif (!ww_ctx)\n\t\treturn rt_mutex_trylock(rtm);\n\n\t/*\n\t * Reset the wounded flag after a kill. No other process can\n\t * race and wound us here, since they can't have a valid owner\n\t * pointer if we don't have any locks held.\n\t */\n\tif (ww_ctx->acquired == 0)\n\t\tww_ctx->wounded = 0;\n\n\tif (__rt_mutex_trylock(&rtm->rtmutex)) {\n\t\tww_mutex_set_context_fastpath(lock, ww_ctx);\n\t\tmutex_acquire_nest(&rtm->dep_map, 0, 1, &ww_ctx->dep_map, _RET_IP_);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_for_completion",
          "args": [
            "&mtx->go"
          ],
          "line": 45
        },
        "resolved": true,
        "details": {
          "function_name": "try_wait_for_completion",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/completion.c",
          "lines": "282-303",
          "snippet": "bool try_wait_for_completion(struct completion *x)\n{\n\tunsigned long flags;\n\tbool ret = true;\n\n\t/*\n\t * Since x->done will need to be locked only\n\t * in the non-blocking case, we check x->done\n\t * first without taking the lock so we can\n\t * return early in the blocking case.\n\t */\n\tif (!READ_ONCE(x->done))\n\t\treturn false;\n\n\traw_spin_lock_irqsave(&x->wait.lock, flags);\n\tif (!x->done)\n\t\tret = false;\n\telse if (x->done != UINT_MAX)\n\t\tx->done--;\n\traw_spin_unlock_irqrestore(&x->wait.lock, flags);\n\treturn ret;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nbool try_wait_for_completion(struct completion *x)\n{\n\tunsigned long flags;\n\tbool ret = true;\n\n\t/*\n\t * Since x->done will need to be locked only\n\t * in the non-blocking case, we check x->done\n\t * first without taking the lock so we can\n\t * return early in the blocking case.\n\t */\n\tif (!READ_ONCE(x->done))\n\t\treturn false;\n\n\traw_spin_lock_irqsave(&x->wait.lock, flags);\n\tif (!x->done)\n\t\tret = false;\n\telse if (x->done != UINT_MAX)\n\t\tx->done--;\n\traw_spin_unlock_irqrestore(&x->wait.lock, flags);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "work",
            "typeof(*mtx)",
            "work"
          ],
          "line": 42
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "typeof",
          "args": [
            "*mtx"
          ],
          "line": 42
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ww_mutex.h>\n#include <linux/slab.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/completion.h>\n#include <linux/kernel.h>\n\n#define TEST_MTX_TRY BIT(1)\n\nstatic void test_mutex_work(struct work_struct *work)\n{\n\tstruct test_mutex *mtx = container_of(work, typeof(*mtx), work);\n\n\tcomplete(&mtx->ready);\n\twait_for_completion(&mtx->go);\n\n\tif (mtx->flags & TEST_MTX_TRY) {\n\t\twhile (!ww_mutex_trylock(&mtx->mutex, NULL))\n\t\t\tcond_resched();\n\t} else {\n\t\tww_mutex_lock(&mtx->mutex, NULL);\n\t}\n\tcomplete(&mtx->done);\n\tww_mutex_unlock(&mtx->mutex);\n}"
  }
]