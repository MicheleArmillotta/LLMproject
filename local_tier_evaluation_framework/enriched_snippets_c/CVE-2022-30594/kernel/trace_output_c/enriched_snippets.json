[
  {
    "function_name": "init_events",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_output.c",
    "lines": "1567-1584",
    "snippet": "__init static int init_events(void)\n{\n\tstruct trace_event *event;\n\tint i, ret;\n\n\tfor (i = 0; events[i]; i++) {\n\t\tevent = events[i];\n\n\t\tret = register_trace_event(event);\n\t\tif (!ret) {\n\t\t\tprintk(KERN_WARNING \"event %d failed to register\\n\",\n\t\t\t       event->type);\n\t\t\tWARN_ON_ONCE(1);\n\t\t}\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct trace_event *events[] __initdata = {\n\t&trace_fn_event,\n\t&trace_ctx_event,\n\t&trace_wake_event,\n\t&trace_stack_event,\n\t&trace_user_stack_event,\n\t&trace_bputs_event,\n\t&trace_bprint_event,\n\t&trace_print_event,\n\t&trace_hwlat_event,\n\t&trace_osnoise_event,\n\t&trace_timerlat_event,\n\t&trace_raw_data_event,\n\t&trace_func_repeats_event,\n\tNULL\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "1"
          ],
          "line": 1579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_WARNING \"event %d failed to register\\n\"",
            "event->type"
          ],
          "line": 1577
        },
        "resolved": true,
        "details": {
          "function_name": "mmio_trace_printk",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_mmiotrace.c",
          "lines": "359-362",
          "snippet": "int mmio_trace_printk(const char *fmt, va_list args)\n{\n\treturn trace_vprintk(0, fmt, args);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/atomic.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/pci.h>",
            "#include <linux/mmiotrace.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/atomic.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/pci.h>\n#include <linux/mmiotrace.h>\n#include <linux/kernel.h>\n\nint mmio_trace_printk(const char *fmt, va_list args)\n{\n\treturn trace_vprintk(0, fmt, args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "register_trace_event",
          "args": [
            "event"
          ],
          "line": 1575
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_trace_event",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_output.c",
          "lines": "826-833",
          "snippet": "int unregister_trace_event(struct trace_event *event)\n{\n\tdown_write(&trace_event_sem);\n\t__unregister_trace_event(event);\n\tup_write(&trace_event_sem);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nint unregister_trace_event(struct trace_event *event)\n{\n\tdown_write(&trace_event_sem);\n\t__unregister_trace_event(event);\n\tup_write(&trace_event_sem);\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nstatic struct trace_event *events[] __initdata = {\n\t&trace_fn_event,\n\t&trace_ctx_event,\n\t&trace_wake_event,\n\t&trace_stack_event,\n\t&trace_user_stack_event,\n\t&trace_bputs_event,\n\t&trace_bprint_event,\n\t&trace_print_event,\n\t&trace_hwlat_event,\n\t&trace_osnoise_event,\n\t&trace_timerlat_event,\n\t&trace_raw_data_event,\n\t&trace_func_repeats_event,\n\tNULL\n};\n\n__init static int init_events(void)\n{\n\tstruct trace_event *event;\n\tint i, ret;\n\n\tfor (i = 0; events[i]; i++) {\n\t\tevent = events[i];\n\n\t\tret = register_trace_event(event);\n\t\tif (!ret) {\n\t\t\tprintk(KERN_WARNING \"event %d failed to register\\n\",\n\t\t\t       event->type);\n\t\t\tWARN_ON_ONCE(1);\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "trace_func_repeats_print",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_output.c",
    "lines": "1522-1538",
    "snippet": "static enum print_line_t\ntrace_func_repeats_print(struct trace_iterator *iter, int flags,\n\t\t\t struct trace_event *event)\n{\n\tstruct func_repeats_entry *field;\n\tstruct trace_seq *s = &iter->seq;\n\n\ttrace_assign_type(field, iter->ent);\n\n\tprint_fn_trace(s, field->ip, field->parent_ip, flags);\n\ttrace_seq_printf(s, \" (repeats: %u, last_ts:\", field->count);\n\ttrace_print_time(s, iter,\n\t\t\t iter->ts - FUNC_REPEATS_GET_DELTA_TS(field));\n\ttrace_seq_puts(s, \")\\n\");\n\n\treturn trace_handle_return(s);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_handle_return",
          "args": [
            "s"
          ],
          "line": 1537
        },
        "resolved": true,
        "details": {
          "function_name": "trace_handle_return",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "2577-2581",
          "snippet": "enum print_line_t trace_handle_return(struct trace_seq *s)\n{\n\treturn trace_seq_has_overflowed(s) ?\n\t\tTRACE_TYPE_PARTIAL_LINE : TRACE_TYPE_HANDLED;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nenum print_line_t trace_handle_return(struct trace_seq *s)\n{\n\treturn trace_seq_has_overflowed(s) ?\n\t\tTRACE_TYPE_PARTIAL_LINE : TRACE_TYPE_HANDLED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_seq_puts",
          "args": [
            "s",
            "\")\\n\""
          ],
          "line": 1535
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_puts",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "205-220",
          "snippet": "void trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_print_time",
          "args": [
            "s",
            "iter",
            "iter->ts - FUNC_REPEATS_GET_DELTA_TS(field)"
          ],
          "line": 1533
        },
        "resolved": true,
        "details": {
          "function_name": "trace_print_time",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_output.c",
          "lines": "590-603",
          "snippet": "static void trace_print_time(struct trace_seq *s, struct trace_iterator *iter,\n\t\t\t     unsigned long long ts)\n{\n\tunsigned long secs, usec_rem;\n\tunsigned long long t;\n\n\tif (iter->iter_flags & TRACE_FILE_TIME_IN_NS) {\n\t\tt = ns2usecs(ts);\n\t\tusec_rem = do_div(t, USEC_PER_SEC);\n\t\tsecs = (unsigned long)t;\n\t\ttrace_seq_printf(s, \" %5lu.%06lu\", secs, usec_rem);\n\t} else\n\t\ttrace_seq_printf(s, \" %12llu\", ts);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nstatic void trace_print_time(struct trace_seq *s, struct trace_iterator *iter,\n\t\t\t     unsigned long long ts)\n{\n\tunsigned long secs, usec_rem;\n\tunsigned long long t;\n\n\tif (iter->iter_flags & TRACE_FILE_TIME_IN_NS) {\n\t\tt = ns2usecs(ts);\n\t\tusec_rem = do_div(t, USEC_PER_SEC);\n\t\tsecs = (unsigned long)t;\n\t\ttrace_seq_printf(s, \" %5lu.%06lu\", secs, usec_rem);\n\t} else\n\t\ttrace_seq_printf(s, \" %12llu\", ts);\n}"
        }
      },
      {
        "call_info": {
          "callee": "FUNC_REPEATS_GET_DELTA_TS",
          "args": [
            "field"
          ],
          "line": 1534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_seq_printf",
          "args": [
            "s",
            "\" (repeats: %u, last_ts:\"",
            "field->count"
          ],
          "line": 1532
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "81-100",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_fn_trace",
          "args": [
            "s",
            "field->ip",
            "field->parent_ip",
            "flags"
          ],
          "line": 1531
        },
        "resolved": true,
        "details": {
          "function_name": "print_fn_trace",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_output.c",
          "lines": "848-857",
          "snippet": "static void print_fn_trace(struct trace_seq *s, unsigned long ip,\n\t\t\t   unsigned long parent_ip, int flags)\n{\n\tseq_print_ip_sym(s, ip, flags);\n\n\tif ((flags & TRACE_ITER_PRINT_PARENT) && parent_ip) {\n\t\ttrace_seq_puts(s, \" <-\");\n\t\tseq_print_ip_sym(s, parent_ip, flags);\n\t}\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nstatic void print_fn_trace(struct trace_seq *s, unsigned long ip,\n\t\t\t   unsigned long parent_ip, int flags)\n{\n\tseq_print_ip_sym(s, ip, flags);\n\n\tif ((flags & TRACE_ITER_PRINT_PARENT) && parent_ip) {\n\t\ttrace_seq_puts(s, \" <-\");\n\t\tseq_print_ip_sym(s, parent_ip, flags);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_assign_type",
          "args": [
            "field",
            "iter->ent"
          ],
          "line": 1529
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nstatic enum print_line_t\ntrace_func_repeats_print(struct trace_iterator *iter, int flags,\n\t\t\t struct trace_event *event)\n{\n\tstruct func_repeats_entry *field;\n\tstruct trace_seq *s = &iter->seq;\n\n\ttrace_assign_type(field, iter->ent);\n\n\tprint_fn_trace(s, field->ip, field->parent_ip, flags);\n\ttrace_seq_printf(s, \" (repeats: %u, last_ts:\", field->count);\n\ttrace_print_time(s, iter,\n\t\t\t iter->ts - FUNC_REPEATS_GET_DELTA_TS(field));\n\ttrace_seq_puts(s, \")\\n\");\n\n\treturn trace_handle_return(s);\n}"
  },
  {
    "function_name": "trace_func_repeats_raw",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_output.c",
    "lines": "1504-1520",
    "snippet": "static enum print_line_t\ntrace_func_repeats_raw(struct trace_iterator *iter, int flags,\n\t\t\t struct trace_event *event)\n{\n\tstruct func_repeats_entry *field;\n\tstruct trace_seq *s = &iter->seq;\n\n\ttrace_assign_type(field, iter->ent);\n\n\ttrace_seq_printf(s, \"%lu %lu %u %llu\\n\",\n\t\t\t field->ip,\n\t\t\t field->parent_ip,\n\t\t\t field->count,\n\t\t\t FUNC_REPEATS_GET_DELTA_TS(field));\n\n\treturn trace_handle_return(s);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_handle_return",
          "args": [
            "s"
          ],
          "line": 1519
        },
        "resolved": true,
        "details": {
          "function_name": "trace_handle_return",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "2577-2581",
          "snippet": "enum print_line_t trace_handle_return(struct trace_seq *s)\n{\n\treturn trace_seq_has_overflowed(s) ?\n\t\tTRACE_TYPE_PARTIAL_LINE : TRACE_TYPE_HANDLED;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nenum print_line_t trace_handle_return(struct trace_seq *s)\n{\n\treturn trace_seq_has_overflowed(s) ?\n\t\tTRACE_TYPE_PARTIAL_LINE : TRACE_TYPE_HANDLED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_seq_printf",
          "args": [
            "s",
            "\"%lu %lu %u %llu\\n\"",
            "field->ip",
            "field->parent_ip",
            "field->count",
            "FUNC_REPEATS_GET_DELTA_TS(field)"
          ],
          "line": 1513
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "81-100",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "FUNC_REPEATS_GET_DELTA_TS",
          "args": [
            "field"
          ],
          "line": 1517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_assign_type",
          "args": [
            "field",
            "iter->ent"
          ],
          "line": 1511
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nstatic enum print_line_t\ntrace_func_repeats_raw(struct trace_iterator *iter, int flags,\n\t\t\t struct trace_event *event)\n{\n\tstruct func_repeats_entry *field;\n\tstruct trace_seq *s = &iter->seq;\n\n\ttrace_assign_type(field, iter->ent);\n\n\ttrace_seq_printf(s, \"%lu %lu %u %llu\\n\",\n\t\t\t field->ip,\n\t\t\t field->parent_ip,\n\t\t\t field->count,\n\t\t\t FUNC_REPEATS_GET_DELTA_TS(field));\n\n\treturn trace_handle_return(s);\n}"
  },
  {
    "function_name": "trace_raw_data",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_output.c",
    "lines": "1475-1492",
    "snippet": "static enum print_line_t trace_raw_data(struct trace_iterator *iter, int flags,\n\t\t\t\t\t struct trace_event *event)\n{\n\tstruct raw_data_entry *field;\n\tint i;\n\n\ttrace_assign_type(field, iter->ent);\n\n\ttrace_seq_printf(&iter->seq, \"# %x buf:\", field->id);\n\n\tfor (i = 0; i < iter->ent_size - offsetof(struct raw_data_entry, buf); i++)\n\t\ttrace_seq_printf(&iter->seq, \" %02x\",\n\t\t\t\t (unsigned char)field->buf[i]);\n\n\ttrace_seq_putc(&iter->seq, '\\n');\n\n\treturn trace_handle_return(&iter->seq);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_handle_return",
          "args": [
            "&iter->seq"
          ],
          "line": 1491
        },
        "resolved": true,
        "details": {
          "function_name": "trace_handle_return",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "2577-2581",
          "snippet": "enum print_line_t trace_handle_return(struct trace_seq *s)\n{\n\treturn trace_seq_has_overflowed(s) ?\n\t\tTRACE_TYPE_PARTIAL_LINE : TRACE_TYPE_HANDLED;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nenum print_line_t trace_handle_return(struct trace_seq *s)\n{\n\treturn trace_seq_has_overflowed(s) ?\n\t\tTRACE_TYPE_PARTIAL_LINE : TRACE_TYPE_HANDLED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_seq_putc",
          "args": [
            "&iter->seq",
            "'\\n'"
          ],
          "line": 1489
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_putc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "233-246",
          "snippet": "void trace_seq_putc(struct trace_seq *s, unsigned char c)\n{\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (TRACE_SEQ_BUF_LEFT(s) < 1) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putc(&s->seq, c);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_putc(struct trace_seq *s, unsigned char c)\n{\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (TRACE_SEQ_BUF_LEFT(s) < 1) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putc(&s->seq, c);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_seq_printf",
          "args": [
            "&iter->seq",
            "\" %02x\"",
            "(unsigned char)field->buf[i]"
          ],
          "line": 1486
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "81-100",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_assign_type",
          "args": [
            "field",
            "iter->ent"
          ],
          "line": 1481
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nstatic enum print_line_t trace_raw_data(struct trace_iterator *iter, int flags,\n\t\t\t\t\t struct trace_event *event)\n{\n\tstruct raw_data_entry *field;\n\tint i;\n\n\ttrace_assign_type(field, iter->ent);\n\n\ttrace_seq_printf(&iter->seq, \"# %x buf:\", field->id);\n\n\tfor (i = 0; i < iter->ent_size - offsetof(struct raw_data_entry, buf); i++)\n\t\ttrace_seq_printf(&iter->seq, \" %02x\",\n\t\t\t\t (unsigned char)field->buf[i]);\n\n\ttrace_seq_putc(&iter->seq, '\\n');\n\n\treturn trace_handle_return(&iter->seq);\n}"
  },
  {
    "function_name": "trace_print_raw",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_output.c",
    "lines": "1453-1463",
    "snippet": "static enum print_line_t trace_print_raw(struct trace_iterator *iter, int flags,\n\t\t\t\t\t struct trace_event *event)\n{\n\tstruct print_entry *field;\n\n\ttrace_assign_type(field, iter->ent);\n\n\ttrace_seq_printf(&iter->seq, \"# %lx %s\", field->ip, field->buf);\n\n\treturn trace_handle_return(&iter->seq);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_handle_return",
          "args": [
            "&iter->seq"
          ],
          "line": 1462
        },
        "resolved": true,
        "details": {
          "function_name": "trace_handle_return",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "2577-2581",
          "snippet": "enum print_line_t trace_handle_return(struct trace_seq *s)\n{\n\treturn trace_seq_has_overflowed(s) ?\n\t\tTRACE_TYPE_PARTIAL_LINE : TRACE_TYPE_HANDLED;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nenum print_line_t trace_handle_return(struct trace_seq *s)\n{\n\treturn trace_seq_has_overflowed(s) ?\n\t\tTRACE_TYPE_PARTIAL_LINE : TRACE_TYPE_HANDLED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_seq_printf",
          "args": [
            "&iter->seq",
            "\"# %lx %s\"",
            "field->ip",
            "field->buf"
          ],
          "line": 1460
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "81-100",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_assign_type",
          "args": [
            "field",
            "iter->ent"
          ],
          "line": 1458
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nstatic enum print_line_t trace_print_raw(struct trace_iterator *iter, int flags,\n\t\t\t\t\t struct trace_event *event)\n{\n\tstruct print_entry *field;\n\n\ttrace_assign_type(field, iter->ent);\n\n\ttrace_seq_printf(&iter->seq, \"# %lx %s\", field->ip, field->buf);\n\n\treturn trace_handle_return(&iter->seq);\n}"
  },
  {
    "function_name": "trace_print_print",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_output.c",
    "lines": "1439-1451",
    "snippet": "static enum print_line_t trace_print_print(struct trace_iterator *iter,\n\t\t\t\t\t   int flags, struct trace_event *event)\n{\n\tstruct print_entry *field;\n\tstruct trace_seq *s = &iter->seq;\n\n\ttrace_assign_type(field, iter->ent);\n\n\tseq_print_ip_sym(s, field->ip, flags);\n\ttrace_seq_printf(s, \": %s\", field->buf);\n\n\treturn trace_handle_return(s);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_handle_return",
          "args": [
            "s"
          ],
          "line": 1450
        },
        "resolved": true,
        "details": {
          "function_name": "trace_handle_return",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "2577-2581",
          "snippet": "enum print_line_t trace_handle_return(struct trace_seq *s)\n{\n\treturn trace_seq_has_overflowed(s) ?\n\t\tTRACE_TYPE_PARTIAL_LINE : TRACE_TYPE_HANDLED;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nenum print_line_t trace_handle_return(struct trace_seq *s)\n{\n\treturn trace_seq_has_overflowed(s) ?\n\t\tTRACE_TYPE_PARTIAL_LINE : TRACE_TYPE_HANDLED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_seq_printf",
          "args": [
            "s",
            "\": %s\"",
            "field->buf"
          ],
          "line": 1448
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "81-100",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_print_ip_sym",
          "args": [
            "s",
            "field->ip",
            "flags"
          ],
          "line": 1447
        },
        "resolved": true,
        "details": {
          "function_name": "seq_print_ip_sym",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_output.c",
          "lines": "416-431",
          "snippet": "int\nseq_print_ip_sym(struct trace_seq *s, unsigned long ip, unsigned long sym_flags)\n{\n\tif (!ip) {\n\t\ttrace_seq_putc(s, '0');\n\t\tgoto out;\n\t}\n\n\ttrace_seq_print_sym(s, ip, sym_flags & TRACE_ITER_SYM_OFFSET);\n\n\tif (sym_flags & TRACE_ITER_SYM_ADDR)\n\t\ttrace_seq_printf(s, \" <\" IP_FMT \">\", ip);\n\n out:\n\treturn !trace_seq_has_overflowed(s);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nint\nseq_print_ip_sym(struct trace_seq *s, unsigned long ip, unsigned long sym_flags)\n{\n\tif (!ip) {\n\t\ttrace_seq_putc(s, '0');\n\t\tgoto out;\n\t}\n\n\ttrace_seq_print_sym(s, ip, sym_flags & TRACE_ITER_SYM_OFFSET);\n\n\tif (sym_flags & TRACE_ITER_SYM_ADDR)\n\t\ttrace_seq_printf(s, \" <\" IP_FMT \">\", ip);\n\n out:\n\treturn !trace_seq_has_overflowed(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_assign_type",
          "args": [
            "field",
            "iter->ent"
          ],
          "line": 1445
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nstatic enum print_line_t trace_print_print(struct trace_iterator *iter,\n\t\t\t\t\t   int flags, struct trace_event *event)\n{\n\tstruct print_entry *field;\n\tstruct trace_seq *s = &iter->seq;\n\n\ttrace_assign_type(field, iter->ent);\n\n\tseq_print_ip_sym(s, field->ip, flags);\n\ttrace_seq_printf(s, \": %s\", field->buf);\n\n\treturn trace_handle_return(s);\n}"
  },
  {
    "function_name": "trace_bprint_raw",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_output.c",
    "lines": "1413-1426",
    "snippet": "static enum print_line_t\ntrace_bprint_raw(struct trace_iterator *iter, int flags,\n\t\t struct trace_event *event)\n{\n\tstruct bprint_entry *field;\n\tstruct trace_seq *s = &iter->seq;\n\n\ttrace_assign_type(field, iter->ent);\n\n\ttrace_seq_printf(s, \": %lx : \", field->ip);\n\ttrace_seq_bprintf(s, field->fmt, field->buf);\n\n\treturn trace_handle_return(s);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_handle_return",
          "args": [
            "s"
          ],
          "line": 1425
        },
        "resolved": true,
        "details": {
          "function_name": "trace_handle_return",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "2577-2581",
          "snippet": "enum print_line_t trace_handle_return(struct trace_seq *s)\n{\n\treturn trace_seq_has_overflowed(s) ?\n\t\tTRACE_TYPE_PARTIAL_LINE : TRACE_TYPE_HANDLED;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nenum print_line_t trace_handle_return(struct trace_seq *s)\n{\n\treturn trace_seq_has_overflowed(s) ?\n\t\tTRACE_TYPE_PARTIAL_LINE : TRACE_TYPE_HANDLED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_seq_bprintf",
          "args": [
            "s",
            "field->fmt",
            "field->buf"
          ],
          "line": 1423
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_bprintf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "175-192",
          "snippet": "void trace_seq_bprintf(struct trace_seq *s, const char *fmt, const u32 *binary)\n{\n\tunsigned int save_len = s->seq.len;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tseq_buf_bprintf(&s->seq, fmt, binary);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t\treturn;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_bprintf(struct trace_seq *s, const char *fmt, const u32 *binary)\n{\n\tunsigned int save_len = s->seq.len;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tseq_buf_bprintf(&s->seq, fmt, binary);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t\treturn;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_seq_printf",
          "args": [
            "s",
            "\": %lx : \"",
            "field->ip"
          ],
          "line": 1422
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "81-100",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_assign_type",
          "args": [
            "field",
            "iter->ent"
          ],
          "line": 1420
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nstatic enum print_line_t\ntrace_bprint_raw(struct trace_iterator *iter, int flags,\n\t\t struct trace_event *event)\n{\n\tstruct bprint_entry *field;\n\tstruct trace_seq *s = &iter->seq;\n\n\ttrace_assign_type(field, iter->ent);\n\n\ttrace_seq_printf(s, \": %lx : \", field->ip);\n\ttrace_seq_bprintf(s, field->fmt, field->buf);\n\n\treturn trace_handle_return(s);\n}"
  },
  {
    "function_name": "trace_bprint_print",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_output.c",
    "lines": "1395-1410",
    "snippet": "static enum print_line_t\ntrace_bprint_print(struct trace_iterator *iter, int flags,\n\t\t   struct trace_event *event)\n{\n\tstruct trace_entry *entry = iter->ent;\n\tstruct trace_seq *s = &iter->seq;\n\tstruct bprint_entry *field;\n\n\ttrace_assign_type(field, entry);\n\n\tseq_print_ip_sym(s, field->ip, flags);\n\ttrace_seq_puts(s, \": \");\n\ttrace_seq_bprintf(s, field->fmt, field->buf);\n\n\treturn trace_handle_return(s);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_handle_return",
          "args": [
            "s"
          ],
          "line": 1409
        },
        "resolved": true,
        "details": {
          "function_name": "trace_handle_return",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "2577-2581",
          "snippet": "enum print_line_t trace_handle_return(struct trace_seq *s)\n{\n\treturn trace_seq_has_overflowed(s) ?\n\t\tTRACE_TYPE_PARTIAL_LINE : TRACE_TYPE_HANDLED;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nenum print_line_t trace_handle_return(struct trace_seq *s)\n{\n\treturn trace_seq_has_overflowed(s) ?\n\t\tTRACE_TYPE_PARTIAL_LINE : TRACE_TYPE_HANDLED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_seq_bprintf",
          "args": [
            "s",
            "field->fmt",
            "field->buf"
          ],
          "line": 1407
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_bprintf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "175-192",
          "snippet": "void trace_seq_bprintf(struct trace_seq *s, const char *fmt, const u32 *binary)\n{\n\tunsigned int save_len = s->seq.len;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tseq_buf_bprintf(&s->seq, fmt, binary);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t\treturn;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_bprintf(struct trace_seq *s, const char *fmt, const u32 *binary)\n{\n\tunsigned int save_len = s->seq.len;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tseq_buf_bprintf(&s->seq, fmt, binary);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t\treturn;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_seq_puts",
          "args": [
            "s",
            "\": \""
          ],
          "line": 1406
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_puts",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "205-220",
          "snippet": "void trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_print_ip_sym",
          "args": [
            "s",
            "field->ip",
            "flags"
          ],
          "line": 1405
        },
        "resolved": true,
        "details": {
          "function_name": "seq_print_ip_sym",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_output.c",
          "lines": "416-431",
          "snippet": "int\nseq_print_ip_sym(struct trace_seq *s, unsigned long ip, unsigned long sym_flags)\n{\n\tif (!ip) {\n\t\ttrace_seq_putc(s, '0');\n\t\tgoto out;\n\t}\n\n\ttrace_seq_print_sym(s, ip, sym_flags & TRACE_ITER_SYM_OFFSET);\n\n\tif (sym_flags & TRACE_ITER_SYM_ADDR)\n\t\ttrace_seq_printf(s, \" <\" IP_FMT \">\", ip);\n\n out:\n\treturn !trace_seq_has_overflowed(s);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nint\nseq_print_ip_sym(struct trace_seq *s, unsigned long ip, unsigned long sym_flags)\n{\n\tif (!ip) {\n\t\ttrace_seq_putc(s, '0');\n\t\tgoto out;\n\t}\n\n\ttrace_seq_print_sym(s, ip, sym_flags & TRACE_ITER_SYM_OFFSET);\n\n\tif (sym_flags & TRACE_ITER_SYM_ADDR)\n\t\ttrace_seq_printf(s, \" <\" IP_FMT \">\", ip);\n\n out:\n\treturn !trace_seq_has_overflowed(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_assign_type",
          "args": [
            "field",
            "entry"
          ],
          "line": 1403
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nstatic enum print_line_t\ntrace_bprint_print(struct trace_iterator *iter, int flags,\n\t\t   struct trace_event *event)\n{\n\tstruct trace_entry *entry = iter->ent;\n\tstruct trace_seq *s = &iter->seq;\n\tstruct bprint_entry *field;\n\n\ttrace_assign_type(field, entry);\n\n\tseq_print_ip_sym(s, field->ip, flags);\n\ttrace_seq_puts(s, \": \");\n\ttrace_seq_bprintf(s, field->fmt, field->buf);\n\n\treturn trace_handle_return(s);\n}"
  },
  {
    "function_name": "trace_bputs_raw",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_output.c",
    "lines": "1369-1382",
    "snippet": "static enum print_line_t\ntrace_bputs_raw(struct trace_iterator *iter, int flags,\n\t\tstruct trace_event *event)\n{\n\tstruct bputs_entry *field;\n\tstruct trace_seq *s = &iter->seq;\n\n\ttrace_assign_type(field, iter->ent);\n\n\ttrace_seq_printf(s, \": %lx : \", field->ip);\n\ttrace_seq_puts(s, field->str);\n\n\treturn trace_handle_return(s);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_handle_return",
          "args": [
            "s"
          ],
          "line": 1381
        },
        "resolved": true,
        "details": {
          "function_name": "trace_handle_return",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "2577-2581",
          "snippet": "enum print_line_t trace_handle_return(struct trace_seq *s)\n{\n\treturn trace_seq_has_overflowed(s) ?\n\t\tTRACE_TYPE_PARTIAL_LINE : TRACE_TYPE_HANDLED;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nenum print_line_t trace_handle_return(struct trace_seq *s)\n{\n\treturn trace_seq_has_overflowed(s) ?\n\t\tTRACE_TYPE_PARTIAL_LINE : TRACE_TYPE_HANDLED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_seq_puts",
          "args": [
            "s",
            "field->str"
          ],
          "line": 1379
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_puts",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "205-220",
          "snippet": "void trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_seq_printf",
          "args": [
            "s",
            "\": %lx : \"",
            "field->ip"
          ],
          "line": 1378
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "81-100",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_assign_type",
          "args": [
            "field",
            "iter->ent"
          ],
          "line": 1376
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nstatic enum print_line_t\ntrace_bputs_raw(struct trace_iterator *iter, int flags,\n\t\tstruct trace_event *event)\n{\n\tstruct bputs_entry *field;\n\tstruct trace_seq *s = &iter->seq;\n\n\ttrace_assign_type(field, iter->ent);\n\n\ttrace_seq_printf(s, \": %lx : \", field->ip);\n\ttrace_seq_puts(s, field->str);\n\n\treturn trace_handle_return(s);\n}"
  },
  {
    "function_name": "trace_bputs_print",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_output.c",
    "lines": "1351-1366",
    "snippet": "static enum print_line_t\ntrace_bputs_print(struct trace_iterator *iter, int flags,\n\t\t   struct trace_event *event)\n{\n\tstruct trace_entry *entry = iter->ent;\n\tstruct trace_seq *s = &iter->seq;\n\tstruct bputs_entry *field;\n\n\ttrace_assign_type(field, entry);\n\n\tseq_print_ip_sym(s, field->ip, flags);\n\ttrace_seq_puts(s, \": \");\n\ttrace_seq_puts(s, field->str);\n\n\treturn trace_handle_return(s);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_handle_return",
          "args": [
            "s"
          ],
          "line": 1365
        },
        "resolved": true,
        "details": {
          "function_name": "trace_handle_return",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "2577-2581",
          "snippet": "enum print_line_t trace_handle_return(struct trace_seq *s)\n{\n\treturn trace_seq_has_overflowed(s) ?\n\t\tTRACE_TYPE_PARTIAL_LINE : TRACE_TYPE_HANDLED;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nenum print_line_t trace_handle_return(struct trace_seq *s)\n{\n\treturn trace_seq_has_overflowed(s) ?\n\t\tTRACE_TYPE_PARTIAL_LINE : TRACE_TYPE_HANDLED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_seq_puts",
          "args": [
            "s",
            "field->str"
          ],
          "line": 1363
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_puts",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "205-220",
          "snippet": "void trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_print_ip_sym",
          "args": [
            "s",
            "field->ip",
            "flags"
          ],
          "line": 1361
        },
        "resolved": true,
        "details": {
          "function_name": "seq_print_ip_sym",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_output.c",
          "lines": "416-431",
          "snippet": "int\nseq_print_ip_sym(struct trace_seq *s, unsigned long ip, unsigned long sym_flags)\n{\n\tif (!ip) {\n\t\ttrace_seq_putc(s, '0');\n\t\tgoto out;\n\t}\n\n\ttrace_seq_print_sym(s, ip, sym_flags & TRACE_ITER_SYM_OFFSET);\n\n\tif (sym_flags & TRACE_ITER_SYM_ADDR)\n\t\ttrace_seq_printf(s, \" <\" IP_FMT \">\", ip);\n\n out:\n\treturn !trace_seq_has_overflowed(s);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nint\nseq_print_ip_sym(struct trace_seq *s, unsigned long ip, unsigned long sym_flags)\n{\n\tif (!ip) {\n\t\ttrace_seq_putc(s, '0');\n\t\tgoto out;\n\t}\n\n\ttrace_seq_print_sym(s, ip, sym_flags & TRACE_ITER_SYM_OFFSET);\n\n\tif (sym_flags & TRACE_ITER_SYM_ADDR)\n\t\ttrace_seq_printf(s, \" <\" IP_FMT \">\", ip);\n\n out:\n\treturn !trace_seq_has_overflowed(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_assign_type",
          "args": [
            "field",
            "entry"
          ],
          "line": 1359
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nstatic enum print_line_t\ntrace_bputs_print(struct trace_iterator *iter, int flags,\n\t\t   struct trace_event *event)\n{\n\tstruct trace_entry *entry = iter->ent;\n\tstruct trace_seq *s = &iter->seq;\n\tstruct bputs_entry *field;\n\n\ttrace_assign_type(field, entry);\n\n\tseq_print_ip_sym(s, field->ip, flags);\n\ttrace_seq_puts(s, \": \");\n\ttrace_seq_puts(s, field->str);\n\n\treturn trace_handle_return(s);\n}"
  },
  {
    "function_name": "trace_timerlat_raw",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_output.c",
    "lines": "1323-1338",
    "snippet": "static enum print_line_t\ntrace_timerlat_raw(struct trace_iterator *iter, int flags,\n\t\t   struct trace_event *event)\n{\n\tstruct timerlat_entry *field;\n\tstruct trace_seq *s = &iter->seq;\n\n\ttrace_assign_type(field, iter->ent);\n\n\ttrace_seq_printf(s, \"%u %d %llu\\n\",\n\t\t\t field->seqnum,\n\t\t\t field->context,\n\t\t\t field->timer_latency);\n\n\treturn trace_handle_return(s);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_handle_return",
          "args": [
            "s"
          ],
          "line": 1337
        },
        "resolved": true,
        "details": {
          "function_name": "trace_handle_return",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "2577-2581",
          "snippet": "enum print_line_t trace_handle_return(struct trace_seq *s)\n{\n\treturn trace_seq_has_overflowed(s) ?\n\t\tTRACE_TYPE_PARTIAL_LINE : TRACE_TYPE_HANDLED;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nenum print_line_t trace_handle_return(struct trace_seq *s)\n{\n\treturn trace_seq_has_overflowed(s) ?\n\t\tTRACE_TYPE_PARTIAL_LINE : TRACE_TYPE_HANDLED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_seq_printf",
          "args": [
            "s",
            "\"%u %d %llu\\n\"",
            "field->seqnum",
            "field->context",
            "field->timer_latency"
          ],
          "line": 1332
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "81-100",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_assign_type",
          "args": [
            "field",
            "iter->ent"
          ],
          "line": 1330
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nstatic enum print_line_t\ntrace_timerlat_raw(struct trace_iterator *iter, int flags,\n\t\t   struct trace_event *event)\n{\n\tstruct timerlat_entry *field;\n\tstruct trace_seq *s = &iter->seq;\n\n\ttrace_assign_type(field, iter->ent);\n\n\ttrace_seq_printf(s, \"%u %d %llu\\n\",\n\t\t\t field->seqnum,\n\t\t\t field->context,\n\t\t\t field->timer_latency);\n\n\treturn trace_handle_return(s);\n}"
  },
  {
    "function_name": "trace_timerlat_print",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_output.c",
    "lines": "1305-1321",
    "snippet": "static enum print_line_t\ntrace_timerlat_print(struct trace_iterator *iter, int flags,\n\t\t     struct trace_event *event)\n{\n\tstruct trace_entry *entry = iter->ent;\n\tstruct trace_seq *s = &iter->seq;\n\tstruct timerlat_entry *field;\n\n\ttrace_assign_type(field, entry);\n\n\ttrace_seq_printf(s, \"#%-5u context %6s timer_latency %9llu ns\\n\",\n\t\t\t field->seqnum,\n\t\t\t field->context ? \"thread\" : \"irq\",\n\t\t\t field->timer_latency);\n\n\treturn trace_handle_return(s);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_handle_return",
          "args": [
            "s"
          ],
          "line": 1320
        },
        "resolved": true,
        "details": {
          "function_name": "trace_handle_return",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "2577-2581",
          "snippet": "enum print_line_t trace_handle_return(struct trace_seq *s)\n{\n\treturn trace_seq_has_overflowed(s) ?\n\t\tTRACE_TYPE_PARTIAL_LINE : TRACE_TYPE_HANDLED;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nenum print_line_t trace_handle_return(struct trace_seq *s)\n{\n\treturn trace_seq_has_overflowed(s) ?\n\t\tTRACE_TYPE_PARTIAL_LINE : TRACE_TYPE_HANDLED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_seq_printf",
          "args": [
            "s",
            "\"#%-5u context %6s timer_latency %9llu ns\\n\"",
            "field->seqnum",
            "field->context ? \"thread\" : \"irq\"",
            "field->timer_latency"
          ],
          "line": 1315
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "81-100",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_assign_type",
          "args": [
            "field",
            "entry"
          ],
          "line": 1313
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nstatic enum print_line_t\ntrace_timerlat_print(struct trace_iterator *iter, int flags,\n\t\t     struct trace_event *event)\n{\n\tstruct trace_entry *entry = iter->ent;\n\tstruct trace_seq *s = &iter->seq;\n\tstruct timerlat_entry *field;\n\n\ttrace_assign_type(field, entry);\n\n\ttrace_seq_printf(s, \"#%-5u context %6s timer_latency %9llu ns\\n\",\n\t\t\t field->seqnum,\n\t\t\t field->context ? \"thread\" : \"irq\",\n\t\t\t field->timer_latency);\n\n\treturn trace_handle_return(s);\n}"
  },
  {
    "function_name": "trace_osnoise_raw",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_output.c",
    "lines": "1272-1292",
    "snippet": "static enum print_line_t\ntrace_osnoise_raw(struct trace_iterator *iter, int flags,\n\t\t  struct trace_event *event)\n{\n\tstruct osnoise_entry *field;\n\tstruct trace_seq *s = &iter->seq;\n\n\ttrace_assign_type(field, iter->ent);\n\n\ttrace_seq_printf(s, \"%lld %llu %llu %u %u %u %u %u\\n\",\n\t\t\t field->runtime,\n\t\t\t field->noise,\n\t\t\t field->max_sample,\n\t\t\t field->hw_count,\n\t\t\t field->nmi_count,\n\t\t\t field->irq_count,\n\t\t\t field->softirq_count,\n\t\t\t field->thread_count);\n\n\treturn trace_handle_return(s);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_handle_return",
          "args": [
            "s"
          ],
          "line": 1291
        },
        "resolved": true,
        "details": {
          "function_name": "trace_handle_return",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "2577-2581",
          "snippet": "enum print_line_t trace_handle_return(struct trace_seq *s)\n{\n\treturn trace_seq_has_overflowed(s) ?\n\t\tTRACE_TYPE_PARTIAL_LINE : TRACE_TYPE_HANDLED;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nenum print_line_t trace_handle_return(struct trace_seq *s)\n{\n\treturn trace_seq_has_overflowed(s) ?\n\t\tTRACE_TYPE_PARTIAL_LINE : TRACE_TYPE_HANDLED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_seq_printf",
          "args": [
            "s",
            "\"%lld %llu %llu %u %u %u %u %u\\n\"",
            "field->runtime",
            "field->noise",
            "field->max_sample",
            "field->hw_count",
            "field->nmi_count",
            "field->irq_count",
            "field->softirq_count",
            "field->thread_count"
          ],
          "line": 1281
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "81-100",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_assign_type",
          "args": [
            "field",
            "iter->ent"
          ],
          "line": 1279
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nstatic enum print_line_t\ntrace_osnoise_raw(struct trace_iterator *iter, int flags,\n\t\t  struct trace_event *event)\n{\n\tstruct osnoise_entry *field;\n\tstruct trace_seq *s = &iter->seq;\n\n\ttrace_assign_type(field, iter->ent);\n\n\ttrace_seq_printf(s, \"%lld %llu %llu %u %u %u %u %u\\n\",\n\t\t\t field->runtime,\n\t\t\t field->noise,\n\t\t\t field->max_sample,\n\t\t\t field->hw_count,\n\t\t\t field->nmi_count,\n\t\t\t field->irq_count,\n\t\t\t field->softirq_count,\n\t\t\t field->thread_count);\n\n\treturn trace_handle_return(s);\n}"
  },
  {
    "function_name": "trace_osnoise_print",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_output.c",
    "lines": "1235-1270",
    "snippet": "static enum print_line_t\ntrace_osnoise_print(struct trace_iterator *iter, int flags,\n\t\t    struct trace_event *event)\n{\n\tstruct trace_entry *entry = iter->ent;\n\tstruct trace_seq *s = &iter->seq;\n\tstruct osnoise_entry *field;\n\tu64 ratio, ratio_dec;\n\tu64 net_runtime;\n\n\ttrace_assign_type(field, entry);\n\n\t/*\n\t * compute the available % of cpu time.\n\t */\n\tnet_runtime = field->runtime - field->noise;\n\tratio = net_runtime * 10000000;\n\tdo_div(ratio, field->runtime);\n\tratio_dec = do_div(ratio, 100000);\n\n\ttrace_seq_printf(s, \"%llu %10llu %3llu.%05llu %7llu\",\n\t\t\t field->runtime,\n\t\t\t field->noise,\n\t\t\t ratio, ratio_dec,\n\t\t\t field->max_sample);\n\n\ttrace_seq_printf(s, \" %6u\", field->hw_count);\n\ttrace_seq_printf(s, \" %6u\", field->nmi_count);\n\ttrace_seq_printf(s, \" %6u\", field->irq_count);\n\ttrace_seq_printf(s, \" %6u\", field->softirq_count);\n\ttrace_seq_printf(s, \" %6u\", field->thread_count);\n\n\ttrace_seq_putc(s, '\\n');\n\n\treturn trace_handle_return(s);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_handle_return",
          "args": [
            "s"
          ],
          "line": 1269
        },
        "resolved": true,
        "details": {
          "function_name": "trace_handle_return",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "2577-2581",
          "snippet": "enum print_line_t trace_handle_return(struct trace_seq *s)\n{\n\treturn trace_seq_has_overflowed(s) ?\n\t\tTRACE_TYPE_PARTIAL_LINE : TRACE_TYPE_HANDLED;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nenum print_line_t trace_handle_return(struct trace_seq *s)\n{\n\treturn trace_seq_has_overflowed(s) ?\n\t\tTRACE_TYPE_PARTIAL_LINE : TRACE_TYPE_HANDLED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_seq_putc",
          "args": [
            "s",
            "'\\n'"
          ],
          "line": 1267
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_putc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "233-246",
          "snippet": "void trace_seq_putc(struct trace_seq *s, unsigned char c)\n{\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (TRACE_SEQ_BUF_LEFT(s) < 1) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putc(&s->seq, c);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_putc(struct trace_seq *s, unsigned char c)\n{\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (TRACE_SEQ_BUF_LEFT(s) < 1) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putc(&s->seq, c);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_seq_printf",
          "args": [
            "s",
            "\" %6u\"",
            "field->thread_count"
          ],
          "line": 1265
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "81-100",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_div",
          "args": [
            "ratio",
            "100000"
          ],
          "line": 1253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_div",
          "args": [
            "ratio",
            "field->runtime"
          ],
          "line": 1252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_assign_type",
          "args": [
            "field",
            "entry"
          ],
          "line": 1245
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nstatic enum print_line_t\ntrace_osnoise_print(struct trace_iterator *iter, int flags,\n\t\t    struct trace_event *event)\n{\n\tstruct trace_entry *entry = iter->ent;\n\tstruct trace_seq *s = &iter->seq;\n\tstruct osnoise_entry *field;\n\tu64 ratio, ratio_dec;\n\tu64 net_runtime;\n\n\ttrace_assign_type(field, entry);\n\n\t/*\n\t * compute the available % of cpu time.\n\t */\n\tnet_runtime = field->runtime - field->noise;\n\tratio = net_runtime * 10000000;\n\tdo_div(ratio, field->runtime);\n\tratio_dec = do_div(ratio, 100000);\n\n\ttrace_seq_printf(s, \"%llu %10llu %3llu.%05llu %7llu\",\n\t\t\t field->runtime,\n\t\t\t field->noise,\n\t\t\t ratio, ratio_dec,\n\t\t\t field->max_sample);\n\n\ttrace_seq_printf(s, \" %6u\", field->hw_count);\n\ttrace_seq_printf(s, \" %6u\", field->nmi_count);\n\ttrace_seq_printf(s, \" %6u\", field->irq_count);\n\ttrace_seq_printf(s, \" %6u\", field->softirq_count);\n\ttrace_seq_printf(s, \" %6u\", field->thread_count);\n\n\ttrace_seq_putc(s, '\\n');\n\n\treturn trace_handle_return(s);\n}"
  },
  {
    "function_name": "trace_hwlat_raw",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_output.c",
    "lines": "1205-1222",
    "snippet": "static enum print_line_t\ntrace_hwlat_raw(struct trace_iterator *iter, int flags,\n\t\tstruct trace_event *event)\n{\n\tstruct hwlat_entry *field;\n\tstruct trace_seq *s = &iter->seq;\n\n\ttrace_assign_type(field, iter->ent);\n\n\ttrace_seq_printf(s, \"%llu %lld %lld %09ld %u\\n\",\n\t\t\t field->duration,\n\t\t\t field->outer_duration,\n\t\t\t (long long)field->timestamp.tv_sec,\n\t\t\t field->timestamp.tv_nsec,\n\t\t\t field->seqnum);\n\n\treturn trace_handle_return(s);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_handle_return",
          "args": [
            "s"
          ],
          "line": 1221
        },
        "resolved": true,
        "details": {
          "function_name": "trace_handle_return",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "2577-2581",
          "snippet": "enum print_line_t trace_handle_return(struct trace_seq *s)\n{\n\treturn trace_seq_has_overflowed(s) ?\n\t\tTRACE_TYPE_PARTIAL_LINE : TRACE_TYPE_HANDLED;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nenum print_line_t trace_handle_return(struct trace_seq *s)\n{\n\treturn trace_seq_has_overflowed(s) ?\n\t\tTRACE_TYPE_PARTIAL_LINE : TRACE_TYPE_HANDLED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_seq_printf",
          "args": [
            "s",
            "\"%llu %lld %lld %09ld %u\\n\"",
            "field->duration",
            "field->outer_duration",
            "(long long)field->timestamp.tv_sec",
            "field->timestamp.tv_nsec",
            "field->seqnum"
          ],
          "line": 1214
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "81-100",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_assign_type",
          "args": [
            "field",
            "iter->ent"
          ],
          "line": 1212
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nstatic enum print_line_t\ntrace_hwlat_raw(struct trace_iterator *iter, int flags,\n\t\tstruct trace_event *event)\n{\n\tstruct hwlat_entry *field;\n\tstruct trace_seq *s = &iter->seq;\n\n\ttrace_assign_type(field, iter->ent);\n\n\ttrace_seq_printf(s, \"%llu %lld %lld %09ld %u\\n\",\n\t\t\t field->duration,\n\t\t\t field->outer_duration,\n\t\t\t (long long)field->timestamp.tv_sec,\n\t\t\t field->timestamp.tv_nsec,\n\t\t\t field->seqnum);\n\n\treturn trace_handle_return(s);\n}"
  },
  {
    "function_name": "trace_hwlat_print",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_output.c",
    "lines": "1171-1203",
    "snippet": "static enum print_line_t\ntrace_hwlat_print(struct trace_iterator *iter, int flags,\n\t\t  struct trace_event *event)\n{\n\tstruct trace_entry *entry = iter->ent;\n\tstruct trace_seq *s = &iter->seq;\n\tstruct hwlat_entry *field;\n\n\ttrace_assign_type(field, entry);\n\n\ttrace_seq_printf(s, \"#%-5u inner/outer(us): %4llu/%-5llu ts:%lld.%09ld count:%d\",\n\t\t\t field->seqnum,\n\t\t\t field->duration,\n\t\t\t field->outer_duration,\n\t\t\t (long long)field->timestamp.tv_sec,\n\t\t\t field->timestamp.tv_nsec, field->count);\n\n\tif (field->nmi_count) {\n\t\t/*\n\t\t * The generic sched_clock() is not NMI safe, thus\n\t\t * we only record the count and not the time.\n\t\t */\n\t\tif (!IS_ENABLED(CONFIG_GENERIC_SCHED_CLOCK))\n\t\t\ttrace_seq_printf(s, \" nmi-total:%llu\",\n\t\t\t\t\t field->nmi_total_ts);\n\t\ttrace_seq_printf(s, \" nmi-count:%u\",\n\t\t\t\t field->nmi_count);\n\t}\n\n\ttrace_seq_putc(s, '\\n');\n\n\treturn trace_handle_return(s);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_handle_return",
          "args": [
            "s"
          ],
          "line": 1202
        },
        "resolved": true,
        "details": {
          "function_name": "trace_handle_return",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "2577-2581",
          "snippet": "enum print_line_t trace_handle_return(struct trace_seq *s)\n{\n\treturn trace_seq_has_overflowed(s) ?\n\t\tTRACE_TYPE_PARTIAL_LINE : TRACE_TYPE_HANDLED;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nenum print_line_t trace_handle_return(struct trace_seq *s)\n{\n\treturn trace_seq_has_overflowed(s) ?\n\t\tTRACE_TYPE_PARTIAL_LINE : TRACE_TYPE_HANDLED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_seq_putc",
          "args": [
            "s",
            "'\\n'"
          ],
          "line": 1200
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_putc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "233-246",
          "snippet": "void trace_seq_putc(struct trace_seq *s, unsigned char c)\n{\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (TRACE_SEQ_BUF_LEFT(s) < 1) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putc(&s->seq, c);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_putc(struct trace_seq *s, unsigned char c)\n{\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (TRACE_SEQ_BUF_LEFT(s) < 1) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putc(&s->seq, c);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_seq_printf",
          "args": [
            "s",
            "\" nmi-count:%u\"",
            "field->nmi_count"
          ],
          "line": 1196
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "81-100",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_GENERIC_SCHED_CLOCK"
          ],
          "line": 1193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_assign_type",
          "args": [
            "field",
            "entry"
          ],
          "line": 1179
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nstatic enum print_line_t\ntrace_hwlat_print(struct trace_iterator *iter, int flags,\n\t\t  struct trace_event *event)\n{\n\tstruct trace_entry *entry = iter->ent;\n\tstruct trace_seq *s = &iter->seq;\n\tstruct hwlat_entry *field;\n\n\ttrace_assign_type(field, entry);\n\n\ttrace_seq_printf(s, \"#%-5u inner/outer(us): %4llu/%-5llu ts:%lld.%09ld count:%d\",\n\t\t\t field->seqnum,\n\t\t\t field->duration,\n\t\t\t field->outer_duration,\n\t\t\t (long long)field->timestamp.tv_sec,\n\t\t\t field->timestamp.tv_nsec, field->count);\n\n\tif (field->nmi_count) {\n\t\t/*\n\t\t * The generic sched_clock() is not NMI safe, thus\n\t\t * we only record the count and not the time.\n\t\t */\n\t\tif (!IS_ENABLED(CONFIG_GENERIC_SCHED_CLOCK))\n\t\t\ttrace_seq_printf(s, \" nmi-total:%llu\",\n\t\t\t\t\t field->nmi_total_ts);\n\t\ttrace_seq_printf(s, \" nmi-count:%u\",\n\t\t\t\t field->nmi_count);\n\t}\n\n\ttrace_seq_putc(s, '\\n');\n\n\treturn trace_handle_return(s);\n}"
  },
  {
    "function_name": "trace_user_stack_print",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_output.c",
    "lines": "1118-1159",
    "snippet": "static enum print_line_t trace_user_stack_print(struct trace_iterator *iter,\n\t\t\t\t\t\tint flags, struct trace_event *event)\n{\n\tstruct trace_array *tr = iter->tr;\n\tstruct userstack_entry *field;\n\tstruct trace_seq *s = &iter->seq;\n\tstruct mm_struct *mm = NULL;\n\tunsigned int i;\n\n\ttrace_assign_type(field, iter->ent);\n\n\ttrace_seq_puts(s, \"<user stack trace>\\n\");\n\n\tif (tr->trace_flags & TRACE_ITER_SYM_USEROBJ) {\n\t\tstruct task_struct *task;\n\t\t/*\n\t\t * we do the lookup on the thread group leader,\n\t\t * since individual threads might have already quit!\n\t\t */\n\t\trcu_read_lock();\n\t\ttask = find_task_by_vpid(field->tgid);\n\t\tif (task)\n\t\t\tmm = get_task_mm(task);\n\t\trcu_read_unlock();\n\t}\n\n\tfor (i = 0; i < FTRACE_STACK_ENTRIES; i++) {\n\t\tunsigned long ip = field->caller[i];\n\n\t\tif (!ip || trace_seq_has_overflowed(s))\n\t\t\tbreak;\n\n\t\ttrace_seq_puts(s, \" => \");\n\t\tseq_print_user_ip(s, mm, ip, flags);\n\t\ttrace_seq_putc(s, '\\n');\n\t}\n\n\tif (mm)\n\t\tmmput(mm);\n\n\treturn trace_handle_return(s);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_handle_return",
          "args": [
            "s"
          ],
          "line": 1158
        },
        "resolved": true,
        "details": {
          "function_name": "trace_handle_return",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "2577-2581",
          "snippet": "enum print_line_t trace_handle_return(struct trace_seq *s)\n{\n\treturn trace_seq_has_overflowed(s) ?\n\t\tTRACE_TYPE_PARTIAL_LINE : TRACE_TYPE_HANDLED;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nenum print_line_t trace_handle_return(struct trace_seq *s)\n{\n\treturn trace_seq_has_overflowed(s) ?\n\t\tTRACE_TYPE_PARTIAL_LINE : TRACE_TYPE_HANDLED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mmput",
          "args": [
            "mm"
          ],
          "line": 1156
        },
        "resolved": true,
        "details": {
          "function_name": "mmput_async",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/fork.c",
          "lines": "1148-1154",
          "snippet": "void mmput_async(struct mm_struct *mm)\n{\n\tif (atomic_dec_and_test(&mm->mm_users)) {\n\t\tINIT_WORK(&mm->async_put_work, mmput_async_fn);\n\t\tschedule_work(&mm->async_put_work);\n\t}\n}",
          "includes": [
            "#include <linux/init_task.h>",
            "#include <trace/events/task.h>",
            "#include <trace/events/sched.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <linux/bpf.h>",
            "#include <linux/io_uring.h>",
            "#include <linux/scs.h>",
            "#include <linux/kasan.h>",
            "#include <linux/stackleak.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/kcov.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/compiler.h>",
            "#include <linux/aio.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/oom.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/magic.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/tty.h>",
            "#include <linux/random.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/acct.h>",
            "#include <linux/ksm.h>",
            "#include <linux/rmap.h>",
            "#include <linux/profile.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/kthread.h>",
            "#include <linux/compat.h>",
            "#include <linux/futex.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mman.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/sem.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>",
            "#include <linux/unistd.h>",
            "#include <linux/init.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/anon_inodes.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __latent_entropy struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/init_task.h>\n#include <trace/events/task.h>\n#include <trace/events/sched.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <linux/bpf.h>\n#include <linux/io_uring.h>\n#include <linux/scs.h>\n#include <linux/kasan.h>\n#include <linux/stackleak.h>\n#include <linux/thread_info.h>\n#include <linux/livepatch.h>\n#include <linux/kcov.h>\n#include <linux/sysctl.h>\n#include <linux/compiler.h>\n#include <linux/aio.h>\n#include <linux/uprobes.h>\n#include <linux/signalfd.h>\n#include <linux/khugepaged.h>\n#include <linux/oom.h>\n#include <linux/user-return-notifier.h>\n#include <linux/posix-timers.h>\n#include <linux/perf_event.h>\n#include <linux/magic.h>\n#include <linux/fs_struct.h>\n#include <linux/tty.h>\n#include <linux/random.h>\n#include <linux/taskstats_kern.h>\n#include <linux/delayacct.h>\n#include <linux/freezer.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/acct.h>\n#include <linux/ksm.h>\n#include <linux/rmap.h>\n#include <linux/profile.h>\n#include <linux/proc_fs.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/ptrace.h>\n#include <linux/rcupdate.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/kthread.h>\n#include <linux/compat.h>\n#include <linux/futex.h>\n#include <linux/jiffies.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/seccomp.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/cgroup.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/nsproxy.h>\n#include <linux/vmacache.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mman.h>\n#include <linux/binfmts.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/sem.h>\n#include <linux/mempolicy.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/unistd.h>\n#include <linux/init.h>\n#include <linux/rtmutex.h>\n#include <linux/seq_file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/user.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/anon_inodes.h>\n\nstatic __latent_entropy struct;\n\nvoid mmput_async(struct mm_struct *mm)\n{\n\tif (atomic_dec_and_test(&mm->mm_users)) {\n\t\tINIT_WORK(&mm->async_put_work, mmput_async_fn);\n\t\tschedule_work(&mm->async_put_work);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_seq_putc",
          "args": [
            "s",
            "'\\n'"
          ],
          "line": 1152
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_putc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "233-246",
          "snippet": "void trace_seq_putc(struct trace_seq *s, unsigned char c)\n{\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (TRACE_SEQ_BUF_LEFT(s) < 1) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putc(&s->seq, c);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_putc(struct trace_seq *s, unsigned char c)\n{\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (TRACE_SEQ_BUF_LEFT(s) < 1) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putc(&s->seq, c);\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_print_user_ip",
          "args": [
            "s",
            "mm",
            "ip",
            "flags"
          ],
          "line": 1151
        },
        "resolved": true,
        "details": {
          "function_name": "seq_print_user_ip",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_output.c",
          "lines": "384-414",
          "snippet": "static int seq_print_user_ip(struct trace_seq *s, struct mm_struct *mm,\n\t\t\t     unsigned long ip, unsigned long sym_flags)\n{\n\tstruct file *file = NULL;\n\tunsigned long vmstart = 0;\n\tint ret = 1;\n\n\tif (s->full)\n\t\treturn 0;\n\n\tif (mm) {\n\t\tconst struct vm_area_struct *vma;\n\n\t\tmmap_read_lock(mm);\n\t\tvma = find_vma(mm, ip);\n\t\tif (vma) {\n\t\t\tfile = vma->vm_file;\n\t\t\tvmstart = vma->vm_start;\n\t\t}\n\t\tif (file) {\n\t\t\tret = trace_seq_path(s, &file->f_path);\n\t\t\tif (ret)\n\t\t\t\ttrace_seq_printf(s, \"[+0x%lx]\",\n\t\t\t\t\t\t ip - vmstart);\n\t\t}\n\t\tmmap_read_unlock(mm);\n\t}\n\tif (ret && ((sym_flags & TRACE_ITER_SYM_ADDR) || !file))\n\t\ttrace_seq_printf(s, \" <\" IP_FMT \">\", ip);\n\treturn !trace_seq_has_overflowed(s);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nstatic int seq_print_user_ip(struct trace_seq *s, struct mm_struct *mm,\n\t\t\t     unsigned long ip, unsigned long sym_flags)\n{\n\tstruct file *file = NULL;\n\tunsigned long vmstart = 0;\n\tint ret = 1;\n\n\tif (s->full)\n\t\treturn 0;\n\n\tif (mm) {\n\t\tconst struct vm_area_struct *vma;\n\n\t\tmmap_read_lock(mm);\n\t\tvma = find_vma(mm, ip);\n\t\tif (vma) {\n\t\t\tfile = vma->vm_file;\n\t\t\tvmstart = vma->vm_start;\n\t\t}\n\t\tif (file) {\n\t\t\tret = trace_seq_path(s, &file->f_path);\n\t\t\tif (ret)\n\t\t\t\ttrace_seq_printf(s, \"[+0x%lx]\",\n\t\t\t\t\t\t ip - vmstart);\n\t\t}\n\t\tmmap_read_unlock(mm);\n\t}\n\tif (ret && ((sym_flags & TRACE_ITER_SYM_ADDR) || !file))\n\t\ttrace_seq_printf(s, \" <\" IP_FMT \">\", ip);\n\treturn !trace_seq_has_overflowed(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_seq_puts",
          "args": [
            "s",
            "\" => \""
          ],
          "line": 1150
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_puts",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "205-220",
          "snippet": "void trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_seq_has_overflowed",
          "args": [
            "s"
          ],
          "line": 1147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 1141
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_unlock_strict",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "815-824",
          "snippet": "void rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nvoid rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_task_mm",
          "args": [
            "task"
          ],
          "line": 1140
        },
        "resolved": true,
        "details": {
          "function_name": "get_task_mm",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/fork.c",
          "lines": "1297-1311",
          "snippet": "struct mm_struct *get_task_mm(struct task_struct *task)\n{\n\tstruct mm_struct *mm;\n\n\ttask_lock(task);\n\tmm = task->mm;\n\tif (mm) {\n\t\tif (task->flags & PF_KTHREAD)\n\t\t\tmm = NULL;\n\t\telse\n\t\t\tmmget(mm);\n\t}\n\ttask_unlock(task);\n\treturn mm;\n}",
          "includes": [
            "#include <linux/init_task.h>",
            "#include <trace/events/task.h>",
            "#include <trace/events/sched.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <linux/bpf.h>",
            "#include <linux/io_uring.h>",
            "#include <linux/scs.h>",
            "#include <linux/kasan.h>",
            "#include <linux/stackleak.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/kcov.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/compiler.h>",
            "#include <linux/aio.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/oom.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/magic.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/tty.h>",
            "#include <linux/random.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/acct.h>",
            "#include <linux/ksm.h>",
            "#include <linux/rmap.h>",
            "#include <linux/profile.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/kthread.h>",
            "#include <linux/compat.h>",
            "#include <linux/futex.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mman.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/sem.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>",
            "#include <linux/unistd.h>",
            "#include <linux/init.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/anon_inodes.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __latent_entropy struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/init_task.h>\n#include <trace/events/task.h>\n#include <trace/events/sched.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <linux/bpf.h>\n#include <linux/io_uring.h>\n#include <linux/scs.h>\n#include <linux/kasan.h>\n#include <linux/stackleak.h>\n#include <linux/thread_info.h>\n#include <linux/livepatch.h>\n#include <linux/kcov.h>\n#include <linux/sysctl.h>\n#include <linux/compiler.h>\n#include <linux/aio.h>\n#include <linux/uprobes.h>\n#include <linux/signalfd.h>\n#include <linux/khugepaged.h>\n#include <linux/oom.h>\n#include <linux/user-return-notifier.h>\n#include <linux/posix-timers.h>\n#include <linux/perf_event.h>\n#include <linux/magic.h>\n#include <linux/fs_struct.h>\n#include <linux/tty.h>\n#include <linux/random.h>\n#include <linux/taskstats_kern.h>\n#include <linux/delayacct.h>\n#include <linux/freezer.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/acct.h>\n#include <linux/ksm.h>\n#include <linux/rmap.h>\n#include <linux/profile.h>\n#include <linux/proc_fs.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/ptrace.h>\n#include <linux/rcupdate.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/kthread.h>\n#include <linux/compat.h>\n#include <linux/futex.h>\n#include <linux/jiffies.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/seccomp.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/cgroup.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/nsproxy.h>\n#include <linux/vmacache.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mman.h>\n#include <linux/binfmts.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/sem.h>\n#include <linux/mempolicy.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/unistd.h>\n#include <linux/init.h>\n#include <linux/rtmutex.h>\n#include <linux/seq_file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/user.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/anon_inodes.h>\n\nstatic __latent_entropy struct;\n\nstruct mm_struct *get_task_mm(struct task_struct *task)\n{\n\tstruct mm_struct *mm;\n\n\ttask_lock(task);\n\tmm = task->mm;\n\tif (mm) {\n\t\tif (task->flags & PF_KTHREAD)\n\t\t\tmm = NULL;\n\t\telse\n\t\t\tmmget(mm);\n\t}\n\ttask_unlock(task);\n\treturn mm;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_task_by_vpid",
          "args": [
            "field->tgid"
          ],
          "line": 1138
        },
        "resolved": true,
        "details": {
          "function_name": "find_task_by_vpid",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/pid.c",
          "lines": "420-423",
          "snippet": "struct task_struct *find_task_by_vpid(pid_t vnr)\n{\n\treturn find_task_by_pid_ns(vnr, task_active_pid_ns(current));\n}",
          "includes": [
            "#include <uapi/linux/pidfd.h>",
            "#include <net/sock.h>",
            "#include <linux/idr.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/refcount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/init_task.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/memblock.h>",
            "#include <linux/rculist.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/pidfd.h>\n#include <net/sock.h>\n#include <linux/idr.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/anon_inodes.h>\n#include <linux/refcount.h>\n#include <linux/proc_ns.h>\n#include <linux/syscalls.h>\n#include <linux/init_task.h>\n#include <linux/pid_namespace.h>\n#include <linux/memblock.h>\n#include <linux/rculist.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\nstruct task_struct *find_task_by_vpid(pid_t vnr)\n{\n\treturn find_task_by_pid_ns(vnr, task_active_pid_ns(current));\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 1137
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_any_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "340-351",
          "snippet": "int rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_assign_type",
          "args": [
            "field",
            "iter->ent"
          ],
          "line": 1127
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nstatic enum print_line_t trace_user_stack_print(struct trace_iterator *iter,\n\t\t\t\t\t\tint flags, struct trace_event *event)\n{\n\tstruct trace_array *tr = iter->tr;\n\tstruct userstack_entry *field;\n\tstruct trace_seq *s = &iter->seq;\n\tstruct mm_struct *mm = NULL;\n\tunsigned int i;\n\n\ttrace_assign_type(field, iter->ent);\n\n\ttrace_seq_puts(s, \"<user stack trace>\\n\");\n\n\tif (tr->trace_flags & TRACE_ITER_SYM_USEROBJ) {\n\t\tstruct task_struct *task;\n\t\t/*\n\t\t * we do the lookup on the thread group leader,\n\t\t * since individual threads might have already quit!\n\t\t */\n\t\trcu_read_lock();\n\t\ttask = find_task_by_vpid(field->tgid);\n\t\tif (task)\n\t\t\tmm = get_task_mm(task);\n\t\trcu_read_unlock();\n\t}\n\n\tfor (i = 0; i < FTRACE_STACK_ENTRIES; i++) {\n\t\tunsigned long ip = field->caller[i];\n\n\t\tif (!ip || trace_seq_has_overflowed(s))\n\t\t\tbreak;\n\n\t\ttrace_seq_puts(s, \" => \");\n\t\tseq_print_user_ip(s, mm, ip, flags);\n\t\ttrace_seq_putc(s, '\\n');\n\t}\n\n\tif (mm)\n\t\tmmput(mm);\n\n\treturn trace_handle_return(s);\n}"
  },
  {
    "function_name": "trace_stack_print",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_output.c",
    "lines": "1082-1106",
    "snippet": "static enum print_line_t trace_stack_print(struct trace_iterator *iter,\n\t\t\t\t\t   int flags, struct trace_event *event)\n{\n\tstruct stack_entry *field;\n\tstruct trace_seq *s = &iter->seq;\n\tunsigned long *p;\n\tunsigned long *end;\n\n\ttrace_assign_type(field, iter->ent);\n\tend = (unsigned long *)((long)iter->ent + iter->ent_size);\n\n\ttrace_seq_puts(s, \"<stack trace>\\n\");\n\n\tfor (p = field->caller; p && p < end && *p != ULONG_MAX; p++) {\n\n\t\tif (trace_seq_has_overflowed(s))\n\t\t\tbreak;\n\n\t\ttrace_seq_puts(s, \" => \");\n\t\tseq_print_ip_sym(s, *p, flags);\n\t\ttrace_seq_putc(s, '\\n');\n\t}\n\n\treturn trace_handle_return(s);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_handle_return",
          "args": [
            "s"
          ],
          "line": 1105
        },
        "resolved": true,
        "details": {
          "function_name": "trace_handle_return",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "2577-2581",
          "snippet": "enum print_line_t trace_handle_return(struct trace_seq *s)\n{\n\treturn trace_seq_has_overflowed(s) ?\n\t\tTRACE_TYPE_PARTIAL_LINE : TRACE_TYPE_HANDLED;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nenum print_line_t trace_handle_return(struct trace_seq *s)\n{\n\treturn trace_seq_has_overflowed(s) ?\n\t\tTRACE_TYPE_PARTIAL_LINE : TRACE_TYPE_HANDLED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_seq_putc",
          "args": [
            "s",
            "'\\n'"
          ],
          "line": 1102
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_putc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "233-246",
          "snippet": "void trace_seq_putc(struct trace_seq *s, unsigned char c)\n{\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (TRACE_SEQ_BUF_LEFT(s) < 1) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putc(&s->seq, c);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_putc(struct trace_seq *s, unsigned char c)\n{\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (TRACE_SEQ_BUF_LEFT(s) < 1) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putc(&s->seq, c);\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_print_ip_sym",
          "args": [
            "s",
            "*p",
            "flags"
          ],
          "line": 1101
        },
        "resolved": true,
        "details": {
          "function_name": "seq_print_ip_sym",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_output.c",
          "lines": "416-431",
          "snippet": "int\nseq_print_ip_sym(struct trace_seq *s, unsigned long ip, unsigned long sym_flags)\n{\n\tif (!ip) {\n\t\ttrace_seq_putc(s, '0');\n\t\tgoto out;\n\t}\n\n\ttrace_seq_print_sym(s, ip, sym_flags & TRACE_ITER_SYM_OFFSET);\n\n\tif (sym_flags & TRACE_ITER_SYM_ADDR)\n\t\ttrace_seq_printf(s, \" <\" IP_FMT \">\", ip);\n\n out:\n\treturn !trace_seq_has_overflowed(s);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nint\nseq_print_ip_sym(struct trace_seq *s, unsigned long ip, unsigned long sym_flags)\n{\n\tif (!ip) {\n\t\ttrace_seq_putc(s, '0');\n\t\tgoto out;\n\t}\n\n\ttrace_seq_print_sym(s, ip, sym_flags & TRACE_ITER_SYM_OFFSET);\n\n\tif (sym_flags & TRACE_ITER_SYM_ADDR)\n\t\ttrace_seq_printf(s, \" <\" IP_FMT \">\", ip);\n\n out:\n\treturn !trace_seq_has_overflowed(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_seq_puts",
          "args": [
            "s",
            "\" => \""
          ],
          "line": 1100
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_puts",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "205-220",
          "snippet": "void trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_seq_has_overflowed",
          "args": [
            "s"
          ],
          "line": 1097
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_assign_type",
          "args": [
            "field",
            "iter->ent"
          ],
          "line": 1090
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nstatic enum print_line_t trace_stack_print(struct trace_iterator *iter,\n\t\t\t\t\t   int flags, struct trace_event *event)\n{\n\tstruct stack_entry *field;\n\tstruct trace_seq *s = &iter->seq;\n\tunsigned long *p;\n\tunsigned long *end;\n\n\ttrace_assign_type(field, iter->ent);\n\tend = (unsigned long *)((long)iter->ent + iter->ent_size);\n\n\ttrace_seq_puts(s, \"<stack trace>\\n\");\n\n\tfor (p = field->caller; p && p < end && *p != ULONG_MAX; p++) {\n\n\t\tif (trace_seq_has_overflowed(s))\n\t\t\tbreak;\n\n\t\ttrace_seq_puts(s, \" => \");\n\t\tseq_print_ip_sym(s, *p, flags);\n\t\ttrace_seq_putc(s, '\\n');\n\t}\n\n\treturn trace_handle_return(s);\n}"
  },
  {
    "function_name": "trace_ctxwake_bin",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_output.c",
    "lines": "1037-1054",
    "snippet": "static enum print_line_t trace_ctxwake_bin(struct trace_iterator *iter,\n\t\t\t\t\t   int flags, struct trace_event *event)\n{\n\tstruct ctx_switch_entry *field;\n\tstruct trace_seq *s = &iter->seq;\n\n\ttrace_assign_type(field, iter->ent);\n\n\tSEQ_PUT_FIELD(s, field->prev_pid);\n\tSEQ_PUT_FIELD(s, field->prev_prio);\n\tSEQ_PUT_FIELD(s, field->prev_state);\n\tSEQ_PUT_FIELD(s, field->next_cpu);\n\tSEQ_PUT_FIELD(s, field->next_pid);\n\tSEQ_PUT_FIELD(s, field->next_prio);\n\tSEQ_PUT_FIELD(s, field->next_state);\n\n\treturn trace_handle_return(s);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_handle_return",
          "args": [
            "s"
          ],
          "line": 1053
        },
        "resolved": true,
        "details": {
          "function_name": "trace_handle_return",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "2577-2581",
          "snippet": "enum print_line_t trace_handle_return(struct trace_seq *s)\n{\n\treturn trace_seq_has_overflowed(s) ?\n\t\tTRACE_TYPE_PARTIAL_LINE : TRACE_TYPE_HANDLED;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nenum print_line_t trace_handle_return(struct trace_seq *s)\n{\n\treturn trace_seq_has_overflowed(s) ?\n\t\tTRACE_TYPE_PARTIAL_LINE : TRACE_TYPE_HANDLED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SEQ_PUT_FIELD",
          "args": [
            "s",
            "field->next_state"
          ],
          "line": 1051
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SEQ_PUT_FIELD",
          "args": [
            "s",
            "field->next_prio"
          ],
          "line": 1050
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SEQ_PUT_FIELD",
          "args": [
            "s",
            "field->next_pid"
          ],
          "line": 1049
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SEQ_PUT_FIELD",
          "args": [
            "s",
            "field->next_cpu"
          ],
          "line": 1048
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SEQ_PUT_FIELD",
          "args": [
            "s",
            "field->prev_state"
          ],
          "line": 1047
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SEQ_PUT_FIELD",
          "args": [
            "s",
            "field->prev_prio"
          ],
          "line": 1046
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SEQ_PUT_FIELD",
          "args": [
            "s",
            "field->prev_pid"
          ],
          "line": 1045
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_assign_type",
          "args": [
            "field",
            "iter->ent"
          ],
          "line": 1043
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nstatic enum print_line_t trace_ctxwake_bin(struct trace_iterator *iter,\n\t\t\t\t\t   int flags, struct trace_event *event)\n{\n\tstruct ctx_switch_entry *field;\n\tstruct trace_seq *s = &iter->seq;\n\n\ttrace_assign_type(field, iter->ent);\n\n\tSEQ_PUT_FIELD(s, field->prev_pid);\n\tSEQ_PUT_FIELD(s, field->prev_prio);\n\tSEQ_PUT_FIELD(s, field->prev_state);\n\tSEQ_PUT_FIELD(s, field->next_cpu);\n\tSEQ_PUT_FIELD(s, field->next_pid);\n\tSEQ_PUT_FIELD(s, field->next_prio);\n\tSEQ_PUT_FIELD(s, field->next_state);\n\n\treturn trace_handle_return(s);\n}"
  },
  {
    "function_name": "trace_wake_hex",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_output.c",
    "lines": "1031-1035",
    "snippet": "static enum print_line_t trace_wake_hex(struct trace_iterator *iter, int flags,\n\t\t\t\t\tstruct trace_event *event)\n{\n\treturn trace_ctxwake_hex(iter, '+');\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_ctxwake_hex",
          "args": [
            "iter",
            "'+'"
          ],
          "line": 1034
        },
        "resolved": true,
        "details": {
          "function_name": "trace_ctxwake_hex",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_output.c",
          "lines": "1002-1023",
          "snippet": "static int trace_ctxwake_hex(struct trace_iterator *iter, char S)\n{\n\tstruct ctx_switch_entry *field;\n\tstruct trace_seq *s = &iter->seq;\n\tint T;\n\n\ttrace_assign_type(field, iter->ent);\n\n\tif (!S)\n\t\tS = task_index_to_char(field->prev_state);\n\tT = task_index_to_char(field->next_state);\n\n\tSEQ_PUT_HEX_FIELD(s, field->prev_pid);\n\tSEQ_PUT_HEX_FIELD(s, field->prev_prio);\n\tSEQ_PUT_HEX_FIELD(s, S);\n\tSEQ_PUT_HEX_FIELD(s, field->next_cpu);\n\tSEQ_PUT_HEX_FIELD(s, field->next_pid);\n\tSEQ_PUT_HEX_FIELD(s, field->next_prio);\n\tSEQ_PUT_HEX_FIELD(s, T);\n\n\treturn trace_handle_return(s);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nstatic int trace_ctxwake_hex(struct trace_iterator *iter, char S)\n{\n\tstruct ctx_switch_entry *field;\n\tstruct trace_seq *s = &iter->seq;\n\tint T;\n\n\ttrace_assign_type(field, iter->ent);\n\n\tif (!S)\n\t\tS = task_index_to_char(field->prev_state);\n\tT = task_index_to_char(field->next_state);\n\n\tSEQ_PUT_HEX_FIELD(s, field->prev_pid);\n\tSEQ_PUT_HEX_FIELD(s, field->prev_prio);\n\tSEQ_PUT_HEX_FIELD(s, S);\n\tSEQ_PUT_HEX_FIELD(s, field->next_cpu);\n\tSEQ_PUT_HEX_FIELD(s, field->next_pid);\n\tSEQ_PUT_HEX_FIELD(s, field->next_prio);\n\tSEQ_PUT_HEX_FIELD(s, T);\n\n\treturn trace_handle_return(s);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nstatic enum print_line_t trace_wake_hex(struct trace_iterator *iter, int flags,\n\t\t\t\t\tstruct trace_event *event)\n{\n\treturn trace_ctxwake_hex(iter, '+');\n}"
  },
  {
    "function_name": "trace_ctx_hex",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_output.c",
    "lines": "1025-1029",
    "snippet": "static enum print_line_t trace_ctx_hex(struct trace_iterator *iter, int flags,\n\t\t\t\t       struct trace_event *event)\n{\n\treturn trace_ctxwake_hex(iter, 0);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_ctxwake_hex",
          "args": [
            "iter",
            "0"
          ],
          "line": 1028
        },
        "resolved": true,
        "details": {
          "function_name": "trace_ctxwake_hex",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_output.c",
          "lines": "1002-1023",
          "snippet": "static int trace_ctxwake_hex(struct trace_iterator *iter, char S)\n{\n\tstruct ctx_switch_entry *field;\n\tstruct trace_seq *s = &iter->seq;\n\tint T;\n\n\ttrace_assign_type(field, iter->ent);\n\n\tif (!S)\n\t\tS = task_index_to_char(field->prev_state);\n\tT = task_index_to_char(field->next_state);\n\n\tSEQ_PUT_HEX_FIELD(s, field->prev_pid);\n\tSEQ_PUT_HEX_FIELD(s, field->prev_prio);\n\tSEQ_PUT_HEX_FIELD(s, S);\n\tSEQ_PUT_HEX_FIELD(s, field->next_cpu);\n\tSEQ_PUT_HEX_FIELD(s, field->next_pid);\n\tSEQ_PUT_HEX_FIELD(s, field->next_prio);\n\tSEQ_PUT_HEX_FIELD(s, T);\n\n\treturn trace_handle_return(s);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nstatic int trace_ctxwake_hex(struct trace_iterator *iter, char S)\n{\n\tstruct ctx_switch_entry *field;\n\tstruct trace_seq *s = &iter->seq;\n\tint T;\n\n\ttrace_assign_type(field, iter->ent);\n\n\tif (!S)\n\t\tS = task_index_to_char(field->prev_state);\n\tT = task_index_to_char(field->next_state);\n\n\tSEQ_PUT_HEX_FIELD(s, field->prev_pid);\n\tSEQ_PUT_HEX_FIELD(s, field->prev_prio);\n\tSEQ_PUT_HEX_FIELD(s, S);\n\tSEQ_PUT_HEX_FIELD(s, field->next_cpu);\n\tSEQ_PUT_HEX_FIELD(s, field->next_pid);\n\tSEQ_PUT_HEX_FIELD(s, field->next_prio);\n\tSEQ_PUT_HEX_FIELD(s, T);\n\n\treturn trace_handle_return(s);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nstatic enum print_line_t trace_ctx_hex(struct trace_iterator *iter, int flags,\n\t\t\t\t       struct trace_event *event)\n{\n\treturn trace_ctxwake_hex(iter, 0);\n}"
  },
  {
    "function_name": "trace_ctxwake_hex",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_output.c",
    "lines": "1002-1023",
    "snippet": "static int trace_ctxwake_hex(struct trace_iterator *iter, char S)\n{\n\tstruct ctx_switch_entry *field;\n\tstruct trace_seq *s = &iter->seq;\n\tint T;\n\n\ttrace_assign_type(field, iter->ent);\n\n\tif (!S)\n\t\tS = task_index_to_char(field->prev_state);\n\tT = task_index_to_char(field->next_state);\n\n\tSEQ_PUT_HEX_FIELD(s, field->prev_pid);\n\tSEQ_PUT_HEX_FIELD(s, field->prev_prio);\n\tSEQ_PUT_HEX_FIELD(s, S);\n\tSEQ_PUT_HEX_FIELD(s, field->next_cpu);\n\tSEQ_PUT_HEX_FIELD(s, field->next_pid);\n\tSEQ_PUT_HEX_FIELD(s, field->next_prio);\n\tSEQ_PUT_HEX_FIELD(s, T);\n\n\treturn trace_handle_return(s);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_handle_return",
          "args": [
            "s"
          ],
          "line": 1022
        },
        "resolved": true,
        "details": {
          "function_name": "trace_handle_return",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "2577-2581",
          "snippet": "enum print_line_t trace_handle_return(struct trace_seq *s)\n{\n\treturn trace_seq_has_overflowed(s) ?\n\t\tTRACE_TYPE_PARTIAL_LINE : TRACE_TYPE_HANDLED;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nenum print_line_t trace_handle_return(struct trace_seq *s)\n{\n\treturn trace_seq_has_overflowed(s) ?\n\t\tTRACE_TYPE_PARTIAL_LINE : TRACE_TYPE_HANDLED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SEQ_PUT_HEX_FIELD",
          "args": [
            "s",
            "T"
          ],
          "line": 1020
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SEQ_PUT_HEX_FIELD",
          "args": [
            "s",
            "field->next_prio"
          ],
          "line": 1019
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SEQ_PUT_HEX_FIELD",
          "args": [
            "s",
            "field->next_pid"
          ],
          "line": 1018
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SEQ_PUT_HEX_FIELD",
          "args": [
            "s",
            "field->next_cpu"
          ],
          "line": 1017
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SEQ_PUT_HEX_FIELD",
          "args": [
            "s",
            "S"
          ],
          "line": 1016
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SEQ_PUT_HEX_FIELD",
          "args": [
            "s",
            "field->prev_prio"
          ],
          "line": 1015
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SEQ_PUT_HEX_FIELD",
          "args": [
            "s",
            "field->prev_pid"
          ],
          "line": 1014
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_index_to_char",
          "args": [
            "field->next_state"
          ],
          "line": 1012
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_index_to_char",
          "args": [
            "field->prev_state"
          ],
          "line": 1011
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_assign_type",
          "args": [
            "field",
            "iter->ent"
          ],
          "line": 1008
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nstatic int trace_ctxwake_hex(struct trace_iterator *iter, char S)\n{\n\tstruct ctx_switch_entry *field;\n\tstruct trace_seq *s = &iter->seq;\n\tint T;\n\n\ttrace_assign_type(field, iter->ent);\n\n\tif (!S)\n\t\tS = task_index_to_char(field->prev_state);\n\tT = task_index_to_char(field->next_state);\n\n\tSEQ_PUT_HEX_FIELD(s, field->prev_pid);\n\tSEQ_PUT_HEX_FIELD(s, field->prev_prio);\n\tSEQ_PUT_HEX_FIELD(s, S);\n\tSEQ_PUT_HEX_FIELD(s, field->next_cpu);\n\tSEQ_PUT_HEX_FIELD(s, field->next_pid);\n\tSEQ_PUT_HEX_FIELD(s, field->next_prio);\n\tSEQ_PUT_HEX_FIELD(s, T);\n\n\treturn trace_handle_return(s);\n}"
  },
  {
    "function_name": "trace_wake_raw",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_output.c",
    "lines": "995-999",
    "snippet": "static enum print_line_t trace_wake_raw(struct trace_iterator *iter, int flags,\n\t\t\t\t\tstruct trace_event *event)\n{\n\treturn trace_ctxwake_raw(iter, '+');\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_ctxwake_raw",
          "args": [
            "iter",
            "'+'"
          ],
          "line": 998
        },
        "resolved": true,
        "details": {
          "function_name": "trace_ctxwake_raw",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_output.c",
          "lines": "967-987",
          "snippet": "static int trace_ctxwake_raw(struct trace_iterator *iter, char S)\n{\n\tstruct ctx_switch_entry *field;\n\tint T;\n\n\ttrace_assign_type(field, iter->ent);\n\n\tif (!S)\n\t\tS = task_index_to_char(field->prev_state);\n\tT = task_index_to_char(field->next_state);\n\ttrace_seq_printf(&iter->seq, \"%d %d %c %d %d %d %c\\n\",\n\t\t\t field->prev_pid,\n\t\t\t field->prev_prio,\n\t\t\t S,\n\t\t\t field->next_cpu,\n\t\t\t field->next_pid,\n\t\t\t field->next_prio,\n\t\t\t T);\n\n\treturn trace_handle_return(&iter->seq);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nstatic int trace_ctxwake_raw(struct trace_iterator *iter, char S)\n{\n\tstruct ctx_switch_entry *field;\n\tint T;\n\n\ttrace_assign_type(field, iter->ent);\n\n\tif (!S)\n\t\tS = task_index_to_char(field->prev_state);\n\tT = task_index_to_char(field->next_state);\n\ttrace_seq_printf(&iter->seq, \"%d %d %c %d %d %d %c\\n\",\n\t\t\t field->prev_pid,\n\t\t\t field->prev_prio,\n\t\t\t S,\n\t\t\t field->next_cpu,\n\t\t\t field->next_pid,\n\t\t\t field->next_prio,\n\t\t\t T);\n\n\treturn trace_handle_return(&iter->seq);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nstatic enum print_line_t trace_wake_raw(struct trace_iterator *iter, int flags,\n\t\t\t\t\tstruct trace_event *event)\n{\n\treturn trace_ctxwake_raw(iter, '+');\n}"
  },
  {
    "function_name": "trace_ctx_raw",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_output.c",
    "lines": "989-993",
    "snippet": "static enum print_line_t trace_ctx_raw(struct trace_iterator *iter, int flags,\n\t\t\t\t       struct trace_event *event)\n{\n\treturn trace_ctxwake_raw(iter, 0);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_ctxwake_raw",
          "args": [
            "iter",
            "0"
          ],
          "line": 992
        },
        "resolved": true,
        "details": {
          "function_name": "trace_ctxwake_raw",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_output.c",
          "lines": "967-987",
          "snippet": "static int trace_ctxwake_raw(struct trace_iterator *iter, char S)\n{\n\tstruct ctx_switch_entry *field;\n\tint T;\n\n\ttrace_assign_type(field, iter->ent);\n\n\tif (!S)\n\t\tS = task_index_to_char(field->prev_state);\n\tT = task_index_to_char(field->next_state);\n\ttrace_seq_printf(&iter->seq, \"%d %d %c %d %d %d %c\\n\",\n\t\t\t field->prev_pid,\n\t\t\t field->prev_prio,\n\t\t\t S,\n\t\t\t field->next_cpu,\n\t\t\t field->next_pid,\n\t\t\t field->next_prio,\n\t\t\t T);\n\n\treturn trace_handle_return(&iter->seq);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nstatic int trace_ctxwake_raw(struct trace_iterator *iter, char S)\n{\n\tstruct ctx_switch_entry *field;\n\tint T;\n\n\ttrace_assign_type(field, iter->ent);\n\n\tif (!S)\n\t\tS = task_index_to_char(field->prev_state);\n\tT = task_index_to_char(field->next_state);\n\ttrace_seq_printf(&iter->seq, \"%d %d %c %d %d %d %c\\n\",\n\t\t\t field->prev_pid,\n\t\t\t field->prev_prio,\n\t\t\t S,\n\t\t\t field->next_cpu,\n\t\t\t field->next_pid,\n\t\t\t field->next_prio,\n\t\t\t T);\n\n\treturn trace_handle_return(&iter->seq);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nstatic enum print_line_t trace_ctx_raw(struct trace_iterator *iter, int flags,\n\t\t\t\t       struct trace_event *event)\n{\n\treturn trace_ctxwake_raw(iter, 0);\n}"
  },
  {
    "function_name": "trace_ctxwake_raw",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_output.c",
    "lines": "967-987",
    "snippet": "static int trace_ctxwake_raw(struct trace_iterator *iter, char S)\n{\n\tstruct ctx_switch_entry *field;\n\tint T;\n\n\ttrace_assign_type(field, iter->ent);\n\n\tif (!S)\n\t\tS = task_index_to_char(field->prev_state);\n\tT = task_index_to_char(field->next_state);\n\ttrace_seq_printf(&iter->seq, \"%d %d %c %d %d %d %c\\n\",\n\t\t\t field->prev_pid,\n\t\t\t field->prev_prio,\n\t\t\t S,\n\t\t\t field->next_cpu,\n\t\t\t field->next_pid,\n\t\t\t field->next_prio,\n\t\t\t T);\n\n\treturn trace_handle_return(&iter->seq);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_handle_return",
          "args": [
            "&iter->seq"
          ],
          "line": 986
        },
        "resolved": true,
        "details": {
          "function_name": "trace_handle_return",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "2577-2581",
          "snippet": "enum print_line_t trace_handle_return(struct trace_seq *s)\n{\n\treturn trace_seq_has_overflowed(s) ?\n\t\tTRACE_TYPE_PARTIAL_LINE : TRACE_TYPE_HANDLED;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nenum print_line_t trace_handle_return(struct trace_seq *s)\n{\n\treturn trace_seq_has_overflowed(s) ?\n\t\tTRACE_TYPE_PARTIAL_LINE : TRACE_TYPE_HANDLED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_seq_printf",
          "args": [
            "&iter->seq",
            "\"%d %d %c %d %d %d %c\\n\"",
            "field->prev_pid",
            "field->prev_prio",
            "S",
            "field->next_cpu",
            "field->next_pid",
            "field->next_prio",
            "T"
          ],
          "line": 977
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "81-100",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_index_to_char",
          "args": [
            "field->next_state"
          ],
          "line": 976
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_index_to_char",
          "args": [
            "field->prev_state"
          ],
          "line": 975
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_assign_type",
          "args": [
            "field",
            "iter->ent"
          ],
          "line": 972
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nstatic int trace_ctxwake_raw(struct trace_iterator *iter, char S)\n{\n\tstruct ctx_switch_entry *field;\n\tint T;\n\n\ttrace_assign_type(field, iter->ent);\n\n\tif (!S)\n\t\tS = task_index_to_char(field->prev_state);\n\tT = task_index_to_char(field->next_state);\n\ttrace_seq_printf(&iter->seq, \"%d %d %c %d %d %d %c\\n\",\n\t\t\t field->prev_pid,\n\t\t\t field->prev_prio,\n\t\t\t S,\n\t\t\t field->next_cpu,\n\t\t\t field->next_pid,\n\t\t\t field->next_prio,\n\t\t\t T);\n\n\treturn trace_handle_return(&iter->seq);\n}"
  },
  {
    "function_name": "trace_wake_print",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_output.c",
    "lines": "961-965",
    "snippet": "static enum print_line_t trace_wake_print(struct trace_iterator *iter,\n\t\t\t\t\t  int flags, struct trace_event *event)\n{\n\treturn trace_ctxwake_print(iter, \"  +\");\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_ctxwake_print",
          "args": [
            "iter",
            "\"  +\""
          ],
          "line": 964
        },
        "resolved": true,
        "details": {
          "function_name": "trace_ctxwake_print",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_output.c",
          "lines": "929-953",
          "snippet": "static enum print_line_t trace_ctxwake_print(struct trace_iterator *iter,\n\t\t\t\t\t     char *delim)\n{\n\tstruct ctx_switch_entry *field;\n\tchar comm[TASK_COMM_LEN];\n\tint S, T;\n\n\n\ttrace_assign_type(field, iter->ent);\n\n\tT = task_index_to_char(field->next_state);\n\tS = task_index_to_char(field->prev_state);\n\ttrace_find_cmdline(field->next_pid, comm);\n\ttrace_seq_printf(&iter->seq,\n\t\t\t \" %7d:%3d:%c %s [%03d] %7d:%3d:%c %s\\n\",\n\t\t\t field->prev_pid,\n\t\t\t field->prev_prio,\n\t\t\t S, delim,\n\t\t\t field->next_cpu,\n\t\t\t field->next_pid,\n\t\t\t field->next_prio,\n\t\t\t T, comm);\n\n\treturn trace_handle_return(&iter->seq);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nstatic enum print_line_t trace_ctxwake_print(struct trace_iterator *iter,\n\t\t\t\t\t     char *delim)\n{\n\tstruct ctx_switch_entry *field;\n\tchar comm[TASK_COMM_LEN];\n\tint S, T;\n\n\n\ttrace_assign_type(field, iter->ent);\n\n\tT = task_index_to_char(field->next_state);\n\tS = task_index_to_char(field->prev_state);\n\ttrace_find_cmdline(field->next_pid, comm);\n\ttrace_seq_printf(&iter->seq,\n\t\t\t \" %7d:%3d:%c %s [%03d] %7d:%3d:%c %s\\n\",\n\t\t\t field->prev_pid,\n\t\t\t field->prev_prio,\n\t\t\t S, delim,\n\t\t\t field->next_cpu,\n\t\t\t field->next_pid,\n\t\t\t field->next_prio,\n\t\t\t T, comm);\n\n\treturn trace_handle_return(&iter->seq);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nstatic enum print_line_t trace_wake_print(struct trace_iterator *iter,\n\t\t\t\t\t  int flags, struct trace_event *event)\n{\n\treturn trace_ctxwake_print(iter, \"  +\");\n}"
  },
  {
    "function_name": "trace_ctx_print",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_output.c",
    "lines": "955-959",
    "snippet": "static enum print_line_t trace_ctx_print(struct trace_iterator *iter, int flags,\n\t\t\t\t\t struct trace_event *event)\n{\n\treturn trace_ctxwake_print(iter, \"==>\");\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_ctxwake_print",
          "args": [
            "iter",
            "\"==>\""
          ],
          "line": 958
        },
        "resolved": true,
        "details": {
          "function_name": "trace_ctxwake_print",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_output.c",
          "lines": "929-953",
          "snippet": "static enum print_line_t trace_ctxwake_print(struct trace_iterator *iter,\n\t\t\t\t\t     char *delim)\n{\n\tstruct ctx_switch_entry *field;\n\tchar comm[TASK_COMM_LEN];\n\tint S, T;\n\n\n\ttrace_assign_type(field, iter->ent);\n\n\tT = task_index_to_char(field->next_state);\n\tS = task_index_to_char(field->prev_state);\n\ttrace_find_cmdline(field->next_pid, comm);\n\ttrace_seq_printf(&iter->seq,\n\t\t\t \" %7d:%3d:%c %s [%03d] %7d:%3d:%c %s\\n\",\n\t\t\t field->prev_pid,\n\t\t\t field->prev_prio,\n\t\t\t S, delim,\n\t\t\t field->next_cpu,\n\t\t\t field->next_pid,\n\t\t\t field->next_prio,\n\t\t\t T, comm);\n\n\treturn trace_handle_return(&iter->seq);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nstatic enum print_line_t trace_ctxwake_print(struct trace_iterator *iter,\n\t\t\t\t\t     char *delim)\n{\n\tstruct ctx_switch_entry *field;\n\tchar comm[TASK_COMM_LEN];\n\tint S, T;\n\n\n\ttrace_assign_type(field, iter->ent);\n\n\tT = task_index_to_char(field->next_state);\n\tS = task_index_to_char(field->prev_state);\n\ttrace_find_cmdline(field->next_pid, comm);\n\ttrace_seq_printf(&iter->seq,\n\t\t\t \" %7d:%3d:%c %s [%03d] %7d:%3d:%c %s\\n\",\n\t\t\t field->prev_pid,\n\t\t\t field->prev_prio,\n\t\t\t S, delim,\n\t\t\t field->next_cpu,\n\t\t\t field->next_pid,\n\t\t\t field->next_prio,\n\t\t\t T, comm);\n\n\treturn trace_handle_return(&iter->seq);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nstatic enum print_line_t trace_ctx_print(struct trace_iterator *iter, int flags,\n\t\t\t\t\t struct trace_event *event)\n{\n\treturn trace_ctxwake_print(iter, \"==>\");\n}"
  },
  {
    "function_name": "trace_ctxwake_print",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_output.c",
    "lines": "929-953",
    "snippet": "static enum print_line_t trace_ctxwake_print(struct trace_iterator *iter,\n\t\t\t\t\t     char *delim)\n{\n\tstruct ctx_switch_entry *field;\n\tchar comm[TASK_COMM_LEN];\n\tint S, T;\n\n\n\ttrace_assign_type(field, iter->ent);\n\n\tT = task_index_to_char(field->next_state);\n\tS = task_index_to_char(field->prev_state);\n\ttrace_find_cmdline(field->next_pid, comm);\n\ttrace_seq_printf(&iter->seq,\n\t\t\t \" %7d:%3d:%c %s [%03d] %7d:%3d:%c %s\\n\",\n\t\t\t field->prev_pid,\n\t\t\t field->prev_prio,\n\t\t\t S, delim,\n\t\t\t field->next_cpu,\n\t\t\t field->next_pid,\n\t\t\t field->next_prio,\n\t\t\t T, comm);\n\n\treturn trace_handle_return(&iter->seq);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_handle_return",
          "args": [
            "&iter->seq"
          ],
          "line": 952
        },
        "resolved": true,
        "details": {
          "function_name": "trace_handle_return",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "2577-2581",
          "snippet": "enum print_line_t trace_handle_return(struct trace_seq *s)\n{\n\treturn trace_seq_has_overflowed(s) ?\n\t\tTRACE_TYPE_PARTIAL_LINE : TRACE_TYPE_HANDLED;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nenum print_line_t trace_handle_return(struct trace_seq *s)\n{\n\treturn trace_seq_has_overflowed(s) ?\n\t\tTRACE_TYPE_PARTIAL_LINE : TRACE_TYPE_HANDLED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_seq_printf",
          "args": [
            "&iter->seq",
            "\" %7d:%3d:%c %s [%03d] %7d:%3d:%c %s\\n\"",
            "field->prev_pid",
            "field->prev_prio",
            "S",
            "delim",
            "field->next_cpu",
            "field->next_pid",
            "field->next_prio",
            "T",
            "comm"
          ],
          "line": 942
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "81-100",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_find_cmdline",
          "args": [
            "field->next_pid",
            "comm"
          ],
          "line": 941
        },
        "resolved": true,
        "details": {
          "function_name": "trace_find_cmdline",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "2443-2452",
          "snippet": "void trace_find_cmdline(int pid, char comm[])\n{\n\tpreempt_disable();\n\tarch_spin_lock(&trace_cmdline_lock);\n\n\t__trace_find_cmdline(pid, comm);\n\n\tarch_spin_unlock(&trace_cmdline_lock);\n\tpreempt_enable();\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static arch_spinlock_t trace_cmdline_lock = __ARCH_SPIN_LOCK_UNLOCKED;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic arch_spinlock_t trace_cmdline_lock = __ARCH_SPIN_LOCK_UNLOCKED;\n\nvoid trace_find_cmdline(int pid, char comm[])\n{\n\tpreempt_disable();\n\tarch_spin_lock(&trace_cmdline_lock);\n\n\t__trace_find_cmdline(pid, comm);\n\n\tarch_spin_unlock(&trace_cmdline_lock);\n\tpreempt_enable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_index_to_char",
          "args": [
            "field->prev_state"
          ],
          "line": 940
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_index_to_char",
          "args": [
            "field->next_state"
          ],
          "line": 939
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_assign_type",
          "args": [
            "field",
            "iter->ent"
          ],
          "line": 937
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nstatic enum print_line_t trace_ctxwake_print(struct trace_iterator *iter,\n\t\t\t\t\t     char *delim)\n{\n\tstruct ctx_switch_entry *field;\n\tchar comm[TASK_COMM_LEN];\n\tint S, T;\n\n\n\ttrace_assign_type(field, iter->ent);\n\n\tT = task_index_to_char(field->next_state);\n\tS = task_index_to_char(field->prev_state);\n\ttrace_find_cmdline(field->next_pid, comm);\n\ttrace_seq_printf(&iter->seq,\n\t\t\t \" %7d:%3d:%c %s [%03d] %7d:%3d:%c %s\\n\",\n\t\t\t field->prev_pid,\n\t\t\t field->prev_prio,\n\t\t\t S, delim,\n\t\t\t field->next_cpu,\n\t\t\t field->next_pid,\n\t\t\t field->next_prio,\n\t\t\t T, comm);\n\n\treturn trace_handle_return(&iter->seq);\n}"
  },
  {
    "function_name": "trace_fn_bin",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_output.c",
    "lines": "902-914",
    "snippet": "static enum print_line_t trace_fn_bin(struct trace_iterator *iter, int flags,\n\t\t\t\t      struct trace_event *event)\n{\n\tstruct ftrace_entry *field;\n\tstruct trace_seq *s = &iter->seq;\n\n\ttrace_assign_type(field, iter->ent);\n\n\tSEQ_PUT_FIELD(s, field->ip);\n\tSEQ_PUT_FIELD(s, field->parent_ip);\n\n\treturn trace_handle_return(s);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_handle_return",
          "args": [
            "s"
          ],
          "line": 913
        },
        "resolved": true,
        "details": {
          "function_name": "trace_handle_return",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "2577-2581",
          "snippet": "enum print_line_t trace_handle_return(struct trace_seq *s)\n{\n\treturn trace_seq_has_overflowed(s) ?\n\t\tTRACE_TYPE_PARTIAL_LINE : TRACE_TYPE_HANDLED;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nenum print_line_t trace_handle_return(struct trace_seq *s)\n{\n\treturn trace_seq_has_overflowed(s) ?\n\t\tTRACE_TYPE_PARTIAL_LINE : TRACE_TYPE_HANDLED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SEQ_PUT_FIELD",
          "args": [
            "s",
            "field->parent_ip"
          ],
          "line": 911
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SEQ_PUT_FIELD",
          "args": [
            "s",
            "field->ip"
          ],
          "line": 910
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_assign_type",
          "args": [
            "field",
            "iter->ent"
          ],
          "line": 908
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nstatic enum print_line_t trace_fn_bin(struct trace_iterator *iter, int flags,\n\t\t\t\t      struct trace_event *event)\n{\n\tstruct ftrace_entry *field;\n\tstruct trace_seq *s = &iter->seq;\n\n\ttrace_assign_type(field, iter->ent);\n\n\tSEQ_PUT_FIELD(s, field->ip);\n\tSEQ_PUT_FIELD(s, field->parent_ip);\n\n\treturn trace_handle_return(s);\n}"
  },
  {
    "function_name": "trace_fn_hex",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_output.c",
    "lines": "888-900",
    "snippet": "static enum print_line_t trace_fn_hex(struct trace_iterator *iter, int flags,\n\t\t\t\t      struct trace_event *event)\n{\n\tstruct ftrace_entry *field;\n\tstruct trace_seq *s = &iter->seq;\n\n\ttrace_assign_type(field, iter->ent);\n\n\tSEQ_PUT_HEX_FIELD(s, field->ip);\n\tSEQ_PUT_HEX_FIELD(s, field->parent_ip);\n\n\treturn trace_handle_return(s);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_handle_return",
          "args": [
            "s"
          ],
          "line": 899
        },
        "resolved": true,
        "details": {
          "function_name": "trace_handle_return",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "2577-2581",
          "snippet": "enum print_line_t trace_handle_return(struct trace_seq *s)\n{\n\treturn trace_seq_has_overflowed(s) ?\n\t\tTRACE_TYPE_PARTIAL_LINE : TRACE_TYPE_HANDLED;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nenum print_line_t trace_handle_return(struct trace_seq *s)\n{\n\treturn trace_seq_has_overflowed(s) ?\n\t\tTRACE_TYPE_PARTIAL_LINE : TRACE_TYPE_HANDLED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SEQ_PUT_HEX_FIELD",
          "args": [
            "s",
            "field->parent_ip"
          ],
          "line": 897
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SEQ_PUT_HEX_FIELD",
          "args": [
            "s",
            "field->ip"
          ],
          "line": 896
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_assign_type",
          "args": [
            "field",
            "iter->ent"
          ],
          "line": 894
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nstatic enum print_line_t trace_fn_hex(struct trace_iterator *iter, int flags,\n\t\t\t\t      struct trace_event *event)\n{\n\tstruct ftrace_entry *field;\n\tstruct trace_seq *s = &iter->seq;\n\n\ttrace_assign_type(field, iter->ent);\n\n\tSEQ_PUT_HEX_FIELD(s, field->ip);\n\tSEQ_PUT_HEX_FIELD(s, field->parent_ip);\n\n\treturn trace_handle_return(s);\n}"
  },
  {
    "function_name": "trace_fn_raw",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_output.c",
    "lines": "874-886",
    "snippet": "static enum print_line_t trace_fn_raw(struct trace_iterator *iter, int flags,\n\t\t\t\t      struct trace_event *event)\n{\n\tstruct ftrace_entry *field;\n\n\ttrace_assign_type(field, iter->ent);\n\n\ttrace_seq_printf(&iter->seq, \"%lx %lx\\n\",\n\t\t\t field->ip,\n\t\t\t field->parent_ip);\n\n\treturn trace_handle_return(&iter->seq);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_handle_return",
          "args": [
            "&iter->seq"
          ],
          "line": 885
        },
        "resolved": true,
        "details": {
          "function_name": "trace_handle_return",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "2577-2581",
          "snippet": "enum print_line_t trace_handle_return(struct trace_seq *s)\n{\n\treturn trace_seq_has_overflowed(s) ?\n\t\tTRACE_TYPE_PARTIAL_LINE : TRACE_TYPE_HANDLED;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nenum print_line_t trace_handle_return(struct trace_seq *s)\n{\n\treturn trace_seq_has_overflowed(s) ?\n\t\tTRACE_TYPE_PARTIAL_LINE : TRACE_TYPE_HANDLED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_seq_printf",
          "args": [
            "&iter->seq",
            "\"%lx %lx\\n\"",
            "field->ip",
            "field->parent_ip"
          ],
          "line": 881
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "81-100",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_assign_type",
          "args": [
            "field",
            "iter->ent"
          ],
          "line": 879
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nstatic enum print_line_t trace_fn_raw(struct trace_iterator *iter, int flags,\n\t\t\t\t      struct trace_event *event)\n{\n\tstruct ftrace_entry *field;\n\n\ttrace_assign_type(field, iter->ent);\n\n\ttrace_seq_printf(&iter->seq, \"%lx %lx\\n\",\n\t\t\t field->ip,\n\t\t\t field->parent_ip);\n\n\treturn trace_handle_return(&iter->seq);\n}"
  },
  {
    "function_name": "trace_fn_trace",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_output.c",
    "lines": "860-872",
    "snippet": "static enum print_line_t trace_fn_trace(struct trace_iterator *iter, int flags,\n\t\t\t\t\tstruct trace_event *event)\n{\n\tstruct ftrace_entry *field;\n\tstruct trace_seq *s = &iter->seq;\n\n\ttrace_assign_type(field, iter->ent);\n\n\tprint_fn_trace(s, field->ip, field->parent_ip, flags);\n\ttrace_seq_putc(s, '\\n');\n\n\treturn trace_handle_return(s);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_handle_return",
          "args": [
            "s"
          ],
          "line": 871
        },
        "resolved": true,
        "details": {
          "function_name": "trace_handle_return",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "2577-2581",
          "snippet": "enum print_line_t trace_handle_return(struct trace_seq *s)\n{\n\treturn trace_seq_has_overflowed(s) ?\n\t\tTRACE_TYPE_PARTIAL_LINE : TRACE_TYPE_HANDLED;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nenum print_line_t trace_handle_return(struct trace_seq *s)\n{\n\treturn trace_seq_has_overflowed(s) ?\n\t\tTRACE_TYPE_PARTIAL_LINE : TRACE_TYPE_HANDLED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_seq_putc",
          "args": [
            "s",
            "'\\n'"
          ],
          "line": 869
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_putc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "233-246",
          "snippet": "void trace_seq_putc(struct trace_seq *s, unsigned char c)\n{\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (TRACE_SEQ_BUF_LEFT(s) < 1) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putc(&s->seq, c);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_putc(struct trace_seq *s, unsigned char c)\n{\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (TRACE_SEQ_BUF_LEFT(s) < 1) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putc(&s->seq, c);\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_fn_trace",
          "args": [
            "s",
            "field->ip",
            "field->parent_ip",
            "flags"
          ],
          "line": 868
        },
        "resolved": true,
        "details": {
          "function_name": "print_fn_trace",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_output.c",
          "lines": "848-857",
          "snippet": "static void print_fn_trace(struct trace_seq *s, unsigned long ip,\n\t\t\t   unsigned long parent_ip, int flags)\n{\n\tseq_print_ip_sym(s, ip, flags);\n\n\tif ((flags & TRACE_ITER_PRINT_PARENT) && parent_ip) {\n\t\ttrace_seq_puts(s, \" <-\");\n\t\tseq_print_ip_sym(s, parent_ip, flags);\n\t}\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nstatic void print_fn_trace(struct trace_seq *s, unsigned long ip,\n\t\t\t   unsigned long parent_ip, int flags)\n{\n\tseq_print_ip_sym(s, ip, flags);\n\n\tif ((flags & TRACE_ITER_PRINT_PARENT) && parent_ip) {\n\t\ttrace_seq_puts(s, \" <-\");\n\t\tseq_print_ip_sym(s, parent_ip, flags);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_assign_type",
          "args": [
            "field",
            "iter->ent"
          ],
          "line": 866
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nstatic enum print_line_t trace_fn_trace(struct trace_iterator *iter, int flags,\n\t\t\t\t\tstruct trace_event *event)\n{\n\tstruct ftrace_entry *field;\n\tstruct trace_seq *s = &iter->seq;\n\n\ttrace_assign_type(field, iter->ent);\n\n\tprint_fn_trace(s, field->ip, field->parent_ip, flags);\n\ttrace_seq_putc(s, '\\n');\n\n\treturn trace_handle_return(s);\n}"
  },
  {
    "function_name": "print_fn_trace",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_output.c",
    "lines": "848-857",
    "snippet": "static void print_fn_trace(struct trace_seq *s, unsigned long ip,\n\t\t\t   unsigned long parent_ip, int flags)\n{\n\tseq_print_ip_sym(s, ip, flags);\n\n\tif ((flags & TRACE_ITER_PRINT_PARENT) && parent_ip) {\n\t\ttrace_seq_puts(s, \" <-\");\n\t\tseq_print_ip_sym(s, parent_ip, flags);\n\t}\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_print_ip_sym",
          "args": [
            "s",
            "parent_ip",
            "flags"
          ],
          "line": 855
        },
        "resolved": true,
        "details": {
          "function_name": "seq_print_ip_sym",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_output.c",
          "lines": "416-431",
          "snippet": "int\nseq_print_ip_sym(struct trace_seq *s, unsigned long ip, unsigned long sym_flags)\n{\n\tif (!ip) {\n\t\ttrace_seq_putc(s, '0');\n\t\tgoto out;\n\t}\n\n\ttrace_seq_print_sym(s, ip, sym_flags & TRACE_ITER_SYM_OFFSET);\n\n\tif (sym_flags & TRACE_ITER_SYM_ADDR)\n\t\ttrace_seq_printf(s, \" <\" IP_FMT \">\", ip);\n\n out:\n\treturn !trace_seq_has_overflowed(s);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nint\nseq_print_ip_sym(struct trace_seq *s, unsigned long ip, unsigned long sym_flags)\n{\n\tif (!ip) {\n\t\ttrace_seq_putc(s, '0');\n\t\tgoto out;\n\t}\n\n\ttrace_seq_print_sym(s, ip, sym_flags & TRACE_ITER_SYM_OFFSET);\n\n\tif (sym_flags & TRACE_ITER_SYM_ADDR)\n\t\ttrace_seq_printf(s, \" <\" IP_FMT \">\", ip);\n\n out:\n\treturn !trace_seq_has_overflowed(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_seq_puts",
          "args": [
            "s",
            "\" <-\""
          ],
          "line": 854
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_puts",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "205-220",
          "snippet": "void trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nstatic void print_fn_trace(struct trace_seq *s, unsigned long ip,\n\t\t\t   unsigned long parent_ip, int flags)\n{\n\tseq_print_ip_sym(s, ip, flags);\n\n\tif ((flags & TRACE_ITER_PRINT_PARENT) && parent_ip) {\n\t\ttrace_seq_puts(s, \" <-\");\n\t\tseq_print_ip_sym(s, parent_ip, flags);\n\t}\n}"
  },
  {
    "function_name": "trace_nop_print",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_output.c",
    "lines": "840-846",
    "snippet": "enum print_line_t trace_nop_print(struct trace_iterator *iter, int flags,\n\t\t\t\t  struct trace_event *event)\n{\n\ttrace_seq_printf(&iter->seq, \"type: %d\\n\", iter->ent->type);\n\n\treturn trace_handle_return(&iter->seq);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_handle_return",
          "args": [
            "&iter->seq"
          ],
          "line": 845
        },
        "resolved": true,
        "details": {
          "function_name": "trace_handle_return",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "2577-2581",
          "snippet": "enum print_line_t trace_handle_return(struct trace_seq *s)\n{\n\treturn trace_seq_has_overflowed(s) ?\n\t\tTRACE_TYPE_PARTIAL_LINE : TRACE_TYPE_HANDLED;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nenum print_line_t trace_handle_return(struct trace_seq *s)\n{\n\treturn trace_seq_has_overflowed(s) ?\n\t\tTRACE_TYPE_PARTIAL_LINE : TRACE_TYPE_HANDLED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_seq_printf",
          "args": [
            "&iter->seq",
            "\"type: %d\\n\"",
            "iter->ent->type"
          ],
          "line": 843
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "81-100",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nenum print_line_t trace_nop_print(struct trace_iterator *iter, int flags,\n\t\t\t\t  struct trace_event *event)\n{\n\ttrace_seq_printf(&iter->seq, \"type: %d\\n\", iter->ent->type);\n\n\treturn trace_handle_return(&iter->seq);\n}"
  },
  {
    "function_name": "unregister_trace_event",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_output.c",
    "lines": "826-833",
    "snippet": "int unregister_trace_event(struct trace_event *event)\n{\n\tdown_write(&trace_event_sem);\n\t__unregister_trace_event(event);\n\tup_write(&trace_event_sem);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&trace_event_sem"
          ],
          "line": 830
        },
        "resolved": true,
        "details": {
          "function_name": "percpu_up_write",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/percpu-rwsem.c",
          "lines": "242-269",
          "snippet": "void percpu_up_write(struct percpu_rw_semaphore *sem)\n{\n\trwsem_release(&sem->dep_map, _RET_IP_);\n\n\t/*\n\t * Signal the writer is done, no fast path yet.\n\t *\n\t * One reason that we cannot just immediately flip to readers_fast is\n\t * that new readers might fail to see the results of this writer's\n\t * critical section.\n\t *\n\t * Therefore we force it through the slow path which guarantees an\n\t * acquire and thereby guarantees the critical section's consistency.\n\t */\n\tatomic_set_release(&sem->block, 0);\n\n\t/*\n\t * Prod any pending reader/writer to make progress.\n\t */\n\t__wake_up(&sem->waiters, TASK_NORMAL, 1, sem);\n\n\t/*\n\t * Once this completes (at least one RCU-sched grace period hence) the\n\t * reader fast path will be available again. Safe to use outside the\n\t * exclusive write lock because its counting.\n\t */\n\trcu_sync_exit(&sem->rss);\n}",
          "includes": [
            "#include <linux/errno.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/wait.h>",
            "#include <linux/percpu.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/errno.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/lockdep.h>\n#include <linux/wait.h>\n#include <linux/percpu.h>\n#include <linux/atomic.h>\n\nvoid percpu_up_write(struct percpu_rw_semaphore *sem)\n{\n\trwsem_release(&sem->dep_map, _RET_IP_);\n\n\t/*\n\t * Signal the writer is done, no fast path yet.\n\t *\n\t * One reason that we cannot just immediately flip to readers_fast is\n\t * that new readers might fail to see the results of this writer's\n\t * critical section.\n\t *\n\t * Therefore we force it through the slow path which guarantees an\n\t * acquire and thereby guarantees the critical section's consistency.\n\t */\n\tatomic_set_release(&sem->block, 0);\n\n\t/*\n\t * Prod any pending reader/writer to make progress.\n\t */\n\t__wake_up(&sem->waiters, TASK_NORMAL, 1, sem);\n\n\t/*\n\t * Once this completes (at least one RCU-sched grace period hence) the\n\t * reader fast path will be available again. Safe to use outside the\n\t * exclusive write lock because its counting.\n\t */\n\trcu_sync_exit(&sem->rss);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__unregister_trace_event",
          "args": [
            "event"
          ],
          "line": 829
        },
        "resolved": true,
        "details": {
          "function_name": "__unregister_trace_event",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_output.c",
          "lines": "815-820",
          "snippet": "int __unregister_trace_event(struct trace_event *event)\n{\n\thlist_del(&event->node);\n\tlist_del(&event->list);\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nint __unregister_trace_event(struct trace_event *event)\n{\n\thlist_del(&event->node);\n\tlist_del(&event->list);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&trace_event_sem"
          ],
          "line": 828
        },
        "resolved": true,
        "details": {
          "function_name": "percpu_down_write",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/percpu-rwsem.c",
          "lines": "214-239",
          "snippet": "void percpu_down_write(struct percpu_rw_semaphore *sem)\n{\n\tmight_sleep();\n\trwsem_acquire(&sem->dep_map, 0, 0, _RET_IP_);\n\n\t/* Notify readers to take the slow path. */\n\trcu_sync_enter(&sem->rss);\n\n\t/*\n\t * Try set sem->block; this provides writer-writer exclusion.\n\t * Having sem->block set makes new readers block.\n\t */\n\tif (!__percpu_down_write_trylock(sem))\n\t\tpercpu_rwsem_wait(sem, /* .reader = */ false);\n\n\t/* smp_mb() implied by __percpu_down_write_trylock() on success -- D matches A */\n\n\t/*\n\t * If they don't see our store of sem->block, then we are guaranteed to\n\t * see their sem->read_count increment, and therefore will wait for\n\t * them.\n\t */\n\n\t/* Wait for all active readers to complete. */\n\trcuwait_wait_event(&sem->writer, readers_active_check(sem), TASK_UNINTERRUPTIBLE);\n}",
          "includes": [
            "#include <linux/errno.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/wait.h>",
            "#include <linux/percpu.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/errno.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/lockdep.h>\n#include <linux/wait.h>\n#include <linux/percpu.h>\n#include <linux/atomic.h>\n\nvoid percpu_down_write(struct percpu_rw_semaphore *sem)\n{\n\tmight_sleep();\n\trwsem_acquire(&sem->dep_map, 0, 0, _RET_IP_);\n\n\t/* Notify readers to take the slow path. */\n\trcu_sync_enter(&sem->rss);\n\n\t/*\n\t * Try set sem->block; this provides writer-writer exclusion.\n\t * Having sem->block set makes new readers block.\n\t */\n\tif (!__percpu_down_write_trylock(sem))\n\t\tpercpu_rwsem_wait(sem, /* .reader = */ false);\n\n\t/* smp_mb() implied by __percpu_down_write_trylock() on success -- D matches A */\n\n\t/*\n\t * If they don't see our store of sem->block, then we are guaranteed to\n\t * see their sem->read_count increment, and therefore will wait for\n\t * them.\n\t */\n\n\t/* Wait for all active readers to complete. */\n\trcuwait_wait_event(&sem->writer, readers_active_check(sem), TASK_UNINTERRUPTIBLE);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nint unregister_trace_event(struct trace_event *event)\n{\n\tdown_write(&trace_event_sem);\n\t__unregister_trace_event(event);\n\tup_write(&trace_event_sem);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "__unregister_trace_event",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_output.c",
    "lines": "815-820",
    "snippet": "int __unregister_trace_event(struct trace_event *event)\n{\n\thlist_del(&event->node);\n\tlist_del(&event->list);\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&event->list"
          ],
          "line": 818
        },
        "resolved": true,
        "details": {
          "function_name": "list_del_leaf_cfs_rq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/fair.c",
          "lines": "475-477",
          "snippet": "static inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool sched_idle_cfs_rq(struct cfs_rq *cfs_rq);",
            "static void check_enqueue_throttle(struct cfs_rq *cfs_rq);",
            "static __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);",
            "static bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic bool sched_idle_cfs_rq(struct cfs_rq *cfs_rq);\nstatic void check_enqueue_throttle(struct cfs_rq *cfs_rq);\nstatic __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);\nstatic bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);\n\nstatic inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_del",
          "args": [
            "&event->node"
          ],
          "line": 817
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nint __unregister_trace_event(struct trace_event *event)\n{\n\thlist_del(&event->node);\n\tlist_del(&event->list);\n\treturn 0;\n}"
  },
  {
    "function_name": "register_trace_event",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_output.c",
    "lines": "746-809",
    "snippet": "int register_trace_event(struct trace_event *event)\n{\n\tunsigned key;\n\tint ret = 0;\n\n\tdown_write(&trace_event_sem);\n\n\tif (WARN_ON(!event))\n\t\tgoto out;\n\n\tif (WARN_ON(!event->funcs))\n\t\tgoto out;\n\n\tINIT_LIST_HEAD(&event->list);\n\n\tif (!event->type) {\n\t\tstruct list_head *list = NULL;\n\n\t\tif (next_event_type > TRACE_EVENT_TYPE_MAX) {\n\n\t\t\tevent->type = trace_search_list(&list);\n\t\t\tif (!event->type)\n\t\t\t\tgoto out;\n\n\t\t} else {\n\n\t\t\tevent->type = next_event_type++;\n\t\t\tlist = &ftrace_event_list;\n\t\t}\n\n\t\tif (WARN_ON(ftrace_find_event(event->type)))\n\t\t\tgoto out;\n\n\t\tlist_add_tail(&event->list, list);\n\n\t} else if (event->type > __TRACE_LAST_TYPE) {\n\t\tprintk(KERN_WARNING \"Need to add type to trace.h\\n\");\n\t\tWARN_ON(1);\n\t\tgoto out;\n\t} else {\n\t\t/* Is this event already used */\n\t\tif (ftrace_find_event(event->type))\n\t\t\tgoto out;\n\t}\n\n\tif (event->funcs->trace == NULL)\n\t\tevent->funcs->trace = trace_nop_print;\n\tif (event->funcs->raw == NULL)\n\t\tevent->funcs->raw = trace_nop_print;\n\tif (event->funcs->hex == NULL)\n\t\tevent->funcs->hex = trace_nop_print;\n\tif (event->funcs->binary == NULL)\n\t\tevent->funcs->binary = trace_nop_print;\n\n\tkey = event->type & (EVENT_HASHSIZE - 1);\n\n\thlist_add_head(&event->node, &event_hash[key]);\n\n\tret = event->type;\n out:\n\tup_write(&trace_event_sem);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define EVENT_HASHSIZE\t128"
    ],
    "globals_used": [
      "static struct hlist_head event_hash[EVENT_HASHSIZE]",
      "static int next_event_type = __TRACE_LAST_TYPE;",
      "static LIST_HEAD(ftrace_event_list);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&trace_event_sem"
          ],
          "line": 806
        },
        "resolved": true,
        "details": {
          "function_name": "percpu_up_write",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/percpu-rwsem.c",
          "lines": "242-269",
          "snippet": "void percpu_up_write(struct percpu_rw_semaphore *sem)\n{\n\trwsem_release(&sem->dep_map, _RET_IP_);\n\n\t/*\n\t * Signal the writer is done, no fast path yet.\n\t *\n\t * One reason that we cannot just immediately flip to readers_fast is\n\t * that new readers might fail to see the results of this writer's\n\t * critical section.\n\t *\n\t * Therefore we force it through the slow path which guarantees an\n\t * acquire and thereby guarantees the critical section's consistency.\n\t */\n\tatomic_set_release(&sem->block, 0);\n\n\t/*\n\t * Prod any pending reader/writer to make progress.\n\t */\n\t__wake_up(&sem->waiters, TASK_NORMAL, 1, sem);\n\n\t/*\n\t * Once this completes (at least one RCU-sched grace period hence) the\n\t * reader fast path will be available again. Safe to use outside the\n\t * exclusive write lock because its counting.\n\t */\n\trcu_sync_exit(&sem->rss);\n}",
          "includes": [
            "#include <linux/errno.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/wait.h>",
            "#include <linux/percpu.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/errno.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/lockdep.h>\n#include <linux/wait.h>\n#include <linux/percpu.h>\n#include <linux/atomic.h>\n\nvoid percpu_up_write(struct percpu_rw_semaphore *sem)\n{\n\trwsem_release(&sem->dep_map, _RET_IP_);\n\n\t/*\n\t * Signal the writer is done, no fast path yet.\n\t *\n\t * One reason that we cannot just immediately flip to readers_fast is\n\t * that new readers might fail to see the results of this writer's\n\t * critical section.\n\t *\n\t * Therefore we force it through the slow path which guarantees an\n\t * acquire and thereby guarantees the critical section's consistency.\n\t */\n\tatomic_set_release(&sem->block, 0);\n\n\t/*\n\t * Prod any pending reader/writer to make progress.\n\t */\n\t__wake_up(&sem->waiters, TASK_NORMAL, 1, sem);\n\n\t/*\n\t * Once this completes (at least one RCU-sched grace period hence) the\n\t * reader fast path will be available again. Safe to use outside the\n\t * exclusive write lock because its counting.\n\t */\n\trcu_sync_exit(&sem->rss);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_add_head",
          "args": [
            "&event->node",
            "&event_hash[key]"
          ],
          "line": 802
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ftrace_find_event",
          "args": [
            "event->type"
          ],
          "line": 787
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_find_event",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_output.c",
          "lines": "676-689",
          "snippet": "struct trace_event *ftrace_find_event(int type)\n{\n\tstruct trace_event *event;\n\tunsigned key;\n\n\tkey = type & (EVENT_HASHSIZE - 1);\n\n\thlist_for_each_entry(event, &event_hash[key], node) {\n\t\tif (event->type == type)\n\t\t\treturn event;\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define EVENT_HASHSIZE\t128"
          ],
          "globals_used": [
            "static struct hlist_head event_hash[EVENT_HASHSIZE]"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\n#define EVENT_HASHSIZE\t128\n\nstatic struct hlist_head event_hash[EVENT_HASHSIZE];\n\nstruct trace_event *ftrace_find_event(int type)\n{\n\tstruct trace_event *event;\n\tunsigned key;\n\n\tkey = type & (EVENT_HASHSIZE - 1);\n\n\thlist_for_each_entry(event, &event_hash[key], node) {\n\t\tif (event->type == type)\n\t\t\treturn event;\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "1"
          ],
          "line": 783
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_WARNING \"Need to add type to trace.h\\n\""
          ],
          "line": 782
        },
        "resolved": true,
        "details": {
          "function_name": "trace_print_printk_msg_only",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_output.c",
          "lines": "52-63",
          "snippet": "enum print_line_t trace_print_printk_msg_only(struct trace_iterator *iter)\n{\n\tstruct trace_seq *s = &iter->seq;\n\tstruct trace_entry *entry = iter->ent;\n\tstruct print_entry *field;\n\n\ttrace_assign_type(field, entry);\n\n\ttrace_seq_puts(s, field->buf);\n\n\treturn trace_handle_return(s);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nenum print_line_t trace_print_printk_msg_only(struct trace_iterator *iter)\n{\n\tstruct trace_seq *s = &iter->seq;\n\tstruct trace_entry *entry = iter->ent;\n\tstruct print_entry *field;\n\n\ttrace_assign_type(field, entry);\n\n\ttrace_seq_puts(s, field->buf);\n\n\treturn trace_handle_return(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&event->list",
            "list"
          ],
          "line": 779
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "ftrace_find_event(event->type)"
          ],
          "line": 776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_search_list",
          "args": [
            "&list"
          ],
          "line": 766
        },
        "resolved": true,
        "details": {
          "function_name": "trace_search_list",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_output.c",
          "lines": "693-719",
          "snippet": "static int trace_search_list(struct list_head **list)\n{\n\tstruct trace_event *e;\n\tint next = __TRACE_LAST_TYPE;\n\n\tif (list_empty(&ftrace_event_list)) {\n\t\t*list = &ftrace_event_list;\n\t\treturn next;\n\t}\n\n\t/*\n\t * We used up all possible max events,\n\t * lets see if somebody freed one.\n\t */\n\tlist_for_each_entry(e, &ftrace_event_list, list) {\n\t\tif (e->type != next)\n\t\t\tbreak;\n\t\tnext++;\n\t}\n\n\t/* Did we used up all 65 thousand events??? */\n\tif (next > TRACE_EVENT_TYPE_MAX)\n\t\treturn 0;\n\n\t*list = &e->list;\n\treturn next;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(ftrace_event_list);",
            "static struct trace_event *events[] __initdata = {\n\t&trace_fn_event,\n\t&trace_ctx_event,\n\t&trace_wake_event,\n\t&trace_stack_event,\n\t&trace_user_stack_event,\n\t&trace_bputs_event,\n\t&trace_bprint_event,\n\t&trace_print_event,\n\t&trace_hwlat_event,\n\t&trace_osnoise_event,\n\t&trace_timerlat_event,\n\t&trace_raw_data_event,\n\t&trace_func_repeats_event,\n\tNULL\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nstatic LIST_HEAD(ftrace_event_list);\nstatic struct trace_event *events[] __initdata = {\n\t&trace_fn_event,\n\t&trace_ctx_event,\n\t&trace_wake_event,\n\t&trace_stack_event,\n\t&trace_user_stack_event,\n\t&trace_bputs_event,\n\t&trace_bprint_event,\n\t&trace_print_event,\n\t&trace_hwlat_event,\n\t&trace_osnoise_event,\n\t&trace_timerlat_event,\n\t&trace_raw_data_event,\n\t&trace_func_repeats_event,\n\tNULL\n};\n\nstatic int trace_search_list(struct list_head **list)\n{\n\tstruct trace_event *e;\n\tint next = __TRACE_LAST_TYPE;\n\n\tif (list_empty(&ftrace_event_list)) {\n\t\t*list = &ftrace_event_list;\n\t\treturn next;\n\t}\n\n\t/*\n\t * We used up all possible max events,\n\t * lets see if somebody freed one.\n\t */\n\tlist_for_each_entry(e, &ftrace_event_list, list) {\n\t\tif (e->type != next)\n\t\t\tbreak;\n\t\tnext++;\n\t}\n\n\t/* Did we used up all 65 thousand events??? */\n\tif (next > TRACE_EVENT_TYPE_MAX)\n\t\treturn 0;\n\n\t*list = &e->list;\n\treturn next;\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&event->list"
          ],
          "line": 759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!event->funcs"
          ],
          "line": 756
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!event"
          ],
          "line": 753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&trace_event_sem"
          ],
          "line": 751
        },
        "resolved": true,
        "details": {
          "function_name": "percpu_down_write",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/percpu-rwsem.c",
          "lines": "214-239",
          "snippet": "void percpu_down_write(struct percpu_rw_semaphore *sem)\n{\n\tmight_sleep();\n\trwsem_acquire(&sem->dep_map, 0, 0, _RET_IP_);\n\n\t/* Notify readers to take the slow path. */\n\trcu_sync_enter(&sem->rss);\n\n\t/*\n\t * Try set sem->block; this provides writer-writer exclusion.\n\t * Having sem->block set makes new readers block.\n\t */\n\tif (!__percpu_down_write_trylock(sem))\n\t\tpercpu_rwsem_wait(sem, /* .reader = */ false);\n\n\t/* smp_mb() implied by __percpu_down_write_trylock() on success -- D matches A */\n\n\t/*\n\t * If they don't see our store of sem->block, then we are guaranteed to\n\t * see their sem->read_count increment, and therefore will wait for\n\t * them.\n\t */\n\n\t/* Wait for all active readers to complete. */\n\trcuwait_wait_event(&sem->writer, readers_active_check(sem), TASK_UNINTERRUPTIBLE);\n}",
          "includes": [
            "#include <linux/errno.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/wait.h>",
            "#include <linux/percpu.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/errno.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/lockdep.h>\n#include <linux/wait.h>\n#include <linux/percpu.h>\n#include <linux/atomic.h>\n\nvoid percpu_down_write(struct percpu_rw_semaphore *sem)\n{\n\tmight_sleep();\n\trwsem_acquire(&sem->dep_map, 0, 0, _RET_IP_);\n\n\t/* Notify readers to take the slow path. */\n\trcu_sync_enter(&sem->rss);\n\n\t/*\n\t * Try set sem->block; this provides writer-writer exclusion.\n\t * Having sem->block set makes new readers block.\n\t */\n\tif (!__percpu_down_write_trylock(sem))\n\t\tpercpu_rwsem_wait(sem, /* .reader = */ false);\n\n\t/* smp_mb() implied by __percpu_down_write_trylock() on success -- D matches A */\n\n\t/*\n\t * If they don't see our store of sem->block, then we are guaranteed to\n\t * see their sem->read_count increment, and therefore will wait for\n\t * them.\n\t */\n\n\t/* Wait for all active readers to complete. */\n\trcuwait_wait_event(&sem->writer, readers_active_check(sem), TASK_UNINTERRUPTIBLE);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\n#define EVENT_HASHSIZE\t128\n\nstatic struct hlist_head event_hash[EVENT_HASHSIZE];\nstatic int next_event_type = __TRACE_LAST_TYPE;\nstatic LIST_HEAD(ftrace_event_list);\n\nint register_trace_event(struct trace_event *event)\n{\n\tunsigned key;\n\tint ret = 0;\n\n\tdown_write(&trace_event_sem);\n\n\tif (WARN_ON(!event))\n\t\tgoto out;\n\n\tif (WARN_ON(!event->funcs))\n\t\tgoto out;\n\n\tINIT_LIST_HEAD(&event->list);\n\n\tif (!event->type) {\n\t\tstruct list_head *list = NULL;\n\n\t\tif (next_event_type > TRACE_EVENT_TYPE_MAX) {\n\n\t\t\tevent->type = trace_search_list(&list);\n\t\t\tif (!event->type)\n\t\t\t\tgoto out;\n\n\t\t} else {\n\n\t\t\tevent->type = next_event_type++;\n\t\t\tlist = &ftrace_event_list;\n\t\t}\n\n\t\tif (WARN_ON(ftrace_find_event(event->type)))\n\t\t\tgoto out;\n\n\t\tlist_add_tail(&event->list, list);\n\n\t} else if (event->type > __TRACE_LAST_TYPE) {\n\t\tprintk(KERN_WARNING \"Need to add type to trace.h\\n\");\n\t\tWARN_ON(1);\n\t\tgoto out;\n\t} else {\n\t\t/* Is this event already used */\n\t\tif (ftrace_find_event(event->type))\n\t\t\tgoto out;\n\t}\n\n\tif (event->funcs->trace == NULL)\n\t\tevent->funcs->trace = trace_nop_print;\n\tif (event->funcs->raw == NULL)\n\t\tevent->funcs->raw = trace_nop_print;\n\tif (event->funcs->hex == NULL)\n\t\tevent->funcs->hex = trace_nop_print;\n\tif (event->funcs->binary == NULL)\n\t\tevent->funcs->binary = trace_nop_print;\n\n\tkey = event->type & (EVENT_HASHSIZE - 1);\n\n\thlist_add_head(&event->node, &event_hash[key]);\n\n\tret = event->type;\n out:\n\tup_write(&trace_event_sem);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "trace_event_read_unlock",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_output.c",
    "lines": "726-729",
    "snippet": "void trace_event_read_unlock(void)\n{\n\tup_read(&trace_event_sem);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&trace_event_sem"
          ],
          "line": 728
        },
        "resolved": true,
        "details": {
          "function_name": "wakeup_readers",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/relay.c",
          "lines": "271-277",
          "snippet": "static void wakeup_readers(struct irq_work *work)\n{\n\tstruct rchan_buf *buf;\n\n\tbuf = container_of(work, struct rchan_buf, wakeup_work);\n\twake_up_interruptible(&buf->read_wait);\n}",
          "includes": [
            "#include <linux/splice.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/relay.h>",
            "#include <linux/string.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/stddef.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/splice.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/relay.h>\n#include <linux/string.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/stddef.h>\n#include <linux/errno.h>\n\nstatic void wakeup_readers(struct irq_work *work)\n{\n\tstruct rchan_buf *buf;\n\n\tbuf = container_of(work, struct rchan_buf, wakeup_work);\n\twake_up_interruptible(&buf->read_wait);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nvoid trace_event_read_unlock(void)\n{\n\tup_read(&trace_event_sem);\n}"
  },
  {
    "function_name": "trace_event_read_lock",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_output.c",
    "lines": "721-724",
    "snippet": "void trace_event_read_lock(void)\n{\n\tdown_read(&trace_event_sem);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&trace_event_sem"
          ],
          "line": 723
        },
        "resolved": true,
        "details": {
          "function_name": "__percpu_down_read_trylock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/percpu-rwsem.c",
          "lines": "46-80",
          "snippet": "static bool __percpu_down_read_trylock(struct percpu_rw_semaphore *sem)\n{\n\tthis_cpu_inc(*sem->read_count);\n\n\t/*\n\t * Due to having preemption disabled the decrement happens on\n\t * the same CPU as the increment, avoiding the\n\t * increment-on-one-CPU-and-decrement-on-another problem.\n\t *\n\t * If the reader misses the writer's assignment of sem->block, then the\n\t * writer is guaranteed to see the reader's increment.\n\t *\n\t * Conversely, any readers that increment their sem->read_count after\n\t * the writer looks are guaranteed to see the sem->block value, which\n\t * in turn means that they are guaranteed to immediately decrement\n\t * their sem->read_count, so that it doesn't matter that the writer\n\t * missed them.\n\t */\n\n\tsmp_mb(); /* A matches D */\n\n\t/*\n\t * If !sem->block the critical section starts here, matched by the\n\t * release in percpu_up_write().\n\t */\n\tif (likely(!atomic_read_acquire(&sem->block)))\n\t\treturn true;\n\n\tthis_cpu_dec(*sem->read_count);\n\n\t/* Prod writer to re-evaluate readers_active_check() */\n\trcuwait_wake_up(&sem->writer);\n\n\treturn false;\n}",
          "includes": [
            "#include <linux/errno.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/wait.h>",
            "#include <linux/percpu.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/errno.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/lockdep.h>\n#include <linux/wait.h>\n#include <linux/percpu.h>\n#include <linux/atomic.h>\n\nstatic bool __percpu_down_read_trylock(struct percpu_rw_semaphore *sem)\n{\n\tthis_cpu_inc(*sem->read_count);\n\n\t/*\n\t * Due to having preemption disabled the decrement happens on\n\t * the same CPU as the increment, avoiding the\n\t * increment-on-one-CPU-and-decrement-on-another problem.\n\t *\n\t * If the reader misses the writer's assignment of sem->block, then the\n\t * writer is guaranteed to see the reader's increment.\n\t *\n\t * Conversely, any readers that increment their sem->read_count after\n\t * the writer looks are guaranteed to see the sem->block value, which\n\t * in turn means that they are guaranteed to immediately decrement\n\t * their sem->read_count, so that it doesn't matter that the writer\n\t * missed them.\n\t */\n\n\tsmp_mb(); /* A matches D */\n\n\t/*\n\t * If !sem->block the critical section starts here, matched by the\n\t * release in percpu_up_write().\n\t */\n\tif (likely(!atomic_read_acquire(&sem->block)))\n\t\treturn true;\n\n\tthis_cpu_dec(*sem->read_count);\n\n\t/* Prod writer to re-evaluate readers_active_check() */\n\trcuwait_wake_up(&sem->writer);\n\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nvoid trace_event_read_lock(void)\n{\n\tdown_read(&trace_event_sem);\n}"
  },
  {
    "function_name": "trace_search_list",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_output.c",
    "lines": "693-719",
    "snippet": "static int trace_search_list(struct list_head **list)\n{\n\tstruct trace_event *e;\n\tint next = __TRACE_LAST_TYPE;\n\n\tif (list_empty(&ftrace_event_list)) {\n\t\t*list = &ftrace_event_list;\n\t\treturn next;\n\t}\n\n\t/*\n\t * We used up all possible max events,\n\t * lets see if somebody freed one.\n\t */\n\tlist_for_each_entry(e, &ftrace_event_list, list) {\n\t\tif (e->type != next)\n\t\t\tbreak;\n\t\tnext++;\n\t}\n\n\t/* Did we used up all 65 thousand events??? */\n\tif (next > TRACE_EVENT_TYPE_MAX)\n\t\treturn 0;\n\n\t*list = &e->list;\n\treturn next;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(ftrace_event_list);",
      "static struct trace_event *events[] __initdata = {\n\t&trace_fn_event,\n\t&trace_ctx_event,\n\t&trace_wake_event,\n\t&trace_stack_event,\n\t&trace_user_stack_event,\n\t&trace_bputs_event,\n\t&trace_bprint_event,\n\t&trace_print_event,\n\t&trace_hwlat_event,\n\t&trace_osnoise_event,\n\t&trace_timerlat_event,\n\t&trace_raw_data_event,\n\t&trace_func_repeats_event,\n\tNULL\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "e",
            "&ftrace_event_list",
            "list"
          ],
          "line": 707
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&ftrace_event_list"
          ],
          "line": 698
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "41-44",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "long rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nlong rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nstatic LIST_HEAD(ftrace_event_list);\nstatic struct trace_event *events[] __initdata = {\n\t&trace_fn_event,\n\t&trace_ctx_event,\n\t&trace_wake_event,\n\t&trace_stack_event,\n\t&trace_user_stack_event,\n\t&trace_bputs_event,\n\t&trace_bprint_event,\n\t&trace_print_event,\n\t&trace_hwlat_event,\n\t&trace_osnoise_event,\n\t&trace_timerlat_event,\n\t&trace_raw_data_event,\n\t&trace_func_repeats_event,\n\tNULL\n};\n\nstatic int trace_search_list(struct list_head **list)\n{\n\tstruct trace_event *e;\n\tint next = __TRACE_LAST_TYPE;\n\n\tif (list_empty(&ftrace_event_list)) {\n\t\t*list = &ftrace_event_list;\n\t\treturn next;\n\t}\n\n\t/*\n\t * We used up all possible max events,\n\t * lets see if somebody freed one.\n\t */\n\tlist_for_each_entry(e, &ftrace_event_list, list) {\n\t\tif (e->type != next)\n\t\t\tbreak;\n\t\tnext++;\n\t}\n\n\t/* Did we used up all 65 thousand events??? */\n\tif (next > TRACE_EVENT_TYPE_MAX)\n\t\treturn 0;\n\n\t*list = &e->list;\n\treturn next;\n}"
  },
  {
    "function_name": "ftrace_find_event",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_output.c",
    "lines": "676-689",
    "snippet": "struct trace_event *ftrace_find_event(int type)\n{\n\tstruct trace_event *event;\n\tunsigned key;\n\n\tkey = type & (EVENT_HASHSIZE - 1);\n\n\thlist_for_each_entry(event, &event_hash[key], node) {\n\t\tif (event->type == type)\n\t\t\treturn event;\n\t}\n\n\treturn NULL;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define EVENT_HASHSIZE\t128"
    ],
    "globals_used": [
      "static struct hlist_head event_hash[EVENT_HASHSIZE]"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "hlist_for_each_entry",
          "args": [
            "event",
            "&event_hash[key]",
            "node"
          ],
          "line": 683
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\n#define EVENT_HASHSIZE\t128\n\nstatic struct hlist_head event_hash[EVENT_HASHSIZE];\n\nstruct trace_event *ftrace_find_event(int type)\n{\n\tstruct trace_event *event;\n\tunsigned key;\n\n\tkey = type & (EVENT_HASHSIZE - 1);\n\n\thlist_for_each_entry(event, &event_hash[key], node) {\n\t\tif (event->type == type)\n\t\t\treturn event;\n\t}\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "trace_print_lat_context",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_output.c",
    "lines": "636-667",
    "snippet": "int trace_print_lat_context(struct trace_iterator *iter)\n{\n\tstruct trace_entry *entry, *next_entry;\n\tstruct trace_array *tr = iter->tr;\n\tstruct trace_seq *s = &iter->seq;\n\tunsigned long verbose = (tr->trace_flags & TRACE_ITER_VERBOSE);\n\tu64 next_ts;\n\n\tnext_entry = trace_find_next_entry(iter, NULL, &next_ts);\n\tif (!next_entry)\n\t\tnext_ts = iter->ts;\n\n\t/* trace_find_next_entry() may change iter->ent */\n\tentry = iter->ent;\n\n\tif (verbose) {\n\t\tchar comm[TASK_COMM_LEN];\n\n\t\ttrace_find_cmdline(entry->pid, comm);\n\n\t\ttrace_seq_printf(\n\t\t\ts, \"%16s %7d %3d %d %08x %08lx \",\n\t\t\tcomm, entry->pid, iter->cpu, entry->flags,\n\t\t\tentry->preempt_count & 0xf, iter->idx);\n\t} else {\n\t\tlat_print_generic(s, entry, iter->cpu);\n\t}\n\n\tlat_print_timestamp(iter, next_ts);\n\n\treturn !trace_seq_has_overflowed(s);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_seq_has_overflowed",
          "args": [
            "s"
          ],
          "line": 666
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lat_print_timestamp",
          "args": [
            "iter",
            "next_ts"
          ],
          "line": 664
        },
        "resolved": true,
        "details": {
          "function_name": "lat_print_timestamp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_output.c",
          "lines": "545-588",
          "snippet": "static int\nlat_print_timestamp(struct trace_iterator *iter, u64 next_ts)\n{\n\tstruct trace_array *tr = iter->tr;\n\tunsigned long verbose = tr->trace_flags & TRACE_ITER_VERBOSE;\n\tunsigned long in_ns = iter->iter_flags & TRACE_FILE_TIME_IN_NS;\n\tunsigned long long abs_ts = iter->ts - iter->array_buffer->time_start;\n\tunsigned long long rel_ts = next_ts - iter->ts;\n\tstruct trace_seq *s = &iter->seq;\n\n\tif (in_ns) {\n\t\tabs_ts = ns2usecs(abs_ts);\n\t\trel_ts = ns2usecs(rel_ts);\n\t}\n\n\tif (verbose && in_ns) {\n\t\tunsigned long abs_usec = do_div(abs_ts, USEC_PER_MSEC);\n\t\tunsigned long abs_msec = (unsigned long)abs_ts;\n\t\tunsigned long rel_usec = do_div(rel_ts, USEC_PER_MSEC);\n\t\tunsigned long rel_msec = (unsigned long)rel_ts;\n\n\t\ttrace_seq_printf(\n\t\t\ts, \"[%08llx] %ld.%03ldms (+%ld.%03ldms): \",\n\t\t\tns2usecs(iter->ts),\n\t\t\tabs_msec, abs_usec,\n\t\t\trel_msec, rel_usec);\n\n\t} else if (verbose && !in_ns) {\n\t\ttrace_seq_printf(\n\t\t\ts, \"[%016llx] %lld (+%lld): \",\n\t\t\titer->ts, abs_ts, rel_ts);\n\n\t} else if (!verbose && in_ns) {\n\t\ttrace_seq_printf(\n\t\t\ts, \" %4lldus%c: \",\n\t\t\tabs_ts,\n\t\t\ttrace_find_mark(rel_ts * NSEC_PER_USEC));\n\n\t} else { /* !verbose && !in_ns */\n\t\ttrace_seq_printf(s, \" %4lld: \", abs_ts);\n\t}\n\n\treturn !trace_seq_has_overflowed(s);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nstatic int\nlat_print_timestamp(struct trace_iterator *iter, u64 next_ts)\n{\n\tstruct trace_array *tr = iter->tr;\n\tunsigned long verbose = tr->trace_flags & TRACE_ITER_VERBOSE;\n\tunsigned long in_ns = iter->iter_flags & TRACE_FILE_TIME_IN_NS;\n\tunsigned long long abs_ts = iter->ts - iter->array_buffer->time_start;\n\tunsigned long long rel_ts = next_ts - iter->ts;\n\tstruct trace_seq *s = &iter->seq;\n\n\tif (in_ns) {\n\t\tabs_ts = ns2usecs(abs_ts);\n\t\trel_ts = ns2usecs(rel_ts);\n\t}\n\n\tif (verbose && in_ns) {\n\t\tunsigned long abs_usec = do_div(abs_ts, USEC_PER_MSEC);\n\t\tunsigned long abs_msec = (unsigned long)abs_ts;\n\t\tunsigned long rel_usec = do_div(rel_ts, USEC_PER_MSEC);\n\t\tunsigned long rel_msec = (unsigned long)rel_ts;\n\n\t\ttrace_seq_printf(\n\t\t\ts, \"[%08llx] %ld.%03ldms (+%ld.%03ldms): \",\n\t\t\tns2usecs(iter->ts),\n\t\t\tabs_msec, abs_usec,\n\t\t\trel_msec, rel_usec);\n\n\t} else if (verbose && !in_ns) {\n\t\ttrace_seq_printf(\n\t\t\ts, \"[%016llx] %lld (+%lld): \",\n\t\t\titer->ts, abs_ts, rel_ts);\n\n\t} else if (!verbose && in_ns) {\n\t\ttrace_seq_printf(\n\t\t\ts, \" %4lldus%c: \",\n\t\t\tabs_ts,\n\t\t\ttrace_find_mark(rel_ts * NSEC_PER_USEC));\n\n\t} else { /* !verbose && !in_ns */\n\t\ttrace_seq_printf(s, \" %4lld: \", abs_ts);\n\t}\n\n\treturn !trace_seq_has_overflowed(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lat_print_generic",
          "args": [
            "s",
            "entry",
            "iter->cpu"
          ],
          "line": 661
        },
        "resolved": true,
        "details": {
          "function_name": "lat_print_generic",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_output.c",
          "lines": "503-514",
          "snippet": "static int\nlat_print_generic(struct trace_seq *s, struct trace_entry *entry, int cpu)\n{\n\tchar comm[TASK_COMM_LEN];\n\n\ttrace_find_cmdline(entry->pid, comm);\n\n\ttrace_seq_printf(s, \"%8.8s-%-7d %3d\",\n\t\t\t comm, entry->pid, cpu);\n\n\treturn trace_print_lat_fmt(s, entry);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nstatic int\nlat_print_generic(struct trace_seq *s, struct trace_entry *entry, int cpu)\n{\n\tchar comm[TASK_COMM_LEN];\n\n\ttrace_find_cmdline(entry->pid, comm);\n\n\ttrace_seq_printf(s, \"%8.8s-%-7d %3d\",\n\t\t\t comm, entry->pid, cpu);\n\n\treturn trace_print_lat_fmt(s, entry);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_seq_printf",
          "args": [
            "s",
            "\"%16s %7d %3d %d %08x %08lx \"",
            "comm",
            "entry->pid",
            "iter->cpu",
            "entry->flags",
            "entry->preempt_count & 0xf",
            "iter->idx"
          ],
          "line": 656
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "81-100",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_find_cmdline",
          "args": [
            "entry->pid",
            "comm"
          ],
          "line": 654
        },
        "resolved": true,
        "details": {
          "function_name": "trace_find_cmdline",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "2443-2452",
          "snippet": "void trace_find_cmdline(int pid, char comm[])\n{\n\tpreempt_disable();\n\tarch_spin_lock(&trace_cmdline_lock);\n\n\t__trace_find_cmdline(pid, comm);\n\n\tarch_spin_unlock(&trace_cmdline_lock);\n\tpreempt_enable();\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static arch_spinlock_t trace_cmdline_lock = __ARCH_SPIN_LOCK_UNLOCKED;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic arch_spinlock_t trace_cmdline_lock = __ARCH_SPIN_LOCK_UNLOCKED;\n\nvoid trace_find_cmdline(int pid, char comm[])\n{\n\tpreempt_disable();\n\tarch_spin_lock(&trace_cmdline_lock);\n\n\t__trace_find_cmdline(pid, comm);\n\n\tarch_spin_unlock(&trace_cmdline_lock);\n\tpreempt_enable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_find_next_entry",
          "args": [
            "iter",
            "NULL",
            "&next_ts"
          ],
          "line": 644
        },
        "resolved": true,
        "details": {
          "function_name": "trace_find_next_entry",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "3935-3978",
          "snippet": "struct trace_entry *trace_find_next_entry(struct trace_iterator *iter,\n\t\t\t\t\t  int *ent_cpu, u64 *ent_ts)\n{\n\t/* __find_next_entry will reset ent_size */\n\tint ent_size = iter->ent_size;\n\tstruct trace_entry *entry;\n\n\t/*\n\t * If called from ftrace_dump(), then the iter->temp buffer\n\t * will be the static_temp_buf and not created from kmalloc.\n\t * If the entry size is greater than the buffer, we can\n\t * not save it. Just return NULL in that case. This is only\n\t * used to add markers when two consecutive events' time\n\t * stamps have a large delta. See trace_print_lat_context()\n\t */\n\tif (iter->temp == static_temp_buf &&\n\t    STATIC_TEMP_BUF_SIZE < ent_size)\n\t\treturn NULL;\n\n\t/*\n\t * The __find_next_entry() may call peek_next_entry(), which may\n\t * call ring_buffer_peek() that may make the contents of iter->ent\n\t * undefined. Need to copy iter->ent now.\n\t */\n\tif (iter->ent && iter->ent != iter->temp) {\n\t\tif ((!iter->temp || iter->temp_size < iter->ent_size) &&\n\t\t    !WARN_ON_ONCE(iter->temp == static_temp_buf)) {\n\t\t\tvoid *temp;\n\t\t\ttemp = kmalloc(iter->ent_size, GFP_KERNEL);\n\t\t\tif (!temp)\n\t\t\t\treturn NULL;\n\t\t\tkfree(iter->temp);\n\t\t\titer->temp = temp;\n\t\t\titer->temp_size = iter->ent_size;\n\t\t}\n\t\tmemcpy(iter->temp, iter->ent, iter->ent_size);\n\t\titer->ent = iter->temp;\n\t}\n\tentry = __find_next_entry(iter, ent_cpu, NULL, ent_ts);\n\t/* Put back the original ent_size */\n\titer->ent_size = ent_size;\n\n\treturn entry;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [
            "#define STATIC_TEMP_BUF_SIZE\t128"
          ],
          "globals_used": [
            "static __always_inline struct",
            "static char static_temp_buf[STATIC_TEMP_BUF_SIZE]"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\n#define STATIC_TEMP_BUF_SIZE\t128\n\nstatic __always_inline struct;\nstatic char static_temp_buf[STATIC_TEMP_BUF_SIZE];\n\nstruct trace_entry *trace_find_next_entry(struct trace_iterator *iter,\n\t\t\t\t\t  int *ent_cpu, u64 *ent_ts)\n{\n\t/* __find_next_entry will reset ent_size */\n\tint ent_size = iter->ent_size;\n\tstruct trace_entry *entry;\n\n\t/*\n\t * If called from ftrace_dump(), then the iter->temp buffer\n\t * will be the static_temp_buf and not created from kmalloc.\n\t * If the entry size is greater than the buffer, we can\n\t * not save it. Just return NULL in that case. This is only\n\t * used to add markers when two consecutive events' time\n\t * stamps have a large delta. See trace_print_lat_context()\n\t */\n\tif (iter->temp == static_temp_buf &&\n\t    STATIC_TEMP_BUF_SIZE < ent_size)\n\t\treturn NULL;\n\n\t/*\n\t * The __find_next_entry() may call peek_next_entry(), which may\n\t * call ring_buffer_peek() that may make the contents of iter->ent\n\t * undefined. Need to copy iter->ent now.\n\t */\n\tif (iter->ent && iter->ent != iter->temp) {\n\t\tif ((!iter->temp || iter->temp_size < iter->ent_size) &&\n\t\t    !WARN_ON_ONCE(iter->temp == static_temp_buf)) {\n\t\t\tvoid *temp;\n\t\t\ttemp = kmalloc(iter->ent_size, GFP_KERNEL);\n\t\t\tif (!temp)\n\t\t\t\treturn NULL;\n\t\t\tkfree(iter->temp);\n\t\t\titer->temp = temp;\n\t\t\titer->temp_size = iter->ent_size;\n\t\t}\n\t\tmemcpy(iter->temp, iter->ent, iter->ent_size);\n\t\titer->ent = iter->temp;\n\t}\n\tentry = __find_next_entry(iter, ent_cpu, NULL, ent_ts);\n\t/* Put back the original ent_size */\n\titer->ent_size = ent_size;\n\n\treturn entry;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nint trace_print_lat_context(struct trace_iterator *iter)\n{\n\tstruct trace_entry *entry, *next_entry;\n\tstruct trace_array *tr = iter->tr;\n\tstruct trace_seq *s = &iter->seq;\n\tunsigned long verbose = (tr->trace_flags & TRACE_ITER_VERBOSE);\n\tu64 next_ts;\n\n\tnext_entry = trace_find_next_entry(iter, NULL, &next_ts);\n\tif (!next_entry)\n\t\tnext_ts = iter->ts;\n\n\t/* trace_find_next_entry() may change iter->ent */\n\tentry = iter->ent;\n\n\tif (verbose) {\n\t\tchar comm[TASK_COMM_LEN];\n\n\t\ttrace_find_cmdline(entry->pid, comm);\n\n\t\ttrace_seq_printf(\n\t\t\ts, \"%16s %7d %3d %d %08x %08lx \",\n\t\t\tcomm, entry->pid, iter->cpu, entry->flags,\n\t\t\tentry->preempt_count & 0xf, iter->idx);\n\t} else {\n\t\tlat_print_generic(s, entry, iter->cpu);\n\t}\n\n\tlat_print_timestamp(iter, next_ts);\n\n\treturn !trace_seq_has_overflowed(s);\n}"
  },
  {
    "function_name": "trace_print_context",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_output.c",
    "lines": "605-634",
    "snippet": "int trace_print_context(struct trace_iterator *iter)\n{\n\tstruct trace_array *tr = iter->tr;\n\tstruct trace_seq *s = &iter->seq;\n\tstruct trace_entry *entry = iter->ent;\n\tchar comm[TASK_COMM_LEN];\n\n\ttrace_find_cmdline(entry->pid, comm);\n\n\ttrace_seq_printf(s, \"%16s-%-7d \", comm, entry->pid);\n\n\tif (tr->trace_flags & TRACE_ITER_RECORD_TGID) {\n\t\tunsigned int tgid = trace_find_tgid(entry->pid);\n\n\t\tif (!tgid)\n\t\t\ttrace_seq_printf(s, \"(-------) \");\n\t\telse\n\t\t\ttrace_seq_printf(s, \"(%7d) \", tgid);\n\t}\n\n\ttrace_seq_printf(s, \"[%03d] \", iter->cpu);\n\n\tif (tr->trace_flags & TRACE_ITER_IRQ_INFO)\n\t\ttrace_print_lat_fmt(s, entry);\n\n\ttrace_print_time(s, iter, iter->ts);\n\ttrace_seq_puts(s, \": \");\n\n\treturn !trace_seq_has_overflowed(s);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_seq_has_overflowed",
          "args": [
            "s"
          ],
          "line": 633
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_seq_puts",
          "args": [
            "s",
            "\": \""
          ],
          "line": 631
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_puts",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "205-220",
          "snippet": "void trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_print_time",
          "args": [
            "s",
            "iter",
            "iter->ts"
          ],
          "line": 630
        },
        "resolved": true,
        "details": {
          "function_name": "trace_print_time",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_output.c",
          "lines": "590-603",
          "snippet": "static void trace_print_time(struct trace_seq *s, struct trace_iterator *iter,\n\t\t\t     unsigned long long ts)\n{\n\tunsigned long secs, usec_rem;\n\tunsigned long long t;\n\n\tif (iter->iter_flags & TRACE_FILE_TIME_IN_NS) {\n\t\tt = ns2usecs(ts);\n\t\tusec_rem = do_div(t, USEC_PER_SEC);\n\t\tsecs = (unsigned long)t;\n\t\ttrace_seq_printf(s, \" %5lu.%06lu\", secs, usec_rem);\n\t} else\n\t\ttrace_seq_printf(s, \" %12llu\", ts);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nstatic void trace_print_time(struct trace_seq *s, struct trace_iterator *iter,\n\t\t\t     unsigned long long ts)\n{\n\tunsigned long secs, usec_rem;\n\tunsigned long long t;\n\n\tif (iter->iter_flags & TRACE_FILE_TIME_IN_NS) {\n\t\tt = ns2usecs(ts);\n\t\tusec_rem = do_div(t, USEC_PER_SEC);\n\t\tsecs = (unsigned long)t;\n\t\ttrace_seq_printf(s, \" %5lu.%06lu\", secs, usec_rem);\n\t} else\n\t\ttrace_seq_printf(s, \" %12llu\", ts);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_print_lat_fmt",
          "args": [
            "s",
            "entry"
          ],
          "line": 628
        },
        "resolved": true,
        "details": {
          "function_name": "trace_print_lat_fmt",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_output.c",
          "lines": "441-501",
          "snippet": "int trace_print_lat_fmt(struct trace_seq *s, struct trace_entry *entry)\n{\n\tchar hardsoft_irq;\n\tchar need_resched;\n\tchar irqs_off;\n\tint hardirq;\n\tint softirq;\n\tint bh_off;\n\tint nmi;\n\n\tnmi = entry->flags & TRACE_FLAG_NMI;\n\thardirq = entry->flags & TRACE_FLAG_HARDIRQ;\n\tsoftirq = entry->flags & TRACE_FLAG_SOFTIRQ;\n\tbh_off = entry->flags & TRACE_FLAG_BH_OFF;\n\n\tirqs_off =\n\t\t(entry->flags & TRACE_FLAG_IRQS_OFF && bh_off) ? 'D' :\n\t\t(entry->flags & TRACE_FLAG_IRQS_OFF) ? 'd' :\n\t\tbh_off ? 'b' :\n\t\t(entry->flags & TRACE_FLAG_IRQS_NOSUPPORT) ? 'X' :\n\t\t'.';\n\n\tswitch (entry->flags & (TRACE_FLAG_NEED_RESCHED |\n\t\t\t\tTRACE_FLAG_PREEMPT_RESCHED)) {\n\tcase TRACE_FLAG_NEED_RESCHED | TRACE_FLAG_PREEMPT_RESCHED:\n\t\tneed_resched = 'N';\n\t\tbreak;\n\tcase TRACE_FLAG_NEED_RESCHED:\n\t\tneed_resched = 'n';\n\t\tbreak;\n\tcase TRACE_FLAG_PREEMPT_RESCHED:\n\t\tneed_resched = 'p';\n\t\tbreak;\n\tdefault:\n\t\tneed_resched = '.';\n\t\tbreak;\n\t}\n\n\thardsoft_irq =\n\t\t(nmi && hardirq)     ? 'Z' :\n\t\tnmi                  ? 'z' :\n\t\t(hardirq && softirq) ? 'H' :\n\t\thardirq              ? 'h' :\n\t\tsoftirq              ? 's' :\n\t\t                       '.' ;\n\n\ttrace_seq_printf(s, \"%c%c%c\",\n\t\t\t irqs_off, need_resched, hardsoft_irq);\n\n\tif (entry->preempt_count & 0xf)\n\t\ttrace_seq_printf(s, \"%x\", entry->preempt_count & 0xf);\n\telse\n\t\ttrace_seq_putc(s, '.');\n\n\tif (entry->preempt_count & 0xf0)\n\t\ttrace_seq_printf(s, \"%x\", entry->preempt_count >> 4);\n\telse\n\t\ttrace_seq_putc(s, '.');\n\n\treturn !trace_seq_has_overflowed(s);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nint trace_print_lat_fmt(struct trace_seq *s, struct trace_entry *entry)\n{\n\tchar hardsoft_irq;\n\tchar need_resched;\n\tchar irqs_off;\n\tint hardirq;\n\tint softirq;\n\tint bh_off;\n\tint nmi;\n\n\tnmi = entry->flags & TRACE_FLAG_NMI;\n\thardirq = entry->flags & TRACE_FLAG_HARDIRQ;\n\tsoftirq = entry->flags & TRACE_FLAG_SOFTIRQ;\n\tbh_off = entry->flags & TRACE_FLAG_BH_OFF;\n\n\tirqs_off =\n\t\t(entry->flags & TRACE_FLAG_IRQS_OFF && bh_off) ? 'D' :\n\t\t(entry->flags & TRACE_FLAG_IRQS_OFF) ? 'd' :\n\t\tbh_off ? 'b' :\n\t\t(entry->flags & TRACE_FLAG_IRQS_NOSUPPORT) ? 'X' :\n\t\t'.';\n\n\tswitch (entry->flags & (TRACE_FLAG_NEED_RESCHED |\n\t\t\t\tTRACE_FLAG_PREEMPT_RESCHED)) {\n\tcase TRACE_FLAG_NEED_RESCHED | TRACE_FLAG_PREEMPT_RESCHED:\n\t\tneed_resched = 'N';\n\t\tbreak;\n\tcase TRACE_FLAG_NEED_RESCHED:\n\t\tneed_resched = 'n';\n\t\tbreak;\n\tcase TRACE_FLAG_PREEMPT_RESCHED:\n\t\tneed_resched = 'p';\n\t\tbreak;\n\tdefault:\n\t\tneed_resched = '.';\n\t\tbreak;\n\t}\n\n\thardsoft_irq =\n\t\t(nmi && hardirq)     ? 'Z' :\n\t\tnmi                  ? 'z' :\n\t\t(hardirq && softirq) ? 'H' :\n\t\thardirq              ? 'h' :\n\t\tsoftirq              ? 's' :\n\t\t                       '.' ;\n\n\ttrace_seq_printf(s, \"%c%c%c\",\n\t\t\t irqs_off, need_resched, hardsoft_irq);\n\n\tif (entry->preempt_count & 0xf)\n\t\ttrace_seq_printf(s, \"%x\", entry->preempt_count & 0xf);\n\telse\n\t\ttrace_seq_putc(s, '.');\n\n\tif (entry->preempt_count & 0xf0)\n\t\ttrace_seq_printf(s, \"%x\", entry->preempt_count >> 4);\n\telse\n\t\ttrace_seq_putc(s, '.');\n\n\treturn !trace_seq_has_overflowed(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_seq_printf",
          "args": [
            "s",
            "\"[%03d] \"",
            "iter->cpu"
          ],
          "line": 625
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "81-100",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_find_tgid",
          "args": [
            "entry->pid"
          ],
          "line": 617
        },
        "resolved": true,
        "details": {
          "function_name": "trace_find_tgid",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "2469-2474",
          "snippet": "int trace_find_tgid(int pid)\n{\n\tint *ptr = trace_find_tgid_ptr(pid);\n\n\treturn ptr ? *ptr : 0;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nint trace_find_tgid(int pid)\n{\n\tint *ptr = trace_find_tgid_ptr(pid);\n\n\treturn ptr ? *ptr : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_find_cmdline",
          "args": [
            "entry->pid",
            "comm"
          ],
          "line": 612
        },
        "resolved": true,
        "details": {
          "function_name": "trace_find_cmdline",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "2443-2452",
          "snippet": "void trace_find_cmdline(int pid, char comm[])\n{\n\tpreempt_disable();\n\tarch_spin_lock(&trace_cmdline_lock);\n\n\t__trace_find_cmdline(pid, comm);\n\n\tarch_spin_unlock(&trace_cmdline_lock);\n\tpreempt_enable();\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static arch_spinlock_t trace_cmdline_lock = __ARCH_SPIN_LOCK_UNLOCKED;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic arch_spinlock_t trace_cmdline_lock = __ARCH_SPIN_LOCK_UNLOCKED;\n\nvoid trace_find_cmdline(int pid, char comm[])\n{\n\tpreempt_disable();\n\tarch_spin_lock(&trace_cmdline_lock);\n\n\t__trace_find_cmdline(pid, comm);\n\n\tarch_spin_unlock(&trace_cmdline_lock);\n\tpreempt_enable();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nint trace_print_context(struct trace_iterator *iter)\n{\n\tstruct trace_array *tr = iter->tr;\n\tstruct trace_seq *s = &iter->seq;\n\tstruct trace_entry *entry = iter->ent;\n\tchar comm[TASK_COMM_LEN];\n\n\ttrace_find_cmdline(entry->pid, comm);\n\n\ttrace_seq_printf(s, \"%16s-%-7d \", comm, entry->pid);\n\n\tif (tr->trace_flags & TRACE_ITER_RECORD_TGID) {\n\t\tunsigned int tgid = trace_find_tgid(entry->pid);\n\n\t\tif (!tgid)\n\t\t\ttrace_seq_printf(s, \"(-------) \");\n\t\telse\n\t\t\ttrace_seq_printf(s, \"(%7d) \", tgid);\n\t}\n\n\ttrace_seq_printf(s, \"[%03d] \", iter->cpu);\n\n\tif (tr->trace_flags & TRACE_ITER_IRQ_INFO)\n\t\ttrace_print_lat_fmt(s, entry);\n\n\ttrace_print_time(s, iter, iter->ts);\n\ttrace_seq_puts(s, \": \");\n\n\treturn !trace_seq_has_overflowed(s);\n}"
  },
  {
    "function_name": "trace_print_time",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_output.c",
    "lines": "590-603",
    "snippet": "static void trace_print_time(struct trace_seq *s, struct trace_iterator *iter,\n\t\t\t     unsigned long long ts)\n{\n\tunsigned long secs, usec_rem;\n\tunsigned long long t;\n\n\tif (iter->iter_flags & TRACE_FILE_TIME_IN_NS) {\n\t\tt = ns2usecs(ts);\n\t\tusec_rem = do_div(t, USEC_PER_SEC);\n\t\tsecs = (unsigned long)t;\n\t\ttrace_seq_printf(s, \" %5lu.%06lu\", secs, usec_rem);\n\t} else\n\t\ttrace_seq_printf(s, \" %12llu\", ts);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_seq_printf",
          "args": [
            "s",
            "\" %12llu\"",
            "ts"
          ],
          "line": 602
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "81-100",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_div",
          "args": [
            "t",
            "USEC_PER_SEC"
          ],
          "line": 598
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ns2usecs",
          "args": [
            "ts"
          ],
          "line": 597
        },
        "resolved": true,
        "details": {
          "function_name": "ns2usecs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "268-273",
          "snippet": "unsigned long long ns2usecs(u64 nsec)\n{\n\tnsec += 500;\n\tdo_div(nsec, 1000);\n\treturn nsec;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nunsigned long long ns2usecs(u64 nsec)\n{\n\tnsec += 500;\n\tdo_div(nsec, 1000);\n\treturn nsec;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nstatic void trace_print_time(struct trace_seq *s, struct trace_iterator *iter,\n\t\t\t     unsigned long long ts)\n{\n\tunsigned long secs, usec_rem;\n\tunsigned long long t;\n\n\tif (iter->iter_flags & TRACE_FILE_TIME_IN_NS) {\n\t\tt = ns2usecs(ts);\n\t\tusec_rem = do_div(t, USEC_PER_SEC);\n\t\tsecs = (unsigned long)t;\n\t\ttrace_seq_printf(s, \" %5lu.%06lu\", secs, usec_rem);\n\t} else\n\t\ttrace_seq_printf(s, \" %12llu\", ts);\n}"
  },
  {
    "function_name": "lat_print_timestamp",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_output.c",
    "lines": "545-588",
    "snippet": "static int\nlat_print_timestamp(struct trace_iterator *iter, u64 next_ts)\n{\n\tstruct trace_array *tr = iter->tr;\n\tunsigned long verbose = tr->trace_flags & TRACE_ITER_VERBOSE;\n\tunsigned long in_ns = iter->iter_flags & TRACE_FILE_TIME_IN_NS;\n\tunsigned long long abs_ts = iter->ts - iter->array_buffer->time_start;\n\tunsigned long long rel_ts = next_ts - iter->ts;\n\tstruct trace_seq *s = &iter->seq;\n\n\tif (in_ns) {\n\t\tabs_ts = ns2usecs(abs_ts);\n\t\trel_ts = ns2usecs(rel_ts);\n\t}\n\n\tif (verbose && in_ns) {\n\t\tunsigned long abs_usec = do_div(abs_ts, USEC_PER_MSEC);\n\t\tunsigned long abs_msec = (unsigned long)abs_ts;\n\t\tunsigned long rel_usec = do_div(rel_ts, USEC_PER_MSEC);\n\t\tunsigned long rel_msec = (unsigned long)rel_ts;\n\n\t\ttrace_seq_printf(\n\t\t\ts, \"[%08llx] %ld.%03ldms (+%ld.%03ldms): \",\n\t\t\tns2usecs(iter->ts),\n\t\t\tabs_msec, abs_usec,\n\t\t\trel_msec, rel_usec);\n\n\t} else if (verbose && !in_ns) {\n\t\ttrace_seq_printf(\n\t\t\ts, \"[%016llx] %lld (+%lld): \",\n\t\t\titer->ts, abs_ts, rel_ts);\n\n\t} else if (!verbose && in_ns) {\n\t\ttrace_seq_printf(\n\t\t\ts, \" %4lldus%c: \",\n\t\t\tabs_ts,\n\t\t\ttrace_find_mark(rel_ts * NSEC_PER_USEC));\n\n\t} else { /* !verbose && !in_ns */\n\t\ttrace_seq_printf(s, \" %4lld: \", abs_ts);\n\t}\n\n\treturn !trace_seq_has_overflowed(s);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_seq_has_overflowed",
          "args": [
            "s"
          ],
          "line": 587
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_seq_printf",
          "args": [
            "s",
            "\" %4lld: \"",
            "abs_ts"
          ],
          "line": 584
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "81-100",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_find_mark",
          "args": [
            "rel_ts * NSEC_PER_USEC"
          ],
          "line": 581
        },
        "resolved": true,
        "details": {
          "function_name": "trace_find_mark",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_output.c",
          "lines": "532-543",
          "snippet": "char trace_find_mark(unsigned long long d)\n{\n\tint i;\n\tint size = ARRAY_SIZE(mark);\n\n\tfor (i = 0; i < size; i++) {\n\t\tif (d > mark[i].val)\n\t\t\tbreak;\n\t}\n\n\treturn (i == size) ? ' ' : mark[i].sym;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct trace_mark {\n\tunsigned long long\tval; /* unit: nsec */\n\tchar\t\t\tsym;\n} mark[] = {\n\tMARK(1000000000ULL\t, '$'), /* 1 sec */\n\tMARK(100000000ULL\t, '@'), /* 100 msec */\n\tMARK(10000000ULL\t, '*'), /* 10 msec */\n\tMARK(1000000ULL\t\t, '#'), /* 1000 usecs */\n\tMARK(100000ULL\t\t, '!'), /* 100 usecs */\n\tMARK(10000ULL\t\t, '+'), /* 10 usecs */\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nstatic const struct trace_mark {\n\tunsigned long long\tval; /* unit: nsec */\n\tchar\t\t\tsym;\n} mark[] = {\n\tMARK(1000000000ULL\t, '$'), /* 1 sec */\n\tMARK(100000000ULL\t, '@'), /* 100 msec */\n\tMARK(10000000ULL\t, '*'), /* 10 msec */\n\tMARK(1000000ULL\t\t, '#'), /* 1000 usecs */\n\tMARK(100000ULL\t\t, '!'), /* 100 usecs */\n\tMARK(10000ULL\t\t, '+'), /* 10 usecs */\n};\n\nchar trace_find_mark(unsigned long long d)\n{\n\tint i;\n\tint size = ARRAY_SIZE(mark);\n\n\tfor (i = 0; i < size; i++) {\n\t\tif (d > mark[i].val)\n\t\t\tbreak;\n\t}\n\n\treturn (i == size) ? ' ' : mark[i].sym;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ns2usecs",
          "args": [
            "iter->ts"
          ],
          "line": 568
        },
        "resolved": true,
        "details": {
          "function_name": "ns2usecs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "268-273",
          "snippet": "unsigned long long ns2usecs(u64 nsec)\n{\n\tnsec += 500;\n\tdo_div(nsec, 1000);\n\treturn nsec;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nunsigned long long ns2usecs(u64 nsec)\n{\n\tnsec += 500;\n\tdo_div(nsec, 1000);\n\treturn nsec;\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_div",
          "args": [
            "rel_ts",
            "USEC_PER_MSEC"
          ],
          "line": 563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_div",
          "args": [
            "abs_ts",
            "USEC_PER_MSEC"
          ],
          "line": 561
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nstatic int\nlat_print_timestamp(struct trace_iterator *iter, u64 next_ts)\n{\n\tstruct trace_array *tr = iter->tr;\n\tunsigned long verbose = tr->trace_flags & TRACE_ITER_VERBOSE;\n\tunsigned long in_ns = iter->iter_flags & TRACE_FILE_TIME_IN_NS;\n\tunsigned long long abs_ts = iter->ts - iter->array_buffer->time_start;\n\tunsigned long long rel_ts = next_ts - iter->ts;\n\tstruct trace_seq *s = &iter->seq;\n\n\tif (in_ns) {\n\t\tabs_ts = ns2usecs(abs_ts);\n\t\trel_ts = ns2usecs(rel_ts);\n\t}\n\n\tif (verbose && in_ns) {\n\t\tunsigned long abs_usec = do_div(abs_ts, USEC_PER_MSEC);\n\t\tunsigned long abs_msec = (unsigned long)abs_ts;\n\t\tunsigned long rel_usec = do_div(rel_ts, USEC_PER_MSEC);\n\t\tunsigned long rel_msec = (unsigned long)rel_ts;\n\n\t\ttrace_seq_printf(\n\t\t\ts, \"[%08llx] %ld.%03ldms (+%ld.%03ldms): \",\n\t\t\tns2usecs(iter->ts),\n\t\t\tabs_msec, abs_usec,\n\t\t\trel_msec, rel_usec);\n\n\t} else if (verbose && !in_ns) {\n\t\ttrace_seq_printf(\n\t\t\ts, \"[%016llx] %lld (+%lld): \",\n\t\t\titer->ts, abs_ts, rel_ts);\n\n\t} else if (!verbose && in_ns) {\n\t\ttrace_seq_printf(\n\t\t\ts, \" %4lldus%c: \",\n\t\t\tabs_ts,\n\t\t\ttrace_find_mark(rel_ts * NSEC_PER_USEC));\n\n\t} else { /* !verbose && !in_ns */\n\t\ttrace_seq_printf(s, \" %4lld: \", abs_ts);\n\t}\n\n\treturn !trace_seq_has_overflowed(s);\n}"
  },
  {
    "function_name": "trace_find_mark",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_output.c",
    "lines": "532-543",
    "snippet": "char trace_find_mark(unsigned long long d)\n{\n\tint i;\n\tint size = ARRAY_SIZE(mark);\n\n\tfor (i = 0; i < size; i++) {\n\t\tif (d > mark[i].val)\n\t\t\tbreak;\n\t}\n\n\treturn (i == size) ? ' ' : mark[i].sym;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct trace_mark {\n\tunsigned long long\tval; /* unit: nsec */\n\tchar\t\t\tsym;\n} mark[] = {\n\tMARK(1000000000ULL\t, '$'), /* 1 sec */\n\tMARK(100000000ULL\t, '@'), /* 100 msec */\n\tMARK(10000000ULL\t, '*'), /* 10 msec */\n\tMARK(1000000ULL\t\t, '#'), /* 1000 usecs */\n\tMARK(100000ULL\t\t, '!'), /* 100 usecs */\n\tMARK(10000ULL\t\t, '+'), /* 10 usecs */\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "mark"
          ],
          "line": 535
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nstatic const struct trace_mark {\n\tunsigned long long\tval; /* unit: nsec */\n\tchar\t\t\tsym;\n} mark[] = {\n\tMARK(1000000000ULL\t, '$'), /* 1 sec */\n\tMARK(100000000ULL\t, '@'), /* 100 msec */\n\tMARK(10000000ULL\t, '*'), /* 10 msec */\n\tMARK(1000000ULL\t\t, '#'), /* 1000 usecs */\n\tMARK(100000ULL\t\t, '!'), /* 100 usecs */\n\tMARK(10000ULL\t\t, '+'), /* 10 usecs */\n};\n\nchar trace_find_mark(unsigned long long d)\n{\n\tint i;\n\tint size = ARRAY_SIZE(mark);\n\n\tfor (i = 0; i < size; i++) {\n\t\tif (d > mark[i].val)\n\t\t\tbreak;\n\t}\n\n\treturn (i == size) ? ' ' : mark[i].sym;\n}"
  },
  {
    "function_name": "lat_print_generic",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_output.c",
    "lines": "503-514",
    "snippet": "static int\nlat_print_generic(struct trace_seq *s, struct trace_entry *entry, int cpu)\n{\n\tchar comm[TASK_COMM_LEN];\n\n\ttrace_find_cmdline(entry->pid, comm);\n\n\ttrace_seq_printf(s, \"%8.8s-%-7d %3d\",\n\t\t\t comm, entry->pid, cpu);\n\n\treturn trace_print_lat_fmt(s, entry);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_print_lat_fmt",
          "args": [
            "s",
            "entry"
          ],
          "line": 513
        },
        "resolved": true,
        "details": {
          "function_name": "trace_print_lat_fmt",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_output.c",
          "lines": "441-501",
          "snippet": "int trace_print_lat_fmt(struct trace_seq *s, struct trace_entry *entry)\n{\n\tchar hardsoft_irq;\n\tchar need_resched;\n\tchar irqs_off;\n\tint hardirq;\n\tint softirq;\n\tint bh_off;\n\tint nmi;\n\n\tnmi = entry->flags & TRACE_FLAG_NMI;\n\thardirq = entry->flags & TRACE_FLAG_HARDIRQ;\n\tsoftirq = entry->flags & TRACE_FLAG_SOFTIRQ;\n\tbh_off = entry->flags & TRACE_FLAG_BH_OFF;\n\n\tirqs_off =\n\t\t(entry->flags & TRACE_FLAG_IRQS_OFF && bh_off) ? 'D' :\n\t\t(entry->flags & TRACE_FLAG_IRQS_OFF) ? 'd' :\n\t\tbh_off ? 'b' :\n\t\t(entry->flags & TRACE_FLAG_IRQS_NOSUPPORT) ? 'X' :\n\t\t'.';\n\n\tswitch (entry->flags & (TRACE_FLAG_NEED_RESCHED |\n\t\t\t\tTRACE_FLAG_PREEMPT_RESCHED)) {\n\tcase TRACE_FLAG_NEED_RESCHED | TRACE_FLAG_PREEMPT_RESCHED:\n\t\tneed_resched = 'N';\n\t\tbreak;\n\tcase TRACE_FLAG_NEED_RESCHED:\n\t\tneed_resched = 'n';\n\t\tbreak;\n\tcase TRACE_FLAG_PREEMPT_RESCHED:\n\t\tneed_resched = 'p';\n\t\tbreak;\n\tdefault:\n\t\tneed_resched = '.';\n\t\tbreak;\n\t}\n\n\thardsoft_irq =\n\t\t(nmi && hardirq)     ? 'Z' :\n\t\tnmi                  ? 'z' :\n\t\t(hardirq && softirq) ? 'H' :\n\t\thardirq              ? 'h' :\n\t\tsoftirq              ? 's' :\n\t\t                       '.' ;\n\n\ttrace_seq_printf(s, \"%c%c%c\",\n\t\t\t irqs_off, need_resched, hardsoft_irq);\n\n\tif (entry->preempt_count & 0xf)\n\t\ttrace_seq_printf(s, \"%x\", entry->preempt_count & 0xf);\n\telse\n\t\ttrace_seq_putc(s, '.');\n\n\tif (entry->preempt_count & 0xf0)\n\t\ttrace_seq_printf(s, \"%x\", entry->preempt_count >> 4);\n\telse\n\t\ttrace_seq_putc(s, '.');\n\n\treturn !trace_seq_has_overflowed(s);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nint trace_print_lat_fmt(struct trace_seq *s, struct trace_entry *entry)\n{\n\tchar hardsoft_irq;\n\tchar need_resched;\n\tchar irqs_off;\n\tint hardirq;\n\tint softirq;\n\tint bh_off;\n\tint nmi;\n\n\tnmi = entry->flags & TRACE_FLAG_NMI;\n\thardirq = entry->flags & TRACE_FLAG_HARDIRQ;\n\tsoftirq = entry->flags & TRACE_FLAG_SOFTIRQ;\n\tbh_off = entry->flags & TRACE_FLAG_BH_OFF;\n\n\tirqs_off =\n\t\t(entry->flags & TRACE_FLAG_IRQS_OFF && bh_off) ? 'D' :\n\t\t(entry->flags & TRACE_FLAG_IRQS_OFF) ? 'd' :\n\t\tbh_off ? 'b' :\n\t\t(entry->flags & TRACE_FLAG_IRQS_NOSUPPORT) ? 'X' :\n\t\t'.';\n\n\tswitch (entry->flags & (TRACE_FLAG_NEED_RESCHED |\n\t\t\t\tTRACE_FLAG_PREEMPT_RESCHED)) {\n\tcase TRACE_FLAG_NEED_RESCHED | TRACE_FLAG_PREEMPT_RESCHED:\n\t\tneed_resched = 'N';\n\t\tbreak;\n\tcase TRACE_FLAG_NEED_RESCHED:\n\t\tneed_resched = 'n';\n\t\tbreak;\n\tcase TRACE_FLAG_PREEMPT_RESCHED:\n\t\tneed_resched = 'p';\n\t\tbreak;\n\tdefault:\n\t\tneed_resched = '.';\n\t\tbreak;\n\t}\n\n\thardsoft_irq =\n\t\t(nmi && hardirq)     ? 'Z' :\n\t\tnmi                  ? 'z' :\n\t\t(hardirq && softirq) ? 'H' :\n\t\thardirq              ? 'h' :\n\t\tsoftirq              ? 's' :\n\t\t                       '.' ;\n\n\ttrace_seq_printf(s, \"%c%c%c\",\n\t\t\t irqs_off, need_resched, hardsoft_irq);\n\n\tif (entry->preempt_count & 0xf)\n\t\ttrace_seq_printf(s, \"%x\", entry->preempt_count & 0xf);\n\telse\n\t\ttrace_seq_putc(s, '.');\n\n\tif (entry->preempt_count & 0xf0)\n\t\ttrace_seq_printf(s, \"%x\", entry->preempt_count >> 4);\n\telse\n\t\ttrace_seq_putc(s, '.');\n\n\treturn !trace_seq_has_overflowed(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_seq_printf",
          "args": [
            "s",
            "\"%8.8s-%-7d %3d\"",
            "comm",
            "entry->pid",
            "cpu"
          ],
          "line": 510
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "81-100",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_find_cmdline",
          "args": [
            "entry->pid",
            "comm"
          ],
          "line": 508
        },
        "resolved": true,
        "details": {
          "function_name": "trace_find_cmdline",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "2443-2452",
          "snippet": "void trace_find_cmdline(int pid, char comm[])\n{\n\tpreempt_disable();\n\tarch_spin_lock(&trace_cmdline_lock);\n\n\t__trace_find_cmdline(pid, comm);\n\n\tarch_spin_unlock(&trace_cmdline_lock);\n\tpreempt_enable();\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static arch_spinlock_t trace_cmdline_lock = __ARCH_SPIN_LOCK_UNLOCKED;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic arch_spinlock_t trace_cmdline_lock = __ARCH_SPIN_LOCK_UNLOCKED;\n\nvoid trace_find_cmdline(int pid, char comm[])\n{\n\tpreempt_disable();\n\tarch_spin_lock(&trace_cmdline_lock);\n\n\t__trace_find_cmdline(pid, comm);\n\n\tarch_spin_unlock(&trace_cmdline_lock);\n\tpreempt_enable();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nstatic int\nlat_print_generic(struct trace_seq *s, struct trace_entry *entry, int cpu)\n{\n\tchar comm[TASK_COMM_LEN];\n\n\ttrace_find_cmdline(entry->pid, comm);\n\n\ttrace_seq_printf(s, \"%8.8s-%-7d %3d\",\n\t\t\t comm, entry->pid, cpu);\n\n\treturn trace_print_lat_fmt(s, entry);\n}"
  },
  {
    "function_name": "trace_print_lat_fmt",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_output.c",
    "lines": "441-501",
    "snippet": "int trace_print_lat_fmt(struct trace_seq *s, struct trace_entry *entry)\n{\n\tchar hardsoft_irq;\n\tchar need_resched;\n\tchar irqs_off;\n\tint hardirq;\n\tint softirq;\n\tint bh_off;\n\tint nmi;\n\n\tnmi = entry->flags & TRACE_FLAG_NMI;\n\thardirq = entry->flags & TRACE_FLAG_HARDIRQ;\n\tsoftirq = entry->flags & TRACE_FLAG_SOFTIRQ;\n\tbh_off = entry->flags & TRACE_FLAG_BH_OFF;\n\n\tirqs_off =\n\t\t(entry->flags & TRACE_FLAG_IRQS_OFF && bh_off) ? 'D' :\n\t\t(entry->flags & TRACE_FLAG_IRQS_OFF) ? 'd' :\n\t\tbh_off ? 'b' :\n\t\t(entry->flags & TRACE_FLAG_IRQS_NOSUPPORT) ? 'X' :\n\t\t'.';\n\n\tswitch (entry->flags & (TRACE_FLAG_NEED_RESCHED |\n\t\t\t\tTRACE_FLAG_PREEMPT_RESCHED)) {\n\tcase TRACE_FLAG_NEED_RESCHED | TRACE_FLAG_PREEMPT_RESCHED:\n\t\tneed_resched = 'N';\n\t\tbreak;\n\tcase TRACE_FLAG_NEED_RESCHED:\n\t\tneed_resched = 'n';\n\t\tbreak;\n\tcase TRACE_FLAG_PREEMPT_RESCHED:\n\t\tneed_resched = 'p';\n\t\tbreak;\n\tdefault:\n\t\tneed_resched = '.';\n\t\tbreak;\n\t}\n\n\thardsoft_irq =\n\t\t(nmi && hardirq)     ? 'Z' :\n\t\tnmi                  ? 'z' :\n\t\t(hardirq && softirq) ? 'H' :\n\t\thardirq              ? 'h' :\n\t\tsoftirq              ? 's' :\n\t\t                       '.' ;\n\n\ttrace_seq_printf(s, \"%c%c%c\",\n\t\t\t irqs_off, need_resched, hardsoft_irq);\n\n\tif (entry->preempt_count & 0xf)\n\t\ttrace_seq_printf(s, \"%x\", entry->preempt_count & 0xf);\n\telse\n\t\ttrace_seq_putc(s, '.');\n\n\tif (entry->preempt_count & 0xf0)\n\t\ttrace_seq_printf(s, \"%x\", entry->preempt_count >> 4);\n\telse\n\t\ttrace_seq_putc(s, '.');\n\n\treturn !trace_seq_has_overflowed(s);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_seq_has_overflowed",
          "args": [
            "s"
          ],
          "line": 500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_seq_putc",
          "args": [
            "s",
            "'.'"
          ],
          "line": 498
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_putc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "233-246",
          "snippet": "void trace_seq_putc(struct trace_seq *s, unsigned char c)\n{\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (TRACE_SEQ_BUF_LEFT(s) < 1) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putc(&s->seq, c);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_putc(struct trace_seq *s, unsigned char c)\n{\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (TRACE_SEQ_BUF_LEFT(s) < 1) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putc(&s->seq, c);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_seq_printf",
          "args": [
            "s",
            "\"%x\"",
            "entry->preempt_count >> 4"
          ],
          "line": 496
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "81-100",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nint trace_print_lat_fmt(struct trace_seq *s, struct trace_entry *entry)\n{\n\tchar hardsoft_irq;\n\tchar need_resched;\n\tchar irqs_off;\n\tint hardirq;\n\tint softirq;\n\tint bh_off;\n\tint nmi;\n\n\tnmi = entry->flags & TRACE_FLAG_NMI;\n\thardirq = entry->flags & TRACE_FLAG_HARDIRQ;\n\tsoftirq = entry->flags & TRACE_FLAG_SOFTIRQ;\n\tbh_off = entry->flags & TRACE_FLAG_BH_OFF;\n\n\tirqs_off =\n\t\t(entry->flags & TRACE_FLAG_IRQS_OFF && bh_off) ? 'D' :\n\t\t(entry->flags & TRACE_FLAG_IRQS_OFF) ? 'd' :\n\t\tbh_off ? 'b' :\n\t\t(entry->flags & TRACE_FLAG_IRQS_NOSUPPORT) ? 'X' :\n\t\t'.';\n\n\tswitch (entry->flags & (TRACE_FLAG_NEED_RESCHED |\n\t\t\t\tTRACE_FLAG_PREEMPT_RESCHED)) {\n\tcase TRACE_FLAG_NEED_RESCHED | TRACE_FLAG_PREEMPT_RESCHED:\n\t\tneed_resched = 'N';\n\t\tbreak;\n\tcase TRACE_FLAG_NEED_RESCHED:\n\t\tneed_resched = 'n';\n\t\tbreak;\n\tcase TRACE_FLAG_PREEMPT_RESCHED:\n\t\tneed_resched = 'p';\n\t\tbreak;\n\tdefault:\n\t\tneed_resched = '.';\n\t\tbreak;\n\t}\n\n\thardsoft_irq =\n\t\t(nmi && hardirq)     ? 'Z' :\n\t\tnmi                  ? 'z' :\n\t\t(hardirq && softirq) ? 'H' :\n\t\thardirq              ? 'h' :\n\t\tsoftirq              ? 's' :\n\t\t                       '.' ;\n\n\ttrace_seq_printf(s, \"%c%c%c\",\n\t\t\t irqs_off, need_resched, hardsoft_irq);\n\n\tif (entry->preempt_count & 0xf)\n\t\ttrace_seq_printf(s, \"%x\", entry->preempt_count & 0xf);\n\telse\n\t\ttrace_seq_putc(s, '.');\n\n\tif (entry->preempt_count & 0xf0)\n\t\ttrace_seq_printf(s, \"%x\", entry->preempt_count >> 4);\n\telse\n\t\ttrace_seq_putc(s, '.');\n\n\treturn !trace_seq_has_overflowed(s);\n}"
  },
  {
    "function_name": "seq_print_ip_sym",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_output.c",
    "lines": "416-431",
    "snippet": "int\nseq_print_ip_sym(struct trace_seq *s, unsigned long ip, unsigned long sym_flags)\n{\n\tif (!ip) {\n\t\ttrace_seq_putc(s, '0');\n\t\tgoto out;\n\t}\n\n\ttrace_seq_print_sym(s, ip, sym_flags & TRACE_ITER_SYM_OFFSET);\n\n\tif (sym_flags & TRACE_ITER_SYM_ADDR)\n\t\ttrace_seq_printf(s, \" <\" IP_FMT \">\", ip);\n\n out:\n\treturn !trace_seq_has_overflowed(s);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_seq_has_overflowed",
          "args": [
            "s"
          ],
          "line": 430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_seq_printf",
          "args": [
            "s",
            "\" <\" IP_FMT \">\"",
            "ip"
          ],
          "line": 427
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "81-100",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_seq_print_sym",
          "args": [
            "s",
            "ip",
            "sym_flags & TRACE_ITER_SYM_OFFSET"
          ],
          "line": 424
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_print_sym",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_output.c",
          "lines": "357-376",
          "snippet": "void\ntrace_seq_print_sym(struct trace_seq *s, unsigned long address, bool offset)\n{\n#ifdef CONFIG_KALLSYMS\n\tchar str[KSYM_SYMBOL_LEN];\n\tconst char *name;\n\n\tif (offset)\n\t\tsprint_symbol(str, address);\n\telse\n\t\tkallsyms_lookup(address, NULL, NULL, NULL, str);\n\tname = kretprobed(str, address);\n\n\tif (name && strlen(name)) {\n\t\ttrace_seq_puts(s, name);\n\t\treturn;\n\t}\n#endif\n\ttrace_seq_printf(s, \"0x%08lx\", address);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nvoid\ntrace_seq_print_sym(struct trace_seq *s, unsigned long address, bool offset)\n{\n#ifdef CONFIG_KALLSYMS\n\tchar str[KSYM_SYMBOL_LEN];\n\tconst char *name;\n\n\tif (offset)\n\t\tsprint_symbol(str, address);\n\telse\n\t\tkallsyms_lookup(address, NULL, NULL, NULL, str);\n\tname = kretprobed(str, address);\n\n\tif (name && strlen(name)) {\n\t\ttrace_seq_puts(s, name);\n\t\treturn;\n\t}\n#endif\n\ttrace_seq_printf(s, \"0x%08lx\", address);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_seq_putc",
          "args": [
            "s",
            "'0'"
          ],
          "line": 420
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_putc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "233-246",
          "snippet": "void trace_seq_putc(struct trace_seq *s, unsigned char c)\n{\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (TRACE_SEQ_BUF_LEFT(s) < 1) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putc(&s->seq, c);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_putc(struct trace_seq *s, unsigned char c)\n{\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (TRACE_SEQ_BUF_LEFT(s) < 1) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putc(&s->seq, c);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nint\nseq_print_ip_sym(struct trace_seq *s, unsigned long ip, unsigned long sym_flags)\n{\n\tif (!ip) {\n\t\ttrace_seq_putc(s, '0');\n\t\tgoto out;\n\t}\n\n\ttrace_seq_print_sym(s, ip, sym_flags & TRACE_ITER_SYM_OFFSET);\n\n\tif (sym_flags & TRACE_ITER_SYM_ADDR)\n\t\ttrace_seq_printf(s, \" <\" IP_FMT \">\", ip);\n\n out:\n\treturn !trace_seq_has_overflowed(s);\n}"
  },
  {
    "function_name": "seq_print_user_ip",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_output.c",
    "lines": "384-414",
    "snippet": "static int seq_print_user_ip(struct trace_seq *s, struct mm_struct *mm,\n\t\t\t     unsigned long ip, unsigned long sym_flags)\n{\n\tstruct file *file = NULL;\n\tunsigned long vmstart = 0;\n\tint ret = 1;\n\n\tif (s->full)\n\t\treturn 0;\n\n\tif (mm) {\n\t\tconst struct vm_area_struct *vma;\n\n\t\tmmap_read_lock(mm);\n\t\tvma = find_vma(mm, ip);\n\t\tif (vma) {\n\t\t\tfile = vma->vm_file;\n\t\t\tvmstart = vma->vm_start;\n\t\t}\n\t\tif (file) {\n\t\t\tret = trace_seq_path(s, &file->f_path);\n\t\t\tif (ret)\n\t\t\t\ttrace_seq_printf(s, \"[+0x%lx]\",\n\t\t\t\t\t\t ip - vmstart);\n\t\t}\n\t\tmmap_read_unlock(mm);\n\t}\n\tif (ret && ((sym_flags & TRACE_ITER_SYM_ADDR) || !file))\n\t\ttrace_seq_printf(s, \" <\" IP_FMT \">\", ip);\n\treturn !trace_seq_has_overflowed(s);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_seq_has_overflowed",
          "args": [
            "s"
          ],
          "line": 413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_seq_printf",
          "args": [
            "s",
            "\" <\" IP_FMT \">\"",
            "ip"
          ],
          "line": 412
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "81-100",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mmap_read_unlock",
          "args": [
            "mm"
          ],
          "line": 409
        },
        "resolved": true,
        "details": {
          "function_name": "do_mmap_read_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/task_iter.c",
          "lines": "634-643",
          "snippet": "static void do_mmap_read_unlock(struct irq_work *entry)\n{\n\tstruct mmap_unlock_irq_work *work;\n\n\tif (WARN_ON_ONCE(IS_ENABLED(CONFIG_PREEMPT_RT)))\n\t\treturn;\n\n\twork = container_of(entry, struct mmap_unlock_irq_work, irq_work);\n\tmmap_read_unlock_non_owner(work->mm);\n}",
          "includes": [
            "#include \"mmap_unlock_work.h\"",
            "#include <linux/btf_ids.h>",
            "#include <linux/filter.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/fs.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/namei.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mmap_unlock_work.h\"\n#include <linux/btf_ids.h>\n#include <linux/filter.h>\n#include <linux/fdtable.h>\n#include <linux/fs.h>\n#include <linux/pid_namespace.h>\n#include <linux/namei.h>\n#include <linux/init.h>\n\nstatic void do_mmap_read_unlock(struct irq_work *entry)\n{\n\tstruct mmap_unlock_irq_work *work;\n\n\tif (WARN_ON_ONCE(IS_ENABLED(CONFIG_PREEMPT_RT)))\n\t\treturn;\n\n\twork = container_of(entry, struct mmap_unlock_irq_work, irq_work);\n\tmmap_read_unlock_non_owner(work->mm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_seq_path",
          "args": [
            "s",
            "&file->f_path"
          ],
          "line": 404
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_path",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "324-347",
          "snippet": "int trace_seq_path(struct trace_seq *s, const struct path *path)\n{\n\tunsigned int save_len = s->seq.len;\n\n\tif (s->full)\n\t\treturn 0;\n\n\t__trace_seq_init(s);\n\n\tif (TRACE_SEQ_BUF_LEFT(s) < 1) {\n\t\ts->full = 1;\n\t\treturn 0;\n\t}\n\n\tseq_buf_path(&s->seq, path, \"\\n\");\n\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nint trace_seq_path(struct trace_seq *s, const struct path *path)\n{\n\tunsigned int save_len = s->seq.len;\n\n\tif (s->full)\n\t\treturn 0;\n\n\t__trace_seq_init(s);\n\n\tif (TRACE_SEQ_BUF_LEFT(s) < 1) {\n\t\ts->full = 1;\n\t\treturn 0;\n\t}\n\n\tseq_buf_path(&s->seq, path, \"\\n\");\n\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_vma",
          "args": [
            "mm",
            "ip"
          ],
          "line": 398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mmap_read_lock",
          "args": [
            "mm"
          ],
          "line": 397
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nstatic int seq_print_user_ip(struct trace_seq *s, struct mm_struct *mm,\n\t\t\t     unsigned long ip, unsigned long sym_flags)\n{\n\tstruct file *file = NULL;\n\tunsigned long vmstart = 0;\n\tint ret = 1;\n\n\tif (s->full)\n\t\treturn 0;\n\n\tif (mm) {\n\t\tconst struct vm_area_struct *vma;\n\n\t\tmmap_read_lock(mm);\n\t\tvma = find_vma(mm, ip);\n\t\tif (vma) {\n\t\t\tfile = vma->vm_file;\n\t\t\tvmstart = vma->vm_start;\n\t\t}\n\t\tif (file) {\n\t\t\tret = trace_seq_path(s, &file->f_path);\n\t\t\tif (ret)\n\t\t\t\ttrace_seq_printf(s, \"[+0x%lx]\",\n\t\t\t\t\t\t ip - vmstart);\n\t\t}\n\t\tmmap_read_unlock(mm);\n\t}\n\tif (ret && ((sym_flags & TRACE_ITER_SYM_ADDR) || !file))\n\t\ttrace_seq_printf(s, \" <\" IP_FMT \">\", ip);\n\treturn !trace_seq_has_overflowed(s);\n}"
  },
  {
    "function_name": "trace_seq_print_sym",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_output.c",
    "lines": "357-376",
    "snippet": "void\ntrace_seq_print_sym(struct trace_seq *s, unsigned long address, bool offset)\n{\n#ifdef CONFIG_KALLSYMS\n\tchar str[KSYM_SYMBOL_LEN];\n\tconst char *name;\n\n\tif (offset)\n\t\tsprint_symbol(str, address);\n\telse\n\t\tkallsyms_lookup(address, NULL, NULL, NULL, str);\n\tname = kretprobed(str, address);\n\n\tif (name && strlen(name)) {\n\t\ttrace_seq_puts(s, name);\n\t\treturn;\n\t}\n#endif\n\ttrace_seq_printf(s, \"0x%08lx\", address);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_seq_printf",
          "args": [
            "s",
            "\"0x%08lx\"",
            "address"
          ],
          "line": 375
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "81-100",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_seq_puts",
          "args": [
            "s",
            "name"
          ],
          "line": 371
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_puts",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "205-220",
          "snippet": "void trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "name"
          ],
          "line": 370
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_eprobe.c",
          "lines": "384-401",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/ftrace.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kretprobed",
          "args": [
            "str",
            "address"
          ],
          "line": 368
        },
        "resolved": true,
        "details": {
          "function_name": "kretprobed",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_output.c",
          "lines": "350-355",
          "snippet": "static inline const char *kretprobed(const char *name, unsigned long addr)\n{\n\tif (is_kretprobe_trampoline(addr))\n\t\treturn \"[unknown/kretprobe'd]\";\n\treturn name;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nstatic inline const char *kretprobed(const char *name, unsigned long addr)\n{\n\tif (is_kretprobe_trampoline(addr))\n\t\treturn \"[unknown/kretprobe'd]\";\n\treturn name;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kallsyms_lookup",
          "args": [
            "address",
            "NULL",
            "NULL",
            "NULL",
            "str"
          ],
          "line": 367
        },
        "resolved": true,
        "details": {
          "function_name": "kallsyms_lookup",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kallsyms.c",
          "lines": "377-384",
          "snippet": "const char *kallsyms_lookup(unsigned long addr,\n\t\t\t    unsigned long *symbolsize,\n\t\t\t    unsigned long *offset,\n\t\t\t    char **modname, char *namebuf)\n{\n\treturn kallsyms_lookup_buildid(addr, symbolsize, offset, modname,\n\t\t\t\t       NULL, namebuf);\n}",
          "includes": [
            "#include <linux/kernel.h>",
            "#include <linux/module.h>",
            "#include <linux/compiler.h>",
            "#include <linux/build_bug.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/filter.h>",
            "#include <linux/slab.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>\t/* for cond_resched */",
            "#include <linux/proc_fs.h>",
            "#include <linux/err.h>",
            "#include <linux/kdb.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/build_bug.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\t/* for cond_resched */\n#include <linux/proc_fs.h>\n#include <linux/err.h>\n#include <linux/kdb.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/kallsyms.h>\n\nconst char *kallsyms_lookup(unsigned long addr,\n\t\t\t    unsigned long *symbolsize,\n\t\t\t    unsigned long *offset,\n\t\t\t    char **modname, char *namebuf)\n{\n\treturn kallsyms_lookup_buildid(addr, symbolsize, offset, modname,\n\t\t\t\t       NULL, namebuf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sprint_symbol",
          "args": [
            "str",
            "address"
          ],
          "line": 365
        },
        "resolved": true,
        "details": {
          "function_name": "sprint_symbol_no_offset",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kallsyms.c",
          "lines": "526-529",
          "snippet": "int sprint_symbol_no_offset(char *buffer, unsigned long address)\n{\n\treturn __sprint_symbol(buffer, address, 0, 0, 0);\n}",
          "includes": [
            "#include <linux/kernel.h>",
            "#include <linux/module.h>",
            "#include <linux/compiler.h>",
            "#include <linux/build_bug.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/filter.h>",
            "#include <linux/slab.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>\t/* for cond_resched */",
            "#include <linux/proc_fs.h>",
            "#include <linux/err.h>",
            "#include <linux/kdb.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/build_bug.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\t/* for cond_resched */\n#include <linux/proc_fs.h>\n#include <linux/err.h>\n#include <linux/kdb.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/kallsyms.h>\n\nint sprint_symbol_no_offset(char *buffer, unsigned long address)\n{\n\treturn __sprint_symbol(buffer, address, 0, 0, 0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nvoid\ntrace_seq_print_sym(struct trace_seq *s, unsigned long address, bool offset)\n{\n#ifdef CONFIG_KALLSYMS\n\tchar str[KSYM_SYMBOL_LEN];\n\tconst char *name;\n\n\tif (offset)\n\t\tsprint_symbol(str, address);\n\telse\n\t\tkallsyms_lookup(address, NULL, NULL, NULL, str);\n\tname = kretprobed(str, address);\n\n\tif (name && strlen(name)) {\n\t\ttrace_seq_puts(s, name);\n\t\treturn;\n\t}\n#endif\n\ttrace_seq_printf(s, \"0x%08lx\", address);\n}"
  },
  {
    "function_name": "kretprobed",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_output.c",
    "lines": "350-355",
    "snippet": "static inline const char *kretprobed(const char *name, unsigned long addr)\n{\n\tif (is_kretprobe_trampoline(addr))\n\t\treturn \"[unknown/kretprobe'd]\";\n\treturn name;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "is_kretprobe_trampoline",
          "args": [
            "addr"
          ],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nstatic inline const char *kretprobed(const char *name, unsigned long addr)\n{\n\tif (is_kretprobe_trampoline(addr))\n\t\treturn \"[unknown/kretprobe'd]\";\n\treturn name;\n}"
  },
  {
    "function_name": "trace_output_call",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_output.c",
    "lines": "337-347",
    "snippet": "int trace_output_call(struct trace_iterator *iter, char *name, char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\n\tva_start(ap, fmt);\n\tret = trace_output_raw(iter, name, fmt, ap);\n\tva_end(ap);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "va_end",
          "args": [
            "ap"
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_output_raw",
          "args": [
            "iter",
            "name",
            "fmt",
            "ap"
          ],
          "line": 343
        },
        "resolved": true,
        "details": {
          "function_name": "trace_output_raw",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_output.c",
          "lines": "326-335",
          "snippet": "static int trace_output_raw(struct trace_iterator *iter, char *name,\n\t\t\t    char *fmt, va_list ap)\n{\n\tstruct trace_seq *s = &iter->seq;\n\n\ttrace_seq_printf(s, \"%s: \", name);\n\ttrace_seq_vprintf(s, trace_event_format(iter, fmt), ap);\n\n\treturn trace_handle_return(s);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nstatic int trace_output_raw(struct trace_iterator *iter, char *name,\n\t\t\t    char *fmt, va_list ap)\n{\n\tstruct trace_seq *s = &iter->seq;\n\n\ttrace_seq_printf(s, \"%s: \", name);\n\ttrace_seq_vprintf(s, trace_event_format(iter, fmt), ap);\n\n\treturn trace_handle_return(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "va_start",
          "args": [
            "ap",
            "fmt"
          ],
          "line": 342
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nint trace_output_call(struct trace_iterator *iter, char *name, char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\n\tva_start(ap, fmt);\n\tret = trace_output_raw(iter, name, fmt, ap);\n\tva_end(ap);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "trace_output_raw",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_output.c",
    "lines": "326-335",
    "snippet": "static int trace_output_raw(struct trace_iterator *iter, char *name,\n\t\t\t    char *fmt, va_list ap)\n{\n\tstruct trace_seq *s = &iter->seq;\n\n\ttrace_seq_printf(s, \"%s: \", name);\n\ttrace_seq_vprintf(s, trace_event_format(iter, fmt), ap);\n\n\treturn trace_handle_return(s);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_handle_return",
          "args": [
            "s"
          ],
          "line": 334
        },
        "resolved": true,
        "details": {
          "function_name": "trace_handle_return",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "2577-2581",
          "snippet": "enum print_line_t trace_handle_return(struct trace_seq *s)\n{\n\treturn trace_seq_has_overflowed(s) ?\n\t\tTRACE_TYPE_PARTIAL_LINE : TRACE_TYPE_HANDLED;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nenum print_line_t trace_handle_return(struct trace_seq *s)\n{\n\treturn trace_seq_has_overflowed(s) ?\n\t\tTRACE_TYPE_PARTIAL_LINE : TRACE_TYPE_HANDLED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_seq_vprintf",
          "args": [
            "s",
            "trace_event_format(iter, fmt)",
            "ap"
          ],
          "line": 332
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_vprintf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "141-157",
          "snippet": "void trace_seq_vprintf(struct trace_seq *s, const char *fmt, va_list args)\n{\n\tunsigned int save_len = s->seq.len;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tseq_buf_vprintf(&s->seq, fmt, args);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_vprintf(struct trace_seq *s, const char *fmt, va_list args)\n{\n\tunsigned int save_len = s->seq.len;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tseq_buf_vprintf(&s->seq, fmt, args);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_event_format",
          "args": [
            "iter",
            "fmt"
          ],
          "line": 332
        },
        "resolved": true,
        "details": {
          "function_name": "trace_event_format",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "3892-3929",
          "snippet": "const char *trace_event_format(struct trace_iterator *iter, const char *fmt)\n{\n\tconst char *p, *new_fmt;\n\tchar *q;\n\n\tif (WARN_ON_ONCE(!fmt))\n\t\treturn fmt;\n\n\tif (!iter->tr || iter->tr->trace_flags & TRACE_ITER_HASH_PTR)\n\t\treturn fmt;\n\n\tp = fmt;\n\tnew_fmt = q = iter->fmt;\n\twhile (*p) {\n\t\tif (unlikely(q - new_fmt + 3 > iter->fmt_size)) {\n\t\t\tif (!trace_iter_expand_format(iter))\n\t\t\t\treturn fmt;\n\n\t\t\tq += iter->fmt - new_fmt;\n\t\t\tnew_fmt = iter->fmt;\n\t\t}\n\n\t\t*q++ = *p++;\n\n\t\t/* Replace %p with %px */\n\t\tif (p[-1] == '%') {\n\t\t\tif (p[0] == '%') {\n\t\t\t\t*q++ = *p++;\n\t\t\t} else if (p[0] == 'p' && !isalnum(p[1])) {\n\t\t\t\t*q++ = *p++;\n\t\t\t\t*q++ = 'x';\n\t\t\t}\n\t\t}\n\t}\n\t*q = '\\0';\n\n\treturn new_fmt;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nconst char *trace_event_format(struct trace_iterator *iter, const char *fmt)\n{\n\tconst char *p, *new_fmt;\n\tchar *q;\n\n\tif (WARN_ON_ONCE(!fmt))\n\t\treturn fmt;\n\n\tif (!iter->tr || iter->tr->trace_flags & TRACE_ITER_HASH_PTR)\n\t\treturn fmt;\n\n\tp = fmt;\n\tnew_fmt = q = iter->fmt;\n\twhile (*p) {\n\t\tif (unlikely(q - new_fmt + 3 > iter->fmt_size)) {\n\t\t\tif (!trace_iter_expand_format(iter))\n\t\t\t\treturn fmt;\n\n\t\t\tq += iter->fmt - new_fmt;\n\t\t\tnew_fmt = iter->fmt;\n\t\t}\n\n\t\t*q++ = *p++;\n\n\t\t/* Replace %p with %px */\n\t\tif (p[-1] == '%') {\n\t\t\tif (p[0] == '%') {\n\t\t\t\t*q++ = *p++;\n\t\t\t} else if (p[0] == 'p' && !isalnum(p[1])) {\n\t\t\t\t*q++ = *p++;\n\t\t\t\t*q++ = 'x';\n\t\t\t}\n\t\t}\n\t}\n\t*q = '\\0';\n\n\treturn new_fmt;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_seq_printf",
          "args": [
            "s",
            "\"%s: \"",
            "name"
          ],
          "line": 331
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "81-100",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nstatic int trace_output_raw(struct trace_iterator *iter, char *name,\n\t\t\t    char *fmt, va_list ap)\n{\n\tstruct trace_seq *s = &iter->seq;\n\n\ttrace_seq_printf(s, \"%s: \", name);\n\ttrace_seq_vprintf(s, trace_event_format(iter, fmt), ap);\n\n\treturn trace_handle_return(s);\n}"
  },
  {
    "function_name": "trace_event_printf",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_output.c",
    "lines": "316-323",
    "snippet": "void trace_event_printf(struct trace_iterator *iter, const char *fmt, ...)\n{\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\ttrace_check_vprintf(iter, trace_event_format(iter, fmt), ap);\n\tva_end(ap);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "va_end",
          "args": [
            "ap"
          ],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_check_vprintf",
          "args": [
            "iter",
            "trace_event_format(iter, fmt)",
            "ap"
          ],
          "line": 321
        },
        "resolved": true,
        "details": {
          "function_name": "trace_check_vprintf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "3759-3890",
          "snippet": "void trace_check_vprintf(struct trace_iterator *iter, const char *fmt,\n\t\t\t va_list ap)\n{\n\tconst char *p = fmt;\n\tconst char *str;\n\tint i, j;\n\n\tif (WARN_ON_ONCE(!fmt))\n\t\treturn;\n\n\tif (static_branch_unlikely(&trace_no_verify))\n\t\tgoto print;\n\n\t/* Don't bother checking when doing a ftrace_dump() */\n\tif (iter->fmt == static_fmt_buf)\n\t\tgoto print;\n\n\twhile (*p) {\n\t\tbool star = false;\n\t\tint len = 0;\n\n\t\tj = 0;\n\n\t\t/* We only care about %s and variants */\n\t\tfor (i = 0; p[i]; i++) {\n\t\t\tif (i + 1 >= iter->fmt_size) {\n\t\t\t\t/*\n\t\t\t\t * If we can't expand the copy buffer,\n\t\t\t\t * just print it.\n\t\t\t\t */\n\t\t\t\tif (!trace_iter_expand_format(iter))\n\t\t\t\t\tgoto print;\n\t\t\t}\n\n\t\t\tif (p[i] == '\\\\' && p[i+1]) {\n\t\t\t\ti++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (p[i] == '%') {\n\t\t\t\t/* Need to test cases like %08.*s */\n\t\t\t\tfor (j = 1; p[i+j]; j++) {\n\t\t\t\t\tif (isdigit(p[i+j]) ||\n\t\t\t\t\t    p[i+j] == '.')\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (p[i+j] == '*') {\n\t\t\t\t\t\tstar = true;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (p[i+j] == 's')\n\t\t\t\t\tbreak;\n\t\t\t\tstar = false;\n\t\t\t}\n\t\t\tj = 0;\n\t\t}\n\t\t/* If no %s found then just print normally */\n\t\tif (!p[i])\n\t\t\tbreak;\n\n\t\t/* Copy up to the %s, and print that */\n\t\tstrncpy(iter->fmt, p, i);\n\t\titer->fmt[i] = '\\0';\n\t\ttrace_seq_vprintf(&iter->seq, iter->fmt, ap);\n\n\t\t/*\n\t\t * If iter->seq is full, the above call no longer guarantees\n\t\t * that ap is in sync with fmt processing, and further calls\n\t\t * to va_arg() can return wrong positional arguments.\n\t\t *\n\t\t * Ensure that ap is no longer used in this case.\n\t\t */\n\t\tif (iter->seq.full) {\n\t\t\tp = \"\";\n\t\t\tbreak;\n\t\t}\n\n\t\tif (star)\n\t\t\tlen = va_arg(ap, int);\n\n\t\t/* The ap now points to the string data of the %s */\n\t\tstr = va_arg(ap, const char *);\n\n\t\t/*\n\t\t * If you hit this warning, it is likely that the\n\t\t * trace event in question used %s on a string that\n\t\t * was saved at the time of the event, but may not be\n\t\t * around when the trace is read. Use __string(),\n\t\t * __assign_str() and __get_str() helpers in the TRACE_EVENT()\n\t\t * instead. See samples/trace_events/trace-events-sample.h\n\t\t * for reference.\n\t\t */\n\t\tif (WARN_ONCE(!trace_safe_str(iter, str),\n\t\t\t      \"fmt: '%s' current_buffer: '%s'\",\n\t\t\t      fmt, show_buffer(&iter->seq))) {\n\t\t\tint ret;\n\n\t\t\t/* Try to safely read the string */\n\t\t\tif (star) {\n\t\t\t\tif (len + 1 > iter->fmt_size)\n\t\t\t\t\tlen = iter->fmt_size - 1;\n\t\t\t\tif (len < 0)\n\t\t\t\t\tlen = 0;\n\t\t\t\tret = copy_from_kernel_nofault(iter->fmt, str, len);\n\t\t\t\titer->fmt[len] = 0;\n\t\t\t\tstar = false;\n\t\t\t} else {\n\t\t\t\tret = strncpy_from_kernel_nofault(iter->fmt, str,\n\t\t\t\t\t\t\t\t  iter->fmt_size);\n\t\t\t}\n\t\t\tif (ret < 0)\n\t\t\t\ttrace_seq_printf(&iter->seq, \"(0x%px)\", str);\n\t\t\telse\n\t\t\t\ttrace_seq_printf(&iter->seq, \"(0x%px:%s)\",\n\t\t\t\t\t\t str, iter->fmt);\n\t\t\tstr = \"[UNSAFE-MEMORY]\";\n\t\t\tstrcpy(iter->fmt, \"%s\");\n\t\t} else {\n\t\t\tstrncpy(iter->fmt, p + i, j + 1);\n\t\t\titer->fmt[j+1] = '\\0';\n\t\t}\n\t\tif (star)\n\t\t\ttrace_seq_printf(&iter->seq, iter->fmt, len, str);\n\t\telse\n\t\t\ttrace_seq_printf(&iter->seq, iter->fmt, str);\n\n\t\tp += i + j + 1;\n\t}\n print:\n\tif (*p)\n\t\ttrace_seq_vprintf(&iter->seq, p, ap);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct",
            "static void add_tracer_options(struct trace_array *tr, struct tracer *t);",
            "static char static_fmt_buf[STATIC_FMT_BUF_SIZE];",
            "static DEFINE_STATIC_KEY_FALSE(trace_no_verify);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\nstatic void add_tracer_options(struct trace_array *tr, struct tracer *t);\nstatic char static_fmt_buf[STATIC_FMT_BUF_SIZE];\nstatic DEFINE_STATIC_KEY_FALSE(trace_no_verify);\n\nvoid trace_check_vprintf(struct trace_iterator *iter, const char *fmt,\n\t\t\t va_list ap)\n{\n\tconst char *p = fmt;\n\tconst char *str;\n\tint i, j;\n\n\tif (WARN_ON_ONCE(!fmt))\n\t\treturn;\n\n\tif (static_branch_unlikely(&trace_no_verify))\n\t\tgoto print;\n\n\t/* Don't bother checking when doing a ftrace_dump() */\n\tif (iter->fmt == static_fmt_buf)\n\t\tgoto print;\n\n\twhile (*p) {\n\t\tbool star = false;\n\t\tint len = 0;\n\n\t\tj = 0;\n\n\t\t/* We only care about %s and variants */\n\t\tfor (i = 0; p[i]; i++) {\n\t\t\tif (i + 1 >= iter->fmt_size) {\n\t\t\t\t/*\n\t\t\t\t * If we can't expand the copy buffer,\n\t\t\t\t * just print it.\n\t\t\t\t */\n\t\t\t\tif (!trace_iter_expand_format(iter))\n\t\t\t\t\tgoto print;\n\t\t\t}\n\n\t\t\tif (p[i] == '\\\\' && p[i+1]) {\n\t\t\t\ti++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (p[i] == '%') {\n\t\t\t\t/* Need to test cases like %08.*s */\n\t\t\t\tfor (j = 1; p[i+j]; j++) {\n\t\t\t\t\tif (isdigit(p[i+j]) ||\n\t\t\t\t\t    p[i+j] == '.')\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (p[i+j] == '*') {\n\t\t\t\t\t\tstar = true;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (p[i+j] == 's')\n\t\t\t\t\tbreak;\n\t\t\t\tstar = false;\n\t\t\t}\n\t\t\tj = 0;\n\t\t}\n\t\t/* If no %s found then just print normally */\n\t\tif (!p[i])\n\t\t\tbreak;\n\n\t\t/* Copy up to the %s, and print that */\n\t\tstrncpy(iter->fmt, p, i);\n\t\titer->fmt[i] = '\\0';\n\t\ttrace_seq_vprintf(&iter->seq, iter->fmt, ap);\n\n\t\t/*\n\t\t * If iter->seq is full, the above call no longer guarantees\n\t\t * that ap is in sync with fmt processing, and further calls\n\t\t * to va_arg() can return wrong positional arguments.\n\t\t *\n\t\t * Ensure that ap is no longer used in this case.\n\t\t */\n\t\tif (iter->seq.full) {\n\t\t\tp = \"\";\n\t\t\tbreak;\n\t\t}\n\n\t\tif (star)\n\t\t\tlen = va_arg(ap, int);\n\n\t\t/* The ap now points to the string data of the %s */\n\t\tstr = va_arg(ap, const char *);\n\n\t\t/*\n\t\t * If you hit this warning, it is likely that the\n\t\t * trace event in question used %s on a string that\n\t\t * was saved at the time of the event, but may not be\n\t\t * around when the trace is read. Use __string(),\n\t\t * __assign_str() and __get_str() helpers in the TRACE_EVENT()\n\t\t * instead. See samples/trace_events/trace-events-sample.h\n\t\t * for reference.\n\t\t */\n\t\tif (WARN_ONCE(!trace_safe_str(iter, str),\n\t\t\t      \"fmt: '%s' current_buffer: '%s'\",\n\t\t\t      fmt, show_buffer(&iter->seq))) {\n\t\t\tint ret;\n\n\t\t\t/* Try to safely read the string */\n\t\t\tif (star) {\n\t\t\t\tif (len + 1 > iter->fmt_size)\n\t\t\t\t\tlen = iter->fmt_size - 1;\n\t\t\t\tif (len < 0)\n\t\t\t\t\tlen = 0;\n\t\t\t\tret = copy_from_kernel_nofault(iter->fmt, str, len);\n\t\t\t\titer->fmt[len] = 0;\n\t\t\t\tstar = false;\n\t\t\t} else {\n\t\t\t\tret = strncpy_from_kernel_nofault(iter->fmt, str,\n\t\t\t\t\t\t\t\t  iter->fmt_size);\n\t\t\t}\n\t\t\tif (ret < 0)\n\t\t\t\ttrace_seq_printf(&iter->seq, \"(0x%px)\", str);\n\t\t\telse\n\t\t\t\ttrace_seq_printf(&iter->seq, \"(0x%px:%s)\",\n\t\t\t\t\t\t str, iter->fmt);\n\t\t\tstr = \"[UNSAFE-MEMORY]\";\n\t\t\tstrcpy(iter->fmt, \"%s\");\n\t\t} else {\n\t\t\tstrncpy(iter->fmt, p + i, j + 1);\n\t\t\titer->fmt[j+1] = '\\0';\n\t\t}\n\t\tif (star)\n\t\t\ttrace_seq_printf(&iter->seq, iter->fmt, len, str);\n\t\telse\n\t\t\ttrace_seq_printf(&iter->seq, iter->fmt, str);\n\n\t\tp += i + j + 1;\n\t}\n print:\n\tif (*p)\n\t\ttrace_seq_vprintf(&iter->seq, p, ap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_event_format",
          "args": [
            "iter",
            "fmt"
          ],
          "line": 321
        },
        "resolved": true,
        "details": {
          "function_name": "trace_event_format",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "3892-3929",
          "snippet": "const char *trace_event_format(struct trace_iterator *iter, const char *fmt)\n{\n\tconst char *p, *new_fmt;\n\tchar *q;\n\n\tif (WARN_ON_ONCE(!fmt))\n\t\treturn fmt;\n\n\tif (!iter->tr || iter->tr->trace_flags & TRACE_ITER_HASH_PTR)\n\t\treturn fmt;\n\n\tp = fmt;\n\tnew_fmt = q = iter->fmt;\n\twhile (*p) {\n\t\tif (unlikely(q - new_fmt + 3 > iter->fmt_size)) {\n\t\t\tif (!trace_iter_expand_format(iter))\n\t\t\t\treturn fmt;\n\n\t\t\tq += iter->fmt - new_fmt;\n\t\t\tnew_fmt = iter->fmt;\n\t\t}\n\n\t\t*q++ = *p++;\n\n\t\t/* Replace %p with %px */\n\t\tif (p[-1] == '%') {\n\t\t\tif (p[0] == '%') {\n\t\t\t\t*q++ = *p++;\n\t\t\t} else if (p[0] == 'p' && !isalnum(p[1])) {\n\t\t\t\t*q++ = *p++;\n\t\t\t\t*q++ = 'x';\n\t\t\t}\n\t\t}\n\t}\n\t*q = '\\0';\n\n\treturn new_fmt;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nconst char *trace_event_format(struct trace_iterator *iter, const char *fmt)\n{\n\tconst char *p, *new_fmt;\n\tchar *q;\n\n\tif (WARN_ON_ONCE(!fmt))\n\t\treturn fmt;\n\n\tif (!iter->tr || iter->tr->trace_flags & TRACE_ITER_HASH_PTR)\n\t\treturn fmt;\n\n\tp = fmt;\n\tnew_fmt = q = iter->fmt;\n\twhile (*p) {\n\t\tif (unlikely(q - new_fmt + 3 > iter->fmt_size)) {\n\t\t\tif (!trace_iter_expand_format(iter))\n\t\t\t\treturn fmt;\n\n\t\t\tq += iter->fmt - new_fmt;\n\t\t\tnew_fmt = iter->fmt;\n\t\t}\n\n\t\t*q++ = *p++;\n\n\t\t/* Replace %p with %px */\n\t\tif (p[-1] == '%') {\n\t\t\tif (p[0] == '%') {\n\t\t\t\t*q++ = *p++;\n\t\t\t} else if (p[0] == 'p' && !isalnum(p[1])) {\n\t\t\t\t*q++ = *p++;\n\t\t\t\t*q++ = 'x';\n\t\t\t}\n\t\t}\n\t}\n\t*q = '\\0';\n\n\treturn new_fmt;\n}"
        }
      },
      {
        "call_info": {
          "callee": "va_start",
          "args": [
            "ap",
            "fmt"
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nvoid trace_event_printf(struct trace_iterator *iter, const char *fmt, ...)\n{\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\ttrace_check_vprintf(iter, trace_event_format(iter, fmt), ap);\n\tva_end(ap);\n}"
  },
  {
    "function_name": "trace_raw_output_prep",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_output.c",
    "lines": "293-313",
    "snippet": "int trace_raw_output_prep(struct trace_iterator *iter,\n\t\t\t  struct trace_event *trace_event)\n{\n\tstruct trace_event_call *event;\n\tstruct trace_seq *s = &iter->seq;\n\tstruct trace_seq *p = &iter->tmp_seq;\n\tstruct trace_entry *entry;\n\n\tevent = container_of(trace_event, struct trace_event_call, event);\n\tentry = iter->ent;\n\n\tif (entry->type != event->event.type) {\n\t\tWARN_ON_ONCE(1);\n\t\treturn TRACE_TYPE_UNHANDLED;\n\t}\n\n\ttrace_seq_init(p);\n\ttrace_seq_printf(s, \"%s: \", trace_event_name(event));\n\n\treturn trace_handle_return(s);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_handle_return",
          "args": [
            "s"
          ],
          "line": 312
        },
        "resolved": true,
        "details": {
          "function_name": "trace_handle_return",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "2577-2581",
          "snippet": "enum print_line_t trace_handle_return(struct trace_seq *s)\n{\n\treturn trace_seq_has_overflowed(s) ?\n\t\tTRACE_TYPE_PARTIAL_LINE : TRACE_TYPE_HANDLED;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nenum print_line_t trace_handle_return(struct trace_seq *s)\n{\n\treturn trace_seq_has_overflowed(s) ?\n\t\tTRACE_TYPE_PARTIAL_LINE : TRACE_TYPE_HANDLED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_seq_printf",
          "args": [
            "s",
            "\"%s: \"",
            "trace_event_name(event)"
          ],
          "line": 310
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "81-100",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_event_name",
          "args": [
            "event"
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_seq_init",
          "args": [
            "p"
          ],
          "line": 309
        },
        "resolved": true,
        "details": {
          "function_name": "__trace_seq_init",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "36-40",
          "snippet": "static inline void __trace_seq_init(struct trace_seq *s)\n{\n\tif (unlikely(!s->seq.size))\n\t\ttrace_seq_init(s);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nstatic inline void __trace_seq_init(struct trace_seq *s)\n{\n\tif (unlikely(!s->seq.size))\n\t\ttrace_seq_init(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "1"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "trace_event",
            "structtrace_event_call",
            "event"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nint trace_raw_output_prep(struct trace_iterator *iter,\n\t\t\t  struct trace_event *trace_event)\n{\n\tstruct trace_event_call *event;\n\tstruct trace_seq *s = &iter->seq;\n\tstruct trace_seq *p = &iter->tmp_seq;\n\tstruct trace_entry *entry;\n\n\tevent = container_of(trace_event, struct trace_event_call, event);\n\tentry = iter->ent;\n\n\tif (entry->type != event->event.type) {\n\t\tWARN_ON_ONCE(1);\n\t\treturn TRACE_TYPE_UNHANDLED;\n\t}\n\n\ttrace_seq_init(p);\n\ttrace_seq_printf(s, \"%s: \", trace_event_name(event));\n\n\treturn trace_handle_return(s);\n}"
  },
  {
    "function_name": "trace_print_hex_dump_seq",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_output.c",
    "lines": "278-290",
    "snippet": "const char *\ntrace_print_hex_dump_seq(struct trace_seq *p, const char *prefix_str,\n\t\t\t int prefix_type, int rowsize, int groupsize,\n\t\t\t const void *buf, size_t len, bool ascii)\n{\n\tconst char *ret = trace_seq_buffer_ptr(p);\n\n\ttrace_seq_putc(p, '\\n');\n\ttrace_seq_hex_dump(p, prefix_str, prefix_type,\n\t\t\t   rowsize, groupsize, buf, len, ascii);\n\ttrace_seq_putc(p, 0);\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_seq_putc",
          "args": [
            "p",
            "0"
          ],
          "line": 288
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_putc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "233-246",
          "snippet": "void trace_seq_putc(struct trace_seq *s, unsigned char c)\n{\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (TRACE_SEQ_BUF_LEFT(s) < 1) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putc(&s->seq, c);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_putc(struct trace_seq *s, unsigned char c)\n{\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (TRACE_SEQ_BUF_LEFT(s) < 1) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putc(&s->seq, c);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_seq_hex_dump",
          "args": [
            "p",
            "prefix_str",
            "prefix_type",
            "rowsize",
            "groupsize",
            "buf",
            "len",
            "ascii"
          ],
          "line": 286
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_hex_dump",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "377-404",
          "snippet": "int trace_seq_hex_dump(struct trace_seq *s, const char *prefix_str,\n\t\t       int prefix_type, int rowsize, int groupsize,\n\t\t       const void *buf, size_t len, bool ascii)\n{\n\tunsigned int save_len = s->seq.len;\n\n\tif (s->full)\n\t\treturn 0;\n\n\t__trace_seq_init(s);\n\n\tif (TRACE_SEQ_BUF_LEFT(s) < 1) {\n\t\ts->full = 1;\n\t\treturn 0;\n\t}\n\n\tseq_buf_hex_dump(&(s->seq), prefix_str,\n\t\t   prefix_type, rowsize, groupsize,\n\t\t   buf, len, ascii);\n\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nint trace_seq_hex_dump(struct trace_seq *s, const char *prefix_str,\n\t\t       int prefix_type, int rowsize, int groupsize,\n\t\t       const void *buf, size_t len, bool ascii)\n{\n\tunsigned int save_len = s->seq.len;\n\n\tif (s->full)\n\t\treturn 0;\n\n\t__trace_seq_init(s);\n\n\tif (TRACE_SEQ_BUF_LEFT(s) < 1) {\n\t\ts->full = 1;\n\t\treturn 0;\n\t}\n\n\tseq_buf_hex_dump(&(s->seq), prefix_str,\n\t\t   prefix_type, rowsize, groupsize,\n\t\t   buf, len, ascii);\n\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_seq_buffer_ptr",
          "args": [
            "p"
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nconst char *\ntrace_print_hex_dump_seq(struct trace_seq *p, const char *prefix_str,\n\t\t\t int prefix_type, int rowsize, int groupsize,\n\t\t\t const void *buf, size_t len, bool ascii)\n{\n\tconst char *ret = trace_seq_buffer_ptr(p);\n\n\ttrace_seq_putc(p, '\\n');\n\ttrace_seq_hex_dump(p, prefix_str, prefix_type,\n\t\t\t   rowsize, groupsize, buf, len, ascii);\n\ttrace_seq_putc(p, 0);\n\treturn ret;\n}"
  },
  {
    "function_name": "trace_print_array_seq",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_output.c",
    "lines": "233-275",
    "snippet": "const char *\ntrace_print_array_seq(struct trace_seq *p, const void *buf, int count,\n\t\t      size_t el_size)\n{\n\tconst char *ret = trace_seq_buffer_ptr(p);\n\tconst char *prefix = \"\";\n\tvoid *ptr = (void *)buf;\n\tsize_t buf_len = count * el_size;\n\n\ttrace_seq_putc(p, '{');\n\n\twhile (ptr < buf + buf_len) {\n\t\tswitch (el_size) {\n\t\tcase 1:\n\t\t\ttrace_seq_printf(p, \"%s0x%x\", prefix,\n\t\t\t\t\t *(u8 *)ptr);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\ttrace_seq_printf(p, \"%s0x%x\", prefix,\n\t\t\t\t\t *(u16 *)ptr);\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\ttrace_seq_printf(p, \"%s0x%x\", prefix,\n\t\t\t\t\t *(u32 *)ptr);\n\t\t\tbreak;\n\t\tcase 8:\n\t\t\ttrace_seq_printf(p, \"%s0x%llx\", prefix,\n\t\t\t\t\t *(u64 *)ptr);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\ttrace_seq_printf(p, \"BAD SIZE:%zu 0x%x\", el_size,\n\t\t\t\t\t *(u8 *)ptr);\n\t\t\tel_size = 1;\n\t\t}\n\t\tprefix = \",\";\n\t\tptr += el_size;\n\t}\n\n\ttrace_seq_putc(p, '}');\n\ttrace_seq_putc(p, 0);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_seq_putc",
          "args": [
            "p",
            "0"
          ],
          "line": 272
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_putc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "233-246",
          "snippet": "void trace_seq_putc(struct trace_seq *s, unsigned char c)\n{\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (TRACE_SEQ_BUF_LEFT(s) < 1) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putc(&s->seq, c);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_putc(struct trace_seq *s, unsigned char c)\n{\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (TRACE_SEQ_BUF_LEFT(s) < 1) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putc(&s->seq, c);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_seq_printf",
          "args": [
            "p",
            "\"BAD SIZE:%zu 0x%x\"",
            "el_size",
            "*(u8 *)ptr"
          ],
          "line": 263
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "81-100",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_seq_buffer_ptr",
          "args": [
            "p"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nconst char *\ntrace_print_array_seq(struct trace_seq *p, const void *buf, int count,\n\t\t      size_t el_size)\n{\n\tconst char *ret = trace_seq_buffer_ptr(p);\n\tconst char *prefix = \"\";\n\tvoid *ptr = (void *)buf;\n\tsize_t buf_len = count * el_size;\n\n\ttrace_seq_putc(p, '{');\n\n\twhile (ptr < buf + buf_len) {\n\t\tswitch (el_size) {\n\t\tcase 1:\n\t\t\ttrace_seq_printf(p, \"%s0x%x\", prefix,\n\t\t\t\t\t *(u8 *)ptr);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\ttrace_seq_printf(p, \"%s0x%x\", prefix,\n\t\t\t\t\t *(u16 *)ptr);\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\ttrace_seq_printf(p, \"%s0x%x\", prefix,\n\t\t\t\t\t *(u32 *)ptr);\n\t\t\tbreak;\n\t\tcase 8:\n\t\t\ttrace_seq_printf(p, \"%s0x%llx\", prefix,\n\t\t\t\t\t *(u64 *)ptr);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\ttrace_seq_printf(p, \"BAD SIZE:%zu 0x%x\", el_size,\n\t\t\t\t\t *(u8 *)ptr);\n\t\t\tel_size = 1;\n\t\t}\n\t\tprefix = \",\";\n\t\tptr += el_size;\n\t}\n\n\ttrace_seq_putc(p, '}');\n\ttrace_seq_putc(p, 0);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "trace_print_hex_seq",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_output.c",
    "lines": "217-230",
    "snippet": "const char *\ntrace_print_hex_seq(struct trace_seq *p, const unsigned char *buf, int buf_len,\n\t\t    bool concatenate)\n{\n\tint i;\n\tconst char *ret = trace_seq_buffer_ptr(p);\n\tconst char *fmt = concatenate ? \"%*phN\" : \"%*ph\";\n\n\tfor (i = 0; i < buf_len; i += 16)\n\t\ttrace_seq_printf(p, fmt, min(buf_len - i, 16), &buf[i]);\n\ttrace_seq_putc(p, 0);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_seq_putc",
          "args": [
            "p",
            "0"
          ],
          "line": 227
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_putc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "233-246",
          "snippet": "void trace_seq_putc(struct trace_seq *s, unsigned char c)\n{\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (TRACE_SEQ_BUF_LEFT(s) < 1) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putc(&s->seq, c);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_putc(struct trace_seq *s, unsigned char c)\n{\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (TRACE_SEQ_BUF_LEFT(s) < 1) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putc(&s->seq, c);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_seq_printf",
          "args": [
            "p",
            "fmt",
            "min(buf_len - i, 16)",
            "&buf[i]"
          ],
          "line": 226
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "81-100",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "buf_len - i",
            "16"
          ],
          "line": 226
        },
        "resolved": true,
        "details": {
          "function_name": "stop_critical_timing",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_irqsoff.c",
          "lines": "403-434",
          "snippet": "static nokprobe_inline void\nstop_critical_timing(unsigned long ip, unsigned long parent_ip)\n{\n\tint cpu;\n\tstruct trace_array *tr = irqsoff_trace;\n\tstruct trace_array_cpu *data;\n\tunsigned int trace_ctx;\n\n\tcpu = raw_smp_processor_id();\n\t/* Always clear the tracing cpu on stopping the trace */\n\tif (unlikely(per_cpu(tracing_cpu, cpu)))\n\t\tper_cpu(tracing_cpu, cpu) = 0;\n\telse\n\t\treturn;\n\n\tif (!tracer_enabled || !tracing_is_enabled())\n\t\treturn;\n\n\tdata = per_cpu_ptr(tr->array_buffer.data, cpu);\n\n\tif (unlikely(!data) ||\n\t    !data->critical_start || atomic_read(&data->disabled))\n\t\treturn;\n\n\tatomic_inc(&data->disabled);\n\n\ttrace_ctx = tracing_gen_ctx();\n\t__trace_function(tr, ip, parent_ip, trace_ctx);\n\tcheck_critical_timing(tr, data, parent_ip ? : ip, cpu);\n\tdata->critical_start = 0;\n\tatomic_dec(&data->disabled);\n}",
          "includes": [
            "#include <trace/events/preemptirq.h>",
            "#include \"trace.h\"",
            "#include <linux/kprobes.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [
            "#define __trace_function trace_function"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/preemptirq.h>\n#include \"trace.h\"\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n\n#define __trace_function trace_function\n\nstatic nokprobe_inline void\nstop_critical_timing(unsigned long ip, unsigned long parent_ip)\n{\n\tint cpu;\n\tstruct trace_array *tr = irqsoff_trace;\n\tstruct trace_array_cpu *data;\n\tunsigned int trace_ctx;\n\n\tcpu = raw_smp_processor_id();\n\t/* Always clear the tracing cpu on stopping the trace */\n\tif (unlikely(per_cpu(tracing_cpu, cpu)))\n\t\tper_cpu(tracing_cpu, cpu) = 0;\n\telse\n\t\treturn;\n\n\tif (!tracer_enabled || !tracing_is_enabled())\n\t\treturn;\n\n\tdata = per_cpu_ptr(tr->array_buffer.data, cpu);\n\n\tif (unlikely(!data) ||\n\t    !data->critical_start || atomic_read(&data->disabled))\n\t\treturn;\n\n\tatomic_inc(&data->disabled);\n\n\ttrace_ctx = tracing_gen_ctx();\n\t__trace_function(tr, ip, parent_ip, trace_ctx);\n\tcheck_critical_timing(tr, data, parent_ip ? : ip, cpu);\n\tdata->critical_start = 0;\n\tatomic_dec(&data->disabled);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_seq_buffer_ptr",
          "args": [
            "p"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nconst char *\ntrace_print_hex_seq(struct trace_seq *p, const unsigned char *buf, int buf_len,\n\t\t    bool concatenate)\n{\n\tint i;\n\tconst char *ret = trace_seq_buffer_ptr(p);\n\tconst char *fmt = concatenate ? \"%*phN\" : \"%*ph\";\n\n\tfor (i = 0; i < buf_len; i += 16)\n\t\ttrace_seq_printf(p, fmt, min(buf_len - i, 16), &buf[i]);\n\ttrace_seq_putc(p, 0);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "trace_print_bitmask_seq",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_output.c",
    "lines": "193-203",
    "snippet": "const char *\ntrace_print_bitmask_seq(struct trace_seq *p, void *bitmask_ptr,\n\t\t\tunsigned int bitmask_size)\n{\n\tconst char *ret = trace_seq_buffer_ptr(p);\n\n\ttrace_seq_bitmask(p, bitmask_ptr, bitmask_size * 8);\n\ttrace_seq_putc(p, 0);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_seq_putc",
          "args": [
            "p",
            "0"
          ],
          "line": 200
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_putc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "233-246",
          "snippet": "void trace_seq_putc(struct trace_seq *s, unsigned char c)\n{\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (TRACE_SEQ_BUF_LEFT(s) < 1) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putc(&s->seq, c);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_putc(struct trace_seq *s, unsigned char c)\n{\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (TRACE_SEQ_BUF_LEFT(s) < 1) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putc(&s->seq, c);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_seq_bitmask",
          "args": [
            "p",
            "bitmask_ptr",
            "bitmask_size * 8"
          ],
          "line": 199
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_bitmask",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "111-127",
          "snippet": "void trace_seq_bitmask(struct trace_seq *s, const unsigned long *maskp,\n\t\t      int nmaskbits)\n{\n\tunsigned int save_len = s->seq.len;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tseq_buf_printf(&s->seq, \"%*pb\", nmaskbits, maskp);\n\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_bitmask(struct trace_seq *s, const unsigned long *maskp,\n\t\t      int nmaskbits)\n{\n\tunsigned int save_len = s->seq.len;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tseq_buf_printf(&s->seq, \"%*pb\", nmaskbits, maskp);\n\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_seq_buffer_ptr",
          "args": [
            "p"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nconst char *\ntrace_print_bitmask_seq(struct trace_seq *p, void *bitmask_ptr,\n\t\t\tunsigned int bitmask_size)\n{\n\tconst char *ret = trace_seq_buffer_ptr(p);\n\n\ttrace_seq_bitmask(p, bitmask_ptr, bitmask_size * 8);\n\ttrace_seq_putc(p, 0);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "trace_print_symbols_seq_u64",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_output.c",
    "lines": "167-189",
    "snippet": "const char *\ntrace_print_symbols_seq_u64(struct trace_seq *p, unsigned long long val,\n\t\t\t const struct trace_print_flags_u64 *symbol_array)\n{\n\tint i;\n\tconst char *ret = trace_seq_buffer_ptr(p);\n\n\tfor (i = 0;  symbol_array[i].name; i++) {\n\n\t\tif (val != symbol_array[i].mask)\n\t\t\tcontinue;\n\n\t\ttrace_seq_puts(p, symbol_array[i].name);\n\t\tbreak;\n\t}\n\n\tif (ret == (const char *)(trace_seq_buffer_ptr(p)))\n\t\ttrace_seq_printf(p, \"0x%llx\", val);\n\n\ttrace_seq_putc(p, 0);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_seq_putc",
          "args": [
            "p",
            "0"
          ],
          "line": 186
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_putc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "233-246",
          "snippet": "void trace_seq_putc(struct trace_seq *s, unsigned char c)\n{\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (TRACE_SEQ_BUF_LEFT(s) < 1) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putc(&s->seq, c);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_putc(struct trace_seq *s, unsigned char c)\n{\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (TRACE_SEQ_BUF_LEFT(s) < 1) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putc(&s->seq, c);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_seq_printf",
          "args": [
            "p",
            "\"0x%llx\"",
            "val"
          ],
          "line": 184
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "81-100",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_seq_buffer_ptr",
          "args": [
            "p"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_seq_puts",
          "args": [
            "p",
            "symbol_array[i].name"
          ],
          "line": 179
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_puts",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "205-220",
          "snippet": "void trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_seq_buffer_ptr",
          "args": [
            "p"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nconst char *\ntrace_print_symbols_seq_u64(struct trace_seq *p, unsigned long long val,\n\t\t\t const struct trace_print_flags_u64 *symbol_array)\n{\n\tint i;\n\tconst char *ret = trace_seq_buffer_ptr(p);\n\n\tfor (i = 0;  symbol_array[i].name; i++) {\n\n\t\tif (val != symbol_array[i].mask)\n\t\t\tcontinue;\n\n\t\ttrace_seq_puts(p, symbol_array[i].name);\n\t\tbreak;\n\t}\n\n\tif (ret == (const char *)(trace_seq_buffer_ptr(p)))\n\t\ttrace_seq_printf(p, \"0x%llx\", val);\n\n\ttrace_seq_putc(p, 0);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "trace_print_flags_seq_u64",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_output.c",
    "lines": "129-164",
    "snippet": "const char *\ntrace_print_flags_seq_u64(struct trace_seq *p, const char *delim,\n\t\t      unsigned long long flags,\n\t\t      const struct trace_print_flags_u64 *flag_array)\n{\n\tunsigned long long mask;\n\tconst char *str;\n\tconst char *ret = trace_seq_buffer_ptr(p);\n\tint i, first = 1;\n\n\tfor (i = 0;  flag_array[i].name && flags; i++) {\n\n\t\tmask = flag_array[i].mask;\n\t\tif ((flags & mask) != mask)\n\t\t\tcontinue;\n\n\t\tstr = flag_array[i].name;\n\t\tflags &= ~mask;\n\t\tif (!first && delim)\n\t\t\ttrace_seq_puts(p, delim);\n\t\telse\n\t\t\tfirst = 0;\n\t\ttrace_seq_puts(p, str);\n\t}\n\n\t/* check for left over flags */\n\tif (flags) {\n\t\tif (!first && delim)\n\t\t\ttrace_seq_puts(p, delim);\n\t\ttrace_seq_printf(p, \"0x%llx\", flags);\n\t}\n\n\ttrace_seq_putc(p, 0);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_seq_putc",
          "args": [
            "p",
            "0"
          ],
          "line": 161
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_putc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "233-246",
          "snippet": "void trace_seq_putc(struct trace_seq *s, unsigned char c)\n{\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (TRACE_SEQ_BUF_LEFT(s) < 1) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putc(&s->seq, c);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_putc(struct trace_seq *s, unsigned char c)\n{\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (TRACE_SEQ_BUF_LEFT(s) < 1) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putc(&s->seq, c);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_seq_printf",
          "args": [
            "p",
            "\"0x%llx\"",
            "flags"
          ],
          "line": 158
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "81-100",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_seq_puts",
          "args": [
            "p",
            "delim"
          ],
          "line": 157
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_puts",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "205-220",
          "snippet": "void trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_seq_buffer_ptr",
          "args": [
            "p"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nconst char *\ntrace_print_flags_seq_u64(struct trace_seq *p, const char *delim,\n\t\t      unsigned long long flags,\n\t\t      const struct trace_print_flags_u64 *flag_array)\n{\n\tunsigned long long mask;\n\tconst char *str;\n\tconst char *ret = trace_seq_buffer_ptr(p);\n\tint i, first = 1;\n\n\tfor (i = 0;  flag_array[i].name && flags; i++) {\n\n\t\tmask = flag_array[i].mask;\n\t\tif ((flags & mask) != mask)\n\t\t\tcontinue;\n\n\t\tstr = flag_array[i].name;\n\t\tflags &= ~mask;\n\t\tif (!first && delim)\n\t\t\ttrace_seq_puts(p, delim);\n\t\telse\n\t\t\tfirst = 0;\n\t\ttrace_seq_puts(p, str);\n\t}\n\n\t/* check for left over flags */\n\tif (flags) {\n\t\tif (!first && delim)\n\t\t\ttrace_seq_puts(p, delim);\n\t\ttrace_seq_printf(p, \"0x%llx\", flags);\n\t}\n\n\ttrace_seq_putc(p, 0);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "trace_print_symbols_seq",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_output.c",
    "lines": "103-125",
    "snippet": "const char *\ntrace_print_symbols_seq(struct trace_seq *p, unsigned long val,\n\t\t\tconst struct trace_print_flags *symbol_array)\n{\n\tint i;\n\tconst char *ret = trace_seq_buffer_ptr(p);\n\n\tfor (i = 0;  symbol_array[i].name; i++) {\n\n\t\tif (val != symbol_array[i].mask)\n\t\t\tcontinue;\n\n\t\ttrace_seq_puts(p, symbol_array[i].name);\n\t\tbreak;\n\t}\n\n\tif (ret == (const char *)(trace_seq_buffer_ptr(p)))\n\t\ttrace_seq_printf(p, \"0x%lx\", val);\n\n\ttrace_seq_putc(p, 0);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_seq_putc",
          "args": [
            "p",
            "0"
          ],
          "line": 122
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_putc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "233-246",
          "snippet": "void trace_seq_putc(struct trace_seq *s, unsigned char c)\n{\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (TRACE_SEQ_BUF_LEFT(s) < 1) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putc(&s->seq, c);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_putc(struct trace_seq *s, unsigned char c)\n{\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (TRACE_SEQ_BUF_LEFT(s) < 1) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putc(&s->seq, c);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_seq_printf",
          "args": [
            "p",
            "\"0x%lx\"",
            "val"
          ],
          "line": 120
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "81-100",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_seq_buffer_ptr",
          "args": [
            "p"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_seq_puts",
          "args": [
            "p",
            "symbol_array[i].name"
          ],
          "line": 115
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_puts",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "205-220",
          "snippet": "void trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_seq_buffer_ptr",
          "args": [
            "p"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nconst char *\ntrace_print_symbols_seq(struct trace_seq *p, unsigned long val,\n\t\t\tconst struct trace_print_flags *symbol_array)\n{\n\tint i;\n\tconst char *ret = trace_seq_buffer_ptr(p);\n\n\tfor (i = 0;  symbol_array[i].name; i++) {\n\n\t\tif (val != symbol_array[i].mask)\n\t\t\tcontinue;\n\n\t\ttrace_seq_puts(p, symbol_array[i].name);\n\t\tbreak;\n\t}\n\n\tif (ret == (const char *)(trace_seq_buffer_ptr(p)))\n\t\ttrace_seq_printf(p, \"0x%lx\", val);\n\n\ttrace_seq_putc(p, 0);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "trace_print_flags_seq",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_output.c",
    "lines": "65-100",
    "snippet": "const char *\ntrace_print_flags_seq(struct trace_seq *p, const char *delim,\n\t\t      unsigned long flags,\n\t\t      const struct trace_print_flags *flag_array)\n{\n\tunsigned long mask;\n\tconst char *str;\n\tconst char *ret = trace_seq_buffer_ptr(p);\n\tint i, first = 1;\n\n\tfor (i = 0;  flag_array[i].name && flags; i++) {\n\n\t\tmask = flag_array[i].mask;\n\t\tif ((flags & mask) != mask)\n\t\t\tcontinue;\n\n\t\tstr = flag_array[i].name;\n\t\tflags &= ~mask;\n\t\tif (!first && delim)\n\t\t\ttrace_seq_puts(p, delim);\n\t\telse\n\t\t\tfirst = 0;\n\t\ttrace_seq_puts(p, str);\n\t}\n\n\t/* check for left over flags */\n\tif (flags) {\n\t\tif (!first && delim)\n\t\t\ttrace_seq_puts(p, delim);\n\t\ttrace_seq_printf(p, \"0x%lx\", flags);\n\t}\n\n\ttrace_seq_putc(p, 0);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_seq_putc",
          "args": [
            "p",
            "0"
          ],
          "line": 97
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_putc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "233-246",
          "snippet": "void trace_seq_putc(struct trace_seq *s, unsigned char c)\n{\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (TRACE_SEQ_BUF_LEFT(s) < 1) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putc(&s->seq, c);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_putc(struct trace_seq *s, unsigned char c)\n{\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (TRACE_SEQ_BUF_LEFT(s) < 1) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putc(&s->seq, c);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_seq_printf",
          "args": [
            "p",
            "\"0x%lx\"",
            "flags"
          ],
          "line": 94
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "81-100",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_seq_puts",
          "args": [
            "p",
            "delim"
          ],
          "line": 93
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_puts",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "205-220",
          "snippet": "void trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_seq_buffer_ptr",
          "args": [
            "p"
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nconst char *\ntrace_print_flags_seq(struct trace_seq *p, const char *delim,\n\t\t      unsigned long flags,\n\t\t      const struct trace_print_flags *flag_array)\n{\n\tunsigned long mask;\n\tconst char *str;\n\tconst char *ret = trace_seq_buffer_ptr(p);\n\tint i, first = 1;\n\n\tfor (i = 0;  flag_array[i].name && flags; i++) {\n\n\t\tmask = flag_array[i].mask;\n\t\tif ((flags & mask) != mask)\n\t\t\tcontinue;\n\n\t\tstr = flag_array[i].name;\n\t\tflags &= ~mask;\n\t\tif (!first && delim)\n\t\t\ttrace_seq_puts(p, delim);\n\t\telse\n\t\t\tfirst = 0;\n\t\ttrace_seq_puts(p, str);\n\t}\n\n\t/* check for left over flags */\n\tif (flags) {\n\t\tif (!first && delim)\n\t\t\ttrace_seq_puts(p, delim);\n\t\ttrace_seq_printf(p, \"0x%lx\", flags);\n\t}\n\n\ttrace_seq_putc(p, 0);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "trace_print_printk_msg_only",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_output.c",
    "lines": "52-63",
    "snippet": "enum print_line_t trace_print_printk_msg_only(struct trace_iterator *iter)\n{\n\tstruct trace_seq *s = &iter->seq;\n\tstruct trace_entry *entry = iter->ent;\n\tstruct print_entry *field;\n\n\ttrace_assign_type(field, entry);\n\n\ttrace_seq_puts(s, field->buf);\n\n\treturn trace_handle_return(s);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_handle_return",
          "args": [
            "s"
          ],
          "line": 62
        },
        "resolved": true,
        "details": {
          "function_name": "trace_handle_return",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "2577-2581",
          "snippet": "enum print_line_t trace_handle_return(struct trace_seq *s)\n{\n\treturn trace_seq_has_overflowed(s) ?\n\t\tTRACE_TYPE_PARTIAL_LINE : TRACE_TYPE_HANDLED;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nenum print_line_t trace_handle_return(struct trace_seq *s)\n{\n\treturn trace_seq_has_overflowed(s) ?\n\t\tTRACE_TYPE_PARTIAL_LINE : TRACE_TYPE_HANDLED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_seq_puts",
          "args": [
            "s",
            "field->buf"
          ],
          "line": 60
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_puts",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "205-220",
          "snippet": "void trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_assign_type",
          "args": [
            "field",
            "entry"
          ],
          "line": 58
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nenum print_line_t trace_print_printk_msg_only(struct trace_iterator *iter)\n{\n\tstruct trace_seq *s = &iter->seq;\n\tstruct trace_entry *entry = iter->ent;\n\tstruct print_entry *field;\n\n\ttrace_assign_type(field, entry);\n\n\ttrace_seq_puts(s, field->buf);\n\n\treturn trace_handle_return(s);\n}"
  },
  {
    "function_name": "trace_print_bprintk_msg_only",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_output.c",
    "lines": "39-50",
    "snippet": "enum print_line_t trace_print_bprintk_msg_only(struct trace_iterator *iter)\n{\n\tstruct trace_seq *s = &iter->seq;\n\tstruct trace_entry *entry = iter->ent;\n\tstruct bprint_entry *field;\n\n\ttrace_assign_type(field, entry);\n\n\ttrace_seq_bprintf(s, field->fmt, field->buf);\n\n\treturn trace_handle_return(s);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_handle_return",
          "args": [
            "s"
          ],
          "line": 49
        },
        "resolved": true,
        "details": {
          "function_name": "trace_handle_return",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "2577-2581",
          "snippet": "enum print_line_t trace_handle_return(struct trace_seq *s)\n{\n\treturn trace_seq_has_overflowed(s) ?\n\t\tTRACE_TYPE_PARTIAL_LINE : TRACE_TYPE_HANDLED;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nenum print_line_t trace_handle_return(struct trace_seq *s)\n{\n\treturn trace_seq_has_overflowed(s) ?\n\t\tTRACE_TYPE_PARTIAL_LINE : TRACE_TYPE_HANDLED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_seq_bprintf",
          "args": [
            "s",
            "field->fmt",
            "field->buf"
          ],
          "line": 47
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_bprintf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "175-192",
          "snippet": "void trace_seq_bprintf(struct trace_seq *s, const char *fmt, const u32 *binary)\n{\n\tunsigned int save_len = s->seq.len;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tseq_buf_bprintf(&s->seq, fmt, binary);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t\treturn;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_bprintf(struct trace_seq *s, const char *fmt, const u32 *binary)\n{\n\tunsigned int save_len = s->seq.len;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tseq_buf_bprintf(&s->seq, fmt, binary);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t\treturn;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_assign_type",
          "args": [
            "field",
            "entry"
          ],
          "line": 45
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nenum print_line_t trace_print_bprintk_msg_only(struct trace_iterator *iter)\n{\n\tstruct trace_seq *s = &iter->seq;\n\tstruct trace_entry *entry = iter->ent;\n\tstruct bprint_entry *field;\n\n\ttrace_assign_type(field, entry);\n\n\ttrace_seq_bprintf(s, field->fmt, field->buf);\n\n\treturn trace_handle_return(s);\n}"
  },
  {
    "function_name": "trace_print_bputs_msg_only",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_output.c",
    "lines": "26-37",
    "snippet": "enum print_line_t trace_print_bputs_msg_only(struct trace_iterator *iter)\n{\n\tstruct trace_seq *s = &iter->seq;\n\tstruct trace_entry *entry = iter->ent;\n\tstruct bputs_entry *field;\n\n\ttrace_assign_type(field, entry);\n\n\ttrace_seq_puts(s, field->str);\n\n\treturn trace_handle_return(s);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_handle_return",
          "args": [
            "s"
          ],
          "line": 36
        },
        "resolved": true,
        "details": {
          "function_name": "trace_handle_return",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "2577-2581",
          "snippet": "enum print_line_t trace_handle_return(struct trace_seq *s)\n{\n\treturn trace_seq_has_overflowed(s) ?\n\t\tTRACE_TYPE_PARTIAL_LINE : TRACE_TYPE_HANDLED;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nenum print_line_t trace_handle_return(struct trace_seq *s)\n{\n\treturn trace_seq_has_overflowed(s) ?\n\t\tTRACE_TYPE_PARTIAL_LINE : TRACE_TYPE_HANDLED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_seq_puts",
          "args": [
            "s",
            "field->str"
          ],
          "line": 34
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_puts",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "205-220",
          "snippet": "void trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_assign_type",
          "args": [
            "field",
            "entry"
          ],
          "line": 32
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nenum print_line_t trace_print_bputs_msg_only(struct trace_iterator *iter)\n{\n\tstruct trace_seq *s = &iter->seq;\n\tstruct trace_entry *entry = iter->ent;\n\tstruct bputs_entry *field;\n\n\ttrace_assign_type(field, entry);\n\n\ttrace_seq_puts(s, field->str);\n\n\treturn trace_handle_return(s);\n}"
  }
]