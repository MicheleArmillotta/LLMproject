[
  {
    "function_name": "bpf_struct_ops_put",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_struct_ops.c",
    "lines": "649-672",
    "snippet": "void bpf_struct_ops_put(const void *kdata)\n{\n\tstruct bpf_struct_ops_value *kvalue;\n\n\tkvalue = container_of(kdata, struct bpf_struct_ops_value, data);\n\tif (refcount_dec_and_test(&kvalue->refcnt)) {\n\t\tstruct bpf_struct_ops_map *st_map;\n\n\t\tst_map = container_of(kvalue, struct bpf_struct_ops_map,\n\t\t\t\t      kvalue);\n\t\t/* The struct_ops's function may switch to another struct_ops.\n\t\t *\n\t\t * For example, bpf_tcp_cc_x->init() may switch to\n\t\t * another tcp_cc_y by calling\n\t\t * setsockopt(TCP_CONGESTION, \"tcp_cc_y\").\n\t\t * During the switch,  bpf_struct_ops_put(tcp_cc_x) is called\n\t\t * and its map->refcnt may reach 0 which then free its\n\t\t * trampoline image while tcp_cc_x is still running.\n\t\t *\n\t\t * Thus, a rcu grace period is needed here.\n\t\t */\n\t\tcall_rcu(&st_map->rcu, bpf_struct_ops_put_rcu);\n\t}\n}",
    "includes": [
      "#include \"bpf_struct_ops_types.h\"",
      "#include \"bpf_struct_ops_types.h\"",
      "#include \"bpf_struct_ops_types.h\"",
      "#include <linux/mutex.h>",
      "#include <linux/refcount.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/numa.h>",
      "#include <linux/slab.h>",
      "#include <linux/filter.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "call_rcu",
          "args": [
            "&st_map->rcu",
            "bpf_struct_ops_put_rcu"
          ],
          "line": 670
        },
        "resolved": true,
        "details": {
          "function_name": "call_rcu_tasks_trace",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tasks.h",
          "lines": "1533-1536",
          "snippet": "void call_rcu_tasks_trace(struct rcu_head *rhp, rcu_callback_t func)\n{\n\tcall_rcu_tasks_generic(rhp, func, &rcu_tasks_trace);\n}",
          "includes": [
            "#include \"rcu_segcblist.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n\nvoid call_rcu_tasks_trace(struct rcu_head *rhp, rcu_callback_t func)\n{\n\tcall_rcu_tasks_generic(rhp, func, &rcu_tasks_trace);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "kvalue",
            "structbpf_struct_ops_map",
            "kvalue"
          ],
          "line": 657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "refcount_dec_and_test",
          "args": [
            "&kvalue->refcnt"
          ],
          "line": 654
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "kdata",
            "structbpf_struct_ops_value",
            "data"
          ],
          "line": 653
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"bpf_struct_ops_types.h\"\n#include \"bpf_struct_ops_types.h\"\n#include \"bpf_struct_ops_types.h\"\n#include <linux/mutex.h>\n#include <linux/refcount.h>\n#include <linux/seq_file.h>\n#include <linux/numa.h>\n#include <linux/slab.h>\n#include <linux/filter.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf.h>\n\nvoid bpf_struct_ops_put(const void *kdata)\n{\n\tstruct bpf_struct_ops_value *kvalue;\n\n\tkvalue = container_of(kdata, struct bpf_struct_ops_value, data);\n\tif (refcount_dec_and_test(&kvalue->refcnt)) {\n\t\tstruct bpf_struct_ops_map *st_map;\n\n\t\tst_map = container_of(kvalue, struct bpf_struct_ops_map,\n\t\t\t\t      kvalue);\n\t\t/* The struct_ops's function may switch to another struct_ops.\n\t\t *\n\t\t * For example, bpf_tcp_cc_x->init() may switch to\n\t\t * another tcp_cc_y by calling\n\t\t * setsockopt(TCP_CONGESTION, \"tcp_cc_y\").\n\t\t * During the switch,  bpf_struct_ops_put(tcp_cc_x) is called\n\t\t * and its map->refcnt may reach 0 which then free its\n\t\t * trampoline image while tcp_cc_x is still running.\n\t\t *\n\t\t * Thus, a rcu grace period is needed here.\n\t\t */\n\t\tcall_rcu(&st_map->rcu, bpf_struct_ops_put_rcu);\n\t}\n}"
  },
  {
    "function_name": "bpf_struct_ops_put_rcu",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_struct_ops.c",
    "lines": "641-647",
    "snippet": "static void bpf_struct_ops_put_rcu(struct rcu_head *head)\n{\n\tstruct bpf_struct_ops_map *st_map;\n\n\tst_map = container_of(head, struct bpf_struct_ops_map, rcu);\n\tbpf_map_put(&st_map->map);\n}",
    "includes": [
      "#include \"bpf_struct_ops_types.h\"",
      "#include \"bpf_struct_ops_types.h\"",
      "#include \"bpf_struct_ops_types.h\"",
      "#include <linux/mutex.h>",
      "#include <linux/refcount.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/numa.h>",
      "#include <linux/slab.h>",
      "#include <linux/filter.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bpf_map_put",
          "args": [
            "&st_map->map"
          ],
          "line": 646
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_map_put_with_uref",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "514-518",
          "snippet": "void bpf_map_put_with_uref(struct bpf_map *map)\n{\n\tbpf_map_put_uref(map);\n\tbpf_map_put(map);\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nvoid bpf_map_put_with_uref(struct bpf_map *map)\n{\n\tbpf_map_put_uref(map);\n\tbpf_map_put(map);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "head",
            "structbpf_struct_ops_map",
            "rcu"
          ],
          "line": 645
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"bpf_struct_ops_types.h\"\n#include \"bpf_struct_ops_types.h\"\n#include \"bpf_struct_ops_types.h\"\n#include <linux/mutex.h>\n#include <linux/refcount.h>\n#include <linux/seq_file.h>\n#include <linux/numa.h>\n#include <linux/slab.h>\n#include <linux/filter.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf.h>\n\nstatic void bpf_struct_ops_put_rcu(struct rcu_head *head)\n{\n\tstruct bpf_struct_ops_map *st_map;\n\n\tst_map = container_of(head, struct bpf_struct_ops_map, rcu);\n\tbpf_map_put(&st_map->map);\n}"
  },
  {
    "function_name": "bpf_struct_ops_get",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_struct_ops.c",
    "lines": "632-639",
    "snippet": "bool bpf_struct_ops_get(const void *kdata)\n{\n\tstruct bpf_struct_ops_value *kvalue;\n\n\tkvalue = container_of(kdata, struct bpf_struct_ops_value, data);\n\n\treturn refcount_inc_not_zero(&kvalue->refcnt);\n}",
    "includes": [
      "#include \"bpf_struct_ops_types.h\"",
      "#include \"bpf_struct_ops_types.h\"",
      "#include \"bpf_struct_ops_types.h\"",
      "#include <linux/mutex.h>",
      "#include <linux/refcount.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/numa.h>",
      "#include <linux/slab.h>",
      "#include <linux/filter.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "refcount_inc_not_zero",
          "args": [
            "&kvalue->refcnt"
          ],
          "line": 638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "kdata",
            "structbpf_struct_ops_value",
            "data"
          ],
          "line": 636
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"bpf_struct_ops_types.h\"\n#include \"bpf_struct_ops_types.h\"\n#include \"bpf_struct_ops_types.h\"\n#include <linux/mutex.h>\n#include <linux/refcount.h>\n#include <linux/seq_file.h>\n#include <linux/numa.h>\n#include <linux/slab.h>\n#include <linux/filter.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf.h>\n\nbool bpf_struct_ops_get(const void *kdata)\n{\n\tstruct bpf_struct_ops_value *kvalue;\n\n\tkvalue = container_of(kdata, struct bpf_struct_ops_value, data);\n\n\treturn refcount_inc_not_zero(&kvalue->refcnt);\n}"
  },
  {
    "function_name": "bpf_struct_ops_map_alloc",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_struct_ops.c",
    "lines": "564-613",
    "snippet": "static struct bpf_map *bpf_struct_ops_map_alloc(union bpf_attr *attr)\n{\n\tconst struct bpf_struct_ops *st_ops;\n\tsize_t st_map_size;\n\tstruct bpf_struct_ops_map *st_map;\n\tconst struct btf_type *t, *vt;\n\tstruct bpf_map *map;\n\n\tif (!bpf_capable())\n\t\treturn ERR_PTR(-EPERM);\n\n\tst_ops = bpf_struct_ops_find_value(attr->btf_vmlinux_value_type_id);\n\tif (!st_ops)\n\t\treturn ERR_PTR(-ENOTSUPP);\n\n\tvt = st_ops->value_type;\n\tif (attr->value_size != vt->size)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tt = st_ops->type;\n\n\tst_map_size = sizeof(*st_map) +\n\t\t/* kvalue stores the\n\t\t * struct bpf_struct_ops_tcp_congestions_ops\n\t\t */\n\t\t(vt->size - sizeof(struct bpf_struct_ops_value));\n\n\tst_map = bpf_map_area_alloc(st_map_size, NUMA_NO_NODE);\n\tif (!st_map)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tst_map->st_ops = st_ops;\n\tmap = &st_map->map;\n\n\tst_map->uvalue = bpf_map_area_alloc(vt->size, NUMA_NO_NODE);\n\tst_map->progs =\n\t\tbpf_map_area_alloc(btf_type_vlen(t) * sizeof(struct bpf_prog *),\n\t\t\t\t   NUMA_NO_NODE);\n\tst_map->image = bpf_jit_alloc_exec(PAGE_SIZE);\n\tif (!st_map->uvalue || !st_map->progs || !st_map->image) {\n\t\tbpf_struct_ops_map_free(map);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tmutex_init(&st_map->lock);\n\tset_vm_flush_reset_perms(st_map->image);\n\tbpf_map_init_from_attr(map, attr);\n\n\treturn map;\n}",
    "includes": [
      "#include \"bpf_struct_ops_types.h\"",
      "#include \"bpf_struct_ops_types.h\"",
      "#include \"bpf_struct_ops_types.h\"",
      "#include <linux/mutex.h>",
      "#include <linux/refcount.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/numa.h>",
      "#include <linux/slab.h>",
      "#include <linux/filter.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct bpf_struct_ops * const bpf_struct_ops[] = {\n#define BPF_STRUCT_OPS_TYPE(_name)\t\t\t\t\\\n\t[BPF_STRUCT_OPS_TYPE_##_name] = &bpf_##_name,\n#include \"bpf_struct_ops_types.h\"\n#undef BPF_STRUCT_OPS_TYPE\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bpf_map_init_from_attr",
          "args": [
            "map",
            "attr"
          ],
          "line": 610
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_map_init_from_attr",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "361-370",
          "snippet": "void bpf_map_init_from_attr(struct bpf_map *map, union bpf_attr *attr)\n{\n\tmap->map_type = attr->map_type;\n\tmap->key_size = attr->key_size;\n\tmap->value_size = attr->value_size;\n\tmap->max_entries = attr->max_entries;\n\tmap->map_flags = bpf_map_flags_retain_permanent(attr->map_flags);\n\tmap->numa_node = bpf_map_attr_numa_node(attr);\n\tmap->map_extra = attr->map_extra;\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nvoid bpf_map_init_from_attr(struct bpf_map *map, union bpf_attr *attr)\n{\n\tmap->map_type = attr->map_type;\n\tmap->key_size = attr->key_size;\n\tmap->value_size = attr->value_size;\n\tmap->max_entries = attr->max_entries;\n\tmap->map_flags = bpf_map_flags_retain_permanent(attr->map_flags);\n\tmap->numa_node = bpf_map_attr_numa_node(attr);\n\tmap->map_extra = attr->map_extra;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_vm_flush_reset_perms",
          "args": [
            "st_map->image"
          ],
          "line": 609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&st_map->lock"
          ],
          "line": 608
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_init_task",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/fork.c",
          "lines": "1700-1708",
          "snippet": "static void rt_mutex_init_task(struct task_struct *p)\n{\n\traw_spin_lock_init(&p->pi_lock);\n#ifdef CONFIG_RT_MUTEXES\n\tp->pi_waiters = RB_ROOT_CACHED;\n\tp->pi_top_task = NULL;\n\tp->pi_blocked_on = NULL;\n#endif\n}",
          "includes": [
            "#include <linux/init_task.h>",
            "#include <trace/events/task.h>",
            "#include <trace/events/sched.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <linux/bpf.h>",
            "#include <linux/io_uring.h>",
            "#include <linux/scs.h>",
            "#include <linux/kasan.h>",
            "#include <linux/stackleak.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/kcov.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/compiler.h>",
            "#include <linux/aio.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/oom.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/magic.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/tty.h>",
            "#include <linux/random.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/acct.h>",
            "#include <linux/ksm.h>",
            "#include <linux/rmap.h>",
            "#include <linux/profile.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/kthread.h>",
            "#include <linux/compat.h>",
            "#include <linux/futex.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mman.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/sem.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>",
            "#include <linux/unistd.h>",
            "#include <linux/init.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/anon_inodes.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __latent_entropy struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/init_task.h>\n#include <trace/events/task.h>\n#include <trace/events/sched.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <linux/bpf.h>\n#include <linux/io_uring.h>\n#include <linux/scs.h>\n#include <linux/kasan.h>\n#include <linux/stackleak.h>\n#include <linux/thread_info.h>\n#include <linux/livepatch.h>\n#include <linux/kcov.h>\n#include <linux/sysctl.h>\n#include <linux/compiler.h>\n#include <linux/aio.h>\n#include <linux/uprobes.h>\n#include <linux/signalfd.h>\n#include <linux/khugepaged.h>\n#include <linux/oom.h>\n#include <linux/user-return-notifier.h>\n#include <linux/posix-timers.h>\n#include <linux/perf_event.h>\n#include <linux/magic.h>\n#include <linux/fs_struct.h>\n#include <linux/tty.h>\n#include <linux/random.h>\n#include <linux/taskstats_kern.h>\n#include <linux/delayacct.h>\n#include <linux/freezer.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/acct.h>\n#include <linux/ksm.h>\n#include <linux/rmap.h>\n#include <linux/profile.h>\n#include <linux/proc_fs.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/ptrace.h>\n#include <linux/rcupdate.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/kthread.h>\n#include <linux/compat.h>\n#include <linux/futex.h>\n#include <linux/jiffies.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/seccomp.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/cgroup.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/nsproxy.h>\n#include <linux/vmacache.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mman.h>\n#include <linux/binfmts.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/sem.h>\n#include <linux/mempolicy.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/unistd.h>\n#include <linux/init.h>\n#include <linux/rtmutex.h>\n#include <linux/seq_file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/user.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/anon_inodes.h>\n\nstatic __latent_entropy struct;\n\nstatic void rt_mutex_init_task(struct task_struct *p)\n{\n\traw_spin_lock_init(&p->pi_lock);\n#ifdef CONFIG_RT_MUTEXES\n\tp->pi_waiters = RB_ROOT_CACHED;\n\tp->pi_top_task = NULL;\n\tp->pi_blocked_on = NULL;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_struct_ops_map_free",
          "args": [
            "map"
          ],
          "line": 604
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_struct_ops_map_free",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_struct_ops.c",
          "lines": "544-554",
          "snippet": "static void bpf_struct_ops_map_free(struct bpf_map *map)\n{\n\tstruct bpf_struct_ops_map *st_map = (struct bpf_struct_ops_map *)map;\n\n\tif (st_map->progs)\n\t\tbpf_struct_ops_map_put_progs(st_map);\n\tbpf_map_area_free(st_map->progs);\n\tbpf_jit_free_exec(st_map->image);\n\tbpf_map_area_free(st_map->uvalue);\n\tbpf_map_area_free(st_map);\n}",
          "includes": [
            "#include \"bpf_struct_ops_types.h\"",
            "#include \"bpf_struct_ops_types.h\"",
            "#include \"bpf_struct_ops_types.h\"",
            "#include <linux/mutex.h>",
            "#include <linux/refcount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/numa.h>",
            "#include <linux/slab.h>",
            "#include <linux/filter.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bpf_struct_ops_types.h\"\n#include \"bpf_struct_ops_types.h\"\n#include \"bpf_struct_ops_types.h\"\n#include <linux/mutex.h>\n#include <linux/refcount.h>\n#include <linux/seq_file.h>\n#include <linux/numa.h>\n#include <linux/slab.h>\n#include <linux/filter.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf.h>\n\nstatic void bpf_struct_ops_map_free(struct bpf_map *map)\n{\n\tstruct bpf_struct_ops_map *st_map = (struct bpf_struct_ops_map *)map;\n\n\tif (st_map->progs)\n\t\tbpf_struct_ops_map_put_progs(st_map);\n\tbpf_map_area_free(st_map->progs);\n\tbpf_jit_free_exec(st_map->image);\n\tbpf_map_area_free(st_map->uvalue);\n\tbpf_map_area_free(st_map);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_jit_alloc_exec",
          "args": [
            "PAGE_SIZE"
          ],
          "line": 602
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_jit_alloc_exec",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/core.c",
          "lines": "854-857",
          "snippet": "void *__weak bpf_jit_alloc_exec(unsigned long size)\n{\n\treturn module_alloc(size);\n}",
          "includes": [
            "#include <linux/bpf_trace.h>",
            "#include <asm/unaligned.h>",
            "#include <asm/barrier.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/log2.h>",
            "#include <linux/extable.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rbtree_latch.h>",
            "#include <linux/objtool.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/random.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/filter.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "const struct bpf_func_proto bpf_map_lookup_elem_proto __weak;",
            "const struct bpf_func_proto bpf_map_update_elem_proto __weak;",
            "const struct bpf_func_proto bpf_map_delete_elem_proto __weak;",
            "const struct bpf_func_proto bpf_map_push_elem_proto __weak;",
            "const struct bpf_func_proto bpf_map_pop_elem_proto __weak;",
            "const struct bpf_func_proto bpf_map_peek_elem_proto __weak;",
            "const struct bpf_func_proto bpf_spin_lock_proto __weak;",
            "const struct bpf_func_proto bpf_spin_unlock_proto __weak;",
            "const struct bpf_func_proto bpf_jiffies64_proto __weak;",
            "const struct bpf_func_proto bpf_get_prandom_u32_proto __weak;",
            "const struct bpf_func_proto bpf_get_smp_processor_id_proto __weak;",
            "const struct bpf_func_proto bpf_get_numa_node_id_proto __weak;",
            "const struct bpf_func_proto bpf_ktime_get_ns_proto __weak;",
            "const struct bpf_func_proto bpf_ktime_get_boot_ns_proto __weak;",
            "const struct bpf_func_proto bpf_ktime_get_coarse_ns_proto __weak;",
            "const struct bpf_func_proto bpf_get_current_pid_tgid_proto __weak;",
            "const struct bpf_func_proto bpf_get_current_uid_gid_proto __weak;",
            "const struct bpf_func_proto bpf_get_current_comm_proto __weak;",
            "const struct bpf_func_proto bpf_get_current_cgroup_id_proto __weak;",
            "const struct bpf_func_proto bpf_get_current_ancestor_cgroup_id_proto __weak;",
            "const struct bpf_func_proto bpf_get_local_storage_proto __weak;",
            "const struct bpf_func_proto bpf_get_ns_current_pid_tgid_proto __weak;",
            "const struct bpf_func_proto bpf_snprintf_btf_proto __weak;",
            "const struct bpf_func_proto bpf_seq_printf_btf_proto __weak;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <asm/barrier.h>\n#include <linux/bpf_verifier.h>\n#include <linux/log2.h>\n#include <linux/extable.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/objtool.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n#include <uapi/linux/btf.h>\n\nconst struct bpf_func_proto bpf_map_lookup_elem_proto __weak;\nconst struct bpf_func_proto bpf_map_update_elem_proto __weak;\nconst struct bpf_func_proto bpf_map_delete_elem_proto __weak;\nconst struct bpf_func_proto bpf_map_push_elem_proto __weak;\nconst struct bpf_func_proto bpf_map_pop_elem_proto __weak;\nconst struct bpf_func_proto bpf_map_peek_elem_proto __weak;\nconst struct bpf_func_proto bpf_spin_lock_proto __weak;\nconst struct bpf_func_proto bpf_spin_unlock_proto __weak;\nconst struct bpf_func_proto bpf_jiffies64_proto __weak;\nconst struct bpf_func_proto bpf_get_prandom_u32_proto __weak;\nconst struct bpf_func_proto bpf_get_smp_processor_id_proto __weak;\nconst struct bpf_func_proto bpf_get_numa_node_id_proto __weak;\nconst struct bpf_func_proto bpf_ktime_get_ns_proto __weak;\nconst struct bpf_func_proto bpf_ktime_get_boot_ns_proto __weak;\nconst struct bpf_func_proto bpf_ktime_get_coarse_ns_proto __weak;\nconst struct bpf_func_proto bpf_get_current_pid_tgid_proto __weak;\nconst struct bpf_func_proto bpf_get_current_uid_gid_proto __weak;\nconst struct bpf_func_proto bpf_get_current_comm_proto __weak;\nconst struct bpf_func_proto bpf_get_current_cgroup_id_proto __weak;\nconst struct bpf_func_proto bpf_get_current_ancestor_cgroup_id_proto __weak;\nconst struct bpf_func_proto bpf_get_local_storage_proto __weak;\nconst struct bpf_func_proto bpf_get_ns_current_pid_tgid_proto __weak;\nconst struct bpf_func_proto bpf_snprintf_btf_proto __weak;\nconst struct bpf_func_proto bpf_seq_printf_btf_proto __weak;\n\nvoid *__weak bpf_jit_alloc_exec(unsigned long size)\n{\n\treturn module_alloc(size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_map_area_alloc",
          "args": [
            "btf_type_vlen(t) * sizeof(struct bpf_prog *)",
            "NUMA_NO_NODE"
          ],
          "line": 600
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_map_area_alloc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "334-337",
          "snippet": "void *bpf_map_area_alloc(u64 size, int numa_node)\n{\n\treturn __bpf_map_area_alloc(size, numa_node, false);\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nvoid *bpf_map_area_alloc(u64 size, int numa_node)\n{\n\treturn __bpf_map_area_alloc(size, numa_node, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_type_vlen",
          "args": [
            "t"
          ],
          "line": 600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EINVAL"
          ],
          "line": 581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOTSUPP"
          ],
          "line": 577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_struct_ops_find_value",
          "args": [
            "attr->btf_vmlinux_value_type_id"
          ],
          "line": 575
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_struct_ops_find_value",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_struct_ops.c",
          "lines": "204-218",
          "snippet": "static const struct bpf_struct_ops *\nbpf_struct_ops_find_value(u32 value_id)\n{\n\tunsigned int i;\n\n\tif (!value_id || !btf_vmlinux)\n\t\treturn NULL;\n\n\tfor (i = 0; i < ARRAY_SIZE(bpf_struct_ops); i++) {\n\t\tif (bpf_struct_ops[i]->value_id == value_id)\n\t\t\treturn bpf_struct_ops[i];\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"bpf_struct_ops_types.h\"",
            "#include \"bpf_struct_ops_types.h\"",
            "#include \"bpf_struct_ops_types.h\"",
            "#include <linux/mutex.h>",
            "#include <linux/refcount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/numa.h>",
            "#include <linux/slab.h>",
            "#include <linux/filter.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct bpf_struct_ops * const bpf_struct_ops[] = {\n#define BPF_STRUCT_OPS_TYPE(_name)\t\t\t\t\\\n\t[BPF_STRUCT_OPS_TYPE_##_name] = &bpf_##_name,\n#include \"bpf_struct_ops_types.h\"\n#undef BPF_STRUCT_OPS_TYPE\n};",
            "extern struct btf *btf_vmlinux;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"bpf_struct_ops_types.h\"\n#include \"bpf_struct_ops_types.h\"\n#include \"bpf_struct_ops_types.h\"\n#include <linux/mutex.h>\n#include <linux/refcount.h>\n#include <linux/seq_file.h>\n#include <linux/numa.h>\n#include <linux/slab.h>\n#include <linux/filter.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf.h>\n\nstatic struct bpf_struct_ops * const bpf_struct_ops[] = {\n#define BPF_STRUCT_OPS_TYPE(_name)\t\t\t\t\\\n\t[BPF_STRUCT_OPS_TYPE_##_name] = &bpf_##_name,\n#include \"bpf_struct_ops_types.h\"\n#undef BPF_STRUCT_OPS_TYPE\n};\nextern struct btf *btf_vmlinux;\n\nstatic const struct bpf_struct_ops *\nbpf_struct_ops_find_value(u32 value_id)\n{\n\tunsigned int i;\n\n\tif (!value_id || !btf_vmlinux)\n\t\treturn NULL;\n\n\tfor (i = 0; i < ARRAY_SIZE(bpf_struct_ops); i++) {\n\t\tif (bpf_struct_ops[i]->value_id == value_id)\n\t\t\treturn bpf_struct_ops[i];\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EPERM"
          ],
          "line": 573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_capable",
          "args": [],
          "line": 572
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"bpf_struct_ops_types.h\"\n#include \"bpf_struct_ops_types.h\"\n#include \"bpf_struct_ops_types.h\"\n#include <linux/mutex.h>\n#include <linux/refcount.h>\n#include <linux/seq_file.h>\n#include <linux/numa.h>\n#include <linux/slab.h>\n#include <linux/filter.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf.h>\n\nstatic struct bpf_struct_ops * const bpf_struct_ops[] = {\n#define BPF_STRUCT_OPS_TYPE(_name)\t\t\t\t\\\n\t[BPF_STRUCT_OPS_TYPE_##_name] = &bpf_##_name,\n#include \"bpf_struct_ops_types.h\"\n#undef BPF_STRUCT_OPS_TYPE\n};\n\nstatic struct bpf_map *bpf_struct_ops_map_alloc(union bpf_attr *attr)\n{\n\tconst struct bpf_struct_ops *st_ops;\n\tsize_t st_map_size;\n\tstruct bpf_struct_ops_map *st_map;\n\tconst struct btf_type *t, *vt;\n\tstruct bpf_map *map;\n\n\tif (!bpf_capable())\n\t\treturn ERR_PTR(-EPERM);\n\n\tst_ops = bpf_struct_ops_find_value(attr->btf_vmlinux_value_type_id);\n\tif (!st_ops)\n\t\treturn ERR_PTR(-ENOTSUPP);\n\n\tvt = st_ops->value_type;\n\tif (attr->value_size != vt->size)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tt = st_ops->type;\n\n\tst_map_size = sizeof(*st_map) +\n\t\t/* kvalue stores the\n\t\t * struct bpf_struct_ops_tcp_congestions_ops\n\t\t */\n\t\t(vt->size - sizeof(struct bpf_struct_ops_value));\n\n\tst_map = bpf_map_area_alloc(st_map_size, NUMA_NO_NODE);\n\tif (!st_map)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tst_map->st_ops = st_ops;\n\tmap = &st_map->map;\n\n\tst_map->uvalue = bpf_map_area_alloc(vt->size, NUMA_NO_NODE);\n\tst_map->progs =\n\t\tbpf_map_area_alloc(btf_type_vlen(t) * sizeof(struct bpf_prog *),\n\t\t\t\t   NUMA_NO_NODE);\n\tst_map->image = bpf_jit_alloc_exec(PAGE_SIZE);\n\tif (!st_map->uvalue || !st_map->progs || !st_map->image) {\n\t\tbpf_struct_ops_map_free(map);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tmutex_init(&st_map->lock);\n\tset_vm_flush_reset_perms(st_map->image);\n\tbpf_map_init_from_attr(map, attr);\n\n\treturn map;\n}"
  },
  {
    "function_name": "bpf_struct_ops_map_alloc_check",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_struct_ops.c",
    "lines": "556-562",
    "snippet": "static int bpf_struct_ops_map_alloc_check(union bpf_attr *attr)\n{\n\tif (attr->key_size != sizeof(unsigned int) || attr->max_entries != 1 ||\n\t    attr->map_flags || !attr->btf_vmlinux_value_type_id)\n\t\treturn -EINVAL;\n\treturn 0;\n}",
    "includes": [
      "#include \"bpf_struct_ops_types.h\"",
      "#include \"bpf_struct_ops_types.h\"",
      "#include \"bpf_struct_ops_types.h\"",
      "#include <linux/mutex.h>",
      "#include <linux/refcount.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/numa.h>",
      "#include <linux/slab.h>",
      "#include <linux/filter.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"bpf_struct_ops_types.h\"\n#include \"bpf_struct_ops_types.h\"\n#include \"bpf_struct_ops_types.h\"\n#include <linux/mutex.h>\n#include <linux/refcount.h>\n#include <linux/seq_file.h>\n#include <linux/numa.h>\n#include <linux/slab.h>\n#include <linux/filter.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf.h>\n\nstatic int bpf_struct_ops_map_alloc_check(union bpf_attr *attr)\n{\n\tif (attr->key_size != sizeof(unsigned int) || attr->max_entries != 1 ||\n\t    attr->map_flags || !attr->btf_vmlinux_value_type_id)\n\t\treturn -EINVAL;\n\treturn 0;\n}"
  },
  {
    "function_name": "bpf_struct_ops_map_free",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_struct_ops.c",
    "lines": "544-554",
    "snippet": "static void bpf_struct_ops_map_free(struct bpf_map *map)\n{\n\tstruct bpf_struct_ops_map *st_map = (struct bpf_struct_ops_map *)map;\n\n\tif (st_map->progs)\n\t\tbpf_struct_ops_map_put_progs(st_map);\n\tbpf_map_area_free(st_map->progs);\n\tbpf_jit_free_exec(st_map->image);\n\tbpf_map_area_free(st_map->uvalue);\n\tbpf_map_area_free(st_map);\n}",
    "includes": [
      "#include \"bpf_struct_ops_types.h\"",
      "#include \"bpf_struct_ops_types.h\"",
      "#include \"bpf_struct_ops_types.h\"",
      "#include <linux/mutex.h>",
      "#include <linux/refcount.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/numa.h>",
      "#include <linux/slab.h>",
      "#include <linux/filter.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bpf_map_area_free",
          "args": [
            "st_map"
          ],
          "line": 553
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_map_area_free",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "344-347",
          "snippet": "void bpf_map_area_free(void *area)\n{\n\tkvfree(area);\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nvoid bpf_map_area_free(void *area)\n{\n\tkvfree(area);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_jit_free_exec",
          "args": [
            "st_map->image"
          ],
          "line": 551
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_jit_free_exec",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/core.c",
          "lines": "859-862",
          "snippet": "void __weak bpf_jit_free_exec(void *addr)\n{\n\tmodule_memfree(addr);\n}",
          "includes": [
            "#include <linux/bpf_trace.h>",
            "#include <asm/unaligned.h>",
            "#include <asm/barrier.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/log2.h>",
            "#include <linux/extable.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rbtree_latch.h>",
            "#include <linux/objtool.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/random.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/filter.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "const struct bpf_func_proto bpf_map_lookup_elem_proto __weak;",
            "const struct bpf_func_proto bpf_map_update_elem_proto __weak;",
            "const struct bpf_func_proto bpf_map_delete_elem_proto __weak;",
            "const struct bpf_func_proto bpf_map_push_elem_proto __weak;",
            "const struct bpf_func_proto bpf_map_pop_elem_proto __weak;",
            "const struct bpf_func_proto bpf_map_peek_elem_proto __weak;",
            "const struct bpf_func_proto bpf_spin_lock_proto __weak;",
            "const struct bpf_func_proto bpf_spin_unlock_proto __weak;",
            "const struct bpf_func_proto bpf_jiffies64_proto __weak;",
            "const struct bpf_func_proto bpf_get_prandom_u32_proto __weak;",
            "const struct bpf_func_proto bpf_get_smp_processor_id_proto __weak;",
            "const struct bpf_func_proto bpf_get_numa_node_id_proto __weak;",
            "const struct bpf_func_proto bpf_ktime_get_ns_proto __weak;",
            "const struct bpf_func_proto bpf_ktime_get_boot_ns_proto __weak;",
            "const struct bpf_func_proto bpf_ktime_get_coarse_ns_proto __weak;",
            "const struct bpf_func_proto bpf_get_current_pid_tgid_proto __weak;",
            "const struct bpf_func_proto bpf_get_current_uid_gid_proto __weak;",
            "const struct bpf_func_proto bpf_get_current_comm_proto __weak;",
            "const struct bpf_func_proto bpf_get_current_cgroup_id_proto __weak;",
            "const struct bpf_func_proto bpf_get_current_ancestor_cgroup_id_proto __weak;",
            "const struct bpf_func_proto bpf_get_local_storage_proto __weak;",
            "const struct bpf_func_proto bpf_get_ns_current_pid_tgid_proto __weak;",
            "const struct bpf_func_proto bpf_snprintf_btf_proto __weak;",
            "const struct bpf_func_proto bpf_seq_printf_btf_proto __weak;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <asm/barrier.h>\n#include <linux/bpf_verifier.h>\n#include <linux/log2.h>\n#include <linux/extable.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/objtool.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n#include <uapi/linux/btf.h>\n\nconst struct bpf_func_proto bpf_map_lookup_elem_proto __weak;\nconst struct bpf_func_proto bpf_map_update_elem_proto __weak;\nconst struct bpf_func_proto bpf_map_delete_elem_proto __weak;\nconst struct bpf_func_proto bpf_map_push_elem_proto __weak;\nconst struct bpf_func_proto bpf_map_pop_elem_proto __weak;\nconst struct bpf_func_proto bpf_map_peek_elem_proto __weak;\nconst struct bpf_func_proto bpf_spin_lock_proto __weak;\nconst struct bpf_func_proto bpf_spin_unlock_proto __weak;\nconst struct bpf_func_proto bpf_jiffies64_proto __weak;\nconst struct bpf_func_proto bpf_get_prandom_u32_proto __weak;\nconst struct bpf_func_proto bpf_get_smp_processor_id_proto __weak;\nconst struct bpf_func_proto bpf_get_numa_node_id_proto __weak;\nconst struct bpf_func_proto bpf_ktime_get_ns_proto __weak;\nconst struct bpf_func_proto bpf_ktime_get_boot_ns_proto __weak;\nconst struct bpf_func_proto bpf_ktime_get_coarse_ns_proto __weak;\nconst struct bpf_func_proto bpf_get_current_pid_tgid_proto __weak;\nconst struct bpf_func_proto bpf_get_current_uid_gid_proto __weak;\nconst struct bpf_func_proto bpf_get_current_comm_proto __weak;\nconst struct bpf_func_proto bpf_get_current_cgroup_id_proto __weak;\nconst struct bpf_func_proto bpf_get_current_ancestor_cgroup_id_proto __weak;\nconst struct bpf_func_proto bpf_get_local_storage_proto __weak;\nconst struct bpf_func_proto bpf_get_ns_current_pid_tgid_proto __weak;\nconst struct bpf_func_proto bpf_snprintf_btf_proto __weak;\nconst struct bpf_func_proto bpf_seq_printf_btf_proto __weak;\n\nvoid __weak bpf_jit_free_exec(void *addr)\n{\n\tmodule_memfree(addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_struct_ops_map_put_progs",
          "args": [
            "st_map"
          ],
          "line": 549
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_struct_ops_map_put_progs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_struct_ops.c",
          "lines": "279-290",
          "snippet": "static void bpf_struct_ops_map_put_progs(struct bpf_struct_ops_map *st_map)\n{\n\tconst struct btf_type *t = st_map->st_ops->type;\n\tu32 i;\n\n\tfor (i = 0; i < btf_type_vlen(t); i++) {\n\t\tif (st_map->progs[i]) {\n\t\t\tbpf_prog_put(st_map->progs[i]);\n\t\t\tst_map->progs[i] = NULL;\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"bpf_struct_ops_types.h\"",
            "#include \"bpf_struct_ops_types.h\"",
            "#include \"bpf_struct_ops_types.h\"",
            "#include <linux/mutex.h>",
            "#include <linux/refcount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/numa.h>",
            "#include <linux/slab.h>",
            "#include <linux/filter.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bpf_struct_ops_types.h\"\n#include \"bpf_struct_ops_types.h\"\n#include \"bpf_struct_ops_types.h\"\n#include <linux/mutex.h>\n#include <linux/refcount.h>\n#include <linux/seq_file.h>\n#include <linux/numa.h>\n#include <linux/slab.h>\n#include <linux/filter.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf.h>\n\nstatic void bpf_struct_ops_map_put_progs(struct bpf_struct_ops_map *st_map)\n{\n\tconst struct btf_type *t = st_map->st_ops->type;\n\tu32 i;\n\n\tfor (i = 0; i < btf_type_vlen(t); i++) {\n\t\tif (st_map->progs[i]) {\n\t\t\tbpf_prog_put(st_map->progs[i]);\n\t\t\tst_map->progs[i] = NULL;\n\t\t}\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"bpf_struct_ops_types.h\"\n#include \"bpf_struct_ops_types.h\"\n#include \"bpf_struct_ops_types.h\"\n#include <linux/mutex.h>\n#include <linux/refcount.h>\n#include <linux/seq_file.h>\n#include <linux/numa.h>\n#include <linux/slab.h>\n#include <linux/filter.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf.h>\n\nstatic void bpf_struct_ops_map_free(struct bpf_map *map)\n{\n\tstruct bpf_struct_ops_map *st_map = (struct bpf_struct_ops_map *)map;\n\n\tif (st_map->progs)\n\t\tbpf_struct_ops_map_put_progs(st_map);\n\tbpf_map_area_free(st_map->progs);\n\tbpf_jit_free_exec(st_map->image);\n\tbpf_map_area_free(st_map->uvalue);\n\tbpf_map_area_free(st_map);\n}"
  },
  {
    "function_name": "bpf_struct_ops_map_seq_show_elem",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_struct_ops.c",
    "lines": "524-542",
    "snippet": "static void bpf_struct_ops_map_seq_show_elem(struct bpf_map *map, void *key,\n\t\t\t\t\t     struct seq_file *m)\n{\n\tvoid *value;\n\tint err;\n\n\tvalue = kmalloc(map->value_size, GFP_USER | __GFP_NOWARN);\n\tif (!value)\n\t\treturn;\n\n\terr = bpf_struct_ops_map_sys_lookup_elem(map, key, value);\n\tif (!err) {\n\t\tbtf_type_seq_show(btf_vmlinux, map->btf_vmlinux_value_type_id,\n\t\t\t\t  value, m);\n\t\tseq_puts(m, \"\\n\");\n\t}\n\n\tkfree(value);\n}",
    "includes": [
      "#include \"bpf_struct_ops_types.h\"",
      "#include \"bpf_struct_ops_types.h\"",
      "#include \"bpf_struct_ops_types.h\"",
      "#include <linux/mutex.h>",
      "#include <linux/refcount.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/numa.h>",
      "#include <linux/slab.h>",
      "#include <linux/filter.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "extern struct btf *btf_vmlinux;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "value"
          ],
          "line": 541
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "m",
            "\"\\n\""
          ],
          "line": 538
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_puts",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "205-220",
          "snippet": "void trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_type_seq_show",
          "args": [
            "btf_vmlinux",
            "map->btf_vmlinux_value_type_id",
            "value",
            "m"
          ],
          "line": 536
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_seq_show",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "5958-5964",
          "snippet": "void btf_type_seq_show(const struct btf *btf, u32 type_id, void *obj,\n\t\t       struct seq_file *m)\n{\n\t(void) btf_type_seq_show_flags(btf, type_id, obj, m,\n\t\t\t\t       BTF_SHOW_NONAME | BTF_SHOW_COMPACT |\n\t\t\t\t       BTF_SHOW_ZERO | BTF_SHOW_UNSAFE);\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);\n\nvoid btf_type_seq_show(const struct btf *btf, u32 type_id, void *obj,\n\t\t       struct seq_file *m)\n{\n\t(void) btf_type_seq_show_flags(btf, type_id, obj, m,\n\t\t\t\t       BTF_SHOW_NONAME | BTF_SHOW_COMPACT |\n\t\t\t\t       BTF_SHOW_ZERO | BTF_SHOW_UNSAFE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_struct_ops_map_sys_lookup_elem",
          "args": [
            "map",
            "key",
            "value"
          ],
          "line": 534
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_struct_ops_map_sys_lookup_elem",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_struct_ops.c",
          "lines": "245-272",
          "snippet": "int bpf_struct_ops_map_sys_lookup_elem(struct bpf_map *map, void *key,\n\t\t\t\t       void *value)\n{\n\tstruct bpf_struct_ops_map *st_map = (struct bpf_struct_ops_map *)map;\n\tstruct bpf_struct_ops_value *uvalue, *kvalue;\n\tenum bpf_struct_ops_state state;\n\n\tif (unlikely(*(u32 *)key != 0))\n\t\treturn -ENOENT;\n\n\tkvalue = &st_map->kvalue;\n\t/* Pair with smp_store_release() during map_update */\n\tstate = smp_load_acquire(&kvalue->state);\n\tif (state == BPF_STRUCT_OPS_STATE_INIT) {\n\t\tmemset(value, 0, map->value_size);\n\t\treturn 0;\n\t}\n\n\t/* No lock is needed.  state and refcnt do not need\n\t * to be updated together under atomic context.\n\t */\n\tuvalue = (struct bpf_struct_ops_value *)value;\n\tmemcpy(uvalue, st_map->uvalue, map->value_size);\n\tuvalue->state = state;\n\trefcount_set(&uvalue->refcnt, refcount_read(&kvalue->refcnt));\n\n\treturn 0;\n}",
          "includes": [
            "#include \"bpf_struct_ops_types.h\"",
            "#include \"bpf_struct_ops_types.h\"",
            "#include \"bpf_struct_ops_types.h\"",
            "#include <linux/mutex.h>",
            "#include <linux/refcount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/numa.h>",
            "#include <linux/slab.h>",
            "#include <linux/filter.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bpf_struct_ops_types.h\"\n#include \"bpf_struct_ops_types.h\"\n#include \"bpf_struct_ops_types.h\"\n#include <linux/mutex.h>\n#include <linux/refcount.h>\n#include <linux/seq_file.h>\n#include <linux/numa.h>\n#include <linux/slab.h>\n#include <linux/filter.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf.h>\n\nint bpf_struct_ops_map_sys_lookup_elem(struct bpf_map *map, void *key,\n\t\t\t\t       void *value)\n{\n\tstruct bpf_struct_ops_map *st_map = (struct bpf_struct_ops_map *)map;\n\tstruct bpf_struct_ops_value *uvalue, *kvalue;\n\tenum bpf_struct_ops_state state;\n\n\tif (unlikely(*(u32 *)key != 0))\n\t\treturn -ENOENT;\n\n\tkvalue = &st_map->kvalue;\n\t/* Pair with smp_store_release() during map_update */\n\tstate = smp_load_acquire(&kvalue->state);\n\tif (state == BPF_STRUCT_OPS_STATE_INIT) {\n\t\tmemset(value, 0, map->value_size);\n\t\treturn 0;\n\t}\n\n\t/* No lock is needed.  state and refcnt do not need\n\t * to be updated together under atomic context.\n\t */\n\tuvalue = (struct bpf_struct_ops_value *)value;\n\tmemcpy(uvalue, st_map->uvalue, map->value_size);\n\tuvalue->state = state;\n\trefcount_set(&uvalue->refcnt, refcount_read(&kvalue->refcnt));\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "map->value_size",
            "GFP_USER | __GFP_NOWARN"
          ],
          "line": 530
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"bpf_struct_ops_types.h\"\n#include \"bpf_struct_ops_types.h\"\n#include \"bpf_struct_ops_types.h\"\n#include <linux/mutex.h>\n#include <linux/refcount.h>\n#include <linux/seq_file.h>\n#include <linux/numa.h>\n#include <linux/slab.h>\n#include <linux/filter.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf.h>\n\nextern struct btf *btf_vmlinux;\n\nstatic void bpf_struct_ops_map_seq_show_elem(struct bpf_map *map, void *key,\n\t\t\t\t\t     struct seq_file *m)\n{\n\tvoid *value;\n\tint err;\n\n\tvalue = kmalloc(map->value_size, GFP_USER | __GFP_NOWARN);\n\tif (!value)\n\t\treturn;\n\n\terr = bpf_struct_ops_map_sys_lookup_elem(map, key, value);\n\tif (!err) {\n\t\tbtf_type_seq_show(btf_vmlinux, map->btf_vmlinux_value_type_id,\n\t\t\t\t  value, m);\n\t\tseq_puts(m, \"\\n\");\n\t}\n\n\tkfree(value);\n}"
  },
  {
    "function_name": "bpf_struct_ops_map_delete_elem",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_struct_ops.c",
    "lines": "498-522",
    "snippet": "static int bpf_struct_ops_map_delete_elem(struct bpf_map *map, void *key)\n{\n\tenum bpf_struct_ops_state prev_state;\n\tstruct bpf_struct_ops_map *st_map;\n\n\tst_map = (struct bpf_struct_ops_map *)map;\n\tprev_state = cmpxchg(&st_map->kvalue.state,\n\t\t\t     BPF_STRUCT_OPS_STATE_INUSE,\n\t\t\t     BPF_STRUCT_OPS_STATE_TOBEFREE);\n\tswitch (prev_state) {\n\tcase BPF_STRUCT_OPS_STATE_INUSE:\n\t\tst_map->st_ops->unreg(&st_map->kvalue.data);\n\t\tif (refcount_dec_and_test(&st_map->kvalue.refcnt))\n\t\t\tbpf_map_put(map);\n\t\treturn 0;\n\tcase BPF_STRUCT_OPS_STATE_TOBEFREE:\n\t\treturn -EINPROGRESS;\n\tcase BPF_STRUCT_OPS_STATE_INIT:\n\t\treturn -ENOENT;\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t\t/* Should never happen.  Treat it as not found. */\n\t\treturn -ENOENT;\n\t}\n}",
    "includes": [
      "#include \"bpf_struct_ops_types.h\"",
      "#include \"bpf_struct_ops_types.h\"",
      "#include \"bpf_struct_ops_types.h\"",
      "#include <linux/mutex.h>",
      "#include <linux/refcount.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/numa.h>",
      "#include <linux/slab.h>",
      "#include <linux/filter.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "1"
          ],
          "line": 518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_map_put",
          "args": [
            "map"
          ],
          "line": 511
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_map_put_with_uref",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "514-518",
          "snippet": "void bpf_map_put_with_uref(struct bpf_map *map)\n{\n\tbpf_map_put_uref(map);\n\tbpf_map_put(map);\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nvoid bpf_map_put_with_uref(struct bpf_map *map)\n{\n\tbpf_map_put_uref(map);\n\tbpf_map_put(map);\n}"
        }
      },
      {
        "call_info": {
          "callee": "refcount_dec_and_test",
          "args": [
            "&st_map->kvalue.refcnt"
          ],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "st_map->st_ops->unreg",
          "args": [
            "&st_map->kvalue.data"
          ],
          "line": 509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cmpxchg",
          "args": [
            "&st_map->kvalue.state",
            "BPF_STRUCT_OPS_STATE_INUSE",
            "BPF_STRUCT_OPS_STATE_TOBEFREE"
          ],
          "line": 504
        },
        "resolved": true,
        "details": {
          "function_name": "rb_time_cmpxchg",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ring_buffer.c",
          "lines": "737-742",
          "snippet": "static bool rb_time_cmpxchg(rb_time_t *t, u64 expect, u64 set)\n{\n\tu64 val;\n\tval = local64_cmpxchg(&t->time, expect, set);\n\treturn val == expect;\n}",
          "includes": [
            "#include <asm/local64.h>",
            "#include <asm/local.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/list.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/delay.h>",
            "#include <linux/mutex.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>\t/* for self test */",
            "#include <linux/hardirq.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/security.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_recursion.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/local64.h>\n#include <asm/local.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/mutex.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\t/* for self test */\n#include <linux/hardirq.h>\n#include <linux/uaccess.h>\n#include <linux/security.h>\n#include <linux/irq_work.h>\n#include <linux/spinlock.h>\n#include <linux/trace_seq.h>\n#include <linux/sched/clock.h>\n#include <linux/trace_clock.h>\n#include <linux/ring_buffer.h>\n#include <linux/trace_events.h>\n#include <linux/trace_recursion.h>\n\nstatic bool rb_time_cmpxchg(rb_time_t *t, u64 expect, u64 set)\n{\n\tu64 val;\n\tval = local64_cmpxchg(&t->time, expect, set);\n\treturn val == expect;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"bpf_struct_ops_types.h\"\n#include \"bpf_struct_ops_types.h\"\n#include \"bpf_struct_ops_types.h\"\n#include <linux/mutex.h>\n#include <linux/refcount.h>\n#include <linux/seq_file.h>\n#include <linux/numa.h>\n#include <linux/slab.h>\n#include <linux/filter.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf.h>\n\nstatic int bpf_struct_ops_map_delete_elem(struct bpf_map *map, void *key)\n{\n\tenum bpf_struct_ops_state prev_state;\n\tstruct bpf_struct_ops_map *st_map;\n\n\tst_map = (struct bpf_struct_ops_map *)map;\n\tprev_state = cmpxchg(&st_map->kvalue.state,\n\t\t\t     BPF_STRUCT_OPS_STATE_INUSE,\n\t\t\t     BPF_STRUCT_OPS_STATE_TOBEFREE);\n\tswitch (prev_state) {\n\tcase BPF_STRUCT_OPS_STATE_INUSE:\n\t\tst_map->st_ops->unreg(&st_map->kvalue.data);\n\t\tif (refcount_dec_and_test(&st_map->kvalue.refcnt))\n\t\t\tbpf_map_put(map);\n\t\treturn 0;\n\tcase BPF_STRUCT_OPS_STATE_TOBEFREE:\n\t\treturn -EINPROGRESS;\n\tcase BPF_STRUCT_OPS_STATE_INIT:\n\t\treturn -ENOENT;\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t\t/* Should never happen.  Treat it as not found. */\n\t\treturn -ENOENT;\n\t}\n}"
  },
  {
    "function_name": "bpf_struct_ops_map_update_elem",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_struct_ops.c",
    "lines": "332-496",
    "snippet": "static int bpf_struct_ops_map_update_elem(struct bpf_map *map, void *key,\n\t\t\t\t\t  void *value, u64 flags)\n{\n\tstruct bpf_struct_ops_map *st_map = (struct bpf_struct_ops_map *)map;\n\tconst struct bpf_struct_ops *st_ops = st_map->st_ops;\n\tstruct bpf_struct_ops_value *uvalue, *kvalue;\n\tconst struct btf_member *member;\n\tconst struct btf_type *t = st_ops->type;\n\tstruct bpf_tramp_progs *tprogs = NULL;\n\tvoid *udata, *kdata;\n\tint prog_fd, err = 0;\n\tvoid *image, *image_end;\n\tu32 i;\n\n\tif (flags)\n\t\treturn -EINVAL;\n\n\tif (*(u32 *)key != 0)\n\t\treturn -E2BIG;\n\n\terr = check_zero_holes(st_ops->value_type, value);\n\tif (err)\n\t\treturn err;\n\n\tuvalue = (struct bpf_struct_ops_value *)value;\n\terr = check_zero_holes(t, uvalue->data);\n\tif (err)\n\t\treturn err;\n\n\tif (uvalue->state || refcount_read(&uvalue->refcnt))\n\t\treturn -EINVAL;\n\n\ttprogs = kcalloc(BPF_TRAMP_MAX, sizeof(*tprogs), GFP_KERNEL);\n\tif (!tprogs)\n\t\treturn -ENOMEM;\n\n\tuvalue = (struct bpf_struct_ops_value *)st_map->uvalue;\n\tkvalue = (struct bpf_struct_ops_value *)&st_map->kvalue;\n\n\tmutex_lock(&st_map->lock);\n\n\tif (kvalue->state != BPF_STRUCT_OPS_STATE_INIT) {\n\t\terr = -EBUSY;\n\t\tgoto unlock;\n\t}\n\n\tmemcpy(uvalue, value, map->value_size);\n\n\tudata = &uvalue->data;\n\tkdata = &kvalue->data;\n\timage = st_map->image;\n\timage_end = st_map->image + PAGE_SIZE;\n\n\tfor_each_member(i, t, member) {\n\t\tconst struct btf_type *mtype, *ptype;\n\t\tstruct bpf_prog *prog;\n\t\tu32 moff;\n\n\t\tmoff = __btf_member_bit_offset(t, member) / 8;\n\t\tptype = btf_type_resolve_ptr(btf_vmlinux, member->type, NULL);\n\t\tif (ptype == module_type) {\n\t\t\tif (*(void **)(udata + moff))\n\t\t\t\tgoto reset_unlock;\n\t\t\t*(void **)(kdata + moff) = BPF_MODULE_OWNER;\n\t\t\tcontinue;\n\t\t}\n\n\t\terr = st_ops->init_member(t, member, kdata, udata);\n\t\tif (err < 0)\n\t\t\tgoto reset_unlock;\n\n\t\t/* The ->init_member() has handled this member */\n\t\tif (err > 0)\n\t\t\tcontinue;\n\n\t\t/* If st_ops->init_member does not handle it,\n\t\t * we will only handle func ptrs and zero-ed members\n\t\t * here.  Reject everything else.\n\t\t */\n\n\t\t/* All non func ptr member must be 0 */\n\t\tif (!ptype || !btf_type_is_func_proto(ptype)) {\n\t\t\tu32 msize;\n\n\t\t\tmtype = btf_type_by_id(btf_vmlinux, member->type);\n\t\t\tmtype = btf_resolve_size(btf_vmlinux, mtype, &msize);\n\t\t\tif (IS_ERR(mtype)) {\n\t\t\t\terr = PTR_ERR(mtype);\n\t\t\t\tgoto reset_unlock;\n\t\t\t}\n\n\t\t\tif (memchr_inv(udata + moff, 0, msize)) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto reset_unlock;\n\t\t\t}\n\n\t\t\tcontinue;\n\t\t}\n\n\t\tprog_fd = (int)(*(unsigned long *)(udata + moff));\n\t\t/* Similar check as the attr->attach_prog_fd */\n\t\tif (!prog_fd)\n\t\t\tcontinue;\n\n\t\tprog = bpf_prog_get(prog_fd);\n\t\tif (IS_ERR(prog)) {\n\t\t\terr = PTR_ERR(prog);\n\t\t\tgoto reset_unlock;\n\t\t}\n\t\tst_map->progs[i] = prog;\n\n\t\tif (prog->type != BPF_PROG_TYPE_STRUCT_OPS ||\n\t\t    prog->aux->attach_btf_id != st_ops->type_id ||\n\t\t    prog->expected_attach_type != i) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto reset_unlock;\n\t\t}\n\n\t\terr = bpf_struct_ops_prepare_trampoline(tprogs, prog,\n\t\t\t\t\t\t\t&st_ops->func_models[i],\n\t\t\t\t\t\t\timage, image_end);\n\t\tif (err < 0)\n\t\t\tgoto reset_unlock;\n\n\t\t*(void **)(kdata + moff) = image;\n\t\timage += err;\n\n\t\t/* put prog_id to udata */\n\t\t*(unsigned long *)(udata + moff) = prog->aux->id;\n\t}\n\n\trefcount_set(&kvalue->refcnt, 1);\n\tbpf_map_inc(map);\n\n\tset_memory_ro((long)st_map->image, 1);\n\tset_memory_x((long)st_map->image, 1);\n\terr = st_ops->reg(kdata);\n\tif (likely(!err)) {\n\t\t/* Pair with smp_load_acquire() during lookup_elem().\n\t\t * It ensures the above udata updates (e.g. prog->aux->id)\n\t\t * can be seen once BPF_STRUCT_OPS_STATE_INUSE is set.\n\t\t */\n\t\tsmp_store_release(&kvalue->state, BPF_STRUCT_OPS_STATE_INUSE);\n\t\tgoto unlock;\n\t}\n\n\t/* Error during st_ops->reg().  It is very unlikely since\n\t * the above init_member() should have caught it earlier\n\t * before reg().  The only possibility is if there was a race\n\t * in registering the struct_ops (under the same name) to\n\t * a sub-system through different struct_ops's maps.\n\t */\n\tset_memory_nx((long)st_map->image, 1);\n\tset_memory_rw((long)st_map->image, 1);\n\tbpf_map_put(map);\n\nreset_unlock:\n\tbpf_struct_ops_map_put_progs(st_map);\n\tmemset(uvalue, 0, map->value_size);\n\tmemset(kvalue, 0, map->value_size);\nunlock:\n\tkfree(tprogs);\n\tmutex_unlock(&st_map->lock);\n\treturn err;\n}",
    "includes": [
      "#include \"bpf_struct_ops_types.h\"",
      "#include \"bpf_struct_ops_types.h\"",
      "#include \"bpf_struct_ops_types.h\"",
      "#include <linux/mutex.h>",
      "#include <linux/refcount.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/numa.h>",
      "#include <linux/slab.h>",
      "#include <linux/filter.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct bpf_struct_ops * const bpf_struct_ops[] = {\n#define BPF_STRUCT_OPS_TYPE(_name)\t\t\t\t\\\n\t[BPF_STRUCT_OPS_TYPE_##_name] = &bpf_##_name,\n#include \"bpf_struct_ops_types.h\"\n#undef BPF_STRUCT_OPS_TYPE\n};",
      "static const struct btf_type *module_type;",
      "extern struct btf *btf_vmlinux;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&st_map->lock"
          ],
          "line": 494
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "tprogs"
          ],
          "line": 493
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "kvalue",
            "0",
            "map->value_size"
          ],
          "line": 491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "uvalue",
            "0",
            "map->value_size"
          ],
          "line": 490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_struct_ops_map_put_progs",
          "args": [
            "st_map"
          ],
          "line": 489
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_struct_ops_map_put_progs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_struct_ops.c",
          "lines": "279-290",
          "snippet": "static void bpf_struct_ops_map_put_progs(struct bpf_struct_ops_map *st_map)\n{\n\tconst struct btf_type *t = st_map->st_ops->type;\n\tu32 i;\n\n\tfor (i = 0; i < btf_type_vlen(t); i++) {\n\t\tif (st_map->progs[i]) {\n\t\t\tbpf_prog_put(st_map->progs[i]);\n\t\t\tst_map->progs[i] = NULL;\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"bpf_struct_ops_types.h\"",
            "#include \"bpf_struct_ops_types.h\"",
            "#include \"bpf_struct_ops_types.h\"",
            "#include <linux/mutex.h>",
            "#include <linux/refcount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/numa.h>",
            "#include <linux/slab.h>",
            "#include <linux/filter.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bpf_struct_ops_types.h\"\n#include \"bpf_struct_ops_types.h\"\n#include \"bpf_struct_ops_types.h\"\n#include <linux/mutex.h>\n#include <linux/refcount.h>\n#include <linux/seq_file.h>\n#include <linux/numa.h>\n#include <linux/slab.h>\n#include <linux/filter.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf.h>\n\nstatic void bpf_struct_ops_map_put_progs(struct bpf_struct_ops_map *st_map)\n{\n\tconst struct btf_type *t = st_map->st_ops->type;\n\tu32 i;\n\n\tfor (i = 0; i < btf_type_vlen(t); i++) {\n\t\tif (st_map->progs[i]) {\n\t\t\tbpf_prog_put(st_map->progs[i]);\n\t\t\tst_map->progs[i] = NULL;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_map_put",
          "args": [
            "map"
          ],
          "line": 486
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_map_put_with_uref",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "514-518",
          "snippet": "void bpf_map_put_with_uref(struct bpf_map *map)\n{\n\tbpf_map_put_uref(map);\n\tbpf_map_put(map);\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nvoid bpf_map_put_with_uref(struct bpf_map *map)\n{\n\tbpf_map_put_uref(map);\n\tbpf_map_put(map);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_memory_rw",
          "args": [
            "(long)st_map->image",
            "1"
          ],
          "line": 485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_memory_nx",
          "args": [
            "(long)st_map->image",
            "1"
          ],
          "line": 484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_store_release",
          "args": [
            "&kvalue->state",
            "BPF_STRUCT_OPS_STATE_INUSE"
          ],
          "line": 474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!err"
          ],
          "line": 469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "st_ops->reg",
          "args": [
            "kdata"
          ],
          "line": 468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_memory_x",
          "args": [
            "(long)st_map->image",
            "1"
          ],
          "line": 467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_memory_ro",
          "args": [
            "(long)st_map->image",
            "1"
          ],
          "line": 466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_map_inc",
          "args": [
            "map"
          ],
          "line": 464
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_map_inc_not_zero",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "1019-1026",
          "snippet": "struct bpf_map *bpf_map_inc_not_zero(struct bpf_map *map)\n{\n\tspin_lock_bh(&map_idr_lock);\n\tmap = __bpf_map_inc_not_zero(map, false);\n\tspin_unlock_bh(&map_idr_lock);\n\n\treturn map;\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(map_idr_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_SPINLOCK(map_idr_lock);\n\nstruct bpf_map *bpf_map_inc_not_zero(struct bpf_map *map)\n{\n\tspin_lock_bh(&map_idr_lock);\n\tmap = __bpf_map_inc_not_zero(map, false);\n\tspin_unlock_bh(&map_idr_lock);\n\n\treturn map;\n}"
        }
      },
      {
        "call_info": {
          "callee": "refcount_set",
          "args": [
            "&kvalue->refcnt",
            "1"
          ],
          "line": 463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_struct_ops_prepare_trampoline",
          "args": [
            "tprogs",
            "prog",
            "&st_ops->func_models[i]",
            "image",
            "image_end"
          ],
          "line": 450
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_struct_ops_prepare_trampoline",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_struct_ops.c",
          "lines": "318-330",
          "snippet": "int bpf_struct_ops_prepare_trampoline(struct bpf_tramp_progs *tprogs,\n\t\t\t\t      struct bpf_prog *prog,\n\t\t\t\t      const struct btf_func_model *model,\n\t\t\t\t      void *image, void *image_end)\n{\n\tu32 flags;\n\n\ttprogs[BPF_TRAMP_FENTRY].progs[0] = prog;\n\ttprogs[BPF_TRAMP_FENTRY].nr_progs = 1;\n\tflags = model->ret_size > 0 ? BPF_TRAMP_F_RET_FENTRY_RET : 0;\n\treturn arch_prepare_bpf_trampoline(NULL, image, image_end,\n\t\t\t\t\t   model, flags, tprogs, NULL);\n}",
          "includes": [
            "#include \"bpf_struct_ops_types.h\"",
            "#include \"bpf_struct_ops_types.h\"",
            "#include \"bpf_struct_ops_types.h\"",
            "#include <linux/mutex.h>",
            "#include <linux/refcount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/numa.h>",
            "#include <linux/slab.h>",
            "#include <linux/filter.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bpf_struct_ops_types.h\"\n#include \"bpf_struct_ops_types.h\"\n#include \"bpf_struct_ops_types.h\"\n#include <linux/mutex.h>\n#include <linux/refcount.h>\n#include <linux/seq_file.h>\n#include <linux/numa.h>\n#include <linux/slab.h>\n#include <linux/filter.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf.h>\n\nint bpf_struct_ops_prepare_trampoline(struct bpf_tramp_progs *tprogs,\n\t\t\t\t      struct bpf_prog *prog,\n\t\t\t\t      const struct btf_func_model *model,\n\t\t\t\t      void *image, void *image_end)\n{\n\tu32 flags;\n\n\ttprogs[BPF_TRAMP_FENTRY].progs[0] = prog;\n\ttprogs[BPF_TRAMP_FENTRY].nr_progs = 1;\n\tflags = model->ret_size > 0 ? BPF_TRAMP_F_RET_FENTRY_RET : 0;\n\treturn arch_prepare_bpf_trampoline(NULL, image, image_end,\n\t\t\t\t\t   model, flags, tprogs, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "prog"
          ],
          "line": 438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "prog"
          ],
          "line": 437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_prog_get",
          "args": [
            "prog_fd"
          ],
          "line": 436
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_get_fd_by_id",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "3441-3462",
          "snippet": "static int bpf_prog_get_fd_by_id(const union bpf_attr *attr)\n{\n\tstruct bpf_prog *prog;\n\tu32 id = attr->prog_id;\n\tint fd;\n\n\tif (CHECK_ATTR(BPF_PROG_GET_FD_BY_ID))\n\t\treturn -EINVAL;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tprog = bpf_prog_by_id(id);\n\tif (IS_ERR(prog))\n\t\treturn PTR_ERR(prog);\n\n\tfd = bpf_prog_new_fd(prog);\n\tif (fd < 0)\n\t\tbpf_prog_put(prog);\n\n\treturn fd;\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic int bpf_prog_get_fd_by_id(const union bpf_attr *attr)\n{\n\tstruct bpf_prog *prog;\n\tu32 id = attr->prog_id;\n\tint fd;\n\n\tif (CHECK_ATTR(BPF_PROG_GET_FD_BY_ID))\n\t\treturn -EINVAL;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tprog = bpf_prog_by_id(id);\n\tif (IS_ERR(prog))\n\t\treturn PTR_ERR(prog);\n\n\tfd = bpf_prog_new_fd(prog);\n\tif (fd < 0)\n\t\tbpf_prog_put(prog);\n\n\treturn fd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memchr_inv",
          "args": [
            "udata + moff",
            "0",
            "msize"
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "mtype"
          ],
          "line": 419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "mtype"
          ],
          "line": 418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_resolve_size",
          "args": [
            "btf_vmlinux",
            "mtype",
            "&msize"
          ],
          "line": 417
        },
        "resolved": true,
        "details": {
          "function_name": "btf_resolve_size",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "1783-1788",
          "snippet": "const struct btf_type *\nbtf_resolve_size(const struct btf *btf, const struct btf_type *type,\n\t\t u32 *type_size)\n{\n\treturn __btf_resolve_size(btf, type, type_size, NULL, NULL, NULL, NULL);\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nconst struct btf_type *\nbtf_resolve_size(const struct btf *btf, const struct btf_type *type,\n\t\t u32 *type_size)\n{\n\treturn __btf_resolve_size(btf, type, type_size, NULL, NULL, NULL, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_type_by_id",
          "args": [
            "btf_vmlinux",
            "member->type"
          ],
          "line": 416
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_by_id",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "731-740",
          "snippet": "const struct btf_type *btf_type_by_id(const struct btf *btf, u32 type_id)\n{\n\twhile (type_id < btf->start_id)\n\t\tbtf = btf->base_btf;\n\n\ttype_id -= btf->start_id;\n\tif (type_id >= btf->nr_types)\n\t\treturn NULL;\n\treturn btf->types[type_id];\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);\n\nconst struct btf_type *btf_type_by_id(const struct btf *btf, u32 type_id)\n{\n\twhile (type_id < btf->start_id)\n\t\tbtf = btf->base_btf;\n\n\ttype_id -= btf->start_id;\n\tif (type_id >= btf->nr_types)\n\t\treturn NULL;\n\treturn btf->types[type_id];\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_type_is_func_proto",
          "args": [
            "ptype"
          ],
          "line": 413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "st_ops->init_member",
          "args": [
            "t",
            "member",
            "kdata",
            "udata"
          ],
          "line": 399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_type_resolve_ptr",
          "args": [
            "btf_vmlinux",
            "member->type",
            "NULL"
          ],
          "line": 391
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_resolve_ptr",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "525-535",
          "snippet": "const struct btf_type *btf_type_resolve_ptr(const struct btf *btf,\n\t\t\t\t\t    u32 id, u32 *res_id)\n{\n\tconst struct btf_type *t;\n\n\tt = btf_type_skip_modifiers(btf, id, NULL);\n\tif (!btf_type_is_ptr(t))\n\t\treturn NULL;\n\n\treturn btf_type_skip_modifiers(btf, t->type, res_id);\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nconst struct btf_type *btf_type_resolve_ptr(const struct btf *btf,\n\t\t\t\t\t    u32 id, u32 *res_id)\n{\n\tconst struct btf_type *t;\n\n\tt = btf_type_skip_modifiers(btf, id, NULL);\n\tif (!btf_type_is_ptr(t))\n\t\treturn NULL;\n\n\treturn btf_type_skip_modifiers(btf, t->type, res_id);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__btf_member_bit_offset",
          "args": [
            "t",
            "member"
          ],
          "line": 390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_member",
          "args": [
            "i",
            "t",
            "member"
          ],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "uvalue",
            "value",
            "map->value_size"
          ],
          "line": 378
        },
        "resolved": true,
        "details": {
          "function_name": "memcpy_skip",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/internal.h",
          "lines": "180-184",
          "snippet": "static inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/refcount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/refcount.h>\n#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n\nstatic inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&st_map->lock"
          ],
          "line": 371
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kcalloc",
          "args": [
            "BPF_TRAMP_MAX",
            "sizeof(*tprogs)",
            "GFP_KERNEL"
          ],
          "line": 364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "refcount_read",
          "args": [
            "&uvalue->refcnt"
          ],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_zero_holes",
          "args": [
            "t",
            "uvalue->data"
          ],
          "line": 357
        },
        "resolved": true,
        "details": {
          "function_name": "check_zero_holes",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_struct_ops.c",
          "lines": "292-316",
          "snippet": "static int check_zero_holes(const struct btf_type *t, void *data)\n{\n\tconst struct btf_member *member;\n\tu32 i, moff, msize, prev_mend = 0;\n\tconst struct btf_type *mtype;\n\n\tfor_each_member(i, t, member) {\n\t\tmoff = __btf_member_bit_offset(t, member) / 8;\n\t\tif (moff > prev_mend &&\n\t\t    memchr_inv(data + prev_mend, 0, moff - prev_mend))\n\t\t\treturn -EINVAL;\n\n\t\tmtype = btf_type_by_id(btf_vmlinux, member->type);\n\t\tmtype = btf_resolve_size(btf_vmlinux, mtype, &msize);\n\t\tif (IS_ERR(mtype))\n\t\t\treturn PTR_ERR(mtype);\n\t\tprev_mend = moff + msize;\n\t}\n\n\tif (t->size > prev_mend &&\n\t    memchr_inv(data + prev_mend, 0, t->size - prev_mend))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"bpf_struct_ops_types.h\"",
            "#include \"bpf_struct_ops_types.h\"",
            "#include \"bpf_struct_ops_types.h\"",
            "#include <linux/mutex.h>",
            "#include <linux/refcount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/numa.h>",
            "#include <linux/slab.h>",
            "#include <linux/filter.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern struct btf *btf_vmlinux;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"bpf_struct_ops_types.h\"\n#include \"bpf_struct_ops_types.h\"\n#include \"bpf_struct_ops_types.h\"\n#include <linux/mutex.h>\n#include <linux/refcount.h>\n#include <linux/seq_file.h>\n#include <linux/numa.h>\n#include <linux/slab.h>\n#include <linux/filter.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf.h>\n\nextern struct btf *btf_vmlinux;\n\nstatic int check_zero_holes(const struct btf_type *t, void *data)\n{\n\tconst struct btf_member *member;\n\tu32 i, moff, msize, prev_mend = 0;\n\tconst struct btf_type *mtype;\n\n\tfor_each_member(i, t, member) {\n\t\tmoff = __btf_member_bit_offset(t, member) / 8;\n\t\tif (moff > prev_mend &&\n\t\t    memchr_inv(data + prev_mend, 0, moff - prev_mend))\n\t\t\treturn -EINVAL;\n\n\t\tmtype = btf_type_by_id(btf_vmlinux, member->type);\n\t\tmtype = btf_resolve_size(btf_vmlinux, mtype, &msize);\n\t\tif (IS_ERR(mtype))\n\t\t\treturn PTR_ERR(mtype);\n\t\tprev_mend = moff + msize;\n\t}\n\n\tif (t->size > prev_mend &&\n\t    memchr_inv(data + prev_mend, 0, t->size - prev_mend))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"bpf_struct_ops_types.h\"\n#include \"bpf_struct_ops_types.h\"\n#include \"bpf_struct_ops_types.h\"\n#include <linux/mutex.h>\n#include <linux/refcount.h>\n#include <linux/seq_file.h>\n#include <linux/numa.h>\n#include <linux/slab.h>\n#include <linux/filter.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf.h>\n\nstatic struct bpf_struct_ops * const bpf_struct_ops[] = {\n#define BPF_STRUCT_OPS_TYPE(_name)\t\t\t\t\\\n\t[BPF_STRUCT_OPS_TYPE_##_name] = &bpf_##_name,\n#include \"bpf_struct_ops_types.h\"\n#undef BPF_STRUCT_OPS_TYPE\n};\nstatic const struct btf_type *module_type;\nextern struct btf *btf_vmlinux;\n\nstatic int bpf_struct_ops_map_update_elem(struct bpf_map *map, void *key,\n\t\t\t\t\t  void *value, u64 flags)\n{\n\tstruct bpf_struct_ops_map *st_map = (struct bpf_struct_ops_map *)map;\n\tconst struct bpf_struct_ops *st_ops = st_map->st_ops;\n\tstruct bpf_struct_ops_value *uvalue, *kvalue;\n\tconst struct btf_member *member;\n\tconst struct btf_type *t = st_ops->type;\n\tstruct bpf_tramp_progs *tprogs = NULL;\n\tvoid *udata, *kdata;\n\tint prog_fd, err = 0;\n\tvoid *image, *image_end;\n\tu32 i;\n\n\tif (flags)\n\t\treturn -EINVAL;\n\n\tif (*(u32 *)key != 0)\n\t\treturn -E2BIG;\n\n\terr = check_zero_holes(st_ops->value_type, value);\n\tif (err)\n\t\treturn err;\n\n\tuvalue = (struct bpf_struct_ops_value *)value;\n\terr = check_zero_holes(t, uvalue->data);\n\tif (err)\n\t\treturn err;\n\n\tif (uvalue->state || refcount_read(&uvalue->refcnt))\n\t\treturn -EINVAL;\n\n\ttprogs = kcalloc(BPF_TRAMP_MAX, sizeof(*tprogs), GFP_KERNEL);\n\tif (!tprogs)\n\t\treturn -ENOMEM;\n\n\tuvalue = (struct bpf_struct_ops_value *)st_map->uvalue;\n\tkvalue = (struct bpf_struct_ops_value *)&st_map->kvalue;\n\n\tmutex_lock(&st_map->lock);\n\n\tif (kvalue->state != BPF_STRUCT_OPS_STATE_INIT) {\n\t\terr = -EBUSY;\n\t\tgoto unlock;\n\t}\n\n\tmemcpy(uvalue, value, map->value_size);\n\n\tudata = &uvalue->data;\n\tkdata = &kvalue->data;\n\timage = st_map->image;\n\timage_end = st_map->image + PAGE_SIZE;\n\n\tfor_each_member(i, t, member) {\n\t\tconst struct btf_type *mtype, *ptype;\n\t\tstruct bpf_prog *prog;\n\t\tu32 moff;\n\n\t\tmoff = __btf_member_bit_offset(t, member) / 8;\n\t\tptype = btf_type_resolve_ptr(btf_vmlinux, member->type, NULL);\n\t\tif (ptype == module_type) {\n\t\t\tif (*(void **)(udata + moff))\n\t\t\t\tgoto reset_unlock;\n\t\t\t*(void **)(kdata + moff) = BPF_MODULE_OWNER;\n\t\t\tcontinue;\n\t\t}\n\n\t\terr = st_ops->init_member(t, member, kdata, udata);\n\t\tif (err < 0)\n\t\t\tgoto reset_unlock;\n\n\t\t/* The ->init_member() has handled this member */\n\t\tif (err > 0)\n\t\t\tcontinue;\n\n\t\t/* If st_ops->init_member does not handle it,\n\t\t * we will only handle func ptrs and zero-ed members\n\t\t * here.  Reject everything else.\n\t\t */\n\n\t\t/* All non func ptr member must be 0 */\n\t\tif (!ptype || !btf_type_is_func_proto(ptype)) {\n\t\t\tu32 msize;\n\n\t\t\tmtype = btf_type_by_id(btf_vmlinux, member->type);\n\t\t\tmtype = btf_resolve_size(btf_vmlinux, mtype, &msize);\n\t\t\tif (IS_ERR(mtype)) {\n\t\t\t\terr = PTR_ERR(mtype);\n\t\t\t\tgoto reset_unlock;\n\t\t\t}\n\n\t\t\tif (memchr_inv(udata + moff, 0, msize)) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto reset_unlock;\n\t\t\t}\n\n\t\t\tcontinue;\n\t\t}\n\n\t\tprog_fd = (int)(*(unsigned long *)(udata + moff));\n\t\t/* Similar check as the attr->attach_prog_fd */\n\t\tif (!prog_fd)\n\t\t\tcontinue;\n\n\t\tprog = bpf_prog_get(prog_fd);\n\t\tif (IS_ERR(prog)) {\n\t\t\terr = PTR_ERR(prog);\n\t\t\tgoto reset_unlock;\n\t\t}\n\t\tst_map->progs[i] = prog;\n\n\t\tif (prog->type != BPF_PROG_TYPE_STRUCT_OPS ||\n\t\t    prog->aux->attach_btf_id != st_ops->type_id ||\n\t\t    prog->expected_attach_type != i) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto reset_unlock;\n\t\t}\n\n\t\terr = bpf_struct_ops_prepare_trampoline(tprogs, prog,\n\t\t\t\t\t\t\t&st_ops->func_models[i],\n\t\t\t\t\t\t\timage, image_end);\n\t\tif (err < 0)\n\t\t\tgoto reset_unlock;\n\n\t\t*(void **)(kdata + moff) = image;\n\t\timage += err;\n\n\t\t/* put prog_id to udata */\n\t\t*(unsigned long *)(udata + moff) = prog->aux->id;\n\t}\n\n\trefcount_set(&kvalue->refcnt, 1);\n\tbpf_map_inc(map);\n\n\tset_memory_ro((long)st_map->image, 1);\n\tset_memory_x((long)st_map->image, 1);\n\terr = st_ops->reg(kdata);\n\tif (likely(!err)) {\n\t\t/* Pair with smp_load_acquire() during lookup_elem().\n\t\t * It ensures the above udata updates (e.g. prog->aux->id)\n\t\t * can be seen once BPF_STRUCT_OPS_STATE_INUSE is set.\n\t\t */\n\t\tsmp_store_release(&kvalue->state, BPF_STRUCT_OPS_STATE_INUSE);\n\t\tgoto unlock;\n\t}\n\n\t/* Error during st_ops->reg().  It is very unlikely since\n\t * the above init_member() should have caught it earlier\n\t * before reg().  The only possibility is if there was a race\n\t * in registering the struct_ops (under the same name) to\n\t * a sub-system through different struct_ops's maps.\n\t */\n\tset_memory_nx((long)st_map->image, 1);\n\tset_memory_rw((long)st_map->image, 1);\n\tbpf_map_put(map);\n\nreset_unlock:\n\tbpf_struct_ops_map_put_progs(st_map);\n\tmemset(uvalue, 0, map->value_size);\n\tmemset(kvalue, 0, map->value_size);\nunlock:\n\tkfree(tprogs);\n\tmutex_unlock(&st_map->lock);\n\treturn err;\n}"
  },
  {
    "function_name": "bpf_struct_ops_prepare_trampoline",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_struct_ops.c",
    "lines": "318-330",
    "snippet": "int bpf_struct_ops_prepare_trampoline(struct bpf_tramp_progs *tprogs,\n\t\t\t\t      struct bpf_prog *prog,\n\t\t\t\t      const struct btf_func_model *model,\n\t\t\t\t      void *image, void *image_end)\n{\n\tu32 flags;\n\n\ttprogs[BPF_TRAMP_FENTRY].progs[0] = prog;\n\ttprogs[BPF_TRAMP_FENTRY].nr_progs = 1;\n\tflags = model->ret_size > 0 ? BPF_TRAMP_F_RET_FENTRY_RET : 0;\n\treturn arch_prepare_bpf_trampoline(NULL, image, image_end,\n\t\t\t\t\t   model, flags, tprogs, NULL);\n}",
    "includes": [
      "#include \"bpf_struct_ops_types.h\"",
      "#include \"bpf_struct_ops_types.h\"",
      "#include \"bpf_struct_ops_types.h\"",
      "#include <linux/mutex.h>",
      "#include <linux/refcount.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/numa.h>",
      "#include <linux/slab.h>",
      "#include <linux/filter.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "arch_prepare_bpf_trampoline",
          "args": [
            "NULL",
            "image",
            "image_end",
            "model",
            "flags",
            "tprogs",
            "NULL"
          ],
          "line": 328
        },
        "resolved": true,
        "details": {
          "function_name": "arch_prepare_bpf_trampoline",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/trampoline.c",
          "lines": "646-653",
          "snippet": "int __weak\narch_prepare_bpf_trampoline(struct bpf_tramp_image *tr, void *image, void *image_end,\n\t\t\t    const struct btf_func_model *m, u32 flags,\n\t\t\t    struct bpf_tramp_progs *tprogs,\n\t\t\t    void *orig_call)\n{\n\treturn -ENOTSUPP;\n}",
          "includes": [
            "#include <linux/static_call.h>",
            "#include <linux/module.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/btf.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/rbtree_latch.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf.h>",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/static_call.h>\n#include <linux/module.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/rbtree_latch.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/hash.h>\n\nint __weak\narch_prepare_bpf_trampoline(struct bpf_tramp_image *tr, void *image, void *image_end,\n\t\t\t    const struct btf_func_model *m, u32 flags,\n\t\t\t    struct bpf_tramp_progs *tprogs,\n\t\t\t    void *orig_call)\n{\n\treturn -ENOTSUPP;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"bpf_struct_ops_types.h\"\n#include \"bpf_struct_ops_types.h\"\n#include \"bpf_struct_ops_types.h\"\n#include <linux/mutex.h>\n#include <linux/refcount.h>\n#include <linux/seq_file.h>\n#include <linux/numa.h>\n#include <linux/slab.h>\n#include <linux/filter.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf.h>\n\nint bpf_struct_ops_prepare_trampoline(struct bpf_tramp_progs *tprogs,\n\t\t\t\t      struct bpf_prog *prog,\n\t\t\t\t      const struct btf_func_model *model,\n\t\t\t\t      void *image, void *image_end)\n{\n\tu32 flags;\n\n\ttprogs[BPF_TRAMP_FENTRY].progs[0] = prog;\n\ttprogs[BPF_TRAMP_FENTRY].nr_progs = 1;\n\tflags = model->ret_size > 0 ? BPF_TRAMP_F_RET_FENTRY_RET : 0;\n\treturn arch_prepare_bpf_trampoline(NULL, image, image_end,\n\t\t\t\t\t   model, flags, tprogs, NULL);\n}"
  },
  {
    "function_name": "check_zero_holes",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_struct_ops.c",
    "lines": "292-316",
    "snippet": "static int check_zero_holes(const struct btf_type *t, void *data)\n{\n\tconst struct btf_member *member;\n\tu32 i, moff, msize, prev_mend = 0;\n\tconst struct btf_type *mtype;\n\n\tfor_each_member(i, t, member) {\n\t\tmoff = __btf_member_bit_offset(t, member) / 8;\n\t\tif (moff > prev_mend &&\n\t\t    memchr_inv(data + prev_mend, 0, moff - prev_mend))\n\t\t\treturn -EINVAL;\n\n\t\tmtype = btf_type_by_id(btf_vmlinux, member->type);\n\t\tmtype = btf_resolve_size(btf_vmlinux, mtype, &msize);\n\t\tif (IS_ERR(mtype))\n\t\t\treturn PTR_ERR(mtype);\n\t\tprev_mend = moff + msize;\n\t}\n\n\tif (t->size > prev_mend &&\n\t    memchr_inv(data + prev_mend, 0, t->size - prev_mend))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"bpf_struct_ops_types.h\"",
      "#include \"bpf_struct_ops_types.h\"",
      "#include \"bpf_struct_ops_types.h\"",
      "#include <linux/mutex.h>",
      "#include <linux/refcount.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/numa.h>",
      "#include <linux/slab.h>",
      "#include <linux/filter.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "extern struct btf *btf_vmlinux;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memchr_inv",
          "args": [
            "data + prev_mend",
            "0",
            "t->size - prev_mend"
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "mtype"
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "mtype"
          ],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_resolve_size",
          "args": [
            "btf_vmlinux",
            "mtype",
            "&msize"
          ],
          "line": 305
        },
        "resolved": true,
        "details": {
          "function_name": "btf_resolve_size",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "1783-1788",
          "snippet": "const struct btf_type *\nbtf_resolve_size(const struct btf *btf, const struct btf_type *type,\n\t\t u32 *type_size)\n{\n\treturn __btf_resolve_size(btf, type, type_size, NULL, NULL, NULL, NULL);\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nconst struct btf_type *\nbtf_resolve_size(const struct btf *btf, const struct btf_type *type,\n\t\t u32 *type_size)\n{\n\treturn __btf_resolve_size(btf, type, type_size, NULL, NULL, NULL, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_type_by_id",
          "args": [
            "btf_vmlinux",
            "member->type"
          ],
          "line": 304
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_by_id",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "731-740",
          "snippet": "const struct btf_type *btf_type_by_id(const struct btf *btf, u32 type_id)\n{\n\twhile (type_id < btf->start_id)\n\t\tbtf = btf->base_btf;\n\n\ttype_id -= btf->start_id;\n\tif (type_id >= btf->nr_types)\n\t\treturn NULL;\n\treturn btf->types[type_id];\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);\n\nconst struct btf_type *btf_type_by_id(const struct btf *btf, u32 type_id)\n{\n\twhile (type_id < btf->start_id)\n\t\tbtf = btf->base_btf;\n\n\ttype_id -= btf->start_id;\n\tif (type_id >= btf->nr_types)\n\t\treturn NULL;\n\treturn btf->types[type_id];\n}"
        }
      },
      {
        "call_info": {
          "callee": "memchr_inv",
          "args": [
            "data + prev_mend",
            "0",
            "moff - prev_mend"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__btf_member_bit_offset",
          "args": [
            "t",
            "member"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_member",
          "args": [
            "i",
            "t",
            "member"
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"bpf_struct_ops_types.h\"\n#include \"bpf_struct_ops_types.h\"\n#include \"bpf_struct_ops_types.h\"\n#include <linux/mutex.h>\n#include <linux/refcount.h>\n#include <linux/seq_file.h>\n#include <linux/numa.h>\n#include <linux/slab.h>\n#include <linux/filter.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf.h>\n\nextern struct btf *btf_vmlinux;\n\nstatic int check_zero_holes(const struct btf_type *t, void *data)\n{\n\tconst struct btf_member *member;\n\tu32 i, moff, msize, prev_mend = 0;\n\tconst struct btf_type *mtype;\n\n\tfor_each_member(i, t, member) {\n\t\tmoff = __btf_member_bit_offset(t, member) / 8;\n\t\tif (moff > prev_mend &&\n\t\t    memchr_inv(data + prev_mend, 0, moff - prev_mend))\n\t\t\treturn -EINVAL;\n\n\t\tmtype = btf_type_by_id(btf_vmlinux, member->type);\n\t\tmtype = btf_resolve_size(btf_vmlinux, mtype, &msize);\n\t\tif (IS_ERR(mtype))\n\t\t\treturn PTR_ERR(mtype);\n\t\tprev_mend = moff + msize;\n\t}\n\n\tif (t->size > prev_mend &&\n\t    memchr_inv(data + prev_mend, 0, t->size - prev_mend))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "bpf_struct_ops_map_put_progs",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_struct_ops.c",
    "lines": "279-290",
    "snippet": "static void bpf_struct_ops_map_put_progs(struct bpf_struct_ops_map *st_map)\n{\n\tconst struct btf_type *t = st_map->st_ops->type;\n\tu32 i;\n\n\tfor (i = 0; i < btf_type_vlen(t); i++) {\n\t\tif (st_map->progs[i]) {\n\t\t\tbpf_prog_put(st_map->progs[i]);\n\t\t\tst_map->progs[i] = NULL;\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"bpf_struct_ops_types.h\"",
      "#include \"bpf_struct_ops_types.h\"",
      "#include \"bpf_struct_ops_types.h\"",
      "#include <linux/mutex.h>",
      "#include <linux/refcount.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/numa.h>",
      "#include <linux/slab.h>",
      "#include <linux/filter.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bpf_prog_put",
          "args": [
            "st_map->progs[i]"
          ],
          "line": 286
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_put",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "1828-1831",
          "snippet": "void bpf_prog_put(struct bpf_prog *prog)\n{\n\t__bpf_prog_put(prog, true);\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nvoid bpf_prog_put(struct bpf_prog *prog)\n{\n\t__bpf_prog_put(prog, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_type_vlen",
          "args": [
            "t"
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"bpf_struct_ops_types.h\"\n#include \"bpf_struct_ops_types.h\"\n#include \"bpf_struct_ops_types.h\"\n#include <linux/mutex.h>\n#include <linux/refcount.h>\n#include <linux/seq_file.h>\n#include <linux/numa.h>\n#include <linux/slab.h>\n#include <linux/filter.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf.h>\n\nstatic void bpf_struct_ops_map_put_progs(struct bpf_struct_ops_map *st_map)\n{\n\tconst struct btf_type *t = st_map->st_ops->type;\n\tu32 i;\n\n\tfor (i = 0; i < btf_type_vlen(t); i++) {\n\t\tif (st_map->progs[i]) {\n\t\t\tbpf_prog_put(st_map->progs[i]);\n\t\t\tst_map->progs[i] = NULL;\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "bpf_struct_ops_map_lookup_elem",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_struct_ops.c",
    "lines": "274-277",
    "snippet": "static void *bpf_struct_ops_map_lookup_elem(struct bpf_map *map, void *key)\n{\n\treturn ERR_PTR(-EINVAL);\n}",
    "includes": [
      "#include \"bpf_struct_ops_types.h\"",
      "#include \"bpf_struct_ops_types.h\"",
      "#include \"bpf_struct_ops_types.h\"",
      "#include <linux/mutex.h>",
      "#include <linux/refcount.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/numa.h>",
      "#include <linux/slab.h>",
      "#include <linux/filter.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EINVAL"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"bpf_struct_ops_types.h\"\n#include \"bpf_struct_ops_types.h\"\n#include \"bpf_struct_ops_types.h\"\n#include <linux/mutex.h>\n#include <linux/refcount.h>\n#include <linux/seq_file.h>\n#include <linux/numa.h>\n#include <linux/slab.h>\n#include <linux/filter.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf.h>\n\nstatic void *bpf_struct_ops_map_lookup_elem(struct bpf_map *map, void *key)\n{\n\treturn ERR_PTR(-EINVAL);\n}"
  },
  {
    "function_name": "bpf_struct_ops_map_sys_lookup_elem",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_struct_ops.c",
    "lines": "245-272",
    "snippet": "int bpf_struct_ops_map_sys_lookup_elem(struct bpf_map *map, void *key,\n\t\t\t\t       void *value)\n{\n\tstruct bpf_struct_ops_map *st_map = (struct bpf_struct_ops_map *)map;\n\tstruct bpf_struct_ops_value *uvalue, *kvalue;\n\tenum bpf_struct_ops_state state;\n\n\tif (unlikely(*(u32 *)key != 0))\n\t\treturn -ENOENT;\n\n\tkvalue = &st_map->kvalue;\n\t/* Pair with smp_store_release() during map_update */\n\tstate = smp_load_acquire(&kvalue->state);\n\tif (state == BPF_STRUCT_OPS_STATE_INIT) {\n\t\tmemset(value, 0, map->value_size);\n\t\treturn 0;\n\t}\n\n\t/* No lock is needed.  state and refcnt do not need\n\t * to be updated together under atomic context.\n\t */\n\tuvalue = (struct bpf_struct_ops_value *)value;\n\tmemcpy(uvalue, st_map->uvalue, map->value_size);\n\tuvalue->state = state;\n\trefcount_set(&uvalue->refcnt, refcount_read(&kvalue->refcnt));\n\n\treturn 0;\n}",
    "includes": [
      "#include \"bpf_struct_ops_types.h\"",
      "#include \"bpf_struct_ops_types.h\"",
      "#include \"bpf_struct_ops_types.h\"",
      "#include <linux/mutex.h>",
      "#include <linux/refcount.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/numa.h>",
      "#include <linux/slab.h>",
      "#include <linux/filter.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "refcount_set",
          "args": [
            "&uvalue->refcnt",
            "refcount_read(&kvalue->refcnt)"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "refcount_read",
          "args": [
            "&kvalue->refcnt"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "uvalue",
            "st_map->uvalue",
            "map->value_size"
          ],
          "line": 267
        },
        "resolved": true,
        "details": {
          "function_name": "memcpy_skip",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/internal.h",
          "lines": "180-184",
          "snippet": "static inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/refcount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/refcount.h>\n#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n\nstatic inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "value",
            "0",
            "map->value_size"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_load_acquire",
          "args": [
            "&kvalue->state"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "*(u32 *)key != 0"
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"bpf_struct_ops_types.h\"\n#include \"bpf_struct_ops_types.h\"\n#include \"bpf_struct_ops_types.h\"\n#include <linux/mutex.h>\n#include <linux/refcount.h>\n#include <linux/seq_file.h>\n#include <linux/numa.h>\n#include <linux/slab.h>\n#include <linux/filter.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf.h>\n\nint bpf_struct_ops_map_sys_lookup_elem(struct bpf_map *map, void *key,\n\t\t\t\t       void *value)\n{\n\tstruct bpf_struct_ops_map *st_map = (struct bpf_struct_ops_map *)map;\n\tstruct bpf_struct_ops_value *uvalue, *kvalue;\n\tenum bpf_struct_ops_state state;\n\n\tif (unlikely(*(u32 *)key != 0))\n\t\treturn -ENOENT;\n\n\tkvalue = &st_map->kvalue;\n\t/* Pair with smp_store_release() during map_update */\n\tstate = smp_load_acquire(&kvalue->state);\n\tif (state == BPF_STRUCT_OPS_STATE_INIT) {\n\t\tmemset(value, 0, map->value_size);\n\t\treturn 0;\n\t}\n\n\t/* No lock is needed.  state and refcnt do not need\n\t * to be updated together under atomic context.\n\t */\n\tuvalue = (struct bpf_struct_ops_value *)value;\n\tmemcpy(uvalue, st_map->uvalue, map->value_size);\n\tuvalue->state = state;\n\trefcount_set(&uvalue->refcnt, refcount_read(&kvalue->refcnt));\n\n\treturn 0;\n}"
  },
  {
    "function_name": "bpf_struct_ops_map_get_next_key",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_struct_ops.c",
    "lines": "235-243",
    "snippet": "static int bpf_struct_ops_map_get_next_key(struct bpf_map *map, void *key,\n\t\t\t\t\t   void *next_key)\n{\n\tif (key && *(u32 *)key == 0)\n\t\treturn -ENOENT;\n\n\t*(u32 *)next_key = 0;\n\treturn 0;\n}",
    "includes": [
      "#include \"bpf_struct_ops_types.h\"",
      "#include \"bpf_struct_ops_types.h\"",
      "#include \"bpf_struct_ops_types.h\"",
      "#include <linux/mutex.h>",
      "#include <linux/refcount.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/numa.h>",
      "#include <linux/slab.h>",
      "#include <linux/filter.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"bpf_struct_ops_types.h\"\n#include \"bpf_struct_ops_types.h\"\n#include \"bpf_struct_ops_types.h\"\n#include <linux/mutex.h>\n#include <linux/refcount.h>\n#include <linux/seq_file.h>\n#include <linux/numa.h>\n#include <linux/slab.h>\n#include <linux/filter.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf.h>\n\nstatic int bpf_struct_ops_map_get_next_key(struct bpf_map *map, void *key,\n\t\t\t\t\t   void *next_key)\n{\n\tif (key && *(u32 *)key == 0)\n\t\treturn -ENOENT;\n\n\t*(u32 *)next_key = 0;\n\treturn 0;\n}"
  },
  {
    "function_name": "bpf_struct_ops_find",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_struct_ops.c",
    "lines": "220-233",
    "snippet": "const struct bpf_struct_ops *bpf_struct_ops_find(u32 type_id)\n{\n\tunsigned int i;\n\n\tif (!type_id || !btf_vmlinux)\n\t\treturn NULL;\n\n\tfor (i = 0; i < ARRAY_SIZE(bpf_struct_ops); i++) {\n\t\tif (bpf_struct_ops[i]->type_id == type_id)\n\t\t\treturn bpf_struct_ops[i];\n\t}\n\n\treturn NULL;\n}",
    "includes": [
      "#include \"bpf_struct_ops_types.h\"",
      "#include \"bpf_struct_ops_types.h\"",
      "#include \"bpf_struct_ops_types.h\"",
      "#include <linux/mutex.h>",
      "#include <linux/refcount.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/numa.h>",
      "#include <linux/slab.h>",
      "#include <linux/filter.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct bpf_struct_ops * const bpf_struct_ops[] = {\n#define BPF_STRUCT_OPS_TYPE(_name)\t\t\t\t\\\n\t[BPF_STRUCT_OPS_TYPE_##_name] = &bpf_##_name,\n#include \"bpf_struct_ops_types.h\"\n#undef BPF_STRUCT_OPS_TYPE\n};",
      "extern struct btf *btf_vmlinux;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "bpf_struct_ops"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"bpf_struct_ops_types.h\"\n#include \"bpf_struct_ops_types.h\"\n#include \"bpf_struct_ops_types.h\"\n#include <linux/mutex.h>\n#include <linux/refcount.h>\n#include <linux/seq_file.h>\n#include <linux/numa.h>\n#include <linux/slab.h>\n#include <linux/filter.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf.h>\n\nstatic struct bpf_struct_ops * const bpf_struct_ops[] = {\n#define BPF_STRUCT_OPS_TYPE(_name)\t\t\t\t\\\n\t[BPF_STRUCT_OPS_TYPE_##_name] = &bpf_##_name,\n#include \"bpf_struct_ops_types.h\"\n#undef BPF_STRUCT_OPS_TYPE\n};\nextern struct btf *btf_vmlinux;\n\nconst struct bpf_struct_ops *bpf_struct_ops_find(u32 type_id)\n{\n\tunsigned int i;\n\n\tif (!type_id || !btf_vmlinux)\n\t\treturn NULL;\n\n\tfor (i = 0; i < ARRAY_SIZE(bpf_struct_ops); i++) {\n\t\tif (bpf_struct_ops[i]->type_id == type_id)\n\t\t\treturn bpf_struct_ops[i];\n\t}\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "bpf_struct_ops_find_value",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_struct_ops.c",
    "lines": "204-218",
    "snippet": "static const struct bpf_struct_ops *\nbpf_struct_ops_find_value(u32 value_id)\n{\n\tunsigned int i;\n\n\tif (!value_id || !btf_vmlinux)\n\t\treturn NULL;\n\n\tfor (i = 0; i < ARRAY_SIZE(bpf_struct_ops); i++) {\n\t\tif (bpf_struct_ops[i]->value_id == value_id)\n\t\t\treturn bpf_struct_ops[i];\n\t}\n\n\treturn NULL;\n}",
    "includes": [
      "#include \"bpf_struct_ops_types.h\"",
      "#include \"bpf_struct_ops_types.h\"",
      "#include \"bpf_struct_ops_types.h\"",
      "#include <linux/mutex.h>",
      "#include <linux/refcount.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/numa.h>",
      "#include <linux/slab.h>",
      "#include <linux/filter.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct bpf_struct_ops * const bpf_struct_ops[] = {\n#define BPF_STRUCT_OPS_TYPE(_name)\t\t\t\t\\\n\t[BPF_STRUCT_OPS_TYPE_##_name] = &bpf_##_name,\n#include \"bpf_struct_ops_types.h\"\n#undef BPF_STRUCT_OPS_TYPE\n};",
      "extern struct btf *btf_vmlinux;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "bpf_struct_ops"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"bpf_struct_ops_types.h\"\n#include \"bpf_struct_ops_types.h\"\n#include \"bpf_struct_ops_types.h\"\n#include <linux/mutex.h>\n#include <linux/refcount.h>\n#include <linux/seq_file.h>\n#include <linux/numa.h>\n#include <linux/slab.h>\n#include <linux/filter.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf.h>\n\nstatic struct bpf_struct_ops * const bpf_struct_ops[] = {\n#define BPF_STRUCT_OPS_TYPE(_name)\t\t\t\t\\\n\t[BPF_STRUCT_OPS_TYPE_##_name] = &bpf_##_name,\n#include \"bpf_struct_ops_types.h\"\n#undef BPF_STRUCT_OPS_TYPE\n};\nextern struct btf *btf_vmlinux;\n\nstatic const struct bpf_struct_ops *\nbpf_struct_ops_find_value(u32 value_id)\n{\n\tunsigned int i;\n\n\tif (!value_id || !btf_vmlinux)\n\t\treturn NULL;\n\n\tfor (i = 0; i < ARRAY_SIZE(bpf_struct_ops); i++) {\n\t\tif (bpf_struct_ops[i]->value_id == value_id)\n\t\t\treturn bpf_struct_ops[i];\n\t}\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "bpf_struct_ops_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_struct_ops.c",
    "lines": "103-200",
    "snippet": "void bpf_struct_ops_init(struct btf *btf, struct bpf_verifier_log *log)\n{\n\ts32 type_id, value_id, module_id;\n\tconst struct btf_member *member;\n\tstruct bpf_struct_ops *st_ops;\n\tconst struct btf_type *t;\n\tchar value_name[128];\n\tconst char *mname;\n\tu32 i, j;\n\n\t/* Ensure BTF type is emitted for \"struct bpf_struct_ops_##_name\" */\n#define BPF_STRUCT_OPS_TYPE(_name) BTF_TYPE_EMIT(struct bpf_struct_ops_##_name);\n#include \"bpf_struct_ops_types.h\"\n#undef BPF_STRUCT_OPS_TYPE\n\n\tmodule_id = btf_find_by_name_kind(btf, \"module\", BTF_KIND_STRUCT);\n\tif (module_id < 0) {\n\t\tpr_warn(\"Cannot find struct module in btf_vmlinux\\n\");\n\t\treturn;\n\t}\n\tmodule_type = btf_type_by_id(btf, module_id);\n\n\tfor (i = 0; i < ARRAY_SIZE(bpf_struct_ops); i++) {\n\t\tst_ops = bpf_struct_ops[i];\n\n\t\tif (strlen(st_ops->name) + VALUE_PREFIX_LEN >=\n\t\t    sizeof(value_name)) {\n\t\t\tpr_warn(\"struct_ops name %s is too long\\n\",\n\t\t\t\tst_ops->name);\n\t\t\tcontinue;\n\t\t}\n\t\tsprintf(value_name, \"%s%s\", VALUE_PREFIX, st_ops->name);\n\n\t\tvalue_id = btf_find_by_name_kind(btf, value_name,\n\t\t\t\t\t\t BTF_KIND_STRUCT);\n\t\tif (value_id < 0) {\n\t\t\tpr_warn(\"Cannot find struct %s in btf_vmlinux\\n\",\n\t\t\t\tvalue_name);\n\t\t\tcontinue;\n\t\t}\n\n\t\ttype_id = btf_find_by_name_kind(btf, st_ops->name,\n\t\t\t\t\t\tBTF_KIND_STRUCT);\n\t\tif (type_id < 0) {\n\t\t\tpr_warn(\"Cannot find struct %s in btf_vmlinux\\n\",\n\t\t\t\tst_ops->name);\n\t\t\tcontinue;\n\t\t}\n\t\tt = btf_type_by_id(btf, type_id);\n\t\tif (btf_type_vlen(t) > BPF_STRUCT_OPS_MAX_NR_MEMBERS) {\n\t\t\tpr_warn(\"Cannot support #%u members in struct %s\\n\",\n\t\t\t\tbtf_type_vlen(t), st_ops->name);\n\t\t\tcontinue;\n\t\t}\n\n\t\tfor_each_member(j, t, member) {\n\t\t\tconst struct btf_type *func_proto;\n\n\t\t\tmname = btf_name_by_offset(btf, member->name_off);\n\t\t\tif (!*mname) {\n\t\t\t\tpr_warn(\"anon member in struct %s is not supported\\n\",\n\t\t\t\t\tst_ops->name);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (__btf_member_bitfield_size(t, member)) {\n\t\t\t\tpr_warn(\"bit field member %s in struct %s is not supported\\n\",\n\t\t\t\t\tmname, st_ops->name);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tfunc_proto = btf_type_resolve_func_ptr(btf,\n\t\t\t\t\t\t\t       member->type,\n\t\t\t\t\t\t\t       NULL);\n\t\t\tif (func_proto &&\n\t\t\t    btf_distill_func_proto(log, btf,\n\t\t\t\t\t\t   func_proto, mname,\n\t\t\t\t\t\t   &st_ops->func_models[j])) {\n\t\t\t\tpr_warn(\"Error in parsing func ptr %s in struct %s\\n\",\n\t\t\t\t\tmname, st_ops->name);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (j == btf_type_vlen(t)) {\n\t\t\tif (st_ops->init(btf)) {\n\t\t\t\tpr_warn(\"Error in init bpf_struct_ops %s\\n\",\n\t\t\t\t\tst_ops->name);\n\t\t\t} else {\n\t\t\t\tst_ops->type_id = type_id;\n\t\t\t\tst_ops->type = t;\n\t\t\t\tst_ops->value_id = value_id;\n\t\t\t\tst_ops->value_type = btf_type_by_id(btf,\n\t\t\t\t\t\t\t\t    value_id);\n\t\t\t}\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"bpf_struct_ops_types.h\"",
      "#include \"bpf_struct_ops_types.h\"",
      "#include \"bpf_struct_ops_types.h\"",
      "#include <linux/mutex.h>",
      "#include <linux/refcount.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/numa.h>",
      "#include <linux/slab.h>",
      "#include <linux/filter.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [
      "#define VALUE_PREFIX_LEN (sizeof(VALUE_PREFIX) - 1)",
      "#define VALUE_PREFIX \"bpf_struct_ops_\""
    ],
    "globals_used": [
      "static struct bpf_struct_ops * const bpf_struct_ops[] = {\n#define BPF_STRUCT_OPS_TYPE(_name)\t\t\t\t\\\n\t[BPF_STRUCT_OPS_TYPE_##_name] = &bpf_##_name,\n#include \"bpf_struct_ops_types.h\"\n#undef BPF_STRUCT_OPS_TYPE\n};",
      "static const struct btf_type *module_type;",
      "extern struct btf *btf_vmlinux;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btf_type_by_id",
          "args": [
            "btf",
            "value_id"
          ],
          "line": 195
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_by_id",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "731-740",
          "snippet": "const struct btf_type *btf_type_by_id(const struct btf *btf, u32 type_id)\n{\n\twhile (type_id < btf->start_id)\n\t\tbtf = btf->base_btf;\n\n\ttype_id -= btf->start_id;\n\tif (type_id >= btf->nr_types)\n\t\treturn NULL;\n\treturn btf->types[type_id];\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);\n\nconst struct btf_type *btf_type_by_id(const struct btf *btf, u32 type_id)\n{\n\twhile (type_id < btf->start_id)\n\t\tbtf = btf->base_btf;\n\n\ttype_id -= btf->start_id;\n\tif (type_id >= btf->nr_types)\n\t\treturn NULL;\n\treturn btf->types[type_id];\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"Error in init bpf_struct_ops %s\\n\"",
            "st_ops->name"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "st_ops->init",
          "args": [
            "btf"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_type_vlen",
          "args": [
            "t"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"Error in parsing func ptr %s in struct %s\\n\"",
            "mname",
            "st_ops->name"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_distill_func_proto",
          "args": [
            "log",
            "btf",
            "func_proto",
            "mname",
            "&st_ops->func_models[j]"
          ],
          "line": 178
        },
        "resolved": true,
        "details": {
          "function_name": "btf_distill_func_proto",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "5365-5427",
          "snippet": "int btf_distill_func_proto(struct bpf_verifier_log *log,\n\t\t\t   struct btf *btf,\n\t\t\t   const struct btf_type *func,\n\t\t\t   const char *tname,\n\t\t\t   struct btf_func_model *m)\n{\n\tconst struct btf_param *args;\n\tconst struct btf_type *t;\n\tu32 i, nargs;\n\tint ret;\n\n\tif (!func) {\n\t\t/* BTF function prototype doesn't match the verifier types.\n\t\t * Fall back to MAX_BPF_FUNC_REG_ARGS u64 args.\n\t\t */\n\t\tfor (i = 0; i < MAX_BPF_FUNC_REG_ARGS; i++)\n\t\t\tm->arg_size[i] = 8;\n\t\tm->ret_size = 8;\n\t\tm->nr_args = MAX_BPF_FUNC_REG_ARGS;\n\t\treturn 0;\n\t}\n\targs = (const struct btf_param *)(func + 1);\n\tnargs = btf_type_vlen(func);\n\tif (nargs >= MAX_BPF_FUNC_ARGS) {\n\t\tbpf_log(log,\n\t\t\t\"The function %s has %d arguments. Too many.\\n\",\n\t\t\ttname, nargs);\n\t\treturn -EINVAL;\n\t}\n\tret = __get_type_size(btf, func->type, &t);\n\tif (ret < 0) {\n\t\tbpf_log(log,\n\t\t\t\"The function %s return type %s is unsupported.\\n\",\n\t\t\ttname, btf_kind_str[BTF_INFO_KIND(t->info)]);\n\t\treturn -EINVAL;\n\t}\n\tm->ret_size = ret;\n\n\tfor (i = 0; i < nargs; i++) {\n\t\tif (i == nargs - 1 && args[i].type == 0) {\n\t\t\tbpf_log(log,\n\t\t\t\t\"The function %s with variable args is unsupported.\\n\",\n\t\t\t\ttname);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tret = __get_type_size(btf, args[i].type, &t);\n\t\tif (ret < 0) {\n\t\t\tbpf_log(log,\n\t\t\t\t\"The function %s arg%d type %s is unsupported.\\n\",\n\t\t\t\ttname, i, btf_kind_str[BTF_INFO_KIND(t->info)]);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (ret == 0) {\n\t\t\tbpf_log(log,\n\t\t\t\t\"The function %s has malformed void argument.\\n\",\n\t\t\t\ttname);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tm->arg_size[i] = ret;\n\t}\n\tm->nr_args = nargs;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char * const btf_kind_str[NR_BTF_KINDS] = {\n\t[BTF_KIND_UNKN]\t\t= \"UNKNOWN\",\n\t[BTF_KIND_INT]\t\t= \"INT\",\n\t[BTF_KIND_PTR]\t\t= \"PTR\",\n\t[BTF_KIND_ARRAY]\t= \"ARRAY\",\n\t[BTF_KIND_STRUCT]\t= \"STRUCT\",\n\t[BTF_KIND_UNION]\t= \"UNION\",\n\t[BTF_KIND_ENUM]\t\t= \"ENUM\",\n\t[BTF_KIND_FWD]\t\t= \"FWD\",\n\t[BTF_KIND_TYPEDEF]\t= \"TYPEDEF\",\n\t[BTF_KIND_VOLATILE]\t= \"VOLATILE\",\n\t[BTF_KIND_CONST]\t= \"CONST\",\n\t[BTF_KIND_RESTRICT]\t= \"RESTRICT\",\n\t[BTF_KIND_FUNC]\t\t= \"FUNC\",\n\t[BTF_KIND_FUNC_PROTO]\t= \"FUNC_PROTO\",\n\t[BTF_KIND_VAR]\t\t= \"VAR\",\n\t[BTF_KIND_DATASEC]\t= \"DATASEC\",\n\t[BTF_KIND_FLOAT]\t= \"FLOAT\",\n\t[BTF_KIND_DECL_TAG]\t= \"DECL_TAG\",\n\t[BTF_KIND_TYPE_TAG]\t= \"TYPE_TAG\",\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic const char * const btf_kind_str[NR_BTF_KINDS] = {\n\t[BTF_KIND_UNKN]\t\t= \"UNKNOWN\",\n\t[BTF_KIND_INT]\t\t= \"INT\",\n\t[BTF_KIND_PTR]\t\t= \"PTR\",\n\t[BTF_KIND_ARRAY]\t= \"ARRAY\",\n\t[BTF_KIND_STRUCT]\t= \"STRUCT\",\n\t[BTF_KIND_UNION]\t= \"UNION\",\n\t[BTF_KIND_ENUM]\t\t= \"ENUM\",\n\t[BTF_KIND_FWD]\t\t= \"FWD\",\n\t[BTF_KIND_TYPEDEF]\t= \"TYPEDEF\",\n\t[BTF_KIND_VOLATILE]\t= \"VOLATILE\",\n\t[BTF_KIND_CONST]\t= \"CONST\",\n\t[BTF_KIND_RESTRICT]\t= \"RESTRICT\",\n\t[BTF_KIND_FUNC]\t\t= \"FUNC\",\n\t[BTF_KIND_FUNC_PROTO]\t= \"FUNC_PROTO\",\n\t[BTF_KIND_VAR]\t\t= \"VAR\",\n\t[BTF_KIND_DATASEC]\t= \"DATASEC\",\n\t[BTF_KIND_FLOAT]\t= \"FLOAT\",\n\t[BTF_KIND_DECL_TAG]\t= \"DECL_TAG\",\n\t[BTF_KIND_TYPE_TAG]\t= \"TYPE_TAG\",\n};\n\nint btf_distill_func_proto(struct bpf_verifier_log *log,\n\t\t\t   struct btf *btf,\n\t\t\t   const struct btf_type *func,\n\t\t\t   const char *tname,\n\t\t\t   struct btf_func_model *m)\n{\n\tconst struct btf_param *args;\n\tconst struct btf_type *t;\n\tu32 i, nargs;\n\tint ret;\n\n\tif (!func) {\n\t\t/* BTF function prototype doesn't match the verifier types.\n\t\t * Fall back to MAX_BPF_FUNC_REG_ARGS u64 args.\n\t\t */\n\t\tfor (i = 0; i < MAX_BPF_FUNC_REG_ARGS; i++)\n\t\t\tm->arg_size[i] = 8;\n\t\tm->ret_size = 8;\n\t\tm->nr_args = MAX_BPF_FUNC_REG_ARGS;\n\t\treturn 0;\n\t}\n\targs = (const struct btf_param *)(func + 1);\n\tnargs = btf_type_vlen(func);\n\tif (nargs >= MAX_BPF_FUNC_ARGS) {\n\t\tbpf_log(log,\n\t\t\t\"The function %s has %d arguments. Too many.\\n\",\n\t\t\ttname, nargs);\n\t\treturn -EINVAL;\n\t}\n\tret = __get_type_size(btf, func->type, &t);\n\tif (ret < 0) {\n\t\tbpf_log(log,\n\t\t\t\"The function %s return type %s is unsupported.\\n\",\n\t\t\ttname, btf_kind_str[BTF_INFO_KIND(t->info)]);\n\t\treturn -EINVAL;\n\t}\n\tm->ret_size = ret;\n\n\tfor (i = 0; i < nargs; i++) {\n\t\tif (i == nargs - 1 && args[i].type == 0) {\n\t\t\tbpf_log(log,\n\t\t\t\t\"The function %s with variable args is unsupported.\\n\",\n\t\t\t\ttname);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tret = __get_type_size(btf, args[i].type, &t);\n\t\tif (ret < 0) {\n\t\t\tbpf_log(log,\n\t\t\t\t\"The function %s arg%d type %s is unsupported.\\n\",\n\t\t\t\ttname, i, btf_kind_str[BTF_INFO_KIND(t->info)]);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (ret == 0) {\n\t\t\tbpf_log(log,\n\t\t\t\t\"The function %s has malformed void argument.\\n\",\n\t\t\t\ttname);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tm->arg_size[i] = ret;\n\t}\n\tm->nr_args = nargs;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_type_resolve_func_ptr",
          "args": [
            "btf",
            "member->type",
            "NULL"
          ],
          "line": 174
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_resolve_func_ptr",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "537-547",
          "snippet": "const struct btf_type *btf_type_resolve_func_ptr(const struct btf *btf,\n\t\t\t\t\t\t u32 id, u32 *res_id)\n{\n\tconst struct btf_type *ptype;\n\n\tptype = btf_type_resolve_ptr(btf, id, res_id);\n\tif (ptype && btf_type_is_func_proto(ptype))\n\t\treturn ptype;\n\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nconst struct btf_type *btf_type_resolve_func_ptr(const struct btf *btf,\n\t\t\t\t\t\t u32 id, u32 *res_id)\n{\n\tconst struct btf_type *ptype;\n\n\tptype = btf_type_resolve_ptr(btf, id, res_id);\n\tif (ptype && btf_type_is_func_proto(ptype))\n\t\treturn ptype;\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"bit field member %s in struct %s is not supported\\n\"",
            "mname",
            "st_ops->name"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__btf_member_bitfield_size",
          "args": [
            "t",
            "member"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"anon member in struct %s is not supported\\n\"",
            "st_ops->name"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_name_by_offset",
          "args": [
            "btf",
            "member->name_off"
          ],
          "line": 161
        },
        "resolved": true,
        "details": {
          "function_name": "btf_name_by_offset",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "726-729",
          "snippet": "const char *btf_name_by_offset(const struct btf *btf, u32 offset)\n{\n\treturn btf_str_by_offset(btf, offset);\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nconst char *btf_name_by_offset(const struct btf *btf, u32 offset)\n{\n\treturn btf_str_by_offset(btf, offset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_member",
          "args": [
            "j",
            "t",
            "member"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"Cannot support #%u members in struct %s\\n\"",
            "btf_type_vlen(t)",
            "st_ops->name"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_type_vlen",
          "args": [
            "t"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_type_vlen",
          "args": [
            "t"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"Cannot find struct %s in btf_vmlinux\\n\"",
            "st_ops->name"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_find_by_name_kind",
          "args": [
            "btf",
            "st_ops->name",
            "BTF_KIND_STRUCT"
          ],
          "line": 144
        },
        "resolved": true,
        "details": {
          "function_name": "btf_find_by_name_kind",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "489-507",
          "snippet": "s32 btf_find_by_name_kind(const struct btf *btf, const char *name, u8 kind)\n{\n\tconst struct btf_type *t;\n\tconst char *tname;\n\tu32 i, total;\n\n\ttotal = btf_nr_types(btf);\n\tfor (i = 1; i < total; i++) {\n\t\tt = btf_type_by_id(btf, i);\n\t\tif (BTF_INFO_KIND(t->info) != kind)\n\t\t\tcontinue;\n\n\t\ttname = btf_name_by_offset(btf, t->name_off);\n\t\tif (!strcmp(tname, name))\n\t\t\treturn i;\n\t}\n\n\treturn -ENOENT;\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\ns32 btf_find_by_name_kind(const struct btf *btf, const char *name, u8 kind)\n{\n\tconst struct btf_type *t;\n\tconst char *tname;\n\tu32 i, total;\n\n\ttotal = btf_nr_types(btf);\n\tfor (i = 1; i < total; i++) {\n\t\tt = btf_type_by_id(btf, i);\n\t\tif (BTF_INFO_KIND(t->info) != kind)\n\t\t\tcontinue;\n\n\t\ttname = btf_name_by_offset(btf, t->name_off);\n\t\tif (!strcmp(tname, name))\n\t\t\treturn i;\n\t}\n\n\treturn -ENOENT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"Cannot find struct %s in btf_vmlinux\\n\"",
            "value_name"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "value_name",
            "\"%s%s\"",
            "VALUE_PREFIX",
            "st_ops->name"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"struct_ops name %s is too long\\n\"",
            "st_ops->name"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "st_ops->name"
          ],
          "line": 128
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_eprobe.c",
          "lines": "384-401",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/ftrace.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "bpf_struct_ops"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"Cannot find struct module in btf_vmlinux\\n\""
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"bpf_struct_ops_types.h\"\n#include \"bpf_struct_ops_types.h\"\n#include \"bpf_struct_ops_types.h\"\n#include <linux/mutex.h>\n#include <linux/refcount.h>\n#include <linux/seq_file.h>\n#include <linux/numa.h>\n#include <linux/slab.h>\n#include <linux/filter.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf.h>\n\n#define VALUE_PREFIX_LEN (sizeof(VALUE_PREFIX) - 1)\n#define VALUE_PREFIX \"bpf_struct_ops_\"\n\nstatic struct bpf_struct_ops * const bpf_struct_ops[] = {\n#define BPF_STRUCT_OPS_TYPE(_name)\t\t\t\t\\\n\t[BPF_STRUCT_OPS_TYPE_##_name] = &bpf_##_name,\n#include \"bpf_struct_ops_types.h\"\n#undef BPF_STRUCT_OPS_TYPE\n};\nstatic const struct btf_type *module_type;\nextern struct btf *btf_vmlinux;\n\nvoid bpf_struct_ops_init(struct btf *btf, struct bpf_verifier_log *log)\n{\n\ts32 type_id, value_id, module_id;\n\tconst struct btf_member *member;\n\tstruct bpf_struct_ops *st_ops;\n\tconst struct btf_type *t;\n\tchar value_name[128];\n\tconst char *mname;\n\tu32 i, j;\n\n\t/* Ensure BTF type is emitted for \"struct bpf_struct_ops_##_name\" */\n#define BPF_STRUCT_OPS_TYPE(_name) BTF_TYPE_EMIT(struct bpf_struct_ops_##_name);\n#include \"bpf_struct_ops_types.h\"\n#undef BPF_STRUCT_OPS_TYPE\n\n\tmodule_id = btf_find_by_name_kind(btf, \"module\", BTF_KIND_STRUCT);\n\tif (module_id < 0) {\n\t\tpr_warn(\"Cannot find struct module in btf_vmlinux\\n\");\n\t\treturn;\n\t}\n\tmodule_type = btf_type_by_id(btf, module_id);\n\n\tfor (i = 0; i < ARRAY_SIZE(bpf_struct_ops); i++) {\n\t\tst_ops = bpf_struct_ops[i];\n\n\t\tif (strlen(st_ops->name) + VALUE_PREFIX_LEN >=\n\t\t    sizeof(value_name)) {\n\t\t\tpr_warn(\"struct_ops name %s is too long\\n\",\n\t\t\t\tst_ops->name);\n\t\t\tcontinue;\n\t\t}\n\t\tsprintf(value_name, \"%s%s\", VALUE_PREFIX, st_ops->name);\n\n\t\tvalue_id = btf_find_by_name_kind(btf, value_name,\n\t\t\t\t\t\t BTF_KIND_STRUCT);\n\t\tif (value_id < 0) {\n\t\t\tpr_warn(\"Cannot find struct %s in btf_vmlinux\\n\",\n\t\t\t\tvalue_name);\n\t\t\tcontinue;\n\t\t}\n\n\t\ttype_id = btf_find_by_name_kind(btf, st_ops->name,\n\t\t\t\t\t\tBTF_KIND_STRUCT);\n\t\tif (type_id < 0) {\n\t\t\tpr_warn(\"Cannot find struct %s in btf_vmlinux\\n\",\n\t\t\t\tst_ops->name);\n\t\t\tcontinue;\n\t\t}\n\t\tt = btf_type_by_id(btf, type_id);\n\t\tif (btf_type_vlen(t) > BPF_STRUCT_OPS_MAX_NR_MEMBERS) {\n\t\t\tpr_warn(\"Cannot support #%u members in struct %s\\n\",\n\t\t\t\tbtf_type_vlen(t), st_ops->name);\n\t\t\tcontinue;\n\t\t}\n\n\t\tfor_each_member(j, t, member) {\n\t\t\tconst struct btf_type *func_proto;\n\n\t\t\tmname = btf_name_by_offset(btf, member->name_off);\n\t\t\tif (!*mname) {\n\t\t\t\tpr_warn(\"anon member in struct %s is not supported\\n\",\n\t\t\t\t\tst_ops->name);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (__btf_member_bitfield_size(t, member)) {\n\t\t\t\tpr_warn(\"bit field member %s in struct %s is not supported\\n\",\n\t\t\t\t\tmname, st_ops->name);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tfunc_proto = btf_type_resolve_func_ptr(btf,\n\t\t\t\t\t\t\t       member->type,\n\t\t\t\t\t\t\t       NULL);\n\t\t\tif (func_proto &&\n\t\t\t    btf_distill_func_proto(log, btf,\n\t\t\t\t\t\t   func_proto, mname,\n\t\t\t\t\t\t   &st_ops->func_models[j])) {\n\t\t\t\tpr_warn(\"Error in parsing func ptr %s in struct %s\\n\",\n\t\t\t\t\tmname, st_ops->name);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (j == btf_type_vlen(t)) {\n\t\t\tif (st_ops->init(btf)) {\n\t\t\t\tpr_warn(\"Error in init bpf_struct_ops %s\\n\",\n\t\t\t\t\tst_ops->name);\n\t\t\t} else {\n\t\t\t\tst_ops->type_id = type_id;\n\t\t\t\tst_ops->type = t;\n\t\t\t\tst_ops->value_id = value_id;\n\t\t\t\tst_ops->value_type = btf_type_by_id(btf,\n\t\t\t\t\t\t\t\t    value_id);\n\t\t\t}\n\t\t}\n\t}\n}"
  }
]