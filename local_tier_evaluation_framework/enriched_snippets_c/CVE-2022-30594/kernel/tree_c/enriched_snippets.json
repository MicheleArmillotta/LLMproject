[
  {
    "function_name": "rcu_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
    "lines": "4739-4778",
    "snippet": "void __init rcu_init(void)\n{\n\tint cpu;\n\n\trcu_early_boot_tests();\n\n\tkfree_rcu_batch_init();\n\trcu_bootup_announce();\n\trcu_init_geometry();\n\trcu_init_one();\n\tif (dump_tree)\n\t\trcu_dump_rcu_node_tree();\n\tif (use_softirq)\n\t\topen_softirq(RCU_SOFTIRQ, rcu_core_si);\n\n\t/*\n\t * We don't need protection against CPU-hotplug here because\n\t * this is called early in boot, before either interrupts\n\t * or the scheduler are operational.\n\t */\n\tpm_notifier(rcu_pm_notify, 0);\n\tfor_each_online_cpu(cpu) {\n\t\trcutree_prepare_cpu(cpu);\n\t\trcu_cpu_starting(cpu);\n\t\trcutree_online_cpu(cpu);\n\t}\n\n\t/* Create workqueue for Tree SRCU and for expedited GPs. */\n\trcu_gp_wq = alloc_workqueue(\"rcu_gp\", WQ_MEM_RECLAIM, 0);\n\tWARN_ON(!rcu_gp_wq);\n\trcu_par_gp_wq = alloc_workqueue(\"rcu_par_gp\", WQ_MEM_RECLAIM, 0);\n\tWARN_ON(!rcu_par_gp_wq);\n\n\t/* Fill in default value for rcutree.qovld boot parameter. */\n\t/* -After- the rcu_node ->lock fields are initialized! */\n\tif (qovld < 0)\n\t\tqovld_calc = DEFAULT_RCU_QOVLD_MULT * qhimark;\n\telse\n\t\tqovld_calc = qovld;\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_nocb.h\"",
      "#include \"tree_exp.h\"",
      "#include \"tree_stall.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <linux/kasan.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/panic_notifier.h>",
      "#include <linux/panic.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [
      "#define DEFAULT_RCU_QOVLD_MULT 2"
    ],
    "globals_used": [
      "static bool dump_tree;",
      "static bool use_softirq = !IS_ENABLED(CONFIG_PREEMPT_RT);",
      "static void sync_sched_exp_online_cleanup(int cpu);",
      "static long qhimark = DEFAULT_RCU_QHIMARK;",
      "static long qovld = DEFAULT_RCU_QOVLD;",
      "static long qovld_calc = -1;",
      "struct workqueue_struct *rcu_gp_wq;",
      "struct workqueue_struct *rcu_par_gp_wq;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!rcu_par_gp_wq"
          ],
          "line": 4770
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_workqueue",
          "args": [
            "\"rcu_par_gp\"",
            "WQ_MEM_RECLAIM",
            "0"
          ],
          "line": 4769
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_workqueue",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "4298-4392",
          "snippet": "struct workqueue_struct *alloc_workqueue(const char *fmt,\n\t\t\t\t\t unsigned int flags,\n\t\t\t\t\t int max_active, ...)\n{\n\tsize_t tbl_size = 0;\n\tva_list args;\n\tstruct workqueue_struct *wq;\n\tstruct pool_workqueue *pwq;\n\n\t/*\n\t * Unbound && max_active == 1 used to imply ordered, which is no\n\t * longer the case on NUMA machines due to per-node pools.  While\n\t * alloc_ordered_workqueue() is the right way to create an ordered\n\t * workqueue, keep the previous behavior to avoid subtle breakages\n\t * on NUMA.\n\t */\n\tif ((flags & WQ_UNBOUND) && max_active == 1)\n\t\tflags |= __WQ_ORDERED;\n\n\t/* see the comment above the definition of WQ_POWER_EFFICIENT */\n\tif ((flags & WQ_POWER_EFFICIENT) && wq_power_efficient)\n\t\tflags |= WQ_UNBOUND;\n\n\t/* allocate wq and format name */\n\tif (flags & WQ_UNBOUND)\n\t\ttbl_size = nr_node_ids * sizeof(wq->numa_pwq_tbl[0]);\n\n\twq = kzalloc(sizeof(*wq) + tbl_size, GFP_KERNEL);\n\tif (!wq)\n\t\treturn NULL;\n\n\tif (flags & WQ_UNBOUND) {\n\t\twq->unbound_attrs = alloc_workqueue_attrs();\n\t\tif (!wq->unbound_attrs)\n\t\t\tgoto err_free_wq;\n\t}\n\n\tva_start(args, max_active);\n\tvsnprintf(wq->name, sizeof(wq->name), fmt, args);\n\tva_end(args);\n\n\tmax_active = max_active ?: WQ_DFL_ACTIVE;\n\tmax_active = wq_clamp_max_active(max_active, flags, wq->name);\n\n\t/* init wq */\n\twq->flags = flags;\n\twq->saved_max_active = max_active;\n\tmutex_init(&wq->mutex);\n\tatomic_set(&wq->nr_pwqs_to_flush, 0);\n\tINIT_LIST_HEAD(&wq->pwqs);\n\tINIT_LIST_HEAD(&wq->flusher_queue);\n\tINIT_LIST_HEAD(&wq->flusher_overflow);\n\tINIT_LIST_HEAD(&wq->maydays);\n\n\twq_init_lockdep(wq);\n\tINIT_LIST_HEAD(&wq->list);\n\n\tif (alloc_and_link_pwqs(wq) < 0)\n\t\tgoto err_unreg_lockdep;\n\n\tif (wq_online && init_rescuer(wq) < 0)\n\t\tgoto err_destroy;\n\n\tif ((wq->flags & WQ_SYSFS) && workqueue_sysfs_register(wq))\n\t\tgoto err_destroy;\n\n\t/*\n\t * wq_pool_mutex protects global freeze state and workqueues list.\n\t * Grab it, adjust max_active and add the new @wq to workqueues\n\t * list.\n\t */\n\tmutex_lock(&wq_pool_mutex);\n\n\tmutex_lock(&wq->mutex);\n\tfor_each_pwq(pwq, wq)\n\t\tpwq_adjust_max_active(pwq);\n\tmutex_unlock(&wq->mutex);\n\n\tlist_add_tail_rcu(&wq->list, &workqueues);\n\n\tmutex_unlock(&wq_pool_mutex);\n\n\treturn wq;\n\nerr_unreg_lockdep:\n\twq_unregister_lockdep(wq);\n\twq_free_lockdep(wq);\nerr_free_wq:\n\tfree_workqueue_attrs(wq->unbound_attrs);\n\tkfree(wq);\n\treturn NULL;\nerr_destroy:\n\tdestroy_workqueue(wq);\n\treturn NULL;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool wq_power_efficient = IS_ENABLED(CONFIG_WQ_POWER_EFFICIENT_DEFAULT);",
            "static bool wq_online;",
            "static DEFINE_MUTEX(wq_pool_mutex);",
            "static LIST_HEAD(workqueues);",
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);",
            "static void show_pwq(struct pool_workqueue *pwq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic bool wq_power_efficient = IS_ENABLED(CONFIG_WQ_POWER_EFFICIENT_DEFAULT);\nstatic bool wq_online;\nstatic DEFINE_MUTEX(wq_pool_mutex);\nstatic LIST_HEAD(workqueues);\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\nstatic void show_pwq(struct pool_workqueue *pwq);\n\nstruct workqueue_struct *alloc_workqueue(const char *fmt,\n\t\t\t\t\t unsigned int flags,\n\t\t\t\t\t int max_active, ...)\n{\n\tsize_t tbl_size = 0;\n\tva_list args;\n\tstruct workqueue_struct *wq;\n\tstruct pool_workqueue *pwq;\n\n\t/*\n\t * Unbound && max_active == 1 used to imply ordered, which is no\n\t * longer the case on NUMA machines due to per-node pools.  While\n\t * alloc_ordered_workqueue() is the right way to create an ordered\n\t * workqueue, keep the previous behavior to avoid subtle breakages\n\t * on NUMA.\n\t */\n\tif ((flags & WQ_UNBOUND) && max_active == 1)\n\t\tflags |= __WQ_ORDERED;\n\n\t/* see the comment above the definition of WQ_POWER_EFFICIENT */\n\tif ((flags & WQ_POWER_EFFICIENT) && wq_power_efficient)\n\t\tflags |= WQ_UNBOUND;\n\n\t/* allocate wq and format name */\n\tif (flags & WQ_UNBOUND)\n\t\ttbl_size = nr_node_ids * sizeof(wq->numa_pwq_tbl[0]);\n\n\twq = kzalloc(sizeof(*wq) + tbl_size, GFP_KERNEL);\n\tif (!wq)\n\t\treturn NULL;\n\n\tif (flags & WQ_UNBOUND) {\n\t\twq->unbound_attrs = alloc_workqueue_attrs();\n\t\tif (!wq->unbound_attrs)\n\t\t\tgoto err_free_wq;\n\t}\n\n\tva_start(args, max_active);\n\tvsnprintf(wq->name, sizeof(wq->name), fmt, args);\n\tva_end(args);\n\n\tmax_active = max_active ?: WQ_DFL_ACTIVE;\n\tmax_active = wq_clamp_max_active(max_active, flags, wq->name);\n\n\t/* init wq */\n\twq->flags = flags;\n\twq->saved_max_active = max_active;\n\tmutex_init(&wq->mutex);\n\tatomic_set(&wq->nr_pwqs_to_flush, 0);\n\tINIT_LIST_HEAD(&wq->pwqs);\n\tINIT_LIST_HEAD(&wq->flusher_queue);\n\tINIT_LIST_HEAD(&wq->flusher_overflow);\n\tINIT_LIST_HEAD(&wq->maydays);\n\n\twq_init_lockdep(wq);\n\tINIT_LIST_HEAD(&wq->list);\n\n\tif (alloc_and_link_pwqs(wq) < 0)\n\t\tgoto err_unreg_lockdep;\n\n\tif (wq_online && init_rescuer(wq) < 0)\n\t\tgoto err_destroy;\n\n\tif ((wq->flags & WQ_SYSFS) && workqueue_sysfs_register(wq))\n\t\tgoto err_destroy;\n\n\t/*\n\t * wq_pool_mutex protects global freeze state and workqueues list.\n\t * Grab it, adjust max_active and add the new @wq to workqueues\n\t * list.\n\t */\n\tmutex_lock(&wq_pool_mutex);\n\n\tmutex_lock(&wq->mutex);\n\tfor_each_pwq(pwq, wq)\n\t\tpwq_adjust_max_active(pwq);\n\tmutex_unlock(&wq->mutex);\n\n\tlist_add_tail_rcu(&wq->list, &workqueues);\n\n\tmutex_unlock(&wq_pool_mutex);\n\n\treturn wq;\n\nerr_unreg_lockdep:\n\twq_unregister_lockdep(wq);\n\twq_free_lockdep(wq);\nerr_free_wq:\n\tfree_workqueue_attrs(wq->unbound_attrs);\n\tkfree(wq);\n\treturn NULL;\nerr_destroy:\n\tdestroy_workqueue(wq);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!rcu_gp_wq"
          ],
          "line": 4768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcutree_online_cpu",
          "args": [
            "cpu"
          ],
          "line": 4763
        },
        "resolved": true,
        "details": {
          "function_name": "rcutree_online_cpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "4220-4239",
          "snippet": "int rcutree_online_cpu(unsigned int cpu)\n{\n\tunsigned long flags;\n\tstruct rcu_data *rdp;\n\tstruct rcu_node *rnp;\n\n\trdp = per_cpu_ptr(&rcu_data, cpu);\n\trnp = rdp->mynode;\n\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\trnp->ffmask |= rdp->grpmask;\n\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\tif (rcu_scheduler_active == RCU_SCHEDULER_INACTIVE)\n\t\treturn 0; /* Too early in boot for scheduler work. */\n\tsync_sched_exp_online_cleanup(cpu);\n\trcutree_affinity_setting(cpu, -1);\n\n\t// Stop-machine done, so allow nohz_full to disable tick.\n\ttick_dep_clear(TICK_DEP_BIT_RCU);\n\treturn 0;\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};",
            "int rcu_scheduler_active",
            "static void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);",
            "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
            "static void sync_sched_exp_online_cleanup(int cpu);",
            "static void check_cb_ovld_locked(struct rcu_data *rdp, struct rcu_node *rnp);",
            "static bool rcu_rdp_is_offloaded(struct rcu_data *rdp);",
            "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};\nint rcu_scheduler_active;\nstatic void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void sync_sched_exp_online_cleanup(int cpu);\nstatic void check_cb_ovld_locked(struct rcu_data *rdp, struct rcu_node *rnp);\nstatic bool rcu_rdp_is_offloaded(struct rcu_data *rdp);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nint rcutree_online_cpu(unsigned int cpu)\n{\n\tunsigned long flags;\n\tstruct rcu_data *rdp;\n\tstruct rcu_node *rnp;\n\n\trdp = per_cpu_ptr(&rcu_data, cpu);\n\trnp = rdp->mynode;\n\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\trnp->ffmask |= rdp->grpmask;\n\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\tif (rcu_scheduler_active == RCU_SCHEDULER_INACTIVE)\n\t\treturn 0; /* Too early in boot for scheduler work. */\n\tsync_sched_exp_online_cleanup(cpu);\n\trcutree_affinity_setting(cpu, -1);\n\n\t// Stop-machine done, so allow nohz_full to disable tick.\n\ttick_dep_clear(TICK_DEP_BIT_RCU);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_cpu_starting",
          "args": [
            "cpu"
          ],
          "line": 4762
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_cpu_starting",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "4275-4317",
          "snippet": "void rcu_cpu_starting(unsigned int cpu)\n{\n\tunsigned long flags;\n\tunsigned long mask;\n\tstruct rcu_data *rdp;\n\tstruct rcu_node *rnp;\n\tbool newcpu;\n\n\trdp = per_cpu_ptr(&rcu_data, cpu);\n\tif (rdp->cpu_started)\n\t\treturn;\n\trdp->cpu_started = true;\n\n\trnp = rdp->mynode;\n\tmask = rdp->grpmask;\n\tWRITE_ONCE(rnp->ofl_seq, rnp->ofl_seq + 1);\n\tWARN_ON_ONCE(!(rnp->ofl_seq & 0x1));\n\trcu_dynticks_eqs_online();\n\tsmp_mb(); // Pair with rcu_gp_cleanup()'s ->ofl_seq barrier().\n\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\tWRITE_ONCE(rnp->qsmaskinitnext, rnp->qsmaskinitnext | mask);\n\tnewcpu = !(rnp->expmaskinitnext & mask);\n\trnp->expmaskinitnext |= mask;\n\t/* Allow lockless access for expedited grace periods. */\n\tsmp_store_release(&rcu_state.ncpus, rcu_state.ncpus + newcpu); /* ^^^ */\n\tASSERT_EXCLUSIVE_WRITER(rcu_state.ncpus);\n\trcu_gpnum_ovf(rnp, rdp); /* Offline-induced counter wrap? */\n\trdp->rcu_onl_gp_seq = READ_ONCE(rcu_state.gp_seq);\n\trdp->rcu_onl_gp_flags = READ_ONCE(rcu_state.gp_flags);\n\n\t/* An incoming CPU should never be blocking a grace period. */\n\tif (WARN_ON_ONCE(rnp->qsmask & mask)) { /* RCU waiting on incoming CPU? */\n\t\trcu_disable_urgency_upon_qs(rdp);\n\t\t/* Report QS -after- changing ->qsmaskinitnext! */\n\t\trcu_report_qs_rnp(mask, rnp, rnp->gp_seq, flags);\n\t} else {\n\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t}\n\tsmp_mb(); // Pair with rcu_gp_cleanup()'s ->ofl_seq barrier().\n\tWRITE_ONCE(rnp->ofl_seq, rnp->ofl_seq + 1);\n\tWARN_ON_ONCE(rnp->ofl_seq & 0x1);\n\tsmp_mb(); /* Ensure RCU read-side usage follows above initialization. */\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};",
            "static struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};",
            "static void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);",
            "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
            "static void sync_sched_exp_online_cleanup(int cpu);",
            "static void check_cb_ovld_locked(struct rcu_data *rdp, struct rcu_node *rnp);",
            "static bool rcu_rdp_is_offloaded(struct rcu_data *rdp);",
            "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};\nstatic struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\nstatic void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void sync_sched_exp_online_cleanup(int cpu);\nstatic void check_cb_ovld_locked(struct rcu_data *rdp, struct rcu_node *rnp);\nstatic bool rcu_rdp_is_offloaded(struct rcu_data *rdp);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nvoid rcu_cpu_starting(unsigned int cpu)\n{\n\tunsigned long flags;\n\tunsigned long mask;\n\tstruct rcu_data *rdp;\n\tstruct rcu_node *rnp;\n\tbool newcpu;\n\n\trdp = per_cpu_ptr(&rcu_data, cpu);\n\tif (rdp->cpu_started)\n\t\treturn;\n\trdp->cpu_started = true;\n\n\trnp = rdp->mynode;\n\tmask = rdp->grpmask;\n\tWRITE_ONCE(rnp->ofl_seq, rnp->ofl_seq + 1);\n\tWARN_ON_ONCE(!(rnp->ofl_seq & 0x1));\n\trcu_dynticks_eqs_online();\n\tsmp_mb(); // Pair with rcu_gp_cleanup()'s ->ofl_seq barrier().\n\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\tWRITE_ONCE(rnp->qsmaskinitnext, rnp->qsmaskinitnext | mask);\n\tnewcpu = !(rnp->expmaskinitnext & mask);\n\trnp->expmaskinitnext |= mask;\n\t/* Allow lockless access for expedited grace periods. */\n\tsmp_store_release(&rcu_state.ncpus, rcu_state.ncpus + newcpu); /* ^^^ */\n\tASSERT_EXCLUSIVE_WRITER(rcu_state.ncpus);\n\trcu_gpnum_ovf(rnp, rdp); /* Offline-induced counter wrap? */\n\trdp->rcu_onl_gp_seq = READ_ONCE(rcu_state.gp_seq);\n\trdp->rcu_onl_gp_flags = READ_ONCE(rcu_state.gp_flags);\n\n\t/* An incoming CPU should never be blocking a grace period. */\n\tif (WARN_ON_ONCE(rnp->qsmask & mask)) { /* RCU waiting on incoming CPU? */\n\t\trcu_disable_urgency_upon_qs(rdp);\n\t\t/* Report QS -after- changing ->qsmaskinitnext! */\n\t\trcu_report_qs_rnp(mask, rnp, rnp->gp_seq, flags);\n\t} else {\n\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t}\n\tsmp_mb(); // Pair with rcu_gp_cleanup()'s ->ofl_seq barrier().\n\tWRITE_ONCE(rnp->ofl_seq, rnp->ofl_seq + 1);\n\tWARN_ON_ONCE(rnp->ofl_seq & 0x1);\n\tsmp_mb(); /* Ensure RCU read-side usage follows above initialization. */\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcutree_prepare_cpu",
          "args": [
            "cpu"
          ],
          "line": 4761
        },
        "resolved": true,
        "details": {
          "function_name": "rcutree_prepare_cpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "4161-4204",
          "snippet": "int rcutree_prepare_cpu(unsigned int cpu)\n{\n\tunsigned long flags;\n\tstruct rcu_data *rdp = per_cpu_ptr(&rcu_data, cpu);\n\tstruct rcu_node *rnp = rcu_get_root();\n\n\t/* Set up local state, ensuring consistent view of global state. */\n\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\trdp->qlen_last_fqs_check = 0;\n\trdp->n_force_qs_snap = READ_ONCE(rcu_state.n_force_qs);\n\trdp->blimit = blimit;\n\trdp->dynticks_nesting = 1;\t/* CPU not up, no tearing. */\n\traw_spin_unlock_rcu_node(rnp);\t\t/* irqs remain disabled. */\n\n\t/*\n\t * Only non-NOCB CPUs that didn't have early-boot callbacks need to be\n\t * (re-)initialized.\n\t */\n\tif (!rcu_segcblist_is_enabled(&rdp->cblist))\n\t\trcu_segcblist_init(&rdp->cblist);  /* Re-enable callbacks. */\n\n\t/*\n\t * Add CPU to leaf rcu_node pending-online bitmask.  Any needed\n\t * propagation up the rcu_node tree will happen at the beginning\n\t * of the next grace period.\n\t */\n\trnp = rdp->mynode;\n\traw_spin_lock_rcu_node(rnp);\t\t/* irqs already disabled. */\n\trdp->beenonline = true;\t /* We have now been online. */\n\trdp->gp_seq = READ_ONCE(rnp->gp_seq);\n\trdp->gp_seq_needed = rdp->gp_seq;\n\trdp->cpu_no_qs.b.norm = true;\n\trdp->core_needs_qs = false;\n\trdp->rcu_iw_pending = false;\n\trdp->rcu_iw = IRQ_WORK_INIT_HARD(rcu_iw_handler);\n\trdp->rcu_iw_gp_seq = rdp->gp_seq - 1;\n\ttrace_rcu_grace_period(rcu_state.name, rdp->gp_seq, TPS(\"cpuonl\"));\n\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\trcu_spawn_one_boost_kthread(rnp);\n\trcu_spawn_cpu_nocb_kthread(cpu);\n\tWRITE_ONCE(rcu_state.n_online_cpus, rcu_state.n_online_cpus + 1);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};",
            "static struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};",
            "static void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);",
            "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
            "static void sync_sched_exp_online_cleanup(int cpu);",
            "static void check_cb_ovld_locked(struct rcu_data *rdp, struct rcu_node *rnp);",
            "static bool rcu_rdp_is_offloaded(struct rcu_data *rdp);",
            "static long blimit = DEFAULT_RCU_BLIMIT;",
            "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};\nstatic struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\nstatic void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void sync_sched_exp_online_cleanup(int cpu);\nstatic void check_cb_ovld_locked(struct rcu_data *rdp, struct rcu_node *rnp);\nstatic bool rcu_rdp_is_offloaded(struct rcu_data *rdp);\nstatic long blimit = DEFAULT_RCU_BLIMIT;\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nint rcutree_prepare_cpu(unsigned int cpu)\n{\n\tunsigned long flags;\n\tstruct rcu_data *rdp = per_cpu_ptr(&rcu_data, cpu);\n\tstruct rcu_node *rnp = rcu_get_root();\n\n\t/* Set up local state, ensuring consistent view of global state. */\n\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\trdp->qlen_last_fqs_check = 0;\n\trdp->n_force_qs_snap = READ_ONCE(rcu_state.n_force_qs);\n\trdp->blimit = blimit;\n\trdp->dynticks_nesting = 1;\t/* CPU not up, no tearing. */\n\traw_spin_unlock_rcu_node(rnp);\t\t/* irqs remain disabled. */\n\n\t/*\n\t * Only non-NOCB CPUs that didn't have early-boot callbacks need to be\n\t * (re-)initialized.\n\t */\n\tif (!rcu_segcblist_is_enabled(&rdp->cblist))\n\t\trcu_segcblist_init(&rdp->cblist);  /* Re-enable callbacks. */\n\n\t/*\n\t * Add CPU to leaf rcu_node pending-online bitmask.  Any needed\n\t * propagation up the rcu_node tree will happen at the beginning\n\t * of the next grace period.\n\t */\n\trnp = rdp->mynode;\n\traw_spin_lock_rcu_node(rnp);\t\t/* irqs already disabled. */\n\trdp->beenonline = true;\t /* We have now been online. */\n\trdp->gp_seq = READ_ONCE(rnp->gp_seq);\n\trdp->gp_seq_needed = rdp->gp_seq;\n\trdp->cpu_no_qs.b.norm = true;\n\trdp->core_needs_qs = false;\n\trdp->rcu_iw_pending = false;\n\trdp->rcu_iw = IRQ_WORK_INIT_HARD(rcu_iw_handler);\n\trdp->rcu_iw_gp_seq = rdp->gp_seq - 1;\n\ttrace_rcu_grace_period(rcu_state.name, rdp->gp_seq, TPS(\"cpuonl\"));\n\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\trcu_spawn_one_boost_kthread(rnp);\n\trcu_spawn_cpu_nocb_kthread(cpu);\n\tWRITE_ONCE(rcu_state.n_online_cpus, rcu_state.n_online_cpus + 1);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pm_notifier",
          "args": [
            "rcu_pm_notify",
            "0"
          ],
          "line": 4759
        },
        "resolved": true,
        "details": {
          "function_name": "pm_notifier_call_chain_robust",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/main.c",
          "lines": "83-90",
          "snippet": "int pm_notifier_call_chain_robust(unsigned long val_up, unsigned long val_down)\n{\n\tint ret;\n\n\tret = blocking_notifier_call_chain_robust(&pm_chain_head, val_up, val_down, NULL);\n\n\treturn notifier_to_errno(ret);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/pm_runtime.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/pm-trace.h>",
            "#include <linux/string.h>",
            "#include <linux/kobject.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/pm_runtime.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/workqueue.h>\n#include <linux/pm-trace.h>\n#include <linux/string.h>\n#include <linux/kobject.h>\n#include <linux/export.h>\n\nint pm_notifier_call_chain_robust(unsigned long val_up, unsigned long val_down)\n{\n\tint ret;\n\n\tret = blocking_notifier_call_chain_robust(&pm_chain_head, val_up, val_down, NULL);\n\n\treturn notifier_to_errno(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "open_softirq",
          "args": [
            "RCU_SOFTIRQ",
            "rcu_core_si"
          ],
          "line": 4752
        },
        "resolved": true,
        "details": {
          "function_name": "open_softirq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/softirq.c",
          "lines": "703-706",
          "snippet": "void open_softirq(int nr, void (*action)(struct softirq_action *))\n{\n\tsoftirq_vec[nr].action = action;\n}",
          "includes": [
            "#include <trace/events/irq.h>",
            "#include <asm/softirq_stack.h>",
            "#include <linux/wait_bit.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/smp.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/mm.h>",
            "#include <linux/local_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct softirq_action softirq_vec[NR_SOFTIRQS]"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/irq.h>\n#include <asm/softirq_stack.h>\n#include <linux/wait_bit.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/smpboot.h>\n#include <linux/smp.h>\n#include <linux/ftrace.h>\n#include <linux/rcupdate.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/mm.h>\n#include <linux/local_lock.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/kernel_stat.h>\n#include <linux/export.h>\n\nstatic struct softirq_action softirq_vec[NR_SOFTIRQS];\n\nvoid open_softirq(int nr, void (*action)(struct softirq_action *))\n{\n\tsoftirq_vec[nr].action = action;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_dump_rcu_node_tree",
          "args": [],
          "line": 4750
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_dump_rcu_node_tree",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "4685-4701",
          "snippet": "static void __init rcu_dump_rcu_node_tree(void)\n{\n\tint level = 0;\n\tstruct rcu_node *rnp;\n\n\tpr_info(\"rcu_node tree layout dump\\n\");\n\tpr_info(\" \");\n\trcu_for_each_node_breadth_first(rnp) {\n\t\tif (rnp->level != level) {\n\t\t\tpr_cont(\"\\n\");\n\t\t\tpr_info(\" \");\n\t\t\tlevel = rnp->level;\n\t\t}\n\t\tpr_cont(\"%d:%d ^%d  \", rnp->grplo, rnp->grphi, rnp->grpnum);\n\t}\n\tpr_cont(\"\\n\");\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void check_cb_ovld_locked(struct rcu_data *rdp, struct rcu_node *rnp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic void check_cb_ovld_locked(struct rcu_data *rdp, struct rcu_node *rnp);\n\nstatic void __init rcu_dump_rcu_node_tree(void)\n{\n\tint level = 0;\n\tstruct rcu_node *rnp;\n\n\tpr_info(\"rcu_node tree layout dump\\n\");\n\tpr_info(\" \");\n\trcu_for_each_node_breadth_first(rnp) {\n\t\tif (rnp->level != level) {\n\t\t\tpr_cont(\"\\n\");\n\t\t\tpr_info(\" \");\n\t\t\tlevel = rnp->level;\n\t\t}\n\t\tpr_cont(\"%d:%d ^%d  \", rnp->grplo, rnp->grphi, rnp->grpnum);\n\t}\n\tpr_cont(\"\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_init_one",
          "args": [],
          "line": 4748
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_init_one",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "4508-4585",
          "snippet": "static void __init rcu_init_one(void)\n{\n\tstatic const char * const buf[] = RCU_NODE_NAME_INIT;\n\tstatic const char * const fqs[] = RCU_FQS_NAME_INIT;\n\tstatic struct lock_class_key rcu_node_class[RCU_NUM_LVLS];\n\tstatic struct lock_class_key rcu_fqs_class[RCU_NUM_LVLS];\n\n\tint levelspread[RCU_NUM_LVLS];\t\t/* kids/node in each level. */\n\tint cpustride = 1;\n\tint i;\n\tint j;\n\tstruct rcu_node *rnp;\n\n\tBUILD_BUG_ON(RCU_NUM_LVLS > ARRAY_SIZE(buf));  /* Fix buf[] init! */\n\n\t/* Silence gcc 4.8 false positive about array index out of range. */\n\tif (rcu_num_lvls <= 0 || rcu_num_lvls > RCU_NUM_LVLS)\n\t\tpanic(\"rcu_init_one: rcu_num_lvls out of range\");\n\n\t/* Initialize the level-tracking arrays. */\n\n\tfor (i = 1; i < rcu_num_lvls; i++)\n\t\trcu_state.level[i] =\n\t\t\trcu_state.level[i - 1] + num_rcu_lvl[i - 1];\n\trcu_init_levelspread(levelspread, num_rcu_lvl);\n\n\t/* Initialize the elements themselves, starting from the leaves. */\n\n\tfor (i = rcu_num_lvls - 1; i >= 0; i--) {\n\t\tcpustride *= levelspread[i];\n\t\trnp = rcu_state.level[i];\n\t\tfor (j = 0; j < num_rcu_lvl[i]; j++, rnp++) {\n\t\t\traw_spin_lock_init(&ACCESS_PRIVATE(rnp, lock));\n\t\t\tlockdep_set_class_and_name(&ACCESS_PRIVATE(rnp, lock),\n\t\t\t\t\t\t   &rcu_node_class[i], buf[i]);\n\t\t\traw_spin_lock_init(&rnp->fqslock);\n\t\t\tlockdep_set_class_and_name(&rnp->fqslock,\n\t\t\t\t\t\t   &rcu_fqs_class[i], fqs[i]);\n\t\t\trnp->gp_seq = rcu_state.gp_seq;\n\t\t\trnp->gp_seq_needed = rcu_state.gp_seq;\n\t\t\trnp->completedqs = rcu_state.gp_seq;\n\t\t\trnp->qsmask = 0;\n\t\t\trnp->qsmaskinit = 0;\n\t\t\trnp->grplo = j * cpustride;\n\t\t\trnp->grphi = (j + 1) * cpustride - 1;\n\t\t\tif (rnp->grphi >= nr_cpu_ids)\n\t\t\t\trnp->grphi = nr_cpu_ids - 1;\n\t\t\tif (i == 0) {\n\t\t\t\trnp->grpnum = 0;\n\t\t\t\trnp->grpmask = 0;\n\t\t\t\trnp->parent = NULL;\n\t\t\t} else {\n\t\t\t\trnp->grpnum = j % levelspread[i - 1];\n\t\t\t\trnp->grpmask = BIT(rnp->grpnum);\n\t\t\t\trnp->parent = rcu_state.level[i - 1] +\n\t\t\t\t\t      j / levelspread[i - 1];\n\t\t\t}\n\t\t\trnp->level = i;\n\t\t\tINIT_LIST_HEAD(&rnp->blkd_tasks);\n\t\t\trcu_init_one_nocb(rnp);\n\t\t\tinit_waitqueue_head(&rnp->exp_wq[0]);\n\t\t\tinit_waitqueue_head(&rnp->exp_wq[1]);\n\t\t\tinit_waitqueue_head(&rnp->exp_wq[2]);\n\t\t\tinit_waitqueue_head(&rnp->exp_wq[3]);\n\t\t\tspin_lock_init(&rnp->exp_lock);\n\t\t}\n\t}\n\n\tinit_swait_queue_head(&rcu_state.gp_wq);\n\tinit_swait_queue_head(&rcu_state.expedited_wq);\n\trnp = rcu_first_leaf_node();\n\tfor_each_possible_cpu(i) {\n\t\twhile (i > rnp->grphi)\n\t\t\trnp++;\n\t\tper_cpu_ptr(&rcu_data, i)->mynode = rnp;\n\t\trcu_boot_init_percpu_data(i);\n\t}\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};",
            "static struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};",
            "int rcu_num_lvls",
            "int num_rcu_lvl[] = NUM_RCU_LVL_INIT;",
            "static void check_cb_ovld_locked(struct rcu_data *rdp, struct rcu_node *rnp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};\nstatic struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\nint rcu_num_lvls;\nint num_rcu_lvl[] = NUM_RCU_LVL_INIT;\nstatic void check_cb_ovld_locked(struct rcu_data *rdp, struct rcu_node *rnp);\n\nstatic void __init rcu_init_one(void)\n{\n\tstatic const char * const buf[] = RCU_NODE_NAME_INIT;\n\tstatic const char * const fqs[] = RCU_FQS_NAME_INIT;\n\tstatic struct lock_class_key rcu_node_class[RCU_NUM_LVLS];\n\tstatic struct lock_class_key rcu_fqs_class[RCU_NUM_LVLS];\n\n\tint levelspread[RCU_NUM_LVLS];\t\t/* kids/node in each level. */\n\tint cpustride = 1;\n\tint i;\n\tint j;\n\tstruct rcu_node *rnp;\n\n\tBUILD_BUG_ON(RCU_NUM_LVLS > ARRAY_SIZE(buf));  /* Fix buf[] init! */\n\n\t/* Silence gcc 4.8 false positive about array index out of range. */\n\tif (rcu_num_lvls <= 0 || rcu_num_lvls > RCU_NUM_LVLS)\n\t\tpanic(\"rcu_init_one: rcu_num_lvls out of range\");\n\n\t/* Initialize the level-tracking arrays. */\n\n\tfor (i = 1; i < rcu_num_lvls; i++)\n\t\trcu_state.level[i] =\n\t\t\trcu_state.level[i - 1] + num_rcu_lvl[i - 1];\n\trcu_init_levelspread(levelspread, num_rcu_lvl);\n\n\t/* Initialize the elements themselves, starting from the leaves. */\n\n\tfor (i = rcu_num_lvls - 1; i >= 0; i--) {\n\t\tcpustride *= levelspread[i];\n\t\trnp = rcu_state.level[i];\n\t\tfor (j = 0; j < num_rcu_lvl[i]; j++, rnp++) {\n\t\t\traw_spin_lock_init(&ACCESS_PRIVATE(rnp, lock));\n\t\t\tlockdep_set_class_and_name(&ACCESS_PRIVATE(rnp, lock),\n\t\t\t\t\t\t   &rcu_node_class[i], buf[i]);\n\t\t\traw_spin_lock_init(&rnp->fqslock);\n\t\t\tlockdep_set_class_and_name(&rnp->fqslock,\n\t\t\t\t\t\t   &rcu_fqs_class[i], fqs[i]);\n\t\t\trnp->gp_seq = rcu_state.gp_seq;\n\t\t\trnp->gp_seq_needed = rcu_state.gp_seq;\n\t\t\trnp->completedqs = rcu_state.gp_seq;\n\t\t\trnp->qsmask = 0;\n\t\t\trnp->qsmaskinit = 0;\n\t\t\trnp->grplo = j * cpustride;\n\t\t\trnp->grphi = (j + 1) * cpustride - 1;\n\t\t\tif (rnp->grphi >= nr_cpu_ids)\n\t\t\t\trnp->grphi = nr_cpu_ids - 1;\n\t\t\tif (i == 0) {\n\t\t\t\trnp->grpnum = 0;\n\t\t\t\trnp->grpmask = 0;\n\t\t\t\trnp->parent = NULL;\n\t\t\t} else {\n\t\t\t\trnp->grpnum = j % levelspread[i - 1];\n\t\t\t\trnp->grpmask = BIT(rnp->grpnum);\n\t\t\t\trnp->parent = rcu_state.level[i - 1] +\n\t\t\t\t\t      j / levelspread[i - 1];\n\t\t\t}\n\t\t\trnp->level = i;\n\t\t\tINIT_LIST_HEAD(&rnp->blkd_tasks);\n\t\t\trcu_init_one_nocb(rnp);\n\t\t\tinit_waitqueue_head(&rnp->exp_wq[0]);\n\t\t\tinit_waitqueue_head(&rnp->exp_wq[1]);\n\t\t\tinit_waitqueue_head(&rnp->exp_wq[2]);\n\t\t\tinit_waitqueue_head(&rnp->exp_wq[3]);\n\t\t\tspin_lock_init(&rnp->exp_lock);\n\t\t}\n\t}\n\n\tinit_swait_queue_head(&rcu_state.gp_wq);\n\tinit_swait_queue_head(&rcu_state.expedited_wq);\n\trnp = rcu_first_leaf_node();\n\tfor_each_possible_cpu(i) {\n\t\twhile (i > rnp->grphi)\n\t\t\trnp++;\n\t\tper_cpu_ptr(&rcu_data, i)->mynode = rnp;\n\t\trcu_boot_init_percpu_data(i);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_init_geometry",
          "args": [],
          "line": 4747
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_init_geometry",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "4592-4679",
          "snippet": "void rcu_init_geometry(void)\n{\n\tulong d;\n\tint i;\n\tstatic unsigned long old_nr_cpu_ids;\n\tint rcu_capacity[RCU_NUM_LVLS];\n\tstatic bool initialized;\n\n\tif (initialized) {\n\t\t/*\n\t\t * Warn if setup_nr_cpu_ids() had not yet been invoked,\n\t\t * unless nr_cpus_ids == NR_CPUS, in which case who cares?\n\t\t */\n\t\tWARN_ON_ONCE(old_nr_cpu_ids != nr_cpu_ids);\n\t\treturn;\n\t}\n\n\told_nr_cpu_ids = nr_cpu_ids;\n\tinitialized = true;\n\n\t/*\n\t * Initialize any unspecified boot parameters.\n\t * The default values of jiffies_till_first_fqs and\n\t * jiffies_till_next_fqs are set to the RCU_JIFFIES_TILL_FORCE_QS\n\t * value, which is a function of HZ, then adding one for each\n\t * RCU_JIFFIES_FQS_DIV CPUs that might be on the system.\n\t */\n\td = RCU_JIFFIES_TILL_FORCE_QS + nr_cpu_ids / RCU_JIFFIES_FQS_DIV;\n\tif (jiffies_till_first_fqs == ULONG_MAX)\n\t\tjiffies_till_first_fqs = d;\n\tif (jiffies_till_next_fqs == ULONG_MAX)\n\t\tjiffies_till_next_fqs = d;\n\tadjust_jiffies_till_sched_qs();\n\n\t/* If the compile-time values are accurate, just leave. */\n\tif (rcu_fanout_leaf == RCU_FANOUT_LEAF &&\n\t    nr_cpu_ids == NR_CPUS)\n\t\treturn;\n\tpr_info(\"Adjusting geometry for rcu_fanout_leaf=%d, nr_cpu_ids=%u\\n\",\n\t\trcu_fanout_leaf, nr_cpu_ids);\n\n\t/*\n\t * The boot-time rcu_fanout_leaf parameter must be at least two\n\t * and cannot exceed the number of bits in the rcu_node masks.\n\t * Complain and fall back to the compile-time values if this\n\t * limit is exceeded.\n\t */\n\tif (rcu_fanout_leaf < 2 ||\n\t    rcu_fanout_leaf > sizeof(unsigned long) * 8) {\n\t\trcu_fanout_leaf = RCU_FANOUT_LEAF;\n\t\tWARN_ON(1);\n\t\treturn;\n\t}\n\n\t/*\n\t * Compute number of nodes that can be handled an rcu_node tree\n\t * with the given number of levels.\n\t */\n\trcu_capacity[0] = rcu_fanout_leaf;\n\tfor (i = 1; i < RCU_NUM_LVLS; i++)\n\t\trcu_capacity[i] = rcu_capacity[i - 1] * RCU_FANOUT;\n\n\t/*\n\t * The tree must be able to accommodate the configured number of CPUs.\n\t * If this limit is exceeded, fall back to the compile-time values.\n\t */\n\tif (nr_cpu_ids > rcu_capacity[RCU_NUM_LVLS - 1]) {\n\t\trcu_fanout_leaf = RCU_FANOUT_LEAF;\n\t\tWARN_ON(1);\n\t\treturn;\n\t}\n\n\t/* Calculate the number of levels in the tree. */\n\tfor (i = 0; nr_cpu_ids > rcu_capacity[i]; i++) {\n\t}\n\trcu_num_lvls = i + 1;\n\n\t/* Calculate the number of rcu_nodes at each level of the tree. */\n\tfor (i = 0; i < rcu_num_lvls; i++) {\n\t\tint cap = rcu_capacity[(rcu_num_lvls - 1) - i];\n\t\tnum_rcu_lvl[i] = DIV_ROUND_UP(nr_cpu_ids, cap);\n\t}\n\n\t/* Calculate the total number of rcu_node structures. */\n\trcu_num_nodes = 0;\n\tfor (i = 0; i < rcu_num_lvls; i++)\n\t\trcu_num_nodes += num_rcu_lvl[i];\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int rcu_fanout_leaf = RCU_FANOUT_LEAF;",
            "int rcu_num_lvls",
            "int num_rcu_lvl[] = NUM_RCU_LVL_INIT;",
            "int rcu_num_nodes",
            "static ulong jiffies_till_first_fqs = IS_ENABLED(CONFIG_RCU_STRICT_GRACE_PERIOD) ? 0 : ULONG_MAX;",
            "static ulong jiffies_till_next_fqs = ULONG_MAX;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic int rcu_fanout_leaf = RCU_FANOUT_LEAF;\nint rcu_num_lvls;\nint num_rcu_lvl[] = NUM_RCU_LVL_INIT;\nint rcu_num_nodes;\nstatic ulong jiffies_till_first_fqs = IS_ENABLED(CONFIG_RCU_STRICT_GRACE_PERIOD) ? 0 : ULONG_MAX;\nstatic ulong jiffies_till_next_fqs = ULONG_MAX;\n\nvoid rcu_init_geometry(void)\n{\n\tulong d;\n\tint i;\n\tstatic unsigned long old_nr_cpu_ids;\n\tint rcu_capacity[RCU_NUM_LVLS];\n\tstatic bool initialized;\n\n\tif (initialized) {\n\t\t/*\n\t\t * Warn if setup_nr_cpu_ids() had not yet been invoked,\n\t\t * unless nr_cpus_ids == NR_CPUS, in which case who cares?\n\t\t */\n\t\tWARN_ON_ONCE(old_nr_cpu_ids != nr_cpu_ids);\n\t\treturn;\n\t}\n\n\told_nr_cpu_ids = nr_cpu_ids;\n\tinitialized = true;\n\n\t/*\n\t * Initialize any unspecified boot parameters.\n\t * The default values of jiffies_till_first_fqs and\n\t * jiffies_till_next_fqs are set to the RCU_JIFFIES_TILL_FORCE_QS\n\t * value, which is a function of HZ, then adding one for each\n\t * RCU_JIFFIES_FQS_DIV CPUs that might be on the system.\n\t */\n\td = RCU_JIFFIES_TILL_FORCE_QS + nr_cpu_ids / RCU_JIFFIES_FQS_DIV;\n\tif (jiffies_till_first_fqs == ULONG_MAX)\n\t\tjiffies_till_first_fqs = d;\n\tif (jiffies_till_next_fqs == ULONG_MAX)\n\t\tjiffies_till_next_fqs = d;\n\tadjust_jiffies_till_sched_qs();\n\n\t/* If the compile-time values are accurate, just leave. */\n\tif (rcu_fanout_leaf == RCU_FANOUT_LEAF &&\n\t    nr_cpu_ids == NR_CPUS)\n\t\treturn;\n\tpr_info(\"Adjusting geometry for rcu_fanout_leaf=%d, nr_cpu_ids=%u\\n\",\n\t\trcu_fanout_leaf, nr_cpu_ids);\n\n\t/*\n\t * The boot-time rcu_fanout_leaf parameter must be at least two\n\t * and cannot exceed the number of bits in the rcu_node masks.\n\t * Complain and fall back to the compile-time values if this\n\t * limit is exceeded.\n\t */\n\tif (rcu_fanout_leaf < 2 ||\n\t    rcu_fanout_leaf > sizeof(unsigned long) * 8) {\n\t\trcu_fanout_leaf = RCU_FANOUT_LEAF;\n\t\tWARN_ON(1);\n\t\treturn;\n\t}\n\n\t/*\n\t * Compute number of nodes that can be handled an rcu_node tree\n\t * with the given number of levels.\n\t */\n\trcu_capacity[0] = rcu_fanout_leaf;\n\tfor (i = 1; i < RCU_NUM_LVLS; i++)\n\t\trcu_capacity[i] = rcu_capacity[i - 1] * RCU_FANOUT;\n\n\t/*\n\t * The tree must be able to accommodate the configured number of CPUs.\n\t * If this limit is exceeded, fall back to the compile-time values.\n\t */\n\tif (nr_cpu_ids > rcu_capacity[RCU_NUM_LVLS - 1]) {\n\t\trcu_fanout_leaf = RCU_FANOUT_LEAF;\n\t\tWARN_ON(1);\n\t\treturn;\n\t}\n\n\t/* Calculate the number of levels in the tree. */\n\tfor (i = 0; nr_cpu_ids > rcu_capacity[i]; i++) {\n\t}\n\trcu_num_lvls = i + 1;\n\n\t/* Calculate the number of rcu_nodes at each level of the tree. */\n\tfor (i = 0; i < rcu_num_lvls; i++) {\n\t\tint cap = rcu_capacity[(rcu_num_lvls - 1) - i];\n\t\tnum_rcu_lvl[i] = DIV_ROUND_UP(nr_cpu_ids, cap);\n\t}\n\n\t/* Calculate the total number of rcu_node structures. */\n\trcu_num_nodes = 0;\n\tfor (i = 0; i < rcu_num_lvls; i++)\n\t\trcu_num_nodes += num_rcu_lvl[i];\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_bootup_announce",
          "args": [],
          "line": 4746
        },
        "resolved": true,
        "details": {
          "function_name": "srcu_bootup_announce",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/srcutree.c",
          "lines": "1380-1386",
          "snippet": "static int __init srcu_bootup_announce(void)\n{\n\tpr_info(\"Hierarchical SRCU implementation.\\n\");\n\tif (exp_holdoff != DEFAULT_SRCU_EXP_HOLDOFF)\n\t\tpr_info(\"\\tNon-default auto-expedite holdoff of %lu ns.\\n\", exp_holdoff);\n\treturn 0;\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include \"rcu.h\"",
            "#include <linux/srcu.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [
            "#define DEFAULT_SRCU_EXP_HOLDOFF (25 * 1000)"
          ],
          "globals_used": [
            "static ulong exp_holdoff = DEFAULT_SRCU_EXP_HOLDOFF;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\n#define DEFAULT_SRCU_EXP_HOLDOFF (25 * 1000)\n\nstatic ulong exp_holdoff = DEFAULT_SRCU_EXP_HOLDOFF;\n\nstatic int __init srcu_bootup_announce(void)\n{\n\tpr_info(\"Hierarchical SRCU implementation.\\n\");\n\tif (exp_holdoff != DEFAULT_SRCU_EXP_HOLDOFF)\n\t\tpr_info(\"\\tNon-default auto-expedite holdoff of %lu ns.\\n\", exp_holdoff);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree_rcu_batch_init",
          "args": [],
          "line": 4745
        },
        "resolved": true,
        "details": {
          "function_name": "kfree_rcu_batch_init",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "4706-4737",
          "snippet": "static void __init kfree_rcu_batch_init(void)\n{\n\tint cpu;\n\tint i;\n\n\t/* Clamp it to [0:100] seconds interval. */\n\tif (rcu_delay_page_cache_fill_msec < 0 ||\n\t\trcu_delay_page_cache_fill_msec > 100 * MSEC_PER_SEC) {\n\n\t\trcu_delay_page_cache_fill_msec =\n\t\t\tclamp(rcu_delay_page_cache_fill_msec, 0,\n\t\t\t\t(int) (100 * MSEC_PER_SEC));\n\n\t\tpr_info(\"Adjusting rcutree.rcu_delay_page_cache_fill_msec to %d ms.\\n\",\n\t\t\trcu_delay_page_cache_fill_msec);\n\t}\n\n\tfor_each_possible_cpu(cpu) {\n\t\tstruct kfree_rcu_cpu *krcp = per_cpu_ptr(&krc, cpu);\n\n\t\tfor (i = 0; i < KFREE_N_BATCHES; i++) {\n\t\t\tINIT_RCU_WORK(&krcp->krw_arr[i].rcu_work, kfree_rcu_work);\n\t\t\tkrcp->krw_arr[i].krcp = krcp;\n\t\t}\n\n\t\tINIT_DELAYED_WORK(&krcp->monitor_work, kfree_rcu_monitor);\n\t\tINIT_DELAYED_WORK(&krcp->page_cache_work, fill_page_cache_func);\n\t\tkrcp->initialized = true;\n\t}\n\tif (register_shrinker(&kfree_rcu_shrinker))\n\t\tpr_err(\"Failed to register kfree_rcu() shrinker!\\n\");\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define KFREE_N_BATCHES 2"
          ],
          "globals_used": [
            "static void sync_sched_exp_online_cleanup(int cpu);",
            "static int rcu_delay_page_cache_fill_msec = 5000;",
            "static DEFINE_PER_CPU(struct kfree_rcu_cpu, krc) = {\n\t.lock = __RAW_SPIN_LOCK_UNLOCKED(krc.lock),\n};",
            "static struct shrinker kfree_rcu_shrinker = {\n\t.count_objects = kfree_rcu_shrink_count,\n\t.scan_objects = kfree_rcu_shrink_scan,\n\t.batch = 0,\n\t.seeks = DEFAULT_SEEKS,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define KFREE_N_BATCHES 2\n\nstatic void sync_sched_exp_online_cleanup(int cpu);\nstatic int rcu_delay_page_cache_fill_msec = 5000;\nstatic DEFINE_PER_CPU(struct kfree_rcu_cpu, krc) = {\n\t.lock = __RAW_SPIN_LOCK_UNLOCKED(krc.lock),\n};\nstatic struct shrinker kfree_rcu_shrinker = {\n\t.count_objects = kfree_rcu_shrink_count,\n\t.scan_objects = kfree_rcu_shrink_scan,\n\t.batch = 0,\n\t.seeks = DEFAULT_SEEKS,\n};\n\nstatic void __init kfree_rcu_batch_init(void)\n{\n\tint cpu;\n\tint i;\n\n\t/* Clamp it to [0:100] seconds interval. */\n\tif (rcu_delay_page_cache_fill_msec < 0 ||\n\t\trcu_delay_page_cache_fill_msec > 100 * MSEC_PER_SEC) {\n\n\t\trcu_delay_page_cache_fill_msec =\n\t\t\tclamp(rcu_delay_page_cache_fill_msec, 0,\n\t\t\t\t(int) (100 * MSEC_PER_SEC));\n\n\t\tpr_info(\"Adjusting rcutree.rcu_delay_page_cache_fill_msec to %d ms.\\n\",\n\t\t\trcu_delay_page_cache_fill_msec);\n\t}\n\n\tfor_each_possible_cpu(cpu) {\n\t\tstruct kfree_rcu_cpu *krcp = per_cpu_ptr(&krc, cpu);\n\n\t\tfor (i = 0; i < KFREE_N_BATCHES; i++) {\n\t\t\tINIT_RCU_WORK(&krcp->krw_arr[i].rcu_work, kfree_rcu_work);\n\t\t\tkrcp->krw_arr[i].krcp = krcp;\n\t\t}\n\n\t\tINIT_DELAYED_WORK(&krcp->monitor_work, kfree_rcu_monitor);\n\t\tINIT_DELAYED_WORK(&krcp->page_cache_work, fill_page_cache_func);\n\t\tkrcp->initialized = true;\n\t}\n\tif (register_shrinker(&kfree_rcu_shrinker))\n\t\tpr_err(\"Failed to register kfree_rcu() shrinker!\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_early_boot_tests",
          "args": [],
          "line": 4743
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_early_boot_tests",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "581-581",
          "snippet": "void rcu_early_boot_tests(void) {}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nvoid rcu_early_boot_tests(void) {}"
        }
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define DEFAULT_RCU_QOVLD_MULT 2\n\nstatic bool dump_tree;\nstatic bool use_softirq = !IS_ENABLED(CONFIG_PREEMPT_RT);\nstatic void sync_sched_exp_online_cleanup(int cpu);\nstatic long qhimark = DEFAULT_RCU_QHIMARK;\nstatic long qovld = DEFAULT_RCU_QOVLD;\nstatic long qovld_calc = -1;\nstruct workqueue_struct *rcu_gp_wq;\nstruct workqueue_struct *rcu_par_gp_wq;\n\nvoid __init rcu_init(void)\n{\n\tint cpu;\n\n\trcu_early_boot_tests();\n\n\tkfree_rcu_batch_init();\n\trcu_bootup_announce();\n\trcu_init_geometry();\n\trcu_init_one();\n\tif (dump_tree)\n\t\trcu_dump_rcu_node_tree();\n\tif (use_softirq)\n\t\topen_softirq(RCU_SOFTIRQ, rcu_core_si);\n\n\t/*\n\t * We don't need protection against CPU-hotplug here because\n\t * this is called early in boot, before either interrupts\n\t * or the scheduler are operational.\n\t */\n\tpm_notifier(rcu_pm_notify, 0);\n\tfor_each_online_cpu(cpu) {\n\t\trcutree_prepare_cpu(cpu);\n\t\trcu_cpu_starting(cpu);\n\t\trcutree_online_cpu(cpu);\n\t}\n\n\t/* Create workqueue for Tree SRCU and for expedited GPs. */\n\trcu_gp_wq = alloc_workqueue(\"rcu_gp\", WQ_MEM_RECLAIM, 0);\n\tWARN_ON(!rcu_gp_wq);\n\trcu_par_gp_wq = alloc_workqueue(\"rcu_par_gp\", WQ_MEM_RECLAIM, 0);\n\tWARN_ON(!rcu_par_gp_wq);\n\n\t/* Fill in default value for rcutree.qovld boot parameter. */\n\t/* -After- the rcu_node ->lock fields are initialized! */\n\tif (qovld < 0)\n\t\tqovld_calc = DEFAULT_RCU_QOVLD_MULT * qhimark;\n\telse\n\t\tqovld_calc = qovld;\n}"
  },
  {
    "function_name": "kfree_rcu_batch_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
    "lines": "4706-4737",
    "snippet": "static void __init kfree_rcu_batch_init(void)\n{\n\tint cpu;\n\tint i;\n\n\t/* Clamp it to [0:100] seconds interval. */\n\tif (rcu_delay_page_cache_fill_msec < 0 ||\n\t\trcu_delay_page_cache_fill_msec > 100 * MSEC_PER_SEC) {\n\n\t\trcu_delay_page_cache_fill_msec =\n\t\t\tclamp(rcu_delay_page_cache_fill_msec, 0,\n\t\t\t\t(int) (100 * MSEC_PER_SEC));\n\n\t\tpr_info(\"Adjusting rcutree.rcu_delay_page_cache_fill_msec to %d ms.\\n\",\n\t\t\trcu_delay_page_cache_fill_msec);\n\t}\n\n\tfor_each_possible_cpu(cpu) {\n\t\tstruct kfree_rcu_cpu *krcp = per_cpu_ptr(&krc, cpu);\n\n\t\tfor (i = 0; i < KFREE_N_BATCHES; i++) {\n\t\t\tINIT_RCU_WORK(&krcp->krw_arr[i].rcu_work, kfree_rcu_work);\n\t\t\tkrcp->krw_arr[i].krcp = krcp;\n\t\t}\n\n\t\tINIT_DELAYED_WORK(&krcp->monitor_work, kfree_rcu_monitor);\n\t\tINIT_DELAYED_WORK(&krcp->page_cache_work, fill_page_cache_func);\n\t\tkrcp->initialized = true;\n\t}\n\tif (register_shrinker(&kfree_rcu_shrinker))\n\t\tpr_err(\"Failed to register kfree_rcu() shrinker!\\n\");\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_nocb.h\"",
      "#include \"tree_exp.h\"",
      "#include \"tree_stall.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <linux/kasan.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/panic_notifier.h>",
      "#include <linux/panic.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [
      "#define KFREE_N_BATCHES 2"
    ],
    "globals_used": [
      "static void sync_sched_exp_online_cleanup(int cpu);",
      "static int rcu_delay_page_cache_fill_msec = 5000;",
      "static DEFINE_PER_CPU(struct kfree_rcu_cpu, krc) = {\n\t.lock = __RAW_SPIN_LOCK_UNLOCKED(krc.lock),\n};",
      "static struct shrinker kfree_rcu_shrinker = {\n\t.count_objects = kfree_rcu_shrink_count,\n\t.scan_objects = kfree_rcu_shrink_scan,\n\t.batch = 0,\n\t.seeks = DEFAULT_SEEKS,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Failed to register kfree_rcu() shrinker!\\n\""
          ],
          "line": 4736
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "register_shrinker",
          "args": [
            "&kfree_rcu_shrinker"
          ],
          "line": 4735
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_DELAYED_WORK",
          "args": [
            "&krcp->page_cache_work",
            "fill_page_cache_func"
          ],
          "line": 4732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_DELAYED_WORK",
          "args": [
            "&krcp->monitor_work",
            "kfree_rcu_monitor"
          ],
          "line": 4731
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_RCU_WORK",
          "args": [
            "&krcp->krw_arr[i].rcu_work",
            "kfree_rcu_work"
          ],
          "line": 4727
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "&krc",
            "cpu"
          ],
          "line": 4724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Adjusting rcutree.rcu_delay_page_cache_fill_msec to %d ms.\\n\"",
            "rcu_delay_page_cache_fill_msec"
          ],
          "line": 4719
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clamp",
          "args": [
            "rcu_delay_page_cache_fill_msec",
            "0",
            "(int) (100 * MSEC_PER_SEC)"
          ],
          "line": 4716
        },
        "resolved": true,
        "details": {
          "function_name": "wq_clamp_max_active",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "4254-4264",
          "snippet": "static int wq_clamp_max_active(int max_active, unsigned int flags,\n\t\t\t       const char *name)\n{\n\tint lim = flags & WQ_UNBOUND ? WQ_UNBOUND_MAX_ACTIVE : WQ_MAX_ACTIVE;\n\n\tif (max_active < 1 || max_active > lim)\n\t\tpr_warn(\"workqueue: max_active %d requested for %s is out of range, clamping between %d and %d\\n\",\n\t\t\tmax_active, name, 1, lim);\n\n\treturn clamp_val(max_active, 1, lim);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic int wq_clamp_max_active(int max_active, unsigned int flags,\n\t\t\t       const char *name)\n{\n\tint lim = flags & WQ_UNBOUND ? WQ_UNBOUND_MAX_ACTIVE : WQ_MAX_ACTIVE;\n\n\tif (max_active < 1 || max_active > lim)\n\t\tpr_warn(\"workqueue: max_active %d requested for %s is out of range, clamping between %d and %d\\n\",\n\t\t\tmax_active, name, 1, lim);\n\n\treturn clamp_val(max_active, 1, lim);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define KFREE_N_BATCHES 2\n\nstatic void sync_sched_exp_online_cleanup(int cpu);\nstatic int rcu_delay_page_cache_fill_msec = 5000;\nstatic DEFINE_PER_CPU(struct kfree_rcu_cpu, krc) = {\n\t.lock = __RAW_SPIN_LOCK_UNLOCKED(krc.lock),\n};\nstatic struct shrinker kfree_rcu_shrinker = {\n\t.count_objects = kfree_rcu_shrink_count,\n\t.scan_objects = kfree_rcu_shrink_scan,\n\t.batch = 0,\n\t.seeks = DEFAULT_SEEKS,\n};\n\nstatic void __init kfree_rcu_batch_init(void)\n{\n\tint cpu;\n\tint i;\n\n\t/* Clamp it to [0:100] seconds interval. */\n\tif (rcu_delay_page_cache_fill_msec < 0 ||\n\t\trcu_delay_page_cache_fill_msec > 100 * MSEC_PER_SEC) {\n\n\t\trcu_delay_page_cache_fill_msec =\n\t\t\tclamp(rcu_delay_page_cache_fill_msec, 0,\n\t\t\t\t(int) (100 * MSEC_PER_SEC));\n\n\t\tpr_info(\"Adjusting rcutree.rcu_delay_page_cache_fill_msec to %d ms.\\n\",\n\t\t\trcu_delay_page_cache_fill_msec);\n\t}\n\n\tfor_each_possible_cpu(cpu) {\n\t\tstruct kfree_rcu_cpu *krcp = per_cpu_ptr(&krc, cpu);\n\n\t\tfor (i = 0; i < KFREE_N_BATCHES; i++) {\n\t\t\tINIT_RCU_WORK(&krcp->krw_arr[i].rcu_work, kfree_rcu_work);\n\t\t\tkrcp->krw_arr[i].krcp = krcp;\n\t\t}\n\n\t\tINIT_DELAYED_WORK(&krcp->monitor_work, kfree_rcu_monitor);\n\t\tINIT_DELAYED_WORK(&krcp->page_cache_work, fill_page_cache_func);\n\t\tkrcp->initialized = true;\n\t}\n\tif (register_shrinker(&kfree_rcu_shrinker))\n\t\tpr_err(\"Failed to register kfree_rcu() shrinker!\\n\");\n}"
  },
  {
    "function_name": "rcu_dump_rcu_node_tree",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
    "lines": "4685-4701",
    "snippet": "static void __init rcu_dump_rcu_node_tree(void)\n{\n\tint level = 0;\n\tstruct rcu_node *rnp;\n\n\tpr_info(\"rcu_node tree layout dump\\n\");\n\tpr_info(\" \");\n\trcu_for_each_node_breadth_first(rnp) {\n\t\tif (rnp->level != level) {\n\t\t\tpr_cont(\"\\n\");\n\t\t\tpr_info(\" \");\n\t\t\tlevel = rnp->level;\n\t\t}\n\t\tpr_cont(\"%d:%d ^%d  \", rnp->grplo, rnp->grphi, rnp->grpnum);\n\t}\n\tpr_cont(\"\\n\");\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_nocb.h\"",
      "#include \"tree_exp.h\"",
      "#include \"tree_stall.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <linux/kasan.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/panic_notifier.h>",
      "#include <linux/panic.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void check_cb_ovld_locked(struct rcu_data *rdp, struct rcu_node *rnp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\"\\n\""
          ],
          "line": 4700
        },
        "resolved": true,
        "details": {
          "function_name": "pr_cont_pool_info",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "4715-4721",
          "snippet": "static void pr_cont_pool_info(struct worker_pool *pool)\n{\n\tpr_cont(\" cpus=%*pbl\", nr_cpumask_bits, pool->attrs->cpumask);\n\tif (pool->node != NUMA_NO_NODE)\n\t\tpr_cont(\" node=%d\", pool->node);\n\tpr_cont(\" flags=0x%x nice=%d\", pool->flags, pool->attrs->nice);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
            "static void show_one_worker_pool(struct worker_pool *pool);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nstatic void pr_cont_pool_info(struct worker_pool *pool)\n{\n\tpr_cont(\" cpus=%*pbl\", nr_cpumask_bits, pool->attrs->cpumask);\n\tif (pool->node != NUMA_NO_NODE)\n\t\tpr_cont(\" node=%d\", pool->node);\n\tpr_cont(\" flags=0x%x nice=%d\", pool->flags, pool->attrs->nice);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\"%d:%d ^%d  \"",
            "rnp->grplo",
            "rnp->grphi",
            "rnp->grpnum"
          ],
          "line": 4698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\" \""
          ],
          "line": 4695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\" \""
          ],
          "line": 4691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"rcu_node tree layout dump\\n\""
          ],
          "line": 4690
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic void check_cb_ovld_locked(struct rcu_data *rdp, struct rcu_node *rnp);\n\nstatic void __init rcu_dump_rcu_node_tree(void)\n{\n\tint level = 0;\n\tstruct rcu_node *rnp;\n\n\tpr_info(\"rcu_node tree layout dump\\n\");\n\tpr_info(\" \");\n\trcu_for_each_node_breadth_first(rnp) {\n\t\tif (rnp->level != level) {\n\t\t\tpr_cont(\"\\n\");\n\t\t\tpr_info(\" \");\n\t\t\tlevel = rnp->level;\n\t\t}\n\t\tpr_cont(\"%d:%d ^%d  \", rnp->grplo, rnp->grphi, rnp->grpnum);\n\t}\n\tpr_cont(\"\\n\");\n}"
  },
  {
    "function_name": "rcu_init_geometry",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
    "lines": "4592-4679",
    "snippet": "void rcu_init_geometry(void)\n{\n\tulong d;\n\tint i;\n\tstatic unsigned long old_nr_cpu_ids;\n\tint rcu_capacity[RCU_NUM_LVLS];\n\tstatic bool initialized;\n\n\tif (initialized) {\n\t\t/*\n\t\t * Warn if setup_nr_cpu_ids() had not yet been invoked,\n\t\t * unless nr_cpus_ids == NR_CPUS, in which case who cares?\n\t\t */\n\t\tWARN_ON_ONCE(old_nr_cpu_ids != nr_cpu_ids);\n\t\treturn;\n\t}\n\n\told_nr_cpu_ids = nr_cpu_ids;\n\tinitialized = true;\n\n\t/*\n\t * Initialize any unspecified boot parameters.\n\t * The default values of jiffies_till_first_fqs and\n\t * jiffies_till_next_fqs are set to the RCU_JIFFIES_TILL_FORCE_QS\n\t * value, which is a function of HZ, then adding one for each\n\t * RCU_JIFFIES_FQS_DIV CPUs that might be on the system.\n\t */\n\td = RCU_JIFFIES_TILL_FORCE_QS + nr_cpu_ids / RCU_JIFFIES_FQS_DIV;\n\tif (jiffies_till_first_fqs == ULONG_MAX)\n\t\tjiffies_till_first_fqs = d;\n\tif (jiffies_till_next_fqs == ULONG_MAX)\n\t\tjiffies_till_next_fqs = d;\n\tadjust_jiffies_till_sched_qs();\n\n\t/* If the compile-time values are accurate, just leave. */\n\tif (rcu_fanout_leaf == RCU_FANOUT_LEAF &&\n\t    nr_cpu_ids == NR_CPUS)\n\t\treturn;\n\tpr_info(\"Adjusting geometry for rcu_fanout_leaf=%d, nr_cpu_ids=%u\\n\",\n\t\trcu_fanout_leaf, nr_cpu_ids);\n\n\t/*\n\t * The boot-time rcu_fanout_leaf parameter must be at least two\n\t * and cannot exceed the number of bits in the rcu_node masks.\n\t * Complain and fall back to the compile-time values if this\n\t * limit is exceeded.\n\t */\n\tif (rcu_fanout_leaf < 2 ||\n\t    rcu_fanout_leaf > sizeof(unsigned long) * 8) {\n\t\trcu_fanout_leaf = RCU_FANOUT_LEAF;\n\t\tWARN_ON(1);\n\t\treturn;\n\t}\n\n\t/*\n\t * Compute number of nodes that can be handled an rcu_node tree\n\t * with the given number of levels.\n\t */\n\trcu_capacity[0] = rcu_fanout_leaf;\n\tfor (i = 1; i < RCU_NUM_LVLS; i++)\n\t\trcu_capacity[i] = rcu_capacity[i - 1] * RCU_FANOUT;\n\n\t/*\n\t * The tree must be able to accommodate the configured number of CPUs.\n\t * If this limit is exceeded, fall back to the compile-time values.\n\t */\n\tif (nr_cpu_ids > rcu_capacity[RCU_NUM_LVLS - 1]) {\n\t\trcu_fanout_leaf = RCU_FANOUT_LEAF;\n\t\tWARN_ON(1);\n\t\treturn;\n\t}\n\n\t/* Calculate the number of levels in the tree. */\n\tfor (i = 0; nr_cpu_ids > rcu_capacity[i]; i++) {\n\t}\n\trcu_num_lvls = i + 1;\n\n\t/* Calculate the number of rcu_nodes at each level of the tree. */\n\tfor (i = 0; i < rcu_num_lvls; i++) {\n\t\tint cap = rcu_capacity[(rcu_num_lvls - 1) - i];\n\t\tnum_rcu_lvl[i] = DIV_ROUND_UP(nr_cpu_ids, cap);\n\t}\n\n\t/* Calculate the total number of rcu_node structures. */\n\trcu_num_nodes = 0;\n\tfor (i = 0; i < rcu_num_lvls; i++)\n\t\trcu_num_nodes += num_rcu_lvl[i];\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_nocb.h\"",
      "#include \"tree_exp.h\"",
      "#include \"tree_stall.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <linux/kasan.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/panic_notifier.h>",
      "#include <linux/panic.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int rcu_fanout_leaf = RCU_FANOUT_LEAF;",
      "int rcu_num_lvls",
      "int num_rcu_lvl[] = NUM_RCU_LVL_INIT;",
      "int rcu_num_nodes",
      "static ulong jiffies_till_first_fqs = IS_ENABLED(CONFIG_RCU_STRICT_GRACE_PERIOD) ? 0 : ULONG_MAX;",
      "static ulong jiffies_till_next_fqs = ULONG_MAX;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DIV_ROUND_UP",
          "args": [
            "nr_cpu_ids",
            "cap"
          ],
          "line": 4672
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "1"
          ],
          "line": 4660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "1"
          ],
          "line": 4642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Adjusting geometry for rcu_fanout_leaf=%d, nr_cpu_ids=%u\\n\"",
            "rcu_fanout_leaf",
            "nr_cpu_ids"
          ],
          "line": 4630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "adjust_jiffies_till_sched_qs",
          "args": [],
          "line": 4624
        },
        "resolved": true,
        "details": {
          "function_name": "adjust_jiffies_till_sched_qs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "496-512",
          "snippet": "static void adjust_jiffies_till_sched_qs(void)\n{\n\tunsigned long j;\n\n\t/* If jiffies_till_sched_qs was specified, respect the request. */\n\tif (jiffies_till_sched_qs != ULONG_MAX) {\n\t\tWRITE_ONCE(jiffies_to_sched_qs, jiffies_till_sched_qs);\n\t\treturn;\n\t}\n\t/* Otherwise, set to third fqs scan, but bound below on large system. */\n\tj = READ_ONCE(jiffies_till_first_fqs) +\n\t\t      2 * READ_ONCE(jiffies_till_next_fqs);\n\tif (j < HZ / 10 + nr_cpu_ids / RCU_JIFFIES_FQS_DIV)\n\t\tj = HZ / 10 + nr_cpu_ids / RCU_JIFFIES_FQS_DIV;\n\tpr_info(\"RCU calculated value of scheduler-enlistment delay is %ld jiffies.\\n\", j);\n\tWRITE_ONCE(jiffies_to_sched_qs, j);\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static ulong jiffies_till_first_fqs = IS_ENABLED(CONFIG_RCU_STRICT_GRACE_PERIOD) ? 0 : ULONG_MAX;",
            "static ulong jiffies_till_next_fqs = ULONG_MAX;",
            "static ulong jiffies_till_sched_qs = ULONG_MAX;",
            "static ulong jiffies_to_sched_qs;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic ulong jiffies_till_first_fqs = IS_ENABLED(CONFIG_RCU_STRICT_GRACE_PERIOD) ? 0 : ULONG_MAX;\nstatic ulong jiffies_till_next_fqs = ULONG_MAX;\nstatic ulong jiffies_till_sched_qs = ULONG_MAX;\nstatic ulong jiffies_to_sched_qs;\n\nstatic void adjust_jiffies_till_sched_qs(void)\n{\n\tunsigned long j;\n\n\t/* If jiffies_till_sched_qs was specified, respect the request. */\n\tif (jiffies_till_sched_qs != ULONG_MAX) {\n\t\tWRITE_ONCE(jiffies_to_sched_qs, jiffies_till_sched_qs);\n\t\treturn;\n\t}\n\t/* Otherwise, set to third fqs scan, but bound below on large system. */\n\tj = READ_ONCE(jiffies_till_first_fqs) +\n\t\t      2 * READ_ONCE(jiffies_till_next_fqs);\n\tif (j < HZ / 10 + nr_cpu_ids / RCU_JIFFIES_FQS_DIV)\n\t\tj = HZ / 10 + nr_cpu_ids / RCU_JIFFIES_FQS_DIV;\n\tpr_info(\"RCU calculated value of scheduler-enlistment delay is %ld jiffies.\\n\", j);\n\tWRITE_ONCE(jiffies_to_sched_qs, j);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "old_nr_cpu_ids != nr_cpu_ids"
          ],
          "line": 4605
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic int rcu_fanout_leaf = RCU_FANOUT_LEAF;\nint rcu_num_lvls;\nint num_rcu_lvl[] = NUM_RCU_LVL_INIT;\nint rcu_num_nodes;\nstatic ulong jiffies_till_first_fqs = IS_ENABLED(CONFIG_RCU_STRICT_GRACE_PERIOD) ? 0 : ULONG_MAX;\nstatic ulong jiffies_till_next_fqs = ULONG_MAX;\n\nvoid rcu_init_geometry(void)\n{\n\tulong d;\n\tint i;\n\tstatic unsigned long old_nr_cpu_ids;\n\tint rcu_capacity[RCU_NUM_LVLS];\n\tstatic bool initialized;\n\n\tif (initialized) {\n\t\t/*\n\t\t * Warn if setup_nr_cpu_ids() had not yet been invoked,\n\t\t * unless nr_cpus_ids == NR_CPUS, in which case who cares?\n\t\t */\n\t\tWARN_ON_ONCE(old_nr_cpu_ids != nr_cpu_ids);\n\t\treturn;\n\t}\n\n\told_nr_cpu_ids = nr_cpu_ids;\n\tinitialized = true;\n\n\t/*\n\t * Initialize any unspecified boot parameters.\n\t * The default values of jiffies_till_first_fqs and\n\t * jiffies_till_next_fqs are set to the RCU_JIFFIES_TILL_FORCE_QS\n\t * value, which is a function of HZ, then adding one for each\n\t * RCU_JIFFIES_FQS_DIV CPUs that might be on the system.\n\t */\n\td = RCU_JIFFIES_TILL_FORCE_QS + nr_cpu_ids / RCU_JIFFIES_FQS_DIV;\n\tif (jiffies_till_first_fqs == ULONG_MAX)\n\t\tjiffies_till_first_fqs = d;\n\tif (jiffies_till_next_fqs == ULONG_MAX)\n\t\tjiffies_till_next_fqs = d;\n\tadjust_jiffies_till_sched_qs();\n\n\t/* If the compile-time values are accurate, just leave. */\n\tif (rcu_fanout_leaf == RCU_FANOUT_LEAF &&\n\t    nr_cpu_ids == NR_CPUS)\n\t\treturn;\n\tpr_info(\"Adjusting geometry for rcu_fanout_leaf=%d, nr_cpu_ids=%u\\n\",\n\t\trcu_fanout_leaf, nr_cpu_ids);\n\n\t/*\n\t * The boot-time rcu_fanout_leaf parameter must be at least two\n\t * and cannot exceed the number of bits in the rcu_node masks.\n\t * Complain and fall back to the compile-time values if this\n\t * limit is exceeded.\n\t */\n\tif (rcu_fanout_leaf < 2 ||\n\t    rcu_fanout_leaf > sizeof(unsigned long) * 8) {\n\t\trcu_fanout_leaf = RCU_FANOUT_LEAF;\n\t\tWARN_ON(1);\n\t\treturn;\n\t}\n\n\t/*\n\t * Compute number of nodes that can be handled an rcu_node tree\n\t * with the given number of levels.\n\t */\n\trcu_capacity[0] = rcu_fanout_leaf;\n\tfor (i = 1; i < RCU_NUM_LVLS; i++)\n\t\trcu_capacity[i] = rcu_capacity[i - 1] * RCU_FANOUT;\n\n\t/*\n\t * The tree must be able to accommodate the configured number of CPUs.\n\t * If this limit is exceeded, fall back to the compile-time values.\n\t */\n\tif (nr_cpu_ids > rcu_capacity[RCU_NUM_LVLS - 1]) {\n\t\trcu_fanout_leaf = RCU_FANOUT_LEAF;\n\t\tWARN_ON(1);\n\t\treturn;\n\t}\n\n\t/* Calculate the number of levels in the tree. */\n\tfor (i = 0; nr_cpu_ids > rcu_capacity[i]; i++) {\n\t}\n\trcu_num_lvls = i + 1;\n\n\t/* Calculate the number of rcu_nodes at each level of the tree. */\n\tfor (i = 0; i < rcu_num_lvls; i++) {\n\t\tint cap = rcu_capacity[(rcu_num_lvls - 1) - i];\n\t\tnum_rcu_lvl[i] = DIV_ROUND_UP(nr_cpu_ids, cap);\n\t}\n\n\t/* Calculate the total number of rcu_node structures. */\n\trcu_num_nodes = 0;\n\tfor (i = 0; i < rcu_num_lvls; i++)\n\t\trcu_num_nodes += num_rcu_lvl[i];\n}"
  },
  {
    "function_name": "rcu_init_one",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
    "lines": "4508-4585",
    "snippet": "static void __init rcu_init_one(void)\n{\n\tstatic const char * const buf[] = RCU_NODE_NAME_INIT;\n\tstatic const char * const fqs[] = RCU_FQS_NAME_INIT;\n\tstatic struct lock_class_key rcu_node_class[RCU_NUM_LVLS];\n\tstatic struct lock_class_key rcu_fqs_class[RCU_NUM_LVLS];\n\n\tint levelspread[RCU_NUM_LVLS];\t\t/* kids/node in each level. */\n\tint cpustride = 1;\n\tint i;\n\tint j;\n\tstruct rcu_node *rnp;\n\n\tBUILD_BUG_ON(RCU_NUM_LVLS > ARRAY_SIZE(buf));  /* Fix buf[] init! */\n\n\t/* Silence gcc 4.8 false positive about array index out of range. */\n\tif (rcu_num_lvls <= 0 || rcu_num_lvls > RCU_NUM_LVLS)\n\t\tpanic(\"rcu_init_one: rcu_num_lvls out of range\");\n\n\t/* Initialize the level-tracking arrays. */\n\n\tfor (i = 1; i < rcu_num_lvls; i++)\n\t\trcu_state.level[i] =\n\t\t\trcu_state.level[i - 1] + num_rcu_lvl[i - 1];\n\trcu_init_levelspread(levelspread, num_rcu_lvl);\n\n\t/* Initialize the elements themselves, starting from the leaves. */\n\n\tfor (i = rcu_num_lvls - 1; i >= 0; i--) {\n\t\tcpustride *= levelspread[i];\n\t\trnp = rcu_state.level[i];\n\t\tfor (j = 0; j < num_rcu_lvl[i]; j++, rnp++) {\n\t\t\traw_spin_lock_init(&ACCESS_PRIVATE(rnp, lock));\n\t\t\tlockdep_set_class_and_name(&ACCESS_PRIVATE(rnp, lock),\n\t\t\t\t\t\t   &rcu_node_class[i], buf[i]);\n\t\t\traw_spin_lock_init(&rnp->fqslock);\n\t\t\tlockdep_set_class_and_name(&rnp->fqslock,\n\t\t\t\t\t\t   &rcu_fqs_class[i], fqs[i]);\n\t\t\trnp->gp_seq = rcu_state.gp_seq;\n\t\t\trnp->gp_seq_needed = rcu_state.gp_seq;\n\t\t\trnp->completedqs = rcu_state.gp_seq;\n\t\t\trnp->qsmask = 0;\n\t\t\trnp->qsmaskinit = 0;\n\t\t\trnp->grplo = j * cpustride;\n\t\t\trnp->grphi = (j + 1) * cpustride - 1;\n\t\t\tif (rnp->grphi >= nr_cpu_ids)\n\t\t\t\trnp->grphi = nr_cpu_ids - 1;\n\t\t\tif (i == 0) {\n\t\t\t\trnp->grpnum = 0;\n\t\t\t\trnp->grpmask = 0;\n\t\t\t\trnp->parent = NULL;\n\t\t\t} else {\n\t\t\t\trnp->grpnum = j % levelspread[i - 1];\n\t\t\t\trnp->grpmask = BIT(rnp->grpnum);\n\t\t\t\trnp->parent = rcu_state.level[i - 1] +\n\t\t\t\t\t      j / levelspread[i - 1];\n\t\t\t}\n\t\t\trnp->level = i;\n\t\t\tINIT_LIST_HEAD(&rnp->blkd_tasks);\n\t\t\trcu_init_one_nocb(rnp);\n\t\t\tinit_waitqueue_head(&rnp->exp_wq[0]);\n\t\t\tinit_waitqueue_head(&rnp->exp_wq[1]);\n\t\t\tinit_waitqueue_head(&rnp->exp_wq[2]);\n\t\t\tinit_waitqueue_head(&rnp->exp_wq[3]);\n\t\t\tspin_lock_init(&rnp->exp_lock);\n\t\t}\n\t}\n\n\tinit_swait_queue_head(&rcu_state.gp_wq);\n\tinit_swait_queue_head(&rcu_state.expedited_wq);\n\trnp = rcu_first_leaf_node();\n\tfor_each_possible_cpu(i) {\n\t\twhile (i > rnp->grphi)\n\t\t\trnp++;\n\t\tper_cpu_ptr(&rcu_data, i)->mynode = rnp;\n\t\trcu_boot_init_percpu_data(i);\n\t}\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_nocb.h\"",
      "#include \"tree_exp.h\"",
      "#include \"tree_stall.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <linux/kasan.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/panic_notifier.h>",
      "#include <linux/panic.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};",
      "static struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};",
      "int rcu_num_lvls",
      "int num_rcu_lvl[] = NUM_RCU_LVL_INIT;",
      "static void check_cb_ovld_locked(struct rcu_data *rdp, struct rcu_node *rnp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_boot_init_percpu_data",
          "args": [
            "i"
          ],
          "line": 4583
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_boot_init_percpu_data",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "4133-4149",
          "snippet": "static void __init\nrcu_boot_init_percpu_data(int cpu)\n{\n\tstruct rcu_data *rdp = per_cpu_ptr(&rcu_data, cpu);\n\n\t/* Set up local state, ensuring consistent view of global state. */\n\trdp->grpmask = leaf_node_cpu_bit(rdp->mynode, cpu);\n\tINIT_WORK(&rdp->strict_work, strict_work_handler);\n\tWARN_ON_ONCE(rdp->dynticks_nesting != 1);\n\tWARN_ON_ONCE(rcu_dynticks_in_eqs(rcu_dynticks_snap(rdp)));\n\trdp->rcu_ofl_gp_seq = rcu_state.gp_seq;\n\trdp->rcu_ofl_gp_flags = RCU_GP_CLEANED;\n\trdp->rcu_onl_gp_seq = rcu_state.gp_seq;\n\trdp->rcu_onl_gp_flags = RCU_GP_CLEANED;\n\trdp->cpu = cpu;\n\trcu_boot_init_nocb_percpu_data(rdp);\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};",
            "static struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};",
            "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
            "static void sync_sched_exp_online_cleanup(int cpu);",
            "static bool rcu_rdp_is_offloaded(struct rcu_data *rdp);",
            "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};\nstatic struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void sync_sched_exp_online_cleanup(int cpu);\nstatic bool rcu_rdp_is_offloaded(struct rcu_data *rdp);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nstatic void __init\nrcu_boot_init_percpu_data(int cpu)\n{\n\tstruct rcu_data *rdp = per_cpu_ptr(&rcu_data, cpu);\n\n\t/* Set up local state, ensuring consistent view of global state. */\n\trdp->grpmask = leaf_node_cpu_bit(rdp->mynode, cpu);\n\tINIT_WORK(&rdp->strict_work, strict_work_handler);\n\tWARN_ON_ONCE(rdp->dynticks_nesting != 1);\n\tWARN_ON_ONCE(rcu_dynticks_in_eqs(rcu_dynticks_snap(rdp)));\n\trdp->rcu_ofl_gp_seq = rcu_state.gp_seq;\n\trdp->rcu_ofl_gp_flags = RCU_GP_CLEANED;\n\trdp->rcu_onl_gp_seq = rcu_state.gp_seq;\n\trdp->rcu_onl_gp_flags = RCU_GP_CLEANED;\n\trdp->cpu = cpu;\n\trcu_boot_init_nocb_percpu_data(rdp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "&rcu_data",
            "i"
          ],
          "line": 4582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_first_leaf_node",
          "args": [],
          "line": 4578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_swait_queue_head",
          "args": [
            "&rcu_state.expedited_wq"
          ],
          "line": 4577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_swait_queue_head",
          "args": [
            "&rcu_state.gp_wq"
          ],
          "line": 4576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&rnp->exp_lock"
          ],
          "line": 4572
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_waitqueue_head",
          "args": [
            "&rnp->exp_wq[3]"
          ],
          "line": 4571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_waitqueue_head",
          "args": [
            "&rnp->exp_wq[2]"
          ],
          "line": 4570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_waitqueue_head",
          "args": [
            "&rnp->exp_wq[1]"
          ],
          "line": 4569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_waitqueue_head",
          "args": [
            "&rnp->exp_wq[0]"
          ],
          "line": 4568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_init_one_nocb",
          "args": [
            "rnp"
          ],
          "line": 4567
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_init_one_nocb",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_nocb.h",
          "lines": "1500-1502",
          "snippet": "static void rcu_init_one_nocb(struct rcu_node *rnp)\n{\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static void rcu_init_one_nocb(struct rcu_node *rnp)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&rnp->blkd_tasks"
          ],
          "line": 4566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BIT",
          "args": [
            "rnp->grpnum"
          ],
          "line": 4561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_set_class_and_name",
          "args": [
            "&rnp->fqslock",
            "&rcu_fqs_class[i]",
            "fqs[i]"
          ],
          "line": 4544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_init",
          "args": [
            "&rnp->fqslock"
          ],
          "line": 4543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_set_class_and_name",
          "args": [
            "&ACCESS_PRIVATE(rnp, lock)",
            "&rcu_node_class[i]",
            "buf[i]"
          ],
          "line": 4541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ACCESS_PRIVATE",
          "args": [
            "rnp",
            "lock"
          ],
          "line": 4541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_init",
          "args": [
            "&ACCESS_PRIVATE(rnp, lock)"
          ],
          "line": 4540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ACCESS_PRIVATE",
          "args": [
            "rnp",
            "lock"
          ],
          "line": 4540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_init_levelspread",
          "args": [
            "levelspread",
            "num_rcu_lvl"
          ],
          "line": 4532
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_init_levelspread",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu.h",
          "lines": "288-309",
          "snippet": "static inline void rcu_init_levelspread(int *levelspread, const int *levelcnt)\n{\n\tint i;\n\n\tfor (i = 0; i < RCU_NUM_LVLS; i++)\n\t\tlevelspread[i] = INT_MIN;\n\tif (rcu_fanout_exact) {\n\t\tlevelspread[rcu_num_lvls - 1] = rcu_fanout_leaf;\n\t\tfor (i = rcu_num_lvls - 2; i >= 0; i--)\n\t\t\tlevelspread[i] = RCU_FANOUT;\n\t} else {\n\t\tint ccur;\n\t\tint cprv;\n\n\t\tcprv = nr_cpu_ids;\n\t\tfor (i = rcu_num_lvls - 1; i >= 0; i--) {\n\t\t\tccur = levelcnt[i];\n\t\t\tlevelspread[i] = (cprv + ccur - 1) / ccur;\n\t\t\tcprv = ccur;\n\t\t}\n\t}\n}",
          "includes": [
            "#include <linux/rcu_node_tree.h>",
            "#include <trace/events/rcu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_node_tree.h>\n#include <trace/events/rcu.h>\n\nstatic inline void rcu_init_levelspread(int *levelspread, const int *levelcnt)\n{\n\tint i;\n\n\tfor (i = 0; i < RCU_NUM_LVLS; i++)\n\t\tlevelspread[i] = INT_MIN;\n\tif (rcu_fanout_exact) {\n\t\tlevelspread[rcu_num_lvls - 1] = rcu_fanout_leaf;\n\t\tfor (i = rcu_num_lvls - 2; i >= 0; i--)\n\t\t\tlevelspread[i] = RCU_FANOUT;\n\t} else {\n\t\tint ccur;\n\t\tint cprv;\n\n\t\tcprv = nr_cpu_ids;\n\t\tfor (i = rcu_num_lvls - 1; i >= 0; i--) {\n\t\t\tccur = levelcnt[i];\n\t\t\tlevelspread[i] = (cprv + ccur - 1) / ccur;\n\t\t\tcprv = ccur;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"rcu_init_one: rcu_num_lvls out of range\""
          ],
          "line": 4525
        },
        "resolved": true,
        "details": {
          "function_name": "hardlockup_panic_setup",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/watchdog.c",
          "lines": "74-85",
          "snippet": "static int __init hardlockup_panic_setup(char *str)\n{\n\tif (!strncmp(str, \"panic\", 5))\n\t\thardlockup_panic = 1;\n\telse if (!strncmp(str, \"nopanic\", 7))\n\t\thardlockup_panic = 0;\n\telse if (!strncmp(str, \"0\", 1))\n\t\tnmi_watchdog_user_enabled = 0;\n\telse if (!strncmp(str, \"1\", 1))\n\t\tnmi_watchdog_user_enabled = 1;\n\treturn 1;\n}",
          "includes": [
            "#include <linux/kvm_para.h>",
            "#include <asm/irq_regs.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/tick.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/nmi.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nstatic int __init hardlockup_panic_setup(char *str)\n{\n\tif (!strncmp(str, \"panic\", 5))\n\t\thardlockup_panic = 1;\n\telse if (!strncmp(str, \"nopanic\", 7))\n\t\thardlockup_panic = 0;\n\telse if (!strncmp(str, \"0\", 1))\n\t\tnmi_watchdog_user_enabled = 0;\n\telse if (!strncmp(str, \"1\", 1))\n\t\tnmi_watchdog_user_enabled = 1;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "RCU_NUM_LVLS > ARRAY_SIZE(buf)"
          ],
          "line": 4521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "buf"
          ],
          "line": 4521
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};\nstatic struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\nint rcu_num_lvls;\nint num_rcu_lvl[] = NUM_RCU_LVL_INIT;\nstatic void check_cb_ovld_locked(struct rcu_data *rdp, struct rcu_node *rnp);\n\nstatic void __init rcu_init_one(void)\n{\n\tstatic const char * const buf[] = RCU_NODE_NAME_INIT;\n\tstatic const char * const fqs[] = RCU_FQS_NAME_INIT;\n\tstatic struct lock_class_key rcu_node_class[RCU_NUM_LVLS];\n\tstatic struct lock_class_key rcu_fqs_class[RCU_NUM_LVLS];\n\n\tint levelspread[RCU_NUM_LVLS];\t\t/* kids/node in each level. */\n\tint cpustride = 1;\n\tint i;\n\tint j;\n\tstruct rcu_node *rnp;\n\n\tBUILD_BUG_ON(RCU_NUM_LVLS > ARRAY_SIZE(buf));  /* Fix buf[] init! */\n\n\t/* Silence gcc 4.8 false positive about array index out of range. */\n\tif (rcu_num_lvls <= 0 || rcu_num_lvls > RCU_NUM_LVLS)\n\t\tpanic(\"rcu_init_one: rcu_num_lvls out of range\");\n\n\t/* Initialize the level-tracking arrays. */\n\n\tfor (i = 1; i < rcu_num_lvls; i++)\n\t\trcu_state.level[i] =\n\t\t\trcu_state.level[i - 1] + num_rcu_lvl[i - 1];\n\trcu_init_levelspread(levelspread, num_rcu_lvl);\n\n\t/* Initialize the elements themselves, starting from the leaves. */\n\n\tfor (i = rcu_num_lvls - 1; i >= 0; i--) {\n\t\tcpustride *= levelspread[i];\n\t\trnp = rcu_state.level[i];\n\t\tfor (j = 0; j < num_rcu_lvl[i]; j++, rnp++) {\n\t\t\traw_spin_lock_init(&ACCESS_PRIVATE(rnp, lock));\n\t\t\tlockdep_set_class_and_name(&ACCESS_PRIVATE(rnp, lock),\n\t\t\t\t\t\t   &rcu_node_class[i], buf[i]);\n\t\t\traw_spin_lock_init(&rnp->fqslock);\n\t\t\tlockdep_set_class_and_name(&rnp->fqslock,\n\t\t\t\t\t\t   &rcu_fqs_class[i], fqs[i]);\n\t\t\trnp->gp_seq = rcu_state.gp_seq;\n\t\t\trnp->gp_seq_needed = rcu_state.gp_seq;\n\t\t\trnp->completedqs = rcu_state.gp_seq;\n\t\t\trnp->qsmask = 0;\n\t\t\trnp->qsmaskinit = 0;\n\t\t\trnp->grplo = j * cpustride;\n\t\t\trnp->grphi = (j + 1) * cpustride - 1;\n\t\t\tif (rnp->grphi >= nr_cpu_ids)\n\t\t\t\trnp->grphi = nr_cpu_ids - 1;\n\t\t\tif (i == 0) {\n\t\t\t\trnp->grpnum = 0;\n\t\t\t\trnp->grpmask = 0;\n\t\t\t\trnp->parent = NULL;\n\t\t\t} else {\n\t\t\t\trnp->grpnum = j % levelspread[i - 1];\n\t\t\t\trnp->grpmask = BIT(rnp->grpnum);\n\t\t\t\trnp->parent = rcu_state.level[i - 1] +\n\t\t\t\t\t      j / levelspread[i - 1];\n\t\t\t}\n\t\t\trnp->level = i;\n\t\t\tINIT_LIST_HEAD(&rnp->blkd_tasks);\n\t\t\trcu_init_one_nocb(rnp);\n\t\t\tinit_waitqueue_head(&rnp->exp_wq[0]);\n\t\t\tinit_waitqueue_head(&rnp->exp_wq[1]);\n\t\t\tinit_waitqueue_head(&rnp->exp_wq[2]);\n\t\t\tinit_waitqueue_head(&rnp->exp_wq[3]);\n\t\t\tspin_lock_init(&rnp->exp_lock);\n\t\t}\n\t}\n\n\tinit_swait_queue_head(&rcu_state.gp_wq);\n\tinit_swait_queue_head(&rcu_state.expedited_wq);\n\trnp = rcu_first_leaf_node();\n\tfor_each_possible_cpu(i) {\n\t\twhile (i > rnp->grphi)\n\t\t\trnp++;\n\t\tper_cpu_ptr(&rcu_data, i)->mynode = rnp;\n\t\trcu_boot_init_percpu_data(i);\n\t}\n}"
  },
  {
    "function_name": "rcu_scheduler_starting",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
    "lines": "4496-4503",
    "snippet": "void rcu_scheduler_starting(void)\n{\n\tWARN_ON(num_online_cpus() != 1);\n\tWARN_ON(nr_context_switches() > 0);\n\trcu_test_sync_prims();\n\trcu_scheduler_active = RCU_SCHEDULER_INIT;\n\trcu_test_sync_prims();\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_nocb.h\"",
      "#include \"tree_exp.h\"",
      "#include \"tree_stall.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <linux/kasan.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/panic_notifier.h>",
      "#include <linux/panic.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int rcu_scheduler_active"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_test_sync_prims",
          "args": [],
          "line": 4502
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_test_sync_prims",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "219-225",
          "snippet": "void rcu_test_sync_prims(void)\n{\n\tif (!IS_ENABLED(CONFIG_PROVE_RCU))\n\t\treturn;\n\tsynchronize_rcu();\n\tsynchronize_rcu_expedited();\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nvoid rcu_test_sync_prims(void)\n{\n\tif (!IS_ENABLED(CONFIG_PROVE_RCU))\n\t\treturn;\n\tsynchronize_rcu();\n\tsynchronize_rcu_expedited();\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "nr_context_switches() > 0"
          ],
          "line": 4499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nr_context_switches",
          "args": [],
          "line": 4499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "num_online_cpus() != 1"
          ],
          "line": 4498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "num_online_cpus",
          "args": [],
          "line": 4498
        },
        "resolved": true,
        "details": {
          "function_name": "torture_num_online_cpus",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/torture.c",
          "lines": "185-188",
          "snippet": "int torture_num_online_cpus(void)\n{\n\treturn READ_ONCE(torture_online_cpus);\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint torture_num_online_cpus(void)\n{\n\treturn READ_ONCE(torture_online_cpus);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_scheduler_active;\n\nvoid rcu_scheduler_starting(void)\n{\n\tWARN_ON(num_online_cpus() != 1);\n\tWARN_ON(nr_context_switches() > 0);\n\trcu_test_sync_prims();\n\trcu_scheduler_active = RCU_SCHEDULER_INIT;\n\trcu_test_sync_prims();\n}"
  },
  {
    "function_name": "rcu_spawn_gp_kthread",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
    "lines": "4440-4483",
    "snippet": "static int __init rcu_spawn_gp_kthread(void)\n{\n\tunsigned long flags;\n\tint kthread_prio_in = kthread_prio;\n\tstruct rcu_node *rnp;\n\tstruct sched_param sp;\n\tstruct task_struct *t;\n\n\t/* Force priority into range. */\n\tif (IS_ENABLED(CONFIG_RCU_BOOST) && kthread_prio < 2\n\t    && IS_BUILTIN(CONFIG_RCU_TORTURE_TEST))\n\t\tkthread_prio = 2;\n\telse if (IS_ENABLED(CONFIG_RCU_BOOST) && kthread_prio < 1)\n\t\tkthread_prio = 1;\n\telse if (kthread_prio < 0)\n\t\tkthread_prio = 0;\n\telse if (kthread_prio > 99)\n\t\tkthread_prio = 99;\n\n\tif (kthread_prio != kthread_prio_in)\n\t\tpr_alert(\"rcu_spawn_gp_kthread(): Limited prio to %d from %d\\n\",\n\t\t\t kthread_prio, kthread_prio_in);\n\n\trcu_scheduler_fully_active = 1;\n\tt = kthread_create(rcu_gp_kthread, NULL, \"%s\", rcu_state.name);\n\tif (WARN_ONCE(IS_ERR(t), \"%s: Could not start grace-period kthread, OOM is now expected behavior\\n\", __func__))\n\t\treturn 0;\n\tif (kthread_prio) {\n\t\tsp.sched_priority = kthread_prio;\n\t\tsched_setscheduler_nocheck(t, SCHED_FIFO, &sp);\n\t}\n\trnp = rcu_get_root();\n\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\tWRITE_ONCE(rcu_state.gp_activity, jiffies);\n\tWRITE_ONCE(rcu_state.gp_req_activity, jiffies);\n\t// Reset .gp_activity and .gp_req_activity before setting .gp_kthread.\n\tsmp_store_release(&rcu_state.gp_kthread, t);  /* ^^^ */\n\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\twake_up_process(t);\n\trcu_spawn_nocb_kthreads();\n\trcu_spawn_boost_kthreads();\n\trcu_spawn_core_kthreads();\n\treturn 0;\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_nocb.h\"",
      "#include \"tree_exp.h\"",
      "#include \"tree_stall.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <linux/kasan.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/panic_notifier.h>",
      "#include <linux/panic.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};",
      "static int rcu_scheduler_fully_active",
      "static void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);",
      "static void check_cb_ovld_locked(struct rcu_data *rdp, struct rcu_node *rnp);",
      "static int kthread_prio = IS_ENABLED(CONFIG_RCU_BOOST) ? 1 : 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_spawn_core_kthreads",
          "args": [],
          "line": 4481
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_spawn_core_kthreads",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "2891-2902",
          "snippet": "static int __init rcu_spawn_core_kthreads(void)\n{\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu)\n\t\tper_cpu(rcu_data.rcu_cpu_has_work, cpu) = 0;\n\tif (!IS_ENABLED(CONFIG_RCU_BOOST) && use_softirq)\n\t\treturn 0;\n\tWARN_ONCE(smpboot_register_percpu_thread(&rcu_cpu_thread_spec),\n\t\t  \"%s: Could not start rcuc kthread, OOM is now expected behavior\\n\", __func__);\n\treturn 0;\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};",
            "static bool use_softirq = !IS_ENABLED(CONFIG_PREEMPT_RT);",
            "static void sync_sched_exp_online_cleanup(int cpu);",
            "static struct smp_hotplug_thread rcu_cpu_thread_spec = {\n\t.store\t\t\t= &rcu_data.rcu_cpu_kthread_task,\n\t.thread_should_run\t= rcu_cpu_kthread_should_run,\n\t.thread_fn\t\t= rcu_cpu_kthread,\n\t.thread_comm\t\t= \"rcuc/%u\",\n\t.setup\t\t\t= rcu_cpu_kthread_setup,\n\t.park\t\t\t= rcu_cpu_kthread_park,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};\nstatic bool use_softirq = !IS_ENABLED(CONFIG_PREEMPT_RT);\nstatic void sync_sched_exp_online_cleanup(int cpu);\nstatic struct smp_hotplug_thread rcu_cpu_thread_spec = {\n\t.store\t\t\t= &rcu_data.rcu_cpu_kthread_task,\n\t.thread_should_run\t= rcu_cpu_kthread_should_run,\n\t.thread_fn\t\t= rcu_cpu_kthread,\n\t.thread_comm\t\t= \"rcuc/%u\",\n\t.setup\t\t\t= rcu_cpu_kthread_setup,\n\t.park\t\t\t= rcu_cpu_kthread_park,\n};\n\nstatic int __init rcu_spawn_core_kthreads(void)\n{\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu)\n\t\tper_cpu(rcu_data.rcu_cpu_has_work, cpu) = 0;\n\tif (!IS_ENABLED(CONFIG_RCU_BOOST) && use_softirq)\n\t\treturn 0;\n\tWARN_ONCE(smpboot_register_percpu_thread(&rcu_cpu_thread_spec),\n\t\t  \"%s: Could not start rcuc kthread, OOM is now expected behavior\\n\", __func__);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_spawn_boost_kthreads",
          "args": [],
          "line": 4480
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_spawn_boost_kthreads",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "1261-1263",
          "snippet": "static void __init rcu_spawn_boost_kthreads(void)\n{\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nstatic void __init rcu_spawn_boost_kthreads(void)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_spawn_nocb_kthreads",
          "args": [],
          "line": 4479
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_spawn_nocb_kthreads",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_nocb.h",
          "lines": "1540-1542",
          "snippet": "static void __init rcu_spawn_nocb_kthreads(void)\n{\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static void __init rcu_spawn_nocb_kthreads(void)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "wake_up_process",
          "args": [
            "t"
          ],
          "line": 4478
        },
        "resolved": true,
        "details": {
          "function_name": "wake_up_process",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "4215-4218",
          "snippet": "int wake_up_process(struct task_struct *p)\n{\n\treturn try_to_wake_up(p, TASK_NORMAL, 0);\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\nint wake_up_process(struct task_struct *p)\n{\n\treturn try_to_wake_up(p, TASK_NORMAL, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore_rcu_node",
          "args": [
            "rnp",
            "flags"
          ],
          "line": 4477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_store_release",
          "args": [
            "&rcu_state.gp_kthread",
            "t"
          ],
          "line": 4476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "rcu_state.gp_req_activity",
            "jiffies"
          ],
          "line": 4474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "rcu_state.gp_activity",
            "jiffies"
          ],
          "line": 4473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave_rcu_node",
          "args": [
            "rnp",
            "flags"
          ],
          "line": 4472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_get_root",
          "args": [],
          "line": 4471
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_get_root",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "579-582",
          "snippet": "static struct rcu_node *rcu_get_root(void)\n{\n\treturn &rcu_state.node[0];\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\n\nstatic struct rcu_node *rcu_get_root(void)\n{\n\treturn &rcu_state.node[0];\n}"
        }
      },
      {
        "call_info": {
          "callee": "sched_setscheduler_nocheck",
          "args": [
            "t",
            "SCHED_FIFO",
            "&sp"
          ],
          "line": 4469
        },
        "resolved": true,
        "details": {
          "function_name": "sched_setscheduler_nocheck",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "7565-7569",
          "snippet": "int sched_setscheduler_nocheck(struct task_struct *p, int policy,\n\t\t\t       const struct sched_param *param)\n{\n\treturn _sched_setscheduler(p, policy, param, false);\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\nint sched_setscheduler_nocheck(struct task_struct *p, int policy,\n\t\t\t       const struct sched_param *param)\n{\n\treturn _sched_setscheduler(p, policy, param, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ONCE",
          "args": [
            "IS_ERR(t)",
            "\"%s: Could not start grace-period kthread, OOM is now expected behavior\\n\"",
            "__func__"
          ],
          "line": 4465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "t"
          ],
          "line": 4465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kthread_create",
          "args": [
            "rcu_gp_kthread",
            "NULL",
            "\"%s\"",
            "rcu_state.name"
          ],
          "line": 4464
        },
        "resolved": true,
        "details": {
          "function_name": "kthread_create_worker",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
          "lines": "882-893",
          "snippet": "struct kthread_worker *\nkthread_create_worker(unsigned int flags, const char namefmt[], ...)\n{\n\tstruct kthread_worker *worker;\n\tva_list args;\n\n\tva_start(args, namefmt);\n\tworker = __kthread_create_worker(-1, flags, namefmt, args);\n\tva_end(args);\n\n\treturn worker;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/numa.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mm.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __printf(4, 0)\nstruct task_struct *__kthread_create_on_node(int (*threadfn)(void *data),\n\t\t\t\t\t\t    void *data, int node,\n\t\t\t\t\t\t    const char namefmt[],\n\t\t\t\t\t\t    va_list args)\n{\n\tDECLARE_COMPLETION_ONSTACK(done);\n\tstruct task_struct *task;",
            "static __printf(3, 0) struct kthread_worker *\n__kthread_create_worker(int cpu, unsigned int flags,\n\t\t\tconst char namefmt[], va_list args)\n{\n\tstruct kthread_worker *worker;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nstatic __printf(4, 0)\nstruct task_struct *__kthread_create_on_node(int (*threadfn)(void *data),\n\t\t\t\t\t\t    void *data, int node,\n\t\t\t\t\t\t    const char namefmt[],\n\t\t\t\t\t\t    va_list args)\n{\n\tDECLARE_COMPLETION_ONSTACK(done);\n\tstruct task_struct *task;\nstatic __printf(3, 0) struct kthread_worker *\n__kthread_create_worker(int cpu, unsigned int flags,\n\t\t\tconst char namefmt[], va_list args)\n{\n\tstruct kthread_worker *worker;\n\nstruct kthread_worker *\nkthread_create_worker(unsigned int flags, const char namefmt[], ...)\n{\n\tstruct kthread_worker *worker;\n\tva_list args;\n\n\tva_start(args, namefmt);\n\tworker = __kthread_create_worker(-1, flags, namefmt, args);\n\tva_end(args);\n\n\treturn worker;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_alert",
          "args": [
            "\"rcu_spawn_gp_kthread(): Limited prio to %d from %d\\n\"",
            "kthread_prio",
            "kthread_prio_in"
          ],
          "line": 4460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_RCU_BOOST"
          ],
          "line": 4452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_BUILTIN",
          "args": [
            "CONFIG_RCU_TORTURE_TEST"
          ],
          "line": 4450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_RCU_BOOST"
          ],
          "line": 4449
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\nstatic int rcu_scheduler_fully_active;\nstatic void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);\nstatic void check_cb_ovld_locked(struct rcu_data *rdp, struct rcu_node *rnp);\nstatic int kthread_prio = IS_ENABLED(CONFIG_RCU_BOOST) ? 1 : 0;\n\nstatic int __init rcu_spawn_gp_kthread(void)\n{\n\tunsigned long flags;\n\tint kthread_prio_in = kthread_prio;\n\tstruct rcu_node *rnp;\n\tstruct sched_param sp;\n\tstruct task_struct *t;\n\n\t/* Force priority into range. */\n\tif (IS_ENABLED(CONFIG_RCU_BOOST) && kthread_prio < 2\n\t    && IS_BUILTIN(CONFIG_RCU_TORTURE_TEST))\n\t\tkthread_prio = 2;\n\telse if (IS_ENABLED(CONFIG_RCU_BOOST) && kthread_prio < 1)\n\t\tkthread_prio = 1;\n\telse if (kthread_prio < 0)\n\t\tkthread_prio = 0;\n\telse if (kthread_prio > 99)\n\t\tkthread_prio = 99;\n\n\tif (kthread_prio != kthread_prio_in)\n\t\tpr_alert(\"rcu_spawn_gp_kthread(): Limited prio to %d from %d\\n\",\n\t\t\t kthread_prio, kthread_prio_in);\n\n\trcu_scheduler_fully_active = 1;\n\tt = kthread_create(rcu_gp_kthread, NULL, \"%s\", rcu_state.name);\n\tif (WARN_ONCE(IS_ERR(t), \"%s: Could not start grace-period kthread, OOM is now expected behavior\\n\", __func__))\n\t\treturn 0;\n\tif (kthread_prio) {\n\t\tsp.sched_priority = kthread_prio;\n\t\tsched_setscheduler_nocheck(t, SCHED_FIFO, &sp);\n\t}\n\trnp = rcu_get_root();\n\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\tWRITE_ONCE(rcu_state.gp_activity, jiffies);\n\tWRITE_ONCE(rcu_state.gp_req_activity, jiffies);\n\t// Reset .gp_activity and .gp_req_activity before setting .gp_kthread.\n\tsmp_store_release(&rcu_state.gp_kthread, t);  /* ^^^ */\n\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\twake_up_process(t);\n\trcu_spawn_nocb_kthreads();\n\trcu_spawn_boost_kthreads();\n\trcu_spawn_core_kthreads();\n\treturn 0;\n}"
  },
  {
    "function_name": "rcu_pm_notify",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
    "lines": "4419-4435",
    "snippet": "static int rcu_pm_notify(struct notifier_block *self,\n\t\t\t unsigned long action, void *hcpu)\n{\n\tswitch (action) {\n\tcase PM_HIBERNATION_PREPARE:\n\tcase PM_SUSPEND_PREPARE:\n\t\trcu_expedite_gp();\n\t\tbreak;\n\tcase PM_POST_HIBERNATION:\n\tcase PM_POST_SUSPEND:\n\t\trcu_unexpedite_gp();\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn NOTIFY_OK;\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_nocb.h\"",
      "#include \"tree_exp.h\"",
      "#include \"tree_stall.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <linux/kasan.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/panic_notifier.h>",
      "#include <linux/panic.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_unexpedite_gp",
          "args": [],
          "line": 4429
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_unexpedite_gp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "184-187",
          "snippet": "void rcu_unexpedite_gp(void)\n{\n\tatomic_dec(&rcu_expedited_nesting);\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nvoid rcu_unexpedite_gp(void)\n{\n\tatomic_dec(&rcu_expedited_nesting);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_expedite_gp",
          "args": [],
          "line": 4425
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_expedite_gp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "169-172",
          "snippet": "void rcu_expedite_gp(void)\n{\n\tatomic_inc(&rcu_expedited_nesting);\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nvoid rcu_expedite_gp(void)\n{\n\tatomic_inc(&rcu_expedited_nesting);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic int rcu_pm_notify(struct notifier_block *self,\n\t\t\t unsigned long action, void *hcpu)\n{\n\tswitch (action) {\n\tcase PM_HIBERNATION_PREPARE:\n\tcase PM_SUSPEND_PREPARE:\n\t\trcu_expedite_gp();\n\t\tbreak;\n\tcase PM_POST_HIBERNATION:\n\tcase PM_POST_SUSPEND:\n\t\trcu_unexpedite_gp();\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn NOTIFY_OK;\n}"
  },
  {
    "function_name": "rcutree_migrate_callbacks",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
    "lines": "4371-4412",
    "snippet": "void rcutree_migrate_callbacks(int cpu)\n{\n\tunsigned long flags;\n\tstruct rcu_data *my_rdp;\n\tstruct rcu_node *my_rnp;\n\tstruct rcu_data *rdp = per_cpu_ptr(&rcu_data, cpu);\n\tbool needwake;\n\n\tif (rcu_rdp_is_offloaded(rdp) ||\n\t    rcu_segcblist_empty(&rdp->cblist))\n\t\treturn;  /* No callbacks to migrate. */\n\n\tlocal_irq_save(flags);\n\tmy_rdp = this_cpu_ptr(&rcu_data);\n\tmy_rnp = my_rdp->mynode;\n\trcu_nocb_lock(my_rdp); /* irqs already disabled. */\n\tWARN_ON_ONCE(!rcu_nocb_flush_bypass(my_rdp, NULL, jiffies));\n\traw_spin_lock_rcu_node(my_rnp); /* irqs already disabled. */\n\t/* Leverage recent GPs and set GP for new callbacks. */\n\tneedwake = rcu_advance_cbs(my_rnp, rdp) ||\n\t\t   rcu_advance_cbs(my_rnp, my_rdp);\n\trcu_segcblist_merge(&my_rdp->cblist, &rdp->cblist);\n\tneedwake = needwake || rcu_advance_cbs(my_rnp, my_rdp);\n\trcu_segcblist_disable(&rdp->cblist);\n\tWARN_ON_ONCE(rcu_segcblist_empty(&my_rdp->cblist) !=\n\t\t     !rcu_segcblist_n_cbs(&my_rdp->cblist));\n\tif (rcu_rdp_is_offloaded(my_rdp)) {\n\t\traw_spin_unlock_rcu_node(my_rnp); /* irqs remain disabled. */\n\t\t__call_rcu_nocb_wake(my_rdp, true, flags);\n\t} else {\n\t\trcu_nocb_unlock(my_rdp); /* irqs remain disabled. */\n\t\traw_spin_unlock_irqrestore_rcu_node(my_rnp, flags);\n\t}\n\tif (needwake)\n\t\trcu_gp_kthread_wake();\n\tlockdep_assert_irqs_enabled();\n\tWARN_ONCE(rcu_segcblist_n_cbs(&rdp->cblist) != 0 ||\n\t\t  !rcu_segcblist_empty(&rdp->cblist),\n\t\t  \"rcu_cleanup_dead_cpu: Callbacks on offline CPU %d: qlen=%lu, 1stCB=%p\\n\",\n\t\t  cpu, rcu_segcblist_n_cbs(&rdp->cblist),\n\t\t  rcu_segcblist_first_cb(&rdp->cblist));\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_nocb.h\"",
      "#include \"tree_exp.h\"",
      "#include \"tree_stall.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <linux/kasan.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/panic_notifier.h>",
      "#include <linux/panic.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};",
      "static void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);",
      "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
      "static void sync_sched_exp_online_cleanup(int cpu);",
      "static bool rcu_rdp_is_offloaded(struct rcu_data *rdp);",
      "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ONCE",
          "args": [
            "rcu_segcblist_n_cbs(&rdp->cblist) != 0 ||\n\t\t  !rcu_segcblist_empty(&rdp->cblist)",
            "\"rcu_cleanup_dead_cpu: Callbacks on offline CPU %d: qlen=%lu, 1stCB=%p\\n\"",
            "cpu",
            "rcu_segcblist_n_cbs(&rdp->cblist)",
            "rcu_segcblist_first_cb(&rdp->cblist)"
          ],
          "line": 4407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_segcblist_first_cb",
          "args": [
            "&rdp->cblist"
          ],
          "line": 4411
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_first_cb",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.c",
          "lines": "298-303",
          "snippet": "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp)\n{\n\tif (rcu_segcblist_is_enabled(rsclp))\n\t\treturn rsclp->head;\n\treturn NULL;\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/cpu.h>\n\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp)\n{\n\tif (rcu_segcblist_is_enabled(rsclp))\n\t\treturn rsclp->head;\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_segcblist_n_cbs",
          "args": [
            "&rdp->cblist"
          ],
          "line": 4410
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_n_cbs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "47-54",
          "snippet": "static inline long rcu_segcblist_n_cbs(struct rcu_segcblist *rsclp)\n{\n#ifdef CONFIG_RCU_NOCB_CPU\n\treturn atomic_long_read(&rsclp->len);\n#else\n\treturn READ_ONCE(rsclp->len);\n#endif\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "long rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nlong rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline long rcu_segcblist_n_cbs(struct rcu_segcblist *rsclp)\n{\n#ifdef CONFIG_RCU_NOCB_CPU\n\treturn atomic_long_read(&rsclp->len);\n#else\n\treturn READ_ONCE(rsclp->len);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_segcblist_empty",
          "args": [
            "&rdp->cblist"
          ],
          "line": 4408
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "41-44",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "long rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nlong rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_assert_irqs_enabled",
          "args": [],
          "line": 4406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_gp_kthread_wake",
          "args": [],
          "line": 4405
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_gp_kthread_wake",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "1473-1483",
          "snippet": "static void rcu_gp_kthread_wake(void)\n{\n\tstruct task_struct *t = READ_ONCE(rcu_state.gp_kthread);\n\n\tif ((current == t && !in_hardirq() && !in_serving_softirq()) ||\n\t    !READ_ONCE(rcu_state.gp_flags) || !t)\n\t\treturn;\n\tWRITE_ONCE(rcu_state.gp_wake_time, jiffies);\n\tWRITE_ONCE(rcu_state.gp_wake_seq, READ_ONCE(rcu_state.gp_seq));\n\tswake_up_one(&rcu_state.gp_wq);\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\n\nstatic void rcu_gp_kthread_wake(void)\n{\n\tstruct task_struct *t = READ_ONCE(rcu_state.gp_kthread);\n\n\tif ((current == t && !in_hardirq() && !in_serving_softirq()) ||\n\t    !READ_ONCE(rcu_state.gp_flags) || !t)\n\t\treturn;\n\tWRITE_ONCE(rcu_state.gp_wake_time, jiffies);\n\tWRITE_ONCE(rcu_state.gp_wake_seq, READ_ONCE(rcu_state.gp_seq));\n\tswake_up_one(&rcu_state.gp_wq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore_rcu_node",
          "args": [
            "my_rnp",
            "flags"
          ],
          "line": 4402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_nocb_unlock",
          "args": [
            "my_rdp"
          ],
          "line": 4401
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_nocb_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_nocb.h",
          "lines": "1474-1476",
          "snippet": "static void rcu_nocb_unlock(struct rcu_data *rdp)\n{\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static void rcu_nocb_unlock(struct rcu_data *rdp)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "__call_rcu_nocb_wake",
          "args": [
            "my_rdp",
            "true",
            "flags"
          ],
          "line": 4399
        },
        "resolved": true,
        "details": {
          "function_name": "__call_rcu_nocb_wake",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_nocb.h",
          "lines": "1516-1520",
          "snippet": "static void __call_rcu_nocb_wake(struct rcu_data *rdp, bool was_empty,\n\t\t\t\t unsigned long flags)\n{\n\tWARN_ON_ONCE(1);  /* Should be dead code! */\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static void __call_rcu_nocb_wake(struct rcu_data *rdp, bool was_empty,\n\t\t\t\t unsigned long flags)\n{\n\tWARN_ON_ONCE(1);  /* Should be dead code! */\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_rcu_node",
          "args": [
            "my_rnp"
          ],
          "line": 4398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_rdp_is_offloaded",
          "args": [
            "my_rdp"
          ],
          "line": 4397
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_rdp_is_offloaded",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "16-38",
          "snippet": "static bool rcu_rdp_is_offloaded(struct rcu_data *rdp)\n{\n\t/*\n\t * In order to read the offloaded state of an rdp in a safe\n\t * and stable way and prevent from its value to be changed\n\t * under us, we must either hold the barrier mutex, the cpu\n\t * hotplug lock (read or write) or the nocb lock. Local\n\t * non-preemptible reads are also safe. NOCB kthreads and\n\t * timers have their own means of synchronization against the\n\t * offloaded state updaters.\n\t */\n\tRCU_LOCKDEP_WARN(\n\t\t!(lockdep_is_held(&rcu_state.barrier_mutex) ||\n\t\t  (IS_ENABLED(CONFIG_HOTPLUG_CPU) && lockdep_is_cpus_held()) ||\n\t\t  rcu_lockdep_is_held_nocb(rdp) ||\n\t\t  (rdp == this_cpu_ptr(&rcu_data) &&\n\t\t   !(IS_ENABLED(CONFIG_PREEMPT_COUNT) && preemptible())) ||\n\t\t  rcu_current_is_nocb_kthread(rdp)),\n\t\t\"Unsafe read of RCU_NOCB offloaded state\"\n\t);\n\n\treturn rcu_segcblist_is_offloaded(&rdp->cblist);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nstatic bool rcu_rdp_is_offloaded(struct rcu_data *rdp)\n{\n\t/*\n\t * In order to read the offloaded state of an rdp in a safe\n\t * and stable way and prevent from its value to be changed\n\t * under us, we must either hold the barrier mutex, the cpu\n\t * hotplug lock (read or write) or the nocb lock. Local\n\t * non-preemptible reads are also safe. NOCB kthreads and\n\t * timers have their own means of synchronization against the\n\t * offloaded state updaters.\n\t */\n\tRCU_LOCKDEP_WARN(\n\t\t!(lockdep_is_held(&rcu_state.barrier_mutex) ||\n\t\t  (IS_ENABLED(CONFIG_HOTPLUG_CPU) && lockdep_is_cpus_held()) ||\n\t\t  rcu_lockdep_is_held_nocb(rdp) ||\n\t\t  (rdp == this_cpu_ptr(&rcu_data) &&\n\t\t   !(IS_ENABLED(CONFIG_PREEMPT_COUNT) && preemptible())) ||\n\t\t  rcu_current_is_nocb_kthread(rdp)),\n\t\t\"Unsafe read of RCU_NOCB offloaded state\"\n\t);\n\n\treturn rcu_segcblist_is_offloaded(&rdp->cblist);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "rcu_segcblist_empty(&my_rdp->cblist) !=\n\t\t     !rcu_segcblist_n_cbs(&my_rdp->cblist)"
          ],
          "line": 4395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_segcblist_disable",
          "args": [
            "&rdp->cblist"
          ],
          "line": 4394
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_disable",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.c",
          "lines": "256-261",
          "snippet": "void rcu_segcblist_disable(struct rcu_segcblist *rsclp)\n{\n\tWARN_ON_ONCE(!rcu_segcblist_empty(rsclp));\n\tWARN_ON_ONCE(rcu_segcblist_n_cbs(rsclp));\n\trcu_segcblist_clear_flags(rsclp, SEGCBLIST_ENABLED);\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/cpu.h>\n\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp)\n{\n\tWARN_ON_ONCE(!rcu_segcblist_empty(rsclp));\n\tWARN_ON_ONCE(rcu_segcblist_n_cbs(rsclp));\n\trcu_segcblist_clear_flags(rsclp, SEGCBLIST_ENABLED);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_advance_cbs",
          "args": [
            "my_rnp",
            "my_rdp"
          ],
          "line": 4393
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_advance_cbs_nowake",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "1596-1606",
          "snippet": "static void __maybe_unused rcu_advance_cbs_nowake(struct rcu_node *rnp,\n\t\t\t\t\t\t  struct rcu_data *rdp)\n{\n\trcu_lockdep_assert_cblist_protected(rdp);\n\tif (!rcu_seq_state(rcu_seq_current(&rnp->gp_seq)) || !raw_spin_trylock_rcu_node(rnp))\n\t\treturn;\n\t// The grace period cannot end while we hold the rcu_node lock.\n\tif (rcu_seq_state(rcu_seq_current(&rnp->gp_seq)))\n\t\tWARN_ON_ONCE(rcu_advance_cbs(rnp, rdp));\n\traw_spin_unlock_rcu_node(rnp);\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};",
            "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
            "static void check_cb_ovld_locked(struct rcu_data *rdp, struct rcu_node *rnp);",
            "static bool rcu_rdp_is_offloaded(struct rcu_data *rdp);",
            "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void check_cb_ovld_locked(struct rcu_data *rdp, struct rcu_node *rnp);\nstatic bool rcu_rdp_is_offloaded(struct rcu_data *rdp);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nstatic void __maybe_unused rcu_advance_cbs_nowake(struct rcu_node *rnp,\n\t\t\t\t\t\t  struct rcu_data *rdp)\n{\n\trcu_lockdep_assert_cblist_protected(rdp);\n\tif (!rcu_seq_state(rcu_seq_current(&rnp->gp_seq)) || !raw_spin_trylock_rcu_node(rnp))\n\t\treturn;\n\t// The grace period cannot end while we hold the rcu_node lock.\n\tif (rcu_seq_state(rcu_seq_current(&rnp->gp_seq)))\n\t\tWARN_ON_ONCE(rcu_advance_cbs(rnp, rdp));\n\traw_spin_unlock_rcu_node(rnp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_segcblist_merge",
          "args": [
            "&my_rdp->cblist",
            "&rdp->cblist"
          ],
          "line": 4392
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_merge",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.c",
          "lines": "607-633",
          "snippet": "void rcu_segcblist_merge(struct rcu_segcblist *dst_rsclp,\n\t\t\t struct rcu_segcblist *src_rsclp)\n{\n\tstruct rcu_cblist donecbs;\n\tstruct rcu_cblist pendcbs;\n\n\tlockdep_assert_cpus_held();\n\n\trcu_cblist_init(&donecbs);\n\trcu_cblist_init(&pendcbs);\n\n\trcu_segcblist_extract_done_cbs(src_rsclp, &donecbs);\n\trcu_segcblist_extract_pend_cbs(src_rsclp, &pendcbs);\n\n\t/*\n\t * No need smp_mb() before setting length to 0, because CPU hotplug\n\t * lock excludes rcu_barrier.\n\t */\n\trcu_segcblist_set_len(src_rsclp, 0);\n\n\trcu_segcblist_insert_count(dst_rsclp, &donecbs);\n\trcu_segcblist_insert_count(dst_rsclp, &pendcbs);\n\trcu_segcblist_insert_done_cbs(dst_rsclp, &donecbs);\n\trcu_segcblist_insert_pend_cbs(dst_rsclp, &pendcbs);\n\n\trcu_segcblist_init(src_rsclp);\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/cpu.h>\n\nvoid rcu_segcblist_merge(struct rcu_segcblist *dst_rsclp,\n\t\t\t struct rcu_segcblist *src_rsclp)\n{\n\tstruct rcu_cblist donecbs;\n\tstruct rcu_cblist pendcbs;\n\n\tlockdep_assert_cpus_held();\n\n\trcu_cblist_init(&donecbs);\n\trcu_cblist_init(&pendcbs);\n\n\trcu_segcblist_extract_done_cbs(src_rsclp, &donecbs);\n\trcu_segcblist_extract_pend_cbs(src_rsclp, &pendcbs);\n\n\t/*\n\t * No need smp_mb() before setting length to 0, because CPU hotplug\n\t * lock excludes rcu_barrier.\n\t */\n\trcu_segcblist_set_len(src_rsclp, 0);\n\n\trcu_segcblist_insert_count(dst_rsclp, &donecbs);\n\trcu_segcblist_insert_count(dst_rsclp, &pendcbs);\n\trcu_segcblist_insert_done_cbs(dst_rsclp, &donecbs);\n\trcu_segcblist_insert_pend_cbs(dst_rsclp, &pendcbs);\n\n\trcu_segcblist_init(src_rsclp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_rcu_node",
          "args": [
            "my_rnp"
          ],
          "line": 4388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!rcu_nocb_flush_bypass(my_rdp, NULL, jiffies)"
          ],
          "line": 4387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_nocb_flush_bypass",
          "args": [
            "my_rdp",
            "NULL",
            "jiffies"
          ],
          "line": 4387
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_nocb_flush_bypass",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_nocb.h",
          "lines": "1504-1508",
          "snippet": "static bool rcu_nocb_flush_bypass(struct rcu_data *rdp, struct rcu_head *rhp,\n\t\t\t\t  unsigned long j)\n{\n\treturn true;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static bool rcu_nocb_flush_bypass(struct rcu_data *rdp, struct rcu_head *rhp,\n\t\t\t\t  unsigned long j)\n{\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_nocb_lock",
          "args": [
            "my_rdp"
          ],
          "line": 4386
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_nocb_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_nocb.h",
          "lines": "1469-1471",
          "snippet": "static void rcu_nocb_lock(struct rcu_data *rdp)\n{\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static void rcu_nocb_lock(struct rcu_data *rdp)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&rcu_data"
          ],
          "line": 4384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_save",
          "args": [
            "flags"
          ],
          "line": 4383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "&rcu_data",
            "cpu"
          ],
          "line": 4376
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};\nstatic void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void sync_sched_exp_online_cleanup(int cpu);\nstatic bool rcu_rdp_is_offloaded(struct rcu_data *rdp);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nvoid rcutree_migrate_callbacks(int cpu)\n{\n\tunsigned long flags;\n\tstruct rcu_data *my_rdp;\n\tstruct rcu_node *my_rnp;\n\tstruct rcu_data *rdp = per_cpu_ptr(&rcu_data, cpu);\n\tbool needwake;\n\n\tif (rcu_rdp_is_offloaded(rdp) ||\n\t    rcu_segcblist_empty(&rdp->cblist))\n\t\treturn;  /* No callbacks to migrate. */\n\n\tlocal_irq_save(flags);\n\tmy_rdp = this_cpu_ptr(&rcu_data);\n\tmy_rnp = my_rdp->mynode;\n\trcu_nocb_lock(my_rdp); /* irqs already disabled. */\n\tWARN_ON_ONCE(!rcu_nocb_flush_bypass(my_rdp, NULL, jiffies));\n\traw_spin_lock_rcu_node(my_rnp); /* irqs already disabled. */\n\t/* Leverage recent GPs and set GP for new callbacks. */\n\tneedwake = rcu_advance_cbs(my_rnp, rdp) ||\n\t\t   rcu_advance_cbs(my_rnp, my_rdp);\n\trcu_segcblist_merge(&my_rdp->cblist, &rdp->cblist);\n\tneedwake = needwake || rcu_advance_cbs(my_rnp, my_rdp);\n\trcu_segcblist_disable(&rdp->cblist);\n\tWARN_ON_ONCE(rcu_segcblist_empty(&my_rdp->cblist) !=\n\t\t     !rcu_segcblist_n_cbs(&my_rdp->cblist));\n\tif (rcu_rdp_is_offloaded(my_rdp)) {\n\t\traw_spin_unlock_rcu_node(my_rnp); /* irqs remain disabled. */\n\t\t__call_rcu_nocb_wake(my_rdp, true, flags);\n\t} else {\n\t\trcu_nocb_unlock(my_rdp); /* irqs remain disabled. */\n\t\traw_spin_unlock_irqrestore_rcu_node(my_rnp, flags);\n\t}\n\tif (needwake)\n\t\trcu_gp_kthread_wake();\n\tlockdep_assert_irqs_enabled();\n\tWARN_ONCE(rcu_segcblist_n_cbs(&rdp->cblist) != 0 ||\n\t\t  !rcu_segcblist_empty(&rdp->cblist),\n\t\t  \"rcu_cleanup_dead_cpu: Callbacks on offline CPU %d: qlen=%lu, 1stCB=%p\\n\",\n\t\t  cpu, rcu_segcblist_n_cbs(&rdp->cblist),\n\t\t  rcu_segcblist_first_cb(&rdp->cblist));\n}"
  },
  {
    "function_name": "rcu_report_dead",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
    "lines": "4327-4363",
    "snippet": "void rcu_report_dead(unsigned int cpu)\n{\n\tunsigned long flags;\n\tunsigned long mask;\n\tstruct rcu_data *rdp = per_cpu_ptr(&rcu_data, cpu);\n\tstruct rcu_node *rnp = rdp->mynode;  /* Outgoing CPU's rdp & rnp. */\n\n\t// Do any dangling deferred wakeups.\n\tdo_nocb_deferred_wakeup(rdp);\n\n\t/* QS for any half-done expedited grace period. */\n\trcu_report_exp_rdp(rdp);\n\trcu_preempt_deferred_qs(current);\n\n\t/* Remove outgoing CPU from mask in the leaf rcu_node structure. */\n\tmask = rdp->grpmask;\n\tWRITE_ONCE(rnp->ofl_seq, rnp->ofl_seq + 1);\n\tWARN_ON_ONCE(!(rnp->ofl_seq & 0x1));\n\tsmp_mb(); // Pair with rcu_gp_cleanup()'s ->ofl_seq barrier().\n\traw_spin_lock(&rcu_state.ofl_lock);\n\traw_spin_lock_irqsave_rcu_node(rnp, flags); /* Enforce GP memory-order guarantee. */\n\trdp->rcu_ofl_gp_seq = READ_ONCE(rcu_state.gp_seq);\n\trdp->rcu_ofl_gp_flags = READ_ONCE(rcu_state.gp_flags);\n\tif (rnp->qsmask & mask) { /* RCU waiting on outgoing CPU? */\n\t\t/* Report quiescent state -before- changing ->qsmaskinitnext! */\n\t\trcu_report_qs_rnp(mask, rnp, rnp->gp_seq, flags);\n\t\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\t}\n\tWRITE_ONCE(rnp->qsmaskinitnext, rnp->qsmaskinitnext & ~mask);\n\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\traw_spin_unlock(&rcu_state.ofl_lock);\n\tsmp_mb(); // Pair with rcu_gp_cleanup()'s ->ofl_seq barrier().\n\tWRITE_ONCE(rnp->ofl_seq, rnp->ofl_seq + 1);\n\tWARN_ON_ONCE(rnp->ofl_seq & 0x1);\n\n\trdp->cpu_started = false;\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_nocb.h\"",
      "#include \"tree_exp.h\"",
      "#include \"tree_stall.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <linux/kasan.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/panic_notifier.h>",
      "#include <linux/panic.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};",
      "static struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};",
      "static void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);",
      "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
      "static void sync_sched_exp_online_cleanup(int cpu);",
      "static void check_cb_ovld_locked(struct rcu_data *rdp, struct rcu_node *rnp);",
      "static bool rcu_rdp_is_offloaded(struct rcu_data *rdp);",
      "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "rnp->ofl_seq & 0x1"
          ],
          "line": 4360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "rnp->ofl_seq",
            "rnp->ofl_seq + 1"
          ],
          "line": 4359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_mb",
          "args": [],
          "line": 4358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock",
          "args": [
            "&rcu_state.ofl_lock"
          ],
          "line": 4357
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_bh",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "208-211",
          "snippet": "void __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore_rcu_node",
          "args": [
            "rnp",
            "flags"
          ],
          "line": 4356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "rnp->qsmaskinitnext",
            "rnp->qsmaskinitnext & ~mask"
          ],
          "line": 4355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave_rcu_node",
          "args": [
            "rnp",
            "flags"
          ],
          "line": 4353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_report_qs_rnp",
          "args": [
            "mask",
            "rnp",
            "rnp->gp_seq",
            "flags"
          ],
          "line": 4352
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_report_qs_rnp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "2179-2234",
          "snippet": "static void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags)\n\t__releases(rnp->lock)\n{\n\tunsigned long oldmask = 0;\n\tstruct rcu_node *rnp_c;\n\n\traw_lockdep_assert_held_rcu_node(rnp);\n\n\t/* Walk up the rcu_node hierarchy. */\n\tfor (;;) {\n\t\tif ((!(rnp->qsmask & mask) && mask) || rnp->gp_seq != gps) {\n\n\t\t\t/*\n\t\t\t * Our bit has already been cleared, or the\n\t\t\t * relevant grace period is already over, so done.\n\t\t\t */\n\t\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\t\treturn;\n\t\t}\n\t\tWARN_ON_ONCE(oldmask); /* Any child must be all zeroed! */\n\t\tWARN_ON_ONCE(!rcu_is_leaf_node(rnp) &&\n\t\t\t     rcu_preempt_blocked_readers_cgp(rnp));\n\t\tWRITE_ONCE(rnp->qsmask, rnp->qsmask & ~mask);\n\t\ttrace_rcu_quiescent_state_report(rcu_state.name, rnp->gp_seq,\n\t\t\t\t\t\t mask, rnp->qsmask, rnp->level,\n\t\t\t\t\t\t rnp->grplo, rnp->grphi,\n\t\t\t\t\t\t !!rnp->gp_tasks);\n\t\tif (rnp->qsmask != 0 || rcu_preempt_blocked_readers_cgp(rnp)) {\n\n\t\t\t/* Other bits still set at this level, so done. */\n\t\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\t\treturn;\n\t\t}\n\t\trnp->completedqs = rnp->gp_seq;\n\t\tmask = rnp->grpmask;\n\t\tif (rnp->parent == NULL) {\n\n\t\t\t/* No more levels.  Exit loop holding root lock. */\n\n\t\t\tbreak;\n\t\t}\n\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\trnp_c = rnp;\n\t\trnp = rnp->parent;\n\t\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\t\toldmask = READ_ONCE(rnp_c->qsmask);\n\t}\n\n\t/*\n\t * Get here if we are the last CPU to pass through a quiescent\n\t * state for this grace period.  Invoke rcu_report_qs_rsp()\n\t * to clean up and start the next grace period if one is needed.\n\t */\n\trcu_report_qs_rsp(flags); /* releases rnp->lock. */\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};",
            "static void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);",
            "static void check_cb_ovld_locked(struct rcu_data *rdp, struct rcu_node *rnp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\nstatic void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);\nstatic void check_cb_ovld_locked(struct rcu_data *rdp, struct rcu_node *rnp);\n\nstatic void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags)\n\t__releases(rnp->lock)\n{\n\tunsigned long oldmask = 0;\n\tstruct rcu_node *rnp_c;\n\n\traw_lockdep_assert_held_rcu_node(rnp);\n\n\t/* Walk up the rcu_node hierarchy. */\n\tfor (;;) {\n\t\tif ((!(rnp->qsmask & mask) && mask) || rnp->gp_seq != gps) {\n\n\t\t\t/*\n\t\t\t * Our bit has already been cleared, or the\n\t\t\t * relevant grace period is already over, so done.\n\t\t\t */\n\t\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\t\treturn;\n\t\t}\n\t\tWARN_ON_ONCE(oldmask); /* Any child must be all zeroed! */\n\t\tWARN_ON_ONCE(!rcu_is_leaf_node(rnp) &&\n\t\t\t     rcu_preempt_blocked_readers_cgp(rnp));\n\t\tWRITE_ONCE(rnp->qsmask, rnp->qsmask & ~mask);\n\t\ttrace_rcu_quiescent_state_report(rcu_state.name, rnp->gp_seq,\n\t\t\t\t\t\t mask, rnp->qsmask, rnp->level,\n\t\t\t\t\t\t rnp->grplo, rnp->grphi,\n\t\t\t\t\t\t !!rnp->gp_tasks);\n\t\tif (rnp->qsmask != 0 || rcu_preempt_blocked_readers_cgp(rnp)) {\n\n\t\t\t/* Other bits still set at this level, so done. */\n\t\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\t\treturn;\n\t\t}\n\t\trnp->completedqs = rnp->gp_seq;\n\t\tmask = rnp->grpmask;\n\t\tif (rnp->parent == NULL) {\n\n\t\t\t/* No more levels.  Exit loop holding root lock. */\n\n\t\t\tbreak;\n\t\t}\n\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\trnp_c = rnp;\n\t\trnp = rnp->parent;\n\t\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\t\toldmask = READ_ONCE(rnp_c->qsmask);\n\t}\n\n\t/*\n\t * Get here if we are the last CPU to pass through a quiescent\n\t * state for this grace period.  Invoke rcu_report_qs_rsp()\n\t * to clean up and start the next grace period if one is needed.\n\t */\n\trcu_report_qs_rsp(flags); /* releases rnp->lock. */\n}"
        }
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rcu_state.gp_flags"
          ],
          "line": 4349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rcu_state.gp_seq"
          ],
          "line": 4348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave_rcu_node",
          "args": [
            "rnp",
            "flags"
          ],
          "line": 4347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock",
          "args": [
            "&rcu_state.ofl_lock"
          ],
          "line": 4346
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_bh",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "176-179",
          "snippet": "void __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_mb",
          "args": [],
          "line": 4345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!(rnp->ofl_seq & 0x1)"
          ],
          "line": 4344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "rnp->ofl_seq",
            "rnp->ofl_seq + 1"
          ],
          "line": 4343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_preempt_deferred_qs",
          "args": [
            "current"
          ],
          "line": 4339
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_preempt_deferred_qs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "933-939",
          "snippet": "static void rcu_preempt_deferred_qs(struct task_struct *t)\n{\n\tstruct rcu_data *rdp = this_cpu_ptr(&rcu_data);\n\n\tif (rdp->cpu_no_qs.b.exp)\n\t\trcu_report_exp_rdp(rdp);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nstatic void rcu_preempt_deferred_qs(struct task_struct *t)\n{\n\tstruct rcu_data *rdp = this_cpu_ptr(&rcu_data);\n\n\tif (rdp->cpu_no_qs.b.exp)\n\t\trcu_report_exp_rdp(rdp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_report_exp_rdp",
          "args": [
            "rdp"
          ],
          "line": 4338
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_report_exp_rdp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_exp.h",
          "lines": "256-260",
          "snippet": "static void rcu_report_exp_rdp(struct rcu_data *rdp)\n{\n\tWRITE_ONCE(rdp->cpu_no_qs.b.exp, false);\n\trcu_report_exp_cpu_mult(rdp->mynode, rdp->grpmask, true);\n}",
          "includes": [
            "#include <linux/lockdep.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockdep.h>\n\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp)\n{\n\tWRITE_ONCE(rdp->cpu_no_qs.b.exp, false);\n\trcu_report_exp_cpu_mult(rdp->mynode, rdp->grpmask, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_nocb_deferred_wakeup",
          "args": [
            "rdp"
          ],
          "line": 4335
        },
        "resolved": true,
        "details": {
          "function_name": "do_nocb_deferred_wakeup",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_nocb.h",
          "lines": "1531-1534",
          "snippet": "static bool do_nocb_deferred_wakeup(struct rcu_data *rdp)\n{\n\treturn false;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static bool do_nocb_deferred_wakeup(struct rcu_data *rdp)\n{\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "&rcu_data",
            "cpu"
          ],
          "line": 4331
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};\nstatic struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\nstatic void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void sync_sched_exp_online_cleanup(int cpu);\nstatic void check_cb_ovld_locked(struct rcu_data *rdp, struct rcu_node *rnp);\nstatic bool rcu_rdp_is_offloaded(struct rcu_data *rdp);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nvoid rcu_report_dead(unsigned int cpu)\n{\n\tunsigned long flags;\n\tunsigned long mask;\n\tstruct rcu_data *rdp = per_cpu_ptr(&rcu_data, cpu);\n\tstruct rcu_node *rnp = rdp->mynode;  /* Outgoing CPU's rdp & rnp. */\n\n\t// Do any dangling deferred wakeups.\n\tdo_nocb_deferred_wakeup(rdp);\n\n\t/* QS for any half-done expedited grace period. */\n\trcu_report_exp_rdp(rdp);\n\trcu_preempt_deferred_qs(current);\n\n\t/* Remove outgoing CPU from mask in the leaf rcu_node structure. */\n\tmask = rdp->grpmask;\n\tWRITE_ONCE(rnp->ofl_seq, rnp->ofl_seq + 1);\n\tWARN_ON_ONCE(!(rnp->ofl_seq & 0x1));\n\tsmp_mb(); // Pair with rcu_gp_cleanup()'s ->ofl_seq barrier().\n\traw_spin_lock(&rcu_state.ofl_lock);\n\traw_spin_lock_irqsave_rcu_node(rnp, flags); /* Enforce GP memory-order guarantee. */\n\trdp->rcu_ofl_gp_seq = READ_ONCE(rcu_state.gp_seq);\n\trdp->rcu_ofl_gp_flags = READ_ONCE(rcu_state.gp_flags);\n\tif (rnp->qsmask & mask) { /* RCU waiting on outgoing CPU? */\n\t\t/* Report quiescent state -before- changing ->qsmaskinitnext! */\n\t\trcu_report_qs_rnp(mask, rnp, rnp->gp_seq, flags);\n\t\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\t}\n\tWRITE_ONCE(rnp->qsmaskinitnext, rnp->qsmaskinitnext & ~mask);\n\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\traw_spin_unlock(&rcu_state.ofl_lock);\n\tsmp_mb(); // Pair with rcu_gp_cleanup()'s ->ofl_seq barrier().\n\tWRITE_ONCE(rnp->ofl_seq, rnp->ofl_seq + 1);\n\tWARN_ON_ONCE(rnp->ofl_seq & 0x1);\n\n\trdp->cpu_started = false;\n}"
  },
  {
    "function_name": "rcu_cpu_starting",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
    "lines": "4275-4317",
    "snippet": "void rcu_cpu_starting(unsigned int cpu)\n{\n\tunsigned long flags;\n\tunsigned long mask;\n\tstruct rcu_data *rdp;\n\tstruct rcu_node *rnp;\n\tbool newcpu;\n\n\trdp = per_cpu_ptr(&rcu_data, cpu);\n\tif (rdp->cpu_started)\n\t\treturn;\n\trdp->cpu_started = true;\n\n\trnp = rdp->mynode;\n\tmask = rdp->grpmask;\n\tWRITE_ONCE(rnp->ofl_seq, rnp->ofl_seq + 1);\n\tWARN_ON_ONCE(!(rnp->ofl_seq & 0x1));\n\trcu_dynticks_eqs_online();\n\tsmp_mb(); // Pair with rcu_gp_cleanup()'s ->ofl_seq barrier().\n\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\tWRITE_ONCE(rnp->qsmaskinitnext, rnp->qsmaskinitnext | mask);\n\tnewcpu = !(rnp->expmaskinitnext & mask);\n\trnp->expmaskinitnext |= mask;\n\t/* Allow lockless access for expedited grace periods. */\n\tsmp_store_release(&rcu_state.ncpus, rcu_state.ncpus + newcpu); /* ^^^ */\n\tASSERT_EXCLUSIVE_WRITER(rcu_state.ncpus);\n\trcu_gpnum_ovf(rnp, rdp); /* Offline-induced counter wrap? */\n\trdp->rcu_onl_gp_seq = READ_ONCE(rcu_state.gp_seq);\n\trdp->rcu_onl_gp_flags = READ_ONCE(rcu_state.gp_flags);\n\n\t/* An incoming CPU should never be blocking a grace period. */\n\tif (WARN_ON_ONCE(rnp->qsmask & mask)) { /* RCU waiting on incoming CPU? */\n\t\trcu_disable_urgency_upon_qs(rdp);\n\t\t/* Report QS -after- changing ->qsmaskinitnext! */\n\t\trcu_report_qs_rnp(mask, rnp, rnp->gp_seq, flags);\n\t} else {\n\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t}\n\tsmp_mb(); // Pair with rcu_gp_cleanup()'s ->ofl_seq barrier().\n\tWRITE_ONCE(rnp->ofl_seq, rnp->ofl_seq + 1);\n\tWARN_ON_ONCE(rnp->ofl_seq & 0x1);\n\tsmp_mb(); /* Ensure RCU read-side usage follows above initialization. */\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_nocb.h\"",
      "#include \"tree_exp.h\"",
      "#include \"tree_stall.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <linux/kasan.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/panic_notifier.h>",
      "#include <linux/panic.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};",
      "static struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};",
      "static void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);",
      "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
      "static void sync_sched_exp_online_cleanup(int cpu);",
      "static void check_cb_ovld_locked(struct rcu_data *rdp, struct rcu_node *rnp);",
      "static bool rcu_rdp_is_offloaded(struct rcu_data *rdp);",
      "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "smp_mb",
          "args": [],
          "line": 4316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "rnp->ofl_seq & 0x1"
          ],
          "line": 4315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "rnp->ofl_seq",
            "rnp->ofl_seq + 1"
          ],
          "line": 4314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_mb",
          "args": [],
          "line": 4313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore_rcu_node",
          "args": [
            "rnp",
            "flags"
          ],
          "line": 4311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_report_qs_rnp",
          "args": [
            "mask",
            "rnp",
            "rnp->gp_seq",
            "flags"
          ],
          "line": 4309
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_report_qs_rnp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "2179-2234",
          "snippet": "static void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags)\n\t__releases(rnp->lock)\n{\n\tunsigned long oldmask = 0;\n\tstruct rcu_node *rnp_c;\n\n\traw_lockdep_assert_held_rcu_node(rnp);\n\n\t/* Walk up the rcu_node hierarchy. */\n\tfor (;;) {\n\t\tif ((!(rnp->qsmask & mask) && mask) || rnp->gp_seq != gps) {\n\n\t\t\t/*\n\t\t\t * Our bit has already been cleared, or the\n\t\t\t * relevant grace period is already over, so done.\n\t\t\t */\n\t\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\t\treturn;\n\t\t}\n\t\tWARN_ON_ONCE(oldmask); /* Any child must be all zeroed! */\n\t\tWARN_ON_ONCE(!rcu_is_leaf_node(rnp) &&\n\t\t\t     rcu_preempt_blocked_readers_cgp(rnp));\n\t\tWRITE_ONCE(rnp->qsmask, rnp->qsmask & ~mask);\n\t\ttrace_rcu_quiescent_state_report(rcu_state.name, rnp->gp_seq,\n\t\t\t\t\t\t mask, rnp->qsmask, rnp->level,\n\t\t\t\t\t\t rnp->grplo, rnp->grphi,\n\t\t\t\t\t\t !!rnp->gp_tasks);\n\t\tif (rnp->qsmask != 0 || rcu_preempt_blocked_readers_cgp(rnp)) {\n\n\t\t\t/* Other bits still set at this level, so done. */\n\t\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\t\treturn;\n\t\t}\n\t\trnp->completedqs = rnp->gp_seq;\n\t\tmask = rnp->grpmask;\n\t\tif (rnp->parent == NULL) {\n\n\t\t\t/* No more levels.  Exit loop holding root lock. */\n\n\t\t\tbreak;\n\t\t}\n\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\trnp_c = rnp;\n\t\trnp = rnp->parent;\n\t\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\t\toldmask = READ_ONCE(rnp_c->qsmask);\n\t}\n\n\t/*\n\t * Get here if we are the last CPU to pass through a quiescent\n\t * state for this grace period.  Invoke rcu_report_qs_rsp()\n\t * to clean up and start the next grace period if one is needed.\n\t */\n\trcu_report_qs_rsp(flags); /* releases rnp->lock. */\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};",
            "static void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);",
            "static void check_cb_ovld_locked(struct rcu_data *rdp, struct rcu_node *rnp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\nstatic void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);\nstatic void check_cb_ovld_locked(struct rcu_data *rdp, struct rcu_node *rnp);\n\nstatic void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags)\n\t__releases(rnp->lock)\n{\n\tunsigned long oldmask = 0;\n\tstruct rcu_node *rnp_c;\n\n\traw_lockdep_assert_held_rcu_node(rnp);\n\n\t/* Walk up the rcu_node hierarchy. */\n\tfor (;;) {\n\t\tif ((!(rnp->qsmask & mask) && mask) || rnp->gp_seq != gps) {\n\n\t\t\t/*\n\t\t\t * Our bit has already been cleared, or the\n\t\t\t * relevant grace period is already over, so done.\n\t\t\t */\n\t\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\t\treturn;\n\t\t}\n\t\tWARN_ON_ONCE(oldmask); /* Any child must be all zeroed! */\n\t\tWARN_ON_ONCE(!rcu_is_leaf_node(rnp) &&\n\t\t\t     rcu_preempt_blocked_readers_cgp(rnp));\n\t\tWRITE_ONCE(rnp->qsmask, rnp->qsmask & ~mask);\n\t\ttrace_rcu_quiescent_state_report(rcu_state.name, rnp->gp_seq,\n\t\t\t\t\t\t mask, rnp->qsmask, rnp->level,\n\t\t\t\t\t\t rnp->grplo, rnp->grphi,\n\t\t\t\t\t\t !!rnp->gp_tasks);\n\t\tif (rnp->qsmask != 0 || rcu_preempt_blocked_readers_cgp(rnp)) {\n\n\t\t\t/* Other bits still set at this level, so done. */\n\t\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\t\treturn;\n\t\t}\n\t\trnp->completedqs = rnp->gp_seq;\n\t\tmask = rnp->grpmask;\n\t\tif (rnp->parent == NULL) {\n\n\t\t\t/* No more levels.  Exit loop holding root lock. */\n\n\t\t\tbreak;\n\t\t}\n\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\trnp_c = rnp;\n\t\trnp = rnp->parent;\n\t\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\t\toldmask = READ_ONCE(rnp_c->qsmask);\n\t}\n\n\t/*\n\t * Get here if we are the last CPU to pass through a quiescent\n\t * state for this grace period.  Invoke rcu_report_qs_rsp()\n\t * to clean up and start the next grace period if one is needed.\n\t */\n\trcu_report_qs_rsp(flags); /* releases rnp->lock. */\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_disable_urgency_upon_qs",
          "args": [
            "rdp"
          ],
          "line": 4307
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_disable_urgency_upon_qs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "1101-1110",
          "snippet": "static void rcu_disable_urgency_upon_qs(struct rcu_data *rdp)\n{\n\traw_lockdep_assert_held_rcu_node(rdp->mynode);\n\tWRITE_ONCE(rdp->rcu_urgent_qs, false);\n\tWRITE_ONCE(rdp->rcu_need_heavy_qs, false);\n\tif (tick_nohz_full_cpu(rdp->cpu) && rdp->rcu_forced_tick) {\n\t\ttick_dep_clear_cpu(rdp->cpu, TICK_DEP_BIT_RCU);\n\t\tWRITE_ONCE(rdp->rcu_forced_tick, false);\n\t}\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};",
            "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
            "static void sync_sched_exp_online_cleanup(int cpu);",
            "static bool rcu_rdp_is_offloaded(struct rcu_data *rdp);",
            "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void sync_sched_exp_online_cleanup(int cpu);\nstatic bool rcu_rdp_is_offloaded(struct rcu_data *rdp);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nstatic void rcu_disable_urgency_upon_qs(struct rcu_data *rdp)\n{\n\traw_lockdep_assert_held_rcu_node(rdp->mynode);\n\tWRITE_ONCE(rdp->rcu_urgent_qs, false);\n\tWRITE_ONCE(rdp->rcu_need_heavy_qs, false);\n\tif (tick_nohz_full_cpu(rdp->cpu) && rdp->rcu_forced_tick) {\n\t\ttick_dep_clear_cpu(rdp->cpu, TICK_DEP_BIT_RCU);\n\t\tWRITE_ONCE(rdp->rcu_forced_tick, false);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "rnp->qsmask & mask"
          ],
          "line": 4306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rcu_state.gp_flags"
          ],
          "line": 4303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rcu_state.gp_seq"
          ],
          "line": 4302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_gpnum_ovf",
          "args": [
            "rnp",
            "rdp"
          ],
          "line": 4301
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_gpnum_ovf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "1194-1202",
          "snippet": "static void rcu_gpnum_ovf(struct rcu_node *rnp, struct rcu_data *rdp)\n{\n\traw_lockdep_assert_held_rcu_node(rnp);\n\tif (ULONG_CMP_LT(rcu_seq_current(&rdp->gp_seq) + ULONG_MAX / 4,\n\t\t\t rnp->gp_seq))\n\t\tWRITE_ONCE(rdp->gpwrap, true);\n\tif (ULONG_CMP_LT(rdp->rcu_iw_gp_seq + ULONG_MAX / 4, rnp->gp_seq))\n\t\trdp->rcu_iw_gp_seq = rnp->gp_seq + ULONG_MAX / 4;\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};",
            "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
            "static void check_cb_ovld_locked(struct rcu_data *rdp, struct rcu_node *rnp);",
            "static bool rcu_rdp_is_offloaded(struct rcu_data *rdp);",
            "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void check_cb_ovld_locked(struct rcu_data *rdp, struct rcu_node *rnp);\nstatic bool rcu_rdp_is_offloaded(struct rcu_data *rdp);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nstatic void rcu_gpnum_ovf(struct rcu_node *rnp, struct rcu_data *rdp)\n{\n\traw_lockdep_assert_held_rcu_node(rnp);\n\tif (ULONG_CMP_LT(rcu_seq_current(&rdp->gp_seq) + ULONG_MAX / 4,\n\t\t\t rnp->gp_seq))\n\t\tWRITE_ONCE(rdp->gpwrap, true);\n\tif (ULONG_CMP_LT(rdp->rcu_iw_gp_seq + ULONG_MAX / 4, rnp->gp_seq))\n\t\trdp->rcu_iw_gp_seq = rnp->gp_seq + ULONG_MAX / 4;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT_EXCLUSIVE_WRITER",
          "args": [
            "rcu_state.ncpus"
          ],
          "line": 4300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_store_release",
          "args": [
            "&rcu_state.ncpus",
            "rcu_state.ncpus + newcpu"
          ],
          "line": 4299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "rnp->qsmaskinitnext",
            "rnp->qsmaskinitnext | mask"
          ],
          "line": 4295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave_rcu_node",
          "args": [
            "rnp",
            "flags"
          ],
          "line": 4294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_mb",
          "args": [],
          "line": 4293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_dynticks_eqs_online",
          "args": [],
          "line": 4292
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_dynticks_eqs_online",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "314-321",
          "snippet": "static void rcu_dynticks_eqs_online(void)\n{\n\tstruct rcu_data *rdp = this_cpu_ptr(&rcu_data);\n\n\tif (atomic_read(&rdp->dynticks) & 0x1)\n\t\treturn;\n\trcu_dynticks_inc(1);\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};",
            "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
            "static bool rcu_rdp_is_offloaded(struct rcu_data *rdp);",
            "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic bool rcu_rdp_is_offloaded(struct rcu_data *rdp);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nstatic void rcu_dynticks_eqs_online(void)\n{\n\tstruct rcu_data *rdp = this_cpu_ptr(&rcu_data);\n\n\tif (atomic_read(&rdp->dynticks) & 0x1)\n\t\treturn;\n\trcu_dynticks_inc(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!(rnp->ofl_seq & 0x1)"
          ],
          "line": 4291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "rnp->ofl_seq",
            "rnp->ofl_seq + 1"
          ],
          "line": 4290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "&rcu_data",
            "cpu"
          ],
          "line": 4283
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};\nstatic struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\nstatic void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void sync_sched_exp_online_cleanup(int cpu);\nstatic void check_cb_ovld_locked(struct rcu_data *rdp, struct rcu_node *rnp);\nstatic bool rcu_rdp_is_offloaded(struct rcu_data *rdp);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nvoid rcu_cpu_starting(unsigned int cpu)\n{\n\tunsigned long flags;\n\tunsigned long mask;\n\tstruct rcu_data *rdp;\n\tstruct rcu_node *rnp;\n\tbool newcpu;\n\n\trdp = per_cpu_ptr(&rcu_data, cpu);\n\tif (rdp->cpu_started)\n\t\treturn;\n\trdp->cpu_started = true;\n\n\trnp = rdp->mynode;\n\tmask = rdp->grpmask;\n\tWRITE_ONCE(rnp->ofl_seq, rnp->ofl_seq + 1);\n\tWARN_ON_ONCE(!(rnp->ofl_seq & 0x1));\n\trcu_dynticks_eqs_online();\n\tsmp_mb(); // Pair with rcu_gp_cleanup()'s ->ofl_seq barrier().\n\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\tWRITE_ONCE(rnp->qsmaskinitnext, rnp->qsmaskinitnext | mask);\n\tnewcpu = !(rnp->expmaskinitnext & mask);\n\trnp->expmaskinitnext |= mask;\n\t/* Allow lockless access for expedited grace periods. */\n\tsmp_store_release(&rcu_state.ncpus, rcu_state.ncpus + newcpu); /* ^^^ */\n\tASSERT_EXCLUSIVE_WRITER(rcu_state.ncpus);\n\trcu_gpnum_ovf(rnp, rdp); /* Offline-induced counter wrap? */\n\trdp->rcu_onl_gp_seq = READ_ONCE(rcu_state.gp_seq);\n\trdp->rcu_onl_gp_flags = READ_ONCE(rcu_state.gp_flags);\n\n\t/* An incoming CPU should never be blocking a grace period. */\n\tif (WARN_ON_ONCE(rnp->qsmask & mask)) { /* RCU waiting on incoming CPU? */\n\t\trcu_disable_urgency_upon_qs(rdp);\n\t\t/* Report QS -after- changing ->qsmaskinitnext! */\n\t\trcu_report_qs_rnp(mask, rnp, rnp->gp_seq, flags);\n\t} else {\n\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t}\n\tsmp_mb(); // Pair with rcu_gp_cleanup()'s ->ofl_seq barrier().\n\tWRITE_ONCE(rnp->ofl_seq, rnp->ofl_seq + 1);\n\tWARN_ON_ONCE(rnp->ofl_seq & 0x1);\n\tsmp_mb(); /* Ensure RCU read-side usage follows above initialization. */\n}"
  },
  {
    "function_name": "rcutree_offline_cpu",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
    "lines": "4245-4262",
    "snippet": "int rcutree_offline_cpu(unsigned int cpu)\n{\n\tunsigned long flags;\n\tstruct rcu_data *rdp;\n\tstruct rcu_node *rnp;\n\n\trdp = per_cpu_ptr(&rcu_data, cpu);\n\trnp = rdp->mynode;\n\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\trnp->ffmask &= ~rdp->grpmask;\n\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\n\trcutree_affinity_setting(cpu, cpu);\n\n\t// nohz_full CPUs need the tick for stop-machine to work quickly\n\ttick_dep_set(TICK_DEP_BIT_RCU);\n\treturn 0;\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_nocb.h\"",
      "#include \"tree_exp.h\"",
      "#include \"tree_stall.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <linux/kasan.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/panic_notifier.h>",
      "#include <linux/panic.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};",
      "static void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);",
      "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
      "static void sync_sched_exp_online_cleanup(int cpu);",
      "static void check_cb_ovld_locked(struct rcu_data *rdp, struct rcu_node *rnp);",
      "static bool rcu_rdp_is_offloaded(struct rcu_data *rdp);",
      "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tick_dep_set",
          "args": [
            "TICK_DEP_BIT_RCU"
          ],
          "line": 4260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcutree_affinity_setting",
          "args": [
            "cpu",
            "cpu"
          ],
          "line": 4257
        },
        "resolved": true,
        "details": {
          "function_name": "rcutree_affinity_setting",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "4209-4214",
          "snippet": "static void rcutree_affinity_setting(unsigned int cpu, int outgoing)\n{\n\tstruct rcu_data *rdp = per_cpu_ptr(&rcu_data, cpu);\n\n\trcu_boost_kthread_setaffinity(rdp->mynode, outgoing);\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};",
            "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
            "static void sync_sched_exp_online_cleanup(int cpu);",
            "static bool rcu_rdp_is_offloaded(struct rcu_data *rdp);",
            "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void sync_sched_exp_online_cleanup(int cpu);\nstatic bool rcu_rdp_is_offloaded(struct rcu_data *rdp);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nstatic void rcutree_affinity_setting(unsigned int cpu, int outgoing)\n{\n\tstruct rcu_data *rdp = per_cpu_ptr(&rcu_data, cpu);\n\n\trcu_boost_kthread_setaffinity(rdp->mynode, outgoing);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore_rcu_node",
          "args": [
            "rnp",
            "flags"
          ],
          "line": 4255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave_rcu_node",
          "args": [
            "rnp",
            "flags"
          ],
          "line": 4253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "&rcu_data",
            "cpu"
          ],
          "line": 4251
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};\nstatic void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void sync_sched_exp_online_cleanup(int cpu);\nstatic void check_cb_ovld_locked(struct rcu_data *rdp, struct rcu_node *rnp);\nstatic bool rcu_rdp_is_offloaded(struct rcu_data *rdp);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nint rcutree_offline_cpu(unsigned int cpu)\n{\n\tunsigned long flags;\n\tstruct rcu_data *rdp;\n\tstruct rcu_node *rnp;\n\n\trdp = per_cpu_ptr(&rcu_data, cpu);\n\trnp = rdp->mynode;\n\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\trnp->ffmask &= ~rdp->grpmask;\n\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\n\trcutree_affinity_setting(cpu, cpu);\n\n\t// nohz_full CPUs need the tick for stop-machine to work quickly\n\ttick_dep_set(TICK_DEP_BIT_RCU);\n\treturn 0;\n}"
  },
  {
    "function_name": "rcutree_online_cpu",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
    "lines": "4220-4239",
    "snippet": "int rcutree_online_cpu(unsigned int cpu)\n{\n\tunsigned long flags;\n\tstruct rcu_data *rdp;\n\tstruct rcu_node *rnp;\n\n\trdp = per_cpu_ptr(&rcu_data, cpu);\n\trnp = rdp->mynode;\n\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\trnp->ffmask |= rdp->grpmask;\n\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\tif (rcu_scheduler_active == RCU_SCHEDULER_INACTIVE)\n\t\treturn 0; /* Too early in boot for scheduler work. */\n\tsync_sched_exp_online_cleanup(cpu);\n\trcutree_affinity_setting(cpu, -1);\n\n\t// Stop-machine done, so allow nohz_full to disable tick.\n\ttick_dep_clear(TICK_DEP_BIT_RCU);\n\treturn 0;\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_nocb.h\"",
      "#include \"tree_exp.h\"",
      "#include \"tree_stall.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <linux/kasan.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/panic_notifier.h>",
      "#include <linux/panic.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};",
      "int rcu_scheduler_active",
      "static void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);",
      "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
      "static void sync_sched_exp_online_cleanup(int cpu);",
      "static void check_cb_ovld_locked(struct rcu_data *rdp, struct rcu_node *rnp);",
      "static bool rcu_rdp_is_offloaded(struct rcu_data *rdp);",
      "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tick_dep_clear",
          "args": [
            "TICK_DEP_BIT_RCU"
          ],
          "line": 4237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcutree_affinity_setting",
          "args": [
            "cpu",
            "-1"
          ],
          "line": 4234
        },
        "resolved": true,
        "details": {
          "function_name": "rcutree_affinity_setting",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "4209-4214",
          "snippet": "static void rcutree_affinity_setting(unsigned int cpu, int outgoing)\n{\n\tstruct rcu_data *rdp = per_cpu_ptr(&rcu_data, cpu);\n\n\trcu_boost_kthread_setaffinity(rdp->mynode, outgoing);\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};",
            "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
            "static void sync_sched_exp_online_cleanup(int cpu);",
            "static bool rcu_rdp_is_offloaded(struct rcu_data *rdp);",
            "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void sync_sched_exp_online_cleanup(int cpu);\nstatic bool rcu_rdp_is_offloaded(struct rcu_data *rdp);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nstatic void rcutree_affinity_setting(unsigned int cpu, int outgoing)\n{\n\tstruct rcu_data *rdp = per_cpu_ptr(&rcu_data, cpu);\n\n\trcu_boost_kthread_setaffinity(rdp->mynode, outgoing);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sync_sched_exp_online_cleanup",
          "args": [
            "cpu"
          ],
          "line": 4233
        },
        "resolved": true,
        "details": {
          "function_name": "sync_sched_exp_online_cleanup",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_exp.h",
          "lines": "753-782",
          "snippet": "static void sync_sched_exp_online_cleanup(int cpu)\n{\n\tunsigned long flags;\n\tint my_cpu;\n\tstruct rcu_data *rdp;\n\tint ret;\n\tstruct rcu_node *rnp;\n\n\trdp = per_cpu_ptr(&rcu_data, cpu);\n\trnp = rdp->mynode;\n\tmy_cpu = get_cpu();\n\t/* Quiescent state either not needed or already requested, leave. */\n\tif (!(READ_ONCE(rnp->expmask) & rdp->grpmask) ||\n\t    READ_ONCE(rdp->cpu_no_qs.b.exp)) {\n\t\tput_cpu();\n\t\treturn;\n\t}\n\t/* Quiescent state needed on current CPU, so set it up locally. */\n\tif (my_cpu == cpu) {\n\t\tlocal_irq_save(flags);\n\t\trcu_exp_need_qs();\n\t\tlocal_irq_restore(flags);\n\t\tput_cpu();\n\t\treturn;\n\t}\n\t/* Quiescent state needed on some other CPU, send IPI. */\n\tret = smp_call_function_single(cpu, rcu_exp_handler, NULL, 0);\n\tput_cpu();\n\tWARN_ON_ONCE(ret);\n}",
          "includes": [
            "#include <linux/lockdep.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int rcu_print_task_exp_stall(struct rcu_node *rnp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockdep.h>\n\nstatic int rcu_print_task_exp_stall(struct rcu_node *rnp);\n\nstatic void sync_sched_exp_online_cleanup(int cpu)\n{\n\tunsigned long flags;\n\tint my_cpu;\n\tstruct rcu_data *rdp;\n\tint ret;\n\tstruct rcu_node *rnp;\n\n\trdp = per_cpu_ptr(&rcu_data, cpu);\n\trnp = rdp->mynode;\n\tmy_cpu = get_cpu();\n\t/* Quiescent state either not needed or already requested, leave. */\n\tif (!(READ_ONCE(rnp->expmask) & rdp->grpmask) ||\n\t    READ_ONCE(rdp->cpu_no_qs.b.exp)) {\n\t\tput_cpu();\n\t\treturn;\n\t}\n\t/* Quiescent state needed on current CPU, so set it up locally. */\n\tif (my_cpu == cpu) {\n\t\tlocal_irq_save(flags);\n\t\trcu_exp_need_qs();\n\t\tlocal_irq_restore(flags);\n\t\tput_cpu();\n\t\treturn;\n\t}\n\t/* Quiescent state needed on some other CPU, send IPI. */\n\tret = smp_call_function_single(cpu, rcu_exp_handler, NULL, 0);\n\tput_cpu();\n\tWARN_ON_ONCE(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore_rcu_node",
          "args": [
            "rnp",
            "flags"
          ],
          "line": 4230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave_rcu_node",
          "args": [
            "rnp",
            "flags"
          ],
          "line": 4228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "&rcu_data",
            "cpu"
          ],
          "line": 4226
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};\nint rcu_scheduler_active;\nstatic void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void sync_sched_exp_online_cleanup(int cpu);\nstatic void check_cb_ovld_locked(struct rcu_data *rdp, struct rcu_node *rnp);\nstatic bool rcu_rdp_is_offloaded(struct rcu_data *rdp);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nint rcutree_online_cpu(unsigned int cpu)\n{\n\tunsigned long flags;\n\tstruct rcu_data *rdp;\n\tstruct rcu_node *rnp;\n\n\trdp = per_cpu_ptr(&rcu_data, cpu);\n\trnp = rdp->mynode;\n\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\trnp->ffmask |= rdp->grpmask;\n\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\tif (rcu_scheduler_active == RCU_SCHEDULER_INACTIVE)\n\t\treturn 0; /* Too early in boot for scheduler work. */\n\tsync_sched_exp_online_cleanup(cpu);\n\trcutree_affinity_setting(cpu, -1);\n\n\t// Stop-machine done, so allow nohz_full to disable tick.\n\ttick_dep_clear(TICK_DEP_BIT_RCU);\n\treturn 0;\n}"
  },
  {
    "function_name": "rcutree_affinity_setting",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
    "lines": "4209-4214",
    "snippet": "static void rcutree_affinity_setting(unsigned int cpu, int outgoing)\n{\n\tstruct rcu_data *rdp = per_cpu_ptr(&rcu_data, cpu);\n\n\trcu_boost_kthread_setaffinity(rdp->mynode, outgoing);\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_nocb.h\"",
      "#include \"tree_exp.h\"",
      "#include \"tree_stall.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <linux/kasan.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/panic_notifier.h>",
      "#include <linux/panic.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};",
      "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
      "static void sync_sched_exp_online_cleanup(int cpu);",
      "static bool rcu_rdp_is_offloaded(struct rcu_data *rdp);",
      "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_boost_kthread_setaffinity",
          "args": [
            "rdp->mynode",
            "outgoing"
          ],
          "line": 4213
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_boost_kthread_setaffinity",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "1257-1259",
          "snippet": "static void rcu_boost_kthread_setaffinity(struct rcu_node *rnp, int outgoingcpu)\n{\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nstatic void rcu_boost_kthread_setaffinity(struct rcu_node *rnp, int outgoingcpu)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "&rcu_data",
            "cpu"
          ],
          "line": 4211
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void sync_sched_exp_online_cleanup(int cpu);\nstatic bool rcu_rdp_is_offloaded(struct rcu_data *rdp);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nstatic void rcutree_affinity_setting(unsigned int cpu, int outgoing)\n{\n\tstruct rcu_data *rdp = per_cpu_ptr(&rcu_data, cpu);\n\n\trcu_boost_kthread_setaffinity(rdp->mynode, outgoing);\n}"
  },
  {
    "function_name": "rcutree_prepare_cpu",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
    "lines": "4161-4204",
    "snippet": "int rcutree_prepare_cpu(unsigned int cpu)\n{\n\tunsigned long flags;\n\tstruct rcu_data *rdp = per_cpu_ptr(&rcu_data, cpu);\n\tstruct rcu_node *rnp = rcu_get_root();\n\n\t/* Set up local state, ensuring consistent view of global state. */\n\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\trdp->qlen_last_fqs_check = 0;\n\trdp->n_force_qs_snap = READ_ONCE(rcu_state.n_force_qs);\n\trdp->blimit = blimit;\n\trdp->dynticks_nesting = 1;\t/* CPU not up, no tearing. */\n\traw_spin_unlock_rcu_node(rnp);\t\t/* irqs remain disabled. */\n\n\t/*\n\t * Only non-NOCB CPUs that didn't have early-boot callbacks need to be\n\t * (re-)initialized.\n\t */\n\tif (!rcu_segcblist_is_enabled(&rdp->cblist))\n\t\trcu_segcblist_init(&rdp->cblist);  /* Re-enable callbacks. */\n\n\t/*\n\t * Add CPU to leaf rcu_node pending-online bitmask.  Any needed\n\t * propagation up the rcu_node tree will happen at the beginning\n\t * of the next grace period.\n\t */\n\trnp = rdp->mynode;\n\traw_spin_lock_rcu_node(rnp);\t\t/* irqs already disabled. */\n\trdp->beenonline = true;\t /* We have now been online. */\n\trdp->gp_seq = READ_ONCE(rnp->gp_seq);\n\trdp->gp_seq_needed = rdp->gp_seq;\n\trdp->cpu_no_qs.b.norm = true;\n\trdp->core_needs_qs = false;\n\trdp->rcu_iw_pending = false;\n\trdp->rcu_iw = IRQ_WORK_INIT_HARD(rcu_iw_handler);\n\trdp->rcu_iw_gp_seq = rdp->gp_seq - 1;\n\ttrace_rcu_grace_period(rcu_state.name, rdp->gp_seq, TPS(\"cpuonl\"));\n\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\trcu_spawn_one_boost_kthread(rnp);\n\trcu_spawn_cpu_nocb_kthread(cpu);\n\tWRITE_ONCE(rcu_state.n_online_cpus, rcu_state.n_online_cpus + 1);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_nocb.h\"",
      "#include \"tree_exp.h\"",
      "#include \"tree_stall.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <linux/kasan.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/panic_notifier.h>",
      "#include <linux/panic.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};",
      "static struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};",
      "static void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);",
      "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
      "static void sync_sched_exp_online_cleanup(int cpu);",
      "static void check_cb_ovld_locked(struct rcu_data *rdp, struct rcu_node *rnp);",
      "static bool rcu_rdp_is_offloaded(struct rcu_data *rdp);",
      "static long blimit = DEFAULT_RCU_BLIMIT;",
      "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "rcu_state.n_online_cpus",
            "rcu_state.n_online_cpus + 1"
          ],
          "line": 4201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_spawn_cpu_nocb_kthread",
          "args": [
            "cpu"
          ],
          "line": 4200
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_spawn_cpu_nocb_kthread",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_nocb.h",
          "lines": "1536-1538",
          "snippet": "static void rcu_spawn_cpu_nocb_kthread(int cpu)\n{\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static void rcu_spawn_cpu_nocb_kthread(int cpu)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_spawn_one_boost_kthread",
          "args": [
            "rnp"
          ],
          "line": 4199
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_spawn_one_boost_kthread",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "1253-1255",
          "snippet": "static void rcu_spawn_one_boost_kthread(struct rcu_node *rnp)\n{\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nstatic void rcu_spawn_one_boost_kthread(struct rcu_node *rnp)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore_rcu_node",
          "args": [
            "rnp",
            "flags"
          ],
          "line": 4198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_rcu_grace_period",
          "args": [
            "rcu_state.name",
            "rdp->gp_seq",
            "TPS(\"cpuonl\")"
          ],
          "line": 4197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPS",
          "args": [
            "\"cpuonl\""
          ],
          "line": 4197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IRQ_WORK_INIT_HARD",
          "args": [
            "rcu_iw_handler"
          ],
          "line": 4195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rnp->gp_seq"
          ],
          "line": 4190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_rcu_node",
          "args": [
            "rnp"
          ],
          "line": 4188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_segcblist_init",
          "args": [
            "&rdp->cblist"
          ],
          "line": 4180
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_init",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.c",
          "lines": "237-250",
          "snippet": "void rcu_segcblist_init(struct rcu_segcblist *rsclp)\n{\n\tint i;\n\n\tBUILD_BUG_ON(RCU_NEXT_TAIL + 1 != ARRAY_SIZE(rsclp->gp_seq));\n\tBUILD_BUG_ON(ARRAY_SIZE(rsclp->tails) != ARRAY_SIZE(rsclp->gp_seq));\n\trsclp->head = NULL;\n\tfor (i = 0; i < RCU_CBLIST_NSEGS; i++) {\n\t\trsclp->tails[i] = &rsclp->head;\n\t\trcu_segcblist_set_seglen(rsclp, i, 0);\n\t}\n\trcu_segcblist_set_len(rsclp, 0);\n\trcu_segcblist_set_flags(rsclp, SEGCBLIST_ENABLED);\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/cpu.h>\n\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp)\n{\n\tint i;\n\n\tBUILD_BUG_ON(RCU_NEXT_TAIL + 1 != ARRAY_SIZE(rsclp->gp_seq));\n\tBUILD_BUG_ON(ARRAY_SIZE(rsclp->tails) != ARRAY_SIZE(rsclp->gp_seq));\n\trsclp->head = NULL;\n\tfor (i = 0; i < RCU_CBLIST_NSEGS; i++) {\n\t\trsclp->tails[i] = &rsclp->head;\n\t\trcu_segcblist_set_seglen(rsclp, i, 0);\n\t}\n\trcu_segcblist_set_len(rsclp, 0);\n\trcu_segcblist_set_flags(rsclp, SEGCBLIST_ENABLED);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_segcblist_is_enabled",
          "args": [
            "&rdp->cblist"
          ],
          "line": 4179
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_is_enabled",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "78-81",
          "snippet": "static inline bool rcu_segcblist_is_enabled(struct rcu_segcblist *rsclp)\n{\n\treturn rcu_segcblist_test_flags(rsclp, SEGCBLIST_ENABLED);\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "long rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nlong rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_is_enabled(struct rcu_segcblist *rsclp)\n{\n\treturn rcu_segcblist_test_flags(rsclp, SEGCBLIST_ENABLED);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_rcu_node",
          "args": [
            "rnp"
          ],
          "line": 4173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rcu_state.n_force_qs"
          ],
          "line": 4170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave_rcu_node",
          "args": [
            "rnp",
            "flags"
          ],
          "line": 4168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_get_root",
          "args": [],
          "line": 4165
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_get_root",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "579-582",
          "snippet": "static struct rcu_node *rcu_get_root(void)\n{\n\treturn &rcu_state.node[0];\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\n\nstatic struct rcu_node *rcu_get_root(void)\n{\n\treturn &rcu_state.node[0];\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "&rcu_data",
            "cpu"
          ],
          "line": 4164
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};\nstatic struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\nstatic void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void sync_sched_exp_online_cleanup(int cpu);\nstatic void check_cb_ovld_locked(struct rcu_data *rdp, struct rcu_node *rnp);\nstatic bool rcu_rdp_is_offloaded(struct rcu_data *rdp);\nstatic long blimit = DEFAULT_RCU_BLIMIT;\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nint rcutree_prepare_cpu(unsigned int cpu)\n{\n\tunsigned long flags;\n\tstruct rcu_data *rdp = per_cpu_ptr(&rcu_data, cpu);\n\tstruct rcu_node *rnp = rcu_get_root();\n\n\t/* Set up local state, ensuring consistent view of global state. */\n\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\trdp->qlen_last_fqs_check = 0;\n\trdp->n_force_qs_snap = READ_ONCE(rcu_state.n_force_qs);\n\trdp->blimit = blimit;\n\trdp->dynticks_nesting = 1;\t/* CPU not up, no tearing. */\n\traw_spin_unlock_rcu_node(rnp);\t\t/* irqs remain disabled. */\n\n\t/*\n\t * Only non-NOCB CPUs that didn't have early-boot callbacks need to be\n\t * (re-)initialized.\n\t */\n\tif (!rcu_segcblist_is_enabled(&rdp->cblist))\n\t\trcu_segcblist_init(&rdp->cblist);  /* Re-enable callbacks. */\n\n\t/*\n\t * Add CPU to leaf rcu_node pending-online bitmask.  Any needed\n\t * propagation up the rcu_node tree will happen at the beginning\n\t * of the next grace period.\n\t */\n\trnp = rdp->mynode;\n\traw_spin_lock_rcu_node(rnp);\t\t/* irqs already disabled. */\n\trdp->beenonline = true;\t /* We have now been online. */\n\trdp->gp_seq = READ_ONCE(rnp->gp_seq);\n\trdp->gp_seq_needed = rdp->gp_seq;\n\trdp->cpu_no_qs.b.norm = true;\n\trdp->core_needs_qs = false;\n\trdp->rcu_iw_pending = false;\n\trdp->rcu_iw = IRQ_WORK_INIT_HARD(rcu_iw_handler);\n\trdp->rcu_iw_gp_seq = rdp->gp_seq - 1;\n\ttrace_rcu_grace_period(rcu_state.name, rdp->gp_seq, TPS(\"cpuonl\"));\n\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\trcu_spawn_one_boost_kthread(rnp);\n\trcu_spawn_cpu_nocb_kthread(cpu);\n\tWRITE_ONCE(rcu_state.n_online_cpus, rcu_state.n_online_cpus + 1);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "rcu_boot_init_percpu_data",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
    "lines": "4133-4149",
    "snippet": "static void __init\nrcu_boot_init_percpu_data(int cpu)\n{\n\tstruct rcu_data *rdp = per_cpu_ptr(&rcu_data, cpu);\n\n\t/* Set up local state, ensuring consistent view of global state. */\n\trdp->grpmask = leaf_node_cpu_bit(rdp->mynode, cpu);\n\tINIT_WORK(&rdp->strict_work, strict_work_handler);\n\tWARN_ON_ONCE(rdp->dynticks_nesting != 1);\n\tWARN_ON_ONCE(rcu_dynticks_in_eqs(rcu_dynticks_snap(rdp)));\n\trdp->rcu_ofl_gp_seq = rcu_state.gp_seq;\n\trdp->rcu_ofl_gp_flags = RCU_GP_CLEANED;\n\trdp->rcu_onl_gp_seq = rcu_state.gp_seq;\n\trdp->rcu_onl_gp_flags = RCU_GP_CLEANED;\n\trdp->cpu = cpu;\n\trcu_boot_init_nocb_percpu_data(rdp);\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_nocb.h\"",
      "#include \"tree_exp.h\"",
      "#include \"tree_stall.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <linux/kasan.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/panic_notifier.h>",
      "#include <linux/panic.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};",
      "static struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};",
      "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
      "static void sync_sched_exp_online_cleanup(int cpu);",
      "static bool rcu_rdp_is_offloaded(struct rcu_data *rdp);",
      "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_boot_init_nocb_percpu_data",
          "args": [
            "rdp"
          ],
          "line": 4148
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_boot_init_nocb_percpu_data",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_nocb.h",
          "lines": "1522-1524",
          "snippet": "static void __init rcu_boot_init_nocb_percpu_data(struct rcu_data *rdp)\n{\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static void __init rcu_boot_init_nocb_percpu_data(struct rcu_data *rdp)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "rcu_dynticks_in_eqs(rcu_dynticks_snap(rdp))"
          ],
          "line": 4142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_dynticks_in_eqs",
          "args": [
            "rcu_dynticks_snap(rdp)"
          ],
          "line": 4142
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_dynticks_in_eqs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "347-350",
          "snippet": "static bool rcu_dynticks_in_eqs(int snap)\n{\n\treturn !(snap & 0x1);\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic bool rcu_dynticks_in_eqs(int snap)\n{\n\treturn !(snap & 0x1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_dynticks_snap",
          "args": [
            "rdp"
          ],
          "line": 4142
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_dynticks_snap",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "337-341",
          "snippet": "static int rcu_dynticks_snap(struct rcu_data *rdp)\n{\n\tsmp_mb();  // Fundamental RCU ordering guarantee.\n\treturn atomic_read_acquire(&rdp->dynticks);\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};",
            "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
            "static bool rcu_rdp_is_offloaded(struct rcu_data *rdp);",
            "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic bool rcu_rdp_is_offloaded(struct rcu_data *rdp);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nstatic int rcu_dynticks_snap(struct rcu_data *rdp)\n{\n\tsmp_mb();  // Fundamental RCU ordering guarantee.\n\treturn atomic_read_acquire(&rdp->dynticks);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "rdp->dynticks_nesting != 1"
          ],
          "line": 4141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_WORK",
          "args": [
            "&rdp->strict_work",
            "strict_work_handler"
          ],
          "line": 4140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "leaf_node_cpu_bit",
          "args": [
            "rdp->mynode",
            "cpu"
          ],
          "line": 4139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "&rcu_data",
            "cpu"
          ],
          "line": 4136
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};\nstatic struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void sync_sched_exp_online_cleanup(int cpu);\nstatic bool rcu_rdp_is_offloaded(struct rcu_data *rdp);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nstatic void __init\nrcu_boot_init_percpu_data(int cpu)\n{\n\tstruct rcu_data *rdp = per_cpu_ptr(&rcu_data, cpu);\n\n\t/* Set up local state, ensuring consistent view of global state. */\n\trdp->grpmask = leaf_node_cpu_bit(rdp->mynode, cpu);\n\tINIT_WORK(&rdp->strict_work, strict_work_handler);\n\tWARN_ON_ONCE(rdp->dynticks_nesting != 1);\n\tWARN_ON_ONCE(rcu_dynticks_in_eqs(rcu_dynticks_snap(rdp)));\n\trdp->rcu_ofl_gp_seq = rcu_state.gp_seq;\n\trdp->rcu_ofl_gp_flags = RCU_GP_CLEANED;\n\trdp->rcu_onl_gp_seq = rcu_state.gp_seq;\n\trdp->rcu_onl_gp_flags = RCU_GP_CLEANED;\n\trdp->cpu = cpu;\n\trcu_boot_init_nocb_percpu_data(rdp);\n}"
  },
  {
    "function_name": "rcu_init_new_rnp",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
    "lines": "4108-4128",
    "snippet": "static void rcu_init_new_rnp(struct rcu_node *rnp_leaf)\n{\n\tlong mask;\n\tlong oldmask;\n\tstruct rcu_node *rnp = rnp_leaf;\n\n\traw_lockdep_assert_held_rcu_node(rnp_leaf);\n\tWARN_ON_ONCE(rnp->wait_blkd_tasks);\n\tfor (;;) {\n\t\tmask = rnp->grpmask;\n\t\trnp = rnp->parent;\n\t\tif (rnp == NULL)\n\t\t\treturn;\n\t\traw_spin_lock_rcu_node(rnp); /* Interrupts already disabled. */\n\t\toldmask = rnp->qsmaskinit;\n\t\trnp->qsmaskinit |= mask;\n\t\traw_spin_unlock_rcu_node(rnp); /* Interrupts remain disabled. */\n\t\tif (oldmask)\n\t\t\treturn;\n\t}\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_nocb.h\"",
      "#include \"tree_exp.h\"",
      "#include \"tree_stall.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <linux/kasan.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/panic_notifier.h>",
      "#include <linux/panic.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void rcu_init_new_rnp(struct rcu_node *rnp_leaf);",
      "static void rcu_cleanup_dead_rnp(struct rcu_node *rnp_leaf);",
      "static void check_cb_ovld_locked(struct rcu_data *rdp, struct rcu_node *rnp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock_rcu_node",
          "args": [
            "rnp"
          ],
          "line": 4124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_rcu_node",
          "args": [
            "rnp"
          ],
          "line": 4121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "rnp->wait_blkd_tasks"
          ],
          "line": 4115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_lockdep_assert_held_rcu_node",
          "args": [
            "rnp_leaf"
          ],
          "line": 4114
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic void rcu_init_new_rnp(struct rcu_node *rnp_leaf);\nstatic void rcu_cleanup_dead_rnp(struct rcu_node *rnp_leaf);\nstatic void check_cb_ovld_locked(struct rcu_data *rdp, struct rcu_node *rnp);\n\nstatic void rcu_init_new_rnp(struct rcu_node *rnp_leaf)\n{\n\tlong mask;\n\tlong oldmask;\n\tstruct rcu_node *rnp = rnp_leaf;\n\n\traw_lockdep_assert_held_rcu_node(rnp_leaf);\n\tWARN_ON_ONCE(rnp->wait_blkd_tasks);\n\tfor (;;) {\n\t\tmask = rnp->grpmask;\n\t\trnp = rnp->parent;\n\t\tif (rnp == NULL)\n\t\t\treturn;\n\t\traw_spin_lock_rcu_node(rnp); /* Interrupts already disabled. */\n\t\toldmask = rnp->qsmaskinit;\n\t\trnp->qsmaskinit |= mask;\n\t\traw_spin_unlock_rcu_node(rnp); /* Interrupts remain disabled. */\n\t\tif (oldmask)\n\t\t\treturn;\n\t}\n}"
  },
  {
    "function_name": "rcu_barrier",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
    "lines": "4017-4099",
    "snippet": "void rcu_barrier(void)\n{\n\tuintptr_t cpu;\n\tstruct rcu_data *rdp;\n\tunsigned long s = rcu_seq_snap(&rcu_state.barrier_sequence);\n\n\trcu_barrier_trace(TPS(\"Begin\"), -1, s);\n\n\t/* Take mutex to serialize concurrent rcu_barrier() requests. */\n\tmutex_lock(&rcu_state.barrier_mutex);\n\n\t/* Did someone else do our work for us? */\n\tif (rcu_seq_done(&rcu_state.barrier_sequence, s)) {\n\t\trcu_barrier_trace(TPS(\"EarlyExit\"), -1,\n\t\t\t\t  rcu_state.barrier_sequence);\n\t\tsmp_mb(); /* caller's subsequent code after above check. */\n\t\tmutex_unlock(&rcu_state.barrier_mutex);\n\t\treturn;\n\t}\n\n\t/* Mark the start of the barrier operation. */\n\trcu_seq_start(&rcu_state.barrier_sequence);\n\trcu_barrier_trace(TPS(\"Inc1\"), -1, rcu_state.barrier_sequence);\n\n\t/*\n\t * Initialize the count to two rather than to zero in order\n\t * to avoid a too-soon return to zero in case of an immediate\n\t * invocation of the just-enqueued callback (or preemption of\n\t * this task).  Exclude CPU-hotplug operations to ensure that no\n\t * offline non-offloaded CPU has callbacks queued.\n\t */\n\tinit_completion(&rcu_state.barrier_completion);\n\tatomic_set(&rcu_state.barrier_cpu_count, 2);\n\tcpus_read_lock();\n\n\t/*\n\t * Force each CPU with callbacks to register a new callback.\n\t * When that callback is invoked, we will know that all of the\n\t * corresponding CPU's preceding callbacks have been invoked.\n\t */\n\tfor_each_possible_cpu(cpu) {\n\t\trdp = per_cpu_ptr(&rcu_data, cpu);\n\t\tif (cpu_is_offline(cpu) &&\n\t\t    !rcu_rdp_is_offloaded(rdp))\n\t\t\tcontinue;\n\t\tif (rcu_segcblist_n_cbs(&rdp->cblist) && cpu_online(cpu)) {\n\t\t\trcu_barrier_trace(TPS(\"OnlineQ\"), cpu,\n\t\t\t\t\t  rcu_state.barrier_sequence);\n\t\t\tsmp_call_function_single(cpu, rcu_barrier_func, (void *)cpu, 1);\n\t\t} else if (rcu_segcblist_n_cbs(&rdp->cblist) &&\n\t\t\t   cpu_is_offline(cpu)) {\n\t\t\trcu_barrier_trace(TPS(\"OfflineNoCBQ\"), cpu,\n\t\t\t\t\t  rcu_state.barrier_sequence);\n\t\t\tlocal_irq_disable();\n\t\t\trcu_barrier_func((void *)cpu);\n\t\t\tlocal_irq_enable();\n\t\t} else if (cpu_is_offline(cpu)) {\n\t\t\trcu_barrier_trace(TPS(\"OfflineNoCBNoQ\"), cpu,\n\t\t\t\t\t  rcu_state.barrier_sequence);\n\t\t} else {\n\t\t\trcu_barrier_trace(TPS(\"OnlineNQ\"), cpu,\n\t\t\t\t\t  rcu_state.barrier_sequence);\n\t\t}\n\t}\n\tcpus_read_unlock();\n\n\t/*\n\t * Now that we have an rcu_barrier_callback() callback on each\n\t * CPU, and thus each counted, remove the initial count.\n\t */\n\tif (atomic_sub_and_test(2, &rcu_state.barrier_cpu_count))\n\t\tcomplete(&rcu_state.barrier_completion);\n\n\t/* Wait for all rcu_barrier_callback() callbacks to be invoked. */\n\twait_for_completion(&rcu_state.barrier_completion);\n\n\t/* Mark the end of the barrier operation. */\n\trcu_barrier_trace(TPS(\"Inc2\"), -1, rcu_state.barrier_sequence);\n\trcu_seq_end(&rcu_state.barrier_sequence);\n\n\t/* Other rcu_barrier() invocations can now safely proceed. */\n\tmutex_unlock(&rcu_state.barrier_mutex);\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_nocb.h\"",
      "#include \"tree_exp.h\"",
      "#include \"tree_stall.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <linux/kasan.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/panic_notifier.h>",
      "#include <linux/panic.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};",
      "static struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};",
      "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
      "static void sync_sched_exp_online_cleanup(int cpu);",
      "static bool rcu_rdp_is_offloaded(struct rcu_data *rdp);",
      "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&rcu_state.barrier_mutex"
          ],
          "line": 4098
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_seq_end",
          "args": [
            "&rcu_state.barrier_sequence"
          ],
          "line": 4095
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_seq_end",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu.h",
          "lines": "69-74",
          "snippet": "static inline void rcu_seq_end(unsigned long *sp)\n{\n\tsmp_mb(); /* Ensure update-side operation before counter increment. */\n\tWARN_ON_ONCE(!rcu_seq_state(*sp));\n\tWRITE_ONCE(*sp, rcu_seq_endval(sp));\n}",
          "includes": [
            "#include <linux/rcu_node_tree.h>",
            "#include <trace/events/rcu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_node_tree.h>\n#include <trace/events/rcu.h>\n\nstatic inline void rcu_seq_end(unsigned long *sp)\n{\n\tsmp_mb(); /* Ensure update-side operation before counter increment. */\n\tWARN_ON_ONCE(!rcu_seq_state(*sp));\n\tWRITE_ONCE(*sp, rcu_seq_endval(sp));\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_barrier_trace",
          "args": [
            "TPS(\"Inc2\")",
            "-1",
            "rcu_state.barrier_sequence"
          ],
          "line": 4094
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_barrier_trace",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "3958-3962",
          "snippet": "static void rcu_barrier_trace(const char *s, int cpu, unsigned long done)\n{\n\ttrace_rcu_barrier(rcu_state.name, s, cpu,\n\t\t\t  atomic_read(&rcu_state.barrier_cpu_count), done);\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};",
            "static void sync_sched_exp_online_cleanup(int cpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\nstatic void sync_sched_exp_online_cleanup(int cpu);\n\nstatic void rcu_barrier_trace(const char *s, int cpu, unsigned long done)\n{\n\ttrace_rcu_barrier(rcu_state.name, s, cpu,\n\t\t\t  atomic_read(&rcu_state.barrier_cpu_count), done);\n}"
        }
      },
      {
        "call_info": {
          "callee": "TPS",
          "args": [
            "\"Inc2\""
          ],
          "line": 4094
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_for_completion",
          "args": [
            "&rcu_state.barrier_completion"
          ],
          "line": 4091
        },
        "resolved": true,
        "details": {
          "function_name": "try_wait_for_completion",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/completion.c",
          "lines": "282-303",
          "snippet": "bool try_wait_for_completion(struct completion *x)\n{\n\tunsigned long flags;\n\tbool ret = true;\n\n\t/*\n\t * Since x->done will need to be locked only\n\t * in the non-blocking case, we check x->done\n\t * first without taking the lock so we can\n\t * return early in the blocking case.\n\t */\n\tif (!READ_ONCE(x->done))\n\t\treturn false;\n\n\traw_spin_lock_irqsave(&x->wait.lock, flags);\n\tif (!x->done)\n\t\tret = false;\n\telse if (x->done != UINT_MAX)\n\t\tx->done--;\n\traw_spin_unlock_irqrestore(&x->wait.lock, flags);\n\treturn ret;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nbool try_wait_for_completion(struct completion *x)\n{\n\tunsigned long flags;\n\tbool ret = true;\n\n\t/*\n\t * Since x->done will need to be locked only\n\t * in the non-blocking case, we check x->done\n\t * first without taking the lock so we can\n\t * return early in the blocking case.\n\t */\n\tif (!READ_ONCE(x->done))\n\t\treturn false;\n\n\traw_spin_lock_irqsave(&x->wait.lock, flags);\n\tif (!x->done)\n\t\tret = false;\n\telse if (x->done != UINT_MAX)\n\t\tx->done--;\n\traw_spin_unlock_irqrestore(&x->wait.lock, flags);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "complete",
          "args": [
            "&rcu_state.barrier_completion"
          ],
          "line": 4088
        },
        "resolved": true,
        "details": {
          "function_name": "srcu_batches_completed",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/srcutree.c",
          "lines": "1162-1165",
          "snippet": "unsigned long srcu_batches_completed(struct srcu_struct *ssp)\n{\n\treturn READ_ONCE(ssp->srcu_idx);\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include \"rcu.h\"",
            "#include <linux/srcu.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nunsigned long srcu_batches_completed(struct srcu_struct *ssp)\n{\n\treturn READ_ONCE(ssp->srcu_idx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_sub_and_test",
          "args": [
            "2",
            "&rcu_state.barrier_cpu_count"
          ],
          "line": 4087
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpus_read_unlock",
          "args": [],
          "line": 4081
        },
        "resolved": true,
        "details": {
          "function_name": "cpus_read_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "319-322",
          "snippet": "void cpus_read_unlock(void)\n{\n\tpercpu_up_read(&cpu_hotplug_lock);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nvoid cpus_read_unlock(void)\n{\n\tpercpu_up_read(&cpu_hotplug_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "TPS",
          "args": [
            "\"OnlineNQ\""
          ],
          "line": 4077
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPS",
          "args": [
            "\"OfflineNoCBNoQ\""
          ],
          "line": 4074
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_is_offline",
          "args": [
            "cpu"
          ],
          "line": 4073
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_enable",
          "args": [],
          "line": 4072
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_barrier_func",
          "args": [
            "(void *)cpu"
          ],
          "line": 4071
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_barrier_func",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "3989-4007",
          "snippet": "static void rcu_barrier_func(void *cpu_in)\n{\n\tuintptr_t cpu = (uintptr_t)cpu_in;\n\tstruct rcu_data *rdp = per_cpu_ptr(&rcu_data, cpu);\n\n\trcu_barrier_trace(TPS(\"IRQ\"), -1, rcu_state.barrier_sequence);\n\trdp->barrier_head.func = rcu_barrier_callback;\n\tdebug_rcu_head_queue(&rdp->barrier_head);\n\trcu_nocb_lock(rdp);\n\tWARN_ON_ONCE(!rcu_nocb_flush_bypass(rdp, NULL, jiffies));\n\tif (rcu_segcblist_entrain(&rdp->cblist, &rdp->barrier_head)) {\n\t\tatomic_inc(&rcu_state.barrier_cpu_count);\n\t} else {\n\t\tdebug_rcu_head_unqueue(&rdp->barrier_head);\n\t\trcu_barrier_trace(TPS(\"IRQNQ\"), -1,\n\t\t\t\t  rcu_state.barrier_sequence);\n\t}\n\trcu_nocb_unlock(rdp);\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};",
            "static struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};",
            "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
            "static void sync_sched_exp_online_cleanup(int cpu);",
            "static bool rcu_rdp_is_offloaded(struct rcu_data *rdp);",
            "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};\nstatic struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void sync_sched_exp_online_cleanup(int cpu);\nstatic bool rcu_rdp_is_offloaded(struct rcu_data *rdp);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nstatic void rcu_barrier_func(void *cpu_in)\n{\n\tuintptr_t cpu = (uintptr_t)cpu_in;\n\tstruct rcu_data *rdp = per_cpu_ptr(&rcu_data, cpu);\n\n\trcu_barrier_trace(TPS(\"IRQ\"), -1, rcu_state.barrier_sequence);\n\trdp->barrier_head.func = rcu_barrier_callback;\n\tdebug_rcu_head_queue(&rdp->barrier_head);\n\trcu_nocb_lock(rdp);\n\tWARN_ON_ONCE(!rcu_nocb_flush_bypass(rdp, NULL, jiffies));\n\tif (rcu_segcblist_entrain(&rdp->cblist, &rdp->barrier_head)) {\n\t\tatomic_inc(&rcu_state.barrier_cpu_count);\n\t} else {\n\t\tdebug_rcu_head_unqueue(&rdp->barrier_head);\n\t\trcu_barrier_trace(TPS(\"IRQNQ\"), -1,\n\t\t\t\t  rcu_state.barrier_sequence);\n\t}\n\trcu_nocb_unlock(rdp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_irq_disable",
          "args": [],
          "line": 4070
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPS",
          "args": [
            "\"OfflineNoCBQ\""
          ],
          "line": 4068
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_is_offline",
          "args": [
            "cpu"
          ],
          "line": 4067
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_segcblist_n_cbs",
          "args": [
            "&rdp->cblist"
          ],
          "line": 4066
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_n_cbs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "47-54",
          "snippet": "static inline long rcu_segcblist_n_cbs(struct rcu_segcblist *rsclp)\n{\n#ifdef CONFIG_RCU_NOCB_CPU\n\treturn atomic_long_read(&rsclp->len);\n#else\n\treturn READ_ONCE(rsclp->len);\n#endif\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "long rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nlong rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline long rcu_segcblist_n_cbs(struct rcu_segcblist *rsclp)\n{\n#ifdef CONFIG_RCU_NOCB_CPU\n\treturn atomic_long_read(&rsclp->len);\n#else\n\treturn READ_ONCE(rsclp->len);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_call_function_single",
          "args": [
            "cpu",
            "rcu_barrier_func",
            "(void *)cpu",
            "1"
          ],
          "line": 4065
        },
        "resolved": true,
        "details": {
          "function_name": "smp_call_function_single",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/up.c",
          "lines": "12-25",
          "snippet": "int smp_call_function_single(int cpu, void (*func) (void *info), void *info,\n\t\t\t\tint wait)\n{\n\tunsigned long flags;\n\n\tif (cpu != 0)\n\t\treturn -ENXIO;\n\n\tlocal_irq_save(flags);\n\tfunc(info);\n\tlocal_irq_restore(flags);\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/hypervisor.h>",
            "#include <linux/smp.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hypervisor.h>\n#include <linux/smp.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n\nint smp_call_function_single(int cpu, void (*func) (void *info), void *info,\n\t\t\t\tint wait)\n{\n\tunsigned long flags;\n\n\tif (cpu != 0)\n\t\treturn -ENXIO;\n\n\tlocal_irq_save(flags);\n\tfunc(info);\n\tlocal_irq_restore(flags);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "TPS",
          "args": [
            "\"OnlineQ\""
          ],
          "line": 4063
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_online",
          "args": [
            "cpu"
          ],
          "line": 4062
        },
        "resolved": true,
        "details": {
          "function_name": "init_cpu_online",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "2616-2619",
          "snippet": "void init_cpu_online(const struct cpumask *src)\n{\n\tcpumask_copy(&__cpu_online_mask, src);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct cpumask __cpu_online_mask"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstruct cpumask __cpu_online_mask;\n\nvoid init_cpu_online(const struct cpumask *src)\n{\n\tcpumask_copy(&__cpu_online_mask, src);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_rdp_is_offloaded",
          "args": [
            "rdp"
          ],
          "line": 4060
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_rdp_is_offloaded",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "16-38",
          "snippet": "static bool rcu_rdp_is_offloaded(struct rcu_data *rdp)\n{\n\t/*\n\t * In order to read the offloaded state of an rdp in a safe\n\t * and stable way and prevent from its value to be changed\n\t * under us, we must either hold the barrier mutex, the cpu\n\t * hotplug lock (read or write) or the nocb lock. Local\n\t * non-preemptible reads are also safe. NOCB kthreads and\n\t * timers have their own means of synchronization against the\n\t * offloaded state updaters.\n\t */\n\tRCU_LOCKDEP_WARN(\n\t\t!(lockdep_is_held(&rcu_state.barrier_mutex) ||\n\t\t  (IS_ENABLED(CONFIG_HOTPLUG_CPU) && lockdep_is_cpus_held()) ||\n\t\t  rcu_lockdep_is_held_nocb(rdp) ||\n\t\t  (rdp == this_cpu_ptr(&rcu_data) &&\n\t\t   !(IS_ENABLED(CONFIG_PREEMPT_COUNT) && preemptible())) ||\n\t\t  rcu_current_is_nocb_kthread(rdp)),\n\t\t\"Unsafe read of RCU_NOCB offloaded state\"\n\t);\n\n\treturn rcu_segcblist_is_offloaded(&rdp->cblist);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nstatic bool rcu_rdp_is_offloaded(struct rcu_data *rdp)\n{\n\t/*\n\t * In order to read the offloaded state of an rdp in a safe\n\t * and stable way and prevent from its value to be changed\n\t * under us, we must either hold the barrier mutex, the cpu\n\t * hotplug lock (read or write) or the nocb lock. Local\n\t * non-preemptible reads are also safe. NOCB kthreads and\n\t * timers have their own means of synchronization against the\n\t * offloaded state updaters.\n\t */\n\tRCU_LOCKDEP_WARN(\n\t\t!(lockdep_is_held(&rcu_state.barrier_mutex) ||\n\t\t  (IS_ENABLED(CONFIG_HOTPLUG_CPU) && lockdep_is_cpus_held()) ||\n\t\t  rcu_lockdep_is_held_nocb(rdp) ||\n\t\t  (rdp == this_cpu_ptr(&rcu_data) &&\n\t\t   !(IS_ENABLED(CONFIG_PREEMPT_COUNT) && preemptible())) ||\n\t\t  rcu_current_is_nocb_kthread(rdp)),\n\t\t\"Unsafe read of RCU_NOCB offloaded state\"\n\t);\n\n\treturn rcu_segcblist_is_offloaded(&rdp->cblist);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_is_offline",
          "args": [
            "cpu"
          ],
          "line": 4059
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "&rcu_data",
            "cpu"
          ],
          "line": 4058
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpus_read_lock",
          "args": [],
          "line": 4050
        },
        "resolved": true,
        "details": {
          "function_name": "cpus_read_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "307-310",
          "snippet": "void cpus_read_lock(void)\n{\n\tpercpu_down_read(&cpu_hotplug_lock);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nvoid cpus_read_lock(void)\n{\n\tpercpu_down_read(&cpu_hotplug_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&rcu_state.barrier_cpu_count",
            "2"
          ],
          "line": 4049
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_completion",
          "args": [
            "&rcu_state.barrier_completion"
          ],
          "line": 4048
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPS",
          "args": [
            "\"Inc1\""
          ],
          "line": 4039
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_seq_start",
          "args": [
            "&rcu_state.barrier_sequence"
          ],
          "line": 4038
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_seq_start",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu.h",
          "lines": "55-60",
          "snippet": "static inline void rcu_seq_start(unsigned long *sp)\n{\n\tWRITE_ONCE(*sp, *sp + 1);\n\tsmp_mb(); /* Ensure update-side operation after counter increment. */\n\tWARN_ON_ONCE(rcu_seq_state(*sp) != 1);\n}",
          "includes": [
            "#include <linux/rcu_node_tree.h>",
            "#include <trace/events/rcu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_node_tree.h>\n#include <trace/events/rcu.h>\n\nstatic inline void rcu_seq_start(unsigned long *sp)\n{\n\tWRITE_ONCE(*sp, *sp + 1);\n\tsmp_mb(); /* Ensure update-side operation after counter increment. */\n\tWARN_ON_ONCE(rcu_seq_state(*sp) != 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_mb",
          "args": [],
          "line": 4032
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPS",
          "args": [
            "\"EarlyExit\""
          ],
          "line": 4030
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_seq_done",
          "args": [
            "&rcu_state.barrier_sequence",
            "s"
          ],
          "line": 4029
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_seq_done",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu.h",
          "lines": "115-118",
          "snippet": "static inline bool rcu_seq_done(unsigned long *sp, unsigned long s)\n{\n\treturn ULONG_CMP_GE(READ_ONCE(*sp), s);\n}",
          "includes": [
            "#include <linux/rcu_node_tree.h>",
            "#include <trace/events/rcu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_node_tree.h>\n#include <trace/events/rcu.h>\n\nstatic inline bool rcu_seq_done(unsigned long *sp, unsigned long s)\n{\n\treturn ULONG_CMP_GE(READ_ONCE(*sp), s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&rcu_state.barrier_mutex"
          ],
          "line": 4026
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "TPS",
          "args": [
            "\"Begin\""
          ],
          "line": 4023
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_seq_snap",
          "args": [
            "&rcu_state.barrier_sequence"
          ],
          "line": 4021
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_seq_snap",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu.h",
          "lines": "87-94",
          "snippet": "static inline unsigned long rcu_seq_snap(unsigned long *sp)\n{\n\tunsigned long s;\n\n\ts = (READ_ONCE(*sp) + 2 * RCU_SEQ_STATE_MASK + 1) & ~RCU_SEQ_STATE_MASK;\n\tsmp_mb(); /* Above access must not bleed into critical section. */\n\treturn s;\n}",
          "includes": [
            "#include <linux/rcu_node_tree.h>",
            "#include <trace/events/rcu.h>"
          ],
          "macros_used": [
            "#define RCU_SEQ_STATE_MASK\t((1 << RCU_SEQ_CTR_SHIFT) - 1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_node_tree.h>\n#include <trace/events/rcu.h>\n\n#define RCU_SEQ_STATE_MASK\t((1 << RCU_SEQ_CTR_SHIFT) - 1)\n\nstatic inline unsigned long rcu_seq_snap(unsigned long *sp)\n{\n\tunsigned long s;\n\n\ts = (READ_ONCE(*sp) + 2 * RCU_SEQ_STATE_MASK + 1) & ~RCU_SEQ_STATE_MASK;\n\tsmp_mb(); /* Above access must not bleed into critical section. */\n\treturn s;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};\nstatic struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void sync_sched_exp_online_cleanup(int cpu);\nstatic bool rcu_rdp_is_offloaded(struct rcu_data *rdp);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nvoid rcu_barrier(void)\n{\n\tuintptr_t cpu;\n\tstruct rcu_data *rdp;\n\tunsigned long s = rcu_seq_snap(&rcu_state.barrier_sequence);\n\n\trcu_barrier_trace(TPS(\"Begin\"), -1, s);\n\n\t/* Take mutex to serialize concurrent rcu_barrier() requests. */\n\tmutex_lock(&rcu_state.barrier_mutex);\n\n\t/* Did someone else do our work for us? */\n\tif (rcu_seq_done(&rcu_state.barrier_sequence, s)) {\n\t\trcu_barrier_trace(TPS(\"EarlyExit\"), -1,\n\t\t\t\t  rcu_state.barrier_sequence);\n\t\tsmp_mb(); /* caller's subsequent code after above check. */\n\t\tmutex_unlock(&rcu_state.barrier_mutex);\n\t\treturn;\n\t}\n\n\t/* Mark the start of the barrier operation. */\n\trcu_seq_start(&rcu_state.barrier_sequence);\n\trcu_barrier_trace(TPS(\"Inc1\"), -1, rcu_state.barrier_sequence);\n\n\t/*\n\t * Initialize the count to two rather than to zero in order\n\t * to avoid a too-soon return to zero in case of an immediate\n\t * invocation of the just-enqueued callback (or preemption of\n\t * this task).  Exclude CPU-hotplug operations to ensure that no\n\t * offline non-offloaded CPU has callbacks queued.\n\t */\n\tinit_completion(&rcu_state.barrier_completion);\n\tatomic_set(&rcu_state.barrier_cpu_count, 2);\n\tcpus_read_lock();\n\n\t/*\n\t * Force each CPU with callbacks to register a new callback.\n\t * When that callback is invoked, we will know that all of the\n\t * corresponding CPU's preceding callbacks have been invoked.\n\t */\n\tfor_each_possible_cpu(cpu) {\n\t\trdp = per_cpu_ptr(&rcu_data, cpu);\n\t\tif (cpu_is_offline(cpu) &&\n\t\t    !rcu_rdp_is_offloaded(rdp))\n\t\t\tcontinue;\n\t\tif (rcu_segcblist_n_cbs(&rdp->cblist) && cpu_online(cpu)) {\n\t\t\trcu_barrier_trace(TPS(\"OnlineQ\"), cpu,\n\t\t\t\t\t  rcu_state.barrier_sequence);\n\t\t\tsmp_call_function_single(cpu, rcu_barrier_func, (void *)cpu, 1);\n\t\t} else if (rcu_segcblist_n_cbs(&rdp->cblist) &&\n\t\t\t   cpu_is_offline(cpu)) {\n\t\t\trcu_barrier_trace(TPS(\"OfflineNoCBQ\"), cpu,\n\t\t\t\t\t  rcu_state.barrier_sequence);\n\t\t\tlocal_irq_disable();\n\t\t\trcu_barrier_func((void *)cpu);\n\t\t\tlocal_irq_enable();\n\t\t} else if (cpu_is_offline(cpu)) {\n\t\t\trcu_barrier_trace(TPS(\"OfflineNoCBNoQ\"), cpu,\n\t\t\t\t\t  rcu_state.barrier_sequence);\n\t\t} else {\n\t\t\trcu_barrier_trace(TPS(\"OnlineNQ\"), cpu,\n\t\t\t\t\t  rcu_state.barrier_sequence);\n\t\t}\n\t}\n\tcpus_read_unlock();\n\n\t/*\n\t * Now that we have an rcu_barrier_callback() callback on each\n\t * CPU, and thus each counted, remove the initial count.\n\t */\n\tif (atomic_sub_and_test(2, &rcu_state.barrier_cpu_count))\n\t\tcomplete(&rcu_state.barrier_completion);\n\n\t/* Wait for all rcu_barrier_callback() callbacks to be invoked. */\n\twait_for_completion(&rcu_state.barrier_completion);\n\n\t/* Mark the end of the barrier operation. */\n\trcu_barrier_trace(TPS(\"Inc2\"), -1, rcu_state.barrier_sequence);\n\trcu_seq_end(&rcu_state.barrier_sequence);\n\n\t/* Other rcu_barrier() invocations can now safely proceed. */\n\tmutex_unlock(&rcu_state.barrier_mutex);\n}"
  },
  {
    "function_name": "rcu_barrier_func",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
    "lines": "3989-4007",
    "snippet": "static void rcu_barrier_func(void *cpu_in)\n{\n\tuintptr_t cpu = (uintptr_t)cpu_in;\n\tstruct rcu_data *rdp = per_cpu_ptr(&rcu_data, cpu);\n\n\trcu_barrier_trace(TPS(\"IRQ\"), -1, rcu_state.barrier_sequence);\n\trdp->barrier_head.func = rcu_barrier_callback;\n\tdebug_rcu_head_queue(&rdp->barrier_head);\n\trcu_nocb_lock(rdp);\n\tWARN_ON_ONCE(!rcu_nocb_flush_bypass(rdp, NULL, jiffies));\n\tif (rcu_segcblist_entrain(&rdp->cblist, &rdp->barrier_head)) {\n\t\tatomic_inc(&rcu_state.barrier_cpu_count);\n\t} else {\n\t\tdebug_rcu_head_unqueue(&rdp->barrier_head);\n\t\trcu_barrier_trace(TPS(\"IRQNQ\"), -1,\n\t\t\t\t  rcu_state.barrier_sequence);\n\t}\n\trcu_nocb_unlock(rdp);\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_nocb.h\"",
      "#include \"tree_exp.h\"",
      "#include \"tree_stall.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <linux/kasan.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/panic_notifier.h>",
      "#include <linux/panic.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};",
      "static struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};",
      "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
      "static void sync_sched_exp_online_cleanup(int cpu);",
      "static bool rcu_rdp_is_offloaded(struct rcu_data *rdp);",
      "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_nocb_unlock",
          "args": [
            "rdp"
          ],
          "line": 4006
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_nocb_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_nocb.h",
          "lines": "1474-1476",
          "snippet": "static void rcu_nocb_unlock(struct rcu_data *rdp)\n{\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static void rcu_nocb_unlock(struct rcu_data *rdp)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_barrier_trace",
          "args": [
            "TPS(\"IRQNQ\")",
            "-1",
            "rcu_state.barrier_sequence"
          ],
          "line": 4003
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_barrier_trace",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "3958-3962",
          "snippet": "static void rcu_barrier_trace(const char *s, int cpu, unsigned long done)\n{\n\ttrace_rcu_barrier(rcu_state.name, s, cpu,\n\t\t\t  atomic_read(&rcu_state.barrier_cpu_count), done);\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};",
            "static void sync_sched_exp_online_cleanup(int cpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\nstatic void sync_sched_exp_online_cleanup(int cpu);\n\nstatic void rcu_barrier_trace(const char *s, int cpu, unsigned long done)\n{\n\ttrace_rcu_barrier(rcu_state.name, s, cpu,\n\t\t\t  atomic_read(&rcu_state.barrier_cpu_count), done);\n}"
        }
      },
      {
        "call_info": {
          "callee": "TPS",
          "args": [
            "\"IRQNQ\""
          ],
          "line": 4003
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_rcu_head_unqueue",
          "args": [
            "&rdp->barrier_head"
          ],
          "line": 4002
        },
        "resolved": true,
        "details": {
          "function_name": "debug_rcu_head_unqueue",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu.h",
          "lines": "196-198",
          "snippet": "static inline void debug_rcu_head_unqueue(struct rcu_head *head)\n{\n}",
          "includes": [
            "#include <linux/rcu_node_tree.h>",
            "#include <trace/events/rcu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_node_tree.h>\n#include <trace/events/rcu.h>\n\nstatic inline void debug_rcu_head_unqueue(struct rcu_head *head)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&rcu_state.barrier_cpu_count"
          ],
          "line": 4000
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_segcblist_entrain",
          "args": [
            "&rdp->cblist",
            "&rdp->barrier_head"
          ],
          "line": 3999
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_entrain",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.c",
          "lines": "360-378",
          "snippet": "bool rcu_segcblist_entrain(struct rcu_segcblist *rsclp,\n\t\t\t   struct rcu_head *rhp)\n{\n\tint i;\n\n\tif (rcu_segcblist_n_cbs(rsclp) == 0)\n\t\treturn false;\n\trcu_segcblist_inc_len(rsclp);\n\tsmp_mb(); /* Ensure counts are updated before callback is entrained. */\n\trhp->next = NULL;\n\tfor (i = RCU_NEXT_TAIL; i > RCU_DONE_TAIL; i--)\n\t\tif (rsclp->tails[i] != rsclp->tails[i - 1])\n\t\t\tbreak;\n\trcu_segcblist_inc_seglen(rsclp, i);\n\tWRITE_ONCE(*rsclp->tails[i], rhp);\n\tfor (; i <= RCU_NEXT_TAIL; i++)\n\t\tWRITE_ONCE(rsclp->tails[i], &rhp->next);\n\treturn true;\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/cpu.h>\n\nbool rcu_segcblist_entrain(struct rcu_segcblist *rsclp,\n\t\t\t   struct rcu_head *rhp)\n{\n\tint i;\n\n\tif (rcu_segcblist_n_cbs(rsclp) == 0)\n\t\treturn false;\n\trcu_segcblist_inc_len(rsclp);\n\tsmp_mb(); /* Ensure counts are updated before callback is entrained. */\n\trhp->next = NULL;\n\tfor (i = RCU_NEXT_TAIL; i > RCU_DONE_TAIL; i--)\n\t\tif (rsclp->tails[i] != rsclp->tails[i - 1])\n\t\t\tbreak;\n\trcu_segcblist_inc_seglen(rsclp, i);\n\tWRITE_ONCE(*rsclp->tails[i], rhp);\n\tfor (; i <= RCU_NEXT_TAIL; i++)\n\t\tWRITE_ONCE(rsclp->tails[i], &rhp->next);\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!rcu_nocb_flush_bypass(rdp, NULL, jiffies)"
          ],
          "line": 3998
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_nocb_flush_bypass",
          "args": [
            "rdp",
            "NULL",
            "jiffies"
          ],
          "line": 3998
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_nocb_flush_bypass",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_nocb.h",
          "lines": "1504-1508",
          "snippet": "static bool rcu_nocb_flush_bypass(struct rcu_data *rdp, struct rcu_head *rhp,\n\t\t\t\t  unsigned long j)\n{\n\treturn true;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static bool rcu_nocb_flush_bypass(struct rcu_data *rdp, struct rcu_head *rhp,\n\t\t\t\t  unsigned long j)\n{\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_nocb_lock",
          "args": [
            "rdp"
          ],
          "line": 3997
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_nocb_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_nocb.h",
          "lines": "1469-1471",
          "snippet": "static void rcu_nocb_lock(struct rcu_data *rdp)\n{\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static void rcu_nocb_lock(struct rcu_data *rdp)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug_rcu_head_queue",
          "args": [
            "&rdp->barrier_head"
          ],
          "line": 3996
        },
        "resolved": true,
        "details": {
          "function_name": "debug_rcu_head_queue",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu.h",
          "lines": "191-194",
          "snippet": "static inline int debug_rcu_head_queue(struct rcu_head *head)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/rcu_node_tree.h>",
            "#include <trace/events/rcu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_node_tree.h>\n#include <trace/events/rcu.h>\n\nstatic inline int debug_rcu_head_queue(struct rcu_head *head)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "TPS",
          "args": [
            "\"IRQ\""
          ],
          "line": 3994
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "&rcu_data",
            "cpu"
          ],
          "line": 3992
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};\nstatic struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void sync_sched_exp_online_cleanup(int cpu);\nstatic bool rcu_rdp_is_offloaded(struct rcu_data *rdp);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nstatic void rcu_barrier_func(void *cpu_in)\n{\n\tuintptr_t cpu = (uintptr_t)cpu_in;\n\tstruct rcu_data *rdp = per_cpu_ptr(&rcu_data, cpu);\n\n\trcu_barrier_trace(TPS(\"IRQ\"), -1, rcu_state.barrier_sequence);\n\trdp->barrier_head.func = rcu_barrier_callback;\n\tdebug_rcu_head_queue(&rdp->barrier_head);\n\trcu_nocb_lock(rdp);\n\tWARN_ON_ONCE(!rcu_nocb_flush_bypass(rdp, NULL, jiffies));\n\tif (rcu_segcblist_entrain(&rdp->cblist, &rdp->barrier_head)) {\n\t\tatomic_inc(&rcu_state.barrier_cpu_count);\n\t} else {\n\t\tdebug_rcu_head_unqueue(&rdp->barrier_head);\n\t\trcu_barrier_trace(TPS(\"IRQNQ\"), -1,\n\t\t\t\t  rcu_state.barrier_sequence);\n\t}\n\trcu_nocb_unlock(rdp);\n}"
  },
  {
    "function_name": "rcu_barrier_callback",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
    "lines": "3974-3984",
    "snippet": "static void rcu_barrier_callback(struct rcu_head *rhp)\n{\n\tunsigned long __maybe_unused s = rcu_state.barrier_sequence;\n\n\tif (atomic_dec_and_test(&rcu_state.barrier_cpu_count)) {\n\t\trcu_barrier_trace(TPS(\"LastCB\"), -1, s);\n\t\tcomplete(&rcu_state.barrier_completion);\n\t} else {\n\t\trcu_barrier_trace(TPS(\"CB\"), -1, s);\n\t}\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_nocb.h\"",
      "#include \"tree_exp.h\"",
      "#include \"tree_stall.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <linux/kasan.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/panic_notifier.h>",
      "#include <linux/panic.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_barrier_trace",
          "args": [
            "TPS(\"CB\")",
            "-1",
            "s"
          ],
          "line": 3982
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_barrier_trace",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "3958-3962",
          "snippet": "static void rcu_barrier_trace(const char *s, int cpu, unsigned long done)\n{\n\ttrace_rcu_barrier(rcu_state.name, s, cpu,\n\t\t\t  atomic_read(&rcu_state.barrier_cpu_count), done);\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};",
            "static void sync_sched_exp_online_cleanup(int cpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\nstatic void sync_sched_exp_online_cleanup(int cpu);\n\nstatic void rcu_barrier_trace(const char *s, int cpu, unsigned long done)\n{\n\ttrace_rcu_barrier(rcu_state.name, s, cpu,\n\t\t\t  atomic_read(&rcu_state.barrier_cpu_count), done);\n}"
        }
      },
      {
        "call_info": {
          "callee": "TPS",
          "args": [
            "\"CB\""
          ],
          "line": 3982
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "complete",
          "args": [
            "&rcu_state.barrier_completion"
          ],
          "line": 3980
        },
        "resolved": true,
        "details": {
          "function_name": "srcu_batches_completed",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/srcutree.c",
          "lines": "1162-1165",
          "snippet": "unsigned long srcu_batches_completed(struct srcu_struct *ssp)\n{\n\treturn READ_ONCE(ssp->srcu_idx);\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include \"rcu.h\"",
            "#include <linux/srcu.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nunsigned long srcu_batches_completed(struct srcu_struct *ssp)\n{\n\treturn READ_ONCE(ssp->srcu_idx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "TPS",
          "args": [
            "\"LastCB\""
          ],
          "line": 3979
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec_and_test",
          "args": [
            "&rcu_state.barrier_cpu_count"
          ],
          "line": 3978
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\n\nstatic void rcu_barrier_callback(struct rcu_head *rhp)\n{\n\tunsigned long __maybe_unused s = rcu_state.barrier_sequence;\n\n\tif (atomic_dec_and_test(&rcu_state.barrier_cpu_count)) {\n\t\trcu_barrier_trace(TPS(\"LastCB\"), -1, s);\n\t\tcomplete(&rcu_state.barrier_completion);\n\t} else {\n\t\trcu_barrier_trace(TPS(\"CB\"), -1, s);\n\t}\n}"
  },
  {
    "function_name": "rcu_barrier_trace",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
    "lines": "3958-3962",
    "snippet": "static void rcu_barrier_trace(const char *s, int cpu, unsigned long done)\n{\n\ttrace_rcu_barrier(rcu_state.name, s, cpu,\n\t\t\t  atomic_read(&rcu_state.barrier_cpu_count), done);\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_nocb.h\"",
      "#include \"tree_exp.h\"",
      "#include \"tree_stall.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <linux/kasan.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/panic_notifier.h>",
      "#include <linux/panic.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};",
      "static void sync_sched_exp_online_cleanup(int cpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_rcu_barrier",
          "args": [
            "rcu_state.name",
            "s",
            "cpu",
            "atomic_read(&rcu_state.barrier_cpu_count)",
            "done"
          ],
          "line": 3960
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&rcu_state.barrier_cpu_count"
          ],
          "line": 3961
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\nstatic void sync_sched_exp_online_cleanup(int cpu);\n\nstatic void rcu_barrier_trace(const char *s, int cpu, unsigned long done)\n{\n\ttrace_rcu_barrier(rcu_state.name, s, cpu,\n\t\t\t  atomic_read(&rcu_state.barrier_cpu_count), done);\n}"
  },
  {
    "function_name": "rcu_pending",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
    "lines": "3910-3952",
    "snippet": "static int rcu_pending(int user)\n{\n\tbool gp_in_progress;\n\tstruct rcu_data *rdp = this_cpu_ptr(&rcu_data);\n\tstruct rcu_node *rnp = rdp->mynode;\n\n\tlockdep_assert_irqs_disabled();\n\n\t/* Check for CPU stalls, if enabled. */\n\tcheck_cpu_stall(rdp);\n\n\t/* Does this CPU need a deferred NOCB wakeup? */\n\tif (rcu_nocb_need_deferred_wakeup(rdp, RCU_NOCB_WAKE))\n\t\treturn 1;\n\n\t/* Is this a nohz_full CPU in userspace or idle?  (Ignore RCU if so.) */\n\tif ((user || rcu_is_cpu_rrupt_from_idle()) && rcu_nohz_full_cpu())\n\t\treturn 0;\n\n\t/* Is the RCU core waiting for a quiescent state from this CPU? */\n\tgp_in_progress = rcu_gp_in_progress();\n\tif (rdp->core_needs_qs && !rdp->cpu_no_qs.b.norm && gp_in_progress)\n\t\treturn 1;\n\n\t/* Does this CPU have callbacks ready to invoke? */\n\tif (!rcu_rdp_is_offloaded(rdp) &&\n\t    rcu_segcblist_ready_cbs(&rdp->cblist))\n\t\treturn 1;\n\n\t/* Has RCU gone idle with this CPU needing another grace period? */\n\tif (!gp_in_progress && rcu_segcblist_is_enabled(&rdp->cblist) &&\n\t    !rcu_rdp_is_offloaded(rdp) &&\n\t    !rcu_segcblist_restempty(&rdp->cblist, RCU_NEXT_READY_TAIL))\n\t\treturn 1;\n\n\t/* Have RCU grace period completed or started?  */\n\tif (rcu_seq_current(&rnp->gp_seq) != rdp->gp_seq ||\n\t    unlikely(READ_ONCE(rdp->gpwrap))) /* outside lock */\n\t\treturn 1;\n\n\t/* nothing to do */\n\treturn 0;\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_nocb.h\"",
      "#include \"tree_exp.h\"",
      "#include \"tree_stall.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <linux/kasan.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/panic_notifier.h>",
      "#include <linux/panic.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};",
      "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
      "static void check_cb_ovld_locked(struct rcu_data *rdp, struct rcu_node *rnp);",
      "static bool rcu_rdp_is_offloaded(struct rcu_data *rdp);",
      "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));",
      "static int rcu_pending(int user);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "READ_ONCE(rdp->gpwrap)"
          ],
          "line": 3947
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rdp->gpwrap"
          ],
          "line": 3947
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_seq_current",
          "args": [
            "&rnp->gp_seq"
          ],
          "line": 3946
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_seq_current",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu.h",
          "lines": "97-100",
          "snippet": "static inline unsigned long rcu_seq_current(unsigned long *sp)\n{\n\treturn READ_ONCE(*sp);\n}",
          "includes": [
            "#include <linux/rcu_node_tree.h>",
            "#include <trace/events/rcu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_node_tree.h>\n#include <trace/events/rcu.h>\n\nstatic inline unsigned long rcu_seq_current(unsigned long *sp)\n{\n\treturn READ_ONCE(*sp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_segcblist_restempty",
          "args": [
            "&rdp->cblist",
            "RCU_NEXT_READY_TAIL"
          ],
          "line": 3942
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_restempty",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "110-113",
          "snippet": "static inline bool rcu_segcblist_restempty(struct rcu_segcblist *rsclp, int seg)\n{\n\treturn !READ_ONCE(*READ_ONCE(rsclp->tails[seg]));\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "long rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nlong rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_restempty(struct rcu_segcblist *rsclp, int seg)\n{\n\treturn !READ_ONCE(*READ_ONCE(rsclp->tails[seg]));\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_rdp_is_offloaded",
          "args": [
            "rdp"
          ],
          "line": 3941
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_rdp_is_offloaded",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "16-38",
          "snippet": "static bool rcu_rdp_is_offloaded(struct rcu_data *rdp)\n{\n\t/*\n\t * In order to read the offloaded state of an rdp in a safe\n\t * and stable way and prevent from its value to be changed\n\t * under us, we must either hold the barrier mutex, the cpu\n\t * hotplug lock (read or write) or the nocb lock. Local\n\t * non-preemptible reads are also safe. NOCB kthreads and\n\t * timers have their own means of synchronization against the\n\t * offloaded state updaters.\n\t */\n\tRCU_LOCKDEP_WARN(\n\t\t!(lockdep_is_held(&rcu_state.barrier_mutex) ||\n\t\t  (IS_ENABLED(CONFIG_HOTPLUG_CPU) && lockdep_is_cpus_held()) ||\n\t\t  rcu_lockdep_is_held_nocb(rdp) ||\n\t\t  (rdp == this_cpu_ptr(&rcu_data) &&\n\t\t   !(IS_ENABLED(CONFIG_PREEMPT_COUNT) && preemptible())) ||\n\t\t  rcu_current_is_nocb_kthread(rdp)),\n\t\t\"Unsafe read of RCU_NOCB offloaded state\"\n\t);\n\n\treturn rcu_segcblist_is_offloaded(&rdp->cblist);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nstatic bool rcu_rdp_is_offloaded(struct rcu_data *rdp)\n{\n\t/*\n\t * In order to read the offloaded state of an rdp in a safe\n\t * and stable way and prevent from its value to be changed\n\t * under us, we must either hold the barrier mutex, the cpu\n\t * hotplug lock (read or write) or the nocb lock. Local\n\t * non-preemptible reads are also safe. NOCB kthreads and\n\t * timers have their own means of synchronization against the\n\t * offloaded state updaters.\n\t */\n\tRCU_LOCKDEP_WARN(\n\t\t!(lockdep_is_held(&rcu_state.barrier_mutex) ||\n\t\t  (IS_ENABLED(CONFIG_HOTPLUG_CPU) && lockdep_is_cpus_held()) ||\n\t\t  rcu_lockdep_is_held_nocb(rdp) ||\n\t\t  (rdp == this_cpu_ptr(&rcu_data) &&\n\t\t   !(IS_ENABLED(CONFIG_PREEMPT_COUNT) && preemptible())) ||\n\t\t  rcu_current_is_nocb_kthread(rdp)),\n\t\t\"Unsafe read of RCU_NOCB offloaded state\"\n\t);\n\n\treturn rcu_segcblist_is_offloaded(&rdp->cblist);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_segcblist_is_enabled",
          "args": [
            "&rdp->cblist"
          ],
          "line": 3940
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_is_enabled",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "78-81",
          "snippet": "static inline bool rcu_segcblist_is_enabled(struct rcu_segcblist *rsclp)\n{\n\treturn rcu_segcblist_test_flags(rsclp, SEGCBLIST_ENABLED);\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "long rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nlong rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_is_enabled(struct rcu_segcblist *rsclp)\n{\n\treturn rcu_segcblist_test_flags(rsclp, SEGCBLIST_ENABLED);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_segcblist_ready_cbs",
          "args": [
            "&rdp->cblist"
          ],
          "line": 3936
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_ready_cbs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.c",
          "lines": "278-282",
          "snippet": "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp)\n{\n\treturn rcu_segcblist_is_enabled(rsclp) &&\n\t       &rsclp->head != READ_ONCE(rsclp->tails[RCU_DONE_TAIL]);\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/cpu.h>\n\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp)\n{\n\treturn rcu_segcblist_is_enabled(rsclp) &&\n\t       &rsclp->head != READ_ONCE(rsclp->tails[RCU_DONE_TAIL]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_gp_in_progress",
          "args": [],
          "line": 3930
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_gp_in_progress",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "229-232",
          "snippet": "static int rcu_gp_in_progress(void)\n{\n\treturn rcu_seq_state(rcu_seq_current(&rcu_state.gp_seq));\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\n\nstatic int rcu_gp_in_progress(void)\n{\n\treturn rcu_seq_state(rcu_seq_current(&rcu_state.gp_seq));\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_nohz_full_cpu",
          "args": [],
          "line": 3926
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_nohz_full_cpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "1276-1285",
          "snippet": "static bool rcu_nohz_full_cpu(void)\n{\n#ifdef CONFIG_NO_HZ_FULL\n\tif (tick_nohz_full_cpu(smp_processor_id()) &&\n\t    (!rcu_gp_in_progress() ||\n\t     time_before(jiffies, READ_ONCE(rcu_state.gp_start) + HZ)))\n\t\treturn true;\n#endif /* #ifdef CONFIG_NO_HZ_FULL */\n\treturn false;\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nstatic bool rcu_nohz_full_cpu(void)\n{\n#ifdef CONFIG_NO_HZ_FULL\n\tif (tick_nohz_full_cpu(smp_processor_id()) &&\n\t    (!rcu_gp_in_progress() ||\n\t     time_before(jiffies, READ_ONCE(rcu_state.gp_start) + HZ)))\n\t\treturn true;\n#endif /* #ifdef CONFIG_NO_HZ_FULL */\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_is_cpu_rrupt_from_idle",
          "args": [],
          "line": 3926
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_is_cpu_rrupt_from_idle",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "422-451",
          "snippet": "static int rcu_is_cpu_rrupt_from_idle(void)\n{\n\tlong nesting;\n\n\t/*\n\t * Usually called from the tick; but also used from smp_function_call()\n\t * for expedited grace periods. This latter can result in running from\n\t * the idle task, instead of an actual IPI.\n\t */\n\tlockdep_assert_irqs_disabled();\n\n\t/* Check for counter underflows */\n\tRCU_LOCKDEP_WARN(__this_cpu_read(rcu_data.dynticks_nesting) < 0,\n\t\t\t \"RCU dynticks_nesting counter underflow!\");\n\tRCU_LOCKDEP_WARN(__this_cpu_read(rcu_data.dynticks_nmi_nesting) <= 0,\n\t\t\t \"RCU dynticks_nmi_nesting counter underflow/zero!\");\n\n\t/* Are we at first interrupt nesting level? */\n\tnesting = __this_cpu_read(rcu_data.dynticks_nmi_nesting);\n\tif (nesting > 1)\n\t\treturn false;\n\n\t/*\n\t * If we're not in an interrupt, we must be in the idle task!\n\t */\n\tWARN_ON_ONCE(!nesting && !is_idle_task(current));\n\n\t/* Does CPU appear to be idle from an RCU standpoint? */\n\treturn __this_cpu_read(rcu_data.dynticks_nesting) == 0;\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};\n\nstatic int rcu_is_cpu_rrupt_from_idle(void)\n{\n\tlong nesting;\n\n\t/*\n\t * Usually called from the tick; but also used from smp_function_call()\n\t * for expedited grace periods. This latter can result in running from\n\t * the idle task, instead of an actual IPI.\n\t */\n\tlockdep_assert_irqs_disabled();\n\n\t/* Check for counter underflows */\n\tRCU_LOCKDEP_WARN(__this_cpu_read(rcu_data.dynticks_nesting) < 0,\n\t\t\t \"RCU dynticks_nesting counter underflow!\");\n\tRCU_LOCKDEP_WARN(__this_cpu_read(rcu_data.dynticks_nmi_nesting) <= 0,\n\t\t\t \"RCU dynticks_nmi_nesting counter underflow/zero!\");\n\n\t/* Are we at first interrupt nesting level? */\n\tnesting = __this_cpu_read(rcu_data.dynticks_nmi_nesting);\n\tif (nesting > 1)\n\t\treturn false;\n\n\t/*\n\t * If we're not in an interrupt, we must be in the idle task!\n\t */\n\tWARN_ON_ONCE(!nesting && !is_idle_task(current));\n\n\t/* Does CPU appear to be idle from an RCU standpoint? */\n\treturn __this_cpu_read(rcu_data.dynticks_nesting) == 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_nocb_need_deferred_wakeup",
          "args": [
            "rdp",
            "RCU_NOCB_WAKE"
          ],
          "line": 3922
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_nocb_need_deferred_wakeup",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_nocb.h",
          "lines": "1526-1529",
          "snippet": "static int rcu_nocb_need_deferred_wakeup(struct rcu_data *rdp, int level)\n{\n\treturn false;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static int rcu_nocb_need_deferred_wakeup(struct rcu_data *rdp, int level)\n{\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_cpu_stall",
          "args": [
            "rdp"
          ],
          "line": 3919
        },
        "resolved": true,
        "details": {
          "function_name": "check_cpu_stall",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_stall.h",
          "lines": "626-715",
          "snippet": "static void check_cpu_stall(struct rcu_data *rdp)\n{\n\tbool didstall = false;\n\tunsigned long gs1;\n\tunsigned long gs2;\n\tunsigned long gps;\n\tunsigned long j;\n\tunsigned long jn;\n\tunsigned long js;\n\tstruct rcu_node *rnp;\n\n\tlockdep_assert_irqs_disabled();\n\tif ((rcu_stall_is_suppressed() && !READ_ONCE(rcu_kick_kthreads)) ||\n\t    !rcu_gp_in_progress())\n\t\treturn;\n\trcu_stall_kick_kthreads();\n\tj = jiffies;\n\n\t/*\n\t * Lots of memory barriers to reject false positives.\n\t *\n\t * The idea is to pick up rcu_state.gp_seq, then\n\t * rcu_state.jiffies_stall, then rcu_state.gp_start, and finally\n\t * another copy of rcu_state.gp_seq.  These values are updated in\n\t * the opposite order with memory barriers (or equivalent) during\n\t * grace-period initialization and cleanup.  Now, a false positive\n\t * can occur if we get an new value of rcu_state.gp_start and a old\n\t * value of rcu_state.jiffies_stall.  But given the memory barriers,\n\t * the only way that this can happen is if one grace period ends\n\t * and another starts between these two fetches.  This is detected\n\t * by comparing the second fetch of rcu_state.gp_seq with the\n\t * previous fetch from rcu_state.gp_seq.\n\t *\n\t * Given this check, comparisons of jiffies, rcu_state.jiffies_stall,\n\t * and rcu_state.gp_start suffice to forestall false positives.\n\t */\n\tgs1 = READ_ONCE(rcu_state.gp_seq);\n\tsmp_rmb(); /* Pick up ->gp_seq first... */\n\tjs = READ_ONCE(rcu_state.jiffies_stall);\n\tsmp_rmb(); /* ...then ->jiffies_stall before the rest... */\n\tgps = READ_ONCE(rcu_state.gp_start);\n\tsmp_rmb(); /* ...and finally ->gp_start before ->gp_seq again. */\n\tgs2 = READ_ONCE(rcu_state.gp_seq);\n\tif (gs1 != gs2 ||\n\t    ULONG_CMP_LT(j, js) ||\n\t    ULONG_CMP_GE(gps, js))\n\t\treturn; /* No stall or GP completed since entering function. */\n\trnp = rdp->mynode;\n\tjn = jiffies + ULONG_MAX / 2;\n\tif (rcu_gp_in_progress() &&\n\t    (READ_ONCE(rnp->qsmask) & rdp->grpmask) &&\n\t    cmpxchg(&rcu_state.jiffies_stall, js, jn) == js) {\n\n\t\t/*\n\t\t * If a virtual machine is stopped by the host it can look to\n\t\t * the watchdog like an RCU stall. Check to see if the host\n\t\t * stopped the vm.\n\t\t */\n\t\tif (kvm_check_and_clear_guest_paused())\n\t\t\treturn;\n\n\t\t/* We haven't checked in, so go dump stack. */\n\t\tprint_cpu_stall(gps);\n\t\tif (READ_ONCE(rcu_cpu_stall_ftrace_dump))\n\t\t\trcu_ftrace_dump(DUMP_ALL);\n\t\tdidstall = true;\n\n\t} else if (rcu_gp_in_progress() &&\n\t\t   ULONG_CMP_GE(j, js + RCU_STALL_RAT_DELAY) &&\n\t\t   cmpxchg(&rcu_state.jiffies_stall, js, jn) == js) {\n\n\t\t/*\n\t\t * If a virtual machine is stopped by the host it can look to\n\t\t * the watchdog like an RCU stall. Check to see if the host\n\t\t * stopped the vm.\n\t\t */\n\t\tif (kvm_check_and_clear_guest_paused())\n\t\t\treturn;\n\n\t\t/* They had a few time units to dump stack, so complain. */\n\t\tprint_other_cpu_stall(gs2, gps);\n\t\tif (READ_ONCE(rcu_cpu_stall_ftrace_dump))\n\t\t\trcu_ftrace_dump(DUMP_ALL);\n\t\tdidstall = true;\n\t}\n\tif (didstall && READ_ONCE(rcu_state.jiffies_stall) == jn) {\n\t\tjn = jiffies + 3 * rcu_jiffies_till_stall_check() + 3;\n\t\tWRITE_ONCE(rcu_state.jiffies_stall, jn);\n\t}\n}",
          "includes": [
            "#include <linux/kvm_para.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_para.h>\n\nstatic void check_cpu_stall(struct rcu_data *rdp)\n{\n\tbool didstall = false;\n\tunsigned long gs1;\n\tunsigned long gs2;\n\tunsigned long gps;\n\tunsigned long j;\n\tunsigned long jn;\n\tunsigned long js;\n\tstruct rcu_node *rnp;\n\n\tlockdep_assert_irqs_disabled();\n\tif ((rcu_stall_is_suppressed() && !READ_ONCE(rcu_kick_kthreads)) ||\n\t    !rcu_gp_in_progress())\n\t\treturn;\n\trcu_stall_kick_kthreads();\n\tj = jiffies;\n\n\t/*\n\t * Lots of memory barriers to reject false positives.\n\t *\n\t * The idea is to pick up rcu_state.gp_seq, then\n\t * rcu_state.jiffies_stall, then rcu_state.gp_start, and finally\n\t * another copy of rcu_state.gp_seq.  These values are updated in\n\t * the opposite order with memory barriers (or equivalent) during\n\t * grace-period initialization and cleanup.  Now, a false positive\n\t * can occur if we get an new value of rcu_state.gp_start and a old\n\t * value of rcu_state.jiffies_stall.  But given the memory barriers,\n\t * the only way that this can happen is if one grace period ends\n\t * and another starts between these two fetches.  This is detected\n\t * by comparing the second fetch of rcu_state.gp_seq with the\n\t * previous fetch from rcu_state.gp_seq.\n\t *\n\t * Given this check, comparisons of jiffies, rcu_state.jiffies_stall,\n\t * and rcu_state.gp_start suffice to forestall false positives.\n\t */\n\tgs1 = READ_ONCE(rcu_state.gp_seq);\n\tsmp_rmb(); /* Pick up ->gp_seq first... */\n\tjs = READ_ONCE(rcu_state.jiffies_stall);\n\tsmp_rmb(); /* ...then ->jiffies_stall before the rest... */\n\tgps = READ_ONCE(rcu_state.gp_start);\n\tsmp_rmb(); /* ...and finally ->gp_start before ->gp_seq again. */\n\tgs2 = READ_ONCE(rcu_state.gp_seq);\n\tif (gs1 != gs2 ||\n\t    ULONG_CMP_LT(j, js) ||\n\t    ULONG_CMP_GE(gps, js))\n\t\treturn; /* No stall or GP completed since entering function. */\n\trnp = rdp->mynode;\n\tjn = jiffies + ULONG_MAX / 2;\n\tif (rcu_gp_in_progress() &&\n\t    (READ_ONCE(rnp->qsmask) & rdp->grpmask) &&\n\t    cmpxchg(&rcu_state.jiffies_stall, js, jn) == js) {\n\n\t\t/*\n\t\t * If a virtual machine is stopped by the host it can look to\n\t\t * the watchdog like an RCU stall. Check to see if the host\n\t\t * stopped the vm.\n\t\t */\n\t\tif (kvm_check_and_clear_guest_paused())\n\t\t\treturn;\n\n\t\t/* We haven't checked in, so go dump stack. */\n\t\tprint_cpu_stall(gps);\n\t\tif (READ_ONCE(rcu_cpu_stall_ftrace_dump))\n\t\t\trcu_ftrace_dump(DUMP_ALL);\n\t\tdidstall = true;\n\n\t} else if (rcu_gp_in_progress() &&\n\t\t   ULONG_CMP_GE(j, js + RCU_STALL_RAT_DELAY) &&\n\t\t   cmpxchg(&rcu_state.jiffies_stall, js, jn) == js) {\n\n\t\t/*\n\t\t * If a virtual machine is stopped by the host it can look to\n\t\t * the watchdog like an RCU stall. Check to see if the host\n\t\t * stopped the vm.\n\t\t */\n\t\tif (kvm_check_and_clear_guest_paused())\n\t\t\treturn;\n\n\t\t/* They had a few time units to dump stack, so complain. */\n\t\tprint_other_cpu_stall(gs2, gps);\n\t\tif (READ_ONCE(rcu_cpu_stall_ftrace_dump))\n\t\t\trcu_ftrace_dump(DUMP_ALL);\n\t\tdidstall = true;\n\t}\n\tif (didstall && READ_ONCE(rcu_state.jiffies_stall) == jn) {\n\t\tjn = jiffies + 3 * rcu_jiffies_till_stall_check() + 3;\n\t\tWRITE_ONCE(rcu_state.jiffies_stall, jn);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_assert_irqs_disabled",
          "args": [],
          "line": 3916
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&rcu_data"
          ],
          "line": 3913
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void check_cb_ovld_locked(struct rcu_data *rdp, struct rcu_node *rnp);\nstatic bool rcu_rdp_is_offloaded(struct rcu_data *rdp);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\nstatic int rcu_pending(int user);\n\nstatic int rcu_pending(int user)\n{\n\tbool gp_in_progress;\n\tstruct rcu_data *rdp = this_cpu_ptr(&rcu_data);\n\tstruct rcu_node *rnp = rdp->mynode;\n\n\tlockdep_assert_irqs_disabled();\n\n\t/* Check for CPU stalls, if enabled. */\n\tcheck_cpu_stall(rdp);\n\n\t/* Does this CPU need a deferred NOCB wakeup? */\n\tif (rcu_nocb_need_deferred_wakeup(rdp, RCU_NOCB_WAKE))\n\t\treturn 1;\n\n\t/* Is this a nohz_full CPU in userspace or idle?  (Ignore RCU if so.) */\n\tif ((user || rcu_is_cpu_rrupt_from_idle()) && rcu_nohz_full_cpu())\n\t\treturn 0;\n\n\t/* Is the RCU core waiting for a quiescent state from this CPU? */\n\tgp_in_progress = rcu_gp_in_progress();\n\tif (rdp->core_needs_qs && !rdp->cpu_no_qs.b.norm && gp_in_progress)\n\t\treturn 1;\n\n\t/* Does this CPU have callbacks ready to invoke? */\n\tif (!rcu_rdp_is_offloaded(rdp) &&\n\t    rcu_segcblist_ready_cbs(&rdp->cblist))\n\t\treturn 1;\n\n\t/* Has RCU gone idle with this CPU needing another grace period? */\n\tif (!gp_in_progress && rcu_segcblist_is_enabled(&rdp->cblist) &&\n\t    !rcu_rdp_is_offloaded(rdp) &&\n\t    !rcu_segcblist_restempty(&rdp->cblist, RCU_NEXT_READY_TAIL))\n\t\treturn 1;\n\n\t/* Have RCU grace period completed or started?  */\n\tif (rcu_seq_current(&rnp->gp_seq) != rdp->gp_seq ||\n\t    unlikely(READ_ONCE(rdp->gpwrap))) /* outside lock */\n\t\treturn 1;\n\n\t/* nothing to do */\n\treturn 0;\n}"
  },
  {
    "function_name": "cond_synchronize_rcu",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
    "lines": "3896-3900",
    "snippet": "void cond_synchronize_rcu(unsigned long oldstate)\n{\n\tif (!poll_state_synchronize_rcu(oldstate))\n\t\tsynchronize_rcu();\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_nocb.h\"",
      "#include \"tree_exp.h\"",
      "#include \"tree_stall.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <linux/kasan.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/panic_notifier.h>",
      "#include <linux/panic.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "synchronize_rcu",
          "args": [],
          "line": 3899
        },
        "resolved": true,
        "details": {
          "function_name": "start_poll_synchronize_rcu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "3821-3839",
          "snippet": "unsigned long start_poll_synchronize_rcu(void)\n{\n\tunsigned long flags;\n\tunsigned long gp_seq = get_state_synchronize_rcu();\n\tbool needwake;\n\tstruct rcu_data *rdp;\n\tstruct rcu_node *rnp;\n\n\tlockdep_assert_irqs_enabled();\n\tlocal_irq_save(flags);\n\trdp = this_cpu_ptr(&rcu_data);\n\trnp = rdp->mynode;\n\traw_spin_lock_rcu_node(rnp); // irqs already disabled.\n\tneedwake = rcu_start_this_gp(rnp, rdp, gp_seq);\n\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\tif (needwake)\n\t\trcu_gp_kthread_wake();\n\treturn gp_seq;\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};",
            "static void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);",
            "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
            "static void check_cb_ovld_locked(struct rcu_data *rdp, struct rcu_node *rnp);",
            "static bool rcu_rdp_is_offloaded(struct rcu_data *rdp);",
            "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};\nstatic void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void check_cb_ovld_locked(struct rcu_data *rdp, struct rcu_node *rnp);\nstatic bool rcu_rdp_is_offloaded(struct rcu_data *rdp);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nunsigned long start_poll_synchronize_rcu(void)\n{\n\tunsigned long flags;\n\tunsigned long gp_seq = get_state_synchronize_rcu();\n\tbool needwake;\n\tstruct rcu_data *rdp;\n\tstruct rcu_node *rnp;\n\n\tlockdep_assert_irqs_enabled();\n\tlocal_irq_save(flags);\n\trdp = this_cpu_ptr(&rcu_data);\n\trnp = rdp->mynode;\n\traw_spin_lock_rcu_node(rnp); // irqs already disabled.\n\tneedwake = rcu_start_this_gp(rnp, rdp, gp_seq);\n\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\tif (needwake)\n\t\trcu_gp_kthread_wake();\n\treturn gp_seq;\n}"
        }
      },
      {
        "call_info": {
          "callee": "poll_state_synchronize_rcu",
          "args": [
            "oldstate"
          ],
          "line": 3898
        },
        "resolved": true,
        "details": {
          "function_name": "poll_state_synchronize_rcu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "3867-3874",
          "snippet": "bool poll_state_synchronize_rcu(unsigned long oldstate)\n{\n\tif (rcu_seq_done(&rcu_state.gp_seq, oldstate)) {\n\t\tsmp_mb(); /* Ensure GP ends before subsequent accesses. */\n\t\treturn true;\n\t}\n\treturn false;\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\n\nbool poll_state_synchronize_rcu(unsigned long oldstate)\n{\n\tif (rcu_seq_done(&rcu_state.gp_seq, oldstate)) {\n\t\tsmp_mb(); /* Ensure GP ends before subsequent accesses. */\n\t\treturn true;\n\t}\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nvoid cond_synchronize_rcu(unsigned long oldstate)\n{\n\tif (!poll_state_synchronize_rcu(oldstate))\n\t\tsynchronize_rcu();\n}"
  },
  {
    "function_name": "poll_state_synchronize_rcu",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
    "lines": "3867-3874",
    "snippet": "bool poll_state_synchronize_rcu(unsigned long oldstate)\n{\n\tif (rcu_seq_done(&rcu_state.gp_seq, oldstate)) {\n\t\tsmp_mb(); /* Ensure GP ends before subsequent accesses. */\n\t\treturn true;\n\t}\n\treturn false;\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_nocb.h\"",
      "#include \"tree_exp.h\"",
      "#include \"tree_stall.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <linux/kasan.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/panic_notifier.h>",
      "#include <linux/panic.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "smp_mb",
          "args": [],
          "line": 3870
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_seq_done",
          "args": [
            "&rcu_state.gp_seq",
            "oldstate"
          ],
          "line": 3869
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_seq_done",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu.h",
          "lines": "115-118",
          "snippet": "static inline bool rcu_seq_done(unsigned long *sp, unsigned long s)\n{\n\treturn ULONG_CMP_GE(READ_ONCE(*sp), s);\n}",
          "includes": [
            "#include <linux/rcu_node_tree.h>",
            "#include <trace/events/rcu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_node_tree.h>\n#include <trace/events/rcu.h>\n\nstatic inline bool rcu_seq_done(unsigned long *sp, unsigned long s)\n{\n\treturn ULONG_CMP_GE(READ_ONCE(*sp), s);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\n\nbool poll_state_synchronize_rcu(unsigned long oldstate)\n{\n\tif (rcu_seq_done(&rcu_state.gp_seq, oldstate)) {\n\t\tsmp_mb(); /* Ensure GP ends before subsequent accesses. */\n\t\treturn true;\n\t}\n\treturn false;\n}"
  },
  {
    "function_name": "start_poll_synchronize_rcu",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
    "lines": "3821-3839",
    "snippet": "unsigned long start_poll_synchronize_rcu(void)\n{\n\tunsigned long flags;\n\tunsigned long gp_seq = get_state_synchronize_rcu();\n\tbool needwake;\n\tstruct rcu_data *rdp;\n\tstruct rcu_node *rnp;\n\n\tlockdep_assert_irqs_enabled();\n\tlocal_irq_save(flags);\n\trdp = this_cpu_ptr(&rcu_data);\n\trnp = rdp->mynode;\n\traw_spin_lock_rcu_node(rnp); // irqs already disabled.\n\tneedwake = rcu_start_this_gp(rnp, rdp, gp_seq);\n\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\tif (needwake)\n\t\trcu_gp_kthread_wake();\n\treturn gp_seq;\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_nocb.h\"",
      "#include \"tree_exp.h\"",
      "#include \"tree_stall.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <linux/kasan.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/panic_notifier.h>",
      "#include <linux/panic.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};",
      "static void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);",
      "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
      "static void check_cb_ovld_locked(struct rcu_data *rdp, struct rcu_node *rnp);",
      "static bool rcu_rdp_is_offloaded(struct rcu_data *rdp);",
      "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_gp_kthread_wake",
          "args": [],
          "line": 3837
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_gp_kthread_wake",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "1473-1483",
          "snippet": "static void rcu_gp_kthread_wake(void)\n{\n\tstruct task_struct *t = READ_ONCE(rcu_state.gp_kthread);\n\n\tif ((current == t && !in_hardirq() && !in_serving_softirq()) ||\n\t    !READ_ONCE(rcu_state.gp_flags) || !t)\n\t\treturn;\n\tWRITE_ONCE(rcu_state.gp_wake_time, jiffies);\n\tWRITE_ONCE(rcu_state.gp_wake_seq, READ_ONCE(rcu_state.gp_seq));\n\tswake_up_one(&rcu_state.gp_wq);\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\n\nstatic void rcu_gp_kthread_wake(void)\n{\n\tstruct task_struct *t = READ_ONCE(rcu_state.gp_kthread);\n\n\tif ((current == t && !in_hardirq() && !in_serving_softirq()) ||\n\t    !READ_ONCE(rcu_state.gp_flags) || !t)\n\t\treturn;\n\tWRITE_ONCE(rcu_state.gp_wake_time, jiffies);\n\tWRITE_ONCE(rcu_state.gp_wake_seq, READ_ONCE(rcu_state.gp_seq));\n\tswake_up_one(&rcu_state.gp_wq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore_rcu_node",
          "args": [
            "rnp",
            "flags"
          ],
          "line": 3835
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_start_this_gp",
          "args": [
            "rnp",
            "rdp",
            "gp_seq"
          ],
          "line": 3834
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_start_this_gp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "1370-1439",
          "snippet": "static bool rcu_start_this_gp(struct rcu_node *rnp_start, struct rcu_data *rdp,\n\t\t\t      unsigned long gp_seq_req)\n{\n\tbool ret = false;\n\tstruct rcu_node *rnp;\n\n\t/*\n\t * Use funnel locking to either acquire the root rcu_node\n\t * structure's lock or bail out if the need for this grace period\n\t * has already been recorded -- or if that grace period has in\n\t * fact already started.  If there is already a grace period in\n\t * progress in a non-leaf node, no recording is needed because the\n\t * end of the grace period will scan the leaf rcu_node structures.\n\t * Note that rnp_start->lock must not be released.\n\t */\n\traw_lockdep_assert_held_rcu_node(rnp_start);\n\ttrace_rcu_this_gp(rnp_start, rdp, gp_seq_req, TPS(\"Startleaf\"));\n\tfor (rnp = rnp_start; 1; rnp = rnp->parent) {\n\t\tif (rnp != rnp_start)\n\t\t\traw_spin_lock_rcu_node(rnp);\n\t\tif (ULONG_CMP_GE(rnp->gp_seq_needed, gp_seq_req) ||\n\t\t    rcu_seq_started(&rnp->gp_seq, gp_seq_req) ||\n\t\t    (rnp != rnp_start &&\n\t\t     rcu_seq_state(rcu_seq_current(&rnp->gp_seq)))) {\n\t\t\ttrace_rcu_this_gp(rnp, rdp, gp_seq_req,\n\t\t\t\t\t  TPS(\"Prestarted\"));\n\t\t\tgoto unlock_out;\n\t\t}\n\t\tWRITE_ONCE(rnp->gp_seq_needed, gp_seq_req);\n\t\tif (rcu_seq_state(rcu_seq_current(&rnp->gp_seq))) {\n\t\t\t/*\n\t\t\t * We just marked the leaf or internal node, and a\n\t\t\t * grace period is in progress, which means that\n\t\t\t * rcu_gp_cleanup() will see the marking.  Bail to\n\t\t\t * reduce contention.\n\t\t\t */\n\t\t\ttrace_rcu_this_gp(rnp_start, rdp, gp_seq_req,\n\t\t\t\t\t  TPS(\"Startedleaf\"));\n\t\t\tgoto unlock_out;\n\t\t}\n\t\tif (rnp != rnp_start && rnp->parent != NULL)\n\t\t\traw_spin_unlock_rcu_node(rnp);\n\t\tif (!rnp->parent)\n\t\t\tbreak;  /* At root, and perhaps also leaf. */\n\t}\n\n\t/* If GP already in progress, just leave, otherwise start one. */\n\tif (rcu_gp_in_progress()) {\n\t\ttrace_rcu_this_gp(rnp, rdp, gp_seq_req, TPS(\"Startedleafroot\"));\n\t\tgoto unlock_out;\n\t}\n\ttrace_rcu_this_gp(rnp, rdp, gp_seq_req, TPS(\"Startedroot\"));\n\tWRITE_ONCE(rcu_state.gp_flags, rcu_state.gp_flags | RCU_GP_FLAG_INIT);\n\tWRITE_ONCE(rcu_state.gp_req_activity, jiffies);\n\tif (!READ_ONCE(rcu_state.gp_kthread)) {\n\t\ttrace_rcu_this_gp(rnp, rdp, gp_seq_req, TPS(\"NoGPkthread\"));\n\t\tgoto unlock_out;\n\t}\n\ttrace_rcu_grace_period(rcu_state.name, data_race(rcu_state.gp_seq), TPS(\"newreq\"));\n\tret = true;  /* Caller must wake GP kthread. */\nunlock_out:\n\t/* Push furthest requested GP to leaf node and rcu_data structure. */\n\tif (ULONG_CMP_LT(gp_seq_req, rnp->gp_seq_needed)) {\n\t\tWRITE_ONCE(rnp_start->gp_seq_needed, rnp->gp_seq_needed);\n\t\tWRITE_ONCE(rdp->gp_seq_needed, rnp->gp_seq_needed);\n\t}\n\tif (rnp != rnp_start)\n\t\traw_spin_unlock_rcu_node(rnp);\n\treturn ret;\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};",
            "static struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};",
            "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
            "static void check_cb_ovld_locked(struct rcu_data *rdp, struct rcu_node *rnp);",
            "static bool rcu_rdp_is_offloaded(struct rcu_data *rdp);",
            "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};\nstatic struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void check_cb_ovld_locked(struct rcu_data *rdp, struct rcu_node *rnp);\nstatic bool rcu_rdp_is_offloaded(struct rcu_data *rdp);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nstatic bool rcu_start_this_gp(struct rcu_node *rnp_start, struct rcu_data *rdp,\n\t\t\t      unsigned long gp_seq_req)\n{\n\tbool ret = false;\n\tstruct rcu_node *rnp;\n\n\t/*\n\t * Use funnel locking to either acquire the root rcu_node\n\t * structure's lock or bail out if the need for this grace period\n\t * has already been recorded -- or if that grace period has in\n\t * fact already started.  If there is already a grace period in\n\t * progress in a non-leaf node, no recording is needed because the\n\t * end of the grace period will scan the leaf rcu_node structures.\n\t * Note that rnp_start->lock must not be released.\n\t */\n\traw_lockdep_assert_held_rcu_node(rnp_start);\n\ttrace_rcu_this_gp(rnp_start, rdp, gp_seq_req, TPS(\"Startleaf\"));\n\tfor (rnp = rnp_start; 1; rnp = rnp->parent) {\n\t\tif (rnp != rnp_start)\n\t\t\traw_spin_lock_rcu_node(rnp);\n\t\tif (ULONG_CMP_GE(rnp->gp_seq_needed, gp_seq_req) ||\n\t\t    rcu_seq_started(&rnp->gp_seq, gp_seq_req) ||\n\t\t    (rnp != rnp_start &&\n\t\t     rcu_seq_state(rcu_seq_current(&rnp->gp_seq)))) {\n\t\t\ttrace_rcu_this_gp(rnp, rdp, gp_seq_req,\n\t\t\t\t\t  TPS(\"Prestarted\"));\n\t\t\tgoto unlock_out;\n\t\t}\n\t\tWRITE_ONCE(rnp->gp_seq_needed, gp_seq_req);\n\t\tif (rcu_seq_state(rcu_seq_current(&rnp->gp_seq))) {\n\t\t\t/*\n\t\t\t * We just marked the leaf or internal node, and a\n\t\t\t * grace period is in progress, which means that\n\t\t\t * rcu_gp_cleanup() will see the marking.  Bail to\n\t\t\t * reduce contention.\n\t\t\t */\n\t\t\ttrace_rcu_this_gp(rnp_start, rdp, gp_seq_req,\n\t\t\t\t\t  TPS(\"Startedleaf\"));\n\t\t\tgoto unlock_out;\n\t\t}\n\t\tif (rnp != rnp_start && rnp->parent != NULL)\n\t\t\traw_spin_unlock_rcu_node(rnp);\n\t\tif (!rnp->parent)\n\t\t\tbreak;  /* At root, and perhaps also leaf. */\n\t}\n\n\t/* If GP already in progress, just leave, otherwise start one. */\n\tif (rcu_gp_in_progress()) {\n\t\ttrace_rcu_this_gp(rnp, rdp, gp_seq_req, TPS(\"Startedleafroot\"));\n\t\tgoto unlock_out;\n\t}\n\ttrace_rcu_this_gp(rnp, rdp, gp_seq_req, TPS(\"Startedroot\"));\n\tWRITE_ONCE(rcu_state.gp_flags, rcu_state.gp_flags | RCU_GP_FLAG_INIT);\n\tWRITE_ONCE(rcu_state.gp_req_activity, jiffies);\n\tif (!READ_ONCE(rcu_state.gp_kthread)) {\n\t\ttrace_rcu_this_gp(rnp, rdp, gp_seq_req, TPS(\"NoGPkthread\"));\n\t\tgoto unlock_out;\n\t}\n\ttrace_rcu_grace_period(rcu_state.name, data_race(rcu_state.gp_seq), TPS(\"newreq\"));\n\tret = true;  /* Caller must wake GP kthread. */\nunlock_out:\n\t/* Push furthest requested GP to leaf node and rcu_data structure. */\n\tif (ULONG_CMP_LT(gp_seq_req, rnp->gp_seq_needed)) {\n\t\tWRITE_ONCE(rnp_start->gp_seq_needed, rnp->gp_seq_needed);\n\t\tWRITE_ONCE(rdp->gp_seq_needed, rnp->gp_seq_needed);\n\t}\n\tif (rnp != rnp_start)\n\t\traw_spin_unlock_rcu_node(rnp);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_rcu_node",
          "args": [
            "rnp"
          ],
          "line": 3833
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&rcu_data"
          ],
          "line": 3831
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_save",
          "args": [
            "flags"
          ],
          "line": 3830
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_irqs_enabled",
          "args": [],
          "line": 3829
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_state_synchronize_rcu",
          "args": [],
          "line": 3824
        },
        "resolved": true,
        "details": {
          "function_name": "get_state_synchronize_rcu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "3798-3806",
          "snippet": "unsigned long get_state_synchronize_rcu(void)\n{\n\t/*\n\t * Any prior manipulation of RCU-protected data must happen\n\t * before the load from ->gp_seq.\n\t */\n\tsmp_mb();  /* ^^^ */\n\treturn rcu_seq_snap(&rcu_state.gp_seq);\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\n\nunsigned long get_state_synchronize_rcu(void)\n{\n\t/*\n\t * Any prior manipulation of RCU-protected data must happen\n\t * before the load from ->gp_seq.\n\t */\n\tsmp_mb();  /* ^^^ */\n\treturn rcu_seq_snap(&rcu_state.gp_seq);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};\nstatic void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void check_cb_ovld_locked(struct rcu_data *rdp, struct rcu_node *rnp);\nstatic bool rcu_rdp_is_offloaded(struct rcu_data *rdp);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nunsigned long start_poll_synchronize_rcu(void)\n{\n\tunsigned long flags;\n\tunsigned long gp_seq = get_state_synchronize_rcu();\n\tbool needwake;\n\tstruct rcu_data *rdp;\n\tstruct rcu_node *rnp;\n\n\tlockdep_assert_irqs_enabled();\n\tlocal_irq_save(flags);\n\trdp = this_cpu_ptr(&rcu_data);\n\trnp = rdp->mynode;\n\traw_spin_lock_rcu_node(rnp); // irqs already disabled.\n\tneedwake = rcu_start_this_gp(rnp, rdp, gp_seq);\n\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\tif (needwake)\n\t\trcu_gp_kthread_wake();\n\treturn gp_seq;\n}"
  },
  {
    "function_name": "get_state_synchronize_rcu",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
    "lines": "3798-3806",
    "snippet": "unsigned long get_state_synchronize_rcu(void)\n{\n\t/*\n\t * Any prior manipulation of RCU-protected data must happen\n\t * before the load from ->gp_seq.\n\t */\n\tsmp_mb();  /* ^^^ */\n\treturn rcu_seq_snap(&rcu_state.gp_seq);\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_nocb.h\"",
      "#include \"tree_exp.h\"",
      "#include \"tree_stall.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <linux/kasan.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/panic_notifier.h>",
      "#include <linux/panic.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_seq_snap",
          "args": [
            "&rcu_state.gp_seq"
          ],
          "line": 3805
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_seq_snap",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu.h",
          "lines": "87-94",
          "snippet": "static inline unsigned long rcu_seq_snap(unsigned long *sp)\n{\n\tunsigned long s;\n\n\ts = (READ_ONCE(*sp) + 2 * RCU_SEQ_STATE_MASK + 1) & ~RCU_SEQ_STATE_MASK;\n\tsmp_mb(); /* Above access must not bleed into critical section. */\n\treturn s;\n}",
          "includes": [
            "#include <linux/rcu_node_tree.h>",
            "#include <trace/events/rcu.h>"
          ],
          "macros_used": [
            "#define RCU_SEQ_STATE_MASK\t((1 << RCU_SEQ_CTR_SHIFT) - 1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_node_tree.h>\n#include <trace/events/rcu.h>\n\n#define RCU_SEQ_STATE_MASK\t((1 << RCU_SEQ_CTR_SHIFT) - 1)\n\nstatic inline unsigned long rcu_seq_snap(unsigned long *sp)\n{\n\tunsigned long s;\n\n\ts = (READ_ONCE(*sp) + 2 * RCU_SEQ_STATE_MASK + 1) & ~RCU_SEQ_STATE_MASK;\n\tsmp_mb(); /* Above access must not bleed into critical section. */\n\treturn s;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_mb",
          "args": [],
          "line": 3804
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\n\nunsigned long get_state_synchronize_rcu(void)\n{\n\t/*\n\t * Any prior manipulation of RCU-protected data must happen\n\t * before the load from ->gp_seq.\n\t */\n\tsmp_mb();  /* ^^^ */\n\treturn rcu_seq_snap(&rcu_state.gp_seq);\n}"
  },
  {
    "function_name": "synchronize_rcu",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
    "lines": "3776-3788",
    "snippet": "void synchronize_rcu(void)\n{\n\tRCU_LOCKDEP_WARN(lock_is_held(&rcu_bh_lock_map) ||\n\t\t\t lock_is_held(&rcu_lock_map) ||\n\t\t\t lock_is_held(&rcu_sched_lock_map),\n\t\t\t \"Illegal synchronize_rcu() in RCU read-side critical section\");\n\tif (rcu_blocking_is_gp())\n\t\treturn;  // Context allows vacuous grace periods.\n\tif (rcu_gp_is_expedited())\n\t\tsynchronize_rcu_expedited();\n\telse\n\t\twait_rcu_gp(call_rcu);\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_nocb.h\"",
      "#include \"tree_exp.h\"",
      "#include \"tree_stall.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <linux/kasan.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/panic_notifier.h>",
      "#include <linux/panic.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wait_rcu_gp",
          "args": [
            "call_rcu"
          ],
          "line": 3787
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "synchronize_rcu_expedited",
          "args": [],
          "line": 3785
        },
        "resolved": true,
        "details": {
          "function_name": "synchronize_rcu_expedited",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_exp.h",
          "lines": "816-865",
          "snippet": "void synchronize_rcu_expedited(void)\n{\n\tbool boottime = (rcu_scheduler_active == RCU_SCHEDULER_INIT);\n\tstruct rcu_exp_work rew;\n\tstruct rcu_node *rnp;\n\tunsigned long s;\n\n\tRCU_LOCKDEP_WARN(lock_is_held(&rcu_bh_lock_map) ||\n\t\t\t lock_is_held(&rcu_lock_map) ||\n\t\t\t lock_is_held(&rcu_sched_lock_map),\n\t\t\t \"Illegal synchronize_rcu_expedited() in RCU read-side critical section\");\n\n\t/* Is the state is such that the call is a grace period? */\n\tif (rcu_blocking_is_gp())\n\t\treturn;\n\n\t/* If expedited grace periods are prohibited, fall back to normal. */\n\tif (rcu_gp_is_normal()) {\n\t\twait_rcu_gp(call_rcu);\n\t\treturn;\n\t}\n\n\t/* Take a snapshot of the sequence number.  */\n\ts = rcu_exp_gp_seq_snap();\n\tif (exp_funnel_lock(s))\n\t\treturn;  /* Someone else did our work for us. */\n\n\t/* Ensure that load happens before action based on it. */\n\tif (unlikely(boottime)) {\n\t\t/* Direct call during scheduler init and early_initcalls(). */\n\t\trcu_exp_sel_wait_wake(s);\n\t} else {\n\t\t/* Marshall arguments & schedule the expedited grace period. */\n\t\trew.rew_s = s;\n\t\tINIT_WORK_ONSTACK(&rew.rew_work, wait_rcu_exp_gp);\n\t\tqueue_work(rcu_gp_wq, &rew.rew_work);\n\t}\n\n\t/* Wait for expedited grace period to complete. */\n\trnp = rcu_get_root();\n\twait_event(rnp->exp_wq[rcu_seq_ctr(s) & 0x3],\n\t\t   sync_exp_work_done(s));\n\tsmp_mb(); /* Workqueue actions happen before return. */\n\n\t/* Let the next expedited grace period start. */\n\tmutex_unlock(&rcu_state.exp_mutex);\n\n\tif (likely(!boottime))\n\t\tdestroy_work_on_stack(&rew.rew_work);\n}",
          "includes": [
            "#include <linux/lockdep.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int rcu_print_task_exp_stall(struct rcu_node *rnp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockdep.h>\n\nstatic int rcu_print_task_exp_stall(struct rcu_node *rnp);\n\nvoid synchronize_rcu_expedited(void)\n{\n\tbool boottime = (rcu_scheduler_active == RCU_SCHEDULER_INIT);\n\tstruct rcu_exp_work rew;\n\tstruct rcu_node *rnp;\n\tunsigned long s;\n\n\tRCU_LOCKDEP_WARN(lock_is_held(&rcu_bh_lock_map) ||\n\t\t\t lock_is_held(&rcu_lock_map) ||\n\t\t\t lock_is_held(&rcu_sched_lock_map),\n\t\t\t \"Illegal synchronize_rcu_expedited() in RCU read-side critical section\");\n\n\t/* Is the state is such that the call is a grace period? */\n\tif (rcu_blocking_is_gp())\n\t\treturn;\n\n\t/* If expedited grace periods are prohibited, fall back to normal. */\n\tif (rcu_gp_is_normal()) {\n\t\twait_rcu_gp(call_rcu);\n\t\treturn;\n\t}\n\n\t/* Take a snapshot of the sequence number.  */\n\ts = rcu_exp_gp_seq_snap();\n\tif (exp_funnel_lock(s))\n\t\treturn;  /* Someone else did our work for us. */\n\n\t/* Ensure that load happens before action based on it. */\n\tif (unlikely(boottime)) {\n\t\t/* Direct call during scheduler init and early_initcalls(). */\n\t\trcu_exp_sel_wait_wake(s);\n\t} else {\n\t\t/* Marshall arguments & schedule the expedited grace period. */\n\t\trew.rew_s = s;\n\t\tINIT_WORK_ONSTACK(&rew.rew_work, wait_rcu_exp_gp);\n\t\tqueue_work(rcu_gp_wq, &rew.rew_work);\n\t}\n\n\t/* Wait for expedited grace period to complete. */\n\trnp = rcu_get_root();\n\twait_event(rnp->exp_wq[rcu_seq_ctr(s) & 0x3],\n\t\t   sync_exp_work_done(s));\n\tsmp_mb(); /* Workqueue actions happen before return. */\n\n\t/* Let the next expedited grace period start. */\n\tmutex_unlock(&rcu_state.exp_mutex);\n\n\tif (likely(!boottime))\n\t\tdestroy_work_on_stack(&rew.rew_work);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_gp_is_expedited",
          "args": [],
          "line": 3784
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_gp_is_expedited",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "156-159",
          "snippet": "bool rcu_gp_is_expedited(void)\n{\n\treturn rcu_expedited || atomic_read(&rcu_expedited_nesting);\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nbool rcu_gp_is_expedited(void)\n{\n\treturn rcu_expedited || atomic_read(&rcu_expedited_nesting);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_blocking_is_gp",
          "args": [],
          "line": 3782
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_blocking_is_gp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "3712-3736",
          "snippet": "static int rcu_blocking_is_gp(void)\n{\n\tint ret;\n\n\tif (IS_ENABLED(CONFIG_PREEMPTION))\n\t\treturn rcu_scheduler_active == RCU_SCHEDULER_INACTIVE;\n\tmight_sleep();  /* Check for RCU read-side critical section. */\n\tpreempt_disable();\n\t/*\n\t * If the rcu_state.n_online_cpus counter is equal to one,\n\t * there is only one CPU, and that CPU sees all prior accesses\n\t * made by any CPU that was online at the time of its access.\n\t * Furthermore, if this counter is equal to one, its value cannot\n\t * change until after the preempt_enable() below.\n\t *\n\t * Furthermore, if rcu_state.n_online_cpus is equal to one here,\n\t * all later CPUs (both this one and any that come online later\n\t * on) are guaranteed to see all accesses prior to this point\n\t * in the code, without the need for additional memory barriers.\n\t * Those memory barriers are provided by CPU-hotplug code.\n\t */\n\tret = READ_ONCE(rcu_state.n_online_cpus) <= 1;\n\tpreempt_enable();\n\treturn ret;\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};",
            "int rcu_scheduler_active"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\nint rcu_scheduler_active;\n\nstatic int rcu_blocking_is_gp(void)\n{\n\tint ret;\n\n\tif (IS_ENABLED(CONFIG_PREEMPTION))\n\t\treturn rcu_scheduler_active == RCU_SCHEDULER_INACTIVE;\n\tmight_sleep();  /* Check for RCU read-side critical section. */\n\tpreempt_disable();\n\t/*\n\t * If the rcu_state.n_online_cpus counter is equal to one,\n\t * there is only one CPU, and that CPU sees all prior accesses\n\t * made by any CPU that was online at the time of its access.\n\t * Furthermore, if this counter is equal to one, its value cannot\n\t * change until after the preempt_enable() below.\n\t *\n\t * Furthermore, if rcu_state.n_online_cpus is equal to one here,\n\t * all later CPUs (both this one and any that come online later\n\t * on) are guaranteed to see all accesses prior to this point\n\t * in the code, without the need for additional memory barriers.\n\t * Those memory barriers are provided by CPU-hotplug code.\n\t */\n\tret = READ_ONCE(rcu_state.n_online_cpus) <= 1;\n\tpreempt_enable();\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "RCU_LOCKDEP_WARN",
          "args": [
            "lock_is_held(&rcu_bh_lock_map) ||\n\t\t\t lock_is_held(&rcu_lock_map) ||\n\t\t\t lock_is_held(&rcu_sched_lock_map)",
            "\"Illegal synchronize_rcu() in RCU read-side critical section\""
          ],
          "line": 3778
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lock_is_held",
          "args": [
            "&rcu_sched_lock_map"
          ],
          "line": 3780
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lock_is_held",
          "args": [
            "&rcu_lock_map"
          ],
          "line": 3779
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lock_is_held",
          "args": [
            "&rcu_bh_lock_map"
          ],
          "line": 3778
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nvoid synchronize_rcu(void)\n{\n\tRCU_LOCKDEP_WARN(lock_is_held(&rcu_bh_lock_map) ||\n\t\t\t lock_is_held(&rcu_lock_map) ||\n\t\t\t lock_is_held(&rcu_sched_lock_map),\n\t\t\t \"Illegal synchronize_rcu() in RCU read-side critical section\");\n\tif (rcu_blocking_is_gp())\n\t\treturn;  // Context allows vacuous grace periods.\n\tif (rcu_gp_is_expedited())\n\t\tsynchronize_rcu_expedited();\n\telse\n\t\twait_rcu_gp(call_rcu);\n}"
  },
  {
    "function_name": "rcu_blocking_is_gp",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
    "lines": "3712-3736",
    "snippet": "static int rcu_blocking_is_gp(void)\n{\n\tint ret;\n\n\tif (IS_ENABLED(CONFIG_PREEMPTION))\n\t\treturn rcu_scheduler_active == RCU_SCHEDULER_INACTIVE;\n\tmight_sleep();  /* Check for RCU read-side critical section. */\n\tpreempt_disable();\n\t/*\n\t * If the rcu_state.n_online_cpus counter is equal to one,\n\t * there is only one CPU, and that CPU sees all prior accesses\n\t * made by any CPU that was online at the time of its access.\n\t * Furthermore, if this counter is equal to one, its value cannot\n\t * change until after the preempt_enable() below.\n\t *\n\t * Furthermore, if rcu_state.n_online_cpus is equal to one here,\n\t * all later CPUs (both this one and any that come online later\n\t * on) are guaranteed to see all accesses prior to this point\n\t * in the code, without the need for additional memory barriers.\n\t * Those memory barriers are provided by CPU-hotplug code.\n\t */\n\tret = READ_ONCE(rcu_state.n_online_cpus) <= 1;\n\tpreempt_enable();\n\treturn ret;\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_nocb.h\"",
      "#include \"tree_exp.h\"",
      "#include \"tree_stall.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <linux/kasan.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/panic_notifier.h>",
      "#include <linux/panic.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};",
      "int rcu_scheduler_active"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "preempt_enable",
          "args": [],
          "line": 3734
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rcu_state.n_online_cpus"
          ],
          "line": 3733
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preempt_disable",
          "args": [],
          "line": 3719
        },
        "resolved": true,
        "details": {
          "function_name": "schedule_preempt_disabled",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "6425-6430",
          "snippet": "void __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __sched",
            "static void __sched"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic void __sched;\nstatic void __sched;\n\nvoid __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "might_sleep",
          "args": [],
          "line": 3718
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_PREEMPTION"
          ],
          "line": 3716
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\nint rcu_scheduler_active;\n\nstatic int rcu_blocking_is_gp(void)\n{\n\tint ret;\n\n\tif (IS_ENABLED(CONFIG_PREEMPTION))\n\t\treturn rcu_scheduler_active == RCU_SCHEDULER_INACTIVE;\n\tmight_sleep();  /* Check for RCU read-side critical section. */\n\tpreempt_disable();\n\t/*\n\t * If the rcu_state.n_online_cpus counter is equal to one,\n\t * there is only one CPU, and that CPU sees all prior accesses\n\t * made by any CPU that was online at the time of its access.\n\t * Furthermore, if this counter is equal to one, its value cannot\n\t * change until after the preempt_enable() below.\n\t *\n\t * Furthermore, if rcu_state.n_online_cpus is equal to one here,\n\t * all later CPUs (both this one and any that come online later\n\t * on) are guaranteed to see all accesses prior to this point\n\t * in the code, without the need for additional memory barriers.\n\t * Those memory barriers are provided by CPU-hotplug code.\n\t */\n\tret = READ_ONCE(rcu_state.n_online_cpus) <= 1;\n\tpreempt_enable();\n\treturn ret;\n}"
  },
  {
    "function_name": "kfree_rcu_scheduler_running",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
    "lines": "3679-3698",
    "snippet": "void __init kfree_rcu_scheduler_running(void)\n{\n\tint cpu;\n\tunsigned long flags;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tstruct kfree_rcu_cpu *krcp = per_cpu_ptr(&krc, cpu);\n\n\t\traw_spin_lock_irqsave(&krcp->lock, flags);\n\t\tif ((!krcp->bkvhead[0] && !krcp->bkvhead[1] && !krcp->head) ||\n\t\t\t\tkrcp->monitor_todo) {\n\t\t\traw_spin_unlock_irqrestore(&krcp->lock, flags);\n\t\t\tcontinue;\n\t\t}\n\t\tkrcp->monitor_todo = true;\n\t\tschedule_delayed_work_on(cpu, &krcp->monitor_work,\n\t\t\t\t\t KFREE_DRAIN_JIFFIES);\n\t\traw_spin_unlock_irqrestore(&krcp->lock, flags);\n\t}\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_nocb.h\"",
      "#include \"tree_exp.h\"",
      "#include \"tree_stall.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <linux/kasan.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/panic_notifier.h>",
      "#include <linux/panic.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [
      "#define KFREE_DRAIN_JIFFIES (HZ / 50)"
    ],
    "globals_used": [
      "static void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);",
      "static void sync_sched_exp_online_cleanup(int cpu);",
      "static DEFINE_PER_CPU(struct kfree_rcu_cpu, krc) = {\n\t.lock = __RAW_SPIN_LOCK_UNLOCKED(krc.lock),\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore",
          "args": [
            "&krcp->lock",
            "flags"
          ],
          "line": 3696
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "192-195",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "schedule_delayed_work_on",
          "args": [
            "cpu",
            "&krcp->monitor_work",
            "KFREE_DRAIN_JIFFIES"
          ],
          "line": 3694
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave",
          "args": [
            "&krcp->lock",
            "flags"
          ],
          "line": 3687
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "383-393",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "&krc",
            "cpu"
          ],
          "line": 3685
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define KFREE_DRAIN_JIFFIES (HZ / 50)\n\nstatic void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);\nstatic void sync_sched_exp_online_cleanup(int cpu);\nstatic DEFINE_PER_CPU(struct kfree_rcu_cpu, krc) = {\n\t.lock = __RAW_SPIN_LOCK_UNLOCKED(krc.lock),\n};\n\nvoid __init kfree_rcu_scheduler_running(void)\n{\n\tint cpu;\n\tunsigned long flags;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tstruct kfree_rcu_cpu *krcp = per_cpu_ptr(&krc, cpu);\n\n\t\traw_spin_lock_irqsave(&krcp->lock, flags);\n\t\tif ((!krcp->bkvhead[0] && !krcp->bkvhead[1] && !krcp->head) ||\n\t\t\t\tkrcp->monitor_todo) {\n\t\t\traw_spin_unlock_irqrestore(&krcp->lock, flags);\n\t\t\tcontinue;\n\t\t}\n\t\tkrcp->monitor_todo = true;\n\t\tschedule_delayed_work_on(cpu, &krcp->monitor_work,\n\t\t\t\t\t KFREE_DRAIN_JIFFIES);\n\t\traw_spin_unlock_irqrestore(&krcp->lock, flags);\n\t}\n}"
  },
  {
    "function_name": "kfree_rcu_shrink_scan",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
    "lines": "3649-3670",
    "snippet": "static unsigned long\nkfree_rcu_shrink_scan(struct shrinker *shrink, struct shrink_control *sc)\n{\n\tint cpu, freed = 0;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tint count;\n\t\tstruct kfree_rcu_cpu *krcp = per_cpu_ptr(&krc, cpu);\n\n\t\tcount = krcp->count;\n\t\tcount += drain_page_cache(krcp);\n\t\tkfree_rcu_monitor(&krcp->monitor_work.work);\n\n\t\tsc->nr_to_scan -= count;\n\t\tfreed += count;\n\n\t\tif (sc->nr_to_scan <= 0)\n\t\t\tbreak;\n\t}\n\n\treturn freed == 0 ? SHRINK_STOP : freed;\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_nocb.h\"",
      "#include \"tree_exp.h\"",
      "#include \"tree_stall.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <linux/kasan.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/panic_notifier.h>",
      "#include <linux/panic.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void sync_sched_exp_online_cleanup(int cpu);",
      "static DEFINE_PER_CPU(struct kfree_rcu_cpu, krc) = {\n\t.lock = __RAW_SPIN_LOCK_UNLOCKED(krc.lock),\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree_rcu_monitor",
          "args": [
            "&krcp->monitor_work.work"
          ],
          "line": 3660
        },
        "resolved": true,
        "details": {
          "function_name": "kfree_rcu_monitor",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "3366-3425",
          "snippet": "static void kfree_rcu_monitor(struct work_struct *work)\n{\n\tstruct kfree_rcu_cpu *krcp = container_of(work,\n\t\tstruct kfree_rcu_cpu, monitor_work.work);\n\tunsigned long flags;\n\tint i, j;\n\n\traw_spin_lock_irqsave(&krcp->lock, flags);\n\n\t// Attempt to start a new batch.\n\tfor (i = 0; i < KFREE_N_BATCHES; i++) {\n\t\tstruct kfree_rcu_cpu_work *krwp = &(krcp->krw_arr[i]);\n\n\t\t// Try to detach bkvhead or head and attach it over any\n\t\t// available corresponding free channel. It can be that\n\t\t// a previous RCU batch is in progress, it means that\n\t\t// immediately to queue another one is not possible so\n\t\t// in that case the monitor work is rearmed.\n\t\tif ((krcp->bkvhead[0] && !krwp->bkvhead_free[0]) ||\n\t\t\t(krcp->bkvhead[1] && !krwp->bkvhead_free[1]) ||\n\t\t\t\t(krcp->head && !krwp->head_free)) {\n\t\t\t// Channel 1 corresponds to the SLAB-pointer bulk path.\n\t\t\t// Channel 2 corresponds to vmalloc-pointer bulk path.\n\t\t\tfor (j = 0; j < FREE_N_CHANNELS; j++) {\n\t\t\t\tif (!krwp->bkvhead_free[j]) {\n\t\t\t\t\tkrwp->bkvhead_free[j] = krcp->bkvhead[j];\n\t\t\t\t\tkrcp->bkvhead[j] = NULL;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Channel 3 corresponds to both SLAB and vmalloc\n\t\t\t// objects queued on the linked list.\n\t\t\tif (!krwp->head_free) {\n\t\t\t\tkrwp->head_free = krcp->head;\n\t\t\t\tkrcp->head = NULL;\n\t\t\t}\n\n\t\t\tWRITE_ONCE(krcp->count, 0);\n\n\t\t\t// One work is per one batch, so there are three\n\t\t\t// \"free channels\", the batch can handle. It can\n\t\t\t// be that the work is in the pending state when\n\t\t\t// channels have been detached following by each\n\t\t\t// other.\n\t\t\tqueue_rcu_work(system_wq, &krwp->rcu_work);\n\t\t}\n\t}\n\n\t// If there is nothing to detach, it means that our job is\n\t// successfully done here. In case of having at least one\n\t// of the channels that is still busy we should rearm the\n\t// work to repeat an attempt. Because previous batches are\n\t// still in progress.\n\tif (!krcp->bkvhead[0] && !krcp->bkvhead[1] && !krcp->head)\n\t\tkrcp->monitor_todo = false;\n\telse\n\t\tschedule_delayed_work(&krcp->monitor_work, KFREE_DRAIN_JIFFIES);\n\n\traw_spin_unlock_irqrestore(&krcp->lock, flags);\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define FREE_N_CHANNELS 2",
            "#define KFREE_N_BATCHES 2",
            "#define KFREE_DRAIN_JIFFIES (HZ / 50)"
          ],
          "globals_used": [
            "static void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define FREE_N_CHANNELS 2\n#define KFREE_N_BATCHES 2\n#define KFREE_DRAIN_JIFFIES (HZ / 50)\n\nstatic void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);\n\nstatic void kfree_rcu_monitor(struct work_struct *work)\n{\n\tstruct kfree_rcu_cpu *krcp = container_of(work,\n\t\tstruct kfree_rcu_cpu, monitor_work.work);\n\tunsigned long flags;\n\tint i, j;\n\n\traw_spin_lock_irqsave(&krcp->lock, flags);\n\n\t// Attempt to start a new batch.\n\tfor (i = 0; i < KFREE_N_BATCHES; i++) {\n\t\tstruct kfree_rcu_cpu_work *krwp = &(krcp->krw_arr[i]);\n\n\t\t// Try to detach bkvhead or head and attach it over any\n\t\t// available corresponding free channel. It can be that\n\t\t// a previous RCU batch is in progress, it means that\n\t\t// immediately to queue another one is not possible so\n\t\t// in that case the monitor work is rearmed.\n\t\tif ((krcp->bkvhead[0] && !krwp->bkvhead_free[0]) ||\n\t\t\t(krcp->bkvhead[1] && !krwp->bkvhead_free[1]) ||\n\t\t\t\t(krcp->head && !krwp->head_free)) {\n\t\t\t// Channel 1 corresponds to the SLAB-pointer bulk path.\n\t\t\t// Channel 2 corresponds to vmalloc-pointer bulk path.\n\t\t\tfor (j = 0; j < FREE_N_CHANNELS; j++) {\n\t\t\t\tif (!krwp->bkvhead_free[j]) {\n\t\t\t\t\tkrwp->bkvhead_free[j] = krcp->bkvhead[j];\n\t\t\t\t\tkrcp->bkvhead[j] = NULL;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Channel 3 corresponds to both SLAB and vmalloc\n\t\t\t// objects queued on the linked list.\n\t\t\tif (!krwp->head_free) {\n\t\t\t\tkrwp->head_free = krcp->head;\n\t\t\t\tkrcp->head = NULL;\n\t\t\t}\n\n\t\t\tWRITE_ONCE(krcp->count, 0);\n\n\t\t\t// One work is per one batch, so there are three\n\t\t\t// \"free channels\", the batch can handle. It can\n\t\t\t// be that the work is in the pending state when\n\t\t\t// channels have been detached following by each\n\t\t\t// other.\n\t\t\tqueue_rcu_work(system_wq, &krwp->rcu_work);\n\t\t}\n\t}\n\n\t// If there is nothing to detach, it means that our job is\n\t// successfully done here. In case of having at least one\n\t// of the channels that is still busy we should rearm the\n\t// work to repeat an attempt. Because previous batches are\n\t// still in progress.\n\tif (!krcp->bkvhead[0] && !krcp->bkvhead[1] && !krcp->head)\n\t\tkrcp->monitor_todo = false;\n\telse\n\t\tschedule_delayed_work(&krcp->monitor_work, KFREE_DRAIN_JIFFIES);\n\n\traw_spin_unlock_irqrestore(&krcp->lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "drain_page_cache",
          "args": [
            "krcp"
          ],
          "line": 3659
        },
        "resolved": true,
        "details": {
          "function_name": "drain_page_cache",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "3253-3271",
          "snippet": "static int\ndrain_page_cache(struct kfree_rcu_cpu *krcp)\n{\n\tunsigned long flags;\n\tstruct llist_node *page_list, *pos, *n;\n\tint freed = 0;\n\n\traw_spin_lock_irqsave(&krcp->lock, flags);\n\tpage_list = llist_del_all(&krcp->bkvcache);\n\tWRITE_ONCE(krcp->nr_bkv_objs, 0);\n\traw_spin_unlock_irqrestore(&krcp->lock, flags);\n\n\tllist_for_each_safe(pos, n, page_list) {\n\t\tfree_page((unsigned long)pos);\n\t\tfreed++;\n\t}\n\n\treturn freed;\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);\n\nstatic int\ndrain_page_cache(struct kfree_rcu_cpu *krcp)\n{\n\tunsigned long flags;\n\tstruct llist_node *page_list, *pos, *n;\n\tint freed = 0;\n\n\traw_spin_lock_irqsave(&krcp->lock, flags);\n\tpage_list = llist_del_all(&krcp->bkvcache);\n\tWRITE_ONCE(krcp->nr_bkv_objs, 0);\n\traw_spin_unlock_irqrestore(&krcp->lock, flags);\n\n\tllist_for_each_safe(pos, n, page_list) {\n\t\tfree_page((unsigned long)pos);\n\t\tfreed++;\n\t}\n\n\treturn freed;\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "&krc",
            "cpu"
          ],
          "line": 3656
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic void sync_sched_exp_online_cleanup(int cpu);\nstatic DEFINE_PER_CPU(struct kfree_rcu_cpu, krc) = {\n\t.lock = __RAW_SPIN_LOCK_UNLOCKED(krc.lock),\n};\n\nstatic unsigned long\nkfree_rcu_shrink_scan(struct shrinker *shrink, struct shrink_control *sc)\n{\n\tint cpu, freed = 0;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tint count;\n\t\tstruct kfree_rcu_cpu *krcp = per_cpu_ptr(&krc, cpu);\n\n\t\tcount = krcp->count;\n\t\tcount += drain_page_cache(krcp);\n\t\tkfree_rcu_monitor(&krcp->monitor_work.work);\n\n\t\tsc->nr_to_scan -= count;\n\t\tfreed += count;\n\n\t\tif (sc->nr_to_scan <= 0)\n\t\t\tbreak;\n\t}\n\n\treturn freed == 0 ? SHRINK_STOP : freed;\n}"
  },
  {
    "function_name": "kfree_rcu_shrink_count",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
    "lines": "3631-3647",
    "snippet": "static unsigned long\nkfree_rcu_shrink_count(struct shrinker *shrink, struct shrink_control *sc)\n{\n\tint cpu;\n\tunsigned long count = 0;\n\n\t/* Snapshot count of all CPUs */\n\tfor_each_possible_cpu(cpu) {\n\t\tstruct kfree_rcu_cpu *krcp = per_cpu_ptr(&krc, cpu);\n\n\t\tcount += READ_ONCE(krcp->count);\n\t\tcount += READ_ONCE(krcp->nr_bkv_objs);\n\t\tatomic_set(&krcp->backoff_page_cache_fill, 1);\n\t}\n\n\treturn count;\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_nocb.h\"",
      "#include \"tree_exp.h\"",
      "#include \"tree_stall.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <linux/kasan.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/panic_notifier.h>",
      "#include <linux/panic.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void sync_sched_exp_online_cleanup(int cpu);",
      "static DEFINE_PER_CPU(struct kfree_rcu_cpu, krc) = {\n\t.lock = __RAW_SPIN_LOCK_UNLOCKED(krc.lock),\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&krcp->backoff_page_cache_fill",
            "1"
          ],
          "line": 3643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "krcp->nr_bkv_objs"
          ],
          "line": 3642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "krcp->count"
          ],
          "line": 3641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "&krc",
            "cpu"
          ],
          "line": 3639
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic void sync_sched_exp_online_cleanup(int cpu);\nstatic DEFINE_PER_CPU(struct kfree_rcu_cpu, krc) = {\n\t.lock = __RAW_SPIN_LOCK_UNLOCKED(krc.lock),\n};\n\nstatic unsigned long\nkfree_rcu_shrink_count(struct shrinker *shrink, struct shrink_control *sc)\n{\n\tint cpu;\n\tunsigned long count = 0;\n\n\t/* Snapshot count of all CPUs */\n\tfor_each_possible_cpu(cpu) {\n\t\tstruct kfree_rcu_cpu *krcp = per_cpu_ptr(&krc, cpu);\n\n\t\tcount += READ_ONCE(krcp->count);\n\t\tcount += READ_ONCE(krcp->nr_bkv_objs);\n\t\tatomic_set(&krcp->backoff_page_cache_fill, 1);\n\t}\n\n\treturn count;\n}"
  },
  {
    "function_name": "kvfree_call_rcu",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
    "lines": "3560-3628",
    "snippet": "void kvfree_call_rcu(struct rcu_head *head, rcu_callback_t func)\n{\n\tunsigned long flags;\n\tstruct kfree_rcu_cpu *krcp;\n\tbool success;\n\tvoid *ptr;\n\n\tif (head) {\n\t\tptr = (void *) head - (unsigned long) func;\n\t} else {\n\t\t/*\n\t\t * Please note there is a limitation for the head-less\n\t\t * variant, that is why there is a clear rule for such\n\t\t * objects: it can be used from might_sleep() context\n\t\t * only. For other places please embed an rcu_head to\n\t\t * your data.\n\t\t */\n\t\tmight_sleep();\n\t\tptr = (unsigned long *) func;\n\t}\n\n\t// Queue the object but don't yet schedule the batch.\n\tif (debug_rcu_head_queue(ptr)) {\n\t\t// Probable double kfree_rcu(), just leak.\n\t\tWARN_ONCE(1, \"%s(): Double-freed call. rcu_head %p\\n\",\n\t\t\t  __func__, head);\n\n\t\t// Mark as success and leave.\n\t\treturn;\n\t}\n\n\tkasan_record_aux_stack_noalloc(ptr);\n\tsuccess = add_ptr_to_bulk_krc_lock(&krcp, &flags, ptr, !head);\n\tif (!success) {\n\t\trun_page_cache_worker(krcp);\n\n\t\tif (head == NULL)\n\t\t\t// Inline if kvfree_rcu(one_arg) call.\n\t\t\tgoto unlock_return;\n\n\t\thead->func = func;\n\t\thead->next = krcp->head;\n\t\tkrcp->head = head;\n\t\tsuccess = true;\n\t}\n\n\tWRITE_ONCE(krcp->count, krcp->count + 1);\n\n\t// Set timer to drain after KFREE_DRAIN_JIFFIES.\n\tif (rcu_scheduler_active == RCU_SCHEDULER_RUNNING &&\n\t    !krcp->monitor_todo) {\n\t\tkrcp->monitor_todo = true;\n\t\tschedule_delayed_work(&krcp->monitor_work, KFREE_DRAIN_JIFFIES);\n\t}\n\nunlock_return:\n\tkrc_this_cpu_unlock(krcp, flags);\n\n\t/*\n\t * Inline kvfree() after synchronize_rcu(). We can do\n\t * it from might_sleep() context only, so the current\n\t * CPU can pass the QS state.\n\t */\n\tif (!success) {\n\t\tdebug_rcu_head_unqueue((struct rcu_head *) ptr);\n\t\tsynchronize_rcu();\n\t\tkvfree(ptr);\n\t}\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_nocb.h\"",
      "#include \"tree_exp.h\"",
      "#include \"tree_stall.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <linux/kasan.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/panic_notifier.h>",
      "#include <linux/panic.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [
      "#define KFREE_DRAIN_JIFFIES (HZ / 50)"
    ],
    "globals_used": [
      "int rcu_scheduler_active",
      "static void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvfree",
          "args": [
            "ptr"
          ],
          "line": 3626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "synchronize_rcu",
          "args": [],
          "line": 3625
        },
        "resolved": true,
        "details": {
          "function_name": "start_poll_synchronize_rcu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "3821-3839",
          "snippet": "unsigned long start_poll_synchronize_rcu(void)\n{\n\tunsigned long flags;\n\tunsigned long gp_seq = get_state_synchronize_rcu();\n\tbool needwake;\n\tstruct rcu_data *rdp;\n\tstruct rcu_node *rnp;\n\n\tlockdep_assert_irqs_enabled();\n\tlocal_irq_save(flags);\n\trdp = this_cpu_ptr(&rcu_data);\n\trnp = rdp->mynode;\n\traw_spin_lock_rcu_node(rnp); // irqs already disabled.\n\tneedwake = rcu_start_this_gp(rnp, rdp, gp_seq);\n\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\tif (needwake)\n\t\trcu_gp_kthread_wake();\n\treturn gp_seq;\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};",
            "static void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);",
            "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
            "static void check_cb_ovld_locked(struct rcu_data *rdp, struct rcu_node *rnp);",
            "static bool rcu_rdp_is_offloaded(struct rcu_data *rdp);",
            "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};\nstatic void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void check_cb_ovld_locked(struct rcu_data *rdp, struct rcu_node *rnp);\nstatic bool rcu_rdp_is_offloaded(struct rcu_data *rdp);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nunsigned long start_poll_synchronize_rcu(void)\n{\n\tunsigned long flags;\n\tunsigned long gp_seq = get_state_synchronize_rcu();\n\tbool needwake;\n\tstruct rcu_data *rdp;\n\tstruct rcu_node *rnp;\n\n\tlockdep_assert_irqs_enabled();\n\tlocal_irq_save(flags);\n\trdp = this_cpu_ptr(&rcu_data);\n\trnp = rdp->mynode;\n\traw_spin_lock_rcu_node(rnp); // irqs already disabled.\n\tneedwake = rcu_start_this_gp(rnp, rdp, gp_seq);\n\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\tif (needwake)\n\t\trcu_gp_kthread_wake();\n\treturn gp_seq;\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug_rcu_head_unqueue",
          "args": [
            "(struct rcu_head *) ptr"
          ],
          "line": 3624
        },
        "resolved": true,
        "details": {
          "function_name": "debug_rcu_head_unqueue",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu.h",
          "lines": "196-198",
          "snippet": "static inline void debug_rcu_head_unqueue(struct rcu_head *head)\n{\n}",
          "includes": [
            "#include <linux/rcu_node_tree.h>",
            "#include <trace/events/rcu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_node_tree.h>\n#include <trace/events/rcu.h>\n\nstatic inline void debug_rcu_head_unqueue(struct rcu_head *head)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "krc_this_cpu_unlock",
          "args": [
            "krcp",
            "flags"
          ],
          "line": 3616
        },
        "resolved": true,
        "details": {
          "function_name": "krc_this_cpu_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "3223-3227",
          "snippet": "static inline void\nkrc_this_cpu_unlock(struct kfree_rcu_cpu *krcp, unsigned long flags)\n{\n\traw_spin_unlock_irqrestore(&krcp->lock, flags);\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);\n\nstatic inline void\nkrc_this_cpu_unlock(struct kfree_rcu_cpu *krcp, unsigned long flags)\n{\n\traw_spin_unlock_irqrestore(&krcp->lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "schedule_delayed_work",
          "args": [
            "&krcp->monitor_work",
            "KFREE_DRAIN_JIFFIES"
          ],
          "line": 3612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "krcp->count",
            "krcp->count + 1"
          ],
          "line": 3606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "run_page_cache_worker",
          "args": [
            "krcp"
          ],
          "line": 3594
        },
        "resolved": true,
        "details": {
          "function_name": "run_page_cache_worker",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "3471-3486",
          "snippet": "static void\nrun_page_cache_worker(struct kfree_rcu_cpu *krcp)\n{\n\tif (rcu_scheduler_active == RCU_SCHEDULER_RUNNING &&\n\t\t\t!atomic_xchg(&krcp->work_in_progress, 1)) {\n\t\tif (atomic_read(&krcp->backoff_page_cache_fill)) {\n\t\t\tqueue_delayed_work(system_wq,\n\t\t\t\t&krcp->page_cache_work,\n\t\t\t\t\tmsecs_to_jiffies(rcu_delay_page_cache_fill_msec));\n\t\t} else {\n\t\t\thrtimer_init(&krcp->hrtimer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);\n\t\t\tkrcp->hrtimer.function = schedule_page_work_fn;\n\t\t\thrtimer_start(&krcp->hrtimer, 0, HRTIMER_MODE_REL);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int rcu_scheduler_active",
            "static int rcu_delay_page_cache_fill_msec = 5000;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_scheduler_active;\nstatic int rcu_delay_page_cache_fill_msec = 5000;\n\nstatic void\nrun_page_cache_worker(struct kfree_rcu_cpu *krcp)\n{\n\tif (rcu_scheduler_active == RCU_SCHEDULER_RUNNING &&\n\t\t\t!atomic_xchg(&krcp->work_in_progress, 1)) {\n\t\tif (atomic_read(&krcp->backoff_page_cache_fill)) {\n\t\t\tqueue_delayed_work(system_wq,\n\t\t\t\t&krcp->page_cache_work,\n\t\t\t\t\tmsecs_to_jiffies(rcu_delay_page_cache_fill_msec));\n\t\t} else {\n\t\t\thrtimer_init(&krcp->hrtimer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);\n\t\t\tkrcp->hrtimer.function = schedule_page_work_fn;\n\t\t\thrtimer_start(&krcp->hrtimer, 0, HRTIMER_MODE_REL);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "add_ptr_to_bulk_krc_lock",
          "args": [
            "&krcp",
            "&flags",
            "ptr",
            "!head"
          ],
          "line": 3592
        },
        "resolved": true,
        "details": {
          "function_name": "add_ptr_to_bulk_krc_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "3494-3546",
          "snippet": "static inline bool\nadd_ptr_to_bulk_krc_lock(struct kfree_rcu_cpu **krcp,\n\tunsigned long *flags, void *ptr, bool can_alloc)\n{\n\tstruct kvfree_rcu_bulk_data *bnode;\n\tint idx;\n\n\t*krcp = krc_this_cpu_lock(flags);\n\tif (unlikely(!(*krcp)->initialized))\n\t\treturn false;\n\n\tidx = !!is_vmalloc_addr(ptr);\n\n\t/* Check if a new block is required. */\n\tif (!(*krcp)->bkvhead[idx] ||\n\t\t\t(*krcp)->bkvhead[idx]->nr_records == KVFREE_BULK_MAX_ENTR) {\n\t\tbnode = get_cached_bnode(*krcp);\n\t\tif (!bnode && can_alloc) {\n\t\t\tkrc_this_cpu_unlock(*krcp, *flags);\n\n\t\t\t// __GFP_NORETRY - allows a light-weight direct reclaim\n\t\t\t// what is OK from minimizing of fallback hitting point of\n\t\t\t// view. Apart of that it forbids any OOM invoking what is\n\t\t\t// also beneficial since we are about to release memory soon.\n\t\t\t//\n\t\t\t// __GFP_NOMEMALLOC - prevents from consuming of all the\n\t\t\t// memory reserves. Please note we have a fallback path.\n\t\t\t//\n\t\t\t// __GFP_NOWARN - it is supposed that an allocation can\n\t\t\t// be failed under low memory or high memory pressure\n\t\t\t// scenarios.\n\t\t\tbnode = (struct kvfree_rcu_bulk_data *)\n\t\t\t\t__get_free_page(GFP_KERNEL | __GFP_NORETRY | __GFP_NOMEMALLOC | __GFP_NOWARN);\n\t\t\t*krcp = krc_this_cpu_lock(flags);\n\t\t}\n\n\t\tif (!bnode)\n\t\t\treturn false;\n\n\t\t/* Initialize the new block. */\n\t\tbnode->nr_records = 0;\n\t\tbnode->next = (*krcp)->bkvhead[idx];\n\n\t\t/* Attach it to the head. */\n\t\t(*krcp)->bkvhead[idx] = bnode;\n\t}\n\n\t/* Finally insert. */\n\t(*krcp)->bkvhead[idx]->records\n\t\t[(*krcp)->bkvhead[idx]->nr_records++] = ptr;\n\n\treturn true;\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define KVFREE_BULK_MAX_ENTR \\\n\t((PAGE_SIZE - sizeof(struct kvfree_rcu_bulk_data)) / sizeof(void *))"
          ],
          "globals_used": [
            "static void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define KVFREE_BULK_MAX_ENTR \\\n\t((PAGE_SIZE - sizeof(struct kvfree_rcu_bulk_data)) / sizeof(void *))\n\nstatic void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);\n\nstatic inline bool\nadd_ptr_to_bulk_krc_lock(struct kfree_rcu_cpu **krcp,\n\tunsigned long *flags, void *ptr, bool can_alloc)\n{\n\tstruct kvfree_rcu_bulk_data *bnode;\n\tint idx;\n\n\t*krcp = krc_this_cpu_lock(flags);\n\tif (unlikely(!(*krcp)->initialized))\n\t\treturn false;\n\n\tidx = !!is_vmalloc_addr(ptr);\n\n\t/* Check if a new block is required. */\n\tif (!(*krcp)->bkvhead[idx] ||\n\t\t\t(*krcp)->bkvhead[idx]->nr_records == KVFREE_BULK_MAX_ENTR) {\n\t\tbnode = get_cached_bnode(*krcp);\n\t\tif (!bnode && can_alloc) {\n\t\t\tkrc_this_cpu_unlock(*krcp, *flags);\n\n\t\t\t// __GFP_NORETRY - allows a light-weight direct reclaim\n\t\t\t// what is OK from minimizing of fallback hitting point of\n\t\t\t// view. Apart of that it forbids any OOM invoking what is\n\t\t\t// also beneficial since we are about to release memory soon.\n\t\t\t//\n\t\t\t// __GFP_NOMEMALLOC - prevents from consuming of all the\n\t\t\t// memory reserves. Please note we have a fallback path.\n\t\t\t//\n\t\t\t// __GFP_NOWARN - it is supposed that an allocation can\n\t\t\t// be failed under low memory or high memory pressure\n\t\t\t// scenarios.\n\t\t\tbnode = (struct kvfree_rcu_bulk_data *)\n\t\t\t\t__get_free_page(GFP_KERNEL | __GFP_NORETRY | __GFP_NOMEMALLOC | __GFP_NOWARN);\n\t\t\t*krcp = krc_this_cpu_lock(flags);\n\t\t}\n\n\t\tif (!bnode)\n\t\t\treturn false;\n\n\t\t/* Initialize the new block. */\n\t\tbnode->nr_records = 0;\n\t\tbnode->next = (*krcp)->bkvhead[idx];\n\n\t\t/* Attach it to the head. */\n\t\t(*krcp)->bkvhead[idx] = bnode;\n\t}\n\n\t/* Finally insert. */\n\t(*krcp)->bkvhead[idx]->records\n\t\t[(*krcp)->bkvhead[idx]->nr_records++] = ptr;\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kasan_record_aux_stack_noalloc",
          "args": [
            "ptr"
          ],
          "line": 3591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ONCE",
          "args": [
            "1",
            "\"%s(): Double-freed call. rcu_head %p\\n\"",
            "__func__",
            "head"
          ],
          "line": 3584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_rcu_head_queue",
          "args": [
            "ptr"
          ],
          "line": 3582
        },
        "resolved": true,
        "details": {
          "function_name": "debug_rcu_head_queue",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu.h",
          "lines": "191-194",
          "snippet": "static inline int debug_rcu_head_queue(struct rcu_head *head)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/rcu_node_tree.h>",
            "#include <trace/events/rcu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_node_tree.h>\n#include <trace/events/rcu.h>\n\nstatic inline int debug_rcu_head_queue(struct rcu_head *head)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "might_sleep",
          "args": [],
          "line": 3577
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define KFREE_DRAIN_JIFFIES (HZ / 50)\n\nint rcu_scheduler_active;\nstatic void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);\n\nvoid kvfree_call_rcu(struct rcu_head *head, rcu_callback_t func)\n{\n\tunsigned long flags;\n\tstruct kfree_rcu_cpu *krcp;\n\tbool success;\n\tvoid *ptr;\n\n\tif (head) {\n\t\tptr = (void *) head - (unsigned long) func;\n\t} else {\n\t\t/*\n\t\t * Please note there is a limitation for the head-less\n\t\t * variant, that is why there is a clear rule for such\n\t\t * objects: it can be used from might_sleep() context\n\t\t * only. For other places please embed an rcu_head to\n\t\t * your data.\n\t\t */\n\t\tmight_sleep();\n\t\tptr = (unsigned long *) func;\n\t}\n\n\t// Queue the object but don't yet schedule the batch.\n\tif (debug_rcu_head_queue(ptr)) {\n\t\t// Probable double kfree_rcu(), just leak.\n\t\tWARN_ONCE(1, \"%s(): Double-freed call. rcu_head %p\\n\",\n\t\t\t  __func__, head);\n\n\t\t// Mark as success and leave.\n\t\treturn;\n\t}\n\n\tkasan_record_aux_stack_noalloc(ptr);\n\tsuccess = add_ptr_to_bulk_krc_lock(&krcp, &flags, ptr, !head);\n\tif (!success) {\n\t\trun_page_cache_worker(krcp);\n\n\t\tif (head == NULL)\n\t\t\t// Inline if kvfree_rcu(one_arg) call.\n\t\t\tgoto unlock_return;\n\n\t\thead->func = func;\n\t\thead->next = krcp->head;\n\t\tkrcp->head = head;\n\t\tsuccess = true;\n\t}\n\n\tWRITE_ONCE(krcp->count, krcp->count + 1);\n\n\t// Set timer to drain after KFREE_DRAIN_JIFFIES.\n\tif (rcu_scheduler_active == RCU_SCHEDULER_RUNNING &&\n\t    !krcp->monitor_todo) {\n\t\tkrcp->monitor_todo = true;\n\t\tschedule_delayed_work(&krcp->monitor_work, KFREE_DRAIN_JIFFIES);\n\t}\n\nunlock_return:\n\tkrc_this_cpu_unlock(krcp, flags);\n\n\t/*\n\t * Inline kvfree() after synchronize_rcu(). We can do\n\t * it from might_sleep() context only, so the current\n\t * CPU can pass the QS state.\n\t */\n\tif (!success) {\n\t\tdebug_rcu_head_unqueue((struct rcu_head *) ptr);\n\t\tsynchronize_rcu();\n\t\tkvfree(ptr);\n\t}\n}"
  },
  {
    "function_name": "add_ptr_to_bulk_krc_lock",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
    "lines": "3494-3546",
    "snippet": "static inline bool\nadd_ptr_to_bulk_krc_lock(struct kfree_rcu_cpu **krcp,\n\tunsigned long *flags, void *ptr, bool can_alloc)\n{\n\tstruct kvfree_rcu_bulk_data *bnode;\n\tint idx;\n\n\t*krcp = krc_this_cpu_lock(flags);\n\tif (unlikely(!(*krcp)->initialized))\n\t\treturn false;\n\n\tidx = !!is_vmalloc_addr(ptr);\n\n\t/* Check if a new block is required. */\n\tif (!(*krcp)->bkvhead[idx] ||\n\t\t\t(*krcp)->bkvhead[idx]->nr_records == KVFREE_BULK_MAX_ENTR) {\n\t\tbnode = get_cached_bnode(*krcp);\n\t\tif (!bnode && can_alloc) {\n\t\t\tkrc_this_cpu_unlock(*krcp, *flags);\n\n\t\t\t// __GFP_NORETRY - allows a light-weight direct reclaim\n\t\t\t// what is OK from minimizing of fallback hitting point of\n\t\t\t// view. Apart of that it forbids any OOM invoking what is\n\t\t\t// also beneficial since we are about to release memory soon.\n\t\t\t//\n\t\t\t// __GFP_NOMEMALLOC - prevents from consuming of all the\n\t\t\t// memory reserves. Please note we have a fallback path.\n\t\t\t//\n\t\t\t// __GFP_NOWARN - it is supposed that an allocation can\n\t\t\t// be failed under low memory or high memory pressure\n\t\t\t// scenarios.\n\t\t\tbnode = (struct kvfree_rcu_bulk_data *)\n\t\t\t\t__get_free_page(GFP_KERNEL | __GFP_NORETRY | __GFP_NOMEMALLOC | __GFP_NOWARN);\n\t\t\t*krcp = krc_this_cpu_lock(flags);\n\t\t}\n\n\t\tif (!bnode)\n\t\t\treturn false;\n\n\t\t/* Initialize the new block. */\n\t\tbnode->nr_records = 0;\n\t\tbnode->next = (*krcp)->bkvhead[idx];\n\n\t\t/* Attach it to the head. */\n\t\t(*krcp)->bkvhead[idx] = bnode;\n\t}\n\n\t/* Finally insert. */\n\t(*krcp)->bkvhead[idx]->records\n\t\t[(*krcp)->bkvhead[idx]->nr_records++] = ptr;\n\n\treturn true;\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_nocb.h\"",
      "#include \"tree_exp.h\"",
      "#include \"tree_stall.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <linux/kasan.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/panic_notifier.h>",
      "#include <linux/panic.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [
      "#define KVFREE_BULK_MAX_ENTR \\\n\t((PAGE_SIZE - sizeof(struct kvfree_rcu_bulk_data)) / sizeof(void *))"
    ],
    "globals_used": [
      "static void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "krc_this_cpu_lock",
          "args": [
            "flags"
          ],
          "line": 3527
        },
        "resolved": true,
        "details": {
          "function_name": "krc_this_cpu_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "3211-3221",
          "snippet": "static inline struct kfree_rcu_cpu *\nkrc_this_cpu_lock(unsigned long *flags)\n{\n\tstruct kfree_rcu_cpu *krcp;\n\n\tlocal_irq_save(*flags);\t// For safely calling this_cpu_ptr().\n\tkrcp = this_cpu_ptr(&krc);\n\traw_spin_lock(&krcp->lock);\n\n\treturn krcp;\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);",
            "static DEFINE_PER_CPU(struct kfree_rcu_cpu, krc) = {\n\t.lock = __RAW_SPIN_LOCK_UNLOCKED(krc.lock),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);\nstatic DEFINE_PER_CPU(struct kfree_rcu_cpu, krc) = {\n\t.lock = __RAW_SPIN_LOCK_UNLOCKED(krc.lock),\n};\n\nstatic inline struct kfree_rcu_cpu *\nkrc_this_cpu_lock(unsigned long *flags)\n{\n\tstruct kfree_rcu_cpu *krcp;\n\n\tlocal_irq_save(*flags);\t// For safely calling this_cpu_ptr().\n\tkrcp = this_cpu_ptr(&krc);\n\traw_spin_lock(&krcp->lock);\n\n\treturn krcp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__get_free_page",
          "args": [
            "GFP_KERNEL | __GFP_NORETRY | __GFP_NOMEMALLOC | __GFP_NOWARN"
          ],
          "line": 3526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krc_this_cpu_unlock",
          "args": [
            "*krcp",
            "*flags"
          ],
          "line": 3512
        },
        "resolved": true,
        "details": {
          "function_name": "krc_this_cpu_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "3223-3227",
          "snippet": "static inline void\nkrc_this_cpu_unlock(struct kfree_rcu_cpu *krcp, unsigned long flags)\n{\n\traw_spin_unlock_irqrestore(&krcp->lock, flags);\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);\n\nstatic inline void\nkrc_this_cpu_unlock(struct kfree_rcu_cpu *krcp, unsigned long flags)\n{\n\traw_spin_unlock_irqrestore(&krcp->lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_cached_bnode",
          "args": [
            "*krcp"
          ],
          "line": 3510
        },
        "resolved": true,
        "details": {
          "function_name": "get_cached_bnode",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "3229-3238",
          "snippet": "static inline struct kvfree_rcu_bulk_data *\nget_cached_bnode(struct kfree_rcu_cpu *krcp)\n{\n\tif (!krcp->nr_bkv_objs)\n\t\treturn NULL;\n\n\tWRITE_ONCE(krcp->nr_bkv_objs, krcp->nr_bkv_objs - 1);\n\treturn (struct kvfree_rcu_bulk_data *)\n\t\tllist_del_first(&krcp->bkvcache);\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic inline struct kvfree_rcu_bulk_data *\nget_cached_bnode(struct kfree_rcu_cpu *krcp)\n{\n\tif (!krcp->nr_bkv_objs)\n\t\treturn NULL;\n\n\tWRITE_ONCE(krcp->nr_bkv_objs, krcp->nr_bkv_objs - 1);\n\treturn (struct kvfree_rcu_bulk_data *)\n\t\tllist_del_first(&krcp->bkvcache);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_vmalloc_addr",
          "args": [
            "ptr"
          ],
          "line": 3505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!(*krcp)->initialized"
          ],
          "line": 3502
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define KVFREE_BULK_MAX_ENTR \\\n\t((PAGE_SIZE - sizeof(struct kvfree_rcu_bulk_data)) / sizeof(void *))\n\nstatic void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);\n\nstatic inline bool\nadd_ptr_to_bulk_krc_lock(struct kfree_rcu_cpu **krcp,\n\tunsigned long *flags, void *ptr, bool can_alloc)\n{\n\tstruct kvfree_rcu_bulk_data *bnode;\n\tint idx;\n\n\t*krcp = krc_this_cpu_lock(flags);\n\tif (unlikely(!(*krcp)->initialized))\n\t\treturn false;\n\n\tidx = !!is_vmalloc_addr(ptr);\n\n\t/* Check if a new block is required. */\n\tif (!(*krcp)->bkvhead[idx] ||\n\t\t\t(*krcp)->bkvhead[idx]->nr_records == KVFREE_BULK_MAX_ENTR) {\n\t\tbnode = get_cached_bnode(*krcp);\n\t\tif (!bnode && can_alloc) {\n\t\t\tkrc_this_cpu_unlock(*krcp, *flags);\n\n\t\t\t// __GFP_NORETRY - allows a light-weight direct reclaim\n\t\t\t// what is OK from minimizing of fallback hitting point of\n\t\t\t// view. Apart of that it forbids any OOM invoking what is\n\t\t\t// also beneficial since we are about to release memory soon.\n\t\t\t//\n\t\t\t// __GFP_NOMEMALLOC - prevents from consuming of all the\n\t\t\t// memory reserves. Please note we have a fallback path.\n\t\t\t//\n\t\t\t// __GFP_NOWARN - it is supposed that an allocation can\n\t\t\t// be failed under low memory or high memory pressure\n\t\t\t// scenarios.\n\t\t\tbnode = (struct kvfree_rcu_bulk_data *)\n\t\t\t\t__get_free_page(GFP_KERNEL | __GFP_NORETRY | __GFP_NOMEMALLOC | __GFP_NOWARN);\n\t\t\t*krcp = krc_this_cpu_lock(flags);\n\t\t}\n\n\t\tif (!bnode)\n\t\t\treturn false;\n\n\t\t/* Initialize the new block. */\n\t\tbnode->nr_records = 0;\n\t\tbnode->next = (*krcp)->bkvhead[idx];\n\n\t\t/* Attach it to the head. */\n\t\t(*krcp)->bkvhead[idx] = bnode;\n\t}\n\n\t/* Finally insert. */\n\t(*krcp)->bkvhead[idx]->records\n\t\t[(*krcp)->bkvhead[idx]->nr_records++] = ptr;\n\n\treturn true;\n}"
  },
  {
    "function_name": "run_page_cache_worker",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
    "lines": "3471-3486",
    "snippet": "static void\nrun_page_cache_worker(struct kfree_rcu_cpu *krcp)\n{\n\tif (rcu_scheduler_active == RCU_SCHEDULER_RUNNING &&\n\t\t\t!atomic_xchg(&krcp->work_in_progress, 1)) {\n\t\tif (atomic_read(&krcp->backoff_page_cache_fill)) {\n\t\t\tqueue_delayed_work(system_wq,\n\t\t\t\t&krcp->page_cache_work,\n\t\t\t\t\tmsecs_to_jiffies(rcu_delay_page_cache_fill_msec));\n\t\t} else {\n\t\t\thrtimer_init(&krcp->hrtimer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);\n\t\t\tkrcp->hrtimer.function = schedule_page_work_fn;\n\t\t\thrtimer_start(&krcp->hrtimer, 0, HRTIMER_MODE_REL);\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_nocb.h\"",
      "#include \"tree_exp.h\"",
      "#include \"tree_stall.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <linux/kasan.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/panic_notifier.h>",
      "#include <linux/panic.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int rcu_scheduler_active",
      "static int rcu_delay_page_cache_fill_msec = 5000;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "hrtimer_start",
          "args": [
            "&krcp->hrtimer",
            "0",
            "HRTIMER_MODE_REL"
          ],
          "line": 3483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hrtimer_init",
          "args": [
            "&krcp->hrtimer",
            "CLOCK_MONOTONIC",
            "HRTIMER_MODE_REL"
          ],
          "line": 3481
        },
        "resolved": true,
        "details": {
          "function_name": "hrtimer_init_sleeper",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
          "lines": "2007-2013",
          "snippet": "void hrtimer_init_sleeper(struct hrtimer_sleeper *sl, clockid_t clock_id,\n\t\t\t  enum hrtimer_mode mode)\n{\n\tdebug_init(&sl->timer, clock_id, mode);\n\t__hrtimer_init_sleeper(sl, clock_id, mode);\n\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nvoid hrtimer_init_sleeper(struct hrtimer_sleeper *sl, clockid_t clock_id,\n\t\t\t  enum hrtimer_mode mode)\n{\n\tdebug_init(&sl->timer, clock_id, mode);\n\t__hrtimer_init_sleeper(sl, clock_id, mode);\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "queue_delayed_work",
          "args": [
            "system_wq",
            "&krcp->page_cache_work",
            "msecs_to_jiffies(rcu_delay_page_cache_fill_msec)"
          ],
          "line": 3477
        },
        "resolved": true,
        "details": {
          "function_name": "kthread_queue_delayed_work",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
          "lines": "1092-1109",
          "snippet": "bool kthread_queue_delayed_work(struct kthread_worker *worker,\n\t\t\t\tstruct kthread_delayed_work *dwork,\n\t\t\t\tunsigned long delay)\n{\n\tstruct kthread_work *work = &dwork->work;\n\tunsigned long flags;\n\tbool ret = false;\n\n\traw_spin_lock_irqsave(&worker->lock, flags);\n\n\tif (!queuing_blocked(worker, work)) {\n\t\t__kthread_queue_delayed_work(worker, dwork, delay);\n\t\tret = true;\n\t}\n\n\traw_spin_unlock_irqrestore(&worker->lock, flags);\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/numa.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mm.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nbool kthread_queue_delayed_work(struct kthread_worker *worker,\n\t\t\t\tstruct kthread_delayed_work *dwork,\n\t\t\t\tunsigned long delay)\n{\n\tstruct kthread_work *work = &dwork->work;\n\tunsigned long flags;\n\tbool ret = false;\n\n\traw_spin_lock_irqsave(&worker->lock, flags);\n\n\tif (!queuing_blocked(worker, work)) {\n\t\t__kthread_queue_delayed_work(worker, dwork, delay);\n\t\tret = true;\n\t}\n\n\traw_spin_unlock_irqrestore(&worker->lock, flags);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "msecs_to_jiffies",
          "args": [
            "rcu_delay_page_cache_fill_msec"
          ],
          "line": 3479
        },
        "resolved": true,
        "details": {
          "function_name": "__msecs_to_jiffies",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/time.c",
          "lines": "552-560",
          "snippet": "unsigned long __msecs_to_jiffies(const unsigned int m)\n{\n\t/*\n\t * Negative value, means infinite timeout:\n\t */\n\tif ((int)m < 0)\n\t\treturn MAX_JIFFY_OFFSET;\n\treturn _msecs_to_jiffies(m);\n}",
          "includes": [
            "#include \"timekeeping.h\"",
            "#include <generated/timeconst.h>",
            "#include <asm/unistd.h>",
            "#include <linux/compat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/math64.h>",
            "#include <linux/fs.h>",
            "#include <linux/security.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/errno.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/capability.h>",
            "#include <linux/timex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping.h\"\n#include <generated/timeconst.h>\n#include <asm/unistd.h>\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/math64.h>\n#include <linux/fs.h>\n#include <linux/security.h>\n#include <linux/syscalls.h>\n#include <linux/errno.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/capability.h>\n#include <linux/timex.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nunsigned long __msecs_to_jiffies(const unsigned int m)\n{\n\t/*\n\t * Negative value, means infinite timeout:\n\t */\n\tif ((int)m < 0)\n\t\treturn MAX_JIFFY_OFFSET;\n\treturn _msecs_to_jiffies(m);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&krcp->backoff_page_cache_fill"
          ],
          "line": 3476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_xchg",
          "args": [
            "&krcp->work_in_progress",
            "1"
          ],
          "line": 3475
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_scheduler_active;\nstatic int rcu_delay_page_cache_fill_msec = 5000;\n\nstatic void\nrun_page_cache_worker(struct kfree_rcu_cpu *krcp)\n{\n\tif (rcu_scheduler_active == RCU_SCHEDULER_RUNNING &&\n\t\t\t!atomic_xchg(&krcp->work_in_progress, 1)) {\n\t\tif (atomic_read(&krcp->backoff_page_cache_fill)) {\n\t\t\tqueue_delayed_work(system_wq,\n\t\t\t\t&krcp->page_cache_work,\n\t\t\t\t\tmsecs_to_jiffies(rcu_delay_page_cache_fill_msec));\n\t\t} else {\n\t\t\thrtimer_init(&krcp->hrtimer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);\n\t\t\tkrcp->hrtimer.function = schedule_page_work_fn;\n\t\t\thrtimer_start(&krcp->hrtimer, 0, HRTIMER_MODE_REL);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "fill_page_cache_func",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
    "lines": "3437-3469",
    "snippet": "static void fill_page_cache_func(struct work_struct *work)\n{\n\tstruct kvfree_rcu_bulk_data *bnode;\n\tstruct kfree_rcu_cpu *krcp =\n\t\tcontainer_of(work, struct kfree_rcu_cpu,\n\t\t\tpage_cache_work.work);\n\tunsigned long flags;\n\tint nr_pages;\n\tbool pushed;\n\tint i;\n\n\tnr_pages = atomic_read(&krcp->backoff_page_cache_fill) ?\n\t\t1 : rcu_min_cached_objs;\n\n\tfor (i = 0; i < nr_pages; i++) {\n\t\tbnode = (struct kvfree_rcu_bulk_data *)\n\t\t\t__get_free_page(GFP_KERNEL | __GFP_NORETRY | __GFP_NOMEMALLOC | __GFP_NOWARN);\n\n\t\tif (bnode) {\n\t\t\traw_spin_lock_irqsave(&krcp->lock, flags);\n\t\t\tpushed = put_cached_bnode(krcp, bnode);\n\t\t\traw_spin_unlock_irqrestore(&krcp->lock, flags);\n\n\t\t\tif (!pushed) {\n\t\t\t\tfree_page((unsigned long) bnode);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tatomic_set(&krcp->work_in_progress, 0);\n\tatomic_set(&krcp->backoff_page_cache_fill, 0);\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_nocb.h\"",
      "#include \"tree_exp.h\"",
      "#include \"tree_stall.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <linux/kasan.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/panic_notifier.h>",
      "#include <linux/panic.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);",
      "static int rcu_min_cached_objs = 5;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&krcp->backoff_page_cache_fill",
            "0"
          ],
          "line": 3468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&krcp->work_in_progress",
            "0"
          ],
          "line": 3467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_page",
          "args": [
            "(unsigned long) bnode"
          ],
          "line": 3461
        },
        "resolved": true,
        "details": {
          "function_name": "kimage_free_page_list",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kexec_core.c",
          "lines": "341-349",
          "snippet": "void kimage_free_page_list(struct list_head *list)\n{\n\tstruct page *page, *next;\n\n\tlist_for_each_entry_safe(page, next, list, lru) {\n\t\tlist_del(&page->lru);\n\t\tkimage_free_pages(page);\n\t}\n}",
          "includes": [
            "#include \"kexec_internal.h\"",
            "#include <crypto/hash.h>",
            "#include <asm/sections.h>",
            "#include <asm/page.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/objtool.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/compiler.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/console.h>",
            "#include <linux/io.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/cpu.h>",
            "#include <linux/pm.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/freezer.h>",
            "#include <linux/device.h>",
            "#include <linux/suspend.h>",
            "#include <linux/numa.h>",
            "#include <linux/utsname.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/elf.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/ioport.h>",
            "#include <linux/reboot.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/highmem.h>",
            "#include <linux/list.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kexec.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kexec_internal.h\"\n#include <crypto/hash.h>\n#include <asm/sections.h>\n#include <asm/page.h>\n#include <linux/kmsg_dump.h>\n#include <linux/objtool.h>\n#include <linux/hugetlb.h>\n#include <linux/compiler.h>\n#include <linux/syscore_ops.h>\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/console.h>\n#include <linux/io.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/pm.h>\n#include <linux/panic_notifier.h>\n#include <linux/freezer.h>\n#include <linux/device.h>\n#include <linux/suspend.h>\n#include <linux/numa.h>\n#include <linux/utsname.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <linux/hardirq.h>\n#include <linux/ioport.h>\n#include <linux/reboot.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/list.h>\n#include <linux/mutex.h>\n#include <linux/kexec.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n\nvoid kimage_free_page_list(struct list_head *list)\n{\n\tstruct page *page, *next;\n\n\tlist_for_each_entry_safe(page, next, list, lru) {\n\t\tlist_del(&page->lru);\n\t\tkimage_free_pages(page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore",
          "args": [
            "&krcp->lock",
            "flags"
          ],
          "line": 3458
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "192-195",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_cached_bnode",
          "args": [
            "krcp",
            "bnode"
          ],
          "line": 3457
        },
        "resolved": true,
        "details": {
          "function_name": "put_cached_bnode",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "3240-3251",
          "snippet": "static inline bool\nput_cached_bnode(struct kfree_rcu_cpu *krcp,\n\tstruct kvfree_rcu_bulk_data *bnode)\n{\n\t// Check the limit.\n\tif (krcp->nr_bkv_objs >= rcu_min_cached_objs)\n\t\treturn false;\n\n\tllist_add((struct llist_node *) bnode, &krcp->bkvcache);\n\tWRITE_ONCE(krcp->nr_bkv_objs, krcp->nr_bkv_objs + 1);\n\treturn true;\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int rcu_min_cached_objs = 5;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic int rcu_min_cached_objs = 5;\n\nstatic inline bool\nput_cached_bnode(struct kfree_rcu_cpu *krcp,\n\tstruct kvfree_rcu_bulk_data *bnode)\n{\n\t// Check the limit.\n\tif (krcp->nr_bkv_objs >= rcu_min_cached_objs)\n\t\treturn false;\n\n\tllist_add((struct llist_node *) bnode, &krcp->bkvcache);\n\tWRITE_ONCE(krcp->nr_bkv_objs, krcp->nr_bkv_objs + 1);\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave",
          "args": [
            "&krcp->lock",
            "flags"
          ],
          "line": 3456
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "383-393",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__get_free_page",
          "args": [
            "GFP_KERNEL | __GFP_NORETRY | __GFP_NOMEMALLOC | __GFP_NOWARN"
          ],
          "line": 3453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&krcp->backoff_page_cache_fill"
          ],
          "line": 3448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "work",
            "structkfree_rcu_cpu",
            "page_cache_work.work"
          ],
          "line": 3441
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);\nstatic int rcu_min_cached_objs = 5;\n\nstatic void fill_page_cache_func(struct work_struct *work)\n{\n\tstruct kvfree_rcu_bulk_data *bnode;\n\tstruct kfree_rcu_cpu *krcp =\n\t\tcontainer_of(work, struct kfree_rcu_cpu,\n\t\t\tpage_cache_work.work);\n\tunsigned long flags;\n\tint nr_pages;\n\tbool pushed;\n\tint i;\n\n\tnr_pages = atomic_read(&krcp->backoff_page_cache_fill) ?\n\t\t1 : rcu_min_cached_objs;\n\n\tfor (i = 0; i < nr_pages; i++) {\n\t\tbnode = (struct kvfree_rcu_bulk_data *)\n\t\t\t__get_free_page(GFP_KERNEL | __GFP_NORETRY | __GFP_NOMEMALLOC | __GFP_NOWARN);\n\n\t\tif (bnode) {\n\t\t\traw_spin_lock_irqsave(&krcp->lock, flags);\n\t\t\tpushed = put_cached_bnode(krcp, bnode);\n\t\t\traw_spin_unlock_irqrestore(&krcp->lock, flags);\n\n\t\t\tif (!pushed) {\n\t\t\t\tfree_page((unsigned long) bnode);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tatomic_set(&krcp->work_in_progress, 0);\n\tatomic_set(&krcp->backoff_page_cache_fill, 0);\n}"
  },
  {
    "function_name": "schedule_page_work_fn",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
    "lines": "3427-3435",
    "snippet": "static enum hrtimer_restart\nschedule_page_work_fn(struct hrtimer *t)\n{\n\tstruct kfree_rcu_cpu *krcp =\n\t\tcontainer_of(t, struct kfree_rcu_cpu, hrtimer);\n\n\tqueue_delayed_work(system_highpri_wq, &krcp->page_cache_work, 0);\n\treturn HRTIMER_NORESTART;\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_nocb.h\"",
      "#include \"tree_exp.h\"",
      "#include \"tree_stall.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <linux/kasan.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/panic_notifier.h>",
      "#include <linux/panic.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "queue_delayed_work",
          "args": [
            "system_highpri_wq",
            "&krcp->page_cache_work",
            "0"
          ],
          "line": 3433
        },
        "resolved": true,
        "details": {
          "function_name": "kthread_queue_delayed_work",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
          "lines": "1092-1109",
          "snippet": "bool kthread_queue_delayed_work(struct kthread_worker *worker,\n\t\t\t\tstruct kthread_delayed_work *dwork,\n\t\t\t\tunsigned long delay)\n{\n\tstruct kthread_work *work = &dwork->work;\n\tunsigned long flags;\n\tbool ret = false;\n\n\traw_spin_lock_irqsave(&worker->lock, flags);\n\n\tif (!queuing_blocked(worker, work)) {\n\t\t__kthread_queue_delayed_work(worker, dwork, delay);\n\t\tret = true;\n\t}\n\n\traw_spin_unlock_irqrestore(&worker->lock, flags);\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/numa.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mm.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nbool kthread_queue_delayed_work(struct kthread_worker *worker,\n\t\t\t\tstruct kthread_delayed_work *dwork,\n\t\t\t\tunsigned long delay)\n{\n\tstruct kthread_work *work = &dwork->work;\n\tunsigned long flags;\n\tbool ret = false;\n\n\traw_spin_lock_irqsave(&worker->lock, flags);\n\n\tif (!queuing_blocked(worker, work)) {\n\t\t__kthread_queue_delayed_work(worker, dwork, delay);\n\t\tret = true;\n\t}\n\n\traw_spin_unlock_irqrestore(&worker->lock, flags);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "t",
            "structkfree_rcu_cpu",
            "hrtimer"
          ],
          "line": 3431
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic enum hrtimer_restart\nschedule_page_work_fn(struct hrtimer *t)\n{\n\tstruct kfree_rcu_cpu *krcp =\n\t\tcontainer_of(t, struct kfree_rcu_cpu, hrtimer);\n\n\tqueue_delayed_work(system_highpri_wq, &krcp->page_cache_work, 0);\n\treturn HRTIMER_NORESTART;\n}"
  },
  {
    "function_name": "kfree_rcu_monitor",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
    "lines": "3366-3425",
    "snippet": "static void kfree_rcu_monitor(struct work_struct *work)\n{\n\tstruct kfree_rcu_cpu *krcp = container_of(work,\n\t\tstruct kfree_rcu_cpu, monitor_work.work);\n\tunsigned long flags;\n\tint i, j;\n\n\traw_spin_lock_irqsave(&krcp->lock, flags);\n\n\t// Attempt to start a new batch.\n\tfor (i = 0; i < KFREE_N_BATCHES; i++) {\n\t\tstruct kfree_rcu_cpu_work *krwp = &(krcp->krw_arr[i]);\n\n\t\t// Try to detach bkvhead or head and attach it over any\n\t\t// available corresponding free channel. It can be that\n\t\t// a previous RCU batch is in progress, it means that\n\t\t// immediately to queue another one is not possible so\n\t\t// in that case the monitor work is rearmed.\n\t\tif ((krcp->bkvhead[0] && !krwp->bkvhead_free[0]) ||\n\t\t\t(krcp->bkvhead[1] && !krwp->bkvhead_free[1]) ||\n\t\t\t\t(krcp->head && !krwp->head_free)) {\n\t\t\t// Channel 1 corresponds to the SLAB-pointer bulk path.\n\t\t\t// Channel 2 corresponds to vmalloc-pointer bulk path.\n\t\t\tfor (j = 0; j < FREE_N_CHANNELS; j++) {\n\t\t\t\tif (!krwp->bkvhead_free[j]) {\n\t\t\t\t\tkrwp->bkvhead_free[j] = krcp->bkvhead[j];\n\t\t\t\t\tkrcp->bkvhead[j] = NULL;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Channel 3 corresponds to both SLAB and vmalloc\n\t\t\t// objects queued on the linked list.\n\t\t\tif (!krwp->head_free) {\n\t\t\t\tkrwp->head_free = krcp->head;\n\t\t\t\tkrcp->head = NULL;\n\t\t\t}\n\n\t\t\tWRITE_ONCE(krcp->count, 0);\n\n\t\t\t// One work is per one batch, so there are three\n\t\t\t// \"free channels\", the batch can handle. It can\n\t\t\t// be that the work is in the pending state when\n\t\t\t// channels have been detached following by each\n\t\t\t// other.\n\t\t\tqueue_rcu_work(system_wq, &krwp->rcu_work);\n\t\t}\n\t}\n\n\t// If there is nothing to detach, it means that our job is\n\t// successfully done here. In case of having at least one\n\t// of the channels that is still busy we should rearm the\n\t// work to repeat an attempt. Because previous batches are\n\t// still in progress.\n\tif (!krcp->bkvhead[0] && !krcp->bkvhead[1] && !krcp->head)\n\t\tkrcp->monitor_todo = false;\n\telse\n\t\tschedule_delayed_work(&krcp->monitor_work, KFREE_DRAIN_JIFFIES);\n\n\traw_spin_unlock_irqrestore(&krcp->lock, flags);\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_nocb.h\"",
      "#include \"tree_exp.h\"",
      "#include \"tree_stall.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <linux/kasan.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/panic_notifier.h>",
      "#include <linux/panic.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [
      "#define FREE_N_CHANNELS 2",
      "#define KFREE_N_BATCHES 2",
      "#define KFREE_DRAIN_JIFFIES (HZ / 50)"
    ],
    "globals_used": [
      "static void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore",
          "args": [
            "&krcp->lock",
            "flags"
          ],
          "line": 3424
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "192-195",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "schedule_delayed_work",
          "args": [
            "&krcp->monitor_work",
            "KFREE_DRAIN_JIFFIES"
          ],
          "line": 3422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "queue_rcu_work",
          "args": [
            "system_wq",
            "&krwp->rcu_work"
          ],
          "line": 3410
        },
        "resolved": true,
        "details": {
          "function_name": "queue_rcu_work",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "1785-1796",
          "snippet": "bool queue_rcu_work(struct workqueue_struct *wq, struct rcu_work *rwork)\n{\n\tstruct work_struct *work = &rwork->work;\n\n\tif (!test_and_set_bit(WORK_STRUCT_PENDING_BIT, work_data_bits(work))) {\n\t\trwork->wq = wq;\n\t\tcall_rcu(&rwork->rcu, rcu_work_rcufn);\n\t\treturn true;\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nbool queue_rcu_work(struct workqueue_struct *wq, struct rcu_work *rwork)\n{\n\tstruct work_struct *work = &rwork->work;\n\n\tif (!test_and_set_bit(WORK_STRUCT_PENDING_BIT, work_data_bits(work))) {\n\t\trwork->wq = wq;\n\t\tcall_rcu(&rwork->rcu, rcu_work_rcufn);\n\t\treturn true;\n\t}\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "krcp->count",
            "0"
          ],
          "line": 3403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave",
          "args": [
            "&krcp->lock",
            "flags"
          ],
          "line": 3373
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "383-393",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "work",
            "structkfree_rcu_cpu",
            "monitor_work.work"
          ],
          "line": 3368
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define FREE_N_CHANNELS 2\n#define KFREE_N_BATCHES 2\n#define KFREE_DRAIN_JIFFIES (HZ / 50)\n\nstatic void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);\n\nstatic void kfree_rcu_monitor(struct work_struct *work)\n{\n\tstruct kfree_rcu_cpu *krcp = container_of(work,\n\t\tstruct kfree_rcu_cpu, monitor_work.work);\n\tunsigned long flags;\n\tint i, j;\n\n\traw_spin_lock_irqsave(&krcp->lock, flags);\n\n\t// Attempt to start a new batch.\n\tfor (i = 0; i < KFREE_N_BATCHES; i++) {\n\t\tstruct kfree_rcu_cpu_work *krwp = &(krcp->krw_arr[i]);\n\n\t\t// Try to detach bkvhead or head and attach it over any\n\t\t// available corresponding free channel. It can be that\n\t\t// a previous RCU batch is in progress, it means that\n\t\t// immediately to queue another one is not possible so\n\t\t// in that case the monitor work is rearmed.\n\t\tif ((krcp->bkvhead[0] && !krwp->bkvhead_free[0]) ||\n\t\t\t(krcp->bkvhead[1] && !krwp->bkvhead_free[1]) ||\n\t\t\t\t(krcp->head && !krwp->head_free)) {\n\t\t\t// Channel 1 corresponds to the SLAB-pointer bulk path.\n\t\t\t// Channel 2 corresponds to vmalloc-pointer bulk path.\n\t\t\tfor (j = 0; j < FREE_N_CHANNELS; j++) {\n\t\t\t\tif (!krwp->bkvhead_free[j]) {\n\t\t\t\t\tkrwp->bkvhead_free[j] = krcp->bkvhead[j];\n\t\t\t\t\tkrcp->bkvhead[j] = NULL;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Channel 3 corresponds to both SLAB and vmalloc\n\t\t\t// objects queued on the linked list.\n\t\t\tif (!krwp->head_free) {\n\t\t\t\tkrwp->head_free = krcp->head;\n\t\t\t\tkrcp->head = NULL;\n\t\t\t}\n\n\t\t\tWRITE_ONCE(krcp->count, 0);\n\n\t\t\t// One work is per one batch, so there are three\n\t\t\t// \"free channels\", the batch can handle. It can\n\t\t\t// be that the work is in the pending state when\n\t\t\t// channels have been detached following by each\n\t\t\t// other.\n\t\t\tqueue_rcu_work(system_wq, &krwp->rcu_work);\n\t\t}\n\t}\n\n\t// If there is nothing to detach, it means that our job is\n\t// successfully done here. In case of having at least one\n\t// of the channels that is still busy we should rearm the\n\t// work to repeat an attempt. Because previous batches are\n\t// still in progress.\n\tif (!krcp->bkvhead[0] && !krcp->bkvhead[1] && !krcp->head)\n\t\tkrcp->monitor_todo = false;\n\telse\n\t\tschedule_delayed_work(&krcp->monitor_work, KFREE_DRAIN_JIFFIES);\n\n\traw_spin_unlock_irqrestore(&krcp->lock, flags);\n}"
  },
  {
    "function_name": "kfree_rcu_work",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
    "lines": "3277-3361",
    "snippet": "static void kfree_rcu_work(struct work_struct *work)\n{\n\tunsigned long flags;\n\tstruct kvfree_rcu_bulk_data *bkvhead[FREE_N_CHANNELS], *bnext;\n\tstruct rcu_head *head, *next;\n\tstruct kfree_rcu_cpu *krcp;\n\tstruct kfree_rcu_cpu_work *krwp;\n\tint i, j;\n\n\tkrwp = container_of(to_rcu_work(work),\n\t\t\t    struct kfree_rcu_cpu_work, rcu_work);\n\tkrcp = krwp->krcp;\n\n\traw_spin_lock_irqsave(&krcp->lock, flags);\n\t// Channels 1 and 2.\n\tfor (i = 0; i < FREE_N_CHANNELS; i++) {\n\t\tbkvhead[i] = krwp->bkvhead_free[i];\n\t\tkrwp->bkvhead_free[i] = NULL;\n\t}\n\n\t// Channel 3.\n\thead = krwp->head_free;\n\tkrwp->head_free = NULL;\n\traw_spin_unlock_irqrestore(&krcp->lock, flags);\n\n\t// Handle the first two channels.\n\tfor (i = 0; i < FREE_N_CHANNELS; i++) {\n\t\tfor (; bkvhead[i]; bkvhead[i] = bnext) {\n\t\t\tbnext = bkvhead[i]->next;\n\t\t\tdebug_rcu_bhead_unqueue(bkvhead[i]);\n\n\t\t\trcu_lock_acquire(&rcu_callback_map);\n\t\t\tif (i == 0) { // kmalloc() / kfree().\n\t\t\t\ttrace_rcu_invoke_kfree_bulk_callback(\n\t\t\t\t\trcu_state.name, bkvhead[i]->nr_records,\n\t\t\t\t\tbkvhead[i]->records);\n\n\t\t\t\tkfree_bulk(bkvhead[i]->nr_records,\n\t\t\t\t\tbkvhead[i]->records);\n\t\t\t} else { // vmalloc() / vfree().\n\t\t\t\tfor (j = 0; j < bkvhead[i]->nr_records; j++) {\n\t\t\t\t\ttrace_rcu_invoke_kvfree_callback(\n\t\t\t\t\t\trcu_state.name,\n\t\t\t\t\t\tbkvhead[i]->records[j], 0);\n\n\t\t\t\t\tvfree(bkvhead[i]->records[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t\trcu_lock_release(&rcu_callback_map);\n\n\t\t\traw_spin_lock_irqsave(&krcp->lock, flags);\n\t\t\tif (put_cached_bnode(krcp, bkvhead[i]))\n\t\t\t\tbkvhead[i] = NULL;\n\t\t\traw_spin_unlock_irqrestore(&krcp->lock, flags);\n\n\t\t\tif (bkvhead[i])\n\t\t\t\tfree_page((unsigned long) bkvhead[i]);\n\n\t\t\tcond_resched_tasks_rcu_qs();\n\t\t}\n\t}\n\n\t/*\n\t * This is used when the \"bulk\" path can not be used for the\n\t * double-argument of kvfree_rcu().  This happens when the\n\t * page-cache is empty, which means that objects are instead\n\t * queued on a linked list through their rcu_head structures.\n\t * This list is named \"Channel 3\".\n\t */\n\tfor (; head; head = next) {\n\t\tunsigned long offset = (unsigned long)head->func;\n\t\tvoid *ptr = (void *)head - offset;\n\n\t\tnext = head->next;\n\t\tdebug_rcu_head_unqueue((struct rcu_head *)ptr);\n\t\trcu_lock_acquire(&rcu_callback_map);\n\t\ttrace_rcu_invoke_kvfree_callback(rcu_state.name, head, offset);\n\n\t\tif (!WARN_ON_ONCE(!__is_kvfree_rcu_offset(offset)))\n\t\t\tkvfree(ptr);\n\n\t\trcu_lock_release(&rcu_callback_map);\n\t\tcond_resched_tasks_rcu_qs();\n\t}\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_nocb.h\"",
      "#include \"tree_exp.h\"",
      "#include \"tree_stall.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <linux/kasan.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/panic_notifier.h>",
      "#include <linux/panic.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [
      "#define FREE_N_CHANNELS 2"
    ],
    "globals_used": [
      "static struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};",
      "static void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cond_resched_tasks_rcu_qs",
          "args": [],
          "line": 3359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_lock_release",
          "args": [
            "&rcu_callback_map"
          ],
          "line": 3358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvfree",
          "args": [
            "ptr"
          ],
          "line": 3356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!__is_kvfree_rcu_offset(offset)"
          ],
          "line": 3355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__is_kvfree_rcu_offset",
          "args": [
            "offset"
          ],
          "line": 3355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_rcu_invoke_kvfree_callback",
          "args": [
            "rcu_state.name",
            "head",
            "offset"
          ],
          "line": 3353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_lock_acquire",
          "args": [
            "&rcu_callback_map"
          ],
          "line": 3352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_rcu_head_unqueue",
          "args": [
            "(struct rcu_head *)ptr"
          ],
          "line": 3351
        },
        "resolved": true,
        "details": {
          "function_name": "debug_rcu_head_unqueue",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu.h",
          "lines": "196-198",
          "snippet": "static inline void debug_rcu_head_unqueue(struct rcu_head *head)\n{\n}",
          "includes": [
            "#include <linux/rcu_node_tree.h>",
            "#include <trace/events/rcu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_node_tree.h>\n#include <trace/events/rcu.h>\n\nstatic inline void debug_rcu_head_unqueue(struct rcu_head *head)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "cond_resched_tasks_rcu_qs",
          "args": [],
          "line": 3335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_page",
          "args": [
            "(unsigned long) bkvhead[i]"
          ],
          "line": 3333
        },
        "resolved": true,
        "details": {
          "function_name": "kimage_free_page_list",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kexec_core.c",
          "lines": "341-349",
          "snippet": "void kimage_free_page_list(struct list_head *list)\n{\n\tstruct page *page, *next;\n\n\tlist_for_each_entry_safe(page, next, list, lru) {\n\t\tlist_del(&page->lru);\n\t\tkimage_free_pages(page);\n\t}\n}",
          "includes": [
            "#include \"kexec_internal.h\"",
            "#include <crypto/hash.h>",
            "#include <asm/sections.h>",
            "#include <asm/page.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/objtool.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/compiler.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/console.h>",
            "#include <linux/io.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/cpu.h>",
            "#include <linux/pm.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/freezer.h>",
            "#include <linux/device.h>",
            "#include <linux/suspend.h>",
            "#include <linux/numa.h>",
            "#include <linux/utsname.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/elf.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/ioport.h>",
            "#include <linux/reboot.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/highmem.h>",
            "#include <linux/list.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kexec.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kexec_internal.h\"\n#include <crypto/hash.h>\n#include <asm/sections.h>\n#include <asm/page.h>\n#include <linux/kmsg_dump.h>\n#include <linux/objtool.h>\n#include <linux/hugetlb.h>\n#include <linux/compiler.h>\n#include <linux/syscore_ops.h>\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/console.h>\n#include <linux/io.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/pm.h>\n#include <linux/panic_notifier.h>\n#include <linux/freezer.h>\n#include <linux/device.h>\n#include <linux/suspend.h>\n#include <linux/numa.h>\n#include <linux/utsname.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <linux/hardirq.h>\n#include <linux/ioport.h>\n#include <linux/reboot.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/list.h>\n#include <linux/mutex.h>\n#include <linux/kexec.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n\nvoid kimage_free_page_list(struct list_head *list)\n{\n\tstruct page *page, *next;\n\n\tlist_for_each_entry_safe(page, next, list, lru) {\n\t\tlist_del(&page->lru);\n\t\tkimage_free_pages(page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore",
          "args": [
            "&krcp->lock",
            "flags"
          ],
          "line": 3330
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "192-195",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_cached_bnode",
          "args": [
            "krcp",
            "bkvhead[i]"
          ],
          "line": 3328
        },
        "resolved": true,
        "details": {
          "function_name": "put_cached_bnode",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "3240-3251",
          "snippet": "static inline bool\nput_cached_bnode(struct kfree_rcu_cpu *krcp,\n\tstruct kvfree_rcu_bulk_data *bnode)\n{\n\t// Check the limit.\n\tif (krcp->nr_bkv_objs >= rcu_min_cached_objs)\n\t\treturn false;\n\n\tllist_add((struct llist_node *) bnode, &krcp->bkvcache);\n\tWRITE_ONCE(krcp->nr_bkv_objs, krcp->nr_bkv_objs + 1);\n\treturn true;\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int rcu_min_cached_objs = 5;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic int rcu_min_cached_objs = 5;\n\nstatic inline bool\nput_cached_bnode(struct kfree_rcu_cpu *krcp,\n\tstruct kvfree_rcu_bulk_data *bnode)\n{\n\t// Check the limit.\n\tif (krcp->nr_bkv_objs >= rcu_min_cached_objs)\n\t\treturn false;\n\n\tllist_add((struct llist_node *) bnode, &krcp->bkvcache);\n\tWRITE_ONCE(krcp->nr_bkv_objs, krcp->nr_bkv_objs + 1);\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave",
          "args": [
            "&krcp->lock",
            "flags"
          ],
          "line": 3327
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "383-393",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_lock_release",
          "args": [
            "&rcu_callback_map"
          ],
          "line": 3325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vfree",
          "args": [
            "bkvhead[i]->records[j]"
          ],
          "line": 3322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_rcu_invoke_kvfree_callback",
          "args": [
            "rcu_state.name",
            "bkvhead[i]->records[j]",
            "0"
          ],
          "line": 3318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree_bulk",
          "args": [
            "bkvhead[i]->nr_records",
            "bkvhead[i]->records"
          ],
          "line": 3314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_rcu_invoke_kfree_bulk_callback",
          "args": [
            "rcu_state.name",
            "bkvhead[i]->nr_records",
            "bkvhead[i]->records"
          ],
          "line": 3310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_lock_acquire",
          "args": [
            "&rcu_callback_map"
          ],
          "line": 3308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_rcu_bhead_unqueue",
          "args": [
            "bkvhead[i]"
          ],
          "line": 3306
        },
        "resolved": true,
        "details": {
          "function_name": "debug_rcu_bhead_unqueue",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "3200-3209",
          "snippet": "static __always_inline void\ndebug_rcu_bhead_unqueue(struct kvfree_rcu_bulk_data *bhead)\n{\n#ifdef CONFIG_DEBUG_OBJECTS_RCU_HEAD\n\tint i;\n\n\tfor (i = 0; i < bhead->nr_records; i++)\n\t\tdebug_rcu_head_unqueue((struct rcu_head *)(bhead->records[i]));\n#endif\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic __always_inline void\ndebug_rcu_bhead_unqueue(struct kvfree_rcu_bulk_data *bhead)\n{\n#ifdef CONFIG_DEBUG_OBJECTS_RCU_HEAD\n\tint i;\n\n\tfor (i = 0; i < bhead->nr_records; i++)\n\t\tdebug_rcu_head_unqueue((struct rcu_head *)(bhead->records[i]));\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "to_rcu_work(work)",
            "structkfree_rcu_cpu_work",
            "rcu_work"
          ],
          "line": 3286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "to_rcu_work",
          "args": [
            "work"
          ],
          "line": 3286
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define FREE_N_CHANNELS 2\n\nstatic struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\nstatic void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);\n\nstatic void kfree_rcu_work(struct work_struct *work)\n{\n\tunsigned long flags;\n\tstruct kvfree_rcu_bulk_data *bkvhead[FREE_N_CHANNELS], *bnext;\n\tstruct rcu_head *head, *next;\n\tstruct kfree_rcu_cpu *krcp;\n\tstruct kfree_rcu_cpu_work *krwp;\n\tint i, j;\n\n\tkrwp = container_of(to_rcu_work(work),\n\t\t\t    struct kfree_rcu_cpu_work, rcu_work);\n\tkrcp = krwp->krcp;\n\n\traw_spin_lock_irqsave(&krcp->lock, flags);\n\t// Channels 1 and 2.\n\tfor (i = 0; i < FREE_N_CHANNELS; i++) {\n\t\tbkvhead[i] = krwp->bkvhead_free[i];\n\t\tkrwp->bkvhead_free[i] = NULL;\n\t}\n\n\t// Channel 3.\n\thead = krwp->head_free;\n\tkrwp->head_free = NULL;\n\traw_spin_unlock_irqrestore(&krcp->lock, flags);\n\n\t// Handle the first two channels.\n\tfor (i = 0; i < FREE_N_CHANNELS; i++) {\n\t\tfor (; bkvhead[i]; bkvhead[i] = bnext) {\n\t\t\tbnext = bkvhead[i]->next;\n\t\t\tdebug_rcu_bhead_unqueue(bkvhead[i]);\n\n\t\t\trcu_lock_acquire(&rcu_callback_map);\n\t\t\tif (i == 0) { // kmalloc() / kfree().\n\t\t\t\ttrace_rcu_invoke_kfree_bulk_callback(\n\t\t\t\t\trcu_state.name, bkvhead[i]->nr_records,\n\t\t\t\t\tbkvhead[i]->records);\n\n\t\t\t\tkfree_bulk(bkvhead[i]->nr_records,\n\t\t\t\t\tbkvhead[i]->records);\n\t\t\t} else { // vmalloc() / vfree().\n\t\t\t\tfor (j = 0; j < bkvhead[i]->nr_records; j++) {\n\t\t\t\t\ttrace_rcu_invoke_kvfree_callback(\n\t\t\t\t\t\trcu_state.name,\n\t\t\t\t\t\tbkvhead[i]->records[j], 0);\n\n\t\t\t\t\tvfree(bkvhead[i]->records[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t\trcu_lock_release(&rcu_callback_map);\n\n\t\t\traw_spin_lock_irqsave(&krcp->lock, flags);\n\t\t\tif (put_cached_bnode(krcp, bkvhead[i]))\n\t\t\t\tbkvhead[i] = NULL;\n\t\t\traw_spin_unlock_irqrestore(&krcp->lock, flags);\n\n\t\t\tif (bkvhead[i])\n\t\t\t\tfree_page((unsigned long) bkvhead[i]);\n\n\t\t\tcond_resched_tasks_rcu_qs();\n\t\t}\n\t}\n\n\t/*\n\t * This is used when the \"bulk\" path can not be used for the\n\t * double-argument of kvfree_rcu().  This happens when the\n\t * page-cache is empty, which means that objects are instead\n\t * queued on a linked list through their rcu_head structures.\n\t * This list is named \"Channel 3\".\n\t */\n\tfor (; head; head = next) {\n\t\tunsigned long offset = (unsigned long)head->func;\n\t\tvoid *ptr = (void *)head - offset;\n\n\t\tnext = head->next;\n\t\tdebug_rcu_head_unqueue((struct rcu_head *)ptr);\n\t\trcu_lock_acquire(&rcu_callback_map);\n\t\ttrace_rcu_invoke_kvfree_callback(rcu_state.name, head, offset);\n\n\t\tif (!WARN_ON_ONCE(!__is_kvfree_rcu_offset(offset)))\n\t\t\tkvfree(ptr);\n\n\t\trcu_lock_release(&rcu_callback_map);\n\t\tcond_resched_tasks_rcu_qs();\n\t}\n}"
  },
  {
    "function_name": "drain_page_cache",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
    "lines": "3253-3271",
    "snippet": "static int\ndrain_page_cache(struct kfree_rcu_cpu *krcp)\n{\n\tunsigned long flags;\n\tstruct llist_node *page_list, *pos, *n;\n\tint freed = 0;\n\n\traw_spin_lock_irqsave(&krcp->lock, flags);\n\tpage_list = llist_del_all(&krcp->bkvcache);\n\tWRITE_ONCE(krcp->nr_bkv_objs, 0);\n\traw_spin_unlock_irqrestore(&krcp->lock, flags);\n\n\tllist_for_each_safe(pos, n, page_list) {\n\t\tfree_page((unsigned long)pos);\n\t\tfreed++;\n\t}\n\n\treturn freed;\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_nocb.h\"",
      "#include \"tree_exp.h\"",
      "#include \"tree_stall.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <linux/kasan.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/panic_notifier.h>",
      "#include <linux/panic.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_page",
          "args": [
            "(unsigned long)pos"
          ],
          "line": 3266
        },
        "resolved": true,
        "details": {
          "function_name": "kimage_free_page_list",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kexec_core.c",
          "lines": "341-349",
          "snippet": "void kimage_free_page_list(struct list_head *list)\n{\n\tstruct page *page, *next;\n\n\tlist_for_each_entry_safe(page, next, list, lru) {\n\t\tlist_del(&page->lru);\n\t\tkimage_free_pages(page);\n\t}\n}",
          "includes": [
            "#include \"kexec_internal.h\"",
            "#include <crypto/hash.h>",
            "#include <asm/sections.h>",
            "#include <asm/page.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/objtool.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/compiler.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/console.h>",
            "#include <linux/io.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/cpu.h>",
            "#include <linux/pm.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/freezer.h>",
            "#include <linux/device.h>",
            "#include <linux/suspend.h>",
            "#include <linux/numa.h>",
            "#include <linux/utsname.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/elf.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/ioport.h>",
            "#include <linux/reboot.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/highmem.h>",
            "#include <linux/list.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kexec.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kexec_internal.h\"\n#include <crypto/hash.h>\n#include <asm/sections.h>\n#include <asm/page.h>\n#include <linux/kmsg_dump.h>\n#include <linux/objtool.h>\n#include <linux/hugetlb.h>\n#include <linux/compiler.h>\n#include <linux/syscore_ops.h>\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/console.h>\n#include <linux/io.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/pm.h>\n#include <linux/panic_notifier.h>\n#include <linux/freezer.h>\n#include <linux/device.h>\n#include <linux/suspend.h>\n#include <linux/numa.h>\n#include <linux/utsname.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <linux/hardirq.h>\n#include <linux/ioport.h>\n#include <linux/reboot.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/list.h>\n#include <linux/mutex.h>\n#include <linux/kexec.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n\nvoid kimage_free_page_list(struct list_head *list)\n{\n\tstruct page *page, *next;\n\n\tlist_for_each_entry_safe(page, next, list, lru) {\n\t\tlist_del(&page->lru);\n\t\tkimage_free_pages(page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "llist_for_each_safe",
          "args": [
            "pos",
            "n",
            "page_list"
          ],
          "line": 3265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore",
          "args": [
            "&krcp->lock",
            "flags"
          ],
          "line": 3263
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "192-195",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "krcp->nr_bkv_objs",
            "0"
          ],
          "line": 3262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "llist_del_all",
          "args": [
            "&krcp->bkvcache"
          ],
          "line": 3261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave",
          "args": [
            "&krcp->lock",
            "flags"
          ],
          "line": 3260
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "383-393",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);\n\nstatic int\ndrain_page_cache(struct kfree_rcu_cpu *krcp)\n{\n\tunsigned long flags;\n\tstruct llist_node *page_list, *pos, *n;\n\tint freed = 0;\n\n\traw_spin_lock_irqsave(&krcp->lock, flags);\n\tpage_list = llist_del_all(&krcp->bkvcache);\n\tWRITE_ONCE(krcp->nr_bkv_objs, 0);\n\traw_spin_unlock_irqrestore(&krcp->lock, flags);\n\n\tllist_for_each_safe(pos, n, page_list) {\n\t\tfree_page((unsigned long)pos);\n\t\tfreed++;\n\t}\n\n\treturn freed;\n}"
  },
  {
    "function_name": "put_cached_bnode",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
    "lines": "3240-3251",
    "snippet": "static inline bool\nput_cached_bnode(struct kfree_rcu_cpu *krcp,\n\tstruct kvfree_rcu_bulk_data *bnode)\n{\n\t// Check the limit.\n\tif (krcp->nr_bkv_objs >= rcu_min_cached_objs)\n\t\treturn false;\n\n\tllist_add((struct llist_node *) bnode, &krcp->bkvcache);\n\tWRITE_ONCE(krcp->nr_bkv_objs, krcp->nr_bkv_objs + 1);\n\treturn true;\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_nocb.h\"",
      "#include \"tree_exp.h\"",
      "#include \"tree_stall.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <linux/kasan.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/panic_notifier.h>",
      "#include <linux/panic.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int rcu_min_cached_objs = 5;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "krcp->nr_bkv_objs",
            "krcp->nr_bkv_objs + 1"
          ],
          "line": 3249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "llist_add",
          "args": [
            "(struct llist_node *) bnode",
            "&krcp->bkvcache"
          ],
          "line": 3248
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic int rcu_min_cached_objs = 5;\n\nstatic inline bool\nput_cached_bnode(struct kfree_rcu_cpu *krcp,\n\tstruct kvfree_rcu_bulk_data *bnode)\n{\n\t// Check the limit.\n\tif (krcp->nr_bkv_objs >= rcu_min_cached_objs)\n\t\treturn false;\n\n\tllist_add((struct llist_node *) bnode, &krcp->bkvcache);\n\tWRITE_ONCE(krcp->nr_bkv_objs, krcp->nr_bkv_objs + 1);\n\treturn true;\n}"
  },
  {
    "function_name": "get_cached_bnode",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
    "lines": "3229-3238",
    "snippet": "static inline struct kvfree_rcu_bulk_data *\nget_cached_bnode(struct kfree_rcu_cpu *krcp)\n{\n\tif (!krcp->nr_bkv_objs)\n\t\treturn NULL;\n\n\tWRITE_ONCE(krcp->nr_bkv_objs, krcp->nr_bkv_objs - 1);\n\treturn (struct kvfree_rcu_bulk_data *)\n\t\tllist_del_first(&krcp->bkvcache);\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_nocb.h\"",
      "#include \"tree_exp.h\"",
      "#include \"tree_stall.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <linux/kasan.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/panic_notifier.h>",
      "#include <linux/panic.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "llist_del_first",
          "args": [
            "&krcp->bkvcache"
          ],
          "line": 3237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "krcp->nr_bkv_objs",
            "krcp->nr_bkv_objs - 1"
          ],
          "line": 3235
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic inline struct kvfree_rcu_bulk_data *\nget_cached_bnode(struct kfree_rcu_cpu *krcp)\n{\n\tif (!krcp->nr_bkv_objs)\n\t\treturn NULL;\n\n\tWRITE_ONCE(krcp->nr_bkv_objs, krcp->nr_bkv_objs - 1);\n\treturn (struct kvfree_rcu_bulk_data *)\n\t\tllist_del_first(&krcp->bkvcache);\n}"
  },
  {
    "function_name": "krc_this_cpu_unlock",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
    "lines": "3223-3227",
    "snippet": "static inline void\nkrc_this_cpu_unlock(struct kfree_rcu_cpu *krcp, unsigned long flags)\n{\n\traw_spin_unlock_irqrestore(&krcp->lock, flags);\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_nocb.h\"",
      "#include \"tree_exp.h\"",
      "#include \"tree_stall.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <linux/kasan.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/panic_notifier.h>",
      "#include <linux/panic.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore",
          "args": [
            "&krcp->lock",
            "flags"
          ],
          "line": 3226
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "192-195",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);\n\nstatic inline void\nkrc_this_cpu_unlock(struct kfree_rcu_cpu *krcp, unsigned long flags)\n{\n\traw_spin_unlock_irqrestore(&krcp->lock, flags);\n}"
  },
  {
    "function_name": "krc_this_cpu_lock",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
    "lines": "3211-3221",
    "snippet": "static inline struct kfree_rcu_cpu *\nkrc_this_cpu_lock(unsigned long *flags)\n{\n\tstruct kfree_rcu_cpu *krcp;\n\n\tlocal_irq_save(*flags);\t// For safely calling this_cpu_ptr().\n\tkrcp = this_cpu_ptr(&krc);\n\traw_spin_lock(&krcp->lock);\n\n\treturn krcp;\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_nocb.h\"",
      "#include \"tree_exp.h\"",
      "#include \"tree_stall.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <linux/kasan.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/panic_notifier.h>",
      "#include <linux/panic.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);",
      "static DEFINE_PER_CPU(struct kfree_rcu_cpu, krc) = {\n\t.lock = __RAW_SPIN_LOCK_UNLOCKED(krc.lock),\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_lock",
          "args": [
            "&krcp->lock"
          ],
          "line": 3218
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_bh",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "176-179",
          "snippet": "void __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&krc"
          ],
          "line": 3217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_save",
          "args": [
            "*flags"
          ],
          "line": 3216
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);\nstatic DEFINE_PER_CPU(struct kfree_rcu_cpu, krc) = {\n\t.lock = __RAW_SPIN_LOCK_UNLOCKED(krc.lock),\n};\n\nstatic inline struct kfree_rcu_cpu *\nkrc_this_cpu_lock(unsigned long *flags)\n{\n\tstruct kfree_rcu_cpu *krcp;\n\n\tlocal_irq_save(*flags);\t// For safely calling this_cpu_ptr().\n\tkrcp = this_cpu_ptr(&krc);\n\traw_spin_lock(&krcp->lock);\n\n\treturn krcp;\n}"
  },
  {
    "function_name": "debug_rcu_bhead_unqueue",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
    "lines": "3200-3209",
    "snippet": "static __always_inline void\ndebug_rcu_bhead_unqueue(struct kvfree_rcu_bulk_data *bhead)\n{\n#ifdef CONFIG_DEBUG_OBJECTS_RCU_HEAD\n\tint i;\n\n\tfor (i = 0; i < bhead->nr_records; i++)\n\t\tdebug_rcu_head_unqueue((struct rcu_head *)(bhead->records[i]));\n#endif\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_nocb.h\"",
      "#include \"tree_exp.h\"",
      "#include \"tree_stall.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <linux/kasan.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/panic_notifier.h>",
      "#include <linux/panic.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "debug_rcu_head_unqueue",
          "args": [
            "(struct rcu_head *)(bhead->records[i])"
          ],
          "line": 3207
        },
        "resolved": true,
        "details": {
          "function_name": "debug_rcu_head_unqueue",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu.h",
          "lines": "196-198",
          "snippet": "static inline void debug_rcu_head_unqueue(struct rcu_head *head)\n{\n}",
          "includes": [
            "#include <linux/rcu_node_tree.h>",
            "#include <trace/events/rcu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_node_tree.h>\n#include <trace/events/rcu.h>\n\nstatic inline void debug_rcu_head_unqueue(struct rcu_head *head)\n{\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic __always_inline void\ndebug_rcu_bhead_unqueue(struct kvfree_rcu_bulk_data *bhead)\n{\n#ifdef CONFIG_DEBUG_OBJECTS_RCU_HEAD\n\tint i;\n\n\tfor (i = 0; i < bhead->nr_records; i++)\n\t\tdebug_rcu_head_unqueue((struct rcu_head *)(bhead->records[i]));\n#endif\n}"
  },
  {
    "function_name": "call_rcu",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
    "lines": "3104-3107",
    "snippet": "void call_rcu(struct rcu_head *head, rcu_callback_t func)\n{\n\t__call_rcu(head, func);\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_nocb.h\"",
      "#include \"tree_exp.h\"",
      "#include \"tree_stall.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <linux/kasan.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/panic_notifier.h>",
      "#include <linux/panic.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__call_rcu",
          "args": [
            "head",
            "func"
          ],
          "line": 3106
        },
        "resolved": true,
        "details": {
          "function_name": "__call_rcu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "2999-3062",
          "snippet": "static void\n__call_rcu(struct rcu_head *head, rcu_callback_t func)\n{\n\tstatic atomic_t doublefrees;\n\tunsigned long flags;\n\tstruct rcu_data *rdp;\n\tbool was_alldone;\n\n\t/* Misaligned rcu_head! */\n\tWARN_ON_ONCE((unsigned long)head & (sizeof(void *) - 1));\n\n\tif (debug_rcu_head_queue(head)) {\n\t\t/*\n\t\t * Probable double call_rcu(), so leak the callback.\n\t\t * Use rcu:rcu_callback trace event to find the previous\n\t\t * time callback was passed to __call_rcu().\n\t\t */\n\t\tif (atomic_inc_return(&doublefrees) < 4) {\n\t\t\tpr_err(\"%s(): Double-freed CB %p->%pS()!!!  \", __func__, head, head->func);\n\t\t\tmem_dump_obj(head);\n\t\t}\n\t\tWRITE_ONCE(head->func, rcu_leak_callback);\n\t\treturn;\n\t}\n\thead->func = func;\n\thead->next = NULL;\n\tlocal_irq_save(flags);\n\tkasan_record_aux_stack_noalloc(head);\n\trdp = this_cpu_ptr(&rcu_data);\n\n\t/* Add the callback to our list. */\n\tif (unlikely(!rcu_segcblist_is_enabled(&rdp->cblist))) {\n\t\t// This can trigger due to call_rcu() from offline CPU:\n\t\tWARN_ON_ONCE(rcu_scheduler_active != RCU_SCHEDULER_INACTIVE);\n\t\tWARN_ON_ONCE(!rcu_is_watching());\n\t\t// Very early boot, before rcu_init().  Initialize if needed\n\t\t// and then drop through to queue the callback.\n\t\tif (rcu_segcblist_empty(&rdp->cblist))\n\t\t\trcu_segcblist_init(&rdp->cblist);\n\t}\n\n\tcheck_cb_ovld(rdp);\n\tif (rcu_nocb_try_bypass(rdp, head, &was_alldone, flags))\n\t\treturn; // Enqueued onto ->nocb_bypass, so just leave.\n\t// If no-CBs CPU gets here, rcu_nocb_try_bypass() acquired ->nocb_lock.\n\trcu_segcblist_enqueue(&rdp->cblist, head);\n\tif (__is_kvfree_rcu_offset((unsigned long)func))\n\t\ttrace_rcu_kvfree_callback(rcu_state.name, head,\n\t\t\t\t\t (unsigned long)func,\n\t\t\t\t\t rcu_segcblist_n_cbs(&rdp->cblist));\n\telse\n\t\ttrace_rcu_callback(rcu_state.name, head,\n\t\t\t\t   rcu_segcblist_n_cbs(&rdp->cblist));\n\n\ttrace_rcu_segcb_stats(&rdp->cblist, TPS(\"SegCBQueued\"));\n\n\t/* Go handle any RCU core processing required. */\n\tif (unlikely(rcu_rdp_is_offloaded(rdp))) {\n\t\t__call_rcu_nocb_wake(rdp, was_alldone, flags); /* unlocks */\n\t} else {\n\t\t__call_rcu_core(rdp, head, flags);\n\t\tlocal_irq_restore(flags);\n\t}\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};",
            "static struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};",
            "int rcu_scheduler_active",
            "static void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);",
            "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
            "static bool rcu_rdp_is_offloaded(struct rcu_data *rdp);",
            "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};\nstatic struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\nint rcu_scheduler_active;\nstatic void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic bool rcu_rdp_is_offloaded(struct rcu_data *rdp);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nstatic void\n__call_rcu(struct rcu_head *head, rcu_callback_t func)\n{\n\tstatic atomic_t doublefrees;\n\tunsigned long flags;\n\tstruct rcu_data *rdp;\n\tbool was_alldone;\n\n\t/* Misaligned rcu_head! */\n\tWARN_ON_ONCE((unsigned long)head & (sizeof(void *) - 1));\n\n\tif (debug_rcu_head_queue(head)) {\n\t\t/*\n\t\t * Probable double call_rcu(), so leak the callback.\n\t\t * Use rcu:rcu_callback trace event to find the previous\n\t\t * time callback was passed to __call_rcu().\n\t\t */\n\t\tif (atomic_inc_return(&doublefrees) < 4) {\n\t\t\tpr_err(\"%s(): Double-freed CB %p->%pS()!!!  \", __func__, head, head->func);\n\t\t\tmem_dump_obj(head);\n\t\t}\n\t\tWRITE_ONCE(head->func, rcu_leak_callback);\n\t\treturn;\n\t}\n\thead->func = func;\n\thead->next = NULL;\n\tlocal_irq_save(flags);\n\tkasan_record_aux_stack_noalloc(head);\n\trdp = this_cpu_ptr(&rcu_data);\n\n\t/* Add the callback to our list. */\n\tif (unlikely(!rcu_segcblist_is_enabled(&rdp->cblist))) {\n\t\t// This can trigger due to call_rcu() from offline CPU:\n\t\tWARN_ON_ONCE(rcu_scheduler_active != RCU_SCHEDULER_INACTIVE);\n\t\tWARN_ON_ONCE(!rcu_is_watching());\n\t\t// Very early boot, before rcu_init().  Initialize if needed\n\t\t// and then drop through to queue the callback.\n\t\tif (rcu_segcblist_empty(&rdp->cblist))\n\t\t\trcu_segcblist_init(&rdp->cblist);\n\t}\n\n\tcheck_cb_ovld(rdp);\n\tif (rcu_nocb_try_bypass(rdp, head, &was_alldone, flags))\n\t\treturn; // Enqueued onto ->nocb_bypass, so just leave.\n\t// If no-CBs CPU gets here, rcu_nocb_try_bypass() acquired ->nocb_lock.\n\trcu_segcblist_enqueue(&rdp->cblist, head);\n\tif (__is_kvfree_rcu_offset((unsigned long)func))\n\t\ttrace_rcu_kvfree_callback(rcu_state.name, head,\n\t\t\t\t\t (unsigned long)func,\n\t\t\t\t\t rcu_segcblist_n_cbs(&rdp->cblist));\n\telse\n\t\ttrace_rcu_callback(rcu_state.name, head,\n\t\t\t\t   rcu_segcblist_n_cbs(&rdp->cblist));\n\n\ttrace_rcu_segcb_stats(&rdp->cblist, TPS(\"SegCBQueued\"));\n\n\t/* Go handle any RCU core processing required. */\n\tif (unlikely(rcu_rdp_is_offloaded(rdp))) {\n\t\t__call_rcu_nocb_wake(rdp, was_alldone, flags); /* unlocks */\n\t} else {\n\t\t__call_rcu_core(rdp, head, flags);\n\t\tlocal_irq_restore(flags);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nvoid call_rcu(struct rcu_head *head, rcu_callback_t func)\n{\n\t__call_rcu(head, func);\n}"
  },
  {
    "function_name": "__call_rcu",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
    "lines": "2999-3062",
    "snippet": "static void\n__call_rcu(struct rcu_head *head, rcu_callback_t func)\n{\n\tstatic atomic_t doublefrees;\n\tunsigned long flags;\n\tstruct rcu_data *rdp;\n\tbool was_alldone;\n\n\t/* Misaligned rcu_head! */\n\tWARN_ON_ONCE((unsigned long)head & (sizeof(void *) - 1));\n\n\tif (debug_rcu_head_queue(head)) {\n\t\t/*\n\t\t * Probable double call_rcu(), so leak the callback.\n\t\t * Use rcu:rcu_callback trace event to find the previous\n\t\t * time callback was passed to __call_rcu().\n\t\t */\n\t\tif (atomic_inc_return(&doublefrees) < 4) {\n\t\t\tpr_err(\"%s(): Double-freed CB %p->%pS()!!!  \", __func__, head, head->func);\n\t\t\tmem_dump_obj(head);\n\t\t}\n\t\tWRITE_ONCE(head->func, rcu_leak_callback);\n\t\treturn;\n\t}\n\thead->func = func;\n\thead->next = NULL;\n\tlocal_irq_save(flags);\n\tkasan_record_aux_stack_noalloc(head);\n\trdp = this_cpu_ptr(&rcu_data);\n\n\t/* Add the callback to our list. */\n\tif (unlikely(!rcu_segcblist_is_enabled(&rdp->cblist))) {\n\t\t// This can trigger due to call_rcu() from offline CPU:\n\t\tWARN_ON_ONCE(rcu_scheduler_active != RCU_SCHEDULER_INACTIVE);\n\t\tWARN_ON_ONCE(!rcu_is_watching());\n\t\t// Very early boot, before rcu_init().  Initialize if needed\n\t\t// and then drop through to queue the callback.\n\t\tif (rcu_segcblist_empty(&rdp->cblist))\n\t\t\trcu_segcblist_init(&rdp->cblist);\n\t}\n\n\tcheck_cb_ovld(rdp);\n\tif (rcu_nocb_try_bypass(rdp, head, &was_alldone, flags))\n\t\treturn; // Enqueued onto ->nocb_bypass, so just leave.\n\t// If no-CBs CPU gets here, rcu_nocb_try_bypass() acquired ->nocb_lock.\n\trcu_segcblist_enqueue(&rdp->cblist, head);\n\tif (__is_kvfree_rcu_offset((unsigned long)func))\n\t\ttrace_rcu_kvfree_callback(rcu_state.name, head,\n\t\t\t\t\t (unsigned long)func,\n\t\t\t\t\t rcu_segcblist_n_cbs(&rdp->cblist));\n\telse\n\t\ttrace_rcu_callback(rcu_state.name, head,\n\t\t\t\t   rcu_segcblist_n_cbs(&rdp->cblist));\n\n\ttrace_rcu_segcb_stats(&rdp->cblist, TPS(\"SegCBQueued\"));\n\n\t/* Go handle any RCU core processing required. */\n\tif (unlikely(rcu_rdp_is_offloaded(rdp))) {\n\t\t__call_rcu_nocb_wake(rdp, was_alldone, flags); /* unlocks */\n\t} else {\n\t\t__call_rcu_core(rdp, head, flags);\n\t\tlocal_irq_restore(flags);\n\t}\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_nocb.h\"",
      "#include \"tree_exp.h\"",
      "#include \"tree_stall.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <linux/kasan.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/panic_notifier.h>",
      "#include <linux/panic.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};",
      "static struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};",
      "int rcu_scheduler_active",
      "static void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);",
      "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
      "static bool rcu_rdp_is_offloaded(struct rcu_data *rdp);",
      "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 3060
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__call_rcu_core",
          "args": [
            "rdp",
            "head",
            "flags"
          ],
          "line": 3059
        },
        "resolved": true,
        "details": {
          "function_name": "__call_rcu_core",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "2907-2947",
          "snippet": "static void __call_rcu_core(struct rcu_data *rdp, struct rcu_head *head,\n\t\t\t    unsigned long flags)\n{\n\t/*\n\t * If called from an extended quiescent state, invoke the RCU\n\t * core in order to force a re-evaluation of RCU's idleness.\n\t */\n\tif (!rcu_is_watching())\n\t\tinvoke_rcu_core();\n\n\t/* If interrupts were disabled or CPU offline, don't invoke RCU core. */\n\tif (irqs_disabled_flags(flags) || cpu_is_offline(smp_processor_id()))\n\t\treturn;\n\n\t/*\n\t * Force the grace period if too many callbacks or too long waiting.\n\t * Enforce hysteresis, and don't invoke rcu_force_quiescent_state()\n\t * if some other CPU has recently done so.  Also, don't bother\n\t * invoking rcu_force_quiescent_state() if the newly enqueued callback\n\t * is the only one waiting for a grace period to complete.\n\t */\n\tif (unlikely(rcu_segcblist_n_cbs(&rdp->cblist) >\n\t\t     rdp->qlen_last_fqs_check + qhimark)) {\n\n\t\t/* Are we ignoring a completed grace period? */\n\t\tnote_gp_changes(rdp);\n\n\t\t/* Start a new grace period if one not already started. */\n\t\tif (!rcu_gp_in_progress()) {\n\t\t\trcu_accelerate_cbs_unlocked(rdp->mynode, rdp);\n\t\t} else {\n\t\t\t/* Give the grace period a kick. */\n\t\t\trdp->blimit = DEFAULT_MAX_RCU_BLIMIT;\n\t\t\tif (READ_ONCE(rcu_state.n_force_qs) == rdp->n_force_qs_snap &&\n\t\t\t    rcu_segcblist_first_pend_cb(&rdp->cblist) != head)\n\t\t\t\trcu_force_quiescent_state();\n\t\t\trdp->n_force_qs_snap = READ_ONCE(rcu_state.n_force_qs);\n\t\t\trdp->qlen_last_fqs_check = rcu_segcblist_n_cbs(&rdp->cblist);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define DEFAULT_MAX_RCU_BLIMIT 10000 // ... even during callback flood."
          ],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};",
            "static struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};",
            "static void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);",
            "static void invoke_rcu_core(void);",
            "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
            "static bool rcu_rdp_is_offloaded(struct rcu_data *rdp);",
            "static long blimit = DEFAULT_RCU_BLIMIT;",
            "static long qhimark = DEFAULT_RCU_QHIMARK;",
            "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define DEFAULT_MAX_RCU_BLIMIT 10000 // ... even during callback flood.\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};\nstatic struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\nstatic void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);\nstatic void invoke_rcu_core(void);\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic bool rcu_rdp_is_offloaded(struct rcu_data *rdp);\nstatic long blimit = DEFAULT_RCU_BLIMIT;\nstatic long qhimark = DEFAULT_RCU_QHIMARK;\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nstatic void __call_rcu_core(struct rcu_data *rdp, struct rcu_head *head,\n\t\t\t    unsigned long flags)\n{\n\t/*\n\t * If called from an extended quiescent state, invoke the RCU\n\t * core in order to force a re-evaluation of RCU's idleness.\n\t */\n\tif (!rcu_is_watching())\n\t\tinvoke_rcu_core();\n\n\t/* If interrupts were disabled or CPU offline, don't invoke RCU core. */\n\tif (irqs_disabled_flags(flags) || cpu_is_offline(smp_processor_id()))\n\t\treturn;\n\n\t/*\n\t * Force the grace period if too many callbacks or too long waiting.\n\t * Enforce hysteresis, and don't invoke rcu_force_quiescent_state()\n\t * if some other CPU has recently done so.  Also, don't bother\n\t * invoking rcu_force_quiescent_state() if the newly enqueued callback\n\t * is the only one waiting for a grace period to complete.\n\t */\n\tif (unlikely(rcu_segcblist_n_cbs(&rdp->cblist) >\n\t\t     rdp->qlen_last_fqs_check + qhimark)) {\n\n\t\t/* Are we ignoring a completed grace period? */\n\t\tnote_gp_changes(rdp);\n\n\t\t/* Start a new grace period if one not already started. */\n\t\tif (!rcu_gp_in_progress()) {\n\t\t\trcu_accelerate_cbs_unlocked(rdp->mynode, rdp);\n\t\t} else {\n\t\t\t/* Give the grace period a kick. */\n\t\t\trdp->blimit = DEFAULT_MAX_RCU_BLIMIT;\n\t\t\tif (READ_ONCE(rcu_state.n_force_qs) == rdp->n_force_qs_snap &&\n\t\t\t    rcu_segcblist_first_pend_cb(&rdp->cblist) != head)\n\t\t\t\trcu_force_quiescent_state();\n\t\t\trdp->n_force_qs_snap = READ_ONCE(rcu_state.n_force_qs);\n\t\t\trdp->qlen_last_fqs_check = rcu_segcblist_n_cbs(&rdp->cblist);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "__call_rcu_nocb_wake",
          "args": [
            "rdp",
            "was_alldone",
            "flags"
          ],
          "line": 3057
        },
        "resolved": true,
        "details": {
          "function_name": "__call_rcu_nocb_wake",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_nocb.h",
          "lines": "1516-1520",
          "snippet": "static void __call_rcu_nocb_wake(struct rcu_data *rdp, bool was_empty,\n\t\t\t\t unsigned long flags)\n{\n\tWARN_ON_ONCE(1);  /* Should be dead code! */\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static void __call_rcu_nocb_wake(struct rcu_data *rdp, bool was_empty,\n\t\t\t\t unsigned long flags)\n{\n\tWARN_ON_ONCE(1);  /* Should be dead code! */\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "rcu_rdp_is_offloaded(rdp)"
          ],
          "line": 3056
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_rdp_is_offloaded",
          "args": [
            "rdp"
          ],
          "line": 3056
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_rdp_is_offloaded",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "16-38",
          "snippet": "static bool rcu_rdp_is_offloaded(struct rcu_data *rdp)\n{\n\t/*\n\t * In order to read the offloaded state of an rdp in a safe\n\t * and stable way and prevent from its value to be changed\n\t * under us, we must either hold the barrier mutex, the cpu\n\t * hotplug lock (read or write) or the nocb lock. Local\n\t * non-preemptible reads are also safe. NOCB kthreads and\n\t * timers have their own means of synchronization against the\n\t * offloaded state updaters.\n\t */\n\tRCU_LOCKDEP_WARN(\n\t\t!(lockdep_is_held(&rcu_state.barrier_mutex) ||\n\t\t  (IS_ENABLED(CONFIG_HOTPLUG_CPU) && lockdep_is_cpus_held()) ||\n\t\t  rcu_lockdep_is_held_nocb(rdp) ||\n\t\t  (rdp == this_cpu_ptr(&rcu_data) &&\n\t\t   !(IS_ENABLED(CONFIG_PREEMPT_COUNT) && preemptible())) ||\n\t\t  rcu_current_is_nocb_kthread(rdp)),\n\t\t\"Unsafe read of RCU_NOCB offloaded state\"\n\t);\n\n\treturn rcu_segcblist_is_offloaded(&rdp->cblist);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nstatic bool rcu_rdp_is_offloaded(struct rcu_data *rdp)\n{\n\t/*\n\t * In order to read the offloaded state of an rdp in a safe\n\t * and stable way and prevent from its value to be changed\n\t * under us, we must either hold the barrier mutex, the cpu\n\t * hotplug lock (read or write) or the nocb lock. Local\n\t * non-preemptible reads are also safe. NOCB kthreads and\n\t * timers have their own means of synchronization against the\n\t * offloaded state updaters.\n\t */\n\tRCU_LOCKDEP_WARN(\n\t\t!(lockdep_is_held(&rcu_state.barrier_mutex) ||\n\t\t  (IS_ENABLED(CONFIG_HOTPLUG_CPU) && lockdep_is_cpus_held()) ||\n\t\t  rcu_lockdep_is_held_nocb(rdp) ||\n\t\t  (rdp == this_cpu_ptr(&rcu_data) &&\n\t\t   !(IS_ENABLED(CONFIG_PREEMPT_COUNT) && preemptible())) ||\n\t\t  rcu_current_is_nocb_kthread(rdp)),\n\t\t\"Unsafe read of RCU_NOCB offloaded state\"\n\t);\n\n\treturn rcu_segcblist_is_offloaded(&rdp->cblist);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_rcu_segcb_stats",
          "args": [
            "&rdp->cblist",
            "TPS(\"SegCBQueued\")"
          ],
          "line": 3053
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPS",
          "args": [
            "\"SegCBQueued\""
          ],
          "line": 3053
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_rcu_callback",
          "args": [
            "rcu_state.name",
            "head",
            "rcu_segcblist_n_cbs(&rdp->cblist)"
          ],
          "line": 3050
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_segcblist_n_cbs",
          "args": [
            "&rdp->cblist"
          ],
          "line": 3051
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_n_cbs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "47-54",
          "snippet": "static inline long rcu_segcblist_n_cbs(struct rcu_segcblist *rsclp)\n{\n#ifdef CONFIG_RCU_NOCB_CPU\n\treturn atomic_long_read(&rsclp->len);\n#else\n\treturn READ_ONCE(rsclp->len);\n#endif\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "long rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nlong rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline long rcu_segcblist_n_cbs(struct rcu_segcblist *rsclp)\n{\n#ifdef CONFIG_RCU_NOCB_CPU\n\treturn atomic_long_read(&rsclp->len);\n#else\n\treturn READ_ONCE(rsclp->len);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_rcu_kvfree_callback",
          "args": [
            "rcu_state.name",
            "head",
            "(unsigned long)func",
            "rcu_segcblist_n_cbs(&rdp->cblist)"
          ],
          "line": 3046
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__is_kvfree_rcu_offset",
          "args": [
            "(unsigned long)func"
          ],
          "line": 3045
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_segcblist_enqueue",
          "args": [
            "&rdp->cblist",
            "head"
          ],
          "line": 3044
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_enqueue",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.c",
          "lines": "340-348",
          "snippet": "void rcu_segcblist_enqueue(struct rcu_segcblist *rsclp,\n\t\t\t   struct rcu_head *rhp)\n{\n\trcu_segcblist_inc_len(rsclp);\n\trcu_segcblist_inc_seglen(rsclp, RCU_NEXT_TAIL);\n\trhp->next = NULL;\n\tWRITE_ONCE(*rsclp->tails[RCU_NEXT_TAIL], rhp);\n\tWRITE_ONCE(rsclp->tails[RCU_NEXT_TAIL], &rhp->next);\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/cpu.h>\n\nvoid rcu_segcblist_enqueue(struct rcu_segcblist *rsclp,\n\t\t\t   struct rcu_head *rhp)\n{\n\trcu_segcblist_inc_len(rsclp);\n\trcu_segcblist_inc_seglen(rsclp, RCU_NEXT_TAIL);\n\trhp->next = NULL;\n\tWRITE_ONCE(*rsclp->tails[RCU_NEXT_TAIL], rhp);\n\tWRITE_ONCE(rsclp->tails[RCU_NEXT_TAIL], &rhp->next);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_nocb_try_bypass",
          "args": [
            "rdp",
            "head",
            "&was_alldone",
            "flags"
          ],
          "line": 3041
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_nocb_try_bypass",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_nocb.h",
          "lines": "1510-1514",
          "snippet": "static bool rcu_nocb_try_bypass(struct rcu_data *rdp, struct rcu_head *rhp,\n\t\t\t\tbool *was_alldone, unsigned long flags)\n{\n\treturn false;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static bool rcu_nocb_try_bypass(struct rcu_data *rdp, struct rcu_head *rhp,\n\t\t\t\tbool *was_alldone, unsigned long flags)\n{\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_cb_ovld",
          "args": [
            "rdp"
          ],
          "line": 3040
        },
        "resolved": true,
        "details": {
          "function_name": "check_cb_ovld",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "2985-2996",
          "snippet": "static void check_cb_ovld(struct rcu_data *rdp)\n{\n\tstruct rcu_node *const rnp = rdp->mynode;\n\n\tif (qovld_calc <= 0 ||\n\t    ((rcu_segcblist_n_cbs(&rdp->cblist) >= qovld_calc) ==\n\t     !!(READ_ONCE(rnp->cbovldmask) & rdp->grpmask)))\n\t\treturn; // Early boot wildcard value or already set correctly.\n\traw_spin_lock_rcu_node(rnp);\n\tcheck_cb_ovld_locked(rdp, rnp);\n\traw_spin_unlock_rcu_node(rnp);\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};",
            "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
            "static void check_cb_ovld_locked(struct rcu_data *rdp, struct rcu_node *rnp);",
            "static bool rcu_rdp_is_offloaded(struct rcu_data *rdp);",
            "static long qovld_calc = -1;",
            "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void check_cb_ovld_locked(struct rcu_data *rdp, struct rcu_node *rnp);\nstatic bool rcu_rdp_is_offloaded(struct rcu_data *rdp);\nstatic long qovld_calc = -1;\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nstatic void check_cb_ovld(struct rcu_data *rdp)\n{\n\tstruct rcu_node *const rnp = rdp->mynode;\n\n\tif (qovld_calc <= 0 ||\n\t    ((rcu_segcblist_n_cbs(&rdp->cblist) >= qovld_calc) ==\n\t     !!(READ_ONCE(rnp->cbovldmask) & rdp->grpmask)))\n\t\treturn; // Early boot wildcard value or already set correctly.\n\traw_spin_lock_rcu_node(rnp);\n\tcheck_cb_ovld_locked(rdp, rnp);\n\traw_spin_unlock_rcu_node(rnp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_segcblist_init",
          "args": [
            "&rdp->cblist"
          ],
          "line": 3037
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_init",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.c",
          "lines": "237-250",
          "snippet": "void rcu_segcblist_init(struct rcu_segcblist *rsclp)\n{\n\tint i;\n\n\tBUILD_BUG_ON(RCU_NEXT_TAIL + 1 != ARRAY_SIZE(rsclp->gp_seq));\n\tBUILD_BUG_ON(ARRAY_SIZE(rsclp->tails) != ARRAY_SIZE(rsclp->gp_seq));\n\trsclp->head = NULL;\n\tfor (i = 0; i < RCU_CBLIST_NSEGS; i++) {\n\t\trsclp->tails[i] = &rsclp->head;\n\t\trcu_segcblist_set_seglen(rsclp, i, 0);\n\t}\n\trcu_segcblist_set_len(rsclp, 0);\n\trcu_segcblist_set_flags(rsclp, SEGCBLIST_ENABLED);\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/cpu.h>\n\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp)\n{\n\tint i;\n\n\tBUILD_BUG_ON(RCU_NEXT_TAIL + 1 != ARRAY_SIZE(rsclp->gp_seq));\n\tBUILD_BUG_ON(ARRAY_SIZE(rsclp->tails) != ARRAY_SIZE(rsclp->gp_seq));\n\trsclp->head = NULL;\n\tfor (i = 0; i < RCU_CBLIST_NSEGS; i++) {\n\t\trsclp->tails[i] = &rsclp->head;\n\t\trcu_segcblist_set_seglen(rsclp, i, 0);\n\t}\n\trcu_segcblist_set_len(rsclp, 0);\n\trcu_segcblist_set_flags(rsclp, SEGCBLIST_ENABLED);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_segcblist_empty",
          "args": [
            "&rdp->cblist"
          ],
          "line": 3036
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "41-44",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "long rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nlong rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!rcu_is_watching()"
          ],
          "line": 3033
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_is_watching",
          "args": [],
          "line": 3033
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_is_watching",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "1123-1131",
          "snippet": "notrace bool rcu_is_watching(void)\n{\n\tbool ret;\n\n\tpreempt_disable_notrace();\n\tret = !rcu_dynticks_curr_cpu_in_eqs();\n\tpreempt_enable_notrace();\n\treturn ret;\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nnotrace bool rcu_is_watching(void)\n{\n\tbool ret;\n\n\tpreempt_disable_notrace();\n\tret = !rcu_dynticks_curr_cpu_in_eqs();\n\tpreempt_enable_notrace();\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "rcu_scheduler_active != RCU_SCHEDULER_INACTIVE"
          ],
          "line": 3032
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!rcu_segcblist_is_enabled(&rdp->cblist)"
          ],
          "line": 3030
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_segcblist_is_enabled",
          "args": [
            "&rdp->cblist"
          ],
          "line": 3030
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_is_enabled",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "78-81",
          "snippet": "static inline bool rcu_segcblist_is_enabled(struct rcu_segcblist *rsclp)\n{\n\treturn rcu_segcblist_test_flags(rsclp, SEGCBLIST_ENABLED);\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "long rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nlong rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_is_enabled(struct rcu_segcblist *rsclp)\n{\n\treturn rcu_segcblist_test_flags(rsclp, SEGCBLIST_ENABLED);\n}"
        }
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&rcu_data"
          ],
          "line": 3027
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kasan_record_aux_stack_noalloc",
          "args": [
            "head"
          ],
          "line": 3026
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_save",
          "args": [
            "flags"
          ],
          "line": 3025
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "head->func",
            "rcu_leak_callback"
          ],
          "line": 3020
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mem_dump_obj",
          "args": [
            "head"
          ],
          "line": 3018
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%s(): Double-freed CB %p->%pS()!!!  \"",
            "__func__",
            "head",
            "head->func"
          ],
          "line": 3017
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc_return",
          "args": [
            "&doublefrees"
          ],
          "line": 3016
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_rcu_head_queue",
          "args": [
            "head"
          ],
          "line": 3010
        },
        "resolved": true,
        "details": {
          "function_name": "debug_rcu_head_queue",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu.h",
          "lines": "191-194",
          "snippet": "static inline int debug_rcu_head_queue(struct rcu_head *head)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/rcu_node_tree.h>",
            "#include <trace/events/rcu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_node_tree.h>\n#include <trace/events/rcu.h>\n\nstatic inline int debug_rcu_head_queue(struct rcu_head *head)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "(unsigned long)head & (sizeof(void *) - 1)"
          ],
          "line": 3008
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};\nstatic struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\nint rcu_scheduler_active;\nstatic void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic bool rcu_rdp_is_offloaded(struct rcu_data *rdp);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nstatic void\n__call_rcu(struct rcu_head *head, rcu_callback_t func)\n{\n\tstatic atomic_t doublefrees;\n\tunsigned long flags;\n\tstruct rcu_data *rdp;\n\tbool was_alldone;\n\n\t/* Misaligned rcu_head! */\n\tWARN_ON_ONCE((unsigned long)head & (sizeof(void *) - 1));\n\n\tif (debug_rcu_head_queue(head)) {\n\t\t/*\n\t\t * Probable double call_rcu(), so leak the callback.\n\t\t * Use rcu:rcu_callback trace event to find the previous\n\t\t * time callback was passed to __call_rcu().\n\t\t */\n\t\tif (atomic_inc_return(&doublefrees) < 4) {\n\t\t\tpr_err(\"%s(): Double-freed CB %p->%pS()!!!  \", __func__, head, head->func);\n\t\t\tmem_dump_obj(head);\n\t\t}\n\t\tWRITE_ONCE(head->func, rcu_leak_callback);\n\t\treturn;\n\t}\n\thead->func = func;\n\thead->next = NULL;\n\tlocal_irq_save(flags);\n\tkasan_record_aux_stack_noalloc(head);\n\trdp = this_cpu_ptr(&rcu_data);\n\n\t/* Add the callback to our list. */\n\tif (unlikely(!rcu_segcblist_is_enabled(&rdp->cblist))) {\n\t\t// This can trigger due to call_rcu() from offline CPU:\n\t\tWARN_ON_ONCE(rcu_scheduler_active != RCU_SCHEDULER_INACTIVE);\n\t\tWARN_ON_ONCE(!rcu_is_watching());\n\t\t// Very early boot, before rcu_init().  Initialize if needed\n\t\t// and then drop through to queue the callback.\n\t\tif (rcu_segcblist_empty(&rdp->cblist))\n\t\t\trcu_segcblist_init(&rdp->cblist);\n\t}\n\n\tcheck_cb_ovld(rdp);\n\tif (rcu_nocb_try_bypass(rdp, head, &was_alldone, flags))\n\t\treturn; // Enqueued onto ->nocb_bypass, so just leave.\n\t// If no-CBs CPU gets here, rcu_nocb_try_bypass() acquired ->nocb_lock.\n\trcu_segcblist_enqueue(&rdp->cblist, head);\n\tif (__is_kvfree_rcu_offset((unsigned long)func))\n\t\ttrace_rcu_kvfree_callback(rcu_state.name, head,\n\t\t\t\t\t (unsigned long)func,\n\t\t\t\t\t rcu_segcblist_n_cbs(&rdp->cblist));\n\telse\n\t\ttrace_rcu_callback(rcu_state.name, head,\n\t\t\t\t   rcu_segcblist_n_cbs(&rdp->cblist));\n\n\ttrace_rcu_segcb_stats(&rdp->cblist, TPS(\"SegCBQueued\"));\n\n\t/* Go handle any RCU core processing required. */\n\tif (unlikely(rcu_rdp_is_offloaded(rdp))) {\n\t\t__call_rcu_nocb_wake(rdp, was_alldone, flags); /* unlocks */\n\t} else {\n\t\t__call_rcu_core(rdp, head, flags);\n\t\tlocal_irq_restore(flags);\n\t}\n}"
  },
  {
    "function_name": "check_cb_ovld",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
    "lines": "2985-2996",
    "snippet": "static void check_cb_ovld(struct rcu_data *rdp)\n{\n\tstruct rcu_node *const rnp = rdp->mynode;\n\n\tif (qovld_calc <= 0 ||\n\t    ((rcu_segcblist_n_cbs(&rdp->cblist) >= qovld_calc) ==\n\t     !!(READ_ONCE(rnp->cbovldmask) & rdp->grpmask)))\n\t\treturn; // Early boot wildcard value or already set correctly.\n\traw_spin_lock_rcu_node(rnp);\n\tcheck_cb_ovld_locked(rdp, rnp);\n\traw_spin_unlock_rcu_node(rnp);\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_nocb.h\"",
      "#include \"tree_exp.h\"",
      "#include \"tree_stall.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <linux/kasan.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/panic_notifier.h>",
      "#include <linux/panic.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};",
      "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
      "static void check_cb_ovld_locked(struct rcu_data *rdp, struct rcu_node *rnp);",
      "static bool rcu_rdp_is_offloaded(struct rcu_data *rdp);",
      "static long qovld_calc = -1;",
      "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock_rcu_node",
          "args": [
            "rnp"
          ],
          "line": 2995
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_cb_ovld_locked",
          "args": [
            "rdp",
            "rnp"
          ],
          "line": 2994
        },
        "resolved": true,
        "details": {
          "function_name": "check_cb_ovld_locked",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "2962-2971",
          "snippet": "static void check_cb_ovld_locked(struct rcu_data *rdp, struct rcu_node *rnp)\n{\n\traw_lockdep_assert_held_rcu_node(rnp);\n\tif (qovld_calc <= 0)\n\t\treturn; // Early boot and wildcard value set.\n\tif (rcu_segcblist_n_cbs(&rdp->cblist) >= qovld_calc)\n\t\tWRITE_ONCE(rnp->cbovldmask, rnp->cbovldmask | rdp->grpmask);\n\telse\n\t\tWRITE_ONCE(rnp->cbovldmask, rnp->cbovldmask & ~rdp->grpmask);\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};",
            "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
            "static void check_cb_ovld_locked(struct rcu_data *rdp, struct rcu_node *rnp);",
            "static bool rcu_rdp_is_offloaded(struct rcu_data *rdp);",
            "static long qovld_calc = -1;",
            "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void check_cb_ovld_locked(struct rcu_data *rdp, struct rcu_node *rnp);\nstatic bool rcu_rdp_is_offloaded(struct rcu_data *rdp);\nstatic long qovld_calc = -1;\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nstatic void check_cb_ovld_locked(struct rcu_data *rdp, struct rcu_node *rnp)\n{\n\traw_lockdep_assert_held_rcu_node(rnp);\n\tif (qovld_calc <= 0)\n\t\treturn; // Early boot and wildcard value set.\n\tif (rcu_segcblist_n_cbs(&rdp->cblist) >= qovld_calc)\n\t\tWRITE_ONCE(rnp->cbovldmask, rnp->cbovldmask | rdp->grpmask);\n\telse\n\t\tWRITE_ONCE(rnp->cbovldmask, rnp->cbovldmask & ~rdp->grpmask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_rcu_node",
          "args": [
            "rnp"
          ],
          "line": 2993
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rnp->cbovldmask"
          ],
          "line": 2991
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_segcblist_n_cbs",
          "args": [
            "&rdp->cblist"
          ],
          "line": 2990
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_n_cbs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "47-54",
          "snippet": "static inline long rcu_segcblist_n_cbs(struct rcu_segcblist *rsclp)\n{\n#ifdef CONFIG_RCU_NOCB_CPU\n\treturn atomic_long_read(&rsclp->len);\n#else\n\treturn READ_ONCE(rsclp->len);\n#endif\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "long rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nlong rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline long rcu_segcblist_n_cbs(struct rcu_segcblist *rsclp)\n{\n#ifdef CONFIG_RCU_NOCB_CPU\n\treturn atomic_long_read(&rsclp->len);\n#else\n\treturn READ_ONCE(rsclp->len);\n#endif\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void check_cb_ovld_locked(struct rcu_data *rdp, struct rcu_node *rnp);\nstatic bool rcu_rdp_is_offloaded(struct rcu_data *rdp);\nstatic long qovld_calc = -1;\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nstatic void check_cb_ovld(struct rcu_data *rdp)\n{\n\tstruct rcu_node *const rnp = rdp->mynode;\n\n\tif (qovld_calc <= 0 ||\n\t    ((rcu_segcblist_n_cbs(&rdp->cblist) >= qovld_calc) ==\n\t     !!(READ_ONCE(rnp->cbovldmask) & rdp->grpmask)))\n\t\treturn; // Early boot wildcard value or already set correctly.\n\traw_spin_lock_rcu_node(rnp);\n\tcheck_cb_ovld_locked(rdp, rnp);\n\traw_spin_unlock_rcu_node(rnp);\n}"
  },
  {
    "function_name": "check_cb_ovld_locked",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
    "lines": "2962-2971",
    "snippet": "static void check_cb_ovld_locked(struct rcu_data *rdp, struct rcu_node *rnp)\n{\n\traw_lockdep_assert_held_rcu_node(rnp);\n\tif (qovld_calc <= 0)\n\t\treturn; // Early boot and wildcard value set.\n\tif (rcu_segcblist_n_cbs(&rdp->cblist) >= qovld_calc)\n\t\tWRITE_ONCE(rnp->cbovldmask, rnp->cbovldmask | rdp->grpmask);\n\telse\n\t\tWRITE_ONCE(rnp->cbovldmask, rnp->cbovldmask & ~rdp->grpmask);\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_nocb.h\"",
      "#include \"tree_exp.h\"",
      "#include \"tree_stall.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <linux/kasan.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/panic_notifier.h>",
      "#include <linux/panic.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};",
      "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
      "static void check_cb_ovld_locked(struct rcu_data *rdp, struct rcu_node *rnp);",
      "static bool rcu_rdp_is_offloaded(struct rcu_data *rdp);",
      "static long qovld_calc = -1;",
      "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "rnp->cbovldmask",
            "rnp->cbovldmask & ~rdp->grpmask"
          ],
          "line": 2970
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "rnp->cbovldmask",
            "rnp->cbovldmask | rdp->grpmask"
          ],
          "line": 2968
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_segcblist_n_cbs",
          "args": [
            "&rdp->cblist"
          ],
          "line": 2967
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_n_cbs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "47-54",
          "snippet": "static inline long rcu_segcblist_n_cbs(struct rcu_segcblist *rsclp)\n{\n#ifdef CONFIG_RCU_NOCB_CPU\n\treturn atomic_long_read(&rsclp->len);\n#else\n\treturn READ_ONCE(rsclp->len);\n#endif\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "long rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nlong rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline long rcu_segcblist_n_cbs(struct rcu_segcblist *rsclp)\n{\n#ifdef CONFIG_RCU_NOCB_CPU\n\treturn atomic_long_read(&rsclp->len);\n#else\n\treturn READ_ONCE(rsclp->len);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_lockdep_assert_held_rcu_node",
          "args": [
            "rnp"
          ],
          "line": 2964
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void check_cb_ovld_locked(struct rcu_data *rdp, struct rcu_node *rnp);\nstatic bool rcu_rdp_is_offloaded(struct rcu_data *rdp);\nstatic long qovld_calc = -1;\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nstatic void check_cb_ovld_locked(struct rcu_data *rdp, struct rcu_node *rnp)\n{\n\traw_lockdep_assert_held_rcu_node(rnp);\n\tif (qovld_calc <= 0)\n\t\treturn; // Early boot and wildcard value set.\n\tif (rcu_segcblist_n_cbs(&rdp->cblist) >= qovld_calc)\n\t\tWRITE_ONCE(rnp->cbovldmask, rnp->cbovldmask | rdp->grpmask);\n\telse\n\t\tWRITE_ONCE(rnp->cbovldmask, rnp->cbovldmask & ~rdp->grpmask);\n}"
  },
  {
    "function_name": "rcu_leak_callback",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
    "lines": "2952-2954",
    "snippet": "static void rcu_leak_callback(struct rcu_head *rhp)\n{\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_nocb.h\"",
      "#include \"tree_exp.h\"",
      "#include \"tree_stall.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <linux/kasan.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/panic_notifier.h>",
      "#include <linux/panic.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic void rcu_leak_callback(struct rcu_head *rhp)\n{\n}"
  },
  {
    "function_name": "__call_rcu_core",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
    "lines": "2907-2947",
    "snippet": "static void __call_rcu_core(struct rcu_data *rdp, struct rcu_head *head,\n\t\t\t    unsigned long flags)\n{\n\t/*\n\t * If called from an extended quiescent state, invoke the RCU\n\t * core in order to force a re-evaluation of RCU's idleness.\n\t */\n\tif (!rcu_is_watching())\n\t\tinvoke_rcu_core();\n\n\t/* If interrupts were disabled or CPU offline, don't invoke RCU core. */\n\tif (irqs_disabled_flags(flags) || cpu_is_offline(smp_processor_id()))\n\t\treturn;\n\n\t/*\n\t * Force the grace period if too many callbacks or too long waiting.\n\t * Enforce hysteresis, and don't invoke rcu_force_quiescent_state()\n\t * if some other CPU has recently done so.  Also, don't bother\n\t * invoking rcu_force_quiescent_state() if the newly enqueued callback\n\t * is the only one waiting for a grace period to complete.\n\t */\n\tif (unlikely(rcu_segcblist_n_cbs(&rdp->cblist) >\n\t\t     rdp->qlen_last_fqs_check + qhimark)) {\n\n\t\t/* Are we ignoring a completed grace period? */\n\t\tnote_gp_changes(rdp);\n\n\t\t/* Start a new grace period if one not already started. */\n\t\tif (!rcu_gp_in_progress()) {\n\t\t\trcu_accelerate_cbs_unlocked(rdp->mynode, rdp);\n\t\t} else {\n\t\t\t/* Give the grace period a kick. */\n\t\t\trdp->blimit = DEFAULT_MAX_RCU_BLIMIT;\n\t\t\tif (READ_ONCE(rcu_state.n_force_qs) == rdp->n_force_qs_snap &&\n\t\t\t    rcu_segcblist_first_pend_cb(&rdp->cblist) != head)\n\t\t\t\trcu_force_quiescent_state();\n\t\t\trdp->n_force_qs_snap = READ_ONCE(rcu_state.n_force_qs);\n\t\t\trdp->qlen_last_fqs_check = rcu_segcblist_n_cbs(&rdp->cblist);\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_nocb.h\"",
      "#include \"tree_exp.h\"",
      "#include \"tree_stall.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <linux/kasan.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/panic_notifier.h>",
      "#include <linux/panic.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [
      "#define DEFAULT_MAX_RCU_BLIMIT 10000 // ... even during callback flood."
    ],
    "globals_used": [
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};",
      "static struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};",
      "static void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);",
      "static void invoke_rcu_core(void);",
      "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
      "static bool rcu_rdp_is_offloaded(struct rcu_data *rdp);",
      "static long blimit = DEFAULT_RCU_BLIMIT;",
      "static long qhimark = DEFAULT_RCU_QHIMARK;",
      "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_segcblist_n_cbs",
          "args": [
            "&rdp->cblist"
          ],
          "line": 2944
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_n_cbs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "47-54",
          "snippet": "static inline long rcu_segcblist_n_cbs(struct rcu_segcblist *rsclp)\n{\n#ifdef CONFIG_RCU_NOCB_CPU\n\treturn atomic_long_read(&rsclp->len);\n#else\n\treturn READ_ONCE(rsclp->len);\n#endif\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "long rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nlong rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline long rcu_segcblist_n_cbs(struct rcu_segcblist *rsclp)\n{\n#ifdef CONFIG_RCU_NOCB_CPU\n\treturn atomic_long_read(&rsclp->len);\n#else\n\treturn READ_ONCE(rsclp->len);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rcu_state.n_force_qs"
          ],
          "line": 2943
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_force_quiescent_state",
          "args": [],
          "line": 2942
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_force_quiescent_state",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "2681-2712",
          "snippet": "void rcu_force_quiescent_state(void)\n{\n\tunsigned long flags;\n\tbool ret;\n\tstruct rcu_node *rnp;\n\tstruct rcu_node *rnp_old = NULL;\n\n\t/* Funnel through hierarchy to reduce memory contention. */\n\trnp = __this_cpu_read(rcu_data.mynode);\n\tfor (; rnp != NULL; rnp = rnp->parent) {\n\t\tret = (READ_ONCE(rcu_state.gp_flags) & RCU_GP_FLAG_FQS) ||\n\t\t       !raw_spin_trylock(&rnp->fqslock);\n\t\tif (rnp_old != NULL)\n\t\t\traw_spin_unlock(&rnp_old->fqslock);\n\t\tif (ret)\n\t\t\treturn;\n\t\trnp_old = rnp;\n\t}\n\t/* rnp_old == rcu_get_root(), rnp == NULL. */\n\n\t/* Reached the root of the rcu_node tree, acquire lock. */\n\traw_spin_lock_irqsave_rcu_node(rnp_old, flags);\n\traw_spin_unlock(&rnp_old->fqslock);\n\tif (READ_ONCE(rcu_state.gp_flags) & RCU_GP_FLAG_FQS) {\n\t\traw_spin_unlock_irqrestore_rcu_node(rnp_old, flags);\n\t\treturn;  /* Someone beat us to it. */\n\t}\n\tWRITE_ONCE(rcu_state.gp_flags,\n\t\t   READ_ONCE(rcu_state.gp_flags) | RCU_GP_FLAG_FQS);\n\traw_spin_unlock_irqrestore_rcu_node(rnp_old, flags);\n\trcu_gp_kthread_wake();\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};",
            "static struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};",
            "static void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);",
            "static void check_cb_ovld_locked(struct rcu_data *rdp, struct rcu_node *rnp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};\nstatic struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\nstatic void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);\nstatic void check_cb_ovld_locked(struct rcu_data *rdp, struct rcu_node *rnp);\n\nvoid rcu_force_quiescent_state(void)\n{\n\tunsigned long flags;\n\tbool ret;\n\tstruct rcu_node *rnp;\n\tstruct rcu_node *rnp_old = NULL;\n\n\t/* Funnel through hierarchy to reduce memory contention. */\n\trnp = __this_cpu_read(rcu_data.mynode);\n\tfor (; rnp != NULL; rnp = rnp->parent) {\n\t\tret = (READ_ONCE(rcu_state.gp_flags) & RCU_GP_FLAG_FQS) ||\n\t\t       !raw_spin_trylock(&rnp->fqslock);\n\t\tif (rnp_old != NULL)\n\t\t\traw_spin_unlock(&rnp_old->fqslock);\n\t\tif (ret)\n\t\t\treturn;\n\t\trnp_old = rnp;\n\t}\n\t/* rnp_old == rcu_get_root(), rnp == NULL. */\n\n\t/* Reached the root of the rcu_node tree, acquire lock. */\n\traw_spin_lock_irqsave_rcu_node(rnp_old, flags);\n\traw_spin_unlock(&rnp_old->fqslock);\n\tif (READ_ONCE(rcu_state.gp_flags) & RCU_GP_FLAG_FQS) {\n\t\traw_spin_unlock_irqrestore_rcu_node(rnp_old, flags);\n\t\treturn;  /* Someone beat us to it. */\n\t}\n\tWRITE_ONCE(rcu_state.gp_flags,\n\t\t   READ_ONCE(rcu_state.gp_flags) | RCU_GP_FLAG_FQS);\n\traw_spin_unlock_irqrestore_rcu_node(rnp_old, flags);\n\trcu_gp_kthread_wake();\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_segcblist_first_pend_cb",
          "args": [
            "&rdp->cblist"
          ],
          "line": 2941
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_first_pend_cb",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.c",
          "lines": "312-317",
          "snippet": "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp)\n{\n\tif (rcu_segcblist_is_enabled(rsclp))\n\t\treturn *rsclp->tails[RCU_DONE_TAIL];\n\treturn NULL;\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/cpu.h>\n\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp)\n{\n\tif (rcu_segcblist_is_enabled(rsclp))\n\t\treturn *rsclp->tails[RCU_DONE_TAIL];\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rcu_state.n_force_qs"
          ],
          "line": 2940
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_accelerate_cbs_unlocked",
          "args": [
            "rdp->mynode",
            "rdp"
          ],
          "line": 2936
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_accelerate_cbs_unlocked",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "1543-1561",
          "snippet": "static void rcu_accelerate_cbs_unlocked(struct rcu_node *rnp,\n\t\t\t\t\tstruct rcu_data *rdp)\n{\n\tunsigned long c;\n\tbool needwake;\n\n\trcu_lockdep_assert_cblist_protected(rdp);\n\tc = rcu_seq_snap(&rcu_state.gp_seq);\n\tif (!READ_ONCE(rdp->gpwrap) && ULONG_CMP_GE(rdp->gp_seq_needed, c)) {\n\t\t/* Old request still live, so mark recent callbacks. */\n\t\t(void)rcu_segcblist_accelerate(&rdp->cblist, c);\n\t\treturn;\n\t}\n\traw_spin_lock_rcu_node(rnp); /* irqs already disabled. */\n\tneedwake = rcu_accelerate_cbs(rnp, rdp);\n\traw_spin_unlock_rcu_node(rnp); /* irqs remain disabled. */\n\tif (needwake)\n\t\trcu_gp_kthread_wake();\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};",
            "static struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};",
            "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
            "static void check_cb_ovld_locked(struct rcu_data *rdp, struct rcu_node *rnp);",
            "static bool rcu_rdp_is_offloaded(struct rcu_data *rdp);",
            "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};\nstatic struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void check_cb_ovld_locked(struct rcu_data *rdp, struct rcu_node *rnp);\nstatic bool rcu_rdp_is_offloaded(struct rcu_data *rdp);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nstatic void rcu_accelerate_cbs_unlocked(struct rcu_node *rnp,\n\t\t\t\t\tstruct rcu_data *rdp)\n{\n\tunsigned long c;\n\tbool needwake;\n\n\trcu_lockdep_assert_cblist_protected(rdp);\n\tc = rcu_seq_snap(&rcu_state.gp_seq);\n\tif (!READ_ONCE(rdp->gpwrap) && ULONG_CMP_GE(rdp->gp_seq_needed, c)) {\n\t\t/* Old request still live, so mark recent callbacks. */\n\t\t(void)rcu_segcblist_accelerate(&rdp->cblist, c);\n\t\treturn;\n\t}\n\traw_spin_lock_rcu_node(rnp); /* irqs already disabled. */\n\tneedwake = rcu_accelerate_cbs(rnp, rdp);\n\traw_spin_unlock_rcu_node(rnp); /* irqs remain disabled. */\n\tif (needwake)\n\t\trcu_gp_kthread_wake();\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_gp_in_progress",
          "args": [],
          "line": 2935
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_gp_in_progress",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "229-232",
          "snippet": "static int rcu_gp_in_progress(void)\n{\n\treturn rcu_seq_state(rcu_seq_current(&rcu_state.gp_seq));\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\n\nstatic int rcu_gp_in_progress(void)\n{\n\treturn rcu_seq_state(rcu_seq_current(&rcu_state.gp_seq));\n}"
        }
      },
      {
        "call_info": {
          "callee": "note_gp_changes",
          "args": [
            "rdp"
          ],
          "line": 2932
        },
        "resolved": true,
        "details": {
          "function_name": "note_gp_changes",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "1674-1693",
          "snippet": "static void note_gp_changes(struct rcu_data *rdp)\n{\n\tunsigned long flags;\n\tbool needwake;\n\tstruct rcu_node *rnp;\n\n\tlocal_irq_save(flags);\n\trnp = rdp->mynode;\n\tif ((rdp->gp_seq == rcu_seq_current(&rnp->gp_seq) &&\n\t     !unlikely(READ_ONCE(rdp->gpwrap))) || /* w/out lock. */\n\t    !raw_spin_trylock_rcu_node(rnp)) { /* irqs already off, so later. */\n\t\tlocal_irq_restore(flags);\n\t\treturn;\n\t}\n\tneedwake = __note_gp_changes(rnp, rdp);\n\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\trcu_strict_gp_check_qs();\n\tif (needwake)\n\t\trcu_gp_kthread_wake();\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};",
            "static void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);",
            "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
            "static void check_cb_ovld_locked(struct rcu_data *rdp, struct rcu_node *rnp);",
            "static bool rcu_rdp_is_offloaded(struct rcu_data *rdp);",
            "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};\nstatic void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void check_cb_ovld_locked(struct rcu_data *rdp, struct rcu_node *rnp);\nstatic bool rcu_rdp_is_offloaded(struct rcu_data *rdp);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nstatic void note_gp_changes(struct rcu_data *rdp)\n{\n\tunsigned long flags;\n\tbool needwake;\n\tstruct rcu_node *rnp;\n\n\tlocal_irq_save(flags);\n\trnp = rdp->mynode;\n\tif ((rdp->gp_seq == rcu_seq_current(&rnp->gp_seq) &&\n\t     !unlikely(READ_ONCE(rdp->gpwrap))) || /* w/out lock. */\n\t    !raw_spin_trylock_rcu_node(rnp)) { /* irqs already off, so later. */\n\t\tlocal_irq_restore(flags);\n\t\treturn;\n\t}\n\tneedwake = __note_gp_changes(rnp, rdp);\n\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\trcu_strict_gp_check_qs();\n\tif (needwake)\n\t\trcu_gp_kthread_wake();\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "rcu_segcblist_n_cbs(&rdp->cblist) >\n\t\t     rdp->qlen_last_fqs_check + qhimark"
          ],
          "line": 2928
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_is_offline",
          "args": [
            "smp_processor_id()"
          ],
          "line": 2918
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 2918
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irqs_disabled_flags",
          "args": [
            "flags"
          ],
          "line": 2918
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "invoke_rcu_core",
          "args": [],
          "line": 2915
        },
        "resolved": true,
        "details": {
          "function_name": "invoke_rcu_core",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "2824-2832",
          "snippet": "static void invoke_rcu_core(void)\n{\n\tif (!cpu_online(smp_processor_id()))\n\t\treturn;\n\tif (use_softirq)\n\t\traise_softirq(RCU_SOFTIRQ);\n\telse\n\t\tinvoke_rcu_core_kthread();\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool use_softirq = !IS_ENABLED(CONFIG_PREEMPT_RT);",
            "static void invoke_rcu_core(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic bool use_softirq = !IS_ENABLED(CONFIG_PREEMPT_RT);\nstatic void invoke_rcu_core(void);\n\nstatic void invoke_rcu_core(void)\n{\n\tif (!cpu_online(smp_processor_id()))\n\t\treturn;\n\tif (use_softirq)\n\t\traise_softirq(RCU_SOFTIRQ);\n\telse\n\t\tinvoke_rcu_core_kthread();\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_is_watching",
          "args": [],
          "line": 2914
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_is_watching",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "1123-1131",
          "snippet": "notrace bool rcu_is_watching(void)\n{\n\tbool ret;\n\n\tpreempt_disable_notrace();\n\tret = !rcu_dynticks_curr_cpu_in_eqs();\n\tpreempt_enable_notrace();\n\treturn ret;\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nnotrace bool rcu_is_watching(void)\n{\n\tbool ret;\n\n\tpreempt_disable_notrace();\n\tret = !rcu_dynticks_curr_cpu_in_eqs();\n\tpreempt_enable_notrace();\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define DEFAULT_MAX_RCU_BLIMIT 10000 // ... even during callback flood.\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};\nstatic struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\nstatic void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);\nstatic void invoke_rcu_core(void);\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic bool rcu_rdp_is_offloaded(struct rcu_data *rdp);\nstatic long blimit = DEFAULT_RCU_BLIMIT;\nstatic long qhimark = DEFAULT_RCU_QHIMARK;\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nstatic void __call_rcu_core(struct rcu_data *rdp, struct rcu_head *head,\n\t\t\t    unsigned long flags)\n{\n\t/*\n\t * If called from an extended quiescent state, invoke the RCU\n\t * core in order to force a re-evaluation of RCU's idleness.\n\t */\n\tif (!rcu_is_watching())\n\t\tinvoke_rcu_core();\n\n\t/* If interrupts were disabled or CPU offline, don't invoke RCU core. */\n\tif (irqs_disabled_flags(flags) || cpu_is_offline(smp_processor_id()))\n\t\treturn;\n\n\t/*\n\t * Force the grace period if too many callbacks or too long waiting.\n\t * Enforce hysteresis, and don't invoke rcu_force_quiescent_state()\n\t * if some other CPU has recently done so.  Also, don't bother\n\t * invoking rcu_force_quiescent_state() if the newly enqueued callback\n\t * is the only one waiting for a grace period to complete.\n\t */\n\tif (unlikely(rcu_segcblist_n_cbs(&rdp->cblist) >\n\t\t     rdp->qlen_last_fqs_check + qhimark)) {\n\n\t\t/* Are we ignoring a completed grace period? */\n\t\tnote_gp_changes(rdp);\n\n\t\t/* Start a new grace period if one not already started. */\n\t\tif (!rcu_gp_in_progress()) {\n\t\t\trcu_accelerate_cbs_unlocked(rdp->mynode, rdp);\n\t\t} else {\n\t\t\t/* Give the grace period a kick. */\n\t\t\trdp->blimit = DEFAULT_MAX_RCU_BLIMIT;\n\t\t\tif (READ_ONCE(rcu_state.n_force_qs) == rdp->n_force_qs_snap &&\n\t\t\t    rcu_segcblist_first_pend_cb(&rdp->cblist) != head)\n\t\t\t\trcu_force_quiescent_state();\n\t\t\trdp->n_force_qs_snap = READ_ONCE(rcu_state.n_force_qs);\n\t\t\trdp->qlen_last_fqs_check = rcu_segcblist_n_cbs(&rdp->cblist);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "rcu_spawn_core_kthreads",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
    "lines": "2891-2902",
    "snippet": "static int __init rcu_spawn_core_kthreads(void)\n{\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu)\n\t\tper_cpu(rcu_data.rcu_cpu_has_work, cpu) = 0;\n\tif (!IS_ENABLED(CONFIG_RCU_BOOST) && use_softirq)\n\t\treturn 0;\n\tWARN_ONCE(smpboot_register_percpu_thread(&rcu_cpu_thread_spec),\n\t\t  \"%s: Could not start rcuc kthread, OOM is now expected behavior\\n\", __func__);\n\treturn 0;\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_nocb.h\"",
      "#include \"tree_exp.h\"",
      "#include \"tree_stall.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <linux/kasan.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/panic_notifier.h>",
      "#include <linux/panic.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};",
      "static bool use_softirq = !IS_ENABLED(CONFIG_PREEMPT_RT);",
      "static void sync_sched_exp_online_cleanup(int cpu);",
      "static struct smp_hotplug_thread rcu_cpu_thread_spec = {\n\t.store\t\t\t= &rcu_data.rcu_cpu_kthread_task,\n\t.thread_should_run\t= rcu_cpu_kthread_should_run,\n\t.thread_fn\t\t= rcu_cpu_kthread,\n\t.thread_comm\t\t= \"rcuc/%u\",\n\t.setup\t\t\t= rcu_cpu_kthread_setup,\n\t.park\t\t\t= rcu_cpu_kthread_park,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ONCE",
          "args": [
            "smpboot_register_percpu_thread(&rcu_cpu_thread_spec)",
            "\"%s: Could not start rcuc kthread, OOM is now expected behavior\\n\"",
            "__func__"
          ],
          "line": 2899
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smpboot_register_percpu_thread",
          "args": [
            "&rcu_cpu_thread_spec"
          ],
          "line": 2899
        },
        "resolved": true,
        "details": {
          "function_name": "smpboot_register_percpu_thread",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/smpboot.c",
          "lines": "289-309",
          "snippet": "int smpboot_register_percpu_thread(struct smp_hotplug_thread *plug_thread)\n{\n\tunsigned int cpu;\n\tint ret = 0;\n\n\tcpus_read_lock();\n\tmutex_lock(&smpboot_threads_lock);\n\tfor_each_online_cpu(cpu) {\n\t\tret = __smpboot_create_thread(plug_thread, cpu);\n\t\tif (ret) {\n\t\t\tsmpboot_destroy_threads(plug_thread);\n\t\t\tgoto out;\n\t\t}\n\t\tsmpboot_unpark_thread(plug_thread, cpu);\n\t}\n\tlist_add(&plug_thread->list, &hotplug_threads);\nout:\n\tmutex_unlock(&smpboot_threads_lock);\n\tcpus_read_unlock();\n\treturn ret;\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <linux/smpboot.h>",
            "#include <linux/kthread.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/delay.h>",
            "#include <linux/smp.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(hotplug_threads);",
            "static DEFINE_MUTEX(smpboot_threads_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <linux/smpboot.h>\n#include <linux/kthread.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic LIST_HEAD(hotplug_threads);\nstatic DEFINE_MUTEX(smpboot_threads_lock);\n\nint smpboot_register_percpu_thread(struct smp_hotplug_thread *plug_thread)\n{\n\tunsigned int cpu;\n\tint ret = 0;\n\n\tcpus_read_lock();\n\tmutex_lock(&smpboot_threads_lock);\n\tfor_each_online_cpu(cpu) {\n\t\tret = __smpboot_create_thread(plug_thread, cpu);\n\t\tif (ret) {\n\t\t\tsmpboot_destroy_threads(plug_thread);\n\t\t\tgoto out;\n\t\t}\n\t\tsmpboot_unpark_thread(plug_thread, cpu);\n\t}\n\tlist_add(&plug_thread->list, &hotplug_threads);\nout:\n\tmutex_unlock(&smpboot_threads_lock);\n\tcpus_read_unlock();\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_RCU_BOOST"
          ],
          "line": 2897
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};\nstatic bool use_softirq = !IS_ENABLED(CONFIG_PREEMPT_RT);\nstatic void sync_sched_exp_online_cleanup(int cpu);\nstatic struct smp_hotplug_thread rcu_cpu_thread_spec = {\n\t.store\t\t\t= &rcu_data.rcu_cpu_kthread_task,\n\t.thread_should_run\t= rcu_cpu_kthread_should_run,\n\t.thread_fn\t\t= rcu_cpu_kthread,\n\t.thread_comm\t\t= \"rcuc/%u\",\n\t.setup\t\t\t= rcu_cpu_kthread_setup,\n\t.park\t\t\t= rcu_cpu_kthread_park,\n};\n\nstatic int __init rcu_spawn_core_kthreads(void)\n{\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu)\n\t\tper_cpu(rcu_data.rcu_cpu_has_work, cpu) = 0;\n\tif (!IS_ENABLED(CONFIG_RCU_BOOST) && use_softirq)\n\t\treturn 0;\n\tWARN_ONCE(smpboot_register_percpu_thread(&rcu_cpu_thread_spec),\n\t\t  \"%s: Could not start rcuc kthread, OOM is now expected behavior\\n\", __func__);\n\treturn 0;\n}"
  },
  {
    "function_name": "rcu_cpu_kthread",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
    "lines": "2849-2877",
    "snippet": "static void rcu_cpu_kthread(unsigned int cpu)\n{\n\tunsigned int *statusp = this_cpu_ptr(&rcu_data.rcu_cpu_kthread_status);\n\tchar work, *workp = this_cpu_ptr(&rcu_data.rcu_cpu_has_work);\n\tint spincnt;\n\n\ttrace_rcu_utilization(TPS(\"Start CPU kthread@rcu_run\"));\n\tfor (spincnt = 0; spincnt < 10; spincnt++) {\n\t\tlocal_bh_disable();\n\t\t*statusp = RCU_KTHREAD_RUNNING;\n\t\tlocal_irq_disable();\n\t\twork = *workp;\n\t\t*workp = 0;\n\t\tlocal_irq_enable();\n\t\tif (work)\n\t\t\trcu_core();\n\t\tlocal_bh_enable();\n\t\tif (*workp == 0) {\n\t\t\ttrace_rcu_utilization(TPS(\"End CPU kthread@rcu_wait\"));\n\t\t\t*statusp = RCU_KTHREAD_WAITING;\n\t\t\treturn;\n\t\t}\n\t}\n\t*statusp = RCU_KTHREAD_YIELDING;\n\ttrace_rcu_utilization(TPS(\"Start CPU kthread@rcu_yield\"));\n\tschedule_timeout_idle(2);\n\ttrace_rcu_utilization(TPS(\"End CPU kthread@rcu_yield\"));\n\t*statusp = RCU_KTHREAD_WAITING;\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_nocb.h\"",
      "#include \"tree_exp.h\"",
      "#include \"tree_stall.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <linux/kasan.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/panic_notifier.h>",
      "#include <linux/panic.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};",
      "static void sync_sched_exp_online_cleanup(int cpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_rcu_utilization",
          "args": [
            "TPS(\"End CPU kthread@rcu_yield\")"
          ],
          "line": 2875
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPS",
          "args": [
            "\"End CPU kthread@rcu_yield\""
          ],
          "line": 2875
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schedule_timeout_idle",
          "args": [
            "2"
          ],
          "line": 2874
        },
        "resolved": true,
        "details": {
          "function_name": "schedule_timeout_idle",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timer.c",
          "lines": "1923-1927",
          "snippet": "signed long __sched schedule_timeout_idle(signed long timeout)\n{\n\t__set_current_state(TASK_IDLE);\n\treturn schedule_timeout(timeout);\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/random.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/random.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nsigned long __sched schedule_timeout_idle(signed long timeout)\n{\n\t__set_current_state(TASK_IDLE);\n\treturn schedule_timeout(timeout);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_rcu_utilization",
          "args": [
            "TPS(\"Start CPU kthread@rcu_yield\")"
          ],
          "line": 2873
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPS",
          "args": [
            "\"Start CPU kthread@rcu_yield\""
          ],
          "line": 2873
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_rcu_utilization",
          "args": [
            "TPS(\"End CPU kthread@rcu_wait\")"
          ],
          "line": 2867
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPS",
          "args": [
            "\"End CPU kthread@rcu_wait\""
          ],
          "line": 2867
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_bh_enable",
          "args": [],
          "line": 2865
        },
        "resolved": true,
        "details": {
          "function_name": "_local_bh_enable",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/softirq.c",
          "lines": "353-357",
          "snippet": "void _local_bh_enable(void)\n{\n\tWARN_ON_ONCE(in_irq());\n\t__local_bh_enable(SOFTIRQ_DISABLE_OFFSET);\n}",
          "includes": [
            "#include <trace/events/irq.h>",
            "#include <asm/softirq_stack.h>",
            "#include <linux/wait_bit.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/smp.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/mm.h>",
            "#include <linux/local_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/irq.h>\n#include <asm/softirq_stack.h>\n#include <linux/wait_bit.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/smpboot.h>\n#include <linux/smp.h>\n#include <linux/ftrace.h>\n#include <linux/rcupdate.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/mm.h>\n#include <linux/local_lock.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/kernel_stat.h>\n#include <linux/export.h>\n\nvoid _local_bh_enable(void)\n{\n\tWARN_ON_ONCE(in_irq());\n\t__local_bh_enable(SOFTIRQ_DISABLE_OFFSET);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_core",
          "args": [],
          "line": 2864
        },
        "resolved": true,
        "details": {
          "function_name": "invoke_rcu_core",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "2824-2832",
          "snippet": "static void invoke_rcu_core(void)\n{\n\tif (!cpu_online(smp_processor_id()))\n\t\treturn;\n\tif (use_softirq)\n\t\traise_softirq(RCU_SOFTIRQ);\n\telse\n\t\tinvoke_rcu_core_kthread();\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool use_softirq = !IS_ENABLED(CONFIG_PREEMPT_RT);",
            "static void invoke_rcu_core(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic bool use_softirq = !IS_ENABLED(CONFIG_PREEMPT_RT);\nstatic void invoke_rcu_core(void);\n\nstatic void invoke_rcu_core(void)\n{\n\tif (!cpu_online(smp_processor_id()))\n\t\treturn;\n\tif (use_softirq)\n\t\traise_softirq(RCU_SOFTIRQ);\n\telse\n\t\tinvoke_rcu_core_kthread();\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_irq_enable",
          "args": [],
          "line": 2862
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_disable",
          "args": [],
          "line": 2859
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_bh_disable",
          "args": [],
          "line": 2857
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_rcu_utilization",
          "args": [
            "TPS(\"Start CPU kthread@rcu_run\")"
          ],
          "line": 2855
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPS",
          "args": [
            "\"Start CPU kthread@rcu_run\""
          ],
          "line": 2855
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&rcu_data.rcu_cpu_has_work"
          ],
          "line": 2852
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&rcu_data.rcu_cpu_kthread_status"
          ],
          "line": 2851
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};\nstatic void sync_sched_exp_online_cleanup(int cpu);\n\nstatic void rcu_cpu_kthread(unsigned int cpu)\n{\n\tunsigned int *statusp = this_cpu_ptr(&rcu_data.rcu_cpu_kthread_status);\n\tchar work, *workp = this_cpu_ptr(&rcu_data.rcu_cpu_has_work);\n\tint spincnt;\n\n\ttrace_rcu_utilization(TPS(\"Start CPU kthread@rcu_run\"));\n\tfor (spincnt = 0; spincnt < 10; spincnt++) {\n\t\tlocal_bh_disable();\n\t\t*statusp = RCU_KTHREAD_RUNNING;\n\t\tlocal_irq_disable();\n\t\twork = *workp;\n\t\t*workp = 0;\n\t\tlocal_irq_enable();\n\t\tif (work)\n\t\t\trcu_core();\n\t\tlocal_bh_enable();\n\t\tif (*workp == 0) {\n\t\t\ttrace_rcu_utilization(TPS(\"End CPU kthread@rcu_wait\"));\n\t\t\t*statusp = RCU_KTHREAD_WAITING;\n\t\t\treturn;\n\t\t}\n\t}\n\t*statusp = RCU_KTHREAD_YIELDING;\n\ttrace_rcu_utilization(TPS(\"Start CPU kthread@rcu_yield\"));\n\tschedule_timeout_idle(2);\n\ttrace_rcu_utilization(TPS(\"End CPU kthread@rcu_yield\"));\n\t*statusp = RCU_KTHREAD_WAITING;\n}"
  },
  {
    "function_name": "rcu_cpu_kthread_should_run",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
    "lines": "2839-2842",
    "snippet": "static int rcu_cpu_kthread_should_run(unsigned int cpu)\n{\n\treturn __this_cpu_read(rcu_data.rcu_cpu_has_work);\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_nocb.h\"",
      "#include \"tree_exp.h\"",
      "#include \"tree_stall.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <linux/kasan.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/panic_notifier.h>",
      "#include <linux/panic.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};",
      "static void sync_sched_exp_online_cleanup(int cpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__this_cpu_read",
          "args": [
            "rcu_data.rcu_cpu_has_work"
          ],
          "line": 2841
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};\nstatic void sync_sched_exp_online_cleanup(int cpu);\n\nstatic int rcu_cpu_kthread_should_run(unsigned int cpu)\n{\n\treturn __this_cpu_read(rcu_data.rcu_cpu_has_work);\n}"
  },
  {
    "function_name": "rcu_cpu_kthread_park",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
    "lines": "2834-2837",
    "snippet": "static void rcu_cpu_kthread_park(unsigned int cpu)\n{\n\tper_cpu(rcu_data.rcu_cpu_kthread_status, cpu) = RCU_KTHREAD_OFFCPU;\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_nocb.h\"",
      "#include \"tree_exp.h\"",
      "#include \"tree_stall.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <linux/kasan.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/panic_notifier.h>",
      "#include <linux/panic.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};",
      "static void sync_sched_exp_online_cleanup(int cpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "rcu_data.rcu_cpu_kthread_status",
            "cpu"
          ],
          "line": 2836
        },
        "resolved": true,
        "details": {
          "function_name": "kthread_set_per_cpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
          "lines": "588-603",
          "snippet": "void kthread_set_per_cpu(struct task_struct *k, int cpu)\n{\n\tstruct kthread *kthread = to_kthread(k);\n\tif (!kthread)\n\t\treturn;\n\n\tWARN_ON_ONCE(!(k->flags & PF_NO_SETAFFINITY));\n\n\tif (cpu < 0) {\n\t\tclear_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n\t\treturn;\n\t}\n\n\tkthread->cpu = cpu;\n\tset_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/numa.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mm.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nvoid kthread_set_per_cpu(struct task_struct *k, int cpu)\n{\n\tstruct kthread *kthread = to_kthread(k);\n\tif (!kthread)\n\t\treturn;\n\n\tWARN_ON_ONCE(!(k->flags & PF_NO_SETAFFINITY));\n\n\tif (cpu < 0) {\n\t\tclear_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n\t\treturn;\n\t}\n\n\tkthread->cpu = cpu;\n\tset_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};\nstatic void sync_sched_exp_online_cleanup(int cpu);\n\nstatic void rcu_cpu_kthread_park(unsigned int cpu)\n{\n\tper_cpu(rcu_data.rcu_cpu_kthread_status, cpu) = RCU_KTHREAD_OFFCPU;\n}"
  },
  {
    "function_name": "invoke_rcu_core",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
    "lines": "2824-2832",
    "snippet": "static void invoke_rcu_core(void)\n{\n\tif (!cpu_online(smp_processor_id()))\n\t\treturn;\n\tif (use_softirq)\n\t\traise_softirq(RCU_SOFTIRQ);\n\telse\n\t\tinvoke_rcu_core_kthread();\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_nocb.h\"",
      "#include \"tree_exp.h\"",
      "#include \"tree_stall.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <linux/kasan.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/panic_notifier.h>",
      "#include <linux/panic.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool use_softirq = !IS_ENABLED(CONFIG_PREEMPT_RT);",
      "static void invoke_rcu_core(void);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "invoke_rcu_core_kthread",
          "args": [],
          "line": 2831
        },
        "resolved": true,
        "details": {
          "function_name": "invoke_rcu_core_kthread",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "2808-2819",
          "snippet": "static void invoke_rcu_core_kthread(void)\n{\n\tstruct task_struct *t;\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__this_cpu_write(rcu_data.rcu_cpu_has_work, 1);\n\tt = __this_cpu_read(rcu_data.rcu_cpu_kthread_task);\n\tif (t != NULL && t != current)\n\t\trcu_wake_cond(t, __this_cpu_read(rcu_data.rcu_cpu_kthread_status));\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};",
            "static void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};\nstatic void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);\n\nstatic void invoke_rcu_core_kthread(void)\n{\n\tstruct task_struct *t;\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__this_cpu_write(rcu_data.rcu_cpu_has_work, 1);\n\tt = __this_cpu_read(rcu_data.rcu_cpu_kthread_task);\n\tif (t != NULL && t != current)\n\t\trcu_wake_cond(t, __this_cpu_read(rcu_data.rcu_cpu_kthread_status));\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raise_softirq",
          "args": [
            "RCU_SOFTIRQ"
          ],
          "line": 2829
        },
        "resolved": true,
        "details": {
          "function_name": "__raise_softirq_irqoff",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/softirq.c",
          "lines": "696-701",
          "snippet": "void __raise_softirq_irqoff(unsigned int nr)\n{\n\tlockdep_assert_irqs_disabled();\n\ttrace_softirq_raise(nr);\n\tor_softirq_pending(1UL << nr);\n}",
          "includes": [
            "#include <trace/events/irq.h>",
            "#include <asm/softirq_stack.h>",
            "#include <linux/wait_bit.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/smp.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/mm.h>",
            "#include <linux/local_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/irq.h>\n#include <asm/softirq_stack.h>\n#include <linux/wait_bit.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/smpboot.h>\n#include <linux/smp.h>\n#include <linux/ftrace.h>\n#include <linux/rcupdate.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/mm.h>\n#include <linux/local_lock.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/kernel_stat.h>\n#include <linux/export.h>\n\nvoid __raise_softirq_irqoff(unsigned int nr)\n{\n\tlockdep_assert_irqs_disabled();\n\ttrace_softirq_raise(nr);\n\tor_softirq_pending(1UL << nr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_online",
          "args": [
            "smp_processor_id()"
          ],
          "line": 2826
        },
        "resolved": true,
        "details": {
          "function_name": "init_cpu_online",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "2616-2619",
          "snippet": "void init_cpu_online(const struct cpumask *src)\n{\n\tcpumask_copy(&__cpu_online_mask, src);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct cpumask __cpu_online_mask"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstruct cpumask __cpu_online_mask;\n\nvoid init_cpu_online(const struct cpumask *src)\n{\n\tcpumask_copy(&__cpu_online_mask, src);\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 2826
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic bool use_softirq = !IS_ENABLED(CONFIG_PREEMPT_RT);\nstatic void invoke_rcu_core(void);\n\nstatic void invoke_rcu_core(void)\n{\n\tif (!cpu_online(smp_processor_id()))\n\t\treturn;\n\tif (use_softirq)\n\t\traise_softirq(RCU_SOFTIRQ);\n\telse\n\t\tinvoke_rcu_core_kthread();\n}"
  },
  {
    "function_name": "invoke_rcu_core_kthread",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
    "lines": "2808-2819",
    "snippet": "static void invoke_rcu_core_kthread(void)\n{\n\tstruct task_struct *t;\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__this_cpu_write(rcu_data.rcu_cpu_has_work, 1);\n\tt = __this_cpu_read(rcu_data.rcu_cpu_kthread_task);\n\tif (t != NULL && t != current)\n\t\trcu_wake_cond(t, __this_cpu_read(rcu_data.rcu_cpu_kthread_status));\n\tlocal_irq_restore(flags);\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_nocb.h\"",
      "#include \"tree_exp.h\"",
      "#include \"tree_stall.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <linux/kasan.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/panic_notifier.h>",
      "#include <linux/panic.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};",
      "static void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 2818
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_wake_cond",
          "args": [
            "t",
            "__this_cpu_read(rcu_data.rcu_cpu_kthread_status)"
          ],
          "line": 2817
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_wake_cond",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "2798-2806",
          "snippet": "static void rcu_wake_cond(struct task_struct *t, int status)\n{\n\t/*\n\t * If the thread is yielding, only wake it when this\n\t * is invoked from idle\n\t */\n\tif (t && (status != RCU_KTHREAD_YIELDING || is_idle_task(current)))\n\t\twake_up_process(t);\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic void rcu_wake_cond(struct task_struct *t, int status)\n{\n\t/*\n\t * If the thread is yielding, only wake it when this\n\t * is invoked from idle\n\t */\n\tif (t && (status != RCU_KTHREAD_YIELDING || is_idle_task(current)))\n\t\twake_up_process(t);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__this_cpu_read",
          "args": [
            "rcu_data.rcu_cpu_kthread_status"
          ],
          "line": 2817
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__this_cpu_read",
          "args": [
            "rcu_data.rcu_cpu_kthread_task"
          ],
          "line": 2815
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__this_cpu_write",
          "args": [
            "rcu_data.rcu_cpu_has_work",
            "1"
          ],
          "line": 2814
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_save",
          "args": [
            "flags"
          ],
          "line": 2813
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};\nstatic void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);\n\nstatic void invoke_rcu_core_kthread(void)\n{\n\tstruct task_struct *t;\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__this_cpu_write(rcu_data.rcu_cpu_has_work, 1);\n\tt = __this_cpu_read(rcu_data.rcu_cpu_kthread_task);\n\tif (t != NULL && t != current)\n\t\trcu_wake_cond(t, __this_cpu_read(rcu_data.rcu_cpu_kthread_status));\n\tlocal_irq_restore(flags);\n}"
  },
  {
    "function_name": "rcu_wake_cond",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
    "lines": "2798-2806",
    "snippet": "static void rcu_wake_cond(struct task_struct *t, int status)\n{\n\t/*\n\t * If the thread is yielding, only wake it when this\n\t * is invoked from idle\n\t */\n\tif (t && (status != RCU_KTHREAD_YIELDING || is_idle_task(current)))\n\t\twake_up_process(t);\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_nocb.h\"",
      "#include \"tree_exp.h\"",
      "#include \"tree_stall.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <linux/kasan.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/panic_notifier.h>",
      "#include <linux/panic.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wake_up_process",
          "args": [
            "t"
          ],
          "line": 2805
        },
        "resolved": true,
        "details": {
          "function_name": "wake_up_process",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "4215-4218",
          "snippet": "int wake_up_process(struct task_struct *p)\n{\n\treturn try_to_wake_up(p, TASK_NORMAL, 0);\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\nint wake_up_process(struct task_struct *p)\n{\n\treturn try_to_wake_up(p, TASK_NORMAL, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_idle_task",
          "args": [
            "current"
          ],
          "line": 2804
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic void rcu_wake_cond(struct task_struct *t, int status)\n{\n\t/*\n\t * If the thread is yielding, only wake it when this\n\t * is invoked from idle\n\t */\n\tif (t && (status != RCU_KTHREAD_YIELDING || is_idle_task(current)))\n\t\twake_up_process(t);\n}"
  },
  {
    "function_name": "rcu_core_si",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
    "lines": "2793-2796",
    "snippet": "static void rcu_core_si(struct softirq_action *h)\n{\n\trcu_core();\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_nocb.h\"",
      "#include \"tree_exp.h\"",
      "#include \"tree_stall.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <linux/kasan.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/panic_notifier.h>",
      "#include <linux/panic.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_core",
          "args": [],
          "line": 2795
        },
        "resolved": true,
        "details": {
          "function_name": "invoke_rcu_core",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "2824-2832",
          "snippet": "static void invoke_rcu_core(void)\n{\n\tif (!cpu_online(smp_processor_id()))\n\t\treturn;\n\tif (use_softirq)\n\t\traise_softirq(RCU_SOFTIRQ);\n\telse\n\t\tinvoke_rcu_core_kthread();\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool use_softirq = !IS_ENABLED(CONFIG_PREEMPT_RT);",
            "static void invoke_rcu_core(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic bool use_softirq = !IS_ENABLED(CONFIG_PREEMPT_RT);\nstatic void invoke_rcu_core(void);\n\nstatic void invoke_rcu_core(void)\n{\n\tif (!cpu_online(smp_processor_id()))\n\t\treturn;\n\tif (use_softirq)\n\t\traise_softirq(RCU_SOFTIRQ);\n\telse\n\t\tinvoke_rcu_core_kthread();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic void rcu_core_si(struct softirq_action *h)\n{\n\trcu_core();\n}"
  },
  {
    "function_name": "rcu_core",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
    "lines": "2724-2791",
    "snippet": "static __latent_entropy void rcu_core(void)\n{\n\tunsigned long flags;\n\tstruct rcu_data *rdp = raw_cpu_ptr(&rcu_data);\n\tstruct rcu_node *rnp = rdp->mynode;\n\t/*\n\t * On RT rcu_core() can be preempted when IRQs aren't disabled.\n\t * Therefore this function can race with concurrent NOCB (de-)offloading\n\t * on this CPU and the below condition must be considered volatile.\n\t * However if we race with:\n\t *\n\t * _ Offloading:   In the worst case we accelerate or process callbacks\n\t *                 concurrently with NOCB kthreads. We are guaranteed to\n\t *                 call rcu_nocb_lock() if that happens.\n\t *\n\t * _ Deoffloading: In the worst case we miss callbacks acceleration or\n\t *                 processing. This is fine because the early stage\n\t *                 of deoffloading invokes rcu_core() after setting\n\t *                 SEGCBLIST_RCU_CORE. So we guarantee that we'll process\n\t *                 what could have been dismissed without the need to wait\n\t *                 for the next rcu_pending() check in the next jiffy.\n\t */\n\tconst bool do_batch = !rcu_segcblist_completely_offloaded(&rdp->cblist);\n\n\tif (cpu_is_offline(smp_processor_id()))\n\t\treturn;\n\ttrace_rcu_utilization(TPS(\"Start RCU core\"));\n\tWARN_ON_ONCE(!rdp->beenonline);\n\n\t/* Report any deferred quiescent states if preemption enabled. */\n\tif (IS_ENABLED(CONFIG_PREEMPT_COUNT) && (!(preempt_count() & PREEMPT_MASK))) {\n\t\trcu_preempt_deferred_qs(current);\n\t} else if (rcu_preempt_need_deferred_qs(current)) {\n\t\tset_tsk_need_resched(current);\n\t\tset_preempt_need_resched();\n\t}\n\n\t/* Update RCU state based on any recent quiescent states. */\n\trcu_check_quiescent_state(rdp);\n\n\t/* No grace period and unregistered callbacks? */\n\tif (!rcu_gp_in_progress() &&\n\t    rcu_segcblist_is_enabled(&rdp->cblist) && do_batch) {\n\t\trcu_nocb_lock_irqsave(rdp, flags);\n\t\tif (!rcu_segcblist_restempty(&rdp->cblist, RCU_NEXT_READY_TAIL))\n\t\t\trcu_accelerate_cbs_unlocked(rnp, rdp);\n\t\trcu_nocb_unlock_irqrestore(rdp, flags);\n\t}\n\n\trcu_check_gp_start_stall(rnp, rdp, rcu_jiffies_till_stall_check());\n\n\t/* If there are callbacks ready, invoke them. */\n\tif (do_batch && rcu_segcblist_ready_cbs(&rdp->cblist) &&\n\t    likely(READ_ONCE(rcu_scheduler_fully_active))) {\n\t\trcu_do_batch(rdp);\n\t\t/* Re-invoke RCU core processing if there are callbacks remaining. */\n\t\tif (rcu_segcblist_ready_cbs(&rdp->cblist))\n\t\t\tinvoke_rcu_core();\n\t}\n\n\t/* Do any needed deferred wakeups of rcuo kthreads. */\n\tdo_nocb_deferred_wakeup(rdp);\n\ttrace_rcu_utilization(TPS(\"End RCU core\"));\n\n\t// If strict GPs, schedule an RCU reader in a clean environment.\n\tif (IS_ENABLED(CONFIG_RCU_STRICT_GRACE_PERIOD))\n\t\tqueue_work_on(rdp->cpu, rcu_gp_wq, &rdp->strict_work);\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_nocb.h\"",
      "#include \"tree_exp.h\"",
      "#include \"tree_stall.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <linux/kasan.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/panic_notifier.h>",
      "#include <linux/panic.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};",
      "static int rcu_scheduler_fully_active",
      "static void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);",
      "static void invoke_rcu_core(void);",
      "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
      "static void sync_sched_exp_online_cleanup(int cpu);",
      "static void check_cb_ovld_locked(struct rcu_data *rdp, struct rcu_node *rnp);",
      "static bool rcu_rdp_is_offloaded(struct rcu_data *rdp);",
      "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));",
      "struct workqueue_struct *rcu_gp_wq;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "queue_work_on",
          "args": [
            "rdp->cpu",
            "rcu_gp_wq",
            "&rdp->strict_work"
          ],
          "line": 2790
        },
        "resolved": true,
        "details": {
          "function_name": "queue_work_on",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "1553-1568",
          "snippet": "bool queue_work_on(int cpu, struct workqueue_struct *wq,\n\t\t   struct work_struct *work)\n{\n\tbool ret = false;\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\n\tif (!test_and_set_bit(WORK_STRUCT_PENDING_BIT, work_data_bits(work))) {\n\t\t__queue_work(cpu, wq, work);\n\t\tret = true;\n\t}\n\n\tlocal_irq_restore(flags);\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nbool queue_work_on(int cpu, struct workqueue_struct *wq,\n\t\t   struct work_struct *work)\n{\n\tbool ret = false;\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\n\tif (!test_and_set_bit(WORK_STRUCT_PENDING_BIT, work_data_bits(work))) {\n\t\t__queue_work(cpu, wq, work);\n\t\tret = true;\n\t}\n\n\tlocal_irq_restore(flags);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_RCU_STRICT_GRACE_PERIOD"
          ],
          "line": 2789
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_rcu_utilization",
          "args": [
            "TPS(\"End RCU core\")"
          ],
          "line": 2786
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPS",
          "args": [
            "\"End RCU core\""
          ],
          "line": 2786
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_nocb_deferred_wakeup",
          "args": [
            "rdp"
          ],
          "line": 2785
        },
        "resolved": true,
        "details": {
          "function_name": "do_nocb_deferred_wakeup",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_nocb.h",
          "lines": "1531-1534",
          "snippet": "static bool do_nocb_deferred_wakeup(struct rcu_data *rdp)\n{\n\treturn false;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static bool do_nocb_deferred_wakeup(struct rcu_data *rdp)\n{\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "invoke_rcu_core",
          "args": [],
          "line": 2781
        },
        "resolved": true,
        "details": {
          "function_name": "invoke_rcu_core",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "2824-2832",
          "snippet": "static void invoke_rcu_core(void)\n{\n\tif (!cpu_online(smp_processor_id()))\n\t\treturn;\n\tif (use_softirq)\n\t\traise_softirq(RCU_SOFTIRQ);\n\telse\n\t\tinvoke_rcu_core_kthread();\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool use_softirq = !IS_ENABLED(CONFIG_PREEMPT_RT);",
            "static void invoke_rcu_core(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic bool use_softirq = !IS_ENABLED(CONFIG_PREEMPT_RT);\nstatic void invoke_rcu_core(void);\n\nstatic void invoke_rcu_core(void)\n{\n\tif (!cpu_online(smp_processor_id()))\n\t\treturn;\n\tif (use_softirq)\n\t\traise_softirq(RCU_SOFTIRQ);\n\telse\n\t\tinvoke_rcu_core_kthread();\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_segcblist_ready_cbs",
          "args": [
            "&rdp->cblist"
          ],
          "line": 2780
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_ready_cbs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.c",
          "lines": "278-282",
          "snippet": "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp)\n{\n\treturn rcu_segcblist_is_enabled(rsclp) &&\n\t       &rsclp->head != READ_ONCE(rsclp->tails[RCU_DONE_TAIL]);\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/cpu.h>\n\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp)\n{\n\treturn rcu_segcblist_is_enabled(rsclp) &&\n\t       &rsclp->head != READ_ONCE(rsclp->tails[RCU_DONE_TAIL]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_do_batch",
          "args": [
            "rdp"
          ],
          "line": 2778
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_do_batch",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "2465-2592",
          "snippet": "static void rcu_do_batch(struct rcu_data *rdp)\n{\n\tint div;\n\tbool __maybe_unused empty;\n\tunsigned long flags;\n\tstruct rcu_head *rhp;\n\tstruct rcu_cblist rcl = RCU_CBLIST_INITIALIZER(rcl);\n\tlong bl, count = 0;\n\tlong pending, tlimit = 0;\n\n\t/* If no callbacks are ready, just return. */\n\tif (!rcu_segcblist_ready_cbs(&rdp->cblist)) {\n\t\ttrace_rcu_batch_start(rcu_state.name,\n\t\t\t\t      rcu_segcblist_n_cbs(&rdp->cblist), 0);\n\t\ttrace_rcu_batch_end(rcu_state.name, 0,\n\t\t\t\t    !rcu_segcblist_empty(&rdp->cblist),\n\t\t\t\t    need_resched(), is_idle_task(current),\n\t\t\t\t    rcu_is_callbacks_kthread());\n\t\treturn;\n\t}\n\n\t/*\n\t * Extract the list of ready callbacks, disabling IRQs to prevent\n\t * races with call_rcu() from interrupt handlers.  Leave the\n\t * callback counts, as rcu_barrier() needs to be conservative.\n\t */\n\trcu_nocb_lock_irqsave(rdp, flags);\n\tWARN_ON_ONCE(cpu_is_offline(smp_processor_id()));\n\tpending = rcu_segcblist_n_cbs(&rdp->cblist);\n\tdiv = READ_ONCE(rcu_divisor);\n\tdiv = div < 0 ? 7 : div > sizeof(long) * 8 - 2 ? sizeof(long) * 8 - 2 : div;\n\tbl = max(rdp->blimit, pending >> div);\n\tif (in_serving_softirq() && unlikely(bl > 100)) {\n\t\tlong rrn = READ_ONCE(rcu_resched_ns);\n\n\t\trrn = rrn < NSEC_PER_MSEC ? NSEC_PER_MSEC : rrn > NSEC_PER_SEC ? NSEC_PER_SEC : rrn;\n\t\ttlimit = local_clock() + rrn;\n\t}\n\ttrace_rcu_batch_start(rcu_state.name,\n\t\t\t      rcu_segcblist_n_cbs(&rdp->cblist), bl);\n\trcu_segcblist_extract_done_cbs(&rdp->cblist, &rcl);\n\tif (rcu_rdp_is_offloaded(rdp))\n\t\trdp->qlen_last_fqs_check = rcu_segcblist_n_cbs(&rdp->cblist);\n\n\ttrace_rcu_segcb_stats(&rdp->cblist, TPS(\"SegCbDequeued\"));\n\trcu_nocb_unlock_irqrestore(rdp, flags);\n\n\t/* Invoke callbacks. */\n\ttick_dep_set_task(current, TICK_DEP_BIT_RCU);\n\trhp = rcu_cblist_dequeue(&rcl);\n\n\tfor (; rhp; rhp = rcu_cblist_dequeue(&rcl)) {\n\t\trcu_callback_t f;\n\n\t\tcount++;\n\t\tdebug_rcu_head_unqueue(rhp);\n\n\t\trcu_lock_acquire(&rcu_callback_map);\n\t\ttrace_rcu_invoke_callback(rcu_state.name, rhp);\n\n\t\tf = rhp->func;\n\t\tWRITE_ONCE(rhp->func, (rcu_callback_t)0L);\n\t\tf(rhp);\n\n\t\trcu_lock_release(&rcu_callback_map);\n\n\t\t/*\n\t\t * Stop only if limit reached and CPU has something to do.\n\t\t */\n\t\tif (in_serving_softirq()) {\n\t\t\tif (count >= bl && (need_resched() || !is_idle_task(current)))\n\t\t\t\tbreak;\n\t\t\t/*\n\t\t\t * Make sure we don't spend too much time here and deprive other\n\t\t\t * softirq vectors of CPU cycles.\n\t\t\t */\n\t\t\tif (unlikely(tlimit)) {\n\t\t\t\t/* only call local_clock() every 32 callbacks */\n\t\t\t\tif (likely((count & 31) || local_clock() < tlimit))\n\t\t\t\t\tcontinue;\n\t\t\t\t/* Exceeded the time limit, so leave. */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tlocal_bh_enable();\n\t\t\tlockdep_assert_irqs_enabled();\n\t\t\tcond_resched_tasks_rcu_qs();\n\t\t\tlockdep_assert_irqs_enabled();\n\t\t\tlocal_bh_disable();\n\t\t}\n\t}\n\n\trcu_nocb_lock_irqsave(rdp, flags);\n\trdp->n_cbs_invoked += count;\n\ttrace_rcu_batch_end(rcu_state.name, count, !!rcl.head, need_resched(),\n\t\t\t    is_idle_task(current), rcu_is_callbacks_kthread());\n\n\t/* Update counts and requeue any remaining callbacks. */\n\trcu_segcblist_insert_done_cbs(&rdp->cblist, &rcl);\n\trcu_segcblist_add_len(&rdp->cblist, -count);\n\n\t/* Reinstate batch limit if we have worked down the excess. */\n\tcount = rcu_segcblist_n_cbs(&rdp->cblist);\n\tif (rdp->blimit >= DEFAULT_MAX_RCU_BLIMIT && count <= qlowmark)\n\t\trdp->blimit = blimit;\n\n\t/* Reset ->qlen_last_fqs_check trigger if enough CBs have drained. */\n\tif (count == 0 && rdp->qlen_last_fqs_check != 0) {\n\t\trdp->qlen_last_fqs_check = 0;\n\t\trdp->n_force_qs_snap = READ_ONCE(rcu_state.n_force_qs);\n\t} else if (count < rdp->qlen_last_fqs_check - qhimark)\n\t\trdp->qlen_last_fqs_check = count;\n\n\t/*\n\t * The following usually indicates a double call_rcu().  To track\n\t * this down, try building with CONFIG_DEBUG_OBJECTS_RCU_HEAD=y.\n\t */\n\tempty = rcu_segcblist_empty(&rdp->cblist);\n\tWARN_ON_ONCE(count == 0 && !empty);\n\tWARN_ON_ONCE(!IS_ENABLED(CONFIG_RCU_NOCB_CPU) &&\n\t\t     count != 0 && empty);\n\tWARN_ON_ONCE(count == 0 && rcu_segcblist_n_segment_cbs(&rdp->cblist) != 0);\n\tWARN_ON_ONCE(!empty && rcu_segcblist_n_segment_cbs(&rdp->cblist) == 0);\n\n\trcu_nocb_unlock_irqrestore(rdp, flags);\n\n\ttick_dep_clear_task(current, TICK_DEP_BIT_RCU);\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define DEFAULT_MAX_RCU_BLIMIT 10000 // ... even during callback flood."
          ],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};",
            "static struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};",
            "static void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);",
            "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
            "static bool rcu_rdp_is_offloaded(struct rcu_data *rdp);",
            "static long blimit = DEFAULT_RCU_BLIMIT;",
            "static long qhimark = DEFAULT_RCU_QHIMARK;",
            "static long qlowmark = DEFAULT_RCU_QLOMARK;",
            "static int rcu_divisor = 7;",
            "static long rcu_resched_ns = 3 * NSEC_PER_MSEC;",
            "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define DEFAULT_MAX_RCU_BLIMIT 10000 // ... even during callback flood.\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};\nstatic struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\nstatic void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic bool rcu_rdp_is_offloaded(struct rcu_data *rdp);\nstatic long blimit = DEFAULT_RCU_BLIMIT;\nstatic long qhimark = DEFAULT_RCU_QHIMARK;\nstatic long qlowmark = DEFAULT_RCU_QLOMARK;\nstatic int rcu_divisor = 7;\nstatic long rcu_resched_ns = 3 * NSEC_PER_MSEC;\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nstatic void rcu_do_batch(struct rcu_data *rdp)\n{\n\tint div;\n\tbool __maybe_unused empty;\n\tunsigned long flags;\n\tstruct rcu_head *rhp;\n\tstruct rcu_cblist rcl = RCU_CBLIST_INITIALIZER(rcl);\n\tlong bl, count = 0;\n\tlong pending, tlimit = 0;\n\n\t/* If no callbacks are ready, just return. */\n\tif (!rcu_segcblist_ready_cbs(&rdp->cblist)) {\n\t\ttrace_rcu_batch_start(rcu_state.name,\n\t\t\t\t      rcu_segcblist_n_cbs(&rdp->cblist), 0);\n\t\ttrace_rcu_batch_end(rcu_state.name, 0,\n\t\t\t\t    !rcu_segcblist_empty(&rdp->cblist),\n\t\t\t\t    need_resched(), is_idle_task(current),\n\t\t\t\t    rcu_is_callbacks_kthread());\n\t\treturn;\n\t}\n\n\t/*\n\t * Extract the list of ready callbacks, disabling IRQs to prevent\n\t * races with call_rcu() from interrupt handlers.  Leave the\n\t * callback counts, as rcu_barrier() needs to be conservative.\n\t */\n\trcu_nocb_lock_irqsave(rdp, flags);\n\tWARN_ON_ONCE(cpu_is_offline(smp_processor_id()));\n\tpending = rcu_segcblist_n_cbs(&rdp->cblist);\n\tdiv = READ_ONCE(rcu_divisor);\n\tdiv = div < 0 ? 7 : div > sizeof(long) * 8 - 2 ? sizeof(long) * 8 - 2 : div;\n\tbl = max(rdp->blimit, pending >> div);\n\tif (in_serving_softirq() && unlikely(bl > 100)) {\n\t\tlong rrn = READ_ONCE(rcu_resched_ns);\n\n\t\trrn = rrn < NSEC_PER_MSEC ? NSEC_PER_MSEC : rrn > NSEC_PER_SEC ? NSEC_PER_SEC : rrn;\n\t\ttlimit = local_clock() + rrn;\n\t}\n\ttrace_rcu_batch_start(rcu_state.name,\n\t\t\t      rcu_segcblist_n_cbs(&rdp->cblist), bl);\n\trcu_segcblist_extract_done_cbs(&rdp->cblist, &rcl);\n\tif (rcu_rdp_is_offloaded(rdp))\n\t\trdp->qlen_last_fqs_check = rcu_segcblist_n_cbs(&rdp->cblist);\n\n\ttrace_rcu_segcb_stats(&rdp->cblist, TPS(\"SegCbDequeued\"));\n\trcu_nocb_unlock_irqrestore(rdp, flags);\n\n\t/* Invoke callbacks. */\n\ttick_dep_set_task(current, TICK_DEP_BIT_RCU);\n\trhp = rcu_cblist_dequeue(&rcl);\n\n\tfor (; rhp; rhp = rcu_cblist_dequeue(&rcl)) {\n\t\trcu_callback_t f;\n\n\t\tcount++;\n\t\tdebug_rcu_head_unqueue(rhp);\n\n\t\trcu_lock_acquire(&rcu_callback_map);\n\t\ttrace_rcu_invoke_callback(rcu_state.name, rhp);\n\n\t\tf = rhp->func;\n\t\tWRITE_ONCE(rhp->func, (rcu_callback_t)0L);\n\t\tf(rhp);\n\n\t\trcu_lock_release(&rcu_callback_map);\n\n\t\t/*\n\t\t * Stop only if limit reached and CPU has something to do.\n\t\t */\n\t\tif (in_serving_softirq()) {\n\t\t\tif (count >= bl && (need_resched() || !is_idle_task(current)))\n\t\t\t\tbreak;\n\t\t\t/*\n\t\t\t * Make sure we don't spend too much time here and deprive other\n\t\t\t * softirq vectors of CPU cycles.\n\t\t\t */\n\t\t\tif (unlikely(tlimit)) {\n\t\t\t\t/* only call local_clock() every 32 callbacks */\n\t\t\t\tif (likely((count & 31) || local_clock() < tlimit))\n\t\t\t\t\tcontinue;\n\t\t\t\t/* Exceeded the time limit, so leave. */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tlocal_bh_enable();\n\t\t\tlockdep_assert_irqs_enabled();\n\t\t\tcond_resched_tasks_rcu_qs();\n\t\t\tlockdep_assert_irqs_enabled();\n\t\t\tlocal_bh_disable();\n\t\t}\n\t}\n\n\trcu_nocb_lock_irqsave(rdp, flags);\n\trdp->n_cbs_invoked += count;\n\ttrace_rcu_batch_end(rcu_state.name, count, !!rcl.head, need_resched(),\n\t\t\t    is_idle_task(current), rcu_is_callbacks_kthread());\n\n\t/* Update counts and requeue any remaining callbacks. */\n\trcu_segcblist_insert_done_cbs(&rdp->cblist, &rcl);\n\trcu_segcblist_add_len(&rdp->cblist, -count);\n\n\t/* Reinstate batch limit if we have worked down the excess. */\n\tcount = rcu_segcblist_n_cbs(&rdp->cblist);\n\tif (rdp->blimit >= DEFAULT_MAX_RCU_BLIMIT && count <= qlowmark)\n\t\trdp->blimit = blimit;\n\n\t/* Reset ->qlen_last_fqs_check trigger if enough CBs have drained. */\n\tif (count == 0 && rdp->qlen_last_fqs_check != 0) {\n\t\trdp->qlen_last_fqs_check = 0;\n\t\trdp->n_force_qs_snap = READ_ONCE(rcu_state.n_force_qs);\n\t} else if (count < rdp->qlen_last_fqs_check - qhimark)\n\t\trdp->qlen_last_fqs_check = count;\n\n\t/*\n\t * The following usually indicates a double call_rcu().  To track\n\t * this down, try building with CONFIG_DEBUG_OBJECTS_RCU_HEAD=y.\n\t */\n\tempty = rcu_segcblist_empty(&rdp->cblist);\n\tWARN_ON_ONCE(count == 0 && !empty);\n\tWARN_ON_ONCE(!IS_ENABLED(CONFIG_RCU_NOCB_CPU) &&\n\t\t     count != 0 && empty);\n\tWARN_ON_ONCE(count == 0 && rcu_segcblist_n_segment_cbs(&rdp->cblist) != 0);\n\tWARN_ON_ONCE(!empty && rcu_segcblist_n_segment_cbs(&rdp->cblist) == 0);\n\n\trcu_nocb_unlock_irqrestore(rdp, flags);\n\n\ttick_dep_clear_task(current, TICK_DEP_BIT_RCU);\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "READ_ONCE(rcu_scheduler_fully_active)"
          ],
          "line": 2777
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rcu_scheduler_fully_active"
          ],
          "line": 2777
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_check_gp_start_stall",
          "args": [
            "rnp",
            "rdp",
            "rcu_jiffies_till_stall_check()"
          ],
          "line": 2773
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_check_gp_start_stall",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_stall.h",
          "lines": "851-903",
          "snippet": "static void rcu_check_gp_start_stall(struct rcu_node *rnp, struct rcu_data *rdp,\n\t\t\t\t     const unsigned long gpssdelay)\n{\n\tunsigned long flags;\n\tunsigned long j;\n\tstruct rcu_node *rnp_root = rcu_get_root();\n\tstatic atomic_t warned = ATOMIC_INIT(0);\n\n\tif (!IS_ENABLED(CONFIG_PROVE_RCU) || rcu_gp_in_progress() ||\n\t    ULONG_CMP_GE(READ_ONCE(rnp_root->gp_seq),\n\t\t\t READ_ONCE(rnp_root->gp_seq_needed)) ||\n\t    !smp_load_acquire(&rcu_state.gp_kthread)) // Get stable kthread.\n\t\treturn;\n\tj = jiffies; /* Expensive access, and in common case don't get here. */\n\tif (time_before(j, READ_ONCE(rcu_state.gp_req_activity) + gpssdelay) ||\n\t    time_before(j, READ_ONCE(rcu_state.gp_activity) + gpssdelay) ||\n\t    atomic_read(&warned))\n\t\treturn;\n\n\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\tj = jiffies;\n\tif (rcu_gp_in_progress() ||\n\t    ULONG_CMP_GE(READ_ONCE(rnp_root->gp_seq),\n\t\t\t READ_ONCE(rnp_root->gp_seq_needed)) ||\n\t    time_before(j, READ_ONCE(rcu_state.gp_req_activity) + gpssdelay) ||\n\t    time_before(j, READ_ONCE(rcu_state.gp_activity) + gpssdelay) ||\n\t    atomic_read(&warned)) {\n\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\treturn;\n\t}\n\t/* Hold onto the leaf lock to make others see warned==1. */\n\n\tif (rnp_root != rnp)\n\t\traw_spin_lock_rcu_node(rnp_root); /* irqs already disabled. */\n\tj = jiffies;\n\tif (rcu_gp_in_progress() ||\n\t    ULONG_CMP_GE(READ_ONCE(rnp_root->gp_seq),\n\t\t\t READ_ONCE(rnp_root->gp_seq_needed)) ||\n\t    time_before(j, READ_ONCE(rcu_state.gp_req_activity) + gpssdelay) ||\n\t    time_before(j, READ_ONCE(rcu_state.gp_activity) + gpssdelay) ||\n\t    atomic_xchg(&warned, 1)) {\n\t\tif (rnp_root != rnp)\n\t\t\t/* irqs remain disabled. */\n\t\t\traw_spin_unlock_rcu_node(rnp_root);\n\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\treturn;\n\t}\n\tWARN_ON(1);\n\tif (rnp_root != rnp)\n\t\traw_spin_unlock_rcu_node(rnp_root);\n\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\tshow_rcu_gp_kthreads();\n}",
          "includes": [
            "#include <linux/kvm_para.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_para.h>\n\nstatic void rcu_check_gp_start_stall(struct rcu_node *rnp, struct rcu_data *rdp,\n\t\t\t\t     const unsigned long gpssdelay)\n{\n\tunsigned long flags;\n\tunsigned long j;\n\tstruct rcu_node *rnp_root = rcu_get_root();\n\tstatic atomic_t warned = ATOMIC_INIT(0);\n\n\tif (!IS_ENABLED(CONFIG_PROVE_RCU) || rcu_gp_in_progress() ||\n\t    ULONG_CMP_GE(READ_ONCE(rnp_root->gp_seq),\n\t\t\t READ_ONCE(rnp_root->gp_seq_needed)) ||\n\t    !smp_load_acquire(&rcu_state.gp_kthread)) // Get stable kthread.\n\t\treturn;\n\tj = jiffies; /* Expensive access, and in common case don't get here. */\n\tif (time_before(j, READ_ONCE(rcu_state.gp_req_activity) + gpssdelay) ||\n\t    time_before(j, READ_ONCE(rcu_state.gp_activity) + gpssdelay) ||\n\t    atomic_read(&warned))\n\t\treturn;\n\n\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\tj = jiffies;\n\tif (rcu_gp_in_progress() ||\n\t    ULONG_CMP_GE(READ_ONCE(rnp_root->gp_seq),\n\t\t\t READ_ONCE(rnp_root->gp_seq_needed)) ||\n\t    time_before(j, READ_ONCE(rcu_state.gp_req_activity) + gpssdelay) ||\n\t    time_before(j, READ_ONCE(rcu_state.gp_activity) + gpssdelay) ||\n\t    atomic_read(&warned)) {\n\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\treturn;\n\t}\n\t/* Hold onto the leaf lock to make others see warned==1. */\n\n\tif (rnp_root != rnp)\n\t\traw_spin_lock_rcu_node(rnp_root); /* irqs already disabled. */\n\tj = jiffies;\n\tif (rcu_gp_in_progress() ||\n\t    ULONG_CMP_GE(READ_ONCE(rnp_root->gp_seq),\n\t\t\t READ_ONCE(rnp_root->gp_seq_needed)) ||\n\t    time_before(j, READ_ONCE(rcu_state.gp_req_activity) + gpssdelay) ||\n\t    time_before(j, READ_ONCE(rcu_state.gp_activity) + gpssdelay) ||\n\t    atomic_xchg(&warned, 1)) {\n\t\tif (rnp_root != rnp)\n\t\t\t/* irqs remain disabled. */\n\t\t\traw_spin_unlock_rcu_node(rnp_root);\n\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\treturn;\n\t}\n\tWARN_ON(1);\n\tif (rnp_root != rnp)\n\t\traw_spin_unlock_rcu_node(rnp_root);\n\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\tshow_rcu_gp_kthreads();\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_jiffies_till_stall_check",
          "args": [],
          "line": 2773
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_jiffies_till_stall_check",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_stall.h",
          "lines": "29-45",
          "snippet": "int rcu_jiffies_till_stall_check(void)\n{\n\tint till_stall_check = READ_ONCE(rcu_cpu_stall_timeout);\n\n\t/*\n\t * Limit check must be consistent with the Kconfig limits\n\t * for CONFIG_RCU_CPU_STALL_TIMEOUT.\n\t */\n\tif (till_stall_check < 3) {\n\t\tWRITE_ONCE(rcu_cpu_stall_timeout, 3);\n\t\ttill_stall_check = 3;\n\t} else if (till_stall_check > 300) {\n\t\tWRITE_ONCE(rcu_cpu_stall_timeout, 300);\n\t\ttill_stall_check = 300;\n\t}\n\treturn till_stall_check * HZ + RCU_STALL_DELAY_DELTA;\n}",
          "includes": [
            "#include <linux/kvm_para.h>"
          ],
          "macros_used": [
            "#define RCU_STALL_DELAY_DELTA\t\t0",
            "#define RCU_STALL_DELAY_DELTA\t\t(5 * HZ)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_para.h>\n\n#define RCU_STALL_DELAY_DELTA\t\t0\n#define RCU_STALL_DELAY_DELTA\t\t(5 * HZ)\n\nint rcu_jiffies_till_stall_check(void)\n{\n\tint till_stall_check = READ_ONCE(rcu_cpu_stall_timeout);\n\n\t/*\n\t * Limit check must be consistent with the Kconfig limits\n\t * for CONFIG_RCU_CPU_STALL_TIMEOUT.\n\t */\n\tif (till_stall_check < 3) {\n\t\tWRITE_ONCE(rcu_cpu_stall_timeout, 3);\n\t\ttill_stall_check = 3;\n\t} else if (till_stall_check > 300) {\n\t\tWRITE_ONCE(rcu_cpu_stall_timeout, 300);\n\t\ttill_stall_check = 300;\n\t}\n\treturn till_stall_check * HZ + RCU_STALL_DELAY_DELTA;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_nocb_unlock_irqrestore",
          "args": [
            "rdp",
            "flags"
          ],
          "line": 2770
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_nocb_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_nocb.h",
          "lines": "1479-1483",
          "snippet": "static void rcu_nocb_unlock_irqrestore(struct rcu_data *rdp,\n\t\t\t\t       unsigned long flags)\n{\n\tlocal_irq_restore(flags);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static void rcu_nocb_unlock_irqrestore(struct rcu_data *rdp,\n\t\t\t\t       unsigned long flags)\n{\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_accelerate_cbs_unlocked",
          "args": [
            "rnp",
            "rdp"
          ],
          "line": 2769
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_accelerate_cbs_unlocked",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "1543-1561",
          "snippet": "static void rcu_accelerate_cbs_unlocked(struct rcu_node *rnp,\n\t\t\t\t\tstruct rcu_data *rdp)\n{\n\tunsigned long c;\n\tbool needwake;\n\n\trcu_lockdep_assert_cblist_protected(rdp);\n\tc = rcu_seq_snap(&rcu_state.gp_seq);\n\tif (!READ_ONCE(rdp->gpwrap) && ULONG_CMP_GE(rdp->gp_seq_needed, c)) {\n\t\t/* Old request still live, so mark recent callbacks. */\n\t\t(void)rcu_segcblist_accelerate(&rdp->cblist, c);\n\t\treturn;\n\t}\n\traw_spin_lock_rcu_node(rnp); /* irqs already disabled. */\n\tneedwake = rcu_accelerate_cbs(rnp, rdp);\n\traw_spin_unlock_rcu_node(rnp); /* irqs remain disabled. */\n\tif (needwake)\n\t\trcu_gp_kthread_wake();\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};",
            "static struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};",
            "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
            "static void check_cb_ovld_locked(struct rcu_data *rdp, struct rcu_node *rnp);",
            "static bool rcu_rdp_is_offloaded(struct rcu_data *rdp);",
            "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};\nstatic struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void check_cb_ovld_locked(struct rcu_data *rdp, struct rcu_node *rnp);\nstatic bool rcu_rdp_is_offloaded(struct rcu_data *rdp);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nstatic void rcu_accelerate_cbs_unlocked(struct rcu_node *rnp,\n\t\t\t\t\tstruct rcu_data *rdp)\n{\n\tunsigned long c;\n\tbool needwake;\n\n\trcu_lockdep_assert_cblist_protected(rdp);\n\tc = rcu_seq_snap(&rcu_state.gp_seq);\n\tif (!READ_ONCE(rdp->gpwrap) && ULONG_CMP_GE(rdp->gp_seq_needed, c)) {\n\t\t/* Old request still live, so mark recent callbacks. */\n\t\t(void)rcu_segcblist_accelerate(&rdp->cblist, c);\n\t\treturn;\n\t}\n\traw_spin_lock_rcu_node(rnp); /* irqs already disabled. */\n\tneedwake = rcu_accelerate_cbs(rnp, rdp);\n\traw_spin_unlock_rcu_node(rnp); /* irqs remain disabled. */\n\tif (needwake)\n\t\trcu_gp_kthread_wake();\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_segcblist_restempty",
          "args": [
            "&rdp->cblist",
            "RCU_NEXT_READY_TAIL"
          ],
          "line": 2768
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_restempty",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "110-113",
          "snippet": "static inline bool rcu_segcblist_restempty(struct rcu_segcblist *rsclp, int seg)\n{\n\treturn !READ_ONCE(*READ_ONCE(rsclp->tails[seg]));\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "long rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nlong rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_restempty(struct rcu_segcblist *rsclp, int seg)\n{\n\treturn !READ_ONCE(*READ_ONCE(rsclp->tails[seg]));\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_nocb_lock_irqsave",
          "args": [
            "rdp",
            "flags"
          ],
          "line": 2767
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_segcblist_is_enabled",
          "args": [
            "&rdp->cblist"
          ],
          "line": 2766
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_is_enabled",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "78-81",
          "snippet": "static inline bool rcu_segcblist_is_enabled(struct rcu_segcblist *rsclp)\n{\n\treturn rcu_segcblist_test_flags(rsclp, SEGCBLIST_ENABLED);\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "long rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nlong rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_is_enabled(struct rcu_segcblist *rsclp)\n{\n\treturn rcu_segcblist_test_flags(rsclp, SEGCBLIST_ENABLED);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_gp_in_progress",
          "args": [],
          "line": 2765
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_gp_in_progress",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "229-232",
          "snippet": "static int rcu_gp_in_progress(void)\n{\n\treturn rcu_seq_state(rcu_seq_current(&rcu_state.gp_seq));\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\n\nstatic int rcu_gp_in_progress(void)\n{\n\treturn rcu_seq_state(rcu_seq_current(&rcu_state.gp_seq));\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_check_quiescent_state",
          "args": [
            "rdp"
          ],
          "line": 2762
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_check_quiescent_state",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "2348-2373",
          "snippet": "static void\nrcu_check_quiescent_state(struct rcu_data *rdp)\n{\n\t/* Check for grace-period ends and beginnings. */\n\tnote_gp_changes(rdp);\n\n\t/*\n\t * Does this CPU still need to do its part for current grace period?\n\t * If no, return and let the other CPUs do their part as well.\n\t */\n\tif (!rdp->core_needs_qs)\n\t\treturn;\n\n\t/*\n\t * Was there a quiescent state since the beginning of the grace\n\t * period? If no, then exit and wait for the next call.\n\t */\n\tif (rdp->cpu_no_qs.b.norm)\n\t\treturn;\n\n\t/*\n\t * Tell RCU we are done (but rcu_report_qs_rdp() will be the\n\t * judge of that).\n\t */\n\trcu_report_qs_rdp(rdp);\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};",
            "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
            "static bool rcu_rdp_is_offloaded(struct rcu_data *rdp);",
            "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic bool rcu_rdp_is_offloaded(struct rcu_data *rdp);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nstatic void\nrcu_check_quiescent_state(struct rcu_data *rdp)\n{\n\t/* Check for grace-period ends and beginnings. */\n\tnote_gp_changes(rdp);\n\n\t/*\n\t * Does this CPU still need to do its part for current grace period?\n\t * If no, return and let the other CPUs do their part as well.\n\t */\n\tif (!rdp->core_needs_qs)\n\t\treturn;\n\n\t/*\n\t * Was there a quiescent state since the beginning of the grace\n\t * period? If no, then exit and wait for the next call.\n\t */\n\tif (rdp->cpu_no_qs.b.norm)\n\t\treturn;\n\n\t/*\n\t * Tell RCU we are done (but rcu_report_qs_rdp() will be the\n\t * judge of that).\n\t */\n\trcu_report_qs_rdp(rdp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_preempt_need_resched",
          "args": [],
          "line": 2758
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_tsk_need_resched",
          "args": [
            "current"
          ],
          "line": 2757
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_preempt_need_deferred_qs",
          "args": [
            "current"
          ],
          "line": 2756
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_preempt_need_deferred_qs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "924-927",
          "snippet": "static bool rcu_preempt_need_deferred_qs(struct task_struct *t)\n{\n\treturn false;\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nstatic bool rcu_preempt_need_deferred_qs(struct task_struct *t)\n{\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_preempt_deferred_qs",
          "args": [
            "current"
          ],
          "line": 2755
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_preempt_deferred_qs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "933-939",
          "snippet": "static void rcu_preempt_deferred_qs(struct task_struct *t)\n{\n\tstruct rcu_data *rdp = this_cpu_ptr(&rcu_data);\n\n\tif (rdp->cpu_no_qs.b.exp)\n\t\trcu_report_exp_rdp(rdp);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nstatic void rcu_preempt_deferred_qs(struct task_struct *t)\n{\n\tstruct rcu_data *rdp = this_cpu_ptr(&rcu_data);\n\n\tif (rdp->cpu_no_qs.b.exp)\n\t\trcu_report_exp_rdp(rdp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "preempt_count",
          "args": [],
          "line": 2754
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_PREEMPT_COUNT"
          ],
          "line": 2754
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!rdp->beenonline"
          ],
          "line": 2751
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_rcu_utilization",
          "args": [
            "TPS(\"Start RCU core\")"
          ],
          "line": 2750
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPS",
          "args": [
            "\"Start RCU core\""
          ],
          "line": 2750
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_is_offline",
          "args": [
            "smp_processor_id()"
          ],
          "line": 2748
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 2748
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_segcblist_completely_offloaded",
          "args": [
            "&rdp->cblist"
          ],
          "line": 2746
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_completely_offloaded",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "96-103",
          "snippet": "static inline bool rcu_segcblist_completely_offloaded(struct rcu_segcblist *rsclp)\n{\n\tif (IS_ENABLED(CONFIG_RCU_NOCB_CPU) &&\n\t    !rcu_segcblist_test_flags(rsclp, SEGCBLIST_RCU_CORE))\n\t\treturn true;\n\n\treturn false;\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "long rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nlong rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_completely_offloaded(struct rcu_segcblist *rsclp)\n{\n\tif (IS_ENABLED(CONFIG_RCU_NOCB_CPU) &&\n\t    !rcu_segcblist_test_flags(rsclp, SEGCBLIST_RCU_CORE))\n\t\treturn true;\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_cpu_ptr",
          "args": [
            "&rcu_data"
          ],
          "line": 2727
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};\nstatic int rcu_scheduler_fully_active;\nstatic void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);\nstatic void invoke_rcu_core(void);\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void sync_sched_exp_online_cleanup(int cpu);\nstatic void check_cb_ovld_locked(struct rcu_data *rdp, struct rcu_node *rnp);\nstatic bool rcu_rdp_is_offloaded(struct rcu_data *rdp);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\nstruct workqueue_struct *rcu_gp_wq;\n\nstatic __latent_entropy void rcu_core(void)\n{\n\tunsigned long flags;\n\tstruct rcu_data *rdp = raw_cpu_ptr(&rcu_data);\n\tstruct rcu_node *rnp = rdp->mynode;\n\t/*\n\t * On RT rcu_core() can be preempted when IRQs aren't disabled.\n\t * Therefore this function can race with concurrent NOCB (de-)offloading\n\t * on this CPU and the below condition must be considered volatile.\n\t * However if we race with:\n\t *\n\t * _ Offloading:   In the worst case we accelerate or process callbacks\n\t *                 concurrently with NOCB kthreads. We are guaranteed to\n\t *                 call rcu_nocb_lock() if that happens.\n\t *\n\t * _ Deoffloading: In the worst case we miss callbacks acceleration or\n\t *                 processing. This is fine because the early stage\n\t *                 of deoffloading invokes rcu_core() after setting\n\t *                 SEGCBLIST_RCU_CORE. So we guarantee that we'll process\n\t *                 what could have been dismissed without the need to wait\n\t *                 for the next rcu_pending() check in the next jiffy.\n\t */\n\tconst bool do_batch = !rcu_segcblist_completely_offloaded(&rdp->cblist);\n\n\tif (cpu_is_offline(smp_processor_id()))\n\t\treturn;\n\ttrace_rcu_utilization(TPS(\"Start RCU core\"));\n\tWARN_ON_ONCE(!rdp->beenonline);\n\n\t/* Report any deferred quiescent states if preemption enabled. */\n\tif (IS_ENABLED(CONFIG_PREEMPT_COUNT) && (!(preempt_count() & PREEMPT_MASK))) {\n\t\trcu_preempt_deferred_qs(current);\n\t} else if (rcu_preempt_need_deferred_qs(current)) {\n\t\tset_tsk_need_resched(current);\n\t\tset_preempt_need_resched();\n\t}\n\n\t/* Update RCU state based on any recent quiescent states. */\n\trcu_check_quiescent_state(rdp);\n\n\t/* No grace period and unregistered callbacks? */\n\tif (!rcu_gp_in_progress() &&\n\t    rcu_segcblist_is_enabled(&rdp->cblist) && do_batch) {\n\t\trcu_nocb_lock_irqsave(rdp, flags);\n\t\tif (!rcu_segcblist_restempty(&rdp->cblist, RCU_NEXT_READY_TAIL))\n\t\t\trcu_accelerate_cbs_unlocked(rnp, rdp);\n\t\trcu_nocb_unlock_irqrestore(rdp, flags);\n\t}\n\n\trcu_check_gp_start_stall(rnp, rdp, rcu_jiffies_till_stall_check());\n\n\t/* If there are callbacks ready, invoke them. */\n\tif (do_batch && rcu_segcblist_ready_cbs(&rdp->cblist) &&\n\t    likely(READ_ONCE(rcu_scheduler_fully_active))) {\n\t\trcu_do_batch(rdp);\n\t\t/* Re-invoke RCU core processing if there are callbacks remaining. */\n\t\tif (rcu_segcblist_ready_cbs(&rdp->cblist))\n\t\t\tinvoke_rcu_core();\n\t}\n\n\t/* Do any needed deferred wakeups of rcuo kthreads. */\n\tdo_nocb_deferred_wakeup(rdp);\n\ttrace_rcu_utilization(TPS(\"End RCU core\"));\n\n\t// If strict GPs, schedule an RCU reader in a clean environment.\n\tif (IS_ENABLED(CONFIG_RCU_STRICT_GRACE_PERIOD))\n\t\tqueue_work_on(rdp->cpu, rcu_gp_wq, &rdp->strict_work);\n}"
  },
  {
    "function_name": "strict_work_handler",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
    "lines": "2717-2721",
    "snippet": "static void strict_work_handler(struct work_struct *work)\n{\n\trcu_read_lock();\n\trcu_read_unlock();\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_nocb.h\"",
      "#include \"tree_exp.h\"",
      "#include \"tree_stall.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <linux/kasan.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/panic_notifier.h>",
      "#include <linux/panic.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 2720
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_unlock_strict",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "815-824",
          "snippet": "void rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nvoid rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 2719
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_any_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "340-351",
          "snippet": "int rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic void strict_work_handler(struct work_struct *work)\n{\n\trcu_read_lock();\n\trcu_read_unlock();\n}"
  },
  {
    "function_name": "rcu_force_quiescent_state",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
    "lines": "2681-2712",
    "snippet": "void rcu_force_quiescent_state(void)\n{\n\tunsigned long flags;\n\tbool ret;\n\tstruct rcu_node *rnp;\n\tstruct rcu_node *rnp_old = NULL;\n\n\t/* Funnel through hierarchy to reduce memory contention. */\n\trnp = __this_cpu_read(rcu_data.mynode);\n\tfor (; rnp != NULL; rnp = rnp->parent) {\n\t\tret = (READ_ONCE(rcu_state.gp_flags) & RCU_GP_FLAG_FQS) ||\n\t\t       !raw_spin_trylock(&rnp->fqslock);\n\t\tif (rnp_old != NULL)\n\t\t\traw_spin_unlock(&rnp_old->fqslock);\n\t\tif (ret)\n\t\t\treturn;\n\t\trnp_old = rnp;\n\t}\n\t/* rnp_old == rcu_get_root(), rnp == NULL. */\n\n\t/* Reached the root of the rcu_node tree, acquire lock. */\n\traw_spin_lock_irqsave_rcu_node(rnp_old, flags);\n\traw_spin_unlock(&rnp_old->fqslock);\n\tif (READ_ONCE(rcu_state.gp_flags) & RCU_GP_FLAG_FQS) {\n\t\traw_spin_unlock_irqrestore_rcu_node(rnp_old, flags);\n\t\treturn;  /* Someone beat us to it. */\n\t}\n\tWRITE_ONCE(rcu_state.gp_flags,\n\t\t   READ_ONCE(rcu_state.gp_flags) | RCU_GP_FLAG_FQS);\n\traw_spin_unlock_irqrestore_rcu_node(rnp_old, flags);\n\trcu_gp_kthread_wake();\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_nocb.h\"",
      "#include \"tree_exp.h\"",
      "#include \"tree_stall.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <linux/kasan.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/panic_notifier.h>",
      "#include <linux/panic.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};",
      "static struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};",
      "static void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);",
      "static void check_cb_ovld_locked(struct rcu_data *rdp, struct rcu_node *rnp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_gp_kthread_wake",
          "args": [],
          "line": 2711
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_gp_kthread_wake",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "1473-1483",
          "snippet": "static void rcu_gp_kthread_wake(void)\n{\n\tstruct task_struct *t = READ_ONCE(rcu_state.gp_kthread);\n\n\tif ((current == t && !in_hardirq() && !in_serving_softirq()) ||\n\t    !READ_ONCE(rcu_state.gp_flags) || !t)\n\t\treturn;\n\tWRITE_ONCE(rcu_state.gp_wake_time, jiffies);\n\tWRITE_ONCE(rcu_state.gp_wake_seq, READ_ONCE(rcu_state.gp_seq));\n\tswake_up_one(&rcu_state.gp_wq);\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\n\nstatic void rcu_gp_kthread_wake(void)\n{\n\tstruct task_struct *t = READ_ONCE(rcu_state.gp_kthread);\n\n\tif ((current == t && !in_hardirq() && !in_serving_softirq()) ||\n\t    !READ_ONCE(rcu_state.gp_flags) || !t)\n\t\treturn;\n\tWRITE_ONCE(rcu_state.gp_wake_time, jiffies);\n\tWRITE_ONCE(rcu_state.gp_wake_seq, READ_ONCE(rcu_state.gp_seq));\n\tswake_up_one(&rcu_state.gp_wq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore_rcu_node",
          "args": [
            "rnp_old",
            "flags"
          ],
          "line": 2710
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "rcu_state.gp_flags",
            "READ_ONCE(rcu_state.gp_flags) | RCU_GP_FLAG_FQS"
          ],
          "line": 2708
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rcu_state.gp_flags"
          ],
          "line": 2709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore_rcu_node",
          "args": [
            "rnp_old",
            "flags"
          ],
          "line": 2705
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rcu_state.gp_flags"
          ],
          "line": 2704
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock",
          "args": [
            "&rnp_old->fqslock"
          ],
          "line": 2703
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_bh",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "208-211",
          "snippet": "void __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave_rcu_node",
          "args": [
            "rnp_old",
            "flags"
          ],
          "line": 2702
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_trylock",
          "args": [
            "&rnp->fqslock"
          ],
          "line": 2692
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_trylock_bh",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "144-147",
          "snippet": "int __lockfunc _raw_spin_trylock_bh(raw_spinlock_t *lock)\n{\n\treturn __raw_spin_trylock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nint __lockfunc _raw_spin_trylock_bh(raw_spinlock_t *lock)\n{\n\treturn __raw_spin_trylock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rcu_state.gp_flags"
          ],
          "line": 2691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__this_cpu_read",
          "args": [
            "rcu_data.mynode"
          ],
          "line": 2689
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};\nstatic struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\nstatic void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);\nstatic void check_cb_ovld_locked(struct rcu_data *rdp, struct rcu_node *rnp);\n\nvoid rcu_force_quiescent_state(void)\n{\n\tunsigned long flags;\n\tbool ret;\n\tstruct rcu_node *rnp;\n\tstruct rcu_node *rnp_old = NULL;\n\n\t/* Funnel through hierarchy to reduce memory contention. */\n\trnp = __this_cpu_read(rcu_data.mynode);\n\tfor (; rnp != NULL; rnp = rnp->parent) {\n\t\tret = (READ_ONCE(rcu_state.gp_flags) & RCU_GP_FLAG_FQS) ||\n\t\t       !raw_spin_trylock(&rnp->fqslock);\n\t\tif (rnp_old != NULL)\n\t\t\traw_spin_unlock(&rnp_old->fqslock);\n\t\tif (ret)\n\t\t\treturn;\n\t\trnp_old = rnp;\n\t}\n\t/* rnp_old == rcu_get_root(), rnp == NULL. */\n\n\t/* Reached the root of the rcu_node tree, acquire lock. */\n\traw_spin_lock_irqsave_rcu_node(rnp_old, flags);\n\traw_spin_unlock(&rnp_old->fqslock);\n\tif (READ_ONCE(rcu_state.gp_flags) & RCU_GP_FLAG_FQS) {\n\t\traw_spin_unlock_irqrestore_rcu_node(rnp_old, flags);\n\t\treturn;  /* Someone beat us to it. */\n\t}\n\tWRITE_ONCE(rcu_state.gp_flags,\n\t\t   READ_ONCE(rcu_state.gp_flags) | RCU_GP_FLAG_FQS);\n\traw_spin_unlock_irqrestore_rcu_node(rnp_old, flags);\n\trcu_gp_kthread_wake();\n}"
  },
  {
    "function_name": "force_qs_rnp",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
    "lines": "2631-2675",
    "snippet": "static void force_qs_rnp(int (*f)(struct rcu_data *rdp))\n{\n\tint cpu;\n\tunsigned long flags;\n\tunsigned long mask;\n\tstruct rcu_data *rdp;\n\tstruct rcu_node *rnp;\n\n\trcu_state.cbovld = rcu_state.cbovldnext;\n\trcu_state.cbovldnext = false;\n\trcu_for_each_leaf_node(rnp) {\n\t\tcond_resched_tasks_rcu_qs();\n\t\tmask = 0;\n\t\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\t\trcu_state.cbovldnext |= !!rnp->cbovldmask;\n\t\tif (rnp->qsmask == 0) {\n\t\t\tif (rcu_preempt_blocked_readers_cgp(rnp)) {\n\t\t\t\t/*\n\t\t\t\t * No point in scanning bits because they\n\t\t\t\t * are all zero.  But we might need to\n\t\t\t\t * priority-boost blocked readers.\n\t\t\t\t */\n\t\t\t\trcu_initiate_boost(rnp, flags);\n\t\t\t\t/* rcu_initiate_boost() releases rnp->lock */\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\t\tcontinue;\n\t\t}\n\t\tfor_each_leaf_node_cpu_mask(rnp, cpu, rnp->qsmask) {\n\t\t\trdp = per_cpu_ptr(&rcu_data, cpu);\n\t\t\tif (f(rdp)) {\n\t\t\t\tmask |= rdp->grpmask;\n\t\t\t\trcu_disable_urgency_upon_qs(rdp);\n\t\t\t}\n\t\t}\n\t\tif (mask != 0) {\n\t\t\t/* Idle/offline CPUs, report (releases rnp->lock). */\n\t\t\trcu_report_qs_rnp(mask, rnp, rnp->gp_seq, flags);\n\t\t} else {\n\t\t\t/* Nothing to do here, so just drop the lock. */\n\t\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_nocb.h\"",
      "#include \"tree_exp.h\"",
      "#include \"tree_stall.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <linux/kasan.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/panic_notifier.h>",
      "#include <linux/panic.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};",
      "static struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};",
      "static void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);",
      "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
      "static void sync_sched_exp_online_cleanup(int cpu);",
      "static void check_cb_ovld_locked(struct rcu_data *rdp, struct rcu_node *rnp);",
      "static bool rcu_rdp_is_offloaded(struct rcu_data *rdp);",
      "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore_rcu_node",
          "args": [
            "rnp",
            "flags"
          ],
          "line": 2672
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_report_qs_rnp",
          "args": [
            "mask",
            "rnp",
            "rnp->gp_seq",
            "flags"
          ],
          "line": 2669
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_report_qs_rnp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "2179-2234",
          "snippet": "static void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags)\n\t__releases(rnp->lock)\n{\n\tunsigned long oldmask = 0;\n\tstruct rcu_node *rnp_c;\n\n\traw_lockdep_assert_held_rcu_node(rnp);\n\n\t/* Walk up the rcu_node hierarchy. */\n\tfor (;;) {\n\t\tif ((!(rnp->qsmask & mask) && mask) || rnp->gp_seq != gps) {\n\n\t\t\t/*\n\t\t\t * Our bit has already been cleared, or the\n\t\t\t * relevant grace period is already over, so done.\n\t\t\t */\n\t\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\t\treturn;\n\t\t}\n\t\tWARN_ON_ONCE(oldmask); /* Any child must be all zeroed! */\n\t\tWARN_ON_ONCE(!rcu_is_leaf_node(rnp) &&\n\t\t\t     rcu_preempt_blocked_readers_cgp(rnp));\n\t\tWRITE_ONCE(rnp->qsmask, rnp->qsmask & ~mask);\n\t\ttrace_rcu_quiescent_state_report(rcu_state.name, rnp->gp_seq,\n\t\t\t\t\t\t mask, rnp->qsmask, rnp->level,\n\t\t\t\t\t\t rnp->grplo, rnp->grphi,\n\t\t\t\t\t\t !!rnp->gp_tasks);\n\t\tif (rnp->qsmask != 0 || rcu_preempt_blocked_readers_cgp(rnp)) {\n\n\t\t\t/* Other bits still set at this level, so done. */\n\t\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\t\treturn;\n\t\t}\n\t\trnp->completedqs = rnp->gp_seq;\n\t\tmask = rnp->grpmask;\n\t\tif (rnp->parent == NULL) {\n\n\t\t\t/* No more levels.  Exit loop holding root lock. */\n\n\t\t\tbreak;\n\t\t}\n\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\trnp_c = rnp;\n\t\trnp = rnp->parent;\n\t\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\t\toldmask = READ_ONCE(rnp_c->qsmask);\n\t}\n\n\t/*\n\t * Get here if we are the last CPU to pass through a quiescent\n\t * state for this grace period.  Invoke rcu_report_qs_rsp()\n\t * to clean up and start the next grace period if one is needed.\n\t */\n\trcu_report_qs_rsp(flags); /* releases rnp->lock. */\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};",
            "static void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);",
            "static void check_cb_ovld_locked(struct rcu_data *rdp, struct rcu_node *rnp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\nstatic void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);\nstatic void check_cb_ovld_locked(struct rcu_data *rdp, struct rcu_node *rnp);\n\nstatic void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags)\n\t__releases(rnp->lock)\n{\n\tunsigned long oldmask = 0;\n\tstruct rcu_node *rnp_c;\n\n\traw_lockdep_assert_held_rcu_node(rnp);\n\n\t/* Walk up the rcu_node hierarchy. */\n\tfor (;;) {\n\t\tif ((!(rnp->qsmask & mask) && mask) || rnp->gp_seq != gps) {\n\n\t\t\t/*\n\t\t\t * Our bit has already been cleared, or the\n\t\t\t * relevant grace period is already over, so done.\n\t\t\t */\n\t\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\t\treturn;\n\t\t}\n\t\tWARN_ON_ONCE(oldmask); /* Any child must be all zeroed! */\n\t\tWARN_ON_ONCE(!rcu_is_leaf_node(rnp) &&\n\t\t\t     rcu_preempt_blocked_readers_cgp(rnp));\n\t\tWRITE_ONCE(rnp->qsmask, rnp->qsmask & ~mask);\n\t\ttrace_rcu_quiescent_state_report(rcu_state.name, rnp->gp_seq,\n\t\t\t\t\t\t mask, rnp->qsmask, rnp->level,\n\t\t\t\t\t\t rnp->grplo, rnp->grphi,\n\t\t\t\t\t\t !!rnp->gp_tasks);\n\t\tif (rnp->qsmask != 0 || rcu_preempt_blocked_readers_cgp(rnp)) {\n\n\t\t\t/* Other bits still set at this level, so done. */\n\t\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\t\treturn;\n\t\t}\n\t\trnp->completedqs = rnp->gp_seq;\n\t\tmask = rnp->grpmask;\n\t\tif (rnp->parent == NULL) {\n\n\t\t\t/* No more levels.  Exit loop holding root lock. */\n\n\t\t\tbreak;\n\t\t}\n\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\trnp_c = rnp;\n\t\trnp = rnp->parent;\n\t\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\t\toldmask = READ_ONCE(rnp_c->qsmask);\n\t}\n\n\t/*\n\t * Get here if we are the last CPU to pass through a quiescent\n\t * state for this grace period.  Invoke rcu_report_qs_rsp()\n\t * to clean up and start the next grace period if one is needed.\n\t */\n\trcu_report_qs_rsp(flags); /* releases rnp->lock. */\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_disable_urgency_upon_qs",
          "args": [
            "rdp"
          ],
          "line": 2664
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_disable_urgency_upon_qs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "1101-1110",
          "snippet": "static void rcu_disable_urgency_upon_qs(struct rcu_data *rdp)\n{\n\traw_lockdep_assert_held_rcu_node(rdp->mynode);\n\tWRITE_ONCE(rdp->rcu_urgent_qs, false);\n\tWRITE_ONCE(rdp->rcu_need_heavy_qs, false);\n\tif (tick_nohz_full_cpu(rdp->cpu) && rdp->rcu_forced_tick) {\n\t\ttick_dep_clear_cpu(rdp->cpu, TICK_DEP_BIT_RCU);\n\t\tWRITE_ONCE(rdp->rcu_forced_tick, false);\n\t}\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};",
            "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
            "static void sync_sched_exp_online_cleanup(int cpu);",
            "static bool rcu_rdp_is_offloaded(struct rcu_data *rdp);",
            "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void sync_sched_exp_online_cleanup(int cpu);\nstatic bool rcu_rdp_is_offloaded(struct rcu_data *rdp);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nstatic void rcu_disable_urgency_upon_qs(struct rcu_data *rdp)\n{\n\traw_lockdep_assert_held_rcu_node(rdp->mynode);\n\tWRITE_ONCE(rdp->rcu_urgent_qs, false);\n\tWRITE_ONCE(rdp->rcu_need_heavy_qs, false);\n\tif (tick_nohz_full_cpu(rdp->cpu) && rdp->rcu_forced_tick) {\n\t\ttick_dep_clear_cpu(rdp->cpu, TICK_DEP_BIT_RCU);\n\t\tWRITE_ONCE(rdp->rcu_forced_tick, false);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "f",
          "args": [
            "rdp"
          ],
          "line": 2662
        },
        "resolved": true,
        "details": {
          "function_name": "rcutree_offline_cpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "4245-4262",
          "snippet": "int rcutree_offline_cpu(unsigned int cpu)\n{\n\tunsigned long flags;\n\tstruct rcu_data *rdp;\n\tstruct rcu_node *rnp;\n\n\trdp = per_cpu_ptr(&rcu_data, cpu);\n\trnp = rdp->mynode;\n\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\trnp->ffmask &= ~rdp->grpmask;\n\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\n\trcutree_affinity_setting(cpu, cpu);\n\n\t// nohz_full CPUs need the tick for stop-machine to work quickly\n\ttick_dep_set(TICK_DEP_BIT_RCU);\n\treturn 0;\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};",
            "static void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);",
            "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
            "static void sync_sched_exp_online_cleanup(int cpu);",
            "static void check_cb_ovld_locked(struct rcu_data *rdp, struct rcu_node *rnp);",
            "static bool rcu_rdp_is_offloaded(struct rcu_data *rdp);",
            "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};\nstatic void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void sync_sched_exp_online_cleanup(int cpu);\nstatic void check_cb_ovld_locked(struct rcu_data *rdp, struct rcu_node *rnp);\nstatic bool rcu_rdp_is_offloaded(struct rcu_data *rdp);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nint rcutree_offline_cpu(unsigned int cpu)\n{\n\tunsigned long flags;\n\tstruct rcu_data *rdp;\n\tstruct rcu_node *rnp;\n\n\trdp = per_cpu_ptr(&rcu_data, cpu);\n\trnp = rdp->mynode;\n\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\trnp->ffmask &= ~rdp->grpmask;\n\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\n\trcutree_affinity_setting(cpu, cpu);\n\n\t// nohz_full CPUs need the tick for stop-machine to work quickly\n\ttick_dep_set(TICK_DEP_BIT_RCU);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "&rcu_data",
            "cpu"
          ],
          "line": 2661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_leaf_node_cpu_mask",
          "args": [
            "rnp",
            "cpu",
            "rnp->qsmask"
          ],
          "line": 2660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore_rcu_node",
          "args": [
            "rnp",
            "flags"
          ],
          "line": 2657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_initiate_boost",
          "args": [
            "rnp",
            "flags"
          ],
          "line": 2653
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_initiate_boost",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "1238-1242",
          "snippet": "static void rcu_initiate_boost(struct rcu_node *rnp, unsigned long flags)\n\t__releases(rnp->lock)\n{\n\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nstatic void rcu_initiate_boost(struct rcu_node *rnp, unsigned long flags)\n\t__releases(rnp->lock)\n{\n\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_preempt_blocked_readers_cgp",
          "args": [
            "rnp"
          ],
          "line": 2647
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_preempt_blocked_readers_cgp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "907-910",
          "snippet": "static int rcu_preempt_blocked_readers_cgp(struct rcu_node *rnp)\n{\n\treturn 0;\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nstatic int rcu_preempt_blocked_readers_cgp(struct rcu_node *rnp)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave_rcu_node",
          "args": [
            "rnp",
            "flags"
          ],
          "line": 2644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cond_resched_tasks_rcu_qs",
          "args": [],
          "line": 2642
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};\nstatic struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\nstatic void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void sync_sched_exp_online_cleanup(int cpu);\nstatic void check_cb_ovld_locked(struct rcu_data *rdp, struct rcu_node *rnp);\nstatic bool rcu_rdp_is_offloaded(struct rcu_data *rdp);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp))\n{\n\tint cpu;\n\tunsigned long flags;\n\tunsigned long mask;\n\tstruct rcu_data *rdp;\n\tstruct rcu_node *rnp;\n\n\trcu_state.cbovld = rcu_state.cbovldnext;\n\trcu_state.cbovldnext = false;\n\trcu_for_each_leaf_node(rnp) {\n\t\tcond_resched_tasks_rcu_qs();\n\t\tmask = 0;\n\t\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\t\trcu_state.cbovldnext |= !!rnp->cbovldmask;\n\t\tif (rnp->qsmask == 0) {\n\t\t\tif (rcu_preempt_blocked_readers_cgp(rnp)) {\n\t\t\t\t/*\n\t\t\t\t * No point in scanning bits because they\n\t\t\t\t * are all zero.  But we might need to\n\t\t\t\t * priority-boost blocked readers.\n\t\t\t\t */\n\t\t\t\trcu_initiate_boost(rnp, flags);\n\t\t\t\t/* rcu_initiate_boost() releases rnp->lock */\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\t\tcontinue;\n\t\t}\n\t\tfor_each_leaf_node_cpu_mask(rnp, cpu, rnp->qsmask) {\n\t\t\trdp = per_cpu_ptr(&rcu_data, cpu);\n\t\t\tif (f(rdp)) {\n\t\t\t\tmask |= rdp->grpmask;\n\t\t\t\trcu_disable_urgency_upon_qs(rdp);\n\t\t\t}\n\t\t}\n\t\tif (mask != 0) {\n\t\t\t/* Idle/offline CPUs, report (releases rnp->lock). */\n\t\t\trcu_report_qs_rnp(mask, rnp, rnp->gp_seq, flags);\n\t\t} else {\n\t\t\t/* Nothing to do here, so just drop the lock. */\n\t\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "rcu_sched_clock_irq",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
    "lines": "2602-2622",
    "snippet": "void rcu_sched_clock_irq(int user)\n{\n\ttrace_rcu_utilization(TPS(\"Start scheduler-tick\"));\n\tlockdep_assert_irqs_disabled();\n\traw_cpu_inc(rcu_data.ticks_this_gp);\n\t/* The load-acquire pairs with the store-release setting to true. */\n\tif (smp_load_acquire(this_cpu_ptr(&rcu_data.rcu_urgent_qs))) {\n\t\t/* Idle and userspace execution already are quiescent states. */\n\t\tif (!rcu_is_cpu_rrupt_from_idle() && !user) {\n\t\t\tset_tsk_need_resched(current);\n\t\t\tset_preempt_need_resched();\n\t\t}\n\t\t__this_cpu_write(rcu_data.rcu_urgent_qs, false);\n\t}\n\trcu_flavor_sched_clock_irq(user);\n\tif (rcu_pending(user))\n\t\tinvoke_rcu_core();\n\tlockdep_assert_irqs_disabled();\n\n\ttrace_rcu_utilization(TPS(\"End scheduler-tick\"));\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_nocb.h\"",
      "#include \"tree_exp.h\"",
      "#include \"tree_stall.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <linux/kasan.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/panic_notifier.h>",
      "#include <linux/panic.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};",
      "static void invoke_rcu_core(void);",
      "static int rcu_pending(int user);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_rcu_utilization",
          "args": [
            "TPS(\"End scheduler-tick\")"
          ],
          "line": 2621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPS",
          "args": [
            "\"End scheduler-tick\""
          ],
          "line": 2621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_irqs_disabled",
          "args": [],
          "line": 2619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "invoke_rcu_core",
          "args": [],
          "line": 2618
        },
        "resolved": true,
        "details": {
          "function_name": "invoke_rcu_core",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "2824-2832",
          "snippet": "static void invoke_rcu_core(void)\n{\n\tif (!cpu_online(smp_processor_id()))\n\t\treturn;\n\tif (use_softirq)\n\t\traise_softirq(RCU_SOFTIRQ);\n\telse\n\t\tinvoke_rcu_core_kthread();\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool use_softirq = !IS_ENABLED(CONFIG_PREEMPT_RT);",
            "static void invoke_rcu_core(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic bool use_softirq = !IS_ENABLED(CONFIG_PREEMPT_RT);\nstatic void invoke_rcu_core(void);\n\nstatic void invoke_rcu_core(void)\n{\n\tif (!cpu_online(smp_processor_id()))\n\t\treturn;\n\tif (use_softirq)\n\t\traise_softirq(RCU_SOFTIRQ);\n\telse\n\t\tinvoke_rcu_core_kthread();\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_pending",
          "args": [
            "user"
          ],
          "line": 2617
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_pending",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "3910-3952",
          "snippet": "static int rcu_pending(int user)\n{\n\tbool gp_in_progress;\n\tstruct rcu_data *rdp = this_cpu_ptr(&rcu_data);\n\tstruct rcu_node *rnp = rdp->mynode;\n\n\tlockdep_assert_irqs_disabled();\n\n\t/* Check for CPU stalls, if enabled. */\n\tcheck_cpu_stall(rdp);\n\n\t/* Does this CPU need a deferred NOCB wakeup? */\n\tif (rcu_nocb_need_deferred_wakeup(rdp, RCU_NOCB_WAKE))\n\t\treturn 1;\n\n\t/* Is this a nohz_full CPU in userspace or idle?  (Ignore RCU if so.) */\n\tif ((user || rcu_is_cpu_rrupt_from_idle()) && rcu_nohz_full_cpu())\n\t\treturn 0;\n\n\t/* Is the RCU core waiting for a quiescent state from this CPU? */\n\tgp_in_progress = rcu_gp_in_progress();\n\tif (rdp->core_needs_qs && !rdp->cpu_no_qs.b.norm && gp_in_progress)\n\t\treturn 1;\n\n\t/* Does this CPU have callbacks ready to invoke? */\n\tif (!rcu_rdp_is_offloaded(rdp) &&\n\t    rcu_segcblist_ready_cbs(&rdp->cblist))\n\t\treturn 1;\n\n\t/* Has RCU gone idle with this CPU needing another grace period? */\n\tif (!gp_in_progress && rcu_segcblist_is_enabled(&rdp->cblist) &&\n\t    !rcu_rdp_is_offloaded(rdp) &&\n\t    !rcu_segcblist_restempty(&rdp->cblist, RCU_NEXT_READY_TAIL))\n\t\treturn 1;\n\n\t/* Have RCU grace period completed or started?  */\n\tif (rcu_seq_current(&rnp->gp_seq) != rdp->gp_seq ||\n\t    unlikely(READ_ONCE(rdp->gpwrap))) /* outside lock */\n\t\treturn 1;\n\n\t/* nothing to do */\n\treturn 0;\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};",
            "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
            "static void check_cb_ovld_locked(struct rcu_data *rdp, struct rcu_node *rnp);",
            "static bool rcu_rdp_is_offloaded(struct rcu_data *rdp);",
            "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));",
            "static int rcu_pending(int user);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void check_cb_ovld_locked(struct rcu_data *rdp, struct rcu_node *rnp);\nstatic bool rcu_rdp_is_offloaded(struct rcu_data *rdp);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\nstatic int rcu_pending(int user);\n\nstatic int rcu_pending(int user)\n{\n\tbool gp_in_progress;\n\tstruct rcu_data *rdp = this_cpu_ptr(&rcu_data);\n\tstruct rcu_node *rnp = rdp->mynode;\n\n\tlockdep_assert_irqs_disabled();\n\n\t/* Check for CPU stalls, if enabled. */\n\tcheck_cpu_stall(rdp);\n\n\t/* Does this CPU need a deferred NOCB wakeup? */\n\tif (rcu_nocb_need_deferred_wakeup(rdp, RCU_NOCB_WAKE))\n\t\treturn 1;\n\n\t/* Is this a nohz_full CPU in userspace or idle?  (Ignore RCU if so.) */\n\tif ((user || rcu_is_cpu_rrupt_from_idle()) && rcu_nohz_full_cpu())\n\t\treturn 0;\n\n\t/* Is the RCU core waiting for a quiescent state from this CPU? */\n\tgp_in_progress = rcu_gp_in_progress();\n\tif (rdp->core_needs_qs && !rdp->cpu_no_qs.b.norm && gp_in_progress)\n\t\treturn 1;\n\n\t/* Does this CPU have callbacks ready to invoke? */\n\tif (!rcu_rdp_is_offloaded(rdp) &&\n\t    rcu_segcblist_ready_cbs(&rdp->cblist))\n\t\treturn 1;\n\n\t/* Has RCU gone idle with this CPU needing another grace period? */\n\tif (!gp_in_progress && rcu_segcblist_is_enabled(&rdp->cblist) &&\n\t    !rcu_rdp_is_offloaded(rdp) &&\n\t    !rcu_segcblist_restempty(&rdp->cblist, RCU_NEXT_READY_TAIL))\n\t\treturn 1;\n\n\t/* Have RCU grace period completed or started?  */\n\tif (rcu_seq_current(&rnp->gp_seq) != rdp->gp_seq ||\n\t    unlikely(READ_ONCE(rdp->gpwrap))) /* outside lock */\n\t\treturn 1;\n\n\t/* nothing to do */\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_flavor_sched_clock_irq",
          "args": [
            "user"
          ],
          "line": 2616
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_flavor_sched_clock_irq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "955-973",
          "snippet": "static void rcu_flavor_sched_clock_irq(int user)\n{\n\tif (user || rcu_is_cpu_rrupt_from_idle()) {\n\n\t\t/*\n\t\t * Get here if this CPU took its interrupt from user\n\t\t * mode or from the idle loop, and if this is not a\n\t\t * nested interrupt.  In this case, the CPU is in\n\t\t * a quiescent state, so note it.\n\t\t *\n\t\t * No memory barrier is required here because rcu_qs()\n\t\t * references only CPU-local variables that other CPUs\n\t\t * neither access nor modify, at least not while the\n\t\t * corresponding CPU is online.\n\t\t */\n\n\t\trcu_qs();\n\t}\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nstatic void rcu_flavor_sched_clock_irq(int user)\n{\n\tif (user || rcu_is_cpu_rrupt_from_idle()) {\n\n\t\t/*\n\t\t * Get here if this CPU took its interrupt from user\n\t\t * mode or from the idle loop, and if this is not a\n\t\t * nested interrupt.  In this case, the CPU is in\n\t\t * a quiescent state, so note it.\n\t\t *\n\t\t * No memory barrier is required here because rcu_qs()\n\t\t * references only CPU-local variables that other CPUs\n\t\t * neither access nor modify, at least not while the\n\t\t * corresponding CPU is online.\n\t\t */\n\n\t\trcu_qs();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "__this_cpu_write",
          "args": [
            "rcu_data.rcu_urgent_qs",
            "false"
          ],
          "line": 2614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_preempt_need_resched",
          "args": [],
          "line": 2612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_tsk_need_resched",
          "args": [
            "current"
          ],
          "line": 2611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_is_cpu_rrupt_from_idle",
          "args": [],
          "line": 2610
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_is_cpu_rrupt_from_idle",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "422-451",
          "snippet": "static int rcu_is_cpu_rrupt_from_idle(void)\n{\n\tlong nesting;\n\n\t/*\n\t * Usually called from the tick; but also used from smp_function_call()\n\t * for expedited grace periods. This latter can result in running from\n\t * the idle task, instead of an actual IPI.\n\t */\n\tlockdep_assert_irqs_disabled();\n\n\t/* Check for counter underflows */\n\tRCU_LOCKDEP_WARN(__this_cpu_read(rcu_data.dynticks_nesting) < 0,\n\t\t\t \"RCU dynticks_nesting counter underflow!\");\n\tRCU_LOCKDEP_WARN(__this_cpu_read(rcu_data.dynticks_nmi_nesting) <= 0,\n\t\t\t \"RCU dynticks_nmi_nesting counter underflow/zero!\");\n\n\t/* Are we at first interrupt nesting level? */\n\tnesting = __this_cpu_read(rcu_data.dynticks_nmi_nesting);\n\tif (nesting > 1)\n\t\treturn false;\n\n\t/*\n\t * If we're not in an interrupt, we must be in the idle task!\n\t */\n\tWARN_ON_ONCE(!nesting && !is_idle_task(current));\n\n\t/* Does CPU appear to be idle from an RCU standpoint? */\n\treturn __this_cpu_read(rcu_data.dynticks_nesting) == 0;\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};\n\nstatic int rcu_is_cpu_rrupt_from_idle(void)\n{\n\tlong nesting;\n\n\t/*\n\t * Usually called from the tick; but also used from smp_function_call()\n\t * for expedited grace periods. This latter can result in running from\n\t * the idle task, instead of an actual IPI.\n\t */\n\tlockdep_assert_irqs_disabled();\n\n\t/* Check for counter underflows */\n\tRCU_LOCKDEP_WARN(__this_cpu_read(rcu_data.dynticks_nesting) < 0,\n\t\t\t \"RCU dynticks_nesting counter underflow!\");\n\tRCU_LOCKDEP_WARN(__this_cpu_read(rcu_data.dynticks_nmi_nesting) <= 0,\n\t\t\t \"RCU dynticks_nmi_nesting counter underflow/zero!\");\n\n\t/* Are we at first interrupt nesting level? */\n\tnesting = __this_cpu_read(rcu_data.dynticks_nmi_nesting);\n\tif (nesting > 1)\n\t\treturn false;\n\n\t/*\n\t * If we're not in an interrupt, we must be in the idle task!\n\t */\n\tWARN_ON_ONCE(!nesting && !is_idle_task(current));\n\n\t/* Does CPU appear to be idle from an RCU standpoint? */\n\treturn __this_cpu_read(rcu_data.dynticks_nesting) == 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_load_acquire",
          "args": [
            "this_cpu_ptr(&rcu_data.rcu_urgent_qs)"
          ],
          "line": 2608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&rcu_data.rcu_urgent_qs"
          ],
          "line": 2608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_cpu_inc",
          "args": [
            "rcu_data.ticks_this_gp"
          ],
          "line": 2606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_irqs_disabled",
          "args": [],
          "line": 2605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_rcu_utilization",
          "args": [
            "TPS(\"Start scheduler-tick\")"
          ],
          "line": 2604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPS",
          "args": [
            "\"Start scheduler-tick\""
          ],
          "line": 2604
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};\nstatic void invoke_rcu_core(void);\nstatic int rcu_pending(int user);\n\nvoid rcu_sched_clock_irq(int user)\n{\n\ttrace_rcu_utilization(TPS(\"Start scheduler-tick\"));\n\tlockdep_assert_irqs_disabled();\n\traw_cpu_inc(rcu_data.ticks_this_gp);\n\t/* The load-acquire pairs with the store-release setting to true. */\n\tif (smp_load_acquire(this_cpu_ptr(&rcu_data.rcu_urgent_qs))) {\n\t\t/* Idle and userspace execution already are quiescent states. */\n\t\tif (!rcu_is_cpu_rrupt_from_idle() && !user) {\n\t\t\tset_tsk_need_resched(current);\n\t\t\tset_preempt_need_resched();\n\t\t}\n\t\t__this_cpu_write(rcu_data.rcu_urgent_qs, false);\n\t}\n\trcu_flavor_sched_clock_irq(user);\n\tif (rcu_pending(user))\n\t\tinvoke_rcu_core();\n\tlockdep_assert_irqs_disabled();\n\n\ttrace_rcu_utilization(TPS(\"End scheduler-tick\"));\n}"
  },
  {
    "function_name": "rcu_do_batch",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
    "lines": "2465-2592",
    "snippet": "static void rcu_do_batch(struct rcu_data *rdp)\n{\n\tint div;\n\tbool __maybe_unused empty;\n\tunsigned long flags;\n\tstruct rcu_head *rhp;\n\tstruct rcu_cblist rcl = RCU_CBLIST_INITIALIZER(rcl);\n\tlong bl, count = 0;\n\tlong pending, tlimit = 0;\n\n\t/* If no callbacks are ready, just return. */\n\tif (!rcu_segcblist_ready_cbs(&rdp->cblist)) {\n\t\ttrace_rcu_batch_start(rcu_state.name,\n\t\t\t\t      rcu_segcblist_n_cbs(&rdp->cblist), 0);\n\t\ttrace_rcu_batch_end(rcu_state.name, 0,\n\t\t\t\t    !rcu_segcblist_empty(&rdp->cblist),\n\t\t\t\t    need_resched(), is_idle_task(current),\n\t\t\t\t    rcu_is_callbacks_kthread());\n\t\treturn;\n\t}\n\n\t/*\n\t * Extract the list of ready callbacks, disabling IRQs to prevent\n\t * races with call_rcu() from interrupt handlers.  Leave the\n\t * callback counts, as rcu_barrier() needs to be conservative.\n\t */\n\trcu_nocb_lock_irqsave(rdp, flags);\n\tWARN_ON_ONCE(cpu_is_offline(smp_processor_id()));\n\tpending = rcu_segcblist_n_cbs(&rdp->cblist);\n\tdiv = READ_ONCE(rcu_divisor);\n\tdiv = div < 0 ? 7 : div > sizeof(long) * 8 - 2 ? sizeof(long) * 8 - 2 : div;\n\tbl = max(rdp->blimit, pending >> div);\n\tif (in_serving_softirq() && unlikely(bl > 100)) {\n\t\tlong rrn = READ_ONCE(rcu_resched_ns);\n\n\t\trrn = rrn < NSEC_PER_MSEC ? NSEC_PER_MSEC : rrn > NSEC_PER_SEC ? NSEC_PER_SEC : rrn;\n\t\ttlimit = local_clock() + rrn;\n\t}\n\ttrace_rcu_batch_start(rcu_state.name,\n\t\t\t      rcu_segcblist_n_cbs(&rdp->cblist), bl);\n\trcu_segcblist_extract_done_cbs(&rdp->cblist, &rcl);\n\tif (rcu_rdp_is_offloaded(rdp))\n\t\trdp->qlen_last_fqs_check = rcu_segcblist_n_cbs(&rdp->cblist);\n\n\ttrace_rcu_segcb_stats(&rdp->cblist, TPS(\"SegCbDequeued\"));\n\trcu_nocb_unlock_irqrestore(rdp, flags);\n\n\t/* Invoke callbacks. */\n\ttick_dep_set_task(current, TICK_DEP_BIT_RCU);\n\trhp = rcu_cblist_dequeue(&rcl);\n\n\tfor (; rhp; rhp = rcu_cblist_dequeue(&rcl)) {\n\t\trcu_callback_t f;\n\n\t\tcount++;\n\t\tdebug_rcu_head_unqueue(rhp);\n\n\t\trcu_lock_acquire(&rcu_callback_map);\n\t\ttrace_rcu_invoke_callback(rcu_state.name, rhp);\n\n\t\tf = rhp->func;\n\t\tWRITE_ONCE(rhp->func, (rcu_callback_t)0L);\n\t\tf(rhp);\n\n\t\trcu_lock_release(&rcu_callback_map);\n\n\t\t/*\n\t\t * Stop only if limit reached and CPU has something to do.\n\t\t */\n\t\tif (in_serving_softirq()) {\n\t\t\tif (count >= bl && (need_resched() || !is_idle_task(current)))\n\t\t\t\tbreak;\n\t\t\t/*\n\t\t\t * Make sure we don't spend too much time here and deprive other\n\t\t\t * softirq vectors of CPU cycles.\n\t\t\t */\n\t\t\tif (unlikely(tlimit)) {\n\t\t\t\t/* only call local_clock() every 32 callbacks */\n\t\t\t\tif (likely((count & 31) || local_clock() < tlimit))\n\t\t\t\t\tcontinue;\n\t\t\t\t/* Exceeded the time limit, so leave. */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tlocal_bh_enable();\n\t\t\tlockdep_assert_irqs_enabled();\n\t\t\tcond_resched_tasks_rcu_qs();\n\t\t\tlockdep_assert_irqs_enabled();\n\t\t\tlocal_bh_disable();\n\t\t}\n\t}\n\n\trcu_nocb_lock_irqsave(rdp, flags);\n\trdp->n_cbs_invoked += count;\n\ttrace_rcu_batch_end(rcu_state.name, count, !!rcl.head, need_resched(),\n\t\t\t    is_idle_task(current), rcu_is_callbacks_kthread());\n\n\t/* Update counts and requeue any remaining callbacks. */\n\trcu_segcblist_insert_done_cbs(&rdp->cblist, &rcl);\n\trcu_segcblist_add_len(&rdp->cblist, -count);\n\n\t/* Reinstate batch limit if we have worked down the excess. */\n\tcount = rcu_segcblist_n_cbs(&rdp->cblist);\n\tif (rdp->blimit >= DEFAULT_MAX_RCU_BLIMIT && count <= qlowmark)\n\t\trdp->blimit = blimit;\n\n\t/* Reset ->qlen_last_fqs_check trigger if enough CBs have drained. */\n\tif (count == 0 && rdp->qlen_last_fqs_check != 0) {\n\t\trdp->qlen_last_fqs_check = 0;\n\t\trdp->n_force_qs_snap = READ_ONCE(rcu_state.n_force_qs);\n\t} else if (count < rdp->qlen_last_fqs_check - qhimark)\n\t\trdp->qlen_last_fqs_check = count;\n\n\t/*\n\t * The following usually indicates a double call_rcu().  To track\n\t * this down, try building with CONFIG_DEBUG_OBJECTS_RCU_HEAD=y.\n\t */\n\tempty = rcu_segcblist_empty(&rdp->cblist);\n\tWARN_ON_ONCE(count == 0 && !empty);\n\tWARN_ON_ONCE(!IS_ENABLED(CONFIG_RCU_NOCB_CPU) &&\n\t\t     count != 0 && empty);\n\tWARN_ON_ONCE(count == 0 && rcu_segcblist_n_segment_cbs(&rdp->cblist) != 0);\n\tWARN_ON_ONCE(!empty && rcu_segcblist_n_segment_cbs(&rdp->cblist) == 0);\n\n\trcu_nocb_unlock_irqrestore(rdp, flags);\n\n\ttick_dep_clear_task(current, TICK_DEP_BIT_RCU);\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_nocb.h\"",
      "#include \"tree_exp.h\"",
      "#include \"tree_stall.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <linux/kasan.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/panic_notifier.h>",
      "#include <linux/panic.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [
      "#define DEFAULT_MAX_RCU_BLIMIT 10000 // ... even during callback flood."
    ],
    "globals_used": [
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};",
      "static struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};",
      "static void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);",
      "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
      "static bool rcu_rdp_is_offloaded(struct rcu_data *rdp);",
      "static long blimit = DEFAULT_RCU_BLIMIT;",
      "static long qhimark = DEFAULT_RCU_QHIMARK;",
      "static long qlowmark = DEFAULT_RCU_QLOMARK;",
      "static int rcu_divisor = 7;",
      "static long rcu_resched_ns = 3 * NSEC_PER_MSEC;",
      "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tick_dep_clear_task",
          "args": [
            "current",
            "TICK_DEP_BIT_RCU"
          ],
          "line": 2591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_nocb_unlock_irqrestore",
          "args": [
            "rdp",
            "flags"
          ],
          "line": 2589
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_nocb_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_nocb.h",
          "lines": "1479-1483",
          "snippet": "static void rcu_nocb_unlock_irqrestore(struct rcu_data *rdp,\n\t\t\t\t       unsigned long flags)\n{\n\tlocal_irq_restore(flags);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static void rcu_nocb_unlock_irqrestore(struct rcu_data *rdp,\n\t\t\t\t       unsigned long flags)\n{\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!empty && rcu_segcblist_n_segment_cbs(&rdp->cblist) == 0"
          ],
          "line": 2587
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_segcblist_n_segment_cbs",
          "args": [
            "&rdp->cblist"
          ],
          "line": 2587
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_n_segment_cbs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.c",
          "lines": "98-107",
          "snippet": "long rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp)\n{\n\tlong len = 0;\n\tint i;\n\n\tfor (i = RCU_DONE_TAIL; i < RCU_CBLIST_NSEGS; i++)\n\t\tlen += rcu_segcblist_get_seglen(rsclp, i);\n\n\treturn len;\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/cpu.h>\n\nlong rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp)\n{\n\tlong len = 0;\n\tint i;\n\n\tfor (i = RCU_DONE_TAIL; i < RCU_CBLIST_NSEGS; i++)\n\t\tlen += rcu_segcblist_get_seglen(rsclp, i);\n\n\treturn len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "count == 0 && rcu_segcblist_n_segment_cbs(&rdp->cblist) != 0"
          ],
          "line": 2586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!IS_ENABLED(CONFIG_RCU_NOCB_CPU) &&\n\t\t     count != 0 && empty"
          ],
          "line": 2584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_RCU_NOCB_CPU"
          ],
          "line": 2584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "count == 0 && !empty"
          ],
          "line": 2583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_segcblist_empty",
          "args": [
            "&rdp->cblist"
          ],
          "line": 2582
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "41-44",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "long rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nlong rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rcu_state.n_force_qs"
          ],
          "line": 2574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_segcblist_n_cbs",
          "args": [
            "&rdp->cblist"
          ],
          "line": 2567
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_n_cbs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "47-54",
          "snippet": "static inline long rcu_segcblist_n_cbs(struct rcu_segcblist *rsclp)\n{\n#ifdef CONFIG_RCU_NOCB_CPU\n\treturn atomic_long_read(&rsclp->len);\n#else\n\treturn READ_ONCE(rsclp->len);\n#endif\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "long rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nlong rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline long rcu_segcblist_n_cbs(struct rcu_segcblist *rsclp)\n{\n#ifdef CONFIG_RCU_NOCB_CPU\n\treturn atomic_long_read(&rsclp->len);\n#else\n\treturn READ_ONCE(rsclp->len);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_segcblist_add_len",
          "args": [
            "&rdp->cblist",
            "-count"
          ],
          "line": 2564
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_add_len",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.c",
          "lines": "210-221",
          "snippet": "void rcu_segcblist_add_len(struct rcu_segcblist *rsclp, long v)\n{\n#ifdef CONFIG_RCU_NOCB_CPU\n\tsmp_mb__before_atomic(); // Read header comment above.\n\tatomic_long_add(v, &rsclp->len);\n\tsmp_mb__after_atomic();  // Read header comment above.\n#else\n\tsmp_mb(); // Read header comment above.\n\tWRITE_ONCE(rsclp->len, rsclp->len + v);\n\tsmp_mb(); // Read header comment above.\n#endif\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/cpu.h>\n\nvoid rcu_segcblist_add_len(struct rcu_segcblist *rsclp, long v)\n{\n#ifdef CONFIG_RCU_NOCB_CPU\n\tsmp_mb__before_atomic(); // Read header comment above.\n\tatomic_long_add(v, &rsclp->len);\n\tsmp_mb__after_atomic();  // Read header comment above.\n#else\n\tsmp_mb(); // Read header comment above.\n\tWRITE_ONCE(rsclp->len, rsclp->len + v);\n\tsmp_mb(); // Read header comment above.\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_segcblist_insert_done_cbs",
          "args": [
            "&rdp->cblist",
            "&rcl"
          ],
          "line": 2563
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_insert_done_cbs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.c",
          "lines": "442-459",
          "snippet": "void rcu_segcblist_insert_done_cbs(struct rcu_segcblist *rsclp,\n\t\t\t\t   struct rcu_cblist *rclp)\n{\n\tint i;\n\n\tif (!rclp->head)\n\t\treturn; /* No callbacks to move. */\n\trcu_segcblist_add_seglen(rsclp, RCU_DONE_TAIL, rclp->len);\n\t*rclp->tail = rsclp->head;\n\tWRITE_ONCE(rsclp->head, rclp->head);\n\tfor (i = RCU_DONE_TAIL; i < RCU_CBLIST_NSEGS; i++)\n\t\tif (&rsclp->head == rsclp->tails[i])\n\t\t\tWRITE_ONCE(rsclp->tails[i], rclp->tail);\n\t\telse\n\t\t\tbreak;\n\trclp->head = NULL;\n\trclp->tail = &rclp->head;\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/cpu.h>\n\nvoid rcu_segcblist_insert_done_cbs(struct rcu_segcblist *rsclp,\n\t\t\t\t   struct rcu_cblist *rclp)\n{\n\tint i;\n\n\tif (!rclp->head)\n\t\treturn; /* No callbacks to move. */\n\trcu_segcblist_add_seglen(rsclp, RCU_DONE_TAIL, rclp->len);\n\t*rclp->tail = rsclp->head;\n\tWRITE_ONCE(rsclp->head, rclp->head);\n\tfor (i = RCU_DONE_TAIL; i < RCU_CBLIST_NSEGS; i++)\n\t\tif (&rsclp->head == rsclp->tails[i])\n\t\t\tWRITE_ONCE(rsclp->tails[i], rclp->tail);\n\t\telse\n\t\t\tbreak;\n\trclp->head = NULL;\n\trclp->tail = &rclp->head;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_rcu_batch_end",
          "args": [
            "rcu_state.name",
            "count",
            "!!rcl.head",
            "need_resched()",
            "is_idle_task(current)",
            "rcu_is_callbacks_kthread()"
          ],
          "line": 2559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_is_callbacks_kthread",
          "args": [],
          "line": 2560
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_is_callbacks_kthread",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "1244-1247",
          "snippet": "static bool rcu_is_callbacks_kthread(void)\n{\n\treturn false;\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nstatic bool rcu_is_callbacks_kthread(void)\n{\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_idle_task",
          "args": [
            "current"
          ],
          "line": 2560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "need_resched",
          "args": [],
          "line": 2559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_nocb_lock_irqsave",
          "args": [
            "rdp",
            "flags"
          ],
          "line": 2557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_bh_disable",
          "args": [],
          "line": 2553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_irqs_enabled",
          "args": [],
          "line": 2552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cond_resched_tasks_rcu_qs",
          "args": [],
          "line": 2551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_irqs_enabled",
          "args": [],
          "line": 2550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_bh_enable",
          "args": [],
          "line": 2549
        },
        "resolved": true,
        "details": {
          "function_name": "_local_bh_enable",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/softirq.c",
          "lines": "353-357",
          "snippet": "void _local_bh_enable(void)\n{\n\tWARN_ON_ONCE(in_irq());\n\t__local_bh_enable(SOFTIRQ_DISABLE_OFFSET);\n}",
          "includes": [
            "#include <trace/events/irq.h>",
            "#include <asm/softirq_stack.h>",
            "#include <linux/wait_bit.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/smp.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/mm.h>",
            "#include <linux/local_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/irq.h>\n#include <asm/softirq_stack.h>\n#include <linux/wait_bit.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/smpboot.h>\n#include <linux/smp.h>\n#include <linux/ftrace.h>\n#include <linux/rcupdate.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/mm.h>\n#include <linux/local_lock.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/kernel_stat.h>\n#include <linux/export.h>\n\nvoid _local_bh_enable(void)\n{\n\tWARN_ON_ONCE(in_irq());\n\t__local_bh_enable(SOFTIRQ_DISABLE_OFFSET);\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "(count & 31) || local_clock() < tlimit"
          ],
          "line": 2543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_clock",
          "args": [],
          "line": 2543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "tlimit"
          ],
          "line": 2541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_idle_task",
          "args": [
            "current"
          ],
          "line": 2535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "need_resched",
          "args": [],
          "line": 2535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_serving_softirq",
          "args": [],
          "line": 2534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_lock_release",
          "args": [
            "&rcu_callback_map"
          ],
          "line": 2529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f",
          "args": [
            "rhp"
          ],
          "line": 2527
        },
        "resolved": true,
        "details": {
          "function_name": "rcutree_offline_cpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "4245-4262",
          "snippet": "int rcutree_offline_cpu(unsigned int cpu)\n{\n\tunsigned long flags;\n\tstruct rcu_data *rdp;\n\tstruct rcu_node *rnp;\n\n\trdp = per_cpu_ptr(&rcu_data, cpu);\n\trnp = rdp->mynode;\n\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\trnp->ffmask &= ~rdp->grpmask;\n\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\n\trcutree_affinity_setting(cpu, cpu);\n\n\t// nohz_full CPUs need the tick for stop-machine to work quickly\n\ttick_dep_set(TICK_DEP_BIT_RCU);\n\treturn 0;\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};",
            "static void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);",
            "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
            "static void sync_sched_exp_online_cleanup(int cpu);",
            "static void check_cb_ovld_locked(struct rcu_data *rdp, struct rcu_node *rnp);",
            "static bool rcu_rdp_is_offloaded(struct rcu_data *rdp);",
            "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};\nstatic void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void sync_sched_exp_online_cleanup(int cpu);\nstatic void check_cb_ovld_locked(struct rcu_data *rdp, struct rcu_node *rnp);\nstatic bool rcu_rdp_is_offloaded(struct rcu_data *rdp);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nint rcutree_offline_cpu(unsigned int cpu)\n{\n\tunsigned long flags;\n\tstruct rcu_data *rdp;\n\tstruct rcu_node *rnp;\n\n\trdp = per_cpu_ptr(&rcu_data, cpu);\n\trnp = rdp->mynode;\n\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\trnp->ffmask &= ~rdp->grpmask;\n\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\n\trcutree_affinity_setting(cpu, cpu);\n\n\t// nohz_full CPUs need the tick for stop-machine to work quickly\n\ttick_dep_set(TICK_DEP_BIT_RCU);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "rhp->func",
            "(rcu_callback_t)0L"
          ],
          "line": 2526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_rcu_invoke_callback",
          "args": [
            "rcu_state.name",
            "rhp"
          ],
          "line": 2523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_lock_acquire",
          "args": [
            "&rcu_callback_map"
          ],
          "line": 2522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_rcu_head_unqueue",
          "args": [
            "rhp"
          ],
          "line": 2520
        },
        "resolved": true,
        "details": {
          "function_name": "debug_rcu_head_unqueue",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu.h",
          "lines": "196-198",
          "snippet": "static inline void debug_rcu_head_unqueue(struct rcu_head *head)\n{\n}",
          "includes": [
            "#include <linux/rcu_node_tree.h>",
            "#include <trace/events/rcu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_node_tree.h>\n#include <trace/events/rcu.h>\n\nstatic inline void debug_rcu_head_unqueue(struct rcu_head *head)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_cblist_dequeue",
          "args": [
            "&rcl"
          ],
          "line": 2516
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_cblist_dequeue",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.c",
          "lines": "67-79",
          "snippet": "struct rcu_head *rcu_cblist_dequeue(struct rcu_cblist *rclp)\n{\n\tstruct rcu_head *rhp;\n\n\trhp = rclp->head;\n\tif (!rhp)\n\t\treturn NULL;\n\trclp->len--;\n\trclp->head = rhp->next;\n\tif (!rclp->head)\n\t\trclp->tail = &rclp->head;\n\treturn rhp;\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/cpu.h>\n\nstruct rcu_head *rcu_cblist_dequeue(struct rcu_cblist *rclp)\n{\n\tstruct rcu_head *rhp;\n\n\trhp = rclp->head;\n\tif (!rhp)\n\t\treturn NULL;\n\trclp->len--;\n\trclp->head = rhp->next;\n\tif (!rclp->head)\n\t\trclp->tail = &rclp->head;\n\treturn rhp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tick_dep_set_task",
          "args": [
            "current",
            "TICK_DEP_BIT_RCU"
          ],
          "line": 2513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_rcu_segcb_stats",
          "args": [
            "&rdp->cblist",
            "TPS(\"SegCbDequeued\")"
          ],
          "line": 2509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPS",
          "args": [
            "\"SegCbDequeued\""
          ],
          "line": 2509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_rdp_is_offloaded",
          "args": [
            "rdp"
          ],
          "line": 2506
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_rdp_is_offloaded",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "16-38",
          "snippet": "static bool rcu_rdp_is_offloaded(struct rcu_data *rdp)\n{\n\t/*\n\t * In order to read the offloaded state of an rdp in a safe\n\t * and stable way and prevent from its value to be changed\n\t * under us, we must either hold the barrier mutex, the cpu\n\t * hotplug lock (read or write) or the nocb lock. Local\n\t * non-preemptible reads are also safe. NOCB kthreads and\n\t * timers have their own means of synchronization against the\n\t * offloaded state updaters.\n\t */\n\tRCU_LOCKDEP_WARN(\n\t\t!(lockdep_is_held(&rcu_state.barrier_mutex) ||\n\t\t  (IS_ENABLED(CONFIG_HOTPLUG_CPU) && lockdep_is_cpus_held()) ||\n\t\t  rcu_lockdep_is_held_nocb(rdp) ||\n\t\t  (rdp == this_cpu_ptr(&rcu_data) &&\n\t\t   !(IS_ENABLED(CONFIG_PREEMPT_COUNT) && preemptible())) ||\n\t\t  rcu_current_is_nocb_kthread(rdp)),\n\t\t\"Unsafe read of RCU_NOCB offloaded state\"\n\t);\n\n\treturn rcu_segcblist_is_offloaded(&rdp->cblist);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nstatic bool rcu_rdp_is_offloaded(struct rcu_data *rdp)\n{\n\t/*\n\t * In order to read the offloaded state of an rdp in a safe\n\t * and stable way and prevent from its value to be changed\n\t * under us, we must either hold the barrier mutex, the cpu\n\t * hotplug lock (read or write) or the nocb lock. Local\n\t * non-preemptible reads are also safe. NOCB kthreads and\n\t * timers have their own means of synchronization against the\n\t * offloaded state updaters.\n\t */\n\tRCU_LOCKDEP_WARN(\n\t\t!(lockdep_is_held(&rcu_state.barrier_mutex) ||\n\t\t  (IS_ENABLED(CONFIG_HOTPLUG_CPU) && lockdep_is_cpus_held()) ||\n\t\t  rcu_lockdep_is_held_nocb(rdp) ||\n\t\t  (rdp == this_cpu_ptr(&rcu_data) &&\n\t\t   !(IS_ENABLED(CONFIG_PREEMPT_COUNT) && preemptible())) ||\n\t\t  rcu_current_is_nocb_kthread(rdp)),\n\t\t\"Unsafe read of RCU_NOCB offloaded state\"\n\t);\n\n\treturn rcu_segcblist_is_offloaded(&rdp->cblist);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_segcblist_extract_done_cbs",
          "args": [
            "&rdp->cblist",
            "&rcl"
          ],
          "line": 2505
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_extract_done_cbs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.c",
          "lines": "385-401",
          "snippet": "void rcu_segcblist_extract_done_cbs(struct rcu_segcblist *rsclp,\n\t\t\t\t    struct rcu_cblist *rclp)\n{\n\tint i;\n\n\tif (!rcu_segcblist_ready_cbs(rsclp))\n\t\treturn; /* Nothing to do. */\n\trclp->len = rcu_segcblist_get_seglen(rsclp, RCU_DONE_TAIL);\n\t*rclp->tail = rsclp->head;\n\tWRITE_ONCE(rsclp->head, *rsclp->tails[RCU_DONE_TAIL]);\n\tWRITE_ONCE(*rsclp->tails[RCU_DONE_TAIL], NULL);\n\trclp->tail = rsclp->tails[RCU_DONE_TAIL];\n\tfor (i = RCU_CBLIST_NSEGS - 1; i >= RCU_DONE_TAIL; i--)\n\t\tif (rsclp->tails[i] == rsclp->tails[RCU_DONE_TAIL])\n\t\t\tWRITE_ONCE(rsclp->tails[i], &rsclp->head);\n\trcu_segcblist_set_seglen(rsclp, RCU_DONE_TAIL, 0);\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/cpu.h>\n\nvoid rcu_segcblist_extract_done_cbs(struct rcu_segcblist *rsclp,\n\t\t\t\t    struct rcu_cblist *rclp)\n{\n\tint i;\n\n\tif (!rcu_segcblist_ready_cbs(rsclp))\n\t\treturn; /* Nothing to do. */\n\trclp->len = rcu_segcblist_get_seglen(rsclp, RCU_DONE_TAIL);\n\t*rclp->tail = rsclp->head;\n\tWRITE_ONCE(rsclp->head, *rsclp->tails[RCU_DONE_TAIL]);\n\tWRITE_ONCE(*rsclp->tails[RCU_DONE_TAIL], NULL);\n\trclp->tail = rsclp->tails[RCU_DONE_TAIL];\n\tfor (i = RCU_CBLIST_NSEGS - 1; i >= RCU_DONE_TAIL; i--)\n\t\tif (rsclp->tails[i] == rsclp->tails[RCU_DONE_TAIL])\n\t\t\tWRITE_ONCE(rsclp->tails[i], &rsclp->head);\n\trcu_segcblist_set_seglen(rsclp, RCU_DONE_TAIL, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_rcu_batch_start",
          "args": [
            "rcu_state.name",
            "rcu_segcblist_n_cbs(&rdp->cblist)",
            "bl"
          ],
          "line": 2503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_clock",
          "args": [],
          "line": 2501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rcu_resched_ns"
          ],
          "line": 2498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "bl > 100"
          ],
          "line": 2497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_serving_softirq",
          "args": [],
          "line": 2497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "max",
          "args": [
            "rdp->blimit",
            "pending >> div"
          ],
          "line": 2496
        },
        "resolved": true,
        "details": {
          "function_name": "module_extend_max_pages",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/module_decompress.c",
          "lines": "17-32",
          "snippet": "static int module_extend_max_pages(struct load_info *info, unsigned int extent)\n{\n\tstruct page **new_pages;\n\n\tnew_pages = kvmalloc_array(info->max_pages + extent,\n\t\t\t\t   sizeof(info->pages), GFP_KERNEL);\n\tif (!new_pages)\n\t\treturn -ENOMEM;\n\n\tmemcpy(new_pages, info->pages, info->max_pages * sizeof(info->pages));\n\tkvfree(info->pages);\n\tinfo->pages = new_pages;\n\tinfo->max_pages += extent;\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/xz.h>",
            "#include <linux/zlib.h>",
            "#include \"module-internal.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/kobject.h>",
            "#include <linux/highmem.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/xz.h>\n#include <linux/zlib.h>\n#include \"module-internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/sysfs.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/kobject.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n\nstatic int module_extend_max_pages(struct load_info *info, unsigned int extent)\n{\n\tstruct page **new_pages;\n\n\tnew_pages = kvmalloc_array(info->max_pages + extent,\n\t\t\t\t   sizeof(info->pages), GFP_KERNEL);\n\tif (!new_pages)\n\t\treturn -ENOMEM;\n\n\tmemcpy(new_pages, info->pages, info->max_pages * sizeof(info->pages));\n\tkvfree(info->pages);\n\tinfo->pages = new_pages;\n\tinfo->max_pages += extent;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rcu_divisor"
          ],
          "line": 2494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "cpu_is_offline(smp_processor_id())"
          ],
          "line": 2492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_is_offline",
          "args": [
            "smp_processor_id()"
          ],
          "line": 2492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 2492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_nocb_lock_irqsave",
          "args": [
            "rdp",
            "flags"
          ],
          "line": 2491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_rcu_batch_end",
          "args": [
            "rcu_state.name",
            "0",
            "!rcu_segcblist_empty(&rdp->cblist)",
            "need_resched()",
            "is_idle_task(current)",
            "rcu_is_callbacks_kthread()"
          ],
          "line": 2479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_idle_task",
          "args": [
            "current"
          ],
          "line": 2481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "need_resched",
          "args": [],
          "line": 2481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_rcu_batch_start",
          "args": [
            "rcu_state.name",
            "rcu_segcblist_n_cbs(&rdp->cblist)",
            "0"
          ],
          "line": 2477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_segcblist_ready_cbs",
          "args": [
            "&rdp->cblist"
          ],
          "line": 2476
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_ready_cbs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.c",
          "lines": "278-282",
          "snippet": "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp)\n{\n\treturn rcu_segcblist_is_enabled(rsclp) &&\n\t       &rsclp->head != READ_ONCE(rsclp->tails[RCU_DONE_TAIL]);\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/cpu.h>\n\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp)\n{\n\treturn rcu_segcblist_is_enabled(rsclp) &&\n\t       &rsclp->head != READ_ONCE(rsclp->tails[RCU_DONE_TAIL]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "RCU_CBLIST_INITIALIZER",
          "args": [
            "rcl"
          ],
          "line": 2471
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define DEFAULT_MAX_RCU_BLIMIT 10000 // ... even during callback flood.\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};\nstatic struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\nstatic void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic bool rcu_rdp_is_offloaded(struct rcu_data *rdp);\nstatic long blimit = DEFAULT_RCU_BLIMIT;\nstatic long qhimark = DEFAULT_RCU_QHIMARK;\nstatic long qlowmark = DEFAULT_RCU_QLOMARK;\nstatic int rcu_divisor = 7;\nstatic long rcu_resched_ns = 3 * NSEC_PER_MSEC;\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nstatic void rcu_do_batch(struct rcu_data *rdp)\n{\n\tint div;\n\tbool __maybe_unused empty;\n\tunsigned long flags;\n\tstruct rcu_head *rhp;\n\tstruct rcu_cblist rcl = RCU_CBLIST_INITIALIZER(rcl);\n\tlong bl, count = 0;\n\tlong pending, tlimit = 0;\n\n\t/* If no callbacks are ready, just return. */\n\tif (!rcu_segcblist_ready_cbs(&rdp->cblist)) {\n\t\ttrace_rcu_batch_start(rcu_state.name,\n\t\t\t\t      rcu_segcblist_n_cbs(&rdp->cblist), 0);\n\t\ttrace_rcu_batch_end(rcu_state.name, 0,\n\t\t\t\t    !rcu_segcblist_empty(&rdp->cblist),\n\t\t\t\t    need_resched(), is_idle_task(current),\n\t\t\t\t    rcu_is_callbacks_kthread());\n\t\treturn;\n\t}\n\n\t/*\n\t * Extract the list of ready callbacks, disabling IRQs to prevent\n\t * races with call_rcu() from interrupt handlers.  Leave the\n\t * callback counts, as rcu_barrier() needs to be conservative.\n\t */\n\trcu_nocb_lock_irqsave(rdp, flags);\n\tWARN_ON_ONCE(cpu_is_offline(smp_processor_id()));\n\tpending = rcu_segcblist_n_cbs(&rdp->cblist);\n\tdiv = READ_ONCE(rcu_divisor);\n\tdiv = div < 0 ? 7 : div > sizeof(long) * 8 - 2 ? sizeof(long) * 8 - 2 : div;\n\tbl = max(rdp->blimit, pending >> div);\n\tif (in_serving_softirq() && unlikely(bl > 100)) {\n\t\tlong rrn = READ_ONCE(rcu_resched_ns);\n\n\t\trrn = rrn < NSEC_PER_MSEC ? NSEC_PER_MSEC : rrn > NSEC_PER_SEC ? NSEC_PER_SEC : rrn;\n\t\ttlimit = local_clock() + rrn;\n\t}\n\ttrace_rcu_batch_start(rcu_state.name,\n\t\t\t      rcu_segcblist_n_cbs(&rdp->cblist), bl);\n\trcu_segcblist_extract_done_cbs(&rdp->cblist, &rcl);\n\tif (rcu_rdp_is_offloaded(rdp))\n\t\trdp->qlen_last_fqs_check = rcu_segcblist_n_cbs(&rdp->cblist);\n\n\ttrace_rcu_segcb_stats(&rdp->cblist, TPS(\"SegCbDequeued\"));\n\trcu_nocb_unlock_irqrestore(rdp, flags);\n\n\t/* Invoke callbacks. */\n\ttick_dep_set_task(current, TICK_DEP_BIT_RCU);\n\trhp = rcu_cblist_dequeue(&rcl);\n\n\tfor (; rhp; rhp = rcu_cblist_dequeue(&rcl)) {\n\t\trcu_callback_t f;\n\n\t\tcount++;\n\t\tdebug_rcu_head_unqueue(rhp);\n\n\t\trcu_lock_acquire(&rcu_callback_map);\n\t\ttrace_rcu_invoke_callback(rcu_state.name, rhp);\n\n\t\tf = rhp->func;\n\t\tWRITE_ONCE(rhp->func, (rcu_callback_t)0L);\n\t\tf(rhp);\n\n\t\trcu_lock_release(&rcu_callback_map);\n\n\t\t/*\n\t\t * Stop only if limit reached and CPU has something to do.\n\t\t */\n\t\tif (in_serving_softirq()) {\n\t\t\tif (count >= bl && (need_resched() || !is_idle_task(current)))\n\t\t\t\tbreak;\n\t\t\t/*\n\t\t\t * Make sure we don't spend too much time here and deprive other\n\t\t\t * softirq vectors of CPU cycles.\n\t\t\t */\n\t\t\tif (unlikely(tlimit)) {\n\t\t\t\t/* only call local_clock() every 32 callbacks */\n\t\t\t\tif (likely((count & 31) || local_clock() < tlimit))\n\t\t\t\t\tcontinue;\n\t\t\t\t/* Exceeded the time limit, so leave. */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tlocal_bh_enable();\n\t\t\tlockdep_assert_irqs_enabled();\n\t\t\tcond_resched_tasks_rcu_qs();\n\t\t\tlockdep_assert_irqs_enabled();\n\t\t\tlocal_bh_disable();\n\t\t}\n\t}\n\n\trcu_nocb_lock_irqsave(rdp, flags);\n\trdp->n_cbs_invoked += count;\n\ttrace_rcu_batch_end(rcu_state.name, count, !!rcl.head, need_resched(),\n\t\t\t    is_idle_task(current), rcu_is_callbacks_kthread());\n\n\t/* Update counts and requeue any remaining callbacks. */\n\trcu_segcblist_insert_done_cbs(&rdp->cblist, &rcl);\n\trcu_segcblist_add_len(&rdp->cblist, -count);\n\n\t/* Reinstate batch limit if we have worked down the excess. */\n\tcount = rcu_segcblist_n_cbs(&rdp->cblist);\n\tif (rdp->blimit >= DEFAULT_MAX_RCU_BLIMIT && count <= qlowmark)\n\t\trdp->blimit = blimit;\n\n\t/* Reset ->qlen_last_fqs_check trigger if enough CBs have drained. */\n\tif (count == 0 && rdp->qlen_last_fqs_check != 0) {\n\t\trdp->qlen_last_fqs_check = 0;\n\t\trdp->n_force_qs_snap = READ_ONCE(rcu_state.n_force_qs);\n\t} else if (count < rdp->qlen_last_fqs_check - qhimark)\n\t\trdp->qlen_last_fqs_check = count;\n\n\t/*\n\t * The following usually indicates a double call_rcu().  To track\n\t * this down, try building with CONFIG_DEBUG_OBJECTS_RCU_HEAD=y.\n\t */\n\tempty = rcu_segcblist_empty(&rdp->cblist);\n\tWARN_ON_ONCE(count == 0 && !empty);\n\tWARN_ON_ONCE(!IS_ENABLED(CONFIG_RCU_NOCB_CPU) &&\n\t\t     count != 0 && empty);\n\tWARN_ON_ONCE(count == 0 && rcu_segcblist_n_segment_cbs(&rdp->cblist) != 0);\n\tWARN_ON_ONCE(!empty && rcu_segcblist_n_segment_cbs(&rdp->cblist) == 0);\n\n\trcu_nocb_unlock_irqrestore(rdp, flags);\n\n\ttick_dep_clear_task(current, TICK_DEP_BIT_RCU);\n}"
  },
  {
    "function_name": "rcutree_dead_cpu",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
    "lines": "2445-2459",
    "snippet": "int rcutree_dead_cpu(unsigned int cpu)\n{\n\tstruct rcu_data *rdp = per_cpu_ptr(&rcu_data, cpu);\n\tstruct rcu_node *rnp = rdp->mynode;  /* Outgoing CPU's rdp & rnp. */\n\n\tif (!IS_ENABLED(CONFIG_HOTPLUG_CPU))\n\t\treturn 0;\n\n\tWRITE_ONCE(rcu_state.n_online_cpus, rcu_state.n_online_cpus - 1);\n\t/* Adjust any no-longer-needed kthreads. */\n\trcu_boost_kthread_setaffinity(rnp, -1);\n\t// Stop-machine done, so allow nohz_full to disable tick.\n\ttick_dep_clear(TICK_DEP_BIT_RCU);\n\treturn 0;\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_nocb.h\"",
      "#include \"tree_exp.h\"",
      "#include \"tree_stall.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <linux/kasan.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/panic_notifier.h>",
      "#include <linux/panic.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};",
      "static struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};",
      "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
      "static void sync_sched_exp_online_cleanup(int cpu);",
      "static void check_cb_ovld_locked(struct rcu_data *rdp, struct rcu_node *rnp);",
      "static bool rcu_rdp_is_offloaded(struct rcu_data *rdp);",
      "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tick_dep_clear",
          "args": [
            "TICK_DEP_BIT_RCU"
          ],
          "line": 2457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_boost_kthread_setaffinity",
          "args": [
            "rnp",
            "-1"
          ],
          "line": 2455
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_boost_kthread_setaffinity",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "1257-1259",
          "snippet": "static void rcu_boost_kthread_setaffinity(struct rcu_node *rnp, int outgoingcpu)\n{\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nstatic void rcu_boost_kthread_setaffinity(struct rcu_node *rnp, int outgoingcpu)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "rcu_state.n_online_cpus",
            "rcu_state.n_online_cpus - 1"
          ],
          "line": 2453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_HOTPLUG_CPU"
          ],
          "line": 2450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "&rcu_data",
            "cpu"
          ],
          "line": 2447
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};\nstatic struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void sync_sched_exp_online_cleanup(int cpu);\nstatic void check_cb_ovld_locked(struct rcu_data *rdp, struct rcu_node *rnp);\nstatic bool rcu_rdp_is_offloaded(struct rcu_data *rdp);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nint rcutree_dead_cpu(unsigned int cpu)\n{\n\tstruct rcu_data *rdp = per_cpu_ptr(&rcu_data, cpu);\n\tstruct rcu_node *rnp = rdp->mynode;  /* Outgoing CPU's rdp & rnp. */\n\n\tif (!IS_ENABLED(CONFIG_HOTPLUG_CPU))\n\t\treturn 0;\n\n\tWRITE_ONCE(rcu_state.n_online_cpus, rcu_state.n_online_cpus - 1);\n\t/* Adjust any no-longer-needed kthreads. */\n\trcu_boost_kthread_setaffinity(rnp, -1);\n\t// Stop-machine done, so allow nohz_full to disable tick.\n\ttick_dep_clear(TICK_DEP_BIT_RCU);\n\treturn 0;\n}"
  },
  {
    "function_name": "rcu_cleanup_dead_rnp",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
    "lines": "2411-2437",
    "snippet": "static void rcu_cleanup_dead_rnp(struct rcu_node *rnp_leaf)\n{\n\tlong mask;\n\tstruct rcu_node *rnp = rnp_leaf;\n\n\traw_lockdep_assert_held_rcu_node(rnp_leaf);\n\tif (!IS_ENABLED(CONFIG_HOTPLUG_CPU) ||\n\t    WARN_ON_ONCE(rnp_leaf->qsmaskinit) ||\n\t    WARN_ON_ONCE(rcu_preempt_has_tasks(rnp_leaf)))\n\t\treturn;\n\tfor (;;) {\n\t\tmask = rnp->grpmask;\n\t\trnp = rnp->parent;\n\t\tif (!rnp)\n\t\t\tbreak;\n\t\traw_spin_lock_rcu_node(rnp); /* irqs already disabled. */\n\t\trnp->qsmaskinit &= ~mask;\n\t\t/* Between grace periods, so better already be zero! */\n\t\tWARN_ON_ONCE(rnp->qsmask);\n\t\tif (rnp->qsmaskinit) {\n\t\t\traw_spin_unlock_rcu_node(rnp);\n\t\t\t/* irqs remain disabled. */\n\t\t\treturn;\n\t\t}\n\t\traw_spin_unlock_rcu_node(rnp); /* irqs remain disabled. */\n\t}\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_nocb.h\"",
      "#include \"tree_exp.h\"",
      "#include \"tree_stall.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <linux/kasan.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/panic_notifier.h>",
      "#include <linux/panic.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void rcu_init_new_rnp(struct rcu_node *rnp_leaf);",
      "static void rcu_cleanup_dead_rnp(struct rcu_node *rnp_leaf);",
      "static void check_cb_ovld_locked(struct rcu_data *rdp, struct rcu_node *rnp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock_rcu_node",
          "args": [
            "rnp"
          ],
          "line": 2435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_rcu_node",
          "args": [
            "rnp"
          ],
          "line": 2431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "rnp->qsmask"
          ],
          "line": 2429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_rcu_node",
          "args": [
            "rnp"
          ],
          "line": 2426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "rcu_preempt_has_tasks(rnp_leaf)"
          ],
          "line": 2419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_preempt_has_tasks",
          "args": [
            "rnp_leaf"
          ],
          "line": 2419
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_preempt_has_tasks",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "915-918",
          "snippet": "static bool rcu_preempt_has_tasks(struct rcu_node *rnp)\n{\n\treturn false;\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nstatic bool rcu_preempt_has_tasks(struct rcu_node *rnp)\n{\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "rnp_leaf->qsmaskinit"
          ],
          "line": 2418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_HOTPLUG_CPU"
          ],
          "line": 2417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_lockdep_assert_held_rcu_node",
          "args": [
            "rnp_leaf"
          ],
          "line": 2416
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic void rcu_init_new_rnp(struct rcu_node *rnp_leaf);\nstatic void rcu_cleanup_dead_rnp(struct rcu_node *rnp_leaf);\nstatic void check_cb_ovld_locked(struct rcu_data *rdp, struct rcu_node *rnp);\n\nstatic void rcu_cleanup_dead_rnp(struct rcu_node *rnp_leaf)\n{\n\tlong mask;\n\tstruct rcu_node *rnp = rnp_leaf;\n\n\traw_lockdep_assert_held_rcu_node(rnp_leaf);\n\tif (!IS_ENABLED(CONFIG_HOTPLUG_CPU) ||\n\t    WARN_ON_ONCE(rnp_leaf->qsmaskinit) ||\n\t    WARN_ON_ONCE(rcu_preempt_has_tasks(rnp_leaf)))\n\t\treturn;\n\tfor (;;) {\n\t\tmask = rnp->grpmask;\n\t\trnp = rnp->parent;\n\t\tif (!rnp)\n\t\t\tbreak;\n\t\traw_spin_lock_rcu_node(rnp); /* irqs already disabled. */\n\t\trnp->qsmaskinit &= ~mask;\n\t\t/* Between grace periods, so better already be zero! */\n\t\tWARN_ON_ONCE(rnp->qsmask);\n\t\tif (rnp->qsmaskinit) {\n\t\t\traw_spin_unlock_rcu_node(rnp);\n\t\t\t/* irqs remain disabled. */\n\t\t\treturn;\n\t\t}\n\t\traw_spin_unlock_rcu_node(rnp); /* irqs remain disabled. */\n\t}\n}"
  },
  {
    "function_name": "rcutree_dying_cpu",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
    "lines": "2379-2392",
    "snippet": "int rcutree_dying_cpu(unsigned int cpu)\n{\n\tbool blkd;\n\tstruct rcu_data *rdp = per_cpu_ptr(&rcu_data, cpu);\n\tstruct rcu_node *rnp = rdp->mynode;\n\n\tif (!IS_ENABLED(CONFIG_HOTPLUG_CPU))\n\t\treturn 0;\n\n\tblkd = !!(rnp->qsmask & rdp->grpmask);\n\ttrace_rcu_grace_period(rcu_state.name, READ_ONCE(rnp->gp_seq),\n\t\t\t       blkd ? TPS(\"cpuofl-bgp\") : TPS(\"cpuofl\"));\n\treturn 0;\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_nocb.h\"",
      "#include \"tree_exp.h\"",
      "#include \"tree_stall.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <linux/kasan.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/panic_notifier.h>",
      "#include <linux/panic.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};",
      "static struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};",
      "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
      "static void sync_sched_exp_online_cleanup(int cpu);",
      "static void check_cb_ovld_locked(struct rcu_data *rdp, struct rcu_node *rnp);",
      "static bool rcu_rdp_is_offloaded(struct rcu_data *rdp);",
      "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_rcu_grace_period",
          "args": [
            "rcu_state.name",
            "READ_ONCE(rnp->gp_seq)",
            "blkd ? TPS(\"cpuofl-bgp\") : TPS(\"cpuofl\")"
          ],
          "line": 2389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPS",
          "args": [
            "\"cpuofl\""
          ],
          "line": 2390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPS",
          "args": [
            "\"cpuofl-bgp\""
          ],
          "line": 2390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rnp->gp_seq"
          ],
          "line": 2389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_HOTPLUG_CPU"
          ],
          "line": 2385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "&rcu_data",
            "cpu"
          ],
          "line": 2382
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};\nstatic struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void sync_sched_exp_online_cleanup(int cpu);\nstatic void check_cb_ovld_locked(struct rcu_data *rdp, struct rcu_node *rnp);\nstatic bool rcu_rdp_is_offloaded(struct rcu_data *rdp);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nint rcutree_dying_cpu(unsigned int cpu)\n{\n\tbool blkd;\n\tstruct rcu_data *rdp = per_cpu_ptr(&rcu_data, cpu);\n\tstruct rcu_node *rnp = rdp->mynode;\n\n\tif (!IS_ENABLED(CONFIG_HOTPLUG_CPU))\n\t\treturn 0;\n\n\tblkd = !!(rnp->qsmask & rdp->grpmask);\n\ttrace_rcu_grace_period(rcu_state.name, READ_ONCE(rnp->gp_seq),\n\t\t\t       blkd ? TPS(\"cpuofl-bgp\") : TPS(\"cpuofl\"));\n\treturn 0;\n}"
  },
  {
    "function_name": "rcu_check_quiescent_state",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
    "lines": "2348-2373",
    "snippet": "static void\nrcu_check_quiescent_state(struct rcu_data *rdp)\n{\n\t/* Check for grace-period ends and beginnings. */\n\tnote_gp_changes(rdp);\n\n\t/*\n\t * Does this CPU still need to do its part for current grace period?\n\t * If no, return and let the other CPUs do their part as well.\n\t */\n\tif (!rdp->core_needs_qs)\n\t\treturn;\n\n\t/*\n\t * Was there a quiescent state since the beginning of the grace\n\t * period? If no, then exit and wait for the next call.\n\t */\n\tif (rdp->cpu_no_qs.b.norm)\n\t\treturn;\n\n\t/*\n\t * Tell RCU we are done (but rcu_report_qs_rdp() will be the\n\t * judge of that).\n\t */\n\trcu_report_qs_rdp(rdp);\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_nocb.h\"",
      "#include \"tree_exp.h\"",
      "#include \"tree_stall.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <linux/kasan.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/panic_notifier.h>",
      "#include <linux/panic.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};",
      "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
      "static bool rcu_rdp_is_offloaded(struct rcu_data *rdp);",
      "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_report_qs_rdp",
          "args": [
            "rdp"
          ],
          "line": 2372
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_report_qs_rdp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "2282-2340",
          "snippet": "static void\nrcu_report_qs_rdp(struct rcu_data *rdp)\n{\n\tunsigned long flags;\n\tunsigned long mask;\n\tbool needwake = false;\n\tbool needacc = false;\n\tstruct rcu_node *rnp;\n\n\tWARN_ON_ONCE(rdp->cpu != smp_processor_id());\n\trnp = rdp->mynode;\n\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\tif (rdp->cpu_no_qs.b.norm || rdp->gp_seq != rnp->gp_seq ||\n\t    rdp->gpwrap) {\n\n\t\t/*\n\t\t * The grace period in which this quiescent state was\n\t\t * recorded has ended, so don't report it upwards.\n\t\t * We will instead need a new quiescent state that lies\n\t\t * within the current grace period.\n\t\t */\n\t\trdp->cpu_no_qs.b.norm = true;\t/* need qs for new gp. */\n\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\treturn;\n\t}\n\tmask = rdp->grpmask;\n\trdp->core_needs_qs = false;\n\tif ((rnp->qsmask & mask) == 0) {\n\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t} else {\n\t\t/*\n\t\t * This GP can't end until cpu checks in, so all of our\n\t\t * callbacks can be processed during the next GP.\n\t\t *\n\t\t * NOCB kthreads have their own way to deal with that...\n\t\t */\n\t\tif (!rcu_rdp_is_offloaded(rdp)) {\n\t\t\tneedwake = rcu_accelerate_cbs(rnp, rdp);\n\t\t} else if (!rcu_segcblist_completely_offloaded(&rdp->cblist)) {\n\t\t\t/*\n\t\t\t * ...but NOCB kthreads may miss or delay callbacks acceleration\n\t\t\t * if in the middle of a (de-)offloading process.\n\t\t\t */\n\t\t\tneedacc = true;\n\t\t}\n\n\t\trcu_disable_urgency_upon_qs(rdp);\n\t\trcu_report_qs_rnp(mask, rnp, rnp->gp_seq, flags);\n\t\t/* ^^^ Released rnp->lock */\n\t\tif (needwake)\n\t\t\trcu_gp_kthread_wake();\n\n\t\tif (needacc) {\n\t\t\trcu_nocb_lock_irqsave(rdp, flags);\n\t\t\trcu_accelerate_cbs_unlocked(rnp, rdp);\n\t\t\trcu_nocb_unlock_irqrestore(rdp, flags);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};",
            "static void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);",
            "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
            "static void sync_sched_exp_online_cleanup(int cpu);",
            "static void check_cb_ovld_locked(struct rcu_data *rdp, struct rcu_node *rnp);",
            "static bool rcu_rdp_is_offloaded(struct rcu_data *rdp);",
            "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};\nstatic void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void sync_sched_exp_online_cleanup(int cpu);\nstatic void check_cb_ovld_locked(struct rcu_data *rdp, struct rcu_node *rnp);\nstatic bool rcu_rdp_is_offloaded(struct rcu_data *rdp);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nstatic void\nrcu_report_qs_rdp(struct rcu_data *rdp)\n{\n\tunsigned long flags;\n\tunsigned long mask;\n\tbool needwake = false;\n\tbool needacc = false;\n\tstruct rcu_node *rnp;\n\n\tWARN_ON_ONCE(rdp->cpu != smp_processor_id());\n\trnp = rdp->mynode;\n\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\tif (rdp->cpu_no_qs.b.norm || rdp->gp_seq != rnp->gp_seq ||\n\t    rdp->gpwrap) {\n\n\t\t/*\n\t\t * The grace period in which this quiescent state was\n\t\t * recorded has ended, so don't report it upwards.\n\t\t * We will instead need a new quiescent state that lies\n\t\t * within the current grace period.\n\t\t */\n\t\trdp->cpu_no_qs.b.norm = true;\t/* need qs for new gp. */\n\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\treturn;\n\t}\n\tmask = rdp->grpmask;\n\trdp->core_needs_qs = false;\n\tif ((rnp->qsmask & mask) == 0) {\n\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t} else {\n\t\t/*\n\t\t * This GP can't end until cpu checks in, so all of our\n\t\t * callbacks can be processed during the next GP.\n\t\t *\n\t\t * NOCB kthreads have their own way to deal with that...\n\t\t */\n\t\tif (!rcu_rdp_is_offloaded(rdp)) {\n\t\t\tneedwake = rcu_accelerate_cbs(rnp, rdp);\n\t\t} else if (!rcu_segcblist_completely_offloaded(&rdp->cblist)) {\n\t\t\t/*\n\t\t\t * ...but NOCB kthreads may miss or delay callbacks acceleration\n\t\t\t * if in the middle of a (de-)offloading process.\n\t\t\t */\n\t\t\tneedacc = true;\n\t\t}\n\n\t\trcu_disable_urgency_upon_qs(rdp);\n\t\trcu_report_qs_rnp(mask, rnp, rnp->gp_seq, flags);\n\t\t/* ^^^ Released rnp->lock */\n\t\tif (needwake)\n\t\t\trcu_gp_kthread_wake();\n\n\t\tif (needacc) {\n\t\t\trcu_nocb_lock_irqsave(rdp, flags);\n\t\t\trcu_accelerate_cbs_unlocked(rnp, rdp);\n\t\t\trcu_nocb_unlock_irqrestore(rdp, flags);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "note_gp_changes",
          "args": [
            "rdp"
          ],
          "line": 2352
        },
        "resolved": true,
        "details": {
          "function_name": "note_gp_changes",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "1674-1693",
          "snippet": "static void note_gp_changes(struct rcu_data *rdp)\n{\n\tunsigned long flags;\n\tbool needwake;\n\tstruct rcu_node *rnp;\n\n\tlocal_irq_save(flags);\n\trnp = rdp->mynode;\n\tif ((rdp->gp_seq == rcu_seq_current(&rnp->gp_seq) &&\n\t     !unlikely(READ_ONCE(rdp->gpwrap))) || /* w/out lock. */\n\t    !raw_spin_trylock_rcu_node(rnp)) { /* irqs already off, so later. */\n\t\tlocal_irq_restore(flags);\n\t\treturn;\n\t}\n\tneedwake = __note_gp_changes(rnp, rdp);\n\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\trcu_strict_gp_check_qs();\n\tif (needwake)\n\t\trcu_gp_kthread_wake();\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};",
            "static void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);",
            "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
            "static void check_cb_ovld_locked(struct rcu_data *rdp, struct rcu_node *rnp);",
            "static bool rcu_rdp_is_offloaded(struct rcu_data *rdp);",
            "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};\nstatic void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void check_cb_ovld_locked(struct rcu_data *rdp, struct rcu_node *rnp);\nstatic bool rcu_rdp_is_offloaded(struct rcu_data *rdp);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nstatic void note_gp_changes(struct rcu_data *rdp)\n{\n\tunsigned long flags;\n\tbool needwake;\n\tstruct rcu_node *rnp;\n\n\tlocal_irq_save(flags);\n\trnp = rdp->mynode;\n\tif ((rdp->gp_seq == rcu_seq_current(&rnp->gp_seq) &&\n\t     !unlikely(READ_ONCE(rdp->gpwrap))) || /* w/out lock. */\n\t    !raw_spin_trylock_rcu_node(rnp)) { /* irqs already off, so later. */\n\t\tlocal_irq_restore(flags);\n\t\treturn;\n\t}\n\tneedwake = __note_gp_changes(rnp, rdp);\n\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\trcu_strict_gp_check_qs();\n\tif (needwake)\n\t\trcu_gp_kthread_wake();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic bool rcu_rdp_is_offloaded(struct rcu_data *rdp);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nstatic void\nrcu_check_quiescent_state(struct rcu_data *rdp)\n{\n\t/* Check for grace-period ends and beginnings. */\n\tnote_gp_changes(rdp);\n\n\t/*\n\t * Does this CPU still need to do its part for current grace period?\n\t * If no, return and let the other CPUs do their part as well.\n\t */\n\tif (!rdp->core_needs_qs)\n\t\treturn;\n\n\t/*\n\t * Was there a quiescent state since the beginning of the grace\n\t * period? If no, then exit and wait for the next call.\n\t */\n\tif (rdp->cpu_no_qs.b.norm)\n\t\treturn;\n\n\t/*\n\t * Tell RCU we are done (but rcu_report_qs_rdp() will be the\n\t * judge of that).\n\t */\n\trcu_report_qs_rdp(rdp);\n}"
  },
  {
    "function_name": "rcu_report_qs_rdp",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
    "lines": "2282-2340",
    "snippet": "static void\nrcu_report_qs_rdp(struct rcu_data *rdp)\n{\n\tunsigned long flags;\n\tunsigned long mask;\n\tbool needwake = false;\n\tbool needacc = false;\n\tstruct rcu_node *rnp;\n\n\tWARN_ON_ONCE(rdp->cpu != smp_processor_id());\n\trnp = rdp->mynode;\n\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\tif (rdp->cpu_no_qs.b.norm || rdp->gp_seq != rnp->gp_seq ||\n\t    rdp->gpwrap) {\n\n\t\t/*\n\t\t * The grace period in which this quiescent state was\n\t\t * recorded has ended, so don't report it upwards.\n\t\t * We will instead need a new quiescent state that lies\n\t\t * within the current grace period.\n\t\t */\n\t\trdp->cpu_no_qs.b.norm = true;\t/* need qs for new gp. */\n\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\treturn;\n\t}\n\tmask = rdp->grpmask;\n\trdp->core_needs_qs = false;\n\tif ((rnp->qsmask & mask) == 0) {\n\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t} else {\n\t\t/*\n\t\t * This GP can't end until cpu checks in, so all of our\n\t\t * callbacks can be processed during the next GP.\n\t\t *\n\t\t * NOCB kthreads have their own way to deal with that...\n\t\t */\n\t\tif (!rcu_rdp_is_offloaded(rdp)) {\n\t\t\tneedwake = rcu_accelerate_cbs(rnp, rdp);\n\t\t} else if (!rcu_segcblist_completely_offloaded(&rdp->cblist)) {\n\t\t\t/*\n\t\t\t * ...but NOCB kthreads may miss or delay callbacks acceleration\n\t\t\t * if in the middle of a (de-)offloading process.\n\t\t\t */\n\t\t\tneedacc = true;\n\t\t}\n\n\t\trcu_disable_urgency_upon_qs(rdp);\n\t\trcu_report_qs_rnp(mask, rnp, rnp->gp_seq, flags);\n\t\t/* ^^^ Released rnp->lock */\n\t\tif (needwake)\n\t\t\trcu_gp_kthread_wake();\n\n\t\tif (needacc) {\n\t\t\trcu_nocb_lock_irqsave(rdp, flags);\n\t\t\trcu_accelerate_cbs_unlocked(rnp, rdp);\n\t\t\trcu_nocb_unlock_irqrestore(rdp, flags);\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_nocb.h\"",
      "#include \"tree_exp.h\"",
      "#include \"tree_stall.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <linux/kasan.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/panic_notifier.h>",
      "#include <linux/panic.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};",
      "static void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);",
      "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
      "static void sync_sched_exp_online_cleanup(int cpu);",
      "static void check_cb_ovld_locked(struct rcu_data *rdp, struct rcu_node *rnp);",
      "static bool rcu_rdp_is_offloaded(struct rcu_data *rdp);",
      "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_nocb_unlock_irqrestore",
          "args": [
            "rdp",
            "flags"
          ],
          "line": 2337
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_nocb_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_nocb.h",
          "lines": "1479-1483",
          "snippet": "static void rcu_nocb_unlock_irqrestore(struct rcu_data *rdp,\n\t\t\t\t       unsigned long flags)\n{\n\tlocal_irq_restore(flags);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static void rcu_nocb_unlock_irqrestore(struct rcu_data *rdp,\n\t\t\t\t       unsigned long flags)\n{\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_accelerate_cbs_unlocked",
          "args": [
            "rnp",
            "rdp"
          ],
          "line": 2336
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_accelerate_cbs_unlocked",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "1543-1561",
          "snippet": "static void rcu_accelerate_cbs_unlocked(struct rcu_node *rnp,\n\t\t\t\t\tstruct rcu_data *rdp)\n{\n\tunsigned long c;\n\tbool needwake;\n\n\trcu_lockdep_assert_cblist_protected(rdp);\n\tc = rcu_seq_snap(&rcu_state.gp_seq);\n\tif (!READ_ONCE(rdp->gpwrap) && ULONG_CMP_GE(rdp->gp_seq_needed, c)) {\n\t\t/* Old request still live, so mark recent callbacks. */\n\t\t(void)rcu_segcblist_accelerate(&rdp->cblist, c);\n\t\treturn;\n\t}\n\traw_spin_lock_rcu_node(rnp); /* irqs already disabled. */\n\tneedwake = rcu_accelerate_cbs(rnp, rdp);\n\traw_spin_unlock_rcu_node(rnp); /* irqs remain disabled. */\n\tif (needwake)\n\t\trcu_gp_kthread_wake();\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};",
            "static struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};",
            "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
            "static void check_cb_ovld_locked(struct rcu_data *rdp, struct rcu_node *rnp);",
            "static bool rcu_rdp_is_offloaded(struct rcu_data *rdp);",
            "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};\nstatic struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void check_cb_ovld_locked(struct rcu_data *rdp, struct rcu_node *rnp);\nstatic bool rcu_rdp_is_offloaded(struct rcu_data *rdp);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nstatic void rcu_accelerate_cbs_unlocked(struct rcu_node *rnp,\n\t\t\t\t\tstruct rcu_data *rdp)\n{\n\tunsigned long c;\n\tbool needwake;\n\n\trcu_lockdep_assert_cblist_protected(rdp);\n\tc = rcu_seq_snap(&rcu_state.gp_seq);\n\tif (!READ_ONCE(rdp->gpwrap) && ULONG_CMP_GE(rdp->gp_seq_needed, c)) {\n\t\t/* Old request still live, so mark recent callbacks. */\n\t\t(void)rcu_segcblist_accelerate(&rdp->cblist, c);\n\t\treturn;\n\t}\n\traw_spin_lock_rcu_node(rnp); /* irqs already disabled. */\n\tneedwake = rcu_accelerate_cbs(rnp, rdp);\n\traw_spin_unlock_rcu_node(rnp); /* irqs remain disabled. */\n\tif (needwake)\n\t\trcu_gp_kthread_wake();\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_nocb_lock_irqsave",
          "args": [
            "rdp",
            "flags"
          ],
          "line": 2335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_gp_kthread_wake",
          "args": [],
          "line": 2332
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_gp_kthread_wake",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "1473-1483",
          "snippet": "static void rcu_gp_kthread_wake(void)\n{\n\tstruct task_struct *t = READ_ONCE(rcu_state.gp_kthread);\n\n\tif ((current == t && !in_hardirq() && !in_serving_softirq()) ||\n\t    !READ_ONCE(rcu_state.gp_flags) || !t)\n\t\treturn;\n\tWRITE_ONCE(rcu_state.gp_wake_time, jiffies);\n\tWRITE_ONCE(rcu_state.gp_wake_seq, READ_ONCE(rcu_state.gp_seq));\n\tswake_up_one(&rcu_state.gp_wq);\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\n\nstatic void rcu_gp_kthread_wake(void)\n{\n\tstruct task_struct *t = READ_ONCE(rcu_state.gp_kthread);\n\n\tif ((current == t && !in_hardirq() && !in_serving_softirq()) ||\n\t    !READ_ONCE(rcu_state.gp_flags) || !t)\n\t\treturn;\n\tWRITE_ONCE(rcu_state.gp_wake_time, jiffies);\n\tWRITE_ONCE(rcu_state.gp_wake_seq, READ_ONCE(rcu_state.gp_seq));\n\tswake_up_one(&rcu_state.gp_wq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_report_qs_rnp",
          "args": [
            "mask",
            "rnp",
            "rnp->gp_seq",
            "flags"
          ],
          "line": 2329
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_report_qs_rnp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "2179-2234",
          "snippet": "static void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags)\n\t__releases(rnp->lock)\n{\n\tunsigned long oldmask = 0;\n\tstruct rcu_node *rnp_c;\n\n\traw_lockdep_assert_held_rcu_node(rnp);\n\n\t/* Walk up the rcu_node hierarchy. */\n\tfor (;;) {\n\t\tif ((!(rnp->qsmask & mask) && mask) || rnp->gp_seq != gps) {\n\n\t\t\t/*\n\t\t\t * Our bit has already been cleared, or the\n\t\t\t * relevant grace period is already over, so done.\n\t\t\t */\n\t\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\t\treturn;\n\t\t}\n\t\tWARN_ON_ONCE(oldmask); /* Any child must be all zeroed! */\n\t\tWARN_ON_ONCE(!rcu_is_leaf_node(rnp) &&\n\t\t\t     rcu_preempt_blocked_readers_cgp(rnp));\n\t\tWRITE_ONCE(rnp->qsmask, rnp->qsmask & ~mask);\n\t\ttrace_rcu_quiescent_state_report(rcu_state.name, rnp->gp_seq,\n\t\t\t\t\t\t mask, rnp->qsmask, rnp->level,\n\t\t\t\t\t\t rnp->grplo, rnp->grphi,\n\t\t\t\t\t\t !!rnp->gp_tasks);\n\t\tif (rnp->qsmask != 0 || rcu_preempt_blocked_readers_cgp(rnp)) {\n\n\t\t\t/* Other bits still set at this level, so done. */\n\t\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\t\treturn;\n\t\t}\n\t\trnp->completedqs = rnp->gp_seq;\n\t\tmask = rnp->grpmask;\n\t\tif (rnp->parent == NULL) {\n\n\t\t\t/* No more levels.  Exit loop holding root lock. */\n\n\t\t\tbreak;\n\t\t}\n\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\trnp_c = rnp;\n\t\trnp = rnp->parent;\n\t\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\t\toldmask = READ_ONCE(rnp_c->qsmask);\n\t}\n\n\t/*\n\t * Get here if we are the last CPU to pass through a quiescent\n\t * state for this grace period.  Invoke rcu_report_qs_rsp()\n\t * to clean up and start the next grace period if one is needed.\n\t */\n\trcu_report_qs_rsp(flags); /* releases rnp->lock. */\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};",
            "static void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);",
            "static void check_cb_ovld_locked(struct rcu_data *rdp, struct rcu_node *rnp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\nstatic void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);\nstatic void check_cb_ovld_locked(struct rcu_data *rdp, struct rcu_node *rnp);\n\nstatic void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags)\n\t__releases(rnp->lock)\n{\n\tunsigned long oldmask = 0;\n\tstruct rcu_node *rnp_c;\n\n\traw_lockdep_assert_held_rcu_node(rnp);\n\n\t/* Walk up the rcu_node hierarchy. */\n\tfor (;;) {\n\t\tif ((!(rnp->qsmask & mask) && mask) || rnp->gp_seq != gps) {\n\n\t\t\t/*\n\t\t\t * Our bit has already been cleared, or the\n\t\t\t * relevant grace period is already over, so done.\n\t\t\t */\n\t\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\t\treturn;\n\t\t}\n\t\tWARN_ON_ONCE(oldmask); /* Any child must be all zeroed! */\n\t\tWARN_ON_ONCE(!rcu_is_leaf_node(rnp) &&\n\t\t\t     rcu_preempt_blocked_readers_cgp(rnp));\n\t\tWRITE_ONCE(rnp->qsmask, rnp->qsmask & ~mask);\n\t\ttrace_rcu_quiescent_state_report(rcu_state.name, rnp->gp_seq,\n\t\t\t\t\t\t mask, rnp->qsmask, rnp->level,\n\t\t\t\t\t\t rnp->grplo, rnp->grphi,\n\t\t\t\t\t\t !!rnp->gp_tasks);\n\t\tif (rnp->qsmask != 0 || rcu_preempt_blocked_readers_cgp(rnp)) {\n\n\t\t\t/* Other bits still set at this level, so done. */\n\t\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\t\treturn;\n\t\t}\n\t\trnp->completedqs = rnp->gp_seq;\n\t\tmask = rnp->grpmask;\n\t\tif (rnp->parent == NULL) {\n\n\t\t\t/* No more levels.  Exit loop holding root lock. */\n\n\t\t\tbreak;\n\t\t}\n\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\trnp_c = rnp;\n\t\trnp = rnp->parent;\n\t\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\t\toldmask = READ_ONCE(rnp_c->qsmask);\n\t}\n\n\t/*\n\t * Get here if we are the last CPU to pass through a quiescent\n\t * state for this grace period.  Invoke rcu_report_qs_rsp()\n\t * to clean up and start the next grace period if one is needed.\n\t */\n\trcu_report_qs_rsp(flags); /* releases rnp->lock. */\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_disable_urgency_upon_qs",
          "args": [
            "rdp"
          ],
          "line": 2328
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_disable_urgency_upon_qs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "1101-1110",
          "snippet": "static void rcu_disable_urgency_upon_qs(struct rcu_data *rdp)\n{\n\traw_lockdep_assert_held_rcu_node(rdp->mynode);\n\tWRITE_ONCE(rdp->rcu_urgent_qs, false);\n\tWRITE_ONCE(rdp->rcu_need_heavy_qs, false);\n\tif (tick_nohz_full_cpu(rdp->cpu) && rdp->rcu_forced_tick) {\n\t\ttick_dep_clear_cpu(rdp->cpu, TICK_DEP_BIT_RCU);\n\t\tWRITE_ONCE(rdp->rcu_forced_tick, false);\n\t}\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};",
            "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
            "static void sync_sched_exp_online_cleanup(int cpu);",
            "static bool rcu_rdp_is_offloaded(struct rcu_data *rdp);",
            "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void sync_sched_exp_online_cleanup(int cpu);\nstatic bool rcu_rdp_is_offloaded(struct rcu_data *rdp);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nstatic void rcu_disable_urgency_upon_qs(struct rcu_data *rdp)\n{\n\traw_lockdep_assert_held_rcu_node(rdp->mynode);\n\tWRITE_ONCE(rdp->rcu_urgent_qs, false);\n\tWRITE_ONCE(rdp->rcu_need_heavy_qs, false);\n\tif (tick_nohz_full_cpu(rdp->cpu) && rdp->rcu_forced_tick) {\n\t\ttick_dep_clear_cpu(rdp->cpu, TICK_DEP_BIT_RCU);\n\t\tWRITE_ONCE(rdp->rcu_forced_tick, false);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_segcblist_completely_offloaded",
          "args": [
            "&rdp->cblist"
          ],
          "line": 2320
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_completely_offloaded",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "96-103",
          "snippet": "static inline bool rcu_segcblist_completely_offloaded(struct rcu_segcblist *rsclp)\n{\n\tif (IS_ENABLED(CONFIG_RCU_NOCB_CPU) &&\n\t    !rcu_segcblist_test_flags(rsclp, SEGCBLIST_RCU_CORE))\n\t\treturn true;\n\n\treturn false;\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "long rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nlong rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_completely_offloaded(struct rcu_segcblist *rsclp)\n{\n\tif (IS_ENABLED(CONFIG_RCU_NOCB_CPU) &&\n\t    !rcu_segcblist_test_flags(rsclp, SEGCBLIST_RCU_CORE))\n\t\treturn true;\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_rdp_is_offloaded",
          "args": [
            "rdp"
          ],
          "line": 2318
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_rdp_is_offloaded",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "16-38",
          "snippet": "static bool rcu_rdp_is_offloaded(struct rcu_data *rdp)\n{\n\t/*\n\t * In order to read the offloaded state of an rdp in a safe\n\t * and stable way and prevent from its value to be changed\n\t * under us, we must either hold the barrier mutex, the cpu\n\t * hotplug lock (read or write) or the nocb lock. Local\n\t * non-preemptible reads are also safe. NOCB kthreads and\n\t * timers have their own means of synchronization against the\n\t * offloaded state updaters.\n\t */\n\tRCU_LOCKDEP_WARN(\n\t\t!(lockdep_is_held(&rcu_state.barrier_mutex) ||\n\t\t  (IS_ENABLED(CONFIG_HOTPLUG_CPU) && lockdep_is_cpus_held()) ||\n\t\t  rcu_lockdep_is_held_nocb(rdp) ||\n\t\t  (rdp == this_cpu_ptr(&rcu_data) &&\n\t\t   !(IS_ENABLED(CONFIG_PREEMPT_COUNT) && preemptible())) ||\n\t\t  rcu_current_is_nocb_kthread(rdp)),\n\t\t\"Unsafe read of RCU_NOCB offloaded state\"\n\t);\n\n\treturn rcu_segcblist_is_offloaded(&rdp->cblist);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nstatic bool rcu_rdp_is_offloaded(struct rcu_data *rdp)\n{\n\t/*\n\t * In order to read the offloaded state of an rdp in a safe\n\t * and stable way and prevent from its value to be changed\n\t * under us, we must either hold the barrier mutex, the cpu\n\t * hotplug lock (read or write) or the nocb lock. Local\n\t * non-preemptible reads are also safe. NOCB kthreads and\n\t * timers have their own means of synchronization against the\n\t * offloaded state updaters.\n\t */\n\tRCU_LOCKDEP_WARN(\n\t\t!(lockdep_is_held(&rcu_state.barrier_mutex) ||\n\t\t  (IS_ENABLED(CONFIG_HOTPLUG_CPU) && lockdep_is_cpus_held()) ||\n\t\t  rcu_lockdep_is_held_nocb(rdp) ||\n\t\t  (rdp == this_cpu_ptr(&rcu_data) &&\n\t\t   !(IS_ENABLED(CONFIG_PREEMPT_COUNT) && preemptible())) ||\n\t\t  rcu_current_is_nocb_kthread(rdp)),\n\t\t\"Unsafe read of RCU_NOCB offloaded state\"\n\t);\n\n\treturn rcu_segcblist_is_offloaded(&rdp->cblist);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore_rcu_node",
          "args": [
            "rnp",
            "flags"
          ],
          "line": 2310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore_rcu_node",
          "args": [
            "rnp",
            "flags"
          ],
          "line": 2304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave_rcu_node",
          "args": [
            "rnp",
            "flags"
          ],
          "line": 2293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "rdp->cpu != smp_processor_id()"
          ],
          "line": 2291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 2291
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};\nstatic void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void sync_sched_exp_online_cleanup(int cpu);\nstatic void check_cb_ovld_locked(struct rcu_data *rdp, struct rcu_node *rnp);\nstatic bool rcu_rdp_is_offloaded(struct rcu_data *rdp);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nstatic void\nrcu_report_qs_rdp(struct rcu_data *rdp)\n{\n\tunsigned long flags;\n\tunsigned long mask;\n\tbool needwake = false;\n\tbool needacc = false;\n\tstruct rcu_node *rnp;\n\n\tWARN_ON_ONCE(rdp->cpu != smp_processor_id());\n\trnp = rdp->mynode;\n\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\tif (rdp->cpu_no_qs.b.norm || rdp->gp_seq != rnp->gp_seq ||\n\t    rdp->gpwrap) {\n\n\t\t/*\n\t\t * The grace period in which this quiescent state was\n\t\t * recorded has ended, so don't report it upwards.\n\t\t * We will instead need a new quiescent state that lies\n\t\t * within the current grace period.\n\t\t */\n\t\trdp->cpu_no_qs.b.norm = true;\t/* need qs for new gp. */\n\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\treturn;\n\t}\n\tmask = rdp->grpmask;\n\trdp->core_needs_qs = false;\n\tif ((rnp->qsmask & mask) == 0) {\n\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t} else {\n\t\t/*\n\t\t * This GP can't end until cpu checks in, so all of our\n\t\t * callbacks can be processed during the next GP.\n\t\t *\n\t\t * NOCB kthreads have their own way to deal with that...\n\t\t */\n\t\tif (!rcu_rdp_is_offloaded(rdp)) {\n\t\t\tneedwake = rcu_accelerate_cbs(rnp, rdp);\n\t\t} else if (!rcu_segcblist_completely_offloaded(&rdp->cblist)) {\n\t\t\t/*\n\t\t\t * ...but NOCB kthreads may miss or delay callbacks acceleration\n\t\t\t * if in the middle of a (de-)offloading process.\n\t\t\t */\n\t\t\tneedacc = true;\n\t\t}\n\n\t\trcu_disable_urgency_upon_qs(rdp);\n\t\trcu_report_qs_rnp(mask, rnp, rnp->gp_seq, flags);\n\t\t/* ^^^ Released rnp->lock */\n\t\tif (needwake)\n\t\t\trcu_gp_kthread_wake();\n\n\t\tif (needacc) {\n\t\t\trcu_nocb_lock_irqsave(rdp, flags);\n\t\t\trcu_accelerate_cbs_unlocked(rnp, rdp);\n\t\t\trcu_nocb_unlock_irqrestore(rdp, flags);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "rcu_report_unblock_qs_rnp",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
    "lines": "2243-2276",
    "snippet": "static void __maybe_unused\nrcu_report_unblock_qs_rnp(struct rcu_node *rnp, unsigned long flags)\n\t__releases(rnp->lock)\n{\n\tunsigned long gps;\n\tunsigned long mask;\n\tstruct rcu_node *rnp_p;\n\n\traw_lockdep_assert_held_rcu_node(rnp);\n\tif (WARN_ON_ONCE(!IS_ENABLED(CONFIG_PREEMPT_RCU)) ||\n\t    WARN_ON_ONCE(rcu_preempt_blocked_readers_cgp(rnp)) ||\n\t    rnp->qsmask != 0) {\n\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\treturn;  /* Still need more quiescent states! */\n\t}\n\n\trnp->completedqs = rnp->gp_seq;\n\trnp_p = rnp->parent;\n\tif (rnp_p == NULL) {\n\t\t/*\n\t\t * Only one rcu_node structure in the tree, so don't\n\t\t * try to report up to its nonexistent parent!\n\t\t */\n\t\trcu_report_qs_rsp(flags);\n\t\treturn;\n\t}\n\n\t/* Report up the rest of the hierarchy, tracking current ->gp_seq. */\n\tgps = rnp->gp_seq;\n\tmask = rnp->grpmask;\n\traw_spin_unlock_rcu_node(rnp);\t/* irqs remain disabled. */\n\traw_spin_lock_rcu_node(rnp_p);\t/* irqs already disabled. */\n\trcu_report_qs_rnp(mask, rnp_p, gps, flags);\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_nocb.h\"",
      "#include \"tree_exp.h\"",
      "#include \"tree_stall.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <linux/kasan.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/panic_notifier.h>",
      "#include <linux/panic.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);",
      "static void check_cb_ovld_locked(struct rcu_data *rdp, struct rcu_node *rnp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_report_qs_rnp",
          "args": [
            "mask",
            "rnp_p",
            "gps",
            "flags"
          ],
          "line": 2275
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_report_qs_rnp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "2179-2234",
          "snippet": "static void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags)\n\t__releases(rnp->lock)\n{\n\tunsigned long oldmask = 0;\n\tstruct rcu_node *rnp_c;\n\n\traw_lockdep_assert_held_rcu_node(rnp);\n\n\t/* Walk up the rcu_node hierarchy. */\n\tfor (;;) {\n\t\tif ((!(rnp->qsmask & mask) && mask) || rnp->gp_seq != gps) {\n\n\t\t\t/*\n\t\t\t * Our bit has already been cleared, or the\n\t\t\t * relevant grace period is already over, so done.\n\t\t\t */\n\t\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\t\treturn;\n\t\t}\n\t\tWARN_ON_ONCE(oldmask); /* Any child must be all zeroed! */\n\t\tWARN_ON_ONCE(!rcu_is_leaf_node(rnp) &&\n\t\t\t     rcu_preempt_blocked_readers_cgp(rnp));\n\t\tWRITE_ONCE(rnp->qsmask, rnp->qsmask & ~mask);\n\t\ttrace_rcu_quiescent_state_report(rcu_state.name, rnp->gp_seq,\n\t\t\t\t\t\t mask, rnp->qsmask, rnp->level,\n\t\t\t\t\t\t rnp->grplo, rnp->grphi,\n\t\t\t\t\t\t !!rnp->gp_tasks);\n\t\tif (rnp->qsmask != 0 || rcu_preempt_blocked_readers_cgp(rnp)) {\n\n\t\t\t/* Other bits still set at this level, so done. */\n\t\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\t\treturn;\n\t\t}\n\t\trnp->completedqs = rnp->gp_seq;\n\t\tmask = rnp->grpmask;\n\t\tif (rnp->parent == NULL) {\n\n\t\t\t/* No more levels.  Exit loop holding root lock. */\n\n\t\t\tbreak;\n\t\t}\n\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\trnp_c = rnp;\n\t\trnp = rnp->parent;\n\t\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\t\toldmask = READ_ONCE(rnp_c->qsmask);\n\t}\n\n\t/*\n\t * Get here if we are the last CPU to pass through a quiescent\n\t * state for this grace period.  Invoke rcu_report_qs_rsp()\n\t * to clean up and start the next grace period if one is needed.\n\t */\n\trcu_report_qs_rsp(flags); /* releases rnp->lock. */\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};",
            "static void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);",
            "static void check_cb_ovld_locked(struct rcu_data *rdp, struct rcu_node *rnp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\nstatic void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);\nstatic void check_cb_ovld_locked(struct rcu_data *rdp, struct rcu_node *rnp);\n\nstatic void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags)\n\t__releases(rnp->lock)\n{\n\tunsigned long oldmask = 0;\n\tstruct rcu_node *rnp_c;\n\n\traw_lockdep_assert_held_rcu_node(rnp);\n\n\t/* Walk up the rcu_node hierarchy. */\n\tfor (;;) {\n\t\tif ((!(rnp->qsmask & mask) && mask) || rnp->gp_seq != gps) {\n\n\t\t\t/*\n\t\t\t * Our bit has already been cleared, or the\n\t\t\t * relevant grace period is already over, so done.\n\t\t\t */\n\t\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\t\treturn;\n\t\t}\n\t\tWARN_ON_ONCE(oldmask); /* Any child must be all zeroed! */\n\t\tWARN_ON_ONCE(!rcu_is_leaf_node(rnp) &&\n\t\t\t     rcu_preempt_blocked_readers_cgp(rnp));\n\t\tWRITE_ONCE(rnp->qsmask, rnp->qsmask & ~mask);\n\t\ttrace_rcu_quiescent_state_report(rcu_state.name, rnp->gp_seq,\n\t\t\t\t\t\t mask, rnp->qsmask, rnp->level,\n\t\t\t\t\t\t rnp->grplo, rnp->grphi,\n\t\t\t\t\t\t !!rnp->gp_tasks);\n\t\tif (rnp->qsmask != 0 || rcu_preempt_blocked_readers_cgp(rnp)) {\n\n\t\t\t/* Other bits still set at this level, so done. */\n\t\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\t\treturn;\n\t\t}\n\t\trnp->completedqs = rnp->gp_seq;\n\t\tmask = rnp->grpmask;\n\t\tif (rnp->parent == NULL) {\n\n\t\t\t/* No more levels.  Exit loop holding root lock. */\n\n\t\t\tbreak;\n\t\t}\n\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\trnp_c = rnp;\n\t\trnp = rnp->parent;\n\t\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\t\toldmask = READ_ONCE(rnp_c->qsmask);\n\t}\n\n\t/*\n\t * Get here if we are the last CPU to pass through a quiescent\n\t * state for this grace period.  Invoke rcu_report_qs_rsp()\n\t * to clean up and start the next grace period if one is needed.\n\t */\n\trcu_report_qs_rsp(flags); /* releases rnp->lock. */\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_rcu_node",
          "args": [
            "rnp_p"
          ],
          "line": 2274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_rcu_node",
          "args": [
            "rnp"
          ],
          "line": 2273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_report_qs_rsp",
          "args": [
            "flags"
          ],
          "line": 2266
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_report_qs_rsp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "2154-2163",
          "snippet": "static void rcu_report_qs_rsp(unsigned long flags)\n\t__releases(rcu_get_root()->lock)\n{\n\traw_lockdep_assert_held_rcu_node(rcu_get_root());\n\tWARN_ON_ONCE(!rcu_gp_in_progress());\n\tWRITE_ONCE(rcu_state.gp_flags,\n\t\t   READ_ONCE(rcu_state.gp_flags) | RCU_GP_FLAG_FQS);\n\traw_spin_unlock_irqrestore_rcu_node(rcu_get_root(), flags);\n\trcu_gp_kthread_wake();\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};",
            "static void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\nstatic void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);\n\nstatic void rcu_report_qs_rsp(unsigned long flags)\n\t__releases(rcu_get_root()->lock)\n{\n\traw_lockdep_assert_held_rcu_node(rcu_get_root());\n\tWARN_ON_ONCE(!rcu_gp_in_progress());\n\tWRITE_ONCE(rcu_state.gp_flags,\n\t\t   READ_ONCE(rcu_state.gp_flags) | RCU_GP_FLAG_FQS);\n\traw_spin_unlock_irqrestore_rcu_node(rcu_get_root(), flags);\n\trcu_gp_kthread_wake();\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore_rcu_node",
          "args": [
            "rnp",
            "flags"
          ],
          "line": 2255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "rcu_preempt_blocked_readers_cgp(rnp)"
          ],
          "line": 2253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_preempt_blocked_readers_cgp",
          "args": [
            "rnp"
          ],
          "line": 2253
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_preempt_blocked_readers_cgp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "907-910",
          "snippet": "static int rcu_preempt_blocked_readers_cgp(struct rcu_node *rnp)\n{\n\treturn 0;\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nstatic int rcu_preempt_blocked_readers_cgp(struct rcu_node *rnp)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!IS_ENABLED(CONFIG_PREEMPT_RCU)"
          ],
          "line": 2252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_PREEMPT_RCU"
          ],
          "line": 2252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_lockdep_assert_held_rcu_node",
          "args": [
            "rnp"
          ],
          "line": 2251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__releases",
          "args": [
            "rnp->lock"
          ],
          "line": 2245
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);\nstatic void check_cb_ovld_locked(struct rcu_data *rdp, struct rcu_node *rnp);\n\nstatic void __maybe_unused\nrcu_report_unblock_qs_rnp(struct rcu_node *rnp, unsigned long flags)\n\t__releases(rnp->lock)\n{\n\tunsigned long gps;\n\tunsigned long mask;\n\tstruct rcu_node *rnp_p;\n\n\traw_lockdep_assert_held_rcu_node(rnp);\n\tif (WARN_ON_ONCE(!IS_ENABLED(CONFIG_PREEMPT_RCU)) ||\n\t    WARN_ON_ONCE(rcu_preempt_blocked_readers_cgp(rnp)) ||\n\t    rnp->qsmask != 0) {\n\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\treturn;  /* Still need more quiescent states! */\n\t}\n\n\trnp->completedqs = rnp->gp_seq;\n\trnp_p = rnp->parent;\n\tif (rnp_p == NULL) {\n\t\t/*\n\t\t * Only one rcu_node structure in the tree, so don't\n\t\t * try to report up to its nonexistent parent!\n\t\t */\n\t\trcu_report_qs_rsp(flags);\n\t\treturn;\n\t}\n\n\t/* Report up the rest of the hierarchy, tracking current ->gp_seq. */\n\tgps = rnp->gp_seq;\n\tmask = rnp->grpmask;\n\traw_spin_unlock_rcu_node(rnp);\t/* irqs remain disabled. */\n\traw_spin_lock_rcu_node(rnp_p);\t/* irqs already disabled. */\n\trcu_report_qs_rnp(mask, rnp_p, gps, flags);\n}"
  },
  {
    "function_name": "rcu_report_qs_rnp",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
    "lines": "2179-2234",
    "snippet": "static void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags)\n\t__releases(rnp->lock)\n{\n\tunsigned long oldmask = 0;\n\tstruct rcu_node *rnp_c;\n\n\traw_lockdep_assert_held_rcu_node(rnp);\n\n\t/* Walk up the rcu_node hierarchy. */\n\tfor (;;) {\n\t\tif ((!(rnp->qsmask & mask) && mask) || rnp->gp_seq != gps) {\n\n\t\t\t/*\n\t\t\t * Our bit has already been cleared, or the\n\t\t\t * relevant grace period is already over, so done.\n\t\t\t */\n\t\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\t\treturn;\n\t\t}\n\t\tWARN_ON_ONCE(oldmask); /* Any child must be all zeroed! */\n\t\tWARN_ON_ONCE(!rcu_is_leaf_node(rnp) &&\n\t\t\t     rcu_preempt_blocked_readers_cgp(rnp));\n\t\tWRITE_ONCE(rnp->qsmask, rnp->qsmask & ~mask);\n\t\ttrace_rcu_quiescent_state_report(rcu_state.name, rnp->gp_seq,\n\t\t\t\t\t\t mask, rnp->qsmask, rnp->level,\n\t\t\t\t\t\t rnp->grplo, rnp->grphi,\n\t\t\t\t\t\t !!rnp->gp_tasks);\n\t\tif (rnp->qsmask != 0 || rcu_preempt_blocked_readers_cgp(rnp)) {\n\n\t\t\t/* Other bits still set at this level, so done. */\n\t\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\t\treturn;\n\t\t}\n\t\trnp->completedqs = rnp->gp_seq;\n\t\tmask = rnp->grpmask;\n\t\tif (rnp->parent == NULL) {\n\n\t\t\t/* No more levels.  Exit loop holding root lock. */\n\n\t\t\tbreak;\n\t\t}\n\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\trnp_c = rnp;\n\t\trnp = rnp->parent;\n\t\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\t\toldmask = READ_ONCE(rnp_c->qsmask);\n\t}\n\n\t/*\n\t * Get here if we are the last CPU to pass through a quiescent\n\t * state for this grace period.  Invoke rcu_report_qs_rsp()\n\t * to clean up and start the next grace period if one is needed.\n\t */\n\trcu_report_qs_rsp(flags); /* releases rnp->lock. */\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_nocb.h\"",
      "#include \"tree_exp.h\"",
      "#include \"tree_stall.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <linux/kasan.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/panic_notifier.h>",
      "#include <linux/panic.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};",
      "static void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);",
      "static void check_cb_ovld_locked(struct rcu_data *rdp, struct rcu_node *rnp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_report_qs_rsp",
          "args": [
            "flags"
          ],
          "line": 2233
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_report_qs_rsp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "2154-2163",
          "snippet": "static void rcu_report_qs_rsp(unsigned long flags)\n\t__releases(rcu_get_root()->lock)\n{\n\traw_lockdep_assert_held_rcu_node(rcu_get_root());\n\tWARN_ON_ONCE(!rcu_gp_in_progress());\n\tWRITE_ONCE(rcu_state.gp_flags,\n\t\t   READ_ONCE(rcu_state.gp_flags) | RCU_GP_FLAG_FQS);\n\traw_spin_unlock_irqrestore_rcu_node(rcu_get_root(), flags);\n\trcu_gp_kthread_wake();\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};",
            "static void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\nstatic void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);\n\nstatic void rcu_report_qs_rsp(unsigned long flags)\n\t__releases(rcu_get_root()->lock)\n{\n\traw_lockdep_assert_held_rcu_node(rcu_get_root());\n\tWARN_ON_ONCE(!rcu_gp_in_progress());\n\tWRITE_ONCE(rcu_state.gp_flags,\n\t\t   READ_ONCE(rcu_state.gp_flags) | RCU_GP_FLAG_FQS);\n\traw_spin_unlock_irqrestore_rcu_node(rcu_get_root(), flags);\n\trcu_gp_kthread_wake();\n}"
        }
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rnp_c->qsmask"
          ],
          "line": 2225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave_rcu_node",
          "args": [
            "rnp",
            "flags"
          ],
          "line": 2224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore_rcu_node",
          "args": [
            "rnp",
            "flags"
          ],
          "line": 2221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore_rcu_node",
          "args": [
            "rnp",
            "flags"
          ],
          "line": 2210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_preempt_blocked_readers_cgp",
          "args": [
            "rnp"
          ],
          "line": 2207
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_preempt_blocked_readers_cgp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "907-910",
          "snippet": "static int rcu_preempt_blocked_readers_cgp(struct rcu_node *rnp)\n{\n\treturn 0;\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nstatic int rcu_preempt_blocked_readers_cgp(struct rcu_node *rnp)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_rcu_quiescent_state_report",
          "args": [
            "rcu_state.name",
            "rnp->gp_seq",
            "mask",
            "rnp->qsmask",
            "rnp->level",
            "rnp->grplo",
            "rnp->grphi",
            "!!rnp->gp_tasks"
          ],
          "line": 2203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "rnp->qsmask",
            "rnp->qsmask & ~mask"
          ],
          "line": 2202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!rcu_is_leaf_node(rnp) &&\n\t\t\t     rcu_preempt_blocked_readers_cgp(rnp)"
          ],
          "line": 2200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_is_leaf_node",
          "args": [
            "rnp"
          ],
          "line": 2200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "oldmask"
          ],
          "line": 2199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore_rcu_node",
          "args": [
            "rnp",
            "flags"
          ],
          "line": 2196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_lockdep_assert_held_rcu_node",
          "args": [
            "rnp"
          ],
          "line": 2186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__releases",
          "args": [
            "rnp->lock"
          ],
          "line": 2181
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\nstatic void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);\nstatic void check_cb_ovld_locked(struct rcu_data *rdp, struct rcu_node *rnp);\n\nstatic void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags)\n\t__releases(rnp->lock)\n{\n\tunsigned long oldmask = 0;\n\tstruct rcu_node *rnp_c;\n\n\traw_lockdep_assert_held_rcu_node(rnp);\n\n\t/* Walk up the rcu_node hierarchy. */\n\tfor (;;) {\n\t\tif ((!(rnp->qsmask & mask) && mask) || rnp->gp_seq != gps) {\n\n\t\t\t/*\n\t\t\t * Our bit has already been cleared, or the\n\t\t\t * relevant grace period is already over, so done.\n\t\t\t */\n\t\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\t\treturn;\n\t\t}\n\t\tWARN_ON_ONCE(oldmask); /* Any child must be all zeroed! */\n\t\tWARN_ON_ONCE(!rcu_is_leaf_node(rnp) &&\n\t\t\t     rcu_preempt_blocked_readers_cgp(rnp));\n\t\tWRITE_ONCE(rnp->qsmask, rnp->qsmask & ~mask);\n\t\ttrace_rcu_quiescent_state_report(rcu_state.name, rnp->gp_seq,\n\t\t\t\t\t\t mask, rnp->qsmask, rnp->level,\n\t\t\t\t\t\t rnp->grplo, rnp->grphi,\n\t\t\t\t\t\t !!rnp->gp_tasks);\n\t\tif (rnp->qsmask != 0 || rcu_preempt_blocked_readers_cgp(rnp)) {\n\n\t\t\t/* Other bits still set at this level, so done. */\n\t\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\t\treturn;\n\t\t}\n\t\trnp->completedqs = rnp->gp_seq;\n\t\tmask = rnp->grpmask;\n\t\tif (rnp->parent == NULL) {\n\n\t\t\t/* No more levels.  Exit loop holding root lock. */\n\n\t\t\tbreak;\n\t\t}\n\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\trnp_c = rnp;\n\t\trnp = rnp->parent;\n\t\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\t\toldmask = READ_ONCE(rnp_c->qsmask);\n\t}\n\n\t/*\n\t * Get here if we are the last CPU to pass through a quiescent\n\t * state for this grace period.  Invoke rcu_report_qs_rsp()\n\t * to clean up and start the next grace period if one is needed.\n\t */\n\trcu_report_qs_rsp(flags); /* releases rnp->lock. */\n}"
  },
  {
    "function_name": "rcu_report_qs_rsp",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
    "lines": "2154-2163",
    "snippet": "static void rcu_report_qs_rsp(unsigned long flags)\n\t__releases(rcu_get_root()->lock)\n{\n\traw_lockdep_assert_held_rcu_node(rcu_get_root());\n\tWARN_ON_ONCE(!rcu_gp_in_progress());\n\tWRITE_ONCE(rcu_state.gp_flags,\n\t\t   READ_ONCE(rcu_state.gp_flags) | RCU_GP_FLAG_FQS);\n\traw_spin_unlock_irqrestore_rcu_node(rcu_get_root(), flags);\n\trcu_gp_kthread_wake();\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_nocb.h\"",
      "#include \"tree_exp.h\"",
      "#include \"tree_stall.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <linux/kasan.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/panic_notifier.h>",
      "#include <linux/panic.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};",
      "static void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_gp_kthread_wake",
          "args": [],
          "line": 2162
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_gp_kthread_wake",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "1473-1483",
          "snippet": "static void rcu_gp_kthread_wake(void)\n{\n\tstruct task_struct *t = READ_ONCE(rcu_state.gp_kthread);\n\n\tif ((current == t && !in_hardirq() && !in_serving_softirq()) ||\n\t    !READ_ONCE(rcu_state.gp_flags) || !t)\n\t\treturn;\n\tWRITE_ONCE(rcu_state.gp_wake_time, jiffies);\n\tWRITE_ONCE(rcu_state.gp_wake_seq, READ_ONCE(rcu_state.gp_seq));\n\tswake_up_one(&rcu_state.gp_wq);\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\n\nstatic void rcu_gp_kthread_wake(void)\n{\n\tstruct task_struct *t = READ_ONCE(rcu_state.gp_kthread);\n\n\tif ((current == t && !in_hardirq() && !in_serving_softirq()) ||\n\t    !READ_ONCE(rcu_state.gp_flags) || !t)\n\t\treturn;\n\tWRITE_ONCE(rcu_state.gp_wake_time, jiffies);\n\tWRITE_ONCE(rcu_state.gp_wake_seq, READ_ONCE(rcu_state.gp_seq));\n\tswake_up_one(&rcu_state.gp_wq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore_rcu_node",
          "args": [
            "rcu_get_root()",
            "flags"
          ],
          "line": 2161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_get_root",
          "args": [],
          "line": 2161
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_get_root",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "579-582",
          "snippet": "static struct rcu_node *rcu_get_root(void)\n{\n\treturn &rcu_state.node[0];\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\n\nstatic struct rcu_node *rcu_get_root(void)\n{\n\treturn &rcu_state.node[0];\n}"
        }
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "rcu_state.gp_flags",
            "READ_ONCE(rcu_state.gp_flags) | RCU_GP_FLAG_FQS"
          ],
          "line": 2159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rcu_state.gp_flags"
          ],
          "line": 2160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!rcu_gp_in_progress()"
          ],
          "line": 2158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_gp_in_progress",
          "args": [],
          "line": 2158
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_gp_in_progress",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "229-232",
          "snippet": "static int rcu_gp_in_progress(void)\n{\n\treturn rcu_seq_state(rcu_seq_current(&rcu_state.gp_seq));\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\n\nstatic int rcu_gp_in_progress(void)\n{\n\treturn rcu_seq_state(rcu_seq_current(&rcu_state.gp_seq));\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_lockdep_assert_held_rcu_node",
          "args": [
            "rcu_get_root()"
          ],
          "line": 2157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__releases",
          "args": [
            "rcu_get_root()->lock"
          ],
          "line": 2155
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\nstatic void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);\n\nstatic void rcu_report_qs_rsp(unsigned long flags)\n\t__releases(rcu_get_root()->lock)\n{\n\traw_lockdep_assert_held_rcu_node(rcu_get_root());\n\tWARN_ON_ONCE(!rcu_gp_in_progress());\n\tWRITE_ONCE(rcu_state.gp_flags,\n\t\t   READ_ONCE(rcu_state.gp_flags) | RCU_GP_FLAG_FQS);\n\traw_spin_unlock_irqrestore_rcu_node(rcu_get_root(), flags);\n\trcu_gp_kthread_wake();\n}"
  },
  {
    "function_name": "rcu_gp_kthread",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
    "lines": "2110-2143",
    "snippet": "static int __noreturn rcu_gp_kthread(void *unused)\n{\n\trcu_bind_gp_kthread();\n\tfor (;;) {\n\n\t\t/* Handle grace-period start. */\n\t\tfor (;;) {\n\t\t\ttrace_rcu_grace_period(rcu_state.name, rcu_state.gp_seq,\n\t\t\t\t\t       TPS(\"reqwait\"));\n\t\t\tWRITE_ONCE(rcu_state.gp_state, RCU_GP_WAIT_GPS);\n\t\t\tswait_event_idle_exclusive(rcu_state.gp_wq,\n\t\t\t\t\t READ_ONCE(rcu_state.gp_flags) &\n\t\t\t\t\t RCU_GP_FLAG_INIT);\n\t\t\trcu_gp_torture_wait();\n\t\t\tWRITE_ONCE(rcu_state.gp_state, RCU_GP_DONE_GPS);\n\t\t\t/* Locking provides needed memory barrier. */\n\t\t\tif (rcu_gp_init())\n\t\t\t\tbreak;\n\t\t\tcond_resched_tasks_rcu_qs();\n\t\t\tWRITE_ONCE(rcu_state.gp_activity, jiffies);\n\t\t\tWARN_ON(signal_pending(current));\n\t\t\ttrace_rcu_grace_period(rcu_state.name, rcu_state.gp_seq,\n\t\t\t\t\t       TPS(\"reqwaitsig\"));\n\t\t}\n\n\t\t/* Handle quiescent-state forcing. */\n\t\trcu_gp_fqs_loop();\n\n\t\t/* Handle grace-period end. */\n\t\tWRITE_ONCE(rcu_state.gp_state, RCU_GP_CLEANUP);\n\t\trcu_gp_cleanup();\n\t\tWRITE_ONCE(rcu_state.gp_state, RCU_GP_CLEANED);\n\t}\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_nocb.h\"",
      "#include \"tree_exp.h\"",
      "#include \"tree_stall.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <linux/kasan.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/panic_notifier.h>",
      "#include <linux/panic.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "rcu_state.gp_state",
            "RCU_GP_CLEANED"
          ],
          "line": 2141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_gp_cleanup",
          "args": [],
          "line": 2140
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_gp_cleanup",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "2010-2105",
          "snippet": "static noinline void rcu_gp_cleanup(void)\n{\n\tint cpu;\n\tbool needgp = false;\n\tunsigned long gp_duration;\n\tunsigned long new_gp_seq;\n\tbool offloaded;\n\tstruct rcu_data *rdp;\n\tstruct rcu_node *rnp = rcu_get_root();\n\tstruct swait_queue_head *sq;\n\n\tWRITE_ONCE(rcu_state.gp_activity, jiffies);\n\traw_spin_lock_irq_rcu_node(rnp);\n\trcu_state.gp_end = jiffies;\n\tgp_duration = rcu_state.gp_end - rcu_state.gp_start;\n\tif (gp_duration > rcu_state.gp_max)\n\t\trcu_state.gp_max = gp_duration;\n\n\t/*\n\t * We know the grace period is complete, but to everyone else\n\t * it appears to still be ongoing.  But it is also the case\n\t * that to everyone else it looks like there is nothing that\n\t * they can do to advance the grace period.  It is therefore\n\t * safe for us to drop the lock in order to mark the grace\n\t * period as completed in all of the rcu_node structures.\n\t */\n\traw_spin_unlock_irq_rcu_node(rnp);\n\n\t/*\n\t * Propagate new ->gp_seq value to rcu_node structures so that\n\t * other CPUs don't have to wait until the start of the next grace\n\t * period to process their callbacks.  This also avoids some nasty\n\t * RCU grace-period initialization races by forcing the end of\n\t * the current grace period to be completely recorded in all of\n\t * the rcu_node structures before the beginning of the next grace\n\t * period is recorded in any of the rcu_node structures.\n\t */\n\tnew_gp_seq = rcu_state.gp_seq;\n\trcu_seq_end(&new_gp_seq);\n\trcu_for_each_node_breadth_first(rnp) {\n\t\traw_spin_lock_irq_rcu_node(rnp);\n\t\tif (WARN_ON_ONCE(rcu_preempt_blocked_readers_cgp(rnp)))\n\t\t\tdump_blkd_tasks(rnp, 10);\n\t\tWARN_ON_ONCE(rnp->qsmask);\n\t\tWRITE_ONCE(rnp->gp_seq, new_gp_seq);\n\t\trdp = this_cpu_ptr(&rcu_data);\n\t\tif (rnp == rdp->mynode)\n\t\t\tneedgp = __note_gp_changes(rnp, rdp) || needgp;\n\t\t/* smp_mb() provided by prior unlock-lock pair. */\n\t\tneedgp = rcu_future_gp_cleanup(rnp) || needgp;\n\t\t// Reset overload indication for CPUs no longer overloaded\n\t\tif (rcu_is_leaf_node(rnp))\n\t\t\tfor_each_leaf_node_cpu_mask(rnp, cpu, rnp->cbovldmask) {\n\t\t\t\trdp = per_cpu_ptr(&rcu_data, cpu);\n\t\t\t\tcheck_cb_ovld_locked(rdp, rnp);\n\t\t\t}\n\t\tsq = rcu_nocb_gp_get(rnp);\n\t\traw_spin_unlock_irq_rcu_node(rnp);\n\t\trcu_nocb_gp_cleanup(sq);\n\t\tcond_resched_tasks_rcu_qs();\n\t\tWRITE_ONCE(rcu_state.gp_activity, jiffies);\n\t\trcu_gp_slow(gp_cleanup_delay);\n\t}\n\trnp = rcu_get_root();\n\traw_spin_lock_irq_rcu_node(rnp); /* GP before ->gp_seq update. */\n\n\t/* Declare grace period done, trace first to use old GP number. */\n\ttrace_rcu_grace_period(rcu_state.name, rcu_state.gp_seq, TPS(\"end\"));\n\trcu_seq_end(&rcu_state.gp_seq);\n\tASSERT_EXCLUSIVE_WRITER(rcu_state.gp_seq);\n\tWRITE_ONCE(rcu_state.gp_state, RCU_GP_IDLE);\n\t/* Check for GP requests since above loop. */\n\trdp = this_cpu_ptr(&rcu_data);\n\tif (!needgp && ULONG_CMP_LT(rnp->gp_seq, rnp->gp_seq_needed)) {\n\t\ttrace_rcu_this_gp(rnp, rdp, rnp->gp_seq_needed,\n\t\t\t\t  TPS(\"CleanupMore\"));\n\t\tneedgp = true;\n\t}\n\t/* Advance CBs to reduce false positives below. */\n\toffloaded = rcu_rdp_is_offloaded(rdp);\n\tif ((offloaded || !rcu_accelerate_cbs(rnp, rdp)) && needgp) {\n\t\tWRITE_ONCE(rcu_state.gp_flags, RCU_GP_FLAG_INIT);\n\t\tWRITE_ONCE(rcu_state.gp_req_activity, jiffies);\n\t\ttrace_rcu_grace_period(rcu_state.name,\n\t\t\t\t       rcu_state.gp_seq,\n\t\t\t\t       TPS(\"newreq\"));\n\t} else {\n\t\tWRITE_ONCE(rcu_state.gp_flags,\n\t\t\t   rcu_state.gp_flags & RCU_GP_FLAG_INIT);\n\t}\n\traw_spin_unlock_irq_rcu_node(rnp);\n\n\t// If strict, make all CPUs aware of the end of the old grace period.\n\tif (IS_ENABLED(CONFIG_RCU_STRICT_GRACE_PERIOD))\n\t\ton_each_cpu(rcu_strict_gp_boundary, NULL, 0);\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};",
            "static struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};",
            "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
            "static void sync_sched_exp_online_cleanup(int cpu);",
            "static void check_cb_ovld_locked(struct rcu_data *rdp, struct rcu_node *rnp);",
            "static bool rcu_rdp_is_offloaded(struct rcu_data *rdp);",
            "static int gp_cleanup_delay;",
            "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};\nstatic struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void sync_sched_exp_online_cleanup(int cpu);\nstatic void check_cb_ovld_locked(struct rcu_data *rdp, struct rcu_node *rnp);\nstatic bool rcu_rdp_is_offloaded(struct rcu_data *rdp);\nstatic int gp_cleanup_delay;\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nstatic noinline void rcu_gp_cleanup(void)\n{\n\tint cpu;\n\tbool needgp = false;\n\tunsigned long gp_duration;\n\tunsigned long new_gp_seq;\n\tbool offloaded;\n\tstruct rcu_data *rdp;\n\tstruct rcu_node *rnp = rcu_get_root();\n\tstruct swait_queue_head *sq;\n\n\tWRITE_ONCE(rcu_state.gp_activity, jiffies);\n\traw_spin_lock_irq_rcu_node(rnp);\n\trcu_state.gp_end = jiffies;\n\tgp_duration = rcu_state.gp_end - rcu_state.gp_start;\n\tif (gp_duration > rcu_state.gp_max)\n\t\trcu_state.gp_max = gp_duration;\n\n\t/*\n\t * We know the grace period is complete, but to everyone else\n\t * it appears to still be ongoing.  But it is also the case\n\t * that to everyone else it looks like there is nothing that\n\t * they can do to advance the grace period.  It is therefore\n\t * safe for us to drop the lock in order to mark the grace\n\t * period as completed in all of the rcu_node structures.\n\t */\n\traw_spin_unlock_irq_rcu_node(rnp);\n\n\t/*\n\t * Propagate new ->gp_seq value to rcu_node structures so that\n\t * other CPUs don't have to wait until the start of the next grace\n\t * period to process their callbacks.  This also avoids some nasty\n\t * RCU grace-period initialization races by forcing the end of\n\t * the current grace period to be completely recorded in all of\n\t * the rcu_node structures before the beginning of the next grace\n\t * period is recorded in any of the rcu_node structures.\n\t */\n\tnew_gp_seq = rcu_state.gp_seq;\n\trcu_seq_end(&new_gp_seq);\n\trcu_for_each_node_breadth_first(rnp) {\n\t\traw_spin_lock_irq_rcu_node(rnp);\n\t\tif (WARN_ON_ONCE(rcu_preempt_blocked_readers_cgp(rnp)))\n\t\t\tdump_blkd_tasks(rnp, 10);\n\t\tWARN_ON_ONCE(rnp->qsmask);\n\t\tWRITE_ONCE(rnp->gp_seq, new_gp_seq);\n\t\trdp = this_cpu_ptr(&rcu_data);\n\t\tif (rnp == rdp->mynode)\n\t\t\tneedgp = __note_gp_changes(rnp, rdp) || needgp;\n\t\t/* smp_mb() provided by prior unlock-lock pair. */\n\t\tneedgp = rcu_future_gp_cleanup(rnp) || needgp;\n\t\t// Reset overload indication for CPUs no longer overloaded\n\t\tif (rcu_is_leaf_node(rnp))\n\t\t\tfor_each_leaf_node_cpu_mask(rnp, cpu, rnp->cbovldmask) {\n\t\t\t\trdp = per_cpu_ptr(&rcu_data, cpu);\n\t\t\t\tcheck_cb_ovld_locked(rdp, rnp);\n\t\t\t}\n\t\tsq = rcu_nocb_gp_get(rnp);\n\t\traw_spin_unlock_irq_rcu_node(rnp);\n\t\trcu_nocb_gp_cleanup(sq);\n\t\tcond_resched_tasks_rcu_qs();\n\t\tWRITE_ONCE(rcu_state.gp_activity, jiffies);\n\t\trcu_gp_slow(gp_cleanup_delay);\n\t}\n\trnp = rcu_get_root();\n\traw_spin_lock_irq_rcu_node(rnp); /* GP before ->gp_seq update. */\n\n\t/* Declare grace period done, trace first to use old GP number. */\n\ttrace_rcu_grace_period(rcu_state.name, rcu_state.gp_seq, TPS(\"end\"));\n\trcu_seq_end(&rcu_state.gp_seq);\n\tASSERT_EXCLUSIVE_WRITER(rcu_state.gp_seq);\n\tWRITE_ONCE(rcu_state.gp_state, RCU_GP_IDLE);\n\t/* Check for GP requests since above loop. */\n\trdp = this_cpu_ptr(&rcu_data);\n\tif (!needgp && ULONG_CMP_LT(rnp->gp_seq, rnp->gp_seq_needed)) {\n\t\ttrace_rcu_this_gp(rnp, rdp, rnp->gp_seq_needed,\n\t\t\t\t  TPS(\"CleanupMore\"));\n\t\tneedgp = true;\n\t}\n\t/* Advance CBs to reduce false positives below. */\n\toffloaded = rcu_rdp_is_offloaded(rdp);\n\tif ((offloaded || !rcu_accelerate_cbs(rnp, rdp)) && needgp) {\n\t\tWRITE_ONCE(rcu_state.gp_flags, RCU_GP_FLAG_INIT);\n\t\tWRITE_ONCE(rcu_state.gp_req_activity, jiffies);\n\t\ttrace_rcu_grace_period(rcu_state.name,\n\t\t\t\t       rcu_state.gp_seq,\n\t\t\t\t       TPS(\"newreq\"));\n\t} else {\n\t\tWRITE_ONCE(rcu_state.gp_flags,\n\t\t\t   rcu_state.gp_flags & RCU_GP_FLAG_INIT);\n\t}\n\traw_spin_unlock_irq_rcu_node(rnp);\n\n\t// If strict, make all CPUs aware of the end of the old grace period.\n\tif (IS_ENABLED(CONFIG_RCU_STRICT_GRACE_PERIOD))\n\t\ton_each_cpu(rcu_strict_gp_boundary, NULL, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "rcu_state.gp_state",
            "RCU_GP_CLEANUP"
          ],
          "line": 2139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_gp_fqs_loop",
          "args": [],
          "line": 2136
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_gp_fqs_loop",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "1936-2005",
          "snippet": "static noinline_for_stack void rcu_gp_fqs_loop(void)\n{\n\tbool first_gp_fqs;\n\tint gf = 0;\n\tunsigned long j;\n\tint ret;\n\tstruct rcu_node *rnp = rcu_get_root();\n\n\tfirst_gp_fqs = true;\n\tj = READ_ONCE(jiffies_till_first_fqs);\n\tif (rcu_state.cbovld)\n\t\tgf = RCU_GP_FLAG_OVLD;\n\tret = 0;\n\tfor (;;) {\n\t\tif (!ret) {\n\t\t\tWRITE_ONCE(rcu_state.jiffies_force_qs, jiffies + j);\n\t\t\t/*\n\t\t\t * jiffies_force_qs before RCU_GP_WAIT_FQS state\n\t\t\t * update; required for stall checks.\n\t\t\t */\n\t\t\tsmp_wmb();\n\t\t\tWRITE_ONCE(rcu_state.jiffies_kick_kthreads,\n\t\t\t\t   jiffies + (j ? 3 * j : 2));\n\t\t}\n\t\ttrace_rcu_grace_period(rcu_state.name, rcu_state.gp_seq,\n\t\t\t\t       TPS(\"fqswait\"));\n\t\tWRITE_ONCE(rcu_state.gp_state, RCU_GP_WAIT_FQS);\n\t\t(void)swait_event_idle_timeout_exclusive(rcu_state.gp_wq,\n\t\t\t\t rcu_gp_fqs_check_wake(&gf), j);\n\t\trcu_gp_torture_wait();\n\t\tWRITE_ONCE(rcu_state.gp_state, RCU_GP_DOING_FQS);\n\t\t/* Locking provides needed memory barriers. */\n\t\t/* If grace period done, leave loop. */\n\t\tif (!READ_ONCE(rnp->qsmask) &&\n\t\t    !rcu_preempt_blocked_readers_cgp(rnp))\n\t\t\tbreak;\n\t\t/* If time for quiescent-state forcing, do it. */\n\t\tif (!time_after(rcu_state.jiffies_force_qs, jiffies) ||\n\t\t    (gf & (RCU_GP_FLAG_FQS | RCU_GP_FLAG_OVLD))) {\n\t\t\ttrace_rcu_grace_period(rcu_state.name, rcu_state.gp_seq,\n\t\t\t\t\t       TPS(\"fqsstart\"));\n\t\t\trcu_gp_fqs(first_gp_fqs);\n\t\t\tgf = 0;\n\t\t\tif (first_gp_fqs) {\n\t\t\t\tfirst_gp_fqs = false;\n\t\t\t\tgf = rcu_state.cbovld ? RCU_GP_FLAG_OVLD : 0;\n\t\t\t}\n\t\t\ttrace_rcu_grace_period(rcu_state.name, rcu_state.gp_seq,\n\t\t\t\t\t       TPS(\"fqsend\"));\n\t\t\tcond_resched_tasks_rcu_qs();\n\t\t\tWRITE_ONCE(rcu_state.gp_activity, jiffies);\n\t\t\tret = 0; /* Force full wait till next FQS. */\n\t\t\tj = READ_ONCE(jiffies_till_next_fqs);\n\t\t} else {\n\t\t\t/* Deal with stray signal. */\n\t\t\tcond_resched_tasks_rcu_qs();\n\t\t\tWRITE_ONCE(rcu_state.gp_activity, jiffies);\n\t\t\tWARN_ON(signal_pending(current));\n\t\t\ttrace_rcu_grace_period(rcu_state.name, rcu_state.gp_seq,\n\t\t\t\t\t       TPS(\"fqswaitsig\"));\n\t\t\tret = 1; /* Keep old FQS timing. */\n\t\t\tj = jiffies;\n\t\t\tif (time_after(jiffies, rcu_state.jiffies_force_qs))\n\t\t\t\tj = 1;\n\t\t\telse\n\t\t\t\tj = rcu_state.jiffies_force_qs - j;\n\t\t\tgf = 0;\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};",
            "static void check_cb_ovld_locked(struct rcu_data *rdp, struct rcu_node *rnp);",
            "static ulong jiffies_till_first_fqs = IS_ENABLED(CONFIG_RCU_STRICT_GRACE_PERIOD) ? 0 : ULONG_MAX;",
            "static ulong jiffies_till_next_fqs = ULONG_MAX;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\nstatic void check_cb_ovld_locked(struct rcu_data *rdp, struct rcu_node *rnp);\nstatic ulong jiffies_till_first_fqs = IS_ENABLED(CONFIG_RCU_STRICT_GRACE_PERIOD) ? 0 : ULONG_MAX;\nstatic ulong jiffies_till_next_fqs = ULONG_MAX;\n\nstatic noinline_for_stack void rcu_gp_fqs_loop(void)\n{\n\tbool first_gp_fqs;\n\tint gf = 0;\n\tunsigned long j;\n\tint ret;\n\tstruct rcu_node *rnp = rcu_get_root();\n\n\tfirst_gp_fqs = true;\n\tj = READ_ONCE(jiffies_till_first_fqs);\n\tif (rcu_state.cbovld)\n\t\tgf = RCU_GP_FLAG_OVLD;\n\tret = 0;\n\tfor (;;) {\n\t\tif (!ret) {\n\t\t\tWRITE_ONCE(rcu_state.jiffies_force_qs, jiffies + j);\n\t\t\t/*\n\t\t\t * jiffies_force_qs before RCU_GP_WAIT_FQS state\n\t\t\t * update; required for stall checks.\n\t\t\t */\n\t\t\tsmp_wmb();\n\t\t\tWRITE_ONCE(rcu_state.jiffies_kick_kthreads,\n\t\t\t\t   jiffies + (j ? 3 * j : 2));\n\t\t}\n\t\ttrace_rcu_grace_period(rcu_state.name, rcu_state.gp_seq,\n\t\t\t\t       TPS(\"fqswait\"));\n\t\tWRITE_ONCE(rcu_state.gp_state, RCU_GP_WAIT_FQS);\n\t\t(void)swait_event_idle_timeout_exclusive(rcu_state.gp_wq,\n\t\t\t\t rcu_gp_fqs_check_wake(&gf), j);\n\t\trcu_gp_torture_wait();\n\t\tWRITE_ONCE(rcu_state.gp_state, RCU_GP_DOING_FQS);\n\t\t/* Locking provides needed memory barriers. */\n\t\t/* If grace period done, leave loop. */\n\t\tif (!READ_ONCE(rnp->qsmask) &&\n\t\t    !rcu_preempt_blocked_readers_cgp(rnp))\n\t\t\tbreak;\n\t\t/* If time for quiescent-state forcing, do it. */\n\t\tif (!time_after(rcu_state.jiffies_force_qs, jiffies) ||\n\t\t    (gf & (RCU_GP_FLAG_FQS | RCU_GP_FLAG_OVLD))) {\n\t\t\ttrace_rcu_grace_period(rcu_state.name, rcu_state.gp_seq,\n\t\t\t\t\t       TPS(\"fqsstart\"));\n\t\t\trcu_gp_fqs(first_gp_fqs);\n\t\t\tgf = 0;\n\t\t\tif (first_gp_fqs) {\n\t\t\t\tfirst_gp_fqs = false;\n\t\t\t\tgf = rcu_state.cbovld ? RCU_GP_FLAG_OVLD : 0;\n\t\t\t}\n\t\t\ttrace_rcu_grace_period(rcu_state.name, rcu_state.gp_seq,\n\t\t\t\t\t       TPS(\"fqsend\"));\n\t\t\tcond_resched_tasks_rcu_qs();\n\t\t\tWRITE_ONCE(rcu_state.gp_activity, jiffies);\n\t\t\tret = 0; /* Force full wait till next FQS. */\n\t\t\tj = READ_ONCE(jiffies_till_next_fqs);\n\t\t} else {\n\t\t\t/* Deal with stray signal. */\n\t\t\tcond_resched_tasks_rcu_qs();\n\t\t\tWRITE_ONCE(rcu_state.gp_activity, jiffies);\n\t\t\tWARN_ON(signal_pending(current));\n\t\t\ttrace_rcu_grace_period(rcu_state.name, rcu_state.gp_seq,\n\t\t\t\t\t       TPS(\"fqswaitsig\"));\n\t\t\tret = 1; /* Keep old FQS timing. */\n\t\t\tj = jiffies;\n\t\t\tif (time_after(jiffies, rcu_state.jiffies_force_qs))\n\t\t\t\tj = 1;\n\t\t\telse\n\t\t\t\tj = rcu_state.jiffies_force_qs - j;\n\t\t\tgf = 0;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_rcu_grace_period",
          "args": [
            "rcu_state.name",
            "rcu_state.gp_seq",
            "TPS(\"reqwaitsig\")"
          ],
          "line": 2131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPS",
          "args": [
            "\"reqwaitsig\""
          ],
          "line": 2132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "signal_pending(current)"
          ],
          "line": 2130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "signal_pending",
          "args": [
            "current"
          ],
          "line": 2130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "rcu_state.gp_activity",
            "jiffies"
          ],
          "line": 2129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cond_resched_tasks_rcu_qs",
          "args": [],
          "line": 2128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_gp_init",
          "args": [],
          "line": 2126
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_gp_init",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "1740-1882",
          "snippet": "static noinline_for_stack bool rcu_gp_init(void)\n{\n\tunsigned long firstseq;\n\tunsigned long flags;\n\tunsigned long oldmask;\n\tunsigned long mask;\n\tstruct rcu_data *rdp;\n\tstruct rcu_node *rnp = rcu_get_root();\n\n\tWRITE_ONCE(rcu_state.gp_activity, jiffies);\n\traw_spin_lock_irq_rcu_node(rnp);\n\tif (!READ_ONCE(rcu_state.gp_flags)) {\n\t\t/* Spurious wakeup, tell caller to go back to sleep.  */\n\t\traw_spin_unlock_irq_rcu_node(rnp);\n\t\treturn false;\n\t}\n\tWRITE_ONCE(rcu_state.gp_flags, 0); /* Clear all flags: New GP. */\n\n\tif (WARN_ON_ONCE(rcu_gp_in_progress())) {\n\t\t/*\n\t\t * Grace period already in progress, don't start another.\n\t\t * Not supposed to be able to happen.\n\t\t */\n\t\traw_spin_unlock_irq_rcu_node(rnp);\n\t\treturn false;\n\t}\n\n\t/* Advance to a new grace period and initialize state. */\n\trecord_gp_stall_check_time();\n\t/* Record GP times before starting GP, hence rcu_seq_start(). */\n\trcu_seq_start(&rcu_state.gp_seq);\n\tASSERT_EXCLUSIVE_WRITER(rcu_state.gp_seq);\n\ttrace_rcu_grace_period(rcu_state.name, rcu_state.gp_seq, TPS(\"start\"));\n\traw_spin_unlock_irq_rcu_node(rnp);\n\n\t/*\n\t * Apply per-leaf buffered online and offline operations to\n\t * the rcu_node tree. Note that this new grace period need not\n\t * wait for subsequent online CPUs, and that RCU hooks in the CPU\n\t * offlining path, when combined with checks in this function,\n\t * will handle CPUs that are currently going offline or that will\n\t * go offline later.  Please also refer to \"Hotplug CPU\" section\n\t * of RCU's Requirements documentation.\n\t */\n\tWRITE_ONCE(rcu_state.gp_state, RCU_GP_ONOFF);\n\trcu_for_each_leaf_node(rnp) {\n\t\t// Wait for CPU-hotplug operations that might have\n\t\t// started before this grace period did.\n\t\tsmp_mb(); // Pair with barriers used when updating ->ofl_seq to odd values.\n\t\tfirstseq = READ_ONCE(rnp->ofl_seq);\n\t\tif (firstseq & 0x1)\n\t\t\twhile (firstseq == READ_ONCE(rnp->ofl_seq))\n\t\t\t\tschedule_timeout_idle(1);  // Can't wake unless RCU is watching.\n\t\tsmp_mb(); // Pair with barriers used when updating ->ofl_seq to even values.\n\t\traw_spin_lock(&rcu_state.ofl_lock);\n\t\traw_spin_lock_irq_rcu_node(rnp);\n\t\tif (rnp->qsmaskinit == rnp->qsmaskinitnext &&\n\t\t    !rnp->wait_blkd_tasks) {\n\t\t\t/* Nothing to do on this leaf rcu_node structure. */\n\t\t\traw_spin_unlock_irq_rcu_node(rnp);\n\t\t\traw_spin_unlock(&rcu_state.ofl_lock);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Record old state, apply changes to ->qsmaskinit field. */\n\t\toldmask = rnp->qsmaskinit;\n\t\trnp->qsmaskinit = rnp->qsmaskinitnext;\n\n\t\t/* If zero-ness of ->qsmaskinit changed, propagate up tree. */\n\t\tif (!oldmask != !rnp->qsmaskinit) {\n\t\t\tif (!oldmask) { /* First online CPU for rcu_node. */\n\t\t\t\tif (!rnp->wait_blkd_tasks) /* Ever offline? */\n\t\t\t\t\trcu_init_new_rnp(rnp);\n\t\t\t} else if (rcu_preempt_has_tasks(rnp)) {\n\t\t\t\trnp->wait_blkd_tasks = true; /* blocked tasks */\n\t\t\t} else { /* Last offline CPU and can propagate. */\n\t\t\t\trcu_cleanup_dead_rnp(rnp);\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * If all waited-on tasks from prior grace period are\n\t\t * done, and if all this rcu_node structure's CPUs are\n\t\t * still offline, propagate up the rcu_node tree and\n\t\t * clear ->wait_blkd_tasks.  Otherwise, if one of this\n\t\t * rcu_node structure's CPUs has since come back online,\n\t\t * simply clear ->wait_blkd_tasks.\n\t\t */\n\t\tif (rnp->wait_blkd_tasks &&\n\t\t    (!rcu_preempt_has_tasks(rnp) || rnp->qsmaskinit)) {\n\t\t\trnp->wait_blkd_tasks = false;\n\t\t\tif (!rnp->qsmaskinit)\n\t\t\t\trcu_cleanup_dead_rnp(rnp);\n\t\t}\n\n\t\traw_spin_unlock_irq_rcu_node(rnp);\n\t\traw_spin_unlock(&rcu_state.ofl_lock);\n\t}\n\trcu_gp_slow(gp_preinit_delay); /* Races with CPU hotplug. */\n\n\t/*\n\t * Set the quiescent-state-needed bits in all the rcu_node\n\t * structures for all currently online CPUs in breadth-first\n\t * order, starting from the root rcu_node structure, relying on the\n\t * layout of the tree within the rcu_state.node[] array.  Note that\n\t * other CPUs will access only the leaves of the hierarchy, thus\n\t * seeing that no grace period is in progress, at least until the\n\t * corresponding leaf node has been initialized.\n\t *\n\t * The grace period cannot complete until the initialization\n\t * process finishes, because this kthread handles both.\n\t */\n\tWRITE_ONCE(rcu_state.gp_state, RCU_GP_INIT);\n\trcu_for_each_node_breadth_first(rnp) {\n\t\trcu_gp_slow(gp_init_delay);\n\t\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\t\trdp = this_cpu_ptr(&rcu_data);\n\t\trcu_preempt_check_blocked_tasks(rnp);\n\t\trnp->qsmask = rnp->qsmaskinit;\n\t\tWRITE_ONCE(rnp->gp_seq, rcu_state.gp_seq);\n\t\tif (rnp == rdp->mynode)\n\t\t\t(void)__note_gp_changes(rnp, rdp);\n\t\trcu_preempt_boost_start_gp(rnp);\n\t\ttrace_rcu_grace_period_init(rcu_state.name, rnp->gp_seq,\n\t\t\t\t\t    rnp->level, rnp->grplo,\n\t\t\t\t\t    rnp->grphi, rnp->qsmask);\n\t\t/* Quiescent states for tasks on any now-offline CPUs. */\n\t\tmask = rnp->qsmask & ~rnp->qsmaskinitnext;\n\t\trnp->rcu_gp_init_mask = mask;\n\t\tif ((mask || rnp->wait_blkd_tasks) && rcu_is_leaf_node(rnp))\n\t\t\trcu_report_qs_rnp(mask, rnp, rnp->gp_seq, flags);\n\t\telse\n\t\t\traw_spin_unlock_irq_rcu_node(rnp);\n\t\tcond_resched_tasks_rcu_qs();\n\t\tWRITE_ONCE(rcu_state.gp_activity, jiffies);\n\t}\n\n\t// If strict, make all CPUs aware of new grace period.\n\tif (IS_ENABLED(CONFIG_RCU_STRICT_GRACE_PERIOD))\n\t\ton_each_cpu(rcu_strict_gp_boundary, NULL, 0);\n\n\treturn true;\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};",
            "static struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};",
            "static void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);",
            "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
            "static void check_cb_ovld_locked(struct rcu_data *rdp, struct rcu_node *rnp);",
            "static bool rcu_rdp_is_offloaded(struct rcu_data *rdp);",
            "static int gp_preinit_delay;",
            "static int gp_init_delay;",
            "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};\nstatic struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\nstatic void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void check_cb_ovld_locked(struct rcu_data *rdp, struct rcu_node *rnp);\nstatic bool rcu_rdp_is_offloaded(struct rcu_data *rdp);\nstatic int gp_preinit_delay;\nstatic int gp_init_delay;\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nstatic noinline_for_stack bool rcu_gp_init(void)\n{\n\tunsigned long firstseq;\n\tunsigned long flags;\n\tunsigned long oldmask;\n\tunsigned long mask;\n\tstruct rcu_data *rdp;\n\tstruct rcu_node *rnp = rcu_get_root();\n\n\tWRITE_ONCE(rcu_state.gp_activity, jiffies);\n\traw_spin_lock_irq_rcu_node(rnp);\n\tif (!READ_ONCE(rcu_state.gp_flags)) {\n\t\t/* Spurious wakeup, tell caller to go back to sleep.  */\n\t\traw_spin_unlock_irq_rcu_node(rnp);\n\t\treturn false;\n\t}\n\tWRITE_ONCE(rcu_state.gp_flags, 0); /* Clear all flags: New GP. */\n\n\tif (WARN_ON_ONCE(rcu_gp_in_progress())) {\n\t\t/*\n\t\t * Grace period already in progress, don't start another.\n\t\t * Not supposed to be able to happen.\n\t\t */\n\t\traw_spin_unlock_irq_rcu_node(rnp);\n\t\treturn false;\n\t}\n\n\t/* Advance to a new grace period and initialize state. */\n\trecord_gp_stall_check_time();\n\t/* Record GP times before starting GP, hence rcu_seq_start(). */\n\trcu_seq_start(&rcu_state.gp_seq);\n\tASSERT_EXCLUSIVE_WRITER(rcu_state.gp_seq);\n\ttrace_rcu_grace_period(rcu_state.name, rcu_state.gp_seq, TPS(\"start\"));\n\traw_spin_unlock_irq_rcu_node(rnp);\n\n\t/*\n\t * Apply per-leaf buffered online and offline operations to\n\t * the rcu_node tree. Note that this new grace period need not\n\t * wait for subsequent online CPUs, and that RCU hooks in the CPU\n\t * offlining path, when combined with checks in this function,\n\t * will handle CPUs that are currently going offline or that will\n\t * go offline later.  Please also refer to \"Hotplug CPU\" section\n\t * of RCU's Requirements documentation.\n\t */\n\tWRITE_ONCE(rcu_state.gp_state, RCU_GP_ONOFF);\n\trcu_for_each_leaf_node(rnp) {\n\t\t// Wait for CPU-hotplug operations that might have\n\t\t// started before this grace period did.\n\t\tsmp_mb(); // Pair with barriers used when updating ->ofl_seq to odd values.\n\t\tfirstseq = READ_ONCE(rnp->ofl_seq);\n\t\tif (firstseq & 0x1)\n\t\t\twhile (firstseq == READ_ONCE(rnp->ofl_seq))\n\t\t\t\tschedule_timeout_idle(1);  // Can't wake unless RCU is watching.\n\t\tsmp_mb(); // Pair with barriers used when updating ->ofl_seq to even values.\n\t\traw_spin_lock(&rcu_state.ofl_lock);\n\t\traw_spin_lock_irq_rcu_node(rnp);\n\t\tif (rnp->qsmaskinit == rnp->qsmaskinitnext &&\n\t\t    !rnp->wait_blkd_tasks) {\n\t\t\t/* Nothing to do on this leaf rcu_node structure. */\n\t\t\traw_spin_unlock_irq_rcu_node(rnp);\n\t\t\traw_spin_unlock(&rcu_state.ofl_lock);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Record old state, apply changes to ->qsmaskinit field. */\n\t\toldmask = rnp->qsmaskinit;\n\t\trnp->qsmaskinit = rnp->qsmaskinitnext;\n\n\t\t/* If zero-ness of ->qsmaskinit changed, propagate up tree. */\n\t\tif (!oldmask != !rnp->qsmaskinit) {\n\t\t\tif (!oldmask) { /* First online CPU for rcu_node. */\n\t\t\t\tif (!rnp->wait_blkd_tasks) /* Ever offline? */\n\t\t\t\t\trcu_init_new_rnp(rnp);\n\t\t\t} else if (rcu_preempt_has_tasks(rnp)) {\n\t\t\t\trnp->wait_blkd_tasks = true; /* blocked tasks */\n\t\t\t} else { /* Last offline CPU and can propagate. */\n\t\t\t\trcu_cleanup_dead_rnp(rnp);\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * If all waited-on tasks from prior grace period are\n\t\t * done, and if all this rcu_node structure's CPUs are\n\t\t * still offline, propagate up the rcu_node tree and\n\t\t * clear ->wait_blkd_tasks.  Otherwise, if one of this\n\t\t * rcu_node structure's CPUs has since come back online,\n\t\t * simply clear ->wait_blkd_tasks.\n\t\t */\n\t\tif (rnp->wait_blkd_tasks &&\n\t\t    (!rcu_preempt_has_tasks(rnp) || rnp->qsmaskinit)) {\n\t\t\trnp->wait_blkd_tasks = false;\n\t\t\tif (!rnp->qsmaskinit)\n\t\t\t\trcu_cleanup_dead_rnp(rnp);\n\t\t}\n\n\t\traw_spin_unlock_irq_rcu_node(rnp);\n\t\traw_spin_unlock(&rcu_state.ofl_lock);\n\t}\n\trcu_gp_slow(gp_preinit_delay); /* Races with CPU hotplug. */\n\n\t/*\n\t * Set the quiescent-state-needed bits in all the rcu_node\n\t * structures for all currently online CPUs in breadth-first\n\t * order, starting from the root rcu_node structure, relying on the\n\t * layout of the tree within the rcu_state.node[] array.  Note that\n\t * other CPUs will access only the leaves of the hierarchy, thus\n\t * seeing that no grace period is in progress, at least until the\n\t * corresponding leaf node has been initialized.\n\t *\n\t * The grace period cannot complete until the initialization\n\t * process finishes, because this kthread handles both.\n\t */\n\tWRITE_ONCE(rcu_state.gp_state, RCU_GP_INIT);\n\trcu_for_each_node_breadth_first(rnp) {\n\t\trcu_gp_slow(gp_init_delay);\n\t\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\t\trdp = this_cpu_ptr(&rcu_data);\n\t\trcu_preempt_check_blocked_tasks(rnp);\n\t\trnp->qsmask = rnp->qsmaskinit;\n\t\tWRITE_ONCE(rnp->gp_seq, rcu_state.gp_seq);\n\t\tif (rnp == rdp->mynode)\n\t\t\t(void)__note_gp_changes(rnp, rdp);\n\t\trcu_preempt_boost_start_gp(rnp);\n\t\ttrace_rcu_grace_period_init(rcu_state.name, rnp->gp_seq,\n\t\t\t\t\t    rnp->level, rnp->grplo,\n\t\t\t\t\t    rnp->grphi, rnp->qsmask);\n\t\t/* Quiescent states for tasks on any now-offline CPUs. */\n\t\tmask = rnp->qsmask & ~rnp->qsmaskinitnext;\n\t\trnp->rcu_gp_init_mask = mask;\n\t\tif ((mask || rnp->wait_blkd_tasks) && rcu_is_leaf_node(rnp))\n\t\t\trcu_report_qs_rnp(mask, rnp, rnp->gp_seq, flags);\n\t\telse\n\t\t\traw_spin_unlock_irq_rcu_node(rnp);\n\t\tcond_resched_tasks_rcu_qs();\n\t\tWRITE_ONCE(rcu_state.gp_activity, jiffies);\n\t}\n\n\t// If strict, make all CPUs aware of new grace period.\n\tif (IS_ENABLED(CONFIG_RCU_STRICT_GRACE_PERIOD))\n\t\ton_each_cpu(rcu_strict_gp_boundary, NULL, 0);\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "rcu_state.gp_state",
            "RCU_GP_DONE_GPS"
          ],
          "line": 2124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_gp_torture_wait",
          "args": [],
          "line": 2123
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_gp_torture_wait",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "1714-1726",
          "snippet": "static void rcu_gp_torture_wait(void)\n{\n\tunsigned long duration;\n\n\tif (!IS_ENABLED(CONFIG_RCU_TORTURE_TEST))\n\t\treturn;\n\tduration = xchg(&sleep_duration, 0UL);\n\tif (duration > 0) {\n\t\tpr_alert(\"%s: Waiting %lu jiffies\\n\", __func__, duration);\n\t\tschedule_timeout_idle(duration);\n\t\tpr_alert(\"%s: Wait complete\\n\", __func__);\n\t}\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned long sleep_duration;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic unsigned long sleep_duration;\n\nstatic void rcu_gp_torture_wait(void)\n{\n\tunsigned long duration;\n\n\tif (!IS_ENABLED(CONFIG_RCU_TORTURE_TEST))\n\t\treturn;\n\tduration = xchg(&sleep_duration, 0UL);\n\tif (duration > 0) {\n\t\tpr_alert(\"%s: Waiting %lu jiffies\\n\", __func__, duration);\n\t\tschedule_timeout_idle(duration);\n\t\tpr_alert(\"%s: Wait complete\\n\", __func__);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "swait_event_idle_exclusive",
          "args": [
            "rcu_state.gp_wq",
            "READ_ONCE(rcu_state.gp_flags) &\n\t\t\t\t\t RCU_GP_FLAG_INIT"
          ],
          "line": 2120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rcu_state.gp_flags"
          ],
          "line": 2121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "rcu_state.gp_state",
            "RCU_GP_WAIT_GPS"
          ],
          "line": 2119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_rcu_grace_period",
          "args": [
            "rcu_state.name",
            "rcu_state.gp_seq",
            "TPS(\"reqwait\")"
          ],
          "line": 2117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPS",
          "args": [
            "\"reqwait\""
          ],
          "line": 2118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_bind_gp_kthread",
          "args": [],
          "line": 2112
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_bind_gp_kthread",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "1290-1295",
          "snippet": "static void rcu_bind_gp_kthread(void)\n{\n\tif (!tick_nohz_full_enabled())\n\t\treturn;\n\thousekeeping_affine(current, HK_FLAG_RCU);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nstatic void rcu_bind_gp_kthread(void)\n{\n\tif (!tick_nohz_full_enabled())\n\t\treturn;\n\thousekeeping_affine(current, HK_FLAG_RCU);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\n\nstatic int __noreturn rcu_gp_kthread(void *unused)\n{\n\trcu_bind_gp_kthread();\n\tfor (;;) {\n\n\t\t/* Handle grace-period start. */\n\t\tfor (;;) {\n\t\t\ttrace_rcu_grace_period(rcu_state.name, rcu_state.gp_seq,\n\t\t\t\t\t       TPS(\"reqwait\"));\n\t\t\tWRITE_ONCE(rcu_state.gp_state, RCU_GP_WAIT_GPS);\n\t\t\tswait_event_idle_exclusive(rcu_state.gp_wq,\n\t\t\t\t\t READ_ONCE(rcu_state.gp_flags) &\n\t\t\t\t\t RCU_GP_FLAG_INIT);\n\t\t\trcu_gp_torture_wait();\n\t\t\tWRITE_ONCE(rcu_state.gp_state, RCU_GP_DONE_GPS);\n\t\t\t/* Locking provides needed memory barrier. */\n\t\t\tif (rcu_gp_init())\n\t\t\t\tbreak;\n\t\t\tcond_resched_tasks_rcu_qs();\n\t\t\tWRITE_ONCE(rcu_state.gp_activity, jiffies);\n\t\t\tWARN_ON(signal_pending(current));\n\t\t\ttrace_rcu_grace_period(rcu_state.name, rcu_state.gp_seq,\n\t\t\t\t\t       TPS(\"reqwaitsig\"));\n\t\t}\n\n\t\t/* Handle quiescent-state forcing. */\n\t\trcu_gp_fqs_loop();\n\n\t\t/* Handle grace-period end. */\n\t\tWRITE_ONCE(rcu_state.gp_state, RCU_GP_CLEANUP);\n\t\trcu_gp_cleanup();\n\t\tWRITE_ONCE(rcu_state.gp_state, RCU_GP_CLEANED);\n\t}\n}"
  },
  {
    "function_name": "rcu_gp_cleanup",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
    "lines": "2010-2105",
    "snippet": "static noinline void rcu_gp_cleanup(void)\n{\n\tint cpu;\n\tbool needgp = false;\n\tunsigned long gp_duration;\n\tunsigned long new_gp_seq;\n\tbool offloaded;\n\tstruct rcu_data *rdp;\n\tstruct rcu_node *rnp = rcu_get_root();\n\tstruct swait_queue_head *sq;\n\n\tWRITE_ONCE(rcu_state.gp_activity, jiffies);\n\traw_spin_lock_irq_rcu_node(rnp);\n\trcu_state.gp_end = jiffies;\n\tgp_duration = rcu_state.gp_end - rcu_state.gp_start;\n\tif (gp_duration > rcu_state.gp_max)\n\t\trcu_state.gp_max = gp_duration;\n\n\t/*\n\t * We know the grace period is complete, but to everyone else\n\t * it appears to still be ongoing.  But it is also the case\n\t * that to everyone else it looks like there is nothing that\n\t * they can do to advance the grace period.  It is therefore\n\t * safe for us to drop the lock in order to mark the grace\n\t * period as completed in all of the rcu_node structures.\n\t */\n\traw_spin_unlock_irq_rcu_node(rnp);\n\n\t/*\n\t * Propagate new ->gp_seq value to rcu_node structures so that\n\t * other CPUs don't have to wait until the start of the next grace\n\t * period to process their callbacks.  This also avoids some nasty\n\t * RCU grace-period initialization races by forcing the end of\n\t * the current grace period to be completely recorded in all of\n\t * the rcu_node structures before the beginning of the next grace\n\t * period is recorded in any of the rcu_node structures.\n\t */\n\tnew_gp_seq = rcu_state.gp_seq;\n\trcu_seq_end(&new_gp_seq);\n\trcu_for_each_node_breadth_first(rnp) {\n\t\traw_spin_lock_irq_rcu_node(rnp);\n\t\tif (WARN_ON_ONCE(rcu_preempt_blocked_readers_cgp(rnp)))\n\t\t\tdump_blkd_tasks(rnp, 10);\n\t\tWARN_ON_ONCE(rnp->qsmask);\n\t\tWRITE_ONCE(rnp->gp_seq, new_gp_seq);\n\t\trdp = this_cpu_ptr(&rcu_data);\n\t\tif (rnp == rdp->mynode)\n\t\t\tneedgp = __note_gp_changes(rnp, rdp) || needgp;\n\t\t/* smp_mb() provided by prior unlock-lock pair. */\n\t\tneedgp = rcu_future_gp_cleanup(rnp) || needgp;\n\t\t// Reset overload indication for CPUs no longer overloaded\n\t\tif (rcu_is_leaf_node(rnp))\n\t\t\tfor_each_leaf_node_cpu_mask(rnp, cpu, rnp->cbovldmask) {\n\t\t\t\trdp = per_cpu_ptr(&rcu_data, cpu);\n\t\t\t\tcheck_cb_ovld_locked(rdp, rnp);\n\t\t\t}\n\t\tsq = rcu_nocb_gp_get(rnp);\n\t\traw_spin_unlock_irq_rcu_node(rnp);\n\t\trcu_nocb_gp_cleanup(sq);\n\t\tcond_resched_tasks_rcu_qs();\n\t\tWRITE_ONCE(rcu_state.gp_activity, jiffies);\n\t\trcu_gp_slow(gp_cleanup_delay);\n\t}\n\trnp = rcu_get_root();\n\traw_spin_lock_irq_rcu_node(rnp); /* GP before ->gp_seq update. */\n\n\t/* Declare grace period done, trace first to use old GP number. */\n\ttrace_rcu_grace_period(rcu_state.name, rcu_state.gp_seq, TPS(\"end\"));\n\trcu_seq_end(&rcu_state.gp_seq);\n\tASSERT_EXCLUSIVE_WRITER(rcu_state.gp_seq);\n\tWRITE_ONCE(rcu_state.gp_state, RCU_GP_IDLE);\n\t/* Check for GP requests since above loop. */\n\trdp = this_cpu_ptr(&rcu_data);\n\tif (!needgp && ULONG_CMP_LT(rnp->gp_seq, rnp->gp_seq_needed)) {\n\t\ttrace_rcu_this_gp(rnp, rdp, rnp->gp_seq_needed,\n\t\t\t\t  TPS(\"CleanupMore\"));\n\t\tneedgp = true;\n\t}\n\t/* Advance CBs to reduce false positives below. */\n\toffloaded = rcu_rdp_is_offloaded(rdp);\n\tif ((offloaded || !rcu_accelerate_cbs(rnp, rdp)) && needgp) {\n\t\tWRITE_ONCE(rcu_state.gp_flags, RCU_GP_FLAG_INIT);\n\t\tWRITE_ONCE(rcu_state.gp_req_activity, jiffies);\n\t\ttrace_rcu_grace_period(rcu_state.name,\n\t\t\t\t       rcu_state.gp_seq,\n\t\t\t\t       TPS(\"newreq\"));\n\t} else {\n\t\tWRITE_ONCE(rcu_state.gp_flags,\n\t\t\t   rcu_state.gp_flags & RCU_GP_FLAG_INIT);\n\t}\n\traw_spin_unlock_irq_rcu_node(rnp);\n\n\t// If strict, make all CPUs aware of the end of the old grace period.\n\tif (IS_ENABLED(CONFIG_RCU_STRICT_GRACE_PERIOD))\n\t\ton_each_cpu(rcu_strict_gp_boundary, NULL, 0);\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_nocb.h\"",
      "#include \"tree_exp.h\"",
      "#include \"tree_stall.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <linux/kasan.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/panic_notifier.h>",
      "#include <linux/panic.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};",
      "static struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};",
      "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
      "static void sync_sched_exp_online_cleanup(int cpu);",
      "static void check_cb_ovld_locked(struct rcu_data *rdp, struct rcu_node *rnp);",
      "static bool rcu_rdp_is_offloaded(struct rcu_data *rdp);",
      "static int gp_cleanup_delay;",
      "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "on_each_cpu",
          "args": [
            "rcu_strict_gp_boundary",
            "NULL",
            "0"
          ],
          "line": 2104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_RCU_STRICT_GRACE_PERIOD"
          ],
          "line": 2103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irq_rcu_node",
          "args": [
            "rnp"
          ],
          "line": 2100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "rcu_state.gp_flags",
            "rcu_state.gp_flags & RCU_GP_FLAG_INIT"
          ],
          "line": 2097
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_rcu_grace_period",
          "args": [
            "rcu_state.name",
            "rcu_state.gp_seq",
            "TPS(\"newreq\")"
          ],
          "line": 2093
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPS",
          "args": [
            "\"newreq\""
          ],
          "line": 2095
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "rcu_state.gp_req_activity",
            "jiffies"
          ],
          "line": 2092
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "rcu_state.gp_flags",
            "RCU_GP_FLAG_INIT"
          ],
          "line": 2091
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_accelerate_cbs",
          "args": [
            "rnp",
            "rdp"
          ],
          "line": 2090
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_accelerate_cbs_unlocked",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "1543-1561",
          "snippet": "static void rcu_accelerate_cbs_unlocked(struct rcu_node *rnp,\n\t\t\t\t\tstruct rcu_data *rdp)\n{\n\tunsigned long c;\n\tbool needwake;\n\n\trcu_lockdep_assert_cblist_protected(rdp);\n\tc = rcu_seq_snap(&rcu_state.gp_seq);\n\tif (!READ_ONCE(rdp->gpwrap) && ULONG_CMP_GE(rdp->gp_seq_needed, c)) {\n\t\t/* Old request still live, so mark recent callbacks. */\n\t\t(void)rcu_segcblist_accelerate(&rdp->cblist, c);\n\t\treturn;\n\t}\n\traw_spin_lock_rcu_node(rnp); /* irqs already disabled. */\n\tneedwake = rcu_accelerate_cbs(rnp, rdp);\n\traw_spin_unlock_rcu_node(rnp); /* irqs remain disabled. */\n\tif (needwake)\n\t\trcu_gp_kthread_wake();\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};",
            "static struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};",
            "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
            "static void check_cb_ovld_locked(struct rcu_data *rdp, struct rcu_node *rnp);",
            "static bool rcu_rdp_is_offloaded(struct rcu_data *rdp);",
            "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};\nstatic struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void check_cb_ovld_locked(struct rcu_data *rdp, struct rcu_node *rnp);\nstatic bool rcu_rdp_is_offloaded(struct rcu_data *rdp);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nstatic void rcu_accelerate_cbs_unlocked(struct rcu_node *rnp,\n\t\t\t\t\tstruct rcu_data *rdp)\n{\n\tunsigned long c;\n\tbool needwake;\n\n\trcu_lockdep_assert_cblist_protected(rdp);\n\tc = rcu_seq_snap(&rcu_state.gp_seq);\n\tif (!READ_ONCE(rdp->gpwrap) && ULONG_CMP_GE(rdp->gp_seq_needed, c)) {\n\t\t/* Old request still live, so mark recent callbacks. */\n\t\t(void)rcu_segcblist_accelerate(&rdp->cblist, c);\n\t\treturn;\n\t}\n\traw_spin_lock_rcu_node(rnp); /* irqs already disabled. */\n\tneedwake = rcu_accelerate_cbs(rnp, rdp);\n\traw_spin_unlock_rcu_node(rnp); /* irqs remain disabled. */\n\tif (needwake)\n\t\trcu_gp_kthread_wake();\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_rdp_is_offloaded",
          "args": [
            "rdp"
          ],
          "line": 2089
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_rdp_is_offloaded",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "16-38",
          "snippet": "static bool rcu_rdp_is_offloaded(struct rcu_data *rdp)\n{\n\t/*\n\t * In order to read the offloaded state of an rdp in a safe\n\t * and stable way and prevent from its value to be changed\n\t * under us, we must either hold the barrier mutex, the cpu\n\t * hotplug lock (read or write) or the nocb lock. Local\n\t * non-preemptible reads are also safe. NOCB kthreads and\n\t * timers have their own means of synchronization against the\n\t * offloaded state updaters.\n\t */\n\tRCU_LOCKDEP_WARN(\n\t\t!(lockdep_is_held(&rcu_state.barrier_mutex) ||\n\t\t  (IS_ENABLED(CONFIG_HOTPLUG_CPU) && lockdep_is_cpus_held()) ||\n\t\t  rcu_lockdep_is_held_nocb(rdp) ||\n\t\t  (rdp == this_cpu_ptr(&rcu_data) &&\n\t\t   !(IS_ENABLED(CONFIG_PREEMPT_COUNT) && preemptible())) ||\n\t\t  rcu_current_is_nocb_kthread(rdp)),\n\t\t\"Unsafe read of RCU_NOCB offloaded state\"\n\t);\n\n\treturn rcu_segcblist_is_offloaded(&rdp->cblist);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nstatic bool rcu_rdp_is_offloaded(struct rcu_data *rdp)\n{\n\t/*\n\t * In order to read the offloaded state of an rdp in a safe\n\t * and stable way and prevent from its value to be changed\n\t * under us, we must either hold the barrier mutex, the cpu\n\t * hotplug lock (read or write) or the nocb lock. Local\n\t * non-preemptible reads are also safe. NOCB kthreads and\n\t * timers have their own means of synchronization against the\n\t * offloaded state updaters.\n\t */\n\tRCU_LOCKDEP_WARN(\n\t\t!(lockdep_is_held(&rcu_state.barrier_mutex) ||\n\t\t  (IS_ENABLED(CONFIG_HOTPLUG_CPU) && lockdep_is_cpus_held()) ||\n\t\t  rcu_lockdep_is_held_nocb(rdp) ||\n\t\t  (rdp == this_cpu_ptr(&rcu_data) &&\n\t\t   !(IS_ENABLED(CONFIG_PREEMPT_COUNT) && preemptible())) ||\n\t\t  rcu_current_is_nocb_kthread(rdp)),\n\t\t\"Unsafe read of RCU_NOCB offloaded state\"\n\t);\n\n\treturn rcu_segcblist_is_offloaded(&rdp->cblist);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_rcu_this_gp",
          "args": [
            "rnp",
            "rdp",
            "rnp->gp_seq_needed",
            "TPS(\"CleanupMore\")"
          ],
          "line": 2084
        },
        "resolved": true,
        "details": {
          "function_name": "trace_rcu_this_gp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "1346-1352",
          "snippet": "static void trace_rcu_this_gp(struct rcu_node *rnp, struct rcu_data *rdp,\n\t\t\t      unsigned long gp_seq_req, const char *s)\n{\n\ttrace_rcu_future_grace_period(rcu_state.name, READ_ONCE(rnp->gp_seq),\n\t\t\t\t      gp_seq_req, rnp->level,\n\t\t\t\t      rnp->grplo, rnp->grphi, s);\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};",
            "static struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};",
            "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
            "static void check_cb_ovld_locked(struct rcu_data *rdp, struct rcu_node *rnp);",
            "static bool rcu_rdp_is_offloaded(struct rcu_data *rdp);",
            "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};\nstatic struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void check_cb_ovld_locked(struct rcu_data *rdp, struct rcu_node *rnp);\nstatic bool rcu_rdp_is_offloaded(struct rcu_data *rdp);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nstatic void trace_rcu_this_gp(struct rcu_node *rnp, struct rcu_data *rdp,\n\t\t\t      unsigned long gp_seq_req, const char *s)\n{\n\ttrace_rcu_future_grace_period(rcu_state.name, READ_ONCE(rnp->gp_seq),\n\t\t\t\t      gp_seq_req, rnp->level,\n\t\t\t\t      rnp->grplo, rnp->grphi, s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "TPS",
          "args": [
            "\"CleanupMore\""
          ],
          "line": 2085
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ULONG_CMP_LT",
          "args": [
            "rnp->gp_seq",
            "rnp->gp_seq_needed"
          ],
          "line": 2083
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&rcu_data"
          ],
          "line": 2082
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "rcu_state.gp_state",
            "RCU_GP_IDLE"
          ],
          "line": 2080
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_EXCLUSIVE_WRITER",
          "args": [
            "rcu_state.gp_seq"
          ],
          "line": 2079
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_seq_end",
          "args": [
            "&rcu_state.gp_seq"
          ],
          "line": 2078
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_seq_end",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu.h",
          "lines": "69-74",
          "snippet": "static inline void rcu_seq_end(unsigned long *sp)\n{\n\tsmp_mb(); /* Ensure update-side operation before counter increment. */\n\tWARN_ON_ONCE(!rcu_seq_state(*sp));\n\tWRITE_ONCE(*sp, rcu_seq_endval(sp));\n}",
          "includes": [
            "#include <linux/rcu_node_tree.h>",
            "#include <trace/events/rcu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_node_tree.h>\n#include <trace/events/rcu.h>\n\nstatic inline void rcu_seq_end(unsigned long *sp)\n{\n\tsmp_mb(); /* Ensure update-side operation before counter increment. */\n\tWARN_ON_ONCE(!rcu_seq_state(*sp));\n\tWRITE_ONCE(*sp, rcu_seq_endval(sp));\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_rcu_grace_period",
          "args": [
            "rcu_state.name",
            "rcu_state.gp_seq",
            "TPS(\"end\")"
          ],
          "line": 2077
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPS",
          "args": [
            "\"end\""
          ],
          "line": 2077
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irq_rcu_node",
          "args": [
            "rnp"
          ],
          "line": 2074
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_get_root",
          "args": [],
          "line": 2073
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_get_root",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "579-582",
          "snippet": "static struct rcu_node *rcu_get_root(void)\n{\n\treturn &rcu_state.node[0];\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\n\nstatic struct rcu_node *rcu_get_root(void)\n{\n\treturn &rcu_state.node[0];\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_gp_slow",
          "args": [
            "gp_cleanup_delay"
          ],
          "line": 2071
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_gp_slow",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "1695-1701",
          "snippet": "static void rcu_gp_slow(int delay)\n{\n\tif (delay > 0 &&\n\t    !(rcu_seq_ctr(rcu_state.gp_seq) %\n\t      (rcu_num_nodes * PER_RCU_NODE_PERIOD * delay)))\n\t\tschedule_timeout_idle(delay);\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define PER_RCU_NODE_PERIOD 3\t/* Number of grace periods between delays for debugging. */"
          ],
          "globals_used": [
            "static struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};",
            "int rcu_num_nodes"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define PER_RCU_NODE_PERIOD 3\t/* Number of grace periods between delays for debugging. */\n\nstatic struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\nint rcu_num_nodes;\n\nstatic void rcu_gp_slow(int delay)\n{\n\tif (delay > 0 &&\n\t    !(rcu_seq_ctr(rcu_state.gp_seq) %\n\t      (rcu_num_nodes * PER_RCU_NODE_PERIOD * delay)))\n\t\tschedule_timeout_idle(delay);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "rcu_state.gp_activity",
            "jiffies"
          ],
          "line": 2070
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cond_resched_tasks_rcu_qs",
          "args": [],
          "line": 2069
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_nocb_gp_cleanup",
          "args": [
            "sq"
          ],
          "line": 2068
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_nocb_gp_cleanup",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_nocb.h",
          "lines": "1491-1493",
          "snippet": "static void rcu_nocb_gp_cleanup(struct swait_queue_head *sq)\n{\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static void rcu_nocb_gp_cleanup(struct swait_queue_head *sq)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irq_rcu_node",
          "args": [
            "rnp"
          ],
          "line": 2067
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_nocb_gp_get",
          "args": [
            "rnp"
          ],
          "line": 2066
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_nocb_gp_get",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_nocb.h",
          "lines": "1495-1498",
          "snippet": "static struct swait_queue_head *rcu_nocb_gp_get(struct rcu_node *rnp)\n{\n\treturn NULL;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static struct swait_queue_head *rcu_nocb_gp_get(struct rcu_node *rnp)\n{\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_cb_ovld_locked",
          "args": [
            "rdp",
            "rnp"
          ],
          "line": 2064
        },
        "resolved": true,
        "details": {
          "function_name": "check_cb_ovld_locked",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "2962-2971",
          "snippet": "static void check_cb_ovld_locked(struct rcu_data *rdp, struct rcu_node *rnp)\n{\n\traw_lockdep_assert_held_rcu_node(rnp);\n\tif (qovld_calc <= 0)\n\t\treturn; // Early boot and wildcard value set.\n\tif (rcu_segcblist_n_cbs(&rdp->cblist) >= qovld_calc)\n\t\tWRITE_ONCE(rnp->cbovldmask, rnp->cbovldmask | rdp->grpmask);\n\telse\n\t\tWRITE_ONCE(rnp->cbovldmask, rnp->cbovldmask & ~rdp->grpmask);\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};",
            "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
            "static void check_cb_ovld_locked(struct rcu_data *rdp, struct rcu_node *rnp);",
            "static bool rcu_rdp_is_offloaded(struct rcu_data *rdp);",
            "static long qovld_calc = -1;",
            "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void check_cb_ovld_locked(struct rcu_data *rdp, struct rcu_node *rnp);\nstatic bool rcu_rdp_is_offloaded(struct rcu_data *rdp);\nstatic long qovld_calc = -1;\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nstatic void check_cb_ovld_locked(struct rcu_data *rdp, struct rcu_node *rnp)\n{\n\traw_lockdep_assert_held_rcu_node(rnp);\n\tif (qovld_calc <= 0)\n\t\treturn; // Early boot and wildcard value set.\n\tif (rcu_segcblist_n_cbs(&rdp->cblist) >= qovld_calc)\n\t\tWRITE_ONCE(rnp->cbovldmask, rnp->cbovldmask | rdp->grpmask);\n\telse\n\t\tWRITE_ONCE(rnp->cbovldmask, rnp->cbovldmask & ~rdp->grpmask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "&rcu_data",
            "cpu"
          ],
          "line": 2063
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_leaf_node_cpu_mask",
          "args": [
            "rnp",
            "cpu",
            "rnp->cbovldmask"
          ],
          "line": 2062
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_is_leaf_node",
          "args": [
            "rnp"
          ],
          "line": 2061
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_future_gp_cleanup",
          "args": [
            "rnp"
          ],
          "line": 2059
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_future_gp_cleanup",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "1445-1456",
          "snippet": "static bool rcu_future_gp_cleanup(struct rcu_node *rnp)\n{\n\tbool needmore;\n\tstruct rcu_data *rdp = this_cpu_ptr(&rcu_data);\n\n\tneedmore = ULONG_CMP_LT(rnp->gp_seq, rnp->gp_seq_needed);\n\tif (!needmore)\n\t\trnp->gp_seq_needed = rnp->gp_seq; /* Avoid counter wrap. */\n\ttrace_rcu_this_gp(rnp, rdp, rnp->gp_seq,\n\t\t\t  needmore ? TPS(\"CleanupMore\") : TPS(\"Cleanup\"));\n\treturn needmore;\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};",
            "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
            "static void check_cb_ovld_locked(struct rcu_data *rdp, struct rcu_node *rnp);",
            "static bool rcu_rdp_is_offloaded(struct rcu_data *rdp);",
            "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void check_cb_ovld_locked(struct rcu_data *rdp, struct rcu_node *rnp);\nstatic bool rcu_rdp_is_offloaded(struct rcu_data *rdp);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nstatic bool rcu_future_gp_cleanup(struct rcu_node *rnp)\n{\n\tbool needmore;\n\tstruct rcu_data *rdp = this_cpu_ptr(&rcu_data);\n\n\tneedmore = ULONG_CMP_LT(rnp->gp_seq, rnp->gp_seq_needed);\n\tif (!needmore)\n\t\trnp->gp_seq_needed = rnp->gp_seq; /* Avoid counter wrap. */\n\ttrace_rcu_this_gp(rnp, rdp, rnp->gp_seq,\n\t\t\t  needmore ? TPS(\"CleanupMore\") : TPS(\"Cleanup\"));\n\treturn needmore;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__note_gp_changes",
          "args": [
            "rnp",
            "rdp"
          ],
          "line": 2057
        },
        "resolved": true,
        "details": {
          "function_name": "__note_gp_changes",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "1627-1672",
          "snippet": "static bool __note_gp_changes(struct rcu_node *rnp, struct rcu_data *rdp)\n{\n\tbool ret = false;\n\tbool need_qs;\n\tconst bool offloaded = rcu_rdp_is_offloaded(rdp);\n\n\traw_lockdep_assert_held_rcu_node(rnp);\n\n\tif (rdp->gp_seq == rnp->gp_seq)\n\t\treturn false; /* Nothing to do. */\n\n\t/* Handle the ends of any preceding grace periods first. */\n\tif (rcu_seq_completed_gp(rdp->gp_seq, rnp->gp_seq) ||\n\t    unlikely(READ_ONCE(rdp->gpwrap))) {\n\t\tif (!offloaded)\n\t\t\tret = rcu_advance_cbs(rnp, rdp); /* Advance CBs. */\n\t\trdp->core_needs_qs = false;\n\t\ttrace_rcu_grace_period(rcu_state.name, rdp->gp_seq, TPS(\"cpuend\"));\n\t} else {\n\t\tif (!offloaded)\n\t\t\tret = rcu_accelerate_cbs(rnp, rdp); /* Recent CBs. */\n\t\tif (rdp->core_needs_qs)\n\t\t\trdp->core_needs_qs = !!(rnp->qsmask & rdp->grpmask);\n\t}\n\n\t/* Now handle the beginnings of any new-to-this-CPU grace periods. */\n\tif (rcu_seq_new_gp(rdp->gp_seq, rnp->gp_seq) ||\n\t    unlikely(READ_ONCE(rdp->gpwrap))) {\n\t\t/*\n\t\t * If the current grace period is waiting for this CPU,\n\t\t * set up to detect a quiescent state, otherwise don't\n\t\t * go looking for one.\n\t\t */\n\t\ttrace_rcu_grace_period(rcu_state.name, rnp->gp_seq, TPS(\"cpustart\"));\n\t\tneed_qs = !!(rnp->qsmask & rdp->grpmask);\n\t\trdp->cpu_no_qs.b.norm = need_qs;\n\t\trdp->core_needs_qs = need_qs;\n\t\tzero_cpu_stall_ticks(rdp);\n\t}\n\trdp->gp_seq = rnp->gp_seq;  /* Remember new grace-period state. */\n\tif (ULONG_CMP_LT(rdp->gp_seq_needed, rnp->gp_seq_needed) || rdp->gpwrap)\n\t\tWRITE_ONCE(rdp->gp_seq_needed, rnp->gp_seq_needed);\n\tWRITE_ONCE(rdp->gpwrap, false);\n\trcu_gpnum_ovf(rnp, rdp);\n\treturn ret;\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};",
            "static struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};",
            "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
            "static void check_cb_ovld_locked(struct rcu_data *rdp, struct rcu_node *rnp);",
            "static bool rcu_rdp_is_offloaded(struct rcu_data *rdp);",
            "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};\nstatic struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void check_cb_ovld_locked(struct rcu_data *rdp, struct rcu_node *rnp);\nstatic bool rcu_rdp_is_offloaded(struct rcu_data *rdp);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nstatic bool __note_gp_changes(struct rcu_node *rnp, struct rcu_data *rdp)\n{\n\tbool ret = false;\n\tbool need_qs;\n\tconst bool offloaded = rcu_rdp_is_offloaded(rdp);\n\n\traw_lockdep_assert_held_rcu_node(rnp);\n\n\tif (rdp->gp_seq == rnp->gp_seq)\n\t\treturn false; /* Nothing to do. */\n\n\t/* Handle the ends of any preceding grace periods first. */\n\tif (rcu_seq_completed_gp(rdp->gp_seq, rnp->gp_seq) ||\n\t    unlikely(READ_ONCE(rdp->gpwrap))) {\n\t\tif (!offloaded)\n\t\t\tret = rcu_advance_cbs(rnp, rdp); /* Advance CBs. */\n\t\trdp->core_needs_qs = false;\n\t\ttrace_rcu_grace_period(rcu_state.name, rdp->gp_seq, TPS(\"cpuend\"));\n\t} else {\n\t\tif (!offloaded)\n\t\t\tret = rcu_accelerate_cbs(rnp, rdp); /* Recent CBs. */\n\t\tif (rdp->core_needs_qs)\n\t\t\trdp->core_needs_qs = !!(rnp->qsmask & rdp->grpmask);\n\t}\n\n\t/* Now handle the beginnings of any new-to-this-CPU grace periods. */\n\tif (rcu_seq_new_gp(rdp->gp_seq, rnp->gp_seq) ||\n\t    unlikely(READ_ONCE(rdp->gpwrap))) {\n\t\t/*\n\t\t * If the current grace period is waiting for this CPU,\n\t\t * set up to detect a quiescent state, otherwise don't\n\t\t * go looking for one.\n\t\t */\n\t\ttrace_rcu_grace_period(rcu_state.name, rnp->gp_seq, TPS(\"cpustart\"));\n\t\tneed_qs = !!(rnp->qsmask & rdp->grpmask);\n\t\trdp->cpu_no_qs.b.norm = need_qs;\n\t\trdp->core_needs_qs = need_qs;\n\t\tzero_cpu_stall_ticks(rdp);\n\t}\n\trdp->gp_seq = rnp->gp_seq;  /* Remember new grace-period state. */\n\tif (ULONG_CMP_LT(rdp->gp_seq_needed, rnp->gp_seq_needed) || rdp->gpwrap)\n\t\tWRITE_ONCE(rdp->gp_seq_needed, rnp->gp_seq_needed);\n\tWRITE_ONCE(rdp->gpwrap, false);\n\trcu_gpnum_ovf(rnp, rdp);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&rcu_data"
          ],
          "line": 2055
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "rnp->gp_seq",
            "new_gp_seq"
          ],
          "line": 2054
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "rnp->qsmask"
          ],
          "line": 2053
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dump_blkd_tasks",
          "args": [
            "rnp",
            "10"
          ],
          "line": 2052
        },
        "resolved": true,
        "details": {
          "function_name": "dump_blkd_tasks",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "986-990",
          "snippet": "static void\ndump_blkd_tasks(struct rcu_node *rnp, int ncheck)\n{\n\tWARN_ON_ONCE(!list_empty(&rnp->blkd_tasks));\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nstatic void\ndump_blkd_tasks(struct rcu_node *rnp, int ncheck)\n{\n\tWARN_ON_ONCE(!list_empty(&rnp->blkd_tasks));\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "rcu_preempt_blocked_readers_cgp(rnp)"
          ],
          "line": 2051
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_preempt_blocked_readers_cgp",
          "args": [
            "rnp"
          ],
          "line": 2051
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_preempt_blocked_readers_cgp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "907-910",
          "snippet": "static int rcu_preempt_blocked_readers_cgp(struct rcu_node *rnp)\n{\n\treturn 0;\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nstatic int rcu_preempt_blocked_readers_cgp(struct rcu_node *rnp)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irq_rcu_node",
          "args": [
            "rnp"
          ],
          "line": 2050
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irq_rcu_node",
          "args": [
            "rnp"
          ],
          "line": 2036
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irq_rcu_node",
          "args": [
            "rnp"
          ],
          "line": 2022
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "rcu_state.gp_activity",
            "jiffies"
          ],
          "line": 2021
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};\nstatic struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void sync_sched_exp_online_cleanup(int cpu);\nstatic void check_cb_ovld_locked(struct rcu_data *rdp, struct rcu_node *rnp);\nstatic bool rcu_rdp_is_offloaded(struct rcu_data *rdp);\nstatic int gp_cleanup_delay;\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nstatic noinline void rcu_gp_cleanup(void)\n{\n\tint cpu;\n\tbool needgp = false;\n\tunsigned long gp_duration;\n\tunsigned long new_gp_seq;\n\tbool offloaded;\n\tstruct rcu_data *rdp;\n\tstruct rcu_node *rnp = rcu_get_root();\n\tstruct swait_queue_head *sq;\n\n\tWRITE_ONCE(rcu_state.gp_activity, jiffies);\n\traw_spin_lock_irq_rcu_node(rnp);\n\trcu_state.gp_end = jiffies;\n\tgp_duration = rcu_state.gp_end - rcu_state.gp_start;\n\tif (gp_duration > rcu_state.gp_max)\n\t\trcu_state.gp_max = gp_duration;\n\n\t/*\n\t * We know the grace period is complete, but to everyone else\n\t * it appears to still be ongoing.  But it is also the case\n\t * that to everyone else it looks like there is nothing that\n\t * they can do to advance the grace period.  It is therefore\n\t * safe for us to drop the lock in order to mark the grace\n\t * period as completed in all of the rcu_node structures.\n\t */\n\traw_spin_unlock_irq_rcu_node(rnp);\n\n\t/*\n\t * Propagate new ->gp_seq value to rcu_node structures so that\n\t * other CPUs don't have to wait until the start of the next grace\n\t * period to process their callbacks.  This also avoids some nasty\n\t * RCU grace-period initialization races by forcing the end of\n\t * the current grace period to be completely recorded in all of\n\t * the rcu_node structures before the beginning of the next grace\n\t * period is recorded in any of the rcu_node structures.\n\t */\n\tnew_gp_seq = rcu_state.gp_seq;\n\trcu_seq_end(&new_gp_seq);\n\trcu_for_each_node_breadth_first(rnp) {\n\t\traw_spin_lock_irq_rcu_node(rnp);\n\t\tif (WARN_ON_ONCE(rcu_preempt_blocked_readers_cgp(rnp)))\n\t\t\tdump_blkd_tasks(rnp, 10);\n\t\tWARN_ON_ONCE(rnp->qsmask);\n\t\tWRITE_ONCE(rnp->gp_seq, new_gp_seq);\n\t\trdp = this_cpu_ptr(&rcu_data);\n\t\tif (rnp == rdp->mynode)\n\t\t\tneedgp = __note_gp_changes(rnp, rdp) || needgp;\n\t\t/* smp_mb() provided by prior unlock-lock pair. */\n\t\tneedgp = rcu_future_gp_cleanup(rnp) || needgp;\n\t\t// Reset overload indication for CPUs no longer overloaded\n\t\tif (rcu_is_leaf_node(rnp))\n\t\t\tfor_each_leaf_node_cpu_mask(rnp, cpu, rnp->cbovldmask) {\n\t\t\t\trdp = per_cpu_ptr(&rcu_data, cpu);\n\t\t\t\tcheck_cb_ovld_locked(rdp, rnp);\n\t\t\t}\n\t\tsq = rcu_nocb_gp_get(rnp);\n\t\traw_spin_unlock_irq_rcu_node(rnp);\n\t\trcu_nocb_gp_cleanup(sq);\n\t\tcond_resched_tasks_rcu_qs();\n\t\tWRITE_ONCE(rcu_state.gp_activity, jiffies);\n\t\trcu_gp_slow(gp_cleanup_delay);\n\t}\n\trnp = rcu_get_root();\n\traw_spin_lock_irq_rcu_node(rnp); /* GP before ->gp_seq update. */\n\n\t/* Declare grace period done, trace first to use old GP number. */\n\ttrace_rcu_grace_period(rcu_state.name, rcu_state.gp_seq, TPS(\"end\"));\n\trcu_seq_end(&rcu_state.gp_seq);\n\tASSERT_EXCLUSIVE_WRITER(rcu_state.gp_seq);\n\tWRITE_ONCE(rcu_state.gp_state, RCU_GP_IDLE);\n\t/* Check for GP requests since above loop. */\n\trdp = this_cpu_ptr(&rcu_data);\n\tif (!needgp && ULONG_CMP_LT(rnp->gp_seq, rnp->gp_seq_needed)) {\n\t\ttrace_rcu_this_gp(rnp, rdp, rnp->gp_seq_needed,\n\t\t\t\t  TPS(\"CleanupMore\"));\n\t\tneedgp = true;\n\t}\n\t/* Advance CBs to reduce false positives below. */\n\toffloaded = rcu_rdp_is_offloaded(rdp);\n\tif ((offloaded || !rcu_accelerate_cbs(rnp, rdp)) && needgp) {\n\t\tWRITE_ONCE(rcu_state.gp_flags, RCU_GP_FLAG_INIT);\n\t\tWRITE_ONCE(rcu_state.gp_req_activity, jiffies);\n\t\ttrace_rcu_grace_period(rcu_state.name,\n\t\t\t\t       rcu_state.gp_seq,\n\t\t\t\t       TPS(\"newreq\"));\n\t} else {\n\t\tWRITE_ONCE(rcu_state.gp_flags,\n\t\t\t   rcu_state.gp_flags & RCU_GP_FLAG_INIT);\n\t}\n\traw_spin_unlock_irq_rcu_node(rnp);\n\n\t// If strict, make all CPUs aware of the end of the old grace period.\n\tif (IS_ENABLED(CONFIG_RCU_STRICT_GRACE_PERIOD))\n\t\ton_each_cpu(rcu_strict_gp_boundary, NULL, 0);\n}"
  },
  {
    "function_name": "rcu_gp_fqs_loop",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
    "lines": "1936-2005",
    "snippet": "static noinline_for_stack void rcu_gp_fqs_loop(void)\n{\n\tbool first_gp_fqs;\n\tint gf = 0;\n\tunsigned long j;\n\tint ret;\n\tstruct rcu_node *rnp = rcu_get_root();\n\n\tfirst_gp_fqs = true;\n\tj = READ_ONCE(jiffies_till_first_fqs);\n\tif (rcu_state.cbovld)\n\t\tgf = RCU_GP_FLAG_OVLD;\n\tret = 0;\n\tfor (;;) {\n\t\tif (!ret) {\n\t\t\tWRITE_ONCE(rcu_state.jiffies_force_qs, jiffies + j);\n\t\t\t/*\n\t\t\t * jiffies_force_qs before RCU_GP_WAIT_FQS state\n\t\t\t * update; required for stall checks.\n\t\t\t */\n\t\t\tsmp_wmb();\n\t\t\tWRITE_ONCE(rcu_state.jiffies_kick_kthreads,\n\t\t\t\t   jiffies + (j ? 3 * j : 2));\n\t\t}\n\t\ttrace_rcu_grace_period(rcu_state.name, rcu_state.gp_seq,\n\t\t\t\t       TPS(\"fqswait\"));\n\t\tWRITE_ONCE(rcu_state.gp_state, RCU_GP_WAIT_FQS);\n\t\t(void)swait_event_idle_timeout_exclusive(rcu_state.gp_wq,\n\t\t\t\t rcu_gp_fqs_check_wake(&gf), j);\n\t\trcu_gp_torture_wait();\n\t\tWRITE_ONCE(rcu_state.gp_state, RCU_GP_DOING_FQS);\n\t\t/* Locking provides needed memory barriers. */\n\t\t/* If grace period done, leave loop. */\n\t\tif (!READ_ONCE(rnp->qsmask) &&\n\t\t    !rcu_preempt_blocked_readers_cgp(rnp))\n\t\t\tbreak;\n\t\t/* If time for quiescent-state forcing, do it. */\n\t\tif (!time_after(rcu_state.jiffies_force_qs, jiffies) ||\n\t\t    (gf & (RCU_GP_FLAG_FQS | RCU_GP_FLAG_OVLD))) {\n\t\t\ttrace_rcu_grace_period(rcu_state.name, rcu_state.gp_seq,\n\t\t\t\t\t       TPS(\"fqsstart\"));\n\t\t\trcu_gp_fqs(first_gp_fqs);\n\t\t\tgf = 0;\n\t\t\tif (first_gp_fqs) {\n\t\t\t\tfirst_gp_fqs = false;\n\t\t\t\tgf = rcu_state.cbovld ? RCU_GP_FLAG_OVLD : 0;\n\t\t\t}\n\t\t\ttrace_rcu_grace_period(rcu_state.name, rcu_state.gp_seq,\n\t\t\t\t\t       TPS(\"fqsend\"));\n\t\t\tcond_resched_tasks_rcu_qs();\n\t\t\tWRITE_ONCE(rcu_state.gp_activity, jiffies);\n\t\t\tret = 0; /* Force full wait till next FQS. */\n\t\t\tj = READ_ONCE(jiffies_till_next_fqs);\n\t\t} else {\n\t\t\t/* Deal with stray signal. */\n\t\t\tcond_resched_tasks_rcu_qs();\n\t\t\tWRITE_ONCE(rcu_state.gp_activity, jiffies);\n\t\t\tWARN_ON(signal_pending(current));\n\t\t\ttrace_rcu_grace_period(rcu_state.name, rcu_state.gp_seq,\n\t\t\t\t\t       TPS(\"fqswaitsig\"));\n\t\t\tret = 1; /* Keep old FQS timing. */\n\t\t\tj = jiffies;\n\t\t\tif (time_after(jiffies, rcu_state.jiffies_force_qs))\n\t\t\t\tj = 1;\n\t\t\telse\n\t\t\t\tj = rcu_state.jiffies_force_qs - j;\n\t\t\tgf = 0;\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_nocb.h\"",
      "#include \"tree_exp.h\"",
      "#include \"tree_stall.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <linux/kasan.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/panic_notifier.h>",
      "#include <linux/panic.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};",
      "static void check_cb_ovld_locked(struct rcu_data *rdp, struct rcu_node *rnp);",
      "static ulong jiffies_till_first_fqs = IS_ENABLED(CONFIG_RCU_STRICT_GRACE_PERIOD) ? 0 : ULONG_MAX;",
      "static ulong jiffies_till_next_fqs = ULONG_MAX;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "time_after",
          "args": [
            "jiffies",
            "rcu_state.jiffies_force_qs"
          ],
          "line": 1998
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_rcu_grace_period",
          "args": [
            "rcu_state.name",
            "rcu_state.gp_seq",
            "TPS(\"fqswaitsig\")"
          ],
          "line": 1994
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPS",
          "args": [
            "\"fqswaitsig\""
          ],
          "line": 1995
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "signal_pending(current)"
          ],
          "line": 1993
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "signal_pending",
          "args": [
            "current"
          ],
          "line": 1993
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "rcu_state.gp_activity",
            "jiffies"
          ],
          "line": 1992
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cond_resched_tasks_rcu_qs",
          "args": [],
          "line": 1991
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "jiffies_till_next_fqs"
          ],
          "line": 1988
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "rcu_state.gp_activity",
            "jiffies"
          ],
          "line": 1986
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cond_resched_tasks_rcu_qs",
          "args": [],
          "line": 1985
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_rcu_grace_period",
          "args": [
            "rcu_state.name",
            "rcu_state.gp_seq",
            "TPS(\"fqsend\")"
          ],
          "line": 1983
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPS",
          "args": [
            "\"fqsend\""
          ],
          "line": 1984
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_gp_fqs",
          "args": [
            "first_gp_fqs"
          ],
          "line": 1977
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_gp_fqs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "1911-1931",
          "snippet": "static void rcu_gp_fqs(bool first_time)\n{\n\tstruct rcu_node *rnp = rcu_get_root();\n\n\tWRITE_ONCE(rcu_state.gp_activity, jiffies);\n\tWRITE_ONCE(rcu_state.n_force_qs, rcu_state.n_force_qs + 1);\n\tif (first_time) {\n\t\t/* Collect dyntick-idle snapshots. */\n\t\tforce_qs_rnp(dyntick_save_progress_counter);\n\t} else {\n\t\t/* Handle dyntick-idle and offline CPUs. */\n\t\tforce_qs_rnp(rcu_implicit_dynticks_qs);\n\t}\n\t/* Clear flag to prevent immediate re-entry. */\n\tif (READ_ONCE(rcu_state.gp_flags) & RCU_GP_FLAG_FQS) {\n\t\traw_spin_lock_irq_rcu_node(rnp);\n\t\tWRITE_ONCE(rcu_state.gp_flags,\n\t\t\t   READ_ONCE(rcu_state.gp_flags) & ~RCU_GP_FLAG_FQS);\n\t\traw_spin_unlock_irq_rcu_node(rnp);\n\t}\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};",
            "static void check_cb_ovld_locked(struct rcu_data *rdp, struct rcu_node *rnp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\nstatic void check_cb_ovld_locked(struct rcu_data *rdp, struct rcu_node *rnp);\n\nstatic void rcu_gp_fqs(bool first_time)\n{\n\tstruct rcu_node *rnp = rcu_get_root();\n\n\tWRITE_ONCE(rcu_state.gp_activity, jiffies);\n\tWRITE_ONCE(rcu_state.n_force_qs, rcu_state.n_force_qs + 1);\n\tif (first_time) {\n\t\t/* Collect dyntick-idle snapshots. */\n\t\tforce_qs_rnp(dyntick_save_progress_counter);\n\t} else {\n\t\t/* Handle dyntick-idle and offline CPUs. */\n\t\tforce_qs_rnp(rcu_implicit_dynticks_qs);\n\t}\n\t/* Clear flag to prevent immediate re-entry. */\n\tif (READ_ONCE(rcu_state.gp_flags) & RCU_GP_FLAG_FQS) {\n\t\traw_spin_lock_irq_rcu_node(rnp);\n\t\tWRITE_ONCE(rcu_state.gp_flags,\n\t\t\t   READ_ONCE(rcu_state.gp_flags) & ~RCU_GP_FLAG_FQS);\n\t\traw_spin_unlock_irq_rcu_node(rnp);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_rcu_grace_period",
          "args": [
            "rcu_state.name",
            "rcu_state.gp_seq",
            "TPS(\"fqsstart\")"
          ],
          "line": 1975
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPS",
          "args": [
            "\"fqsstart\""
          ],
          "line": 1976
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time_after",
          "args": [
            "rcu_state.jiffies_force_qs",
            "jiffies"
          ],
          "line": 1973
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_preempt_blocked_readers_cgp",
          "args": [
            "rnp"
          ],
          "line": 1970
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_preempt_blocked_readers_cgp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "907-910",
          "snippet": "static int rcu_preempt_blocked_readers_cgp(struct rcu_node *rnp)\n{\n\treturn 0;\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nstatic int rcu_preempt_blocked_readers_cgp(struct rcu_node *rnp)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rnp->qsmask"
          ],
          "line": 1969
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "rcu_state.gp_state",
            "RCU_GP_DOING_FQS"
          ],
          "line": 1966
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_gp_torture_wait",
          "args": [],
          "line": 1965
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_gp_torture_wait",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "1714-1726",
          "snippet": "static void rcu_gp_torture_wait(void)\n{\n\tunsigned long duration;\n\n\tif (!IS_ENABLED(CONFIG_RCU_TORTURE_TEST))\n\t\treturn;\n\tduration = xchg(&sleep_duration, 0UL);\n\tif (duration > 0) {\n\t\tpr_alert(\"%s: Waiting %lu jiffies\\n\", __func__, duration);\n\t\tschedule_timeout_idle(duration);\n\t\tpr_alert(\"%s: Wait complete\\n\", __func__);\n\t}\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned long sleep_duration;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic unsigned long sleep_duration;\n\nstatic void rcu_gp_torture_wait(void)\n{\n\tunsigned long duration;\n\n\tif (!IS_ENABLED(CONFIG_RCU_TORTURE_TEST))\n\t\treturn;\n\tduration = xchg(&sleep_duration, 0UL);\n\tif (duration > 0) {\n\t\tpr_alert(\"%s: Waiting %lu jiffies\\n\", __func__, duration);\n\t\tschedule_timeout_idle(duration);\n\t\tpr_alert(\"%s: Wait complete\\n\", __func__);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "swait_event_idle_timeout_exclusive",
          "args": [
            "rcu_state.gp_wq",
            "rcu_gp_fqs_check_wake(&gf)",
            "j"
          ],
          "line": 1963
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_gp_fqs_check_wake",
          "args": [
            "&gf"
          ],
          "line": 1964
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_gp_fqs_check_wake",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "1888-1906",
          "snippet": "static bool rcu_gp_fqs_check_wake(int *gfp)\n{\n\tstruct rcu_node *rnp = rcu_get_root();\n\n\t// If under overload conditions, force an immediate FQS scan.\n\tif (*gfp & RCU_GP_FLAG_OVLD)\n\t\treturn true;\n\n\t// Someone like call_rcu() requested a force-quiescent-state scan.\n\t*gfp = READ_ONCE(rcu_state.gp_flags);\n\tif (*gfp & RCU_GP_FLAG_FQS)\n\t\treturn true;\n\n\t// The current grace period has completed.\n\tif (!READ_ONCE(rnp->qsmask) && !rcu_preempt_blocked_readers_cgp(rnp))\n\t\treturn true;\n\n\treturn false;\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};",
            "static void check_cb_ovld_locked(struct rcu_data *rdp, struct rcu_node *rnp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\nstatic void check_cb_ovld_locked(struct rcu_data *rdp, struct rcu_node *rnp);\n\nstatic bool rcu_gp_fqs_check_wake(int *gfp)\n{\n\tstruct rcu_node *rnp = rcu_get_root();\n\n\t// If under overload conditions, force an immediate FQS scan.\n\tif (*gfp & RCU_GP_FLAG_OVLD)\n\t\treturn true;\n\n\t// Someone like call_rcu() requested a force-quiescent-state scan.\n\t*gfp = READ_ONCE(rcu_state.gp_flags);\n\tif (*gfp & RCU_GP_FLAG_FQS)\n\t\treturn true;\n\n\t// The current grace period has completed.\n\tif (!READ_ONCE(rnp->qsmask) && !rcu_preempt_blocked_readers_cgp(rnp))\n\t\treturn true;\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "rcu_state.gp_state",
            "RCU_GP_WAIT_FQS"
          ],
          "line": 1962
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_rcu_grace_period",
          "args": [
            "rcu_state.name",
            "rcu_state.gp_seq",
            "TPS(\"fqswait\")"
          ],
          "line": 1960
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPS",
          "args": [
            "\"fqswait\""
          ],
          "line": 1961
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "rcu_state.jiffies_kick_kthreads",
            "jiffies + (j ? 3 * j : 2)"
          ],
          "line": 1957
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_wmb",
          "args": [],
          "line": 1956
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "rcu_state.jiffies_force_qs",
            "jiffies + j"
          ],
          "line": 1951
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "jiffies_till_first_fqs"
          ],
          "line": 1945
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_get_root",
          "args": [],
          "line": 1942
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_get_root",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "579-582",
          "snippet": "static struct rcu_node *rcu_get_root(void)\n{\n\treturn &rcu_state.node[0];\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\n\nstatic struct rcu_node *rcu_get_root(void)\n{\n\treturn &rcu_state.node[0];\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\nstatic void check_cb_ovld_locked(struct rcu_data *rdp, struct rcu_node *rnp);\nstatic ulong jiffies_till_first_fqs = IS_ENABLED(CONFIG_RCU_STRICT_GRACE_PERIOD) ? 0 : ULONG_MAX;\nstatic ulong jiffies_till_next_fqs = ULONG_MAX;\n\nstatic noinline_for_stack void rcu_gp_fqs_loop(void)\n{\n\tbool first_gp_fqs;\n\tint gf = 0;\n\tunsigned long j;\n\tint ret;\n\tstruct rcu_node *rnp = rcu_get_root();\n\n\tfirst_gp_fqs = true;\n\tj = READ_ONCE(jiffies_till_first_fqs);\n\tif (rcu_state.cbovld)\n\t\tgf = RCU_GP_FLAG_OVLD;\n\tret = 0;\n\tfor (;;) {\n\t\tif (!ret) {\n\t\t\tWRITE_ONCE(rcu_state.jiffies_force_qs, jiffies + j);\n\t\t\t/*\n\t\t\t * jiffies_force_qs before RCU_GP_WAIT_FQS state\n\t\t\t * update; required for stall checks.\n\t\t\t */\n\t\t\tsmp_wmb();\n\t\t\tWRITE_ONCE(rcu_state.jiffies_kick_kthreads,\n\t\t\t\t   jiffies + (j ? 3 * j : 2));\n\t\t}\n\t\ttrace_rcu_grace_period(rcu_state.name, rcu_state.gp_seq,\n\t\t\t\t       TPS(\"fqswait\"));\n\t\tWRITE_ONCE(rcu_state.gp_state, RCU_GP_WAIT_FQS);\n\t\t(void)swait_event_idle_timeout_exclusive(rcu_state.gp_wq,\n\t\t\t\t rcu_gp_fqs_check_wake(&gf), j);\n\t\trcu_gp_torture_wait();\n\t\tWRITE_ONCE(rcu_state.gp_state, RCU_GP_DOING_FQS);\n\t\t/* Locking provides needed memory barriers. */\n\t\t/* If grace period done, leave loop. */\n\t\tif (!READ_ONCE(rnp->qsmask) &&\n\t\t    !rcu_preempt_blocked_readers_cgp(rnp))\n\t\t\tbreak;\n\t\t/* If time for quiescent-state forcing, do it. */\n\t\tif (!time_after(rcu_state.jiffies_force_qs, jiffies) ||\n\t\t    (gf & (RCU_GP_FLAG_FQS | RCU_GP_FLAG_OVLD))) {\n\t\t\ttrace_rcu_grace_period(rcu_state.name, rcu_state.gp_seq,\n\t\t\t\t\t       TPS(\"fqsstart\"));\n\t\t\trcu_gp_fqs(first_gp_fqs);\n\t\t\tgf = 0;\n\t\t\tif (first_gp_fqs) {\n\t\t\t\tfirst_gp_fqs = false;\n\t\t\t\tgf = rcu_state.cbovld ? RCU_GP_FLAG_OVLD : 0;\n\t\t\t}\n\t\t\ttrace_rcu_grace_period(rcu_state.name, rcu_state.gp_seq,\n\t\t\t\t\t       TPS(\"fqsend\"));\n\t\t\tcond_resched_tasks_rcu_qs();\n\t\t\tWRITE_ONCE(rcu_state.gp_activity, jiffies);\n\t\t\tret = 0; /* Force full wait till next FQS. */\n\t\t\tj = READ_ONCE(jiffies_till_next_fqs);\n\t\t} else {\n\t\t\t/* Deal with stray signal. */\n\t\t\tcond_resched_tasks_rcu_qs();\n\t\t\tWRITE_ONCE(rcu_state.gp_activity, jiffies);\n\t\t\tWARN_ON(signal_pending(current));\n\t\t\ttrace_rcu_grace_period(rcu_state.name, rcu_state.gp_seq,\n\t\t\t\t\t       TPS(\"fqswaitsig\"));\n\t\t\tret = 1; /* Keep old FQS timing. */\n\t\t\tj = jiffies;\n\t\t\tif (time_after(jiffies, rcu_state.jiffies_force_qs))\n\t\t\t\tj = 1;\n\t\t\telse\n\t\t\t\tj = rcu_state.jiffies_force_qs - j;\n\t\t\tgf = 0;\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "rcu_gp_fqs",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
    "lines": "1911-1931",
    "snippet": "static void rcu_gp_fqs(bool first_time)\n{\n\tstruct rcu_node *rnp = rcu_get_root();\n\n\tWRITE_ONCE(rcu_state.gp_activity, jiffies);\n\tWRITE_ONCE(rcu_state.n_force_qs, rcu_state.n_force_qs + 1);\n\tif (first_time) {\n\t\t/* Collect dyntick-idle snapshots. */\n\t\tforce_qs_rnp(dyntick_save_progress_counter);\n\t} else {\n\t\t/* Handle dyntick-idle and offline CPUs. */\n\t\tforce_qs_rnp(rcu_implicit_dynticks_qs);\n\t}\n\t/* Clear flag to prevent immediate re-entry. */\n\tif (READ_ONCE(rcu_state.gp_flags) & RCU_GP_FLAG_FQS) {\n\t\traw_spin_lock_irq_rcu_node(rnp);\n\t\tWRITE_ONCE(rcu_state.gp_flags,\n\t\t\t   READ_ONCE(rcu_state.gp_flags) & ~RCU_GP_FLAG_FQS);\n\t\traw_spin_unlock_irq_rcu_node(rnp);\n\t}\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_nocb.h\"",
      "#include \"tree_exp.h\"",
      "#include \"tree_stall.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <linux/kasan.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/panic_notifier.h>",
      "#include <linux/panic.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};",
      "static void check_cb_ovld_locked(struct rcu_data *rdp, struct rcu_node *rnp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock_irq_rcu_node",
          "args": [
            "rnp"
          ],
          "line": 1929
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "rcu_state.gp_flags",
            "READ_ONCE(rcu_state.gp_flags) & ~RCU_GP_FLAG_FQS"
          ],
          "line": 1927
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rcu_state.gp_flags"
          ],
          "line": 1928
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irq_rcu_node",
          "args": [
            "rnp"
          ],
          "line": 1926
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rcu_state.gp_flags"
          ],
          "line": 1925
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "force_qs_rnp",
          "args": [
            "rcu_implicit_dynticks_qs"
          ],
          "line": 1922
        },
        "resolved": true,
        "details": {
          "function_name": "force_qs_rnp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "2631-2675",
          "snippet": "static void force_qs_rnp(int (*f)(struct rcu_data *rdp))\n{\n\tint cpu;\n\tunsigned long flags;\n\tunsigned long mask;\n\tstruct rcu_data *rdp;\n\tstruct rcu_node *rnp;\n\n\trcu_state.cbovld = rcu_state.cbovldnext;\n\trcu_state.cbovldnext = false;\n\trcu_for_each_leaf_node(rnp) {\n\t\tcond_resched_tasks_rcu_qs();\n\t\tmask = 0;\n\t\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\t\trcu_state.cbovldnext |= !!rnp->cbovldmask;\n\t\tif (rnp->qsmask == 0) {\n\t\t\tif (rcu_preempt_blocked_readers_cgp(rnp)) {\n\t\t\t\t/*\n\t\t\t\t * No point in scanning bits because they\n\t\t\t\t * are all zero.  But we might need to\n\t\t\t\t * priority-boost blocked readers.\n\t\t\t\t */\n\t\t\t\trcu_initiate_boost(rnp, flags);\n\t\t\t\t/* rcu_initiate_boost() releases rnp->lock */\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\t\tcontinue;\n\t\t}\n\t\tfor_each_leaf_node_cpu_mask(rnp, cpu, rnp->qsmask) {\n\t\t\trdp = per_cpu_ptr(&rcu_data, cpu);\n\t\t\tif (f(rdp)) {\n\t\t\t\tmask |= rdp->grpmask;\n\t\t\t\trcu_disable_urgency_upon_qs(rdp);\n\t\t\t}\n\t\t}\n\t\tif (mask != 0) {\n\t\t\t/* Idle/offline CPUs, report (releases rnp->lock). */\n\t\t\trcu_report_qs_rnp(mask, rnp, rnp->gp_seq, flags);\n\t\t} else {\n\t\t\t/* Nothing to do here, so just drop the lock. */\n\t\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};",
            "static struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};",
            "static void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);",
            "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
            "static void sync_sched_exp_online_cleanup(int cpu);",
            "static void check_cb_ovld_locked(struct rcu_data *rdp, struct rcu_node *rnp);",
            "static bool rcu_rdp_is_offloaded(struct rcu_data *rdp);",
            "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};\nstatic struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\nstatic void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void sync_sched_exp_online_cleanup(int cpu);\nstatic void check_cb_ovld_locked(struct rcu_data *rdp, struct rcu_node *rnp);\nstatic bool rcu_rdp_is_offloaded(struct rcu_data *rdp);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp))\n{\n\tint cpu;\n\tunsigned long flags;\n\tunsigned long mask;\n\tstruct rcu_data *rdp;\n\tstruct rcu_node *rnp;\n\n\trcu_state.cbovld = rcu_state.cbovldnext;\n\trcu_state.cbovldnext = false;\n\trcu_for_each_leaf_node(rnp) {\n\t\tcond_resched_tasks_rcu_qs();\n\t\tmask = 0;\n\t\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\t\trcu_state.cbovldnext |= !!rnp->cbovldmask;\n\t\tif (rnp->qsmask == 0) {\n\t\t\tif (rcu_preempt_blocked_readers_cgp(rnp)) {\n\t\t\t\t/*\n\t\t\t\t * No point in scanning bits because they\n\t\t\t\t * are all zero.  But we might need to\n\t\t\t\t * priority-boost blocked readers.\n\t\t\t\t */\n\t\t\t\trcu_initiate_boost(rnp, flags);\n\t\t\t\t/* rcu_initiate_boost() releases rnp->lock */\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\t\tcontinue;\n\t\t}\n\t\tfor_each_leaf_node_cpu_mask(rnp, cpu, rnp->qsmask) {\n\t\t\trdp = per_cpu_ptr(&rcu_data, cpu);\n\t\t\tif (f(rdp)) {\n\t\t\t\tmask |= rdp->grpmask;\n\t\t\t\trcu_disable_urgency_upon_qs(rdp);\n\t\t\t}\n\t\t}\n\t\tif (mask != 0) {\n\t\t\t/* Idle/offline CPUs, report (releases rnp->lock). */\n\t\t\trcu_report_qs_rnp(mask, rnp, rnp->gp_seq, flags);\n\t\t} else {\n\t\t\t/* Nothing to do here, so just drop the lock. */\n\t\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "rcu_state.n_force_qs",
            "rcu_state.n_force_qs + 1"
          ],
          "line": 1916
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "rcu_state.gp_activity",
            "jiffies"
          ],
          "line": 1915
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_get_root",
          "args": [],
          "line": 1913
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_get_root",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "579-582",
          "snippet": "static struct rcu_node *rcu_get_root(void)\n{\n\treturn &rcu_state.node[0];\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\n\nstatic struct rcu_node *rcu_get_root(void)\n{\n\treturn &rcu_state.node[0];\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\nstatic void check_cb_ovld_locked(struct rcu_data *rdp, struct rcu_node *rnp);\n\nstatic void rcu_gp_fqs(bool first_time)\n{\n\tstruct rcu_node *rnp = rcu_get_root();\n\n\tWRITE_ONCE(rcu_state.gp_activity, jiffies);\n\tWRITE_ONCE(rcu_state.n_force_qs, rcu_state.n_force_qs + 1);\n\tif (first_time) {\n\t\t/* Collect dyntick-idle snapshots. */\n\t\tforce_qs_rnp(dyntick_save_progress_counter);\n\t} else {\n\t\t/* Handle dyntick-idle and offline CPUs. */\n\t\tforce_qs_rnp(rcu_implicit_dynticks_qs);\n\t}\n\t/* Clear flag to prevent immediate re-entry. */\n\tif (READ_ONCE(rcu_state.gp_flags) & RCU_GP_FLAG_FQS) {\n\t\traw_spin_lock_irq_rcu_node(rnp);\n\t\tWRITE_ONCE(rcu_state.gp_flags,\n\t\t\t   READ_ONCE(rcu_state.gp_flags) & ~RCU_GP_FLAG_FQS);\n\t\traw_spin_unlock_irq_rcu_node(rnp);\n\t}\n}"
  },
  {
    "function_name": "rcu_gp_fqs_check_wake",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
    "lines": "1888-1906",
    "snippet": "static bool rcu_gp_fqs_check_wake(int *gfp)\n{\n\tstruct rcu_node *rnp = rcu_get_root();\n\n\t// If under overload conditions, force an immediate FQS scan.\n\tif (*gfp & RCU_GP_FLAG_OVLD)\n\t\treturn true;\n\n\t// Someone like call_rcu() requested a force-quiescent-state scan.\n\t*gfp = READ_ONCE(rcu_state.gp_flags);\n\tif (*gfp & RCU_GP_FLAG_FQS)\n\t\treturn true;\n\n\t// The current grace period has completed.\n\tif (!READ_ONCE(rnp->qsmask) && !rcu_preempt_blocked_readers_cgp(rnp))\n\t\treturn true;\n\n\treturn false;\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_nocb.h\"",
      "#include \"tree_exp.h\"",
      "#include \"tree_stall.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <linux/kasan.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/panic_notifier.h>",
      "#include <linux/panic.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};",
      "static void check_cb_ovld_locked(struct rcu_data *rdp, struct rcu_node *rnp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_preempt_blocked_readers_cgp",
          "args": [
            "rnp"
          ],
          "line": 1902
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_preempt_blocked_readers_cgp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "907-910",
          "snippet": "static int rcu_preempt_blocked_readers_cgp(struct rcu_node *rnp)\n{\n\treturn 0;\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nstatic int rcu_preempt_blocked_readers_cgp(struct rcu_node *rnp)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rnp->qsmask"
          ],
          "line": 1902
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rcu_state.gp_flags"
          ],
          "line": 1897
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_get_root",
          "args": [],
          "line": 1890
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_get_root",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "579-582",
          "snippet": "static struct rcu_node *rcu_get_root(void)\n{\n\treturn &rcu_state.node[0];\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\n\nstatic struct rcu_node *rcu_get_root(void)\n{\n\treturn &rcu_state.node[0];\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\nstatic void check_cb_ovld_locked(struct rcu_data *rdp, struct rcu_node *rnp);\n\nstatic bool rcu_gp_fqs_check_wake(int *gfp)\n{\n\tstruct rcu_node *rnp = rcu_get_root();\n\n\t// If under overload conditions, force an immediate FQS scan.\n\tif (*gfp & RCU_GP_FLAG_OVLD)\n\t\treturn true;\n\n\t// Someone like call_rcu() requested a force-quiescent-state scan.\n\t*gfp = READ_ONCE(rcu_state.gp_flags);\n\tif (*gfp & RCU_GP_FLAG_FQS)\n\t\treturn true;\n\n\t// The current grace period has completed.\n\tif (!READ_ONCE(rnp->qsmask) && !rcu_preempt_blocked_readers_cgp(rnp))\n\t\treturn true;\n\n\treturn false;\n}"
  },
  {
    "function_name": "rcu_gp_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
    "lines": "1740-1882",
    "snippet": "static noinline_for_stack bool rcu_gp_init(void)\n{\n\tunsigned long firstseq;\n\tunsigned long flags;\n\tunsigned long oldmask;\n\tunsigned long mask;\n\tstruct rcu_data *rdp;\n\tstruct rcu_node *rnp = rcu_get_root();\n\n\tWRITE_ONCE(rcu_state.gp_activity, jiffies);\n\traw_spin_lock_irq_rcu_node(rnp);\n\tif (!READ_ONCE(rcu_state.gp_flags)) {\n\t\t/* Spurious wakeup, tell caller to go back to sleep.  */\n\t\traw_spin_unlock_irq_rcu_node(rnp);\n\t\treturn false;\n\t}\n\tWRITE_ONCE(rcu_state.gp_flags, 0); /* Clear all flags: New GP. */\n\n\tif (WARN_ON_ONCE(rcu_gp_in_progress())) {\n\t\t/*\n\t\t * Grace period already in progress, don't start another.\n\t\t * Not supposed to be able to happen.\n\t\t */\n\t\traw_spin_unlock_irq_rcu_node(rnp);\n\t\treturn false;\n\t}\n\n\t/* Advance to a new grace period and initialize state. */\n\trecord_gp_stall_check_time();\n\t/* Record GP times before starting GP, hence rcu_seq_start(). */\n\trcu_seq_start(&rcu_state.gp_seq);\n\tASSERT_EXCLUSIVE_WRITER(rcu_state.gp_seq);\n\ttrace_rcu_grace_period(rcu_state.name, rcu_state.gp_seq, TPS(\"start\"));\n\traw_spin_unlock_irq_rcu_node(rnp);\n\n\t/*\n\t * Apply per-leaf buffered online and offline operations to\n\t * the rcu_node tree. Note that this new grace period need not\n\t * wait for subsequent online CPUs, and that RCU hooks in the CPU\n\t * offlining path, when combined with checks in this function,\n\t * will handle CPUs that are currently going offline or that will\n\t * go offline later.  Please also refer to \"Hotplug CPU\" section\n\t * of RCU's Requirements documentation.\n\t */\n\tWRITE_ONCE(rcu_state.gp_state, RCU_GP_ONOFF);\n\trcu_for_each_leaf_node(rnp) {\n\t\t// Wait for CPU-hotplug operations that might have\n\t\t// started before this grace period did.\n\t\tsmp_mb(); // Pair with barriers used when updating ->ofl_seq to odd values.\n\t\tfirstseq = READ_ONCE(rnp->ofl_seq);\n\t\tif (firstseq & 0x1)\n\t\t\twhile (firstseq == READ_ONCE(rnp->ofl_seq))\n\t\t\t\tschedule_timeout_idle(1);  // Can't wake unless RCU is watching.\n\t\tsmp_mb(); // Pair with barriers used when updating ->ofl_seq to even values.\n\t\traw_spin_lock(&rcu_state.ofl_lock);\n\t\traw_spin_lock_irq_rcu_node(rnp);\n\t\tif (rnp->qsmaskinit == rnp->qsmaskinitnext &&\n\t\t    !rnp->wait_blkd_tasks) {\n\t\t\t/* Nothing to do on this leaf rcu_node structure. */\n\t\t\traw_spin_unlock_irq_rcu_node(rnp);\n\t\t\traw_spin_unlock(&rcu_state.ofl_lock);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Record old state, apply changes to ->qsmaskinit field. */\n\t\toldmask = rnp->qsmaskinit;\n\t\trnp->qsmaskinit = rnp->qsmaskinitnext;\n\n\t\t/* If zero-ness of ->qsmaskinit changed, propagate up tree. */\n\t\tif (!oldmask != !rnp->qsmaskinit) {\n\t\t\tif (!oldmask) { /* First online CPU for rcu_node. */\n\t\t\t\tif (!rnp->wait_blkd_tasks) /* Ever offline? */\n\t\t\t\t\trcu_init_new_rnp(rnp);\n\t\t\t} else if (rcu_preempt_has_tasks(rnp)) {\n\t\t\t\trnp->wait_blkd_tasks = true; /* blocked tasks */\n\t\t\t} else { /* Last offline CPU and can propagate. */\n\t\t\t\trcu_cleanup_dead_rnp(rnp);\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * If all waited-on tasks from prior grace period are\n\t\t * done, and if all this rcu_node structure's CPUs are\n\t\t * still offline, propagate up the rcu_node tree and\n\t\t * clear ->wait_blkd_tasks.  Otherwise, if one of this\n\t\t * rcu_node structure's CPUs has since come back online,\n\t\t * simply clear ->wait_blkd_tasks.\n\t\t */\n\t\tif (rnp->wait_blkd_tasks &&\n\t\t    (!rcu_preempt_has_tasks(rnp) || rnp->qsmaskinit)) {\n\t\t\trnp->wait_blkd_tasks = false;\n\t\t\tif (!rnp->qsmaskinit)\n\t\t\t\trcu_cleanup_dead_rnp(rnp);\n\t\t}\n\n\t\traw_spin_unlock_irq_rcu_node(rnp);\n\t\traw_spin_unlock(&rcu_state.ofl_lock);\n\t}\n\trcu_gp_slow(gp_preinit_delay); /* Races with CPU hotplug. */\n\n\t/*\n\t * Set the quiescent-state-needed bits in all the rcu_node\n\t * structures for all currently online CPUs in breadth-first\n\t * order, starting from the root rcu_node structure, relying on the\n\t * layout of the tree within the rcu_state.node[] array.  Note that\n\t * other CPUs will access only the leaves of the hierarchy, thus\n\t * seeing that no grace period is in progress, at least until the\n\t * corresponding leaf node has been initialized.\n\t *\n\t * The grace period cannot complete until the initialization\n\t * process finishes, because this kthread handles both.\n\t */\n\tWRITE_ONCE(rcu_state.gp_state, RCU_GP_INIT);\n\trcu_for_each_node_breadth_first(rnp) {\n\t\trcu_gp_slow(gp_init_delay);\n\t\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\t\trdp = this_cpu_ptr(&rcu_data);\n\t\trcu_preempt_check_blocked_tasks(rnp);\n\t\trnp->qsmask = rnp->qsmaskinit;\n\t\tWRITE_ONCE(rnp->gp_seq, rcu_state.gp_seq);\n\t\tif (rnp == rdp->mynode)\n\t\t\t(void)__note_gp_changes(rnp, rdp);\n\t\trcu_preempt_boost_start_gp(rnp);\n\t\ttrace_rcu_grace_period_init(rcu_state.name, rnp->gp_seq,\n\t\t\t\t\t    rnp->level, rnp->grplo,\n\t\t\t\t\t    rnp->grphi, rnp->qsmask);\n\t\t/* Quiescent states for tasks on any now-offline CPUs. */\n\t\tmask = rnp->qsmask & ~rnp->qsmaskinitnext;\n\t\trnp->rcu_gp_init_mask = mask;\n\t\tif ((mask || rnp->wait_blkd_tasks) && rcu_is_leaf_node(rnp))\n\t\t\trcu_report_qs_rnp(mask, rnp, rnp->gp_seq, flags);\n\t\telse\n\t\t\traw_spin_unlock_irq_rcu_node(rnp);\n\t\tcond_resched_tasks_rcu_qs();\n\t\tWRITE_ONCE(rcu_state.gp_activity, jiffies);\n\t}\n\n\t// If strict, make all CPUs aware of new grace period.\n\tif (IS_ENABLED(CONFIG_RCU_STRICT_GRACE_PERIOD))\n\t\ton_each_cpu(rcu_strict_gp_boundary, NULL, 0);\n\n\treturn true;\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_nocb.h\"",
      "#include \"tree_exp.h\"",
      "#include \"tree_stall.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <linux/kasan.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/panic_notifier.h>",
      "#include <linux/panic.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};",
      "static struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};",
      "static void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);",
      "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
      "static void check_cb_ovld_locked(struct rcu_data *rdp, struct rcu_node *rnp);",
      "static bool rcu_rdp_is_offloaded(struct rcu_data *rdp);",
      "static int gp_preinit_delay;",
      "static int gp_init_delay;",
      "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "on_each_cpu",
          "args": [
            "rcu_strict_gp_boundary",
            "NULL",
            "0"
          ],
          "line": 1879
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_RCU_STRICT_GRACE_PERIOD"
          ],
          "line": 1878
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "rcu_state.gp_activity",
            "jiffies"
          ],
          "line": 1874
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cond_resched_tasks_rcu_qs",
          "args": [],
          "line": 1873
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irq_rcu_node",
          "args": [
            "rnp"
          ],
          "line": 1872
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_report_qs_rnp",
          "args": [
            "mask",
            "rnp",
            "rnp->gp_seq",
            "flags"
          ],
          "line": 1870
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_report_qs_rnp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "2179-2234",
          "snippet": "static void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags)\n\t__releases(rnp->lock)\n{\n\tunsigned long oldmask = 0;\n\tstruct rcu_node *rnp_c;\n\n\traw_lockdep_assert_held_rcu_node(rnp);\n\n\t/* Walk up the rcu_node hierarchy. */\n\tfor (;;) {\n\t\tif ((!(rnp->qsmask & mask) && mask) || rnp->gp_seq != gps) {\n\n\t\t\t/*\n\t\t\t * Our bit has already been cleared, or the\n\t\t\t * relevant grace period is already over, so done.\n\t\t\t */\n\t\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\t\treturn;\n\t\t}\n\t\tWARN_ON_ONCE(oldmask); /* Any child must be all zeroed! */\n\t\tWARN_ON_ONCE(!rcu_is_leaf_node(rnp) &&\n\t\t\t     rcu_preempt_blocked_readers_cgp(rnp));\n\t\tWRITE_ONCE(rnp->qsmask, rnp->qsmask & ~mask);\n\t\ttrace_rcu_quiescent_state_report(rcu_state.name, rnp->gp_seq,\n\t\t\t\t\t\t mask, rnp->qsmask, rnp->level,\n\t\t\t\t\t\t rnp->grplo, rnp->grphi,\n\t\t\t\t\t\t !!rnp->gp_tasks);\n\t\tif (rnp->qsmask != 0 || rcu_preempt_blocked_readers_cgp(rnp)) {\n\n\t\t\t/* Other bits still set at this level, so done. */\n\t\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\t\treturn;\n\t\t}\n\t\trnp->completedqs = rnp->gp_seq;\n\t\tmask = rnp->grpmask;\n\t\tif (rnp->parent == NULL) {\n\n\t\t\t/* No more levels.  Exit loop holding root lock. */\n\n\t\t\tbreak;\n\t\t}\n\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\trnp_c = rnp;\n\t\trnp = rnp->parent;\n\t\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\t\toldmask = READ_ONCE(rnp_c->qsmask);\n\t}\n\n\t/*\n\t * Get here if we are the last CPU to pass through a quiescent\n\t * state for this grace period.  Invoke rcu_report_qs_rsp()\n\t * to clean up and start the next grace period if one is needed.\n\t */\n\trcu_report_qs_rsp(flags); /* releases rnp->lock. */\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};",
            "static void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);",
            "static void check_cb_ovld_locked(struct rcu_data *rdp, struct rcu_node *rnp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\nstatic void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);\nstatic void check_cb_ovld_locked(struct rcu_data *rdp, struct rcu_node *rnp);\n\nstatic void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags)\n\t__releases(rnp->lock)\n{\n\tunsigned long oldmask = 0;\n\tstruct rcu_node *rnp_c;\n\n\traw_lockdep_assert_held_rcu_node(rnp);\n\n\t/* Walk up the rcu_node hierarchy. */\n\tfor (;;) {\n\t\tif ((!(rnp->qsmask & mask) && mask) || rnp->gp_seq != gps) {\n\n\t\t\t/*\n\t\t\t * Our bit has already been cleared, or the\n\t\t\t * relevant grace period is already over, so done.\n\t\t\t */\n\t\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\t\treturn;\n\t\t}\n\t\tWARN_ON_ONCE(oldmask); /* Any child must be all zeroed! */\n\t\tWARN_ON_ONCE(!rcu_is_leaf_node(rnp) &&\n\t\t\t     rcu_preempt_blocked_readers_cgp(rnp));\n\t\tWRITE_ONCE(rnp->qsmask, rnp->qsmask & ~mask);\n\t\ttrace_rcu_quiescent_state_report(rcu_state.name, rnp->gp_seq,\n\t\t\t\t\t\t mask, rnp->qsmask, rnp->level,\n\t\t\t\t\t\t rnp->grplo, rnp->grphi,\n\t\t\t\t\t\t !!rnp->gp_tasks);\n\t\tif (rnp->qsmask != 0 || rcu_preempt_blocked_readers_cgp(rnp)) {\n\n\t\t\t/* Other bits still set at this level, so done. */\n\t\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\t\treturn;\n\t\t}\n\t\trnp->completedqs = rnp->gp_seq;\n\t\tmask = rnp->grpmask;\n\t\tif (rnp->parent == NULL) {\n\n\t\t\t/* No more levels.  Exit loop holding root lock. */\n\n\t\t\tbreak;\n\t\t}\n\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\trnp_c = rnp;\n\t\trnp = rnp->parent;\n\t\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\t\toldmask = READ_ONCE(rnp_c->qsmask);\n\t}\n\n\t/*\n\t * Get here if we are the last CPU to pass through a quiescent\n\t * state for this grace period.  Invoke rcu_report_qs_rsp()\n\t * to clean up and start the next grace period if one is needed.\n\t */\n\trcu_report_qs_rsp(flags); /* releases rnp->lock. */\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_is_leaf_node",
          "args": [
            "rnp"
          ],
          "line": 1869
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_rcu_grace_period_init",
          "args": [
            "rcu_state.name",
            "rnp->gp_seq",
            "rnp->level",
            "rnp->grplo",
            "rnp->grphi",
            "rnp->qsmask"
          ],
          "line": 1863
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_preempt_boost_start_gp",
          "args": [
            "rnp"
          ],
          "line": 1862
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_preempt_boost_start_gp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "1249-1251",
          "snippet": "static void rcu_preempt_boost_start_gp(struct rcu_node *rnp)\n{\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nstatic void rcu_preempt_boost_start_gp(struct rcu_node *rnp)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "__note_gp_changes",
          "args": [
            "rnp",
            "rdp"
          ],
          "line": 1861
        },
        "resolved": true,
        "details": {
          "function_name": "__note_gp_changes",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "1627-1672",
          "snippet": "static bool __note_gp_changes(struct rcu_node *rnp, struct rcu_data *rdp)\n{\n\tbool ret = false;\n\tbool need_qs;\n\tconst bool offloaded = rcu_rdp_is_offloaded(rdp);\n\n\traw_lockdep_assert_held_rcu_node(rnp);\n\n\tif (rdp->gp_seq == rnp->gp_seq)\n\t\treturn false; /* Nothing to do. */\n\n\t/* Handle the ends of any preceding grace periods first. */\n\tif (rcu_seq_completed_gp(rdp->gp_seq, rnp->gp_seq) ||\n\t    unlikely(READ_ONCE(rdp->gpwrap))) {\n\t\tif (!offloaded)\n\t\t\tret = rcu_advance_cbs(rnp, rdp); /* Advance CBs. */\n\t\trdp->core_needs_qs = false;\n\t\ttrace_rcu_grace_period(rcu_state.name, rdp->gp_seq, TPS(\"cpuend\"));\n\t} else {\n\t\tif (!offloaded)\n\t\t\tret = rcu_accelerate_cbs(rnp, rdp); /* Recent CBs. */\n\t\tif (rdp->core_needs_qs)\n\t\t\trdp->core_needs_qs = !!(rnp->qsmask & rdp->grpmask);\n\t}\n\n\t/* Now handle the beginnings of any new-to-this-CPU grace periods. */\n\tif (rcu_seq_new_gp(rdp->gp_seq, rnp->gp_seq) ||\n\t    unlikely(READ_ONCE(rdp->gpwrap))) {\n\t\t/*\n\t\t * If the current grace period is waiting for this CPU,\n\t\t * set up to detect a quiescent state, otherwise don't\n\t\t * go looking for one.\n\t\t */\n\t\ttrace_rcu_grace_period(rcu_state.name, rnp->gp_seq, TPS(\"cpustart\"));\n\t\tneed_qs = !!(rnp->qsmask & rdp->grpmask);\n\t\trdp->cpu_no_qs.b.norm = need_qs;\n\t\trdp->core_needs_qs = need_qs;\n\t\tzero_cpu_stall_ticks(rdp);\n\t}\n\trdp->gp_seq = rnp->gp_seq;  /* Remember new grace-period state. */\n\tif (ULONG_CMP_LT(rdp->gp_seq_needed, rnp->gp_seq_needed) || rdp->gpwrap)\n\t\tWRITE_ONCE(rdp->gp_seq_needed, rnp->gp_seq_needed);\n\tWRITE_ONCE(rdp->gpwrap, false);\n\trcu_gpnum_ovf(rnp, rdp);\n\treturn ret;\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};",
            "static struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};",
            "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
            "static void check_cb_ovld_locked(struct rcu_data *rdp, struct rcu_node *rnp);",
            "static bool rcu_rdp_is_offloaded(struct rcu_data *rdp);",
            "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};\nstatic struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void check_cb_ovld_locked(struct rcu_data *rdp, struct rcu_node *rnp);\nstatic bool rcu_rdp_is_offloaded(struct rcu_data *rdp);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nstatic bool __note_gp_changes(struct rcu_node *rnp, struct rcu_data *rdp)\n{\n\tbool ret = false;\n\tbool need_qs;\n\tconst bool offloaded = rcu_rdp_is_offloaded(rdp);\n\n\traw_lockdep_assert_held_rcu_node(rnp);\n\n\tif (rdp->gp_seq == rnp->gp_seq)\n\t\treturn false; /* Nothing to do. */\n\n\t/* Handle the ends of any preceding grace periods first. */\n\tif (rcu_seq_completed_gp(rdp->gp_seq, rnp->gp_seq) ||\n\t    unlikely(READ_ONCE(rdp->gpwrap))) {\n\t\tif (!offloaded)\n\t\t\tret = rcu_advance_cbs(rnp, rdp); /* Advance CBs. */\n\t\trdp->core_needs_qs = false;\n\t\ttrace_rcu_grace_period(rcu_state.name, rdp->gp_seq, TPS(\"cpuend\"));\n\t} else {\n\t\tif (!offloaded)\n\t\t\tret = rcu_accelerate_cbs(rnp, rdp); /* Recent CBs. */\n\t\tif (rdp->core_needs_qs)\n\t\t\trdp->core_needs_qs = !!(rnp->qsmask & rdp->grpmask);\n\t}\n\n\t/* Now handle the beginnings of any new-to-this-CPU grace periods. */\n\tif (rcu_seq_new_gp(rdp->gp_seq, rnp->gp_seq) ||\n\t    unlikely(READ_ONCE(rdp->gpwrap))) {\n\t\t/*\n\t\t * If the current grace period is waiting for this CPU,\n\t\t * set up to detect a quiescent state, otherwise don't\n\t\t * go looking for one.\n\t\t */\n\t\ttrace_rcu_grace_period(rcu_state.name, rnp->gp_seq, TPS(\"cpustart\"));\n\t\tneed_qs = !!(rnp->qsmask & rdp->grpmask);\n\t\trdp->cpu_no_qs.b.norm = need_qs;\n\t\trdp->core_needs_qs = need_qs;\n\t\tzero_cpu_stall_ticks(rdp);\n\t}\n\trdp->gp_seq = rnp->gp_seq;  /* Remember new grace-period state. */\n\tif (ULONG_CMP_LT(rdp->gp_seq_needed, rnp->gp_seq_needed) || rdp->gpwrap)\n\t\tWRITE_ONCE(rdp->gp_seq_needed, rnp->gp_seq_needed);\n\tWRITE_ONCE(rdp->gpwrap, false);\n\trcu_gpnum_ovf(rnp, rdp);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "rnp->gp_seq",
            "rcu_state.gp_seq"
          ],
          "line": 1859
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_preempt_check_blocked_tasks",
          "args": [
            "rnp"
          ],
          "line": 1857
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_preempt_check_blocked_tasks",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "946-949",
          "snippet": "static void rcu_preempt_check_blocked_tasks(struct rcu_node *rnp)\n{\n\tWARN_ON_ONCE(rnp->qsmask);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nstatic void rcu_preempt_check_blocked_tasks(struct rcu_node *rnp)\n{\n\tWARN_ON_ONCE(rnp->qsmask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&rcu_data"
          ],
          "line": 1856
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave_rcu_node",
          "args": [
            "rnp",
            "flags"
          ],
          "line": 1855
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_gp_slow",
          "args": [
            "gp_init_delay"
          ],
          "line": 1854
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_gp_slow",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "1695-1701",
          "snippet": "static void rcu_gp_slow(int delay)\n{\n\tif (delay > 0 &&\n\t    !(rcu_seq_ctr(rcu_state.gp_seq) %\n\t      (rcu_num_nodes * PER_RCU_NODE_PERIOD * delay)))\n\t\tschedule_timeout_idle(delay);\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define PER_RCU_NODE_PERIOD 3\t/* Number of grace periods between delays for debugging. */"
          ],
          "globals_used": [
            "static struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};",
            "int rcu_num_nodes"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define PER_RCU_NODE_PERIOD 3\t/* Number of grace periods between delays for debugging. */\n\nstatic struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\nint rcu_num_nodes;\n\nstatic void rcu_gp_slow(int delay)\n{\n\tif (delay > 0 &&\n\t    !(rcu_seq_ctr(rcu_state.gp_seq) %\n\t      (rcu_num_nodes * PER_RCU_NODE_PERIOD * delay)))\n\t\tschedule_timeout_idle(delay);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "rcu_state.gp_state",
            "RCU_GP_INIT"
          ],
          "line": 1852
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock",
          "args": [
            "&rcu_state.ofl_lock"
          ],
          "line": 1836
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_bh",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "208-211",
          "snippet": "void __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irq_rcu_node",
          "args": [
            "rnp"
          ],
          "line": 1835
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_cleanup_dead_rnp",
          "args": [
            "rnp"
          ],
          "line": 1832
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_cleanup_dead_rnp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "2411-2437",
          "snippet": "static void rcu_cleanup_dead_rnp(struct rcu_node *rnp_leaf)\n{\n\tlong mask;\n\tstruct rcu_node *rnp = rnp_leaf;\n\n\traw_lockdep_assert_held_rcu_node(rnp_leaf);\n\tif (!IS_ENABLED(CONFIG_HOTPLUG_CPU) ||\n\t    WARN_ON_ONCE(rnp_leaf->qsmaskinit) ||\n\t    WARN_ON_ONCE(rcu_preempt_has_tasks(rnp_leaf)))\n\t\treturn;\n\tfor (;;) {\n\t\tmask = rnp->grpmask;\n\t\trnp = rnp->parent;\n\t\tif (!rnp)\n\t\t\tbreak;\n\t\traw_spin_lock_rcu_node(rnp); /* irqs already disabled. */\n\t\trnp->qsmaskinit &= ~mask;\n\t\t/* Between grace periods, so better already be zero! */\n\t\tWARN_ON_ONCE(rnp->qsmask);\n\t\tif (rnp->qsmaskinit) {\n\t\t\traw_spin_unlock_rcu_node(rnp);\n\t\t\t/* irqs remain disabled. */\n\t\t\treturn;\n\t\t}\n\t\traw_spin_unlock_rcu_node(rnp); /* irqs remain disabled. */\n\t}\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void rcu_init_new_rnp(struct rcu_node *rnp_leaf);",
            "static void rcu_cleanup_dead_rnp(struct rcu_node *rnp_leaf);",
            "static void check_cb_ovld_locked(struct rcu_data *rdp, struct rcu_node *rnp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic void rcu_init_new_rnp(struct rcu_node *rnp_leaf);\nstatic void rcu_cleanup_dead_rnp(struct rcu_node *rnp_leaf);\nstatic void check_cb_ovld_locked(struct rcu_data *rdp, struct rcu_node *rnp);\n\nstatic void rcu_cleanup_dead_rnp(struct rcu_node *rnp_leaf)\n{\n\tlong mask;\n\tstruct rcu_node *rnp = rnp_leaf;\n\n\traw_lockdep_assert_held_rcu_node(rnp_leaf);\n\tif (!IS_ENABLED(CONFIG_HOTPLUG_CPU) ||\n\t    WARN_ON_ONCE(rnp_leaf->qsmaskinit) ||\n\t    WARN_ON_ONCE(rcu_preempt_has_tasks(rnp_leaf)))\n\t\treturn;\n\tfor (;;) {\n\t\tmask = rnp->grpmask;\n\t\trnp = rnp->parent;\n\t\tif (!rnp)\n\t\t\tbreak;\n\t\traw_spin_lock_rcu_node(rnp); /* irqs already disabled. */\n\t\trnp->qsmaskinit &= ~mask;\n\t\t/* Between grace periods, so better already be zero! */\n\t\tWARN_ON_ONCE(rnp->qsmask);\n\t\tif (rnp->qsmaskinit) {\n\t\t\traw_spin_unlock_rcu_node(rnp);\n\t\t\t/* irqs remain disabled. */\n\t\t\treturn;\n\t\t}\n\t\traw_spin_unlock_rcu_node(rnp); /* irqs remain disabled. */\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_preempt_has_tasks",
          "args": [
            "rnp"
          ],
          "line": 1829
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_preempt_has_tasks",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "915-918",
          "snippet": "static bool rcu_preempt_has_tasks(struct rcu_node *rnp)\n{\n\treturn false;\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nstatic bool rcu_preempt_has_tasks(struct rcu_node *rnp)\n{\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_init_new_rnp",
          "args": [
            "rnp"
          ],
          "line": 1812
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_init_new_rnp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "4108-4128",
          "snippet": "static void rcu_init_new_rnp(struct rcu_node *rnp_leaf)\n{\n\tlong mask;\n\tlong oldmask;\n\tstruct rcu_node *rnp = rnp_leaf;\n\n\traw_lockdep_assert_held_rcu_node(rnp_leaf);\n\tWARN_ON_ONCE(rnp->wait_blkd_tasks);\n\tfor (;;) {\n\t\tmask = rnp->grpmask;\n\t\trnp = rnp->parent;\n\t\tif (rnp == NULL)\n\t\t\treturn;\n\t\traw_spin_lock_rcu_node(rnp); /* Interrupts already disabled. */\n\t\toldmask = rnp->qsmaskinit;\n\t\trnp->qsmaskinit |= mask;\n\t\traw_spin_unlock_rcu_node(rnp); /* Interrupts remain disabled. */\n\t\tif (oldmask)\n\t\t\treturn;\n\t}\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void rcu_init_new_rnp(struct rcu_node *rnp_leaf);",
            "static void rcu_cleanup_dead_rnp(struct rcu_node *rnp_leaf);",
            "static void check_cb_ovld_locked(struct rcu_data *rdp, struct rcu_node *rnp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic void rcu_init_new_rnp(struct rcu_node *rnp_leaf);\nstatic void rcu_cleanup_dead_rnp(struct rcu_node *rnp_leaf);\nstatic void check_cb_ovld_locked(struct rcu_data *rdp, struct rcu_node *rnp);\n\nstatic void rcu_init_new_rnp(struct rcu_node *rnp_leaf)\n{\n\tlong mask;\n\tlong oldmask;\n\tstruct rcu_node *rnp = rnp_leaf;\n\n\traw_lockdep_assert_held_rcu_node(rnp_leaf);\n\tWARN_ON_ONCE(rnp->wait_blkd_tasks);\n\tfor (;;) {\n\t\tmask = rnp->grpmask;\n\t\trnp = rnp->parent;\n\t\tif (rnp == NULL)\n\t\t\treturn;\n\t\traw_spin_lock_rcu_node(rnp); /* Interrupts already disabled. */\n\t\toldmask = rnp->qsmaskinit;\n\t\trnp->qsmaskinit |= mask;\n\t\traw_spin_unlock_rcu_node(rnp); /* Interrupts remain disabled. */\n\t\tif (oldmask)\n\t\t\treturn;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irq_rcu_node",
          "args": [
            "rnp"
          ],
          "line": 1799
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irq_rcu_node",
          "args": [
            "rnp"
          ],
          "line": 1795
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock",
          "args": [
            "&rcu_state.ofl_lock"
          ],
          "line": 1794
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_bh",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "176-179",
          "snippet": "void __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_mb",
          "args": [],
          "line": 1793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schedule_timeout_idle",
          "args": [
            "1"
          ],
          "line": 1792
        },
        "resolved": true,
        "details": {
          "function_name": "schedule_timeout_idle",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timer.c",
          "lines": "1923-1927",
          "snippet": "signed long __sched schedule_timeout_idle(signed long timeout)\n{\n\t__set_current_state(TASK_IDLE);\n\treturn schedule_timeout(timeout);\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/random.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/random.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nsigned long __sched schedule_timeout_idle(signed long timeout)\n{\n\t__set_current_state(TASK_IDLE);\n\treturn schedule_timeout(timeout);\n}"
        }
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rnp->ofl_seq"
          ],
          "line": 1791
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rnp->ofl_seq"
          ],
          "line": 1789
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_mb",
          "args": [],
          "line": 1788
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "rcu_state.gp_state",
            "RCU_GP_ONOFF"
          ],
          "line": 1784
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irq_rcu_node",
          "args": [
            "rnp"
          ],
          "line": 1773
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_rcu_grace_period",
          "args": [
            "rcu_state.name",
            "rcu_state.gp_seq",
            "TPS(\"start\")"
          ],
          "line": 1772
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPS",
          "args": [
            "\"start\""
          ],
          "line": 1772
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_EXCLUSIVE_WRITER",
          "args": [
            "rcu_state.gp_seq"
          ],
          "line": 1771
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_seq_start",
          "args": [
            "&rcu_state.gp_seq"
          ],
          "line": 1770
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_seq_start",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu.h",
          "lines": "55-60",
          "snippet": "static inline void rcu_seq_start(unsigned long *sp)\n{\n\tWRITE_ONCE(*sp, *sp + 1);\n\tsmp_mb(); /* Ensure update-side operation after counter increment. */\n\tWARN_ON_ONCE(rcu_seq_state(*sp) != 1);\n}",
          "includes": [
            "#include <linux/rcu_node_tree.h>",
            "#include <trace/events/rcu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_node_tree.h>\n#include <trace/events/rcu.h>\n\nstatic inline void rcu_seq_start(unsigned long *sp)\n{\n\tWRITE_ONCE(*sp, *sp + 1);\n\tsmp_mb(); /* Ensure update-side operation after counter increment. */\n\tWARN_ON_ONCE(rcu_seq_state(*sp) != 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "record_gp_stall_check_time",
          "args": [],
          "line": 1768
        },
        "resolved": true,
        "details": {
          "function_name": "record_gp_stall_check_time",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_stall.h",
          "lines": "137-148",
          "snippet": "static void record_gp_stall_check_time(void)\n{\n\tunsigned long j = jiffies;\n\tunsigned long j1;\n\n\tWRITE_ONCE(rcu_state.gp_start, j);\n\tj1 = rcu_jiffies_till_stall_check();\n\tsmp_mb(); // ->gp_start before ->jiffies_stall and caller's ->gp_seq.\n\tWRITE_ONCE(rcu_state.jiffies_stall, j + j1);\n\trcu_state.jiffies_resched = j + j1 / 2;\n\trcu_state.n_force_qs_gpstart = READ_ONCE(rcu_state.n_force_qs);\n}",
          "includes": [
            "#include <linux/kvm_para.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_para.h>\n\nstatic void record_gp_stall_check_time(void)\n{\n\tunsigned long j = jiffies;\n\tunsigned long j1;\n\n\tWRITE_ONCE(rcu_state.gp_start, j);\n\tj1 = rcu_jiffies_till_stall_check();\n\tsmp_mb(); // ->gp_start before ->jiffies_stall and caller's ->gp_seq.\n\tWRITE_ONCE(rcu_state.jiffies_stall, j + j1);\n\trcu_state.jiffies_resched = j + j1 / 2;\n\trcu_state.n_force_qs_gpstart = READ_ONCE(rcu_state.n_force_qs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irq_rcu_node",
          "args": [
            "rnp"
          ],
          "line": 1763
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "rcu_gp_in_progress()"
          ],
          "line": 1758
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_gp_in_progress",
          "args": [],
          "line": 1758
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_gp_in_progress",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "229-232",
          "snippet": "static int rcu_gp_in_progress(void)\n{\n\treturn rcu_seq_state(rcu_seq_current(&rcu_state.gp_seq));\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\n\nstatic int rcu_gp_in_progress(void)\n{\n\treturn rcu_seq_state(rcu_seq_current(&rcu_state.gp_seq));\n}"
        }
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "rcu_state.gp_flags",
            "0"
          ],
          "line": 1756
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irq_rcu_node",
          "args": [
            "rnp"
          ],
          "line": 1753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rcu_state.gp_flags"
          ],
          "line": 1751
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irq_rcu_node",
          "args": [
            "rnp"
          ],
          "line": 1750
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "rcu_state.gp_activity",
            "jiffies"
          ],
          "line": 1749
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_get_root",
          "args": [],
          "line": 1747
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_get_root",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "579-582",
          "snippet": "static struct rcu_node *rcu_get_root(void)\n{\n\treturn &rcu_state.node[0];\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\n\nstatic struct rcu_node *rcu_get_root(void)\n{\n\treturn &rcu_state.node[0];\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};\nstatic struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\nstatic void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void check_cb_ovld_locked(struct rcu_data *rdp, struct rcu_node *rnp);\nstatic bool rcu_rdp_is_offloaded(struct rcu_data *rdp);\nstatic int gp_preinit_delay;\nstatic int gp_init_delay;\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nstatic noinline_for_stack bool rcu_gp_init(void)\n{\n\tunsigned long firstseq;\n\tunsigned long flags;\n\tunsigned long oldmask;\n\tunsigned long mask;\n\tstruct rcu_data *rdp;\n\tstruct rcu_node *rnp = rcu_get_root();\n\n\tWRITE_ONCE(rcu_state.gp_activity, jiffies);\n\traw_spin_lock_irq_rcu_node(rnp);\n\tif (!READ_ONCE(rcu_state.gp_flags)) {\n\t\t/* Spurious wakeup, tell caller to go back to sleep.  */\n\t\traw_spin_unlock_irq_rcu_node(rnp);\n\t\treturn false;\n\t}\n\tWRITE_ONCE(rcu_state.gp_flags, 0); /* Clear all flags: New GP. */\n\n\tif (WARN_ON_ONCE(rcu_gp_in_progress())) {\n\t\t/*\n\t\t * Grace period already in progress, don't start another.\n\t\t * Not supposed to be able to happen.\n\t\t */\n\t\traw_spin_unlock_irq_rcu_node(rnp);\n\t\treturn false;\n\t}\n\n\t/* Advance to a new grace period and initialize state. */\n\trecord_gp_stall_check_time();\n\t/* Record GP times before starting GP, hence rcu_seq_start(). */\n\trcu_seq_start(&rcu_state.gp_seq);\n\tASSERT_EXCLUSIVE_WRITER(rcu_state.gp_seq);\n\ttrace_rcu_grace_period(rcu_state.name, rcu_state.gp_seq, TPS(\"start\"));\n\traw_spin_unlock_irq_rcu_node(rnp);\n\n\t/*\n\t * Apply per-leaf buffered online and offline operations to\n\t * the rcu_node tree. Note that this new grace period need not\n\t * wait for subsequent online CPUs, and that RCU hooks in the CPU\n\t * offlining path, when combined with checks in this function,\n\t * will handle CPUs that are currently going offline or that will\n\t * go offline later.  Please also refer to \"Hotplug CPU\" section\n\t * of RCU's Requirements documentation.\n\t */\n\tWRITE_ONCE(rcu_state.gp_state, RCU_GP_ONOFF);\n\trcu_for_each_leaf_node(rnp) {\n\t\t// Wait for CPU-hotplug operations that might have\n\t\t// started before this grace period did.\n\t\tsmp_mb(); // Pair with barriers used when updating ->ofl_seq to odd values.\n\t\tfirstseq = READ_ONCE(rnp->ofl_seq);\n\t\tif (firstseq & 0x1)\n\t\t\twhile (firstseq == READ_ONCE(rnp->ofl_seq))\n\t\t\t\tschedule_timeout_idle(1);  // Can't wake unless RCU is watching.\n\t\tsmp_mb(); // Pair with barriers used when updating ->ofl_seq to even values.\n\t\traw_spin_lock(&rcu_state.ofl_lock);\n\t\traw_spin_lock_irq_rcu_node(rnp);\n\t\tif (rnp->qsmaskinit == rnp->qsmaskinitnext &&\n\t\t    !rnp->wait_blkd_tasks) {\n\t\t\t/* Nothing to do on this leaf rcu_node structure. */\n\t\t\traw_spin_unlock_irq_rcu_node(rnp);\n\t\t\traw_spin_unlock(&rcu_state.ofl_lock);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Record old state, apply changes to ->qsmaskinit field. */\n\t\toldmask = rnp->qsmaskinit;\n\t\trnp->qsmaskinit = rnp->qsmaskinitnext;\n\n\t\t/* If zero-ness of ->qsmaskinit changed, propagate up tree. */\n\t\tif (!oldmask != !rnp->qsmaskinit) {\n\t\t\tif (!oldmask) { /* First online CPU for rcu_node. */\n\t\t\t\tif (!rnp->wait_blkd_tasks) /* Ever offline? */\n\t\t\t\t\trcu_init_new_rnp(rnp);\n\t\t\t} else if (rcu_preempt_has_tasks(rnp)) {\n\t\t\t\trnp->wait_blkd_tasks = true; /* blocked tasks */\n\t\t\t} else { /* Last offline CPU and can propagate. */\n\t\t\t\trcu_cleanup_dead_rnp(rnp);\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * If all waited-on tasks from prior grace period are\n\t\t * done, and if all this rcu_node structure's CPUs are\n\t\t * still offline, propagate up the rcu_node tree and\n\t\t * clear ->wait_blkd_tasks.  Otherwise, if one of this\n\t\t * rcu_node structure's CPUs has since come back online,\n\t\t * simply clear ->wait_blkd_tasks.\n\t\t */\n\t\tif (rnp->wait_blkd_tasks &&\n\t\t    (!rcu_preempt_has_tasks(rnp) || rnp->qsmaskinit)) {\n\t\t\trnp->wait_blkd_tasks = false;\n\t\t\tif (!rnp->qsmaskinit)\n\t\t\t\trcu_cleanup_dead_rnp(rnp);\n\t\t}\n\n\t\traw_spin_unlock_irq_rcu_node(rnp);\n\t\traw_spin_unlock(&rcu_state.ofl_lock);\n\t}\n\trcu_gp_slow(gp_preinit_delay); /* Races with CPU hotplug. */\n\n\t/*\n\t * Set the quiescent-state-needed bits in all the rcu_node\n\t * structures for all currently online CPUs in breadth-first\n\t * order, starting from the root rcu_node structure, relying on the\n\t * layout of the tree within the rcu_state.node[] array.  Note that\n\t * other CPUs will access only the leaves of the hierarchy, thus\n\t * seeing that no grace period is in progress, at least until the\n\t * corresponding leaf node has been initialized.\n\t *\n\t * The grace period cannot complete until the initialization\n\t * process finishes, because this kthread handles both.\n\t */\n\tWRITE_ONCE(rcu_state.gp_state, RCU_GP_INIT);\n\trcu_for_each_node_breadth_first(rnp) {\n\t\trcu_gp_slow(gp_init_delay);\n\t\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\t\trdp = this_cpu_ptr(&rcu_data);\n\t\trcu_preempt_check_blocked_tasks(rnp);\n\t\trnp->qsmask = rnp->qsmaskinit;\n\t\tWRITE_ONCE(rnp->gp_seq, rcu_state.gp_seq);\n\t\tif (rnp == rdp->mynode)\n\t\t\t(void)__note_gp_changes(rnp, rdp);\n\t\trcu_preempt_boost_start_gp(rnp);\n\t\ttrace_rcu_grace_period_init(rcu_state.name, rnp->gp_seq,\n\t\t\t\t\t    rnp->level, rnp->grplo,\n\t\t\t\t\t    rnp->grphi, rnp->qsmask);\n\t\t/* Quiescent states for tasks on any now-offline CPUs. */\n\t\tmask = rnp->qsmask & ~rnp->qsmaskinitnext;\n\t\trnp->rcu_gp_init_mask = mask;\n\t\tif ((mask || rnp->wait_blkd_tasks) && rcu_is_leaf_node(rnp))\n\t\t\trcu_report_qs_rnp(mask, rnp, rnp->gp_seq, flags);\n\t\telse\n\t\t\traw_spin_unlock_irq_rcu_node(rnp);\n\t\tcond_resched_tasks_rcu_qs();\n\t\tWRITE_ONCE(rcu_state.gp_activity, jiffies);\n\t}\n\n\t// If strict, make all CPUs aware of new grace period.\n\tif (IS_ENABLED(CONFIG_RCU_STRICT_GRACE_PERIOD))\n\t\ton_each_cpu(rcu_strict_gp_boundary, NULL, 0);\n\n\treturn true;\n}"
  },
  {
    "function_name": "rcu_strict_gp_boundary",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
    "lines": "1732-1735",
    "snippet": "static void rcu_strict_gp_boundary(void *unused)\n{\n\tinvoke_rcu_core();\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_nocb.h\"",
      "#include \"tree_exp.h\"",
      "#include \"tree_stall.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <linux/kasan.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/panic_notifier.h>",
      "#include <linux/panic.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void invoke_rcu_core(void);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "invoke_rcu_core",
          "args": [],
          "line": 1734
        },
        "resolved": true,
        "details": {
          "function_name": "invoke_rcu_core",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "2824-2832",
          "snippet": "static void invoke_rcu_core(void)\n{\n\tif (!cpu_online(smp_processor_id()))\n\t\treturn;\n\tif (use_softirq)\n\t\traise_softirq(RCU_SOFTIRQ);\n\telse\n\t\tinvoke_rcu_core_kthread();\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool use_softirq = !IS_ENABLED(CONFIG_PREEMPT_RT);",
            "static void invoke_rcu_core(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic bool use_softirq = !IS_ENABLED(CONFIG_PREEMPT_RT);\nstatic void invoke_rcu_core(void);\n\nstatic void invoke_rcu_core(void)\n{\n\tif (!cpu_online(smp_processor_id()))\n\t\treturn;\n\tif (use_softirq)\n\t\traise_softirq(RCU_SOFTIRQ);\n\telse\n\t\tinvoke_rcu_core_kthread();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic void invoke_rcu_core(void);\n\nstatic void rcu_strict_gp_boundary(void *unused)\n{\n\tinvoke_rcu_core();\n}"
  },
  {
    "function_name": "rcu_gp_torture_wait",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
    "lines": "1714-1726",
    "snippet": "static void rcu_gp_torture_wait(void)\n{\n\tunsigned long duration;\n\n\tif (!IS_ENABLED(CONFIG_RCU_TORTURE_TEST))\n\t\treturn;\n\tduration = xchg(&sleep_duration, 0UL);\n\tif (duration > 0) {\n\t\tpr_alert(\"%s: Waiting %lu jiffies\\n\", __func__, duration);\n\t\tschedule_timeout_idle(duration);\n\t\tpr_alert(\"%s: Wait complete\\n\", __func__);\n\t}\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_nocb.h\"",
      "#include \"tree_exp.h\"",
      "#include \"tree_stall.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <linux/kasan.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/panic_notifier.h>",
      "#include <linux/panic.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned long sleep_duration;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_alert",
          "args": [
            "\"%s: Wait complete\\n\"",
            "__func__"
          ],
          "line": 1724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schedule_timeout_idle",
          "args": [
            "duration"
          ],
          "line": 1723
        },
        "resolved": true,
        "details": {
          "function_name": "schedule_timeout_idle",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timer.c",
          "lines": "1923-1927",
          "snippet": "signed long __sched schedule_timeout_idle(signed long timeout)\n{\n\t__set_current_state(TASK_IDLE);\n\treturn schedule_timeout(timeout);\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/random.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/random.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nsigned long __sched schedule_timeout_idle(signed long timeout)\n{\n\t__set_current_state(TASK_IDLE);\n\treturn schedule_timeout(timeout);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_alert",
          "args": [
            "\"%s: Waiting %lu jiffies\\n\"",
            "__func__",
            "duration"
          ],
          "line": 1722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xchg",
          "args": [
            "&sleep_duration",
            "0UL"
          ],
          "line": 1720
        },
        "resolved": true,
        "details": {
          "function_name": "xchg_tail",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/qspinlock.c",
          "lines": "220-238",
          "snippet": "static __always_inline u32 xchg_tail(struct qspinlock *lock, u32 tail)\n{\n\tu32 old, new, val = atomic_read(&lock->val);\n\n\tfor (;;) {\n\t\tnew = (val & _Q_LOCKED_PENDING_MASK) | tail;\n\t\t/*\n\t\t * We can use relaxed semantics since the caller ensures that\n\t\t * the MCS node is properly initialized before updating the\n\t\t * tail.\n\t\t */\n\t\told = atomic_cmpxchg_relaxed(&lock->val, val, new);\n\t\tif (old == val)\n\t\t\tbreak;\n\n\t\tval = old;\n\t}\n\treturn old;\n}",
          "includes": [
            "#include \"qspinlock.c\"",
            "#include \"qspinlock_paravirt.h\"",
            "#include \"mcs_spinlock.h\"",
            "#include \"qspinlock_stat.h\"",
            "#include <asm/qspinlock.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/percpu.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/bug.h>",
            "#include <linux/smp.h>"
          ],
          "macros_used": [
            "#define _Q_LOCKED_PENDING_MASK (_Q_LOCKED_MASK | _Q_PENDING_MASK)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qspinlock.c\"\n#include \"qspinlock_paravirt.h\"\n#include \"mcs_spinlock.h\"\n#include \"qspinlock_stat.h\"\n#include <asm/qspinlock.h>\n#include <asm/byteorder.h>\n#include <linux/prefetch.h>\n#include <linux/mutex.h>\n#include <linux/hardirq.h>\n#include <linux/percpu.h>\n#include <linux/cpumask.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n\n#define _Q_LOCKED_PENDING_MASK (_Q_LOCKED_MASK | _Q_PENDING_MASK)\n\nstatic __always_inline u32 xchg_tail(struct qspinlock *lock, u32 tail)\n{\n\tu32 old, new, val = atomic_read(&lock->val);\n\n\tfor (;;) {\n\t\tnew = (val & _Q_LOCKED_PENDING_MASK) | tail;\n\t\t/*\n\t\t * We can use relaxed semantics since the caller ensures that\n\t\t * the MCS node is properly initialized before updating the\n\t\t * tail.\n\t\t */\n\t\told = atomic_cmpxchg_relaxed(&lock->val, val, new);\n\t\tif (old == val)\n\t\t\tbreak;\n\n\t\tval = old;\n\t}\n\treturn old;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_RCU_TORTURE_TEST"
          ],
          "line": 1718
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic unsigned long sleep_duration;\n\nstatic void rcu_gp_torture_wait(void)\n{\n\tunsigned long duration;\n\n\tif (!IS_ENABLED(CONFIG_RCU_TORTURE_TEST))\n\t\treturn;\n\tduration = xchg(&sleep_duration, 0UL);\n\tif (duration > 0) {\n\t\tpr_alert(\"%s: Waiting %lu jiffies\\n\", __func__, duration);\n\t\tschedule_timeout_idle(duration);\n\t\tpr_alert(\"%s: Wait complete\\n\", __func__);\n\t}\n}"
  },
  {
    "function_name": "rcu_gp_set_torture_wait",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
    "lines": "1706-1710",
    "snippet": "void rcu_gp_set_torture_wait(int duration)\n{\n\tif (IS_ENABLED(CONFIG_RCU_TORTURE_TEST) && duration > 0)\n\t\tWRITE_ONCE(sleep_duration, duration);\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_nocb.h\"",
      "#include \"tree_exp.h\"",
      "#include \"tree_stall.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <linux/kasan.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/panic_notifier.h>",
      "#include <linux/panic.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned long sleep_duration;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "sleep_duration",
            "duration"
          ],
          "line": 1709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_RCU_TORTURE_TEST"
          ],
          "line": 1708
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic unsigned long sleep_duration;\n\nvoid rcu_gp_set_torture_wait(int duration)\n{\n\tif (IS_ENABLED(CONFIG_RCU_TORTURE_TEST) && duration > 0)\n\t\tWRITE_ONCE(sleep_duration, duration);\n}"
  },
  {
    "function_name": "rcu_gp_slow",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
    "lines": "1695-1701",
    "snippet": "static void rcu_gp_slow(int delay)\n{\n\tif (delay > 0 &&\n\t    !(rcu_seq_ctr(rcu_state.gp_seq) %\n\t      (rcu_num_nodes * PER_RCU_NODE_PERIOD * delay)))\n\t\tschedule_timeout_idle(delay);\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_nocb.h\"",
      "#include \"tree_exp.h\"",
      "#include \"tree_stall.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <linux/kasan.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/panic_notifier.h>",
      "#include <linux/panic.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [
      "#define PER_RCU_NODE_PERIOD 3\t/* Number of grace periods between delays for debugging. */"
    ],
    "globals_used": [
      "static struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};",
      "int rcu_num_nodes"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "schedule_timeout_idle",
          "args": [
            "delay"
          ],
          "line": 1700
        },
        "resolved": true,
        "details": {
          "function_name": "schedule_timeout_idle",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timer.c",
          "lines": "1923-1927",
          "snippet": "signed long __sched schedule_timeout_idle(signed long timeout)\n{\n\t__set_current_state(TASK_IDLE);\n\treturn schedule_timeout(timeout);\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/random.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/random.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nsigned long __sched schedule_timeout_idle(signed long timeout)\n{\n\t__set_current_state(TASK_IDLE);\n\treturn schedule_timeout(timeout);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_seq_ctr",
          "args": [
            "rcu_state.gp_seq"
          ],
          "line": 1698
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_seq_ctr",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu.h",
          "lines": "30-33",
          "snippet": "static inline unsigned long rcu_seq_ctr(unsigned long s)\n{\n\treturn s >> RCU_SEQ_CTR_SHIFT;\n}",
          "includes": [
            "#include <linux/rcu_node_tree.h>",
            "#include <trace/events/rcu.h>"
          ],
          "macros_used": [
            "#define RCU_SEQ_CTR_SHIFT\t2"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_node_tree.h>\n#include <trace/events/rcu.h>\n\n#define RCU_SEQ_CTR_SHIFT\t2\n\nstatic inline unsigned long rcu_seq_ctr(unsigned long s)\n{\n\treturn s >> RCU_SEQ_CTR_SHIFT;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define PER_RCU_NODE_PERIOD 3\t/* Number of grace periods between delays for debugging. */\n\nstatic struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\nint rcu_num_nodes;\n\nstatic void rcu_gp_slow(int delay)\n{\n\tif (delay > 0 &&\n\t    !(rcu_seq_ctr(rcu_state.gp_seq) %\n\t      (rcu_num_nodes * PER_RCU_NODE_PERIOD * delay)))\n\t\tschedule_timeout_idle(delay);\n}"
  },
  {
    "function_name": "note_gp_changes",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
    "lines": "1674-1693",
    "snippet": "static void note_gp_changes(struct rcu_data *rdp)\n{\n\tunsigned long flags;\n\tbool needwake;\n\tstruct rcu_node *rnp;\n\n\tlocal_irq_save(flags);\n\trnp = rdp->mynode;\n\tif ((rdp->gp_seq == rcu_seq_current(&rnp->gp_seq) &&\n\t     !unlikely(READ_ONCE(rdp->gpwrap))) || /* w/out lock. */\n\t    !raw_spin_trylock_rcu_node(rnp)) { /* irqs already off, so later. */\n\t\tlocal_irq_restore(flags);\n\t\treturn;\n\t}\n\tneedwake = __note_gp_changes(rnp, rdp);\n\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\trcu_strict_gp_check_qs();\n\tif (needwake)\n\t\trcu_gp_kthread_wake();\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_nocb.h\"",
      "#include \"tree_exp.h\"",
      "#include \"tree_stall.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <linux/kasan.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/panic_notifier.h>",
      "#include <linux/panic.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};",
      "static void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);",
      "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
      "static void check_cb_ovld_locked(struct rcu_data *rdp, struct rcu_node *rnp);",
      "static bool rcu_rdp_is_offloaded(struct rcu_data *rdp);",
      "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_gp_kthread_wake",
          "args": [],
          "line": 1692
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_gp_kthread_wake",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "1473-1483",
          "snippet": "static void rcu_gp_kthread_wake(void)\n{\n\tstruct task_struct *t = READ_ONCE(rcu_state.gp_kthread);\n\n\tif ((current == t && !in_hardirq() && !in_serving_softirq()) ||\n\t    !READ_ONCE(rcu_state.gp_flags) || !t)\n\t\treturn;\n\tWRITE_ONCE(rcu_state.gp_wake_time, jiffies);\n\tWRITE_ONCE(rcu_state.gp_wake_seq, READ_ONCE(rcu_state.gp_seq));\n\tswake_up_one(&rcu_state.gp_wq);\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\n\nstatic void rcu_gp_kthread_wake(void)\n{\n\tstruct task_struct *t = READ_ONCE(rcu_state.gp_kthread);\n\n\tif ((current == t && !in_hardirq() && !in_serving_softirq()) ||\n\t    !READ_ONCE(rcu_state.gp_flags) || !t)\n\t\treturn;\n\tWRITE_ONCE(rcu_state.gp_wake_time, jiffies);\n\tWRITE_ONCE(rcu_state.gp_wake_seq, READ_ONCE(rcu_state.gp_seq));\n\tswake_up_one(&rcu_state.gp_wq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_strict_gp_check_qs",
          "args": [],
          "line": 1690
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_strict_gp_check_qs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "1613-1619",
          "snippet": "static void rcu_strict_gp_check_qs(void)\n{\n\tif (IS_ENABLED(CONFIG_RCU_STRICT_GRACE_PERIOD)) {\n\t\trcu_read_lock();\n\t\trcu_read_unlock();\n\t}\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic void rcu_strict_gp_check_qs(void)\n{\n\tif (IS_ENABLED(CONFIG_RCU_STRICT_GRACE_PERIOD)) {\n\t\trcu_read_lock();\n\t\trcu_read_unlock();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore_rcu_node",
          "args": [
            "rnp",
            "flags"
          ],
          "line": 1689
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__note_gp_changes",
          "args": [
            "rnp",
            "rdp"
          ],
          "line": 1688
        },
        "resolved": true,
        "details": {
          "function_name": "__note_gp_changes",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "1627-1672",
          "snippet": "static bool __note_gp_changes(struct rcu_node *rnp, struct rcu_data *rdp)\n{\n\tbool ret = false;\n\tbool need_qs;\n\tconst bool offloaded = rcu_rdp_is_offloaded(rdp);\n\n\traw_lockdep_assert_held_rcu_node(rnp);\n\n\tif (rdp->gp_seq == rnp->gp_seq)\n\t\treturn false; /* Nothing to do. */\n\n\t/* Handle the ends of any preceding grace periods first. */\n\tif (rcu_seq_completed_gp(rdp->gp_seq, rnp->gp_seq) ||\n\t    unlikely(READ_ONCE(rdp->gpwrap))) {\n\t\tif (!offloaded)\n\t\t\tret = rcu_advance_cbs(rnp, rdp); /* Advance CBs. */\n\t\trdp->core_needs_qs = false;\n\t\ttrace_rcu_grace_period(rcu_state.name, rdp->gp_seq, TPS(\"cpuend\"));\n\t} else {\n\t\tif (!offloaded)\n\t\t\tret = rcu_accelerate_cbs(rnp, rdp); /* Recent CBs. */\n\t\tif (rdp->core_needs_qs)\n\t\t\trdp->core_needs_qs = !!(rnp->qsmask & rdp->grpmask);\n\t}\n\n\t/* Now handle the beginnings of any new-to-this-CPU grace periods. */\n\tif (rcu_seq_new_gp(rdp->gp_seq, rnp->gp_seq) ||\n\t    unlikely(READ_ONCE(rdp->gpwrap))) {\n\t\t/*\n\t\t * If the current grace period is waiting for this CPU,\n\t\t * set up to detect a quiescent state, otherwise don't\n\t\t * go looking for one.\n\t\t */\n\t\ttrace_rcu_grace_period(rcu_state.name, rnp->gp_seq, TPS(\"cpustart\"));\n\t\tneed_qs = !!(rnp->qsmask & rdp->grpmask);\n\t\trdp->cpu_no_qs.b.norm = need_qs;\n\t\trdp->core_needs_qs = need_qs;\n\t\tzero_cpu_stall_ticks(rdp);\n\t}\n\trdp->gp_seq = rnp->gp_seq;  /* Remember new grace-period state. */\n\tif (ULONG_CMP_LT(rdp->gp_seq_needed, rnp->gp_seq_needed) || rdp->gpwrap)\n\t\tWRITE_ONCE(rdp->gp_seq_needed, rnp->gp_seq_needed);\n\tWRITE_ONCE(rdp->gpwrap, false);\n\trcu_gpnum_ovf(rnp, rdp);\n\treturn ret;\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};",
            "static struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};",
            "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
            "static void check_cb_ovld_locked(struct rcu_data *rdp, struct rcu_node *rnp);",
            "static bool rcu_rdp_is_offloaded(struct rcu_data *rdp);",
            "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};\nstatic struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void check_cb_ovld_locked(struct rcu_data *rdp, struct rcu_node *rnp);\nstatic bool rcu_rdp_is_offloaded(struct rcu_data *rdp);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nstatic bool __note_gp_changes(struct rcu_node *rnp, struct rcu_data *rdp)\n{\n\tbool ret = false;\n\tbool need_qs;\n\tconst bool offloaded = rcu_rdp_is_offloaded(rdp);\n\n\traw_lockdep_assert_held_rcu_node(rnp);\n\n\tif (rdp->gp_seq == rnp->gp_seq)\n\t\treturn false; /* Nothing to do. */\n\n\t/* Handle the ends of any preceding grace periods first. */\n\tif (rcu_seq_completed_gp(rdp->gp_seq, rnp->gp_seq) ||\n\t    unlikely(READ_ONCE(rdp->gpwrap))) {\n\t\tif (!offloaded)\n\t\t\tret = rcu_advance_cbs(rnp, rdp); /* Advance CBs. */\n\t\trdp->core_needs_qs = false;\n\t\ttrace_rcu_grace_period(rcu_state.name, rdp->gp_seq, TPS(\"cpuend\"));\n\t} else {\n\t\tif (!offloaded)\n\t\t\tret = rcu_accelerate_cbs(rnp, rdp); /* Recent CBs. */\n\t\tif (rdp->core_needs_qs)\n\t\t\trdp->core_needs_qs = !!(rnp->qsmask & rdp->grpmask);\n\t}\n\n\t/* Now handle the beginnings of any new-to-this-CPU grace periods. */\n\tif (rcu_seq_new_gp(rdp->gp_seq, rnp->gp_seq) ||\n\t    unlikely(READ_ONCE(rdp->gpwrap))) {\n\t\t/*\n\t\t * If the current grace period is waiting for this CPU,\n\t\t * set up to detect a quiescent state, otherwise don't\n\t\t * go looking for one.\n\t\t */\n\t\ttrace_rcu_grace_period(rcu_state.name, rnp->gp_seq, TPS(\"cpustart\"));\n\t\tneed_qs = !!(rnp->qsmask & rdp->grpmask);\n\t\trdp->cpu_no_qs.b.norm = need_qs;\n\t\trdp->core_needs_qs = need_qs;\n\t\tzero_cpu_stall_ticks(rdp);\n\t}\n\trdp->gp_seq = rnp->gp_seq;  /* Remember new grace-period state. */\n\tif (ULONG_CMP_LT(rdp->gp_seq_needed, rnp->gp_seq_needed) || rdp->gpwrap)\n\t\tWRITE_ONCE(rdp->gp_seq_needed, rnp->gp_seq_needed);\n\tWRITE_ONCE(rdp->gpwrap, false);\n\trcu_gpnum_ovf(rnp, rdp);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 1685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_trylock_rcu_node",
          "args": [
            "rnp"
          ],
          "line": 1684
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "READ_ONCE(rdp->gpwrap)"
          ],
          "line": 1683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rdp->gpwrap"
          ],
          "line": 1683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_seq_current",
          "args": [
            "&rnp->gp_seq"
          ],
          "line": 1682
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_seq_current",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu.h",
          "lines": "97-100",
          "snippet": "static inline unsigned long rcu_seq_current(unsigned long *sp)\n{\n\treturn READ_ONCE(*sp);\n}",
          "includes": [
            "#include <linux/rcu_node_tree.h>",
            "#include <trace/events/rcu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_node_tree.h>\n#include <trace/events/rcu.h>\n\nstatic inline unsigned long rcu_seq_current(unsigned long *sp)\n{\n\treturn READ_ONCE(*sp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_irq_save",
          "args": [
            "flags"
          ],
          "line": 1680
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};\nstatic void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void check_cb_ovld_locked(struct rcu_data *rdp, struct rcu_node *rnp);\nstatic bool rcu_rdp_is_offloaded(struct rcu_data *rdp);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nstatic void note_gp_changes(struct rcu_data *rdp)\n{\n\tunsigned long flags;\n\tbool needwake;\n\tstruct rcu_node *rnp;\n\n\tlocal_irq_save(flags);\n\trnp = rdp->mynode;\n\tif ((rdp->gp_seq == rcu_seq_current(&rnp->gp_seq) &&\n\t     !unlikely(READ_ONCE(rdp->gpwrap))) || /* w/out lock. */\n\t    !raw_spin_trylock_rcu_node(rnp)) { /* irqs already off, so later. */\n\t\tlocal_irq_restore(flags);\n\t\treturn;\n\t}\n\tneedwake = __note_gp_changes(rnp, rdp);\n\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\trcu_strict_gp_check_qs();\n\tif (needwake)\n\t\trcu_gp_kthread_wake();\n}"
  },
  {
    "function_name": "__note_gp_changes",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
    "lines": "1627-1672",
    "snippet": "static bool __note_gp_changes(struct rcu_node *rnp, struct rcu_data *rdp)\n{\n\tbool ret = false;\n\tbool need_qs;\n\tconst bool offloaded = rcu_rdp_is_offloaded(rdp);\n\n\traw_lockdep_assert_held_rcu_node(rnp);\n\n\tif (rdp->gp_seq == rnp->gp_seq)\n\t\treturn false; /* Nothing to do. */\n\n\t/* Handle the ends of any preceding grace periods first. */\n\tif (rcu_seq_completed_gp(rdp->gp_seq, rnp->gp_seq) ||\n\t    unlikely(READ_ONCE(rdp->gpwrap))) {\n\t\tif (!offloaded)\n\t\t\tret = rcu_advance_cbs(rnp, rdp); /* Advance CBs. */\n\t\trdp->core_needs_qs = false;\n\t\ttrace_rcu_grace_period(rcu_state.name, rdp->gp_seq, TPS(\"cpuend\"));\n\t} else {\n\t\tif (!offloaded)\n\t\t\tret = rcu_accelerate_cbs(rnp, rdp); /* Recent CBs. */\n\t\tif (rdp->core_needs_qs)\n\t\t\trdp->core_needs_qs = !!(rnp->qsmask & rdp->grpmask);\n\t}\n\n\t/* Now handle the beginnings of any new-to-this-CPU grace periods. */\n\tif (rcu_seq_new_gp(rdp->gp_seq, rnp->gp_seq) ||\n\t    unlikely(READ_ONCE(rdp->gpwrap))) {\n\t\t/*\n\t\t * If the current grace period is waiting for this CPU,\n\t\t * set up to detect a quiescent state, otherwise don't\n\t\t * go looking for one.\n\t\t */\n\t\ttrace_rcu_grace_period(rcu_state.name, rnp->gp_seq, TPS(\"cpustart\"));\n\t\tneed_qs = !!(rnp->qsmask & rdp->grpmask);\n\t\trdp->cpu_no_qs.b.norm = need_qs;\n\t\trdp->core_needs_qs = need_qs;\n\t\tzero_cpu_stall_ticks(rdp);\n\t}\n\trdp->gp_seq = rnp->gp_seq;  /* Remember new grace-period state. */\n\tif (ULONG_CMP_LT(rdp->gp_seq_needed, rnp->gp_seq_needed) || rdp->gpwrap)\n\t\tWRITE_ONCE(rdp->gp_seq_needed, rnp->gp_seq_needed);\n\tWRITE_ONCE(rdp->gpwrap, false);\n\trcu_gpnum_ovf(rnp, rdp);\n\treturn ret;\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_nocb.h\"",
      "#include \"tree_exp.h\"",
      "#include \"tree_stall.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <linux/kasan.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/panic_notifier.h>",
      "#include <linux/panic.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};",
      "static struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};",
      "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
      "static void check_cb_ovld_locked(struct rcu_data *rdp, struct rcu_node *rnp);",
      "static bool rcu_rdp_is_offloaded(struct rcu_data *rdp);",
      "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_gpnum_ovf",
          "args": [
            "rnp",
            "rdp"
          ],
          "line": 1670
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_gpnum_ovf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "1194-1202",
          "snippet": "static void rcu_gpnum_ovf(struct rcu_node *rnp, struct rcu_data *rdp)\n{\n\traw_lockdep_assert_held_rcu_node(rnp);\n\tif (ULONG_CMP_LT(rcu_seq_current(&rdp->gp_seq) + ULONG_MAX / 4,\n\t\t\t rnp->gp_seq))\n\t\tWRITE_ONCE(rdp->gpwrap, true);\n\tif (ULONG_CMP_LT(rdp->rcu_iw_gp_seq + ULONG_MAX / 4, rnp->gp_seq))\n\t\trdp->rcu_iw_gp_seq = rnp->gp_seq + ULONG_MAX / 4;\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};",
            "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
            "static void check_cb_ovld_locked(struct rcu_data *rdp, struct rcu_node *rnp);",
            "static bool rcu_rdp_is_offloaded(struct rcu_data *rdp);",
            "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void check_cb_ovld_locked(struct rcu_data *rdp, struct rcu_node *rnp);\nstatic bool rcu_rdp_is_offloaded(struct rcu_data *rdp);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nstatic void rcu_gpnum_ovf(struct rcu_node *rnp, struct rcu_data *rdp)\n{\n\traw_lockdep_assert_held_rcu_node(rnp);\n\tif (ULONG_CMP_LT(rcu_seq_current(&rdp->gp_seq) + ULONG_MAX / 4,\n\t\t\t rnp->gp_seq))\n\t\tWRITE_ONCE(rdp->gpwrap, true);\n\tif (ULONG_CMP_LT(rdp->rcu_iw_gp_seq + ULONG_MAX / 4, rnp->gp_seq))\n\t\trdp->rcu_iw_gp_seq = rnp->gp_seq + ULONG_MAX / 4;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "rdp->gpwrap",
            "false"
          ],
          "line": 1669
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "rdp->gp_seq_needed",
            "rnp->gp_seq_needed"
          ],
          "line": 1668
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ULONG_CMP_LT",
          "args": [
            "rdp->gp_seq_needed",
            "rnp->gp_seq_needed"
          ],
          "line": 1667
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zero_cpu_stall_ticks",
          "args": [
            "rdp"
          ],
          "line": 1664
        },
        "resolved": true,
        "details": {
          "function_name": "zero_cpu_stall_ticks",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_stall.h",
          "lines": "151-156",
          "snippet": "static void zero_cpu_stall_ticks(struct rcu_data *rdp)\n{\n\trdp->ticks_this_gp = 0;\n\trdp->softirq_snap = kstat_softirqs_cpu(RCU_SOFTIRQ, smp_processor_id());\n\tWRITE_ONCE(rdp->last_fqs_resched, jiffies);\n}",
          "includes": [
            "#include <linux/kvm_para.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_para.h>\n\nstatic void zero_cpu_stall_ticks(struct rcu_data *rdp)\n{\n\trdp->ticks_this_gp = 0;\n\trdp->softirq_snap = kstat_softirqs_cpu(RCU_SOFTIRQ, smp_processor_id());\n\tWRITE_ONCE(rdp->last_fqs_resched, jiffies);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_rcu_grace_period",
          "args": [
            "rcu_state.name",
            "rnp->gp_seq",
            "TPS(\"cpustart\")"
          ],
          "line": 1660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPS",
          "args": [
            "\"cpustart\""
          ],
          "line": 1660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "READ_ONCE(rdp->gpwrap)"
          ],
          "line": 1654
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rdp->gpwrap"
          ],
          "line": 1654
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_seq_new_gp",
          "args": [
            "rdp->gp_seq",
            "rnp->gp_seq"
          ],
          "line": 1653
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_seq_new_gp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu.h",
          "lines": "131-135",
          "snippet": "static inline bool rcu_seq_new_gp(unsigned long old, unsigned long new)\n{\n\treturn ULONG_CMP_LT((old + RCU_SEQ_STATE_MASK) & ~RCU_SEQ_STATE_MASK,\n\t\t\t    new);\n}",
          "includes": [
            "#include <linux/rcu_node_tree.h>",
            "#include <trace/events/rcu.h>"
          ],
          "macros_used": [
            "#define RCU_SEQ_STATE_MASK\t((1 << RCU_SEQ_CTR_SHIFT) - 1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_node_tree.h>\n#include <trace/events/rcu.h>\n\n#define RCU_SEQ_STATE_MASK\t((1 << RCU_SEQ_CTR_SHIFT) - 1)\n\nstatic inline bool rcu_seq_new_gp(unsigned long old, unsigned long new)\n{\n\treturn ULONG_CMP_LT((old + RCU_SEQ_STATE_MASK) & ~RCU_SEQ_STATE_MASK,\n\t\t\t    new);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_accelerate_cbs",
          "args": [
            "rnp",
            "rdp"
          ],
          "line": 1647
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_accelerate_cbs_unlocked",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "1543-1561",
          "snippet": "static void rcu_accelerate_cbs_unlocked(struct rcu_node *rnp,\n\t\t\t\t\tstruct rcu_data *rdp)\n{\n\tunsigned long c;\n\tbool needwake;\n\n\trcu_lockdep_assert_cblist_protected(rdp);\n\tc = rcu_seq_snap(&rcu_state.gp_seq);\n\tif (!READ_ONCE(rdp->gpwrap) && ULONG_CMP_GE(rdp->gp_seq_needed, c)) {\n\t\t/* Old request still live, so mark recent callbacks. */\n\t\t(void)rcu_segcblist_accelerate(&rdp->cblist, c);\n\t\treturn;\n\t}\n\traw_spin_lock_rcu_node(rnp); /* irqs already disabled. */\n\tneedwake = rcu_accelerate_cbs(rnp, rdp);\n\traw_spin_unlock_rcu_node(rnp); /* irqs remain disabled. */\n\tif (needwake)\n\t\trcu_gp_kthread_wake();\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};",
            "static struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};",
            "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
            "static void check_cb_ovld_locked(struct rcu_data *rdp, struct rcu_node *rnp);",
            "static bool rcu_rdp_is_offloaded(struct rcu_data *rdp);",
            "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};\nstatic struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void check_cb_ovld_locked(struct rcu_data *rdp, struct rcu_node *rnp);\nstatic bool rcu_rdp_is_offloaded(struct rcu_data *rdp);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nstatic void rcu_accelerate_cbs_unlocked(struct rcu_node *rnp,\n\t\t\t\t\tstruct rcu_data *rdp)\n{\n\tunsigned long c;\n\tbool needwake;\n\n\trcu_lockdep_assert_cblist_protected(rdp);\n\tc = rcu_seq_snap(&rcu_state.gp_seq);\n\tif (!READ_ONCE(rdp->gpwrap) && ULONG_CMP_GE(rdp->gp_seq_needed, c)) {\n\t\t/* Old request still live, so mark recent callbacks. */\n\t\t(void)rcu_segcblist_accelerate(&rdp->cblist, c);\n\t\treturn;\n\t}\n\traw_spin_lock_rcu_node(rnp); /* irqs already disabled. */\n\tneedwake = rcu_accelerate_cbs(rnp, rdp);\n\traw_spin_unlock_rcu_node(rnp); /* irqs remain disabled. */\n\tif (needwake)\n\t\trcu_gp_kthread_wake();\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_rcu_grace_period",
          "args": [
            "rcu_state.name",
            "rdp->gp_seq",
            "TPS(\"cpuend\")"
          ],
          "line": 1644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPS",
          "args": [
            "\"cpuend\""
          ],
          "line": 1644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_advance_cbs",
          "args": [
            "rnp",
            "rdp"
          ],
          "line": 1642
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_advance_cbs_nowake",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "1596-1606",
          "snippet": "static void __maybe_unused rcu_advance_cbs_nowake(struct rcu_node *rnp,\n\t\t\t\t\t\t  struct rcu_data *rdp)\n{\n\trcu_lockdep_assert_cblist_protected(rdp);\n\tif (!rcu_seq_state(rcu_seq_current(&rnp->gp_seq)) || !raw_spin_trylock_rcu_node(rnp))\n\t\treturn;\n\t// The grace period cannot end while we hold the rcu_node lock.\n\tif (rcu_seq_state(rcu_seq_current(&rnp->gp_seq)))\n\t\tWARN_ON_ONCE(rcu_advance_cbs(rnp, rdp));\n\traw_spin_unlock_rcu_node(rnp);\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};",
            "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
            "static void check_cb_ovld_locked(struct rcu_data *rdp, struct rcu_node *rnp);",
            "static bool rcu_rdp_is_offloaded(struct rcu_data *rdp);",
            "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void check_cb_ovld_locked(struct rcu_data *rdp, struct rcu_node *rnp);\nstatic bool rcu_rdp_is_offloaded(struct rcu_data *rdp);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nstatic void __maybe_unused rcu_advance_cbs_nowake(struct rcu_node *rnp,\n\t\t\t\t\t\t  struct rcu_data *rdp)\n{\n\trcu_lockdep_assert_cblist_protected(rdp);\n\tif (!rcu_seq_state(rcu_seq_current(&rnp->gp_seq)) || !raw_spin_trylock_rcu_node(rnp))\n\t\treturn;\n\t// The grace period cannot end while we hold the rcu_node lock.\n\tif (rcu_seq_state(rcu_seq_current(&rnp->gp_seq)))\n\t\tWARN_ON_ONCE(rcu_advance_cbs(rnp, rdp));\n\traw_spin_unlock_rcu_node(rnp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "READ_ONCE(rdp->gpwrap)"
          ],
          "line": 1640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rdp->gpwrap"
          ],
          "line": 1640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_seq_completed_gp",
          "args": [
            "rdp->gp_seq",
            "rnp->gp_seq"
          ],
          "line": 1639
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_seq_completed_gp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu.h",
          "lines": "123-126",
          "snippet": "static inline bool rcu_seq_completed_gp(unsigned long old, unsigned long new)\n{\n\treturn ULONG_CMP_LT(old, new & ~RCU_SEQ_STATE_MASK);\n}",
          "includes": [
            "#include <linux/rcu_node_tree.h>",
            "#include <trace/events/rcu.h>"
          ],
          "macros_used": [
            "#define RCU_SEQ_STATE_MASK\t((1 << RCU_SEQ_CTR_SHIFT) - 1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_node_tree.h>\n#include <trace/events/rcu.h>\n\n#define RCU_SEQ_STATE_MASK\t((1 << RCU_SEQ_CTR_SHIFT) - 1)\n\nstatic inline bool rcu_seq_completed_gp(unsigned long old, unsigned long new)\n{\n\treturn ULONG_CMP_LT(old, new & ~RCU_SEQ_STATE_MASK);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_lockdep_assert_held_rcu_node",
          "args": [
            "rnp"
          ],
          "line": 1633
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_rdp_is_offloaded",
          "args": [
            "rdp"
          ],
          "line": 1631
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_rdp_is_offloaded",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "16-38",
          "snippet": "static bool rcu_rdp_is_offloaded(struct rcu_data *rdp)\n{\n\t/*\n\t * In order to read the offloaded state of an rdp in a safe\n\t * and stable way and prevent from its value to be changed\n\t * under us, we must either hold the barrier mutex, the cpu\n\t * hotplug lock (read or write) or the nocb lock. Local\n\t * non-preemptible reads are also safe. NOCB kthreads and\n\t * timers have their own means of synchronization against the\n\t * offloaded state updaters.\n\t */\n\tRCU_LOCKDEP_WARN(\n\t\t!(lockdep_is_held(&rcu_state.barrier_mutex) ||\n\t\t  (IS_ENABLED(CONFIG_HOTPLUG_CPU) && lockdep_is_cpus_held()) ||\n\t\t  rcu_lockdep_is_held_nocb(rdp) ||\n\t\t  (rdp == this_cpu_ptr(&rcu_data) &&\n\t\t   !(IS_ENABLED(CONFIG_PREEMPT_COUNT) && preemptible())) ||\n\t\t  rcu_current_is_nocb_kthread(rdp)),\n\t\t\"Unsafe read of RCU_NOCB offloaded state\"\n\t);\n\n\treturn rcu_segcblist_is_offloaded(&rdp->cblist);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nstatic bool rcu_rdp_is_offloaded(struct rcu_data *rdp)\n{\n\t/*\n\t * In order to read the offloaded state of an rdp in a safe\n\t * and stable way and prevent from its value to be changed\n\t * under us, we must either hold the barrier mutex, the cpu\n\t * hotplug lock (read or write) or the nocb lock. Local\n\t * non-preemptible reads are also safe. NOCB kthreads and\n\t * timers have their own means of synchronization against the\n\t * offloaded state updaters.\n\t */\n\tRCU_LOCKDEP_WARN(\n\t\t!(lockdep_is_held(&rcu_state.barrier_mutex) ||\n\t\t  (IS_ENABLED(CONFIG_HOTPLUG_CPU) && lockdep_is_cpus_held()) ||\n\t\t  rcu_lockdep_is_held_nocb(rdp) ||\n\t\t  (rdp == this_cpu_ptr(&rcu_data) &&\n\t\t   !(IS_ENABLED(CONFIG_PREEMPT_COUNT) && preemptible())) ||\n\t\t  rcu_current_is_nocb_kthread(rdp)),\n\t\t\"Unsafe read of RCU_NOCB offloaded state\"\n\t);\n\n\treturn rcu_segcblist_is_offloaded(&rdp->cblist);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};\nstatic struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void check_cb_ovld_locked(struct rcu_data *rdp, struct rcu_node *rnp);\nstatic bool rcu_rdp_is_offloaded(struct rcu_data *rdp);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nstatic bool __note_gp_changes(struct rcu_node *rnp, struct rcu_data *rdp)\n{\n\tbool ret = false;\n\tbool need_qs;\n\tconst bool offloaded = rcu_rdp_is_offloaded(rdp);\n\n\traw_lockdep_assert_held_rcu_node(rnp);\n\n\tif (rdp->gp_seq == rnp->gp_seq)\n\t\treturn false; /* Nothing to do. */\n\n\t/* Handle the ends of any preceding grace periods first. */\n\tif (rcu_seq_completed_gp(rdp->gp_seq, rnp->gp_seq) ||\n\t    unlikely(READ_ONCE(rdp->gpwrap))) {\n\t\tif (!offloaded)\n\t\t\tret = rcu_advance_cbs(rnp, rdp); /* Advance CBs. */\n\t\trdp->core_needs_qs = false;\n\t\ttrace_rcu_grace_period(rcu_state.name, rdp->gp_seq, TPS(\"cpuend\"));\n\t} else {\n\t\tif (!offloaded)\n\t\t\tret = rcu_accelerate_cbs(rnp, rdp); /* Recent CBs. */\n\t\tif (rdp->core_needs_qs)\n\t\t\trdp->core_needs_qs = !!(rnp->qsmask & rdp->grpmask);\n\t}\n\n\t/* Now handle the beginnings of any new-to-this-CPU grace periods. */\n\tif (rcu_seq_new_gp(rdp->gp_seq, rnp->gp_seq) ||\n\t    unlikely(READ_ONCE(rdp->gpwrap))) {\n\t\t/*\n\t\t * If the current grace period is waiting for this CPU,\n\t\t * set up to detect a quiescent state, otherwise don't\n\t\t * go looking for one.\n\t\t */\n\t\ttrace_rcu_grace_period(rcu_state.name, rnp->gp_seq, TPS(\"cpustart\"));\n\t\tneed_qs = !!(rnp->qsmask & rdp->grpmask);\n\t\trdp->cpu_no_qs.b.norm = need_qs;\n\t\trdp->core_needs_qs = need_qs;\n\t\tzero_cpu_stall_ticks(rdp);\n\t}\n\trdp->gp_seq = rnp->gp_seq;  /* Remember new grace-period state. */\n\tif (ULONG_CMP_LT(rdp->gp_seq_needed, rnp->gp_seq_needed) || rdp->gpwrap)\n\t\tWRITE_ONCE(rdp->gp_seq_needed, rnp->gp_seq_needed);\n\tWRITE_ONCE(rdp->gpwrap, false);\n\trcu_gpnum_ovf(rnp, rdp);\n\treturn ret;\n}"
  },
  {
    "function_name": "rcu_strict_gp_check_qs",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
    "lines": "1613-1619",
    "snippet": "static void rcu_strict_gp_check_qs(void)\n{\n\tif (IS_ENABLED(CONFIG_RCU_STRICT_GRACE_PERIOD)) {\n\t\trcu_read_lock();\n\t\trcu_read_unlock();\n\t}\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_nocb.h\"",
      "#include \"tree_exp.h\"",
      "#include \"tree_stall.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <linux/kasan.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/panic_notifier.h>",
      "#include <linux/panic.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 1617
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_unlock_strict",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "815-824",
          "snippet": "void rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nvoid rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 1616
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_any_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "340-351",
          "snippet": "int rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_RCU_STRICT_GRACE_PERIOD"
          ],
          "line": 1615
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic void rcu_strict_gp_check_qs(void)\n{\n\tif (IS_ENABLED(CONFIG_RCU_STRICT_GRACE_PERIOD)) {\n\t\trcu_read_lock();\n\t\trcu_read_unlock();\n\t}\n}"
  },
  {
    "function_name": "rcu_advance_cbs_nowake",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
    "lines": "1596-1606",
    "snippet": "static void __maybe_unused rcu_advance_cbs_nowake(struct rcu_node *rnp,\n\t\t\t\t\t\t  struct rcu_data *rdp)\n{\n\trcu_lockdep_assert_cblist_protected(rdp);\n\tif (!rcu_seq_state(rcu_seq_current(&rnp->gp_seq)) || !raw_spin_trylock_rcu_node(rnp))\n\t\treturn;\n\t// The grace period cannot end while we hold the rcu_node lock.\n\tif (rcu_seq_state(rcu_seq_current(&rnp->gp_seq)))\n\t\tWARN_ON_ONCE(rcu_advance_cbs(rnp, rdp));\n\traw_spin_unlock_rcu_node(rnp);\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_nocb.h\"",
      "#include \"tree_exp.h\"",
      "#include \"tree_stall.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <linux/kasan.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/panic_notifier.h>",
      "#include <linux/panic.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};",
      "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
      "static void check_cb_ovld_locked(struct rcu_data *rdp, struct rcu_node *rnp);",
      "static bool rcu_rdp_is_offloaded(struct rcu_data *rdp);",
      "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock_rcu_node",
          "args": [
            "rnp"
          ],
          "line": 1605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "rcu_advance_cbs(rnp, rdp)"
          ],
          "line": 1604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_advance_cbs",
          "args": [
            "rnp",
            "rdp"
          ],
          "line": 1604
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_advance_cbs_nowake",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "1596-1606",
          "snippet": "static void __maybe_unused rcu_advance_cbs_nowake(struct rcu_node *rnp,\n\t\t\t\t\t\t  struct rcu_data *rdp)\n{\n\trcu_lockdep_assert_cblist_protected(rdp);\n\tif (!rcu_seq_state(rcu_seq_current(&rnp->gp_seq)) || !raw_spin_trylock_rcu_node(rnp))\n\t\treturn;\n\t// The grace period cannot end while we hold the rcu_node lock.\n\tif (rcu_seq_state(rcu_seq_current(&rnp->gp_seq)))\n\t\tWARN_ON_ONCE(rcu_advance_cbs(rnp, rdp));\n\traw_spin_unlock_rcu_node(rnp);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "rcu_seq_state",
          "args": [
            "rcu_seq_current(&rnp->gp_seq)"
          ],
          "line": 1603
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_seq_state",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu.h",
          "lines": "39-42",
          "snippet": "static inline int rcu_seq_state(unsigned long s)\n{\n\treturn s & RCU_SEQ_STATE_MASK;\n}",
          "includes": [
            "#include <linux/rcu_node_tree.h>",
            "#include <trace/events/rcu.h>"
          ],
          "macros_used": [
            "#define RCU_SEQ_STATE_MASK\t((1 << RCU_SEQ_CTR_SHIFT) - 1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_node_tree.h>\n#include <trace/events/rcu.h>\n\n#define RCU_SEQ_STATE_MASK\t((1 << RCU_SEQ_CTR_SHIFT) - 1)\n\nstatic inline int rcu_seq_state(unsigned long s)\n{\n\treturn s & RCU_SEQ_STATE_MASK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_seq_current",
          "args": [
            "&rnp->gp_seq"
          ],
          "line": 1603
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_seq_current",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu.h",
          "lines": "97-100",
          "snippet": "static inline unsigned long rcu_seq_current(unsigned long *sp)\n{\n\treturn READ_ONCE(*sp);\n}",
          "includes": [
            "#include <linux/rcu_node_tree.h>",
            "#include <trace/events/rcu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_node_tree.h>\n#include <trace/events/rcu.h>\n\nstatic inline unsigned long rcu_seq_current(unsigned long *sp)\n{\n\treturn READ_ONCE(*sp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_trylock_rcu_node",
          "args": [
            "rnp"
          ],
          "line": 1600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_lockdep_assert_cblist_protected",
          "args": [
            "rdp"
          ],
          "line": 1599
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_lockdep_assert_cblist_protected",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_nocb.h",
          "lines": "1486-1489",
          "snippet": "static void rcu_lockdep_assert_cblist_protected(struct rcu_data *rdp)\n{\n\tlockdep_assert_irqs_disabled();\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static void rcu_lockdep_assert_cblist_protected(struct rcu_data *rdp)\n{\n\tlockdep_assert_irqs_disabled();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void check_cb_ovld_locked(struct rcu_data *rdp, struct rcu_node *rnp);\nstatic bool rcu_rdp_is_offloaded(struct rcu_data *rdp);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nstatic void __maybe_unused rcu_advance_cbs_nowake(struct rcu_node *rnp,\n\t\t\t\t\t\t  struct rcu_data *rdp)\n{\n\trcu_lockdep_assert_cblist_protected(rdp);\n\tif (!rcu_seq_state(rcu_seq_current(&rnp->gp_seq)) || !raw_spin_trylock_rcu_node(rnp))\n\t\treturn;\n\t// The grace period cannot end while we hold the rcu_node lock.\n\tif (rcu_seq_state(rcu_seq_current(&rnp->gp_seq)))\n\t\tWARN_ON_ONCE(rcu_advance_cbs(rnp, rdp));\n\traw_spin_unlock_rcu_node(rnp);\n}"
  },
  {
    "function_name": "rcu_advance_cbs",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
    "lines": "1573-1590",
    "snippet": "static bool rcu_advance_cbs(struct rcu_node *rnp, struct rcu_data *rdp)\n{\n\trcu_lockdep_assert_cblist_protected(rdp);\n\traw_lockdep_assert_held_rcu_node(rnp);\n\n\t/* If no pending (not yet ready to invoke) callbacks, nothing to do. */\n\tif (!rcu_segcblist_pend_cbs(&rdp->cblist))\n\t\treturn false;\n\n\t/*\n\t * Find all callbacks whose ->gp_seq numbers indicate that they\n\t * are ready to invoke, and put them into the RCU_DONE_TAIL sublist.\n\t */\n\trcu_segcblist_advance(&rdp->cblist, rnp->gp_seq);\n\n\t/* Classify any remaining callbacks. */\n\treturn rcu_accelerate_cbs(rnp, rdp);\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_nocb.h\"",
      "#include \"tree_exp.h\"",
      "#include \"tree_stall.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <linux/kasan.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/panic_notifier.h>",
      "#include <linux/panic.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};",
      "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
      "static void check_cb_ovld_locked(struct rcu_data *rdp, struct rcu_node *rnp);",
      "static bool rcu_rdp_is_offloaded(struct rcu_data *rdp);",
      "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_accelerate_cbs",
          "args": [
            "rnp",
            "rdp"
          ],
          "line": 1589
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_accelerate_cbs_unlocked",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "1543-1561",
          "snippet": "static void rcu_accelerate_cbs_unlocked(struct rcu_node *rnp,\n\t\t\t\t\tstruct rcu_data *rdp)\n{\n\tunsigned long c;\n\tbool needwake;\n\n\trcu_lockdep_assert_cblist_protected(rdp);\n\tc = rcu_seq_snap(&rcu_state.gp_seq);\n\tif (!READ_ONCE(rdp->gpwrap) && ULONG_CMP_GE(rdp->gp_seq_needed, c)) {\n\t\t/* Old request still live, so mark recent callbacks. */\n\t\t(void)rcu_segcblist_accelerate(&rdp->cblist, c);\n\t\treturn;\n\t}\n\traw_spin_lock_rcu_node(rnp); /* irqs already disabled. */\n\tneedwake = rcu_accelerate_cbs(rnp, rdp);\n\traw_spin_unlock_rcu_node(rnp); /* irqs remain disabled. */\n\tif (needwake)\n\t\trcu_gp_kthread_wake();\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};",
            "static struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};",
            "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
            "static void check_cb_ovld_locked(struct rcu_data *rdp, struct rcu_node *rnp);",
            "static bool rcu_rdp_is_offloaded(struct rcu_data *rdp);",
            "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};\nstatic struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void check_cb_ovld_locked(struct rcu_data *rdp, struct rcu_node *rnp);\nstatic bool rcu_rdp_is_offloaded(struct rcu_data *rdp);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nstatic void rcu_accelerate_cbs_unlocked(struct rcu_node *rnp,\n\t\t\t\t\tstruct rcu_data *rdp)\n{\n\tunsigned long c;\n\tbool needwake;\n\n\trcu_lockdep_assert_cblist_protected(rdp);\n\tc = rcu_seq_snap(&rcu_state.gp_seq);\n\tif (!READ_ONCE(rdp->gpwrap) && ULONG_CMP_GE(rdp->gp_seq_needed, c)) {\n\t\t/* Old request still live, so mark recent callbacks. */\n\t\t(void)rcu_segcblist_accelerate(&rdp->cblist, c);\n\t\treturn;\n\t}\n\traw_spin_lock_rcu_node(rnp); /* irqs already disabled. */\n\tneedwake = rcu_accelerate_cbs(rnp, rdp);\n\traw_spin_unlock_rcu_node(rnp); /* irqs remain disabled. */\n\tif (needwake)\n\t\trcu_gp_kthread_wake();\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_segcblist_advance",
          "args": [
            "&rdp->cblist",
            "rnp->gp_seq"
          ],
          "line": 1586
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_advance",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.c",
          "lines": "480-520",
          "snippet": "void rcu_segcblist_advance(struct rcu_segcblist *rsclp, unsigned long seq)\n{\n\tint i, j;\n\n\tWARN_ON_ONCE(!rcu_segcblist_is_enabled(rsclp));\n\tif (rcu_segcblist_restempty(rsclp, RCU_DONE_TAIL))\n\t\treturn;\n\n\t/*\n\t * Find all callbacks whose ->gp_seq numbers indicate that they\n\t * are ready to invoke, and put them into the RCU_DONE_TAIL segment.\n\t */\n\tfor (i = RCU_WAIT_TAIL; i < RCU_NEXT_TAIL; i++) {\n\t\tif (ULONG_CMP_LT(seq, rsclp->gp_seq[i]))\n\t\t\tbreak;\n\t\tWRITE_ONCE(rsclp->tails[RCU_DONE_TAIL], rsclp->tails[i]);\n\t\trcu_segcblist_move_seglen(rsclp, i, RCU_DONE_TAIL);\n\t}\n\n\t/* If no callbacks moved, nothing more need be done. */\n\tif (i == RCU_WAIT_TAIL)\n\t\treturn;\n\n\t/* Clean up tail pointers that might have been misordered above. */\n\tfor (j = RCU_WAIT_TAIL; j < i; j++)\n\t\tWRITE_ONCE(rsclp->tails[j], rsclp->tails[RCU_DONE_TAIL]);\n\n\t/*\n\t * Callbacks moved, so clean up the misordered ->tails[] pointers\n\t * that now point into the middle of the list of ready-to-invoke\n\t * callbacks.  The overall effect is to copy down the later pointers\n\t * into the gap that was created by the now-ready segments.\n\t */\n\tfor (j = RCU_WAIT_TAIL; i < RCU_NEXT_TAIL; i++, j++) {\n\t\tif (rsclp->tails[j] == rsclp->tails[RCU_NEXT_TAIL])\n\t\t\tbreak;  /* No more callbacks. */\n\t\tWRITE_ONCE(rsclp->tails[j], rsclp->tails[i]);\n\t\trcu_segcblist_move_seglen(rsclp, i, j);\n\t\trsclp->gp_seq[j] = rsclp->gp_seq[i];\n\t}\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/cpu.h>\n\nvoid rcu_segcblist_advance(struct rcu_segcblist *rsclp, unsigned long seq)\n{\n\tint i, j;\n\n\tWARN_ON_ONCE(!rcu_segcblist_is_enabled(rsclp));\n\tif (rcu_segcblist_restempty(rsclp, RCU_DONE_TAIL))\n\t\treturn;\n\n\t/*\n\t * Find all callbacks whose ->gp_seq numbers indicate that they\n\t * are ready to invoke, and put them into the RCU_DONE_TAIL segment.\n\t */\n\tfor (i = RCU_WAIT_TAIL; i < RCU_NEXT_TAIL; i++) {\n\t\tif (ULONG_CMP_LT(seq, rsclp->gp_seq[i]))\n\t\t\tbreak;\n\t\tWRITE_ONCE(rsclp->tails[RCU_DONE_TAIL], rsclp->tails[i]);\n\t\trcu_segcblist_move_seglen(rsclp, i, RCU_DONE_TAIL);\n\t}\n\n\t/* If no callbacks moved, nothing more need be done. */\n\tif (i == RCU_WAIT_TAIL)\n\t\treturn;\n\n\t/* Clean up tail pointers that might have been misordered above. */\n\tfor (j = RCU_WAIT_TAIL; j < i; j++)\n\t\tWRITE_ONCE(rsclp->tails[j], rsclp->tails[RCU_DONE_TAIL]);\n\n\t/*\n\t * Callbacks moved, so clean up the misordered ->tails[] pointers\n\t * that now point into the middle of the list of ready-to-invoke\n\t * callbacks.  The overall effect is to copy down the later pointers\n\t * into the gap that was created by the now-ready segments.\n\t */\n\tfor (j = RCU_WAIT_TAIL; i < RCU_NEXT_TAIL; i++, j++) {\n\t\tif (rsclp->tails[j] == rsclp->tails[RCU_NEXT_TAIL])\n\t\t\tbreak;  /* No more callbacks. */\n\t\tWRITE_ONCE(rsclp->tails[j], rsclp->tails[i]);\n\t\trcu_segcblist_move_seglen(rsclp, i, j);\n\t\trsclp->gp_seq[j] = rsclp->gp_seq[i];\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_segcblist_pend_cbs",
          "args": [
            "&rdp->cblist"
          ],
          "line": 1579
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_pend_cbs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.c",
          "lines": "288-292",
          "snippet": "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp)\n{\n\treturn rcu_segcblist_is_enabled(rsclp) &&\n\t       !rcu_segcblist_restempty(rsclp, RCU_DONE_TAIL);\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/cpu.h>\n\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp)\n{\n\treturn rcu_segcblist_is_enabled(rsclp) &&\n\t       !rcu_segcblist_restempty(rsclp, RCU_DONE_TAIL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_lockdep_assert_held_rcu_node",
          "args": [
            "rnp"
          ],
          "line": 1576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_lockdep_assert_cblist_protected",
          "args": [
            "rdp"
          ],
          "line": 1575
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_lockdep_assert_cblist_protected",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_nocb.h",
          "lines": "1486-1489",
          "snippet": "static void rcu_lockdep_assert_cblist_protected(struct rcu_data *rdp)\n{\n\tlockdep_assert_irqs_disabled();\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static void rcu_lockdep_assert_cblist_protected(struct rcu_data *rdp)\n{\n\tlockdep_assert_irqs_disabled();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void check_cb_ovld_locked(struct rcu_data *rdp, struct rcu_node *rnp);\nstatic bool rcu_rdp_is_offloaded(struct rcu_data *rdp);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nstatic bool rcu_advance_cbs(struct rcu_node *rnp, struct rcu_data *rdp)\n{\n\trcu_lockdep_assert_cblist_protected(rdp);\n\traw_lockdep_assert_held_rcu_node(rnp);\n\n\t/* If no pending (not yet ready to invoke) callbacks, nothing to do. */\n\tif (!rcu_segcblist_pend_cbs(&rdp->cblist))\n\t\treturn false;\n\n\t/*\n\t * Find all callbacks whose ->gp_seq numbers indicate that they\n\t * are ready to invoke, and put them into the RCU_DONE_TAIL sublist.\n\t */\n\trcu_segcblist_advance(&rdp->cblist, rnp->gp_seq);\n\n\t/* Classify any remaining callbacks. */\n\treturn rcu_accelerate_cbs(rnp, rdp);\n}"
  },
  {
    "function_name": "rcu_accelerate_cbs_unlocked",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
    "lines": "1543-1561",
    "snippet": "static void rcu_accelerate_cbs_unlocked(struct rcu_node *rnp,\n\t\t\t\t\tstruct rcu_data *rdp)\n{\n\tunsigned long c;\n\tbool needwake;\n\n\trcu_lockdep_assert_cblist_protected(rdp);\n\tc = rcu_seq_snap(&rcu_state.gp_seq);\n\tif (!READ_ONCE(rdp->gpwrap) && ULONG_CMP_GE(rdp->gp_seq_needed, c)) {\n\t\t/* Old request still live, so mark recent callbacks. */\n\t\t(void)rcu_segcblist_accelerate(&rdp->cblist, c);\n\t\treturn;\n\t}\n\traw_spin_lock_rcu_node(rnp); /* irqs already disabled. */\n\tneedwake = rcu_accelerate_cbs(rnp, rdp);\n\traw_spin_unlock_rcu_node(rnp); /* irqs remain disabled. */\n\tif (needwake)\n\t\trcu_gp_kthread_wake();\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_nocb.h\"",
      "#include \"tree_exp.h\"",
      "#include \"tree_stall.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <linux/kasan.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/panic_notifier.h>",
      "#include <linux/panic.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};",
      "static struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};",
      "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
      "static void check_cb_ovld_locked(struct rcu_data *rdp, struct rcu_node *rnp);",
      "static bool rcu_rdp_is_offloaded(struct rcu_data *rdp);",
      "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_gp_kthread_wake",
          "args": [],
          "line": 1560
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_gp_kthread_wake",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "1473-1483",
          "snippet": "static void rcu_gp_kthread_wake(void)\n{\n\tstruct task_struct *t = READ_ONCE(rcu_state.gp_kthread);\n\n\tif ((current == t && !in_hardirq() && !in_serving_softirq()) ||\n\t    !READ_ONCE(rcu_state.gp_flags) || !t)\n\t\treturn;\n\tWRITE_ONCE(rcu_state.gp_wake_time, jiffies);\n\tWRITE_ONCE(rcu_state.gp_wake_seq, READ_ONCE(rcu_state.gp_seq));\n\tswake_up_one(&rcu_state.gp_wq);\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\n\nstatic void rcu_gp_kthread_wake(void)\n{\n\tstruct task_struct *t = READ_ONCE(rcu_state.gp_kthread);\n\n\tif ((current == t && !in_hardirq() && !in_serving_softirq()) ||\n\t    !READ_ONCE(rcu_state.gp_flags) || !t)\n\t\treturn;\n\tWRITE_ONCE(rcu_state.gp_wake_time, jiffies);\n\tWRITE_ONCE(rcu_state.gp_wake_seq, READ_ONCE(rcu_state.gp_seq));\n\tswake_up_one(&rcu_state.gp_wq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_rcu_node",
          "args": [
            "rnp"
          ],
          "line": 1558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_accelerate_cbs",
          "args": [
            "rnp",
            "rdp"
          ],
          "line": 1557
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_accelerate_cbs_unlocked",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "1543-1561",
          "snippet": "static void rcu_accelerate_cbs_unlocked(struct rcu_node *rnp,\n\t\t\t\t\tstruct rcu_data *rdp)\n{\n\tunsigned long c;\n\tbool needwake;\n\n\trcu_lockdep_assert_cblist_protected(rdp);\n\tc = rcu_seq_snap(&rcu_state.gp_seq);\n\tif (!READ_ONCE(rdp->gpwrap) && ULONG_CMP_GE(rdp->gp_seq_needed, c)) {\n\t\t/* Old request still live, so mark recent callbacks. */\n\t\t(void)rcu_segcblist_accelerate(&rdp->cblist, c);\n\t\treturn;\n\t}\n\traw_spin_lock_rcu_node(rnp); /* irqs already disabled. */\n\tneedwake = rcu_accelerate_cbs(rnp, rdp);\n\traw_spin_unlock_rcu_node(rnp); /* irqs remain disabled. */\n\tif (needwake)\n\t\trcu_gp_kthread_wake();\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_rcu_node",
          "args": [
            "rnp"
          ],
          "line": 1556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_segcblist_accelerate",
          "args": [
            "&rdp->cblist",
            "c"
          ],
          "line": 1553
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_accelerate",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.c",
          "lines": "537-598",
          "snippet": "bool rcu_segcblist_accelerate(struct rcu_segcblist *rsclp, unsigned long seq)\n{\n\tint i, j;\n\n\tWARN_ON_ONCE(!rcu_segcblist_is_enabled(rsclp));\n\tif (rcu_segcblist_restempty(rsclp, RCU_DONE_TAIL))\n\t\treturn false;\n\n\t/*\n\t * Find the segment preceding the oldest segment of callbacks\n\t * whose ->gp_seq[] completion is at or after that passed in via\n\t * \"seq\", skipping any empty segments.  This oldest segment, along\n\t * with any later segments, can be merged in with any newly arrived\n\t * callbacks in the RCU_NEXT_TAIL segment, and assigned \"seq\"\n\t * as their ->gp_seq[] grace-period completion sequence number.\n\t */\n\tfor (i = RCU_NEXT_READY_TAIL; i > RCU_DONE_TAIL; i--)\n\t\tif (rsclp->tails[i] != rsclp->tails[i - 1] &&\n\t\t    ULONG_CMP_LT(rsclp->gp_seq[i], seq))\n\t\t\tbreak;\n\n\t/*\n\t * If all the segments contain callbacks that correspond to\n\t * earlier grace-period sequence numbers than \"seq\", leave.\n\t * Assuming that the rcu_segcblist structure has enough\n\t * segments in its arrays, this can only happen if some of\n\t * the non-done segments contain callbacks that really are\n\t * ready to invoke.  This situation will get straightened\n\t * out by the next call to rcu_segcblist_advance().\n\t *\n\t * Also advance to the oldest segment of callbacks whose\n\t * ->gp_seq[] completion is at or after that passed in via \"seq\",\n\t * skipping any empty segments.\n\t *\n\t * Note that segment \"i\" (and any lower-numbered segments\n\t * containing older callbacks) will be unaffected, and their\n\t * grace-period numbers remain unchanged.  For example, if i ==\n\t * WAIT_TAIL, then neither WAIT_TAIL nor DONE_TAIL will be touched.\n\t * Instead, the CBs in NEXT_TAIL will be merged with those in\n\t * NEXT_READY_TAIL and the grace-period number of NEXT_READY_TAIL\n\t * would be updated.  NEXT_TAIL would then be empty.\n\t */\n\tif (rcu_segcblist_restempty(rsclp, i) || ++i >= RCU_NEXT_TAIL)\n\t\treturn false;\n\n\t/* Accounting: everything below i is about to get merged into i. */\n\tfor (j = i + 1; j <= RCU_NEXT_TAIL; j++)\n\t\trcu_segcblist_move_seglen(rsclp, j, i);\n\n\t/*\n\t * Merge all later callbacks, including newly arrived callbacks,\n\t * into the segment located by the for-loop above.  Assign \"seq\"\n\t * as the ->gp_seq[] value in order to correctly handle the case\n\t * where there were no pending callbacks in the rcu_segcblist\n\t * structure other than in the RCU_NEXT_TAIL segment.\n\t */\n\tfor (; i < RCU_NEXT_TAIL; i++) {\n\t\tWRITE_ONCE(rsclp->tails[i], rsclp->tails[RCU_NEXT_TAIL]);\n\t\trsclp->gp_seq[i] = seq;\n\t}\n\treturn true;\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/cpu.h>\n\nbool rcu_segcblist_accelerate(struct rcu_segcblist *rsclp, unsigned long seq)\n{\n\tint i, j;\n\n\tWARN_ON_ONCE(!rcu_segcblist_is_enabled(rsclp));\n\tif (rcu_segcblist_restempty(rsclp, RCU_DONE_TAIL))\n\t\treturn false;\n\n\t/*\n\t * Find the segment preceding the oldest segment of callbacks\n\t * whose ->gp_seq[] completion is at or after that passed in via\n\t * \"seq\", skipping any empty segments.  This oldest segment, along\n\t * with any later segments, can be merged in with any newly arrived\n\t * callbacks in the RCU_NEXT_TAIL segment, and assigned \"seq\"\n\t * as their ->gp_seq[] grace-period completion sequence number.\n\t */\n\tfor (i = RCU_NEXT_READY_TAIL; i > RCU_DONE_TAIL; i--)\n\t\tif (rsclp->tails[i] != rsclp->tails[i - 1] &&\n\t\t    ULONG_CMP_LT(rsclp->gp_seq[i], seq))\n\t\t\tbreak;\n\n\t/*\n\t * If all the segments contain callbacks that correspond to\n\t * earlier grace-period sequence numbers than \"seq\", leave.\n\t * Assuming that the rcu_segcblist structure has enough\n\t * segments in its arrays, this can only happen if some of\n\t * the non-done segments contain callbacks that really are\n\t * ready to invoke.  This situation will get straightened\n\t * out by the next call to rcu_segcblist_advance().\n\t *\n\t * Also advance to the oldest segment of callbacks whose\n\t * ->gp_seq[] completion is at or after that passed in via \"seq\",\n\t * skipping any empty segments.\n\t *\n\t * Note that segment \"i\" (and any lower-numbered segments\n\t * containing older callbacks) will be unaffected, and their\n\t * grace-period numbers remain unchanged.  For example, if i ==\n\t * WAIT_TAIL, then neither WAIT_TAIL nor DONE_TAIL will be touched.\n\t * Instead, the CBs in NEXT_TAIL will be merged with those in\n\t * NEXT_READY_TAIL and the grace-period number of NEXT_READY_TAIL\n\t * would be updated.  NEXT_TAIL would then be empty.\n\t */\n\tif (rcu_segcblist_restempty(rsclp, i) || ++i >= RCU_NEXT_TAIL)\n\t\treturn false;\n\n\t/* Accounting: everything below i is about to get merged into i. */\n\tfor (j = i + 1; j <= RCU_NEXT_TAIL; j++)\n\t\trcu_segcblist_move_seglen(rsclp, j, i);\n\n\t/*\n\t * Merge all later callbacks, including newly arrived callbacks,\n\t * into the segment located by the for-loop above.  Assign \"seq\"\n\t * as the ->gp_seq[] value in order to correctly handle the case\n\t * where there were no pending callbacks in the rcu_segcblist\n\t * structure other than in the RCU_NEXT_TAIL segment.\n\t */\n\tfor (; i < RCU_NEXT_TAIL; i++) {\n\t\tWRITE_ONCE(rsclp->tails[i], rsclp->tails[RCU_NEXT_TAIL]);\n\t\trsclp->gp_seq[i] = seq;\n\t}\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ULONG_CMP_GE",
          "args": [
            "rdp->gp_seq_needed",
            "c"
          ],
          "line": 1551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rdp->gpwrap"
          ],
          "line": 1551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_seq_snap",
          "args": [
            "&rcu_state.gp_seq"
          ],
          "line": 1550
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_seq_snap",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu.h",
          "lines": "87-94",
          "snippet": "static inline unsigned long rcu_seq_snap(unsigned long *sp)\n{\n\tunsigned long s;\n\n\ts = (READ_ONCE(*sp) + 2 * RCU_SEQ_STATE_MASK + 1) & ~RCU_SEQ_STATE_MASK;\n\tsmp_mb(); /* Above access must not bleed into critical section. */\n\treturn s;\n}",
          "includes": [
            "#include <linux/rcu_node_tree.h>",
            "#include <trace/events/rcu.h>"
          ],
          "macros_used": [
            "#define RCU_SEQ_STATE_MASK\t((1 << RCU_SEQ_CTR_SHIFT) - 1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_node_tree.h>\n#include <trace/events/rcu.h>\n\n#define RCU_SEQ_STATE_MASK\t((1 << RCU_SEQ_CTR_SHIFT) - 1)\n\nstatic inline unsigned long rcu_seq_snap(unsigned long *sp)\n{\n\tunsigned long s;\n\n\ts = (READ_ONCE(*sp) + 2 * RCU_SEQ_STATE_MASK + 1) & ~RCU_SEQ_STATE_MASK;\n\tsmp_mb(); /* Above access must not bleed into critical section. */\n\treturn s;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_lockdep_assert_cblist_protected",
          "args": [
            "rdp"
          ],
          "line": 1549
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_lockdep_assert_cblist_protected",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_nocb.h",
          "lines": "1486-1489",
          "snippet": "static void rcu_lockdep_assert_cblist_protected(struct rcu_data *rdp)\n{\n\tlockdep_assert_irqs_disabled();\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static void rcu_lockdep_assert_cblist_protected(struct rcu_data *rdp)\n{\n\tlockdep_assert_irqs_disabled();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};\nstatic struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void check_cb_ovld_locked(struct rcu_data *rdp, struct rcu_node *rnp);\nstatic bool rcu_rdp_is_offloaded(struct rcu_data *rdp);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nstatic void rcu_accelerate_cbs_unlocked(struct rcu_node *rnp,\n\t\t\t\t\tstruct rcu_data *rdp)\n{\n\tunsigned long c;\n\tbool needwake;\n\n\trcu_lockdep_assert_cblist_protected(rdp);\n\tc = rcu_seq_snap(&rcu_state.gp_seq);\n\tif (!READ_ONCE(rdp->gpwrap) && ULONG_CMP_GE(rdp->gp_seq_needed, c)) {\n\t\t/* Old request still live, so mark recent callbacks. */\n\t\t(void)rcu_segcblist_accelerate(&rdp->cblist, c);\n\t\treturn;\n\t}\n\traw_spin_lock_rcu_node(rnp); /* irqs already disabled. */\n\tneedwake = rcu_accelerate_cbs(rnp, rdp);\n\traw_spin_unlock_rcu_node(rnp); /* irqs remain disabled. */\n\tif (needwake)\n\t\trcu_gp_kthread_wake();\n}"
  },
  {
    "function_name": "rcu_accelerate_cbs",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
    "lines": "1497-1534",
    "snippet": "static bool rcu_accelerate_cbs(struct rcu_node *rnp, struct rcu_data *rdp)\n{\n\tunsigned long gp_seq_req;\n\tbool ret = false;\n\n\trcu_lockdep_assert_cblist_protected(rdp);\n\traw_lockdep_assert_held_rcu_node(rnp);\n\n\t/* If no pending (not yet ready to invoke) callbacks, nothing to do. */\n\tif (!rcu_segcblist_pend_cbs(&rdp->cblist))\n\t\treturn false;\n\n\ttrace_rcu_segcb_stats(&rdp->cblist, TPS(\"SegCbPreAcc\"));\n\n\t/*\n\t * Callbacks are often registered with incomplete grace-period\n\t * information.  Something about the fact that getting exact\n\t * information requires acquiring a global lock...  RCU therefore\n\t * makes a conservative estimate of the grace period number at which\n\t * a given callback will become ready to invoke.\tThe following\n\t * code checks this estimate and improves it when possible, thus\n\t * accelerating callback invocation to an earlier grace-period\n\t * number.\n\t */\n\tgp_seq_req = rcu_seq_snap(&rcu_state.gp_seq);\n\tif (rcu_segcblist_accelerate(&rdp->cblist, gp_seq_req))\n\t\tret = rcu_start_this_gp(rnp, rdp, gp_seq_req);\n\n\t/* Trace depending on how much we were able to accelerate. */\n\tif (rcu_segcblist_restempty(&rdp->cblist, RCU_WAIT_TAIL))\n\t\ttrace_rcu_grace_period(rcu_state.name, gp_seq_req, TPS(\"AccWaitCB\"));\n\telse\n\t\ttrace_rcu_grace_period(rcu_state.name, gp_seq_req, TPS(\"AccReadyCB\"));\n\n\ttrace_rcu_segcb_stats(&rdp->cblist, TPS(\"SegCbPostAcc\"));\n\n\treturn ret;\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_nocb.h\"",
      "#include \"tree_exp.h\"",
      "#include \"tree_stall.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <linux/kasan.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/panic_notifier.h>",
      "#include <linux/panic.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};",
      "static struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};",
      "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
      "static void check_cb_ovld_locked(struct rcu_data *rdp, struct rcu_node *rnp);",
      "static bool rcu_rdp_is_offloaded(struct rcu_data *rdp);",
      "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_rcu_segcb_stats",
          "args": [
            "&rdp->cblist",
            "TPS(\"SegCbPostAcc\")"
          ],
          "line": 1531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPS",
          "args": [
            "\"SegCbPostAcc\""
          ],
          "line": 1531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_rcu_grace_period",
          "args": [
            "rcu_state.name",
            "gp_seq_req",
            "TPS(\"AccReadyCB\")"
          ],
          "line": 1529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPS",
          "args": [
            "\"AccReadyCB\""
          ],
          "line": 1529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_rcu_grace_period",
          "args": [
            "rcu_state.name",
            "gp_seq_req",
            "TPS(\"AccWaitCB\")"
          ],
          "line": 1527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPS",
          "args": [
            "\"AccWaitCB\""
          ],
          "line": 1527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_segcblist_restempty",
          "args": [
            "&rdp->cblist",
            "RCU_WAIT_TAIL"
          ],
          "line": 1526
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_restempty",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "110-113",
          "snippet": "static inline bool rcu_segcblist_restempty(struct rcu_segcblist *rsclp, int seg)\n{\n\treturn !READ_ONCE(*READ_ONCE(rsclp->tails[seg]));\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "long rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nlong rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_restempty(struct rcu_segcblist *rsclp, int seg)\n{\n\treturn !READ_ONCE(*READ_ONCE(rsclp->tails[seg]));\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_start_this_gp",
          "args": [
            "rnp",
            "rdp",
            "gp_seq_req"
          ],
          "line": 1523
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_start_this_gp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "1370-1439",
          "snippet": "static bool rcu_start_this_gp(struct rcu_node *rnp_start, struct rcu_data *rdp,\n\t\t\t      unsigned long gp_seq_req)\n{\n\tbool ret = false;\n\tstruct rcu_node *rnp;\n\n\t/*\n\t * Use funnel locking to either acquire the root rcu_node\n\t * structure's lock or bail out if the need for this grace period\n\t * has already been recorded -- or if that grace period has in\n\t * fact already started.  If there is already a grace period in\n\t * progress in a non-leaf node, no recording is needed because the\n\t * end of the grace period will scan the leaf rcu_node structures.\n\t * Note that rnp_start->lock must not be released.\n\t */\n\traw_lockdep_assert_held_rcu_node(rnp_start);\n\ttrace_rcu_this_gp(rnp_start, rdp, gp_seq_req, TPS(\"Startleaf\"));\n\tfor (rnp = rnp_start; 1; rnp = rnp->parent) {\n\t\tif (rnp != rnp_start)\n\t\t\traw_spin_lock_rcu_node(rnp);\n\t\tif (ULONG_CMP_GE(rnp->gp_seq_needed, gp_seq_req) ||\n\t\t    rcu_seq_started(&rnp->gp_seq, gp_seq_req) ||\n\t\t    (rnp != rnp_start &&\n\t\t     rcu_seq_state(rcu_seq_current(&rnp->gp_seq)))) {\n\t\t\ttrace_rcu_this_gp(rnp, rdp, gp_seq_req,\n\t\t\t\t\t  TPS(\"Prestarted\"));\n\t\t\tgoto unlock_out;\n\t\t}\n\t\tWRITE_ONCE(rnp->gp_seq_needed, gp_seq_req);\n\t\tif (rcu_seq_state(rcu_seq_current(&rnp->gp_seq))) {\n\t\t\t/*\n\t\t\t * We just marked the leaf or internal node, and a\n\t\t\t * grace period is in progress, which means that\n\t\t\t * rcu_gp_cleanup() will see the marking.  Bail to\n\t\t\t * reduce contention.\n\t\t\t */\n\t\t\ttrace_rcu_this_gp(rnp_start, rdp, gp_seq_req,\n\t\t\t\t\t  TPS(\"Startedleaf\"));\n\t\t\tgoto unlock_out;\n\t\t}\n\t\tif (rnp != rnp_start && rnp->parent != NULL)\n\t\t\traw_spin_unlock_rcu_node(rnp);\n\t\tif (!rnp->parent)\n\t\t\tbreak;  /* At root, and perhaps also leaf. */\n\t}\n\n\t/* If GP already in progress, just leave, otherwise start one. */\n\tif (rcu_gp_in_progress()) {\n\t\ttrace_rcu_this_gp(rnp, rdp, gp_seq_req, TPS(\"Startedleafroot\"));\n\t\tgoto unlock_out;\n\t}\n\ttrace_rcu_this_gp(rnp, rdp, gp_seq_req, TPS(\"Startedroot\"));\n\tWRITE_ONCE(rcu_state.gp_flags, rcu_state.gp_flags | RCU_GP_FLAG_INIT);\n\tWRITE_ONCE(rcu_state.gp_req_activity, jiffies);\n\tif (!READ_ONCE(rcu_state.gp_kthread)) {\n\t\ttrace_rcu_this_gp(rnp, rdp, gp_seq_req, TPS(\"NoGPkthread\"));\n\t\tgoto unlock_out;\n\t}\n\ttrace_rcu_grace_period(rcu_state.name, data_race(rcu_state.gp_seq), TPS(\"newreq\"));\n\tret = true;  /* Caller must wake GP kthread. */\nunlock_out:\n\t/* Push furthest requested GP to leaf node and rcu_data structure. */\n\tif (ULONG_CMP_LT(gp_seq_req, rnp->gp_seq_needed)) {\n\t\tWRITE_ONCE(rnp_start->gp_seq_needed, rnp->gp_seq_needed);\n\t\tWRITE_ONCE(rdp->gp_seq_needed, rnp->gp_seq_needed);\n\t}\n\tif (rnp != rnp_start)\n\t\traw_spin_unlock_rcu_node(rnp);\n\treturn ret;\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};",
            "static struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};",
            "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
            "static void check_cb_ovld_locked(struct rcu_data *rdp, struct rcu_node *rnp);",
            "static bool rcu_rdp_is_offloaded(struct rcu_data *rdp);",
            "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};\nstatic struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void check_cb_ovld_locked(struct rcu_data *rdp, struct rcu_node *rnp);\nstatic bool rcu_rdp_is_offloaded(struct rcu_data *rdp);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nstatic bool rcu_start_this_gp(struct rcu_node *rnp_start, struct rcu_data *rdp,\n\t\t\t      unsigned long gp_seq_req)\n{\n\tbool ret = false;\n\tstruct rcu_node *rnp;\n\n\t/*\n\t * Use funnel locking to either acquire the root rcu_node\n\t * structure's lock or bail out if the need for this grace period\n\t * has already been recorded -- or if that grace period has in\n\t * fact already started.  If there is already a grace period in\n\t * progress in a non-leaf node, no recording is needed because the\n\t * end of the grace period will scan the leaf rcu_node structures.\n\t * Note that rnp_start->lock must not be released.\n\t */\n\traw_lockdep_assert_held_rcu_node(rnp_start);\n\ttrace_rcu_this_gp(rnp_start, rdp, gp_seq_req, TPS(\"Startleaf\"));\n\tfor (rnp = rnp_start; 1; rnp = rnp->parent) {\n\t\tif (rnp != rnp_start)\n\t\t\traw_spin_lock_rcu_node(rnp);\n\t\tif (ULONG_CMP_GE(rnp->gp_seq_needed, gp_seq_req) ||\n\t\t    rcu_seq_started(&rnp->gp_seq, gp_seq_req) ||\n\t\t    (rnp != rnp_start &&\n\t\t     rcu_seq_state(rcu_seq_current(&rnp->gp_seq)))) {\n\t\t\ttrace_rcu_this_gp(rnp, rdp, gp_seq_req,\n\t\t\t\t\t  TPS(\"Prestarted\"));\n\t\t\tgoto unlock_out;\n\t\t}\n\t\tWRITE_ONCE(rnp->gp_seq_needed, gp_seq_req);\n\t\tif (rcu_seq_state(rcu_seq_current(&rnp->gp_seq))) {\n\t\t\t/*\n\t\t\t * We just marked the leaf or internal node, and a\n\t\t\t * grace period is in progress, which means that\n\t\t\t * rcu_gp_cleanup() will see the marking.  Bail to\n\t\t\t * reduce contention.\n\t\t\t */\n\t\t\ttrace_rcu_this_gp(rnp_start, rdp, gp_seq_req,\n\t\t\t\t\t  TPS(\"Startedleaf\"));\n\t\t\tgoto unlock_out;\n\t\t}\n\t\tif (rnp != rnp_start && rnp->parent != NULL)\n\t\t\traw_spin_unlock_rcu_node(rnp);\n\t\tif (!rnp->parent)\n\t\t\tbreak;  /* At root, and perhaps also leaf. */\n\t}\n\n\t/* If GP already in progress, just leave, otherwise start one. */\n\tif (rcu_gp_in_progress()) {\n\t\ttrace_rcu_this_gp(rnp, rdp, gp_seq_req, TPS(\"Startedleafroot\"));\n\t\tgoto unlock_out;\n\t}\n\ttrace_rcu_this_gp(rnp, rdp, gp_seq_req, TPS(\"Startedroot\"));\n\tWRITE_ONCE(rcu_state.gp_flags, rcu_state.gp_flags | RCU_GP_FLAG_INIT);\n\tWRITE_ONCE(rcu_state.gp_req_activity, jiffies);\n\tif (!READ_ONCE(rcu_state.gp_kthread)) {\n\t\ttrace_rcu_this_gp(rnp, rdp, gp_seq_req, TPS(\"NoGPkthread\"));\n\t\tgoto unlock_out;\n\t}\n\ttrace_rcu_grace_period(rcu_state.name, data_race(rcu_state.gp_seq), TPS(\"newreq\"));\n\tret = true;  /* Caller must wake GP kthread. */\nunlock_out:\n\t/* Push furthest requested GP to leaf node and rcu_data structure. */\n\tif (ULONG_CMP_LT(gp_seq_req, rnp->gp_seq_needed)) {\n\t\tWRITE_ONCE(rnp_start->gp_seq_needed, rnp->gp_seq_needed);\n\t\tWRITE_ONCE(rdp->gp_seq_needed, rnp->gp_seq_needed);\n\t}\n\tif (rnp != rnp_start)\n\t\traw_spin_unlock_rcu_node(rnp);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_segcblist_accelerate",
          "args": [
            "&rdp->cblist",
            "gp_seq_req"
          ],
          "line": 1522
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_accelerate",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.c",
          "lines": "537-598",
          "snippet": "bool rcu_segcblist_accelerate(struct rcu_segcblist *rsclp, unsigned long seq)\n{\n\tint i, j;\n\n\tWARN_ON_ONCE(!rcu_segcblist_is_enabled(rsclp));\n\tif (rcu_segcblist_restempty(rsclp, RCU_DONE_TAIL))\n\t\treturn false;\n\n\t/*\n\t * Find the segment preceding the oldest segment of callbacks\n\t * whose ->gp_seq[] completion is at or after that passed in via\n\t * \"seq\", skipping any empty segments.  This oldest segment, along\n\t * with any later segments, can be merged in with any newly arrived\n\t * callbacks in the RCU_NEXT_TAIL segment, and assigned \"seq\"\n\t * as their ->gp_seq[] grace-period completion sequence number.\n\t */\n\tfor (i = RCU_NEXT_READY_TAIL; i > RCU_DONE_TAIL; i--)\n\t\tif (rsclp->tails[i] != rsclp->tails[i - 1] &&\n\t\t    ULONG_CMP_LT(rsclp->gp_seq[i], seq))\n\t\t\tbreak;\n\n\t/*\n\t * If all the segments contain callbacks that correspond to\n\t * earlier grace-period sequence numbers than \"seq\", leave.\n\t * Assuming that the rcu_segcblist structure has enough\n\t * segments in its arrays, this can only happen if some of\n\t * the non-done segments contain callbacks that really are\n\t * ready to invoke.  This situation will get straightened\n\t * out by the next call to rcu_segcblist_advance().\n\t *\n\t * Also advance to the oldest segment of callbacks whose\n\t * ->gp_seq[] completion is at or after that passed in via \"seq\",\n\t * skipping any empty segments.\n\t *\n\t * Note that segment \"i\" (and any lower-numbered segments\n\t * containing older callbacks) will be unaffected, and their\n\t * grace-period numbers remain unchanged.  For example, if i ==\n\t * WAIT_TAIL, then neither WAIT_TAIL nor DONE_TAIL will be touched.\n\t * Instead, the CBs in NEXT_TAIL will be merged with those in\n\t * NEXT_READY_TAIL and the grace-period number of NEXT_READY_TAIL\n\t * would be updated.  NEXT_TAIL would then be empty.\n\t */\n\tif (rcu_segcblist_restempty(rsclp, i) || ++i >= RCU_NEXT_TAIL)\n\t\treturn false;\n\n\t/* Accounting: everything below i is about to get merged into i. */\n\tfor (j = i + 1; j <= RCU_NEXT_TAIL; j++)\n\t\trcu_segcblist_move_seglen(rsclp, j, i);\n\n\t/*\n\t * Merge all later callbacks, including newly arrived callbacks,\n\t * into the segment located by the for-loop above.  Assign \"seq\"\n\t * as the ->gp_seq[] value in order to correctly handle the case\n\t * where there were no pending callbacks in the rcu_segcblist\n\t * structure other than in the RCU_NEXT_TAIL segment.\n\t */\n\tfor (; i < RCU_NEXT_TAIL; i++) {\n\t\tWRITE_ONCE(rsclp->tails[i], rsclp->tails[RCU_NEXT_TAIL]);\n\t\trsclp->gp_seq[i] = seq;\n\t}\n\treturn true;\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/cpu.h>\n\nbool rcu_segcblist_accelerate(struct rcu_segcblist *rsclp, unsigned long seq)\n{\n\tint i, j;\n\n\tWARN_ON_ONCE(!rcu_segcblist_is_enabled(rsclp));\n\tif (rcu_segcblist_restempty(rsclp, RCU_DONE_TAIL))\n\t\treturn false;\n\n\t/*\n\t * Find the segment preceding the oldest segment of callbacks\n\t * whose ->gp_seq[] completion is at or after that passed in via\n\t * \"seq\", skipping any empty segments.  This oldest segment, along\n\t * with any later segments, can be merged in with any newly arrived\n\t * callbacks in the RCU_NEXT_TAIL segment, and assigned \"seq\"\n\t * as their ->gp_seq[] grace-period completion sequence number.\n\t */\n\tfor (i = RCU_NEXT_READY_TAIL; i > RCU_DONE_TAIL; i--)\n\t\tif (rsclp->tails[i] != rsclp->tails[i - 1] &&\n\t\t    ULONG_CMP_LT(rsclp->gp_seq[i], seq))\n\t\t\tbreak;\n\n\t/*\n\t * If all the segments contain callbacks that correspond to\n\t * earlier grace-period sequence numbers than \"seq\", leave.\n\t * Assuming that the rcu_segcblist structure has enough\n\t * segments in its arrays, this can only happen if some of\n\t * the non-done segments contain callbacks that really are\n\t * ready to invoke.  This situation will get straightened\n\t * out by the next call to rcu_segcblist_advance().\n\t *\n\t * Also advance to the oldest segment of callbacks whose\n\t * ->gp_seq[] completion is at or after that passed in via \"seq\",\n\t * skipping any empty segments.\n\t *\n\t * Note that segment \"i\" (and any lower-numbered segments\n\t * containing older callbacks) will be unaffected, and their\n\t * grace-period numbers remain unchanged.  For example, if i ==\n\t * WAIT_TAIL, then neither WAIT_TAIL nor DONE_TAIL will be touched.\n\t * Instead, the CBs in NEXT_TAIL will be merged with those in\n\t * NEXT_READY_TAIL and the grace-period number of NEXT_READY_TAIL\n\t * would be updated.  NEXT_TAIL would then be empty.\n\t */\n\tif (rcu_segcblist_restempty(rsclp, i) || ++i >= RCU_NEXT_TAIL)\n\t\treturn false;\n\n\t/* Accounting: everything below i is about to get merged into i. */\n\tfor (j = i + 1; j <= RCU_NEXT_TAIL; j++)\n\t\trcu_segcblist_move_seglen(rsclp, j, i);\n\n\t/*\n\t * Merge all later callbacks, including newly arrived callbacks,\n\t * into the segment located by the for-loop above.  Assign \"seq\"\n\t * as the ->gp_seq[] value in order to correctly handle the case\n\t * where there were no pending callbacks in the rcu_segcblist\n\t * structure other than in the RCU_NEXT_TAIL segment.\n\t */\n\tfor (; i < RCU_NEXT_TAIL; i++) {\n\t\tWRITE_ONCE(rsclp->tails[i], rsclp->tails[RCU_NEXT_TAIL]);\n\t\trsclp->gp_seq[i] = seq;\n\t}\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_seq_snap",
          "args": [
            "&rcu_state.gp_seq"
          ],
          "line": 1521
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_seq_snap",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu.h",
          "lines": "87-94",
          "snippet": "static inline unsigned long rcu_seq_snap(unsigned long *sp)\n{\n\tunsigned long s;\n\n\ts = (READ_ONCE(*sp) + 2 * RCU_SEQ_STATE_MASK + 1) & ~RCU_SEQ_STATE_MASK;\n\tsmp_mb(); /* Above access must not bleed into critical section. */\n\treturn s;\n}",
          "includes": [
            "#include <linux/rcu_node_tree.h>",
            "#include <trace/events/rcu.h>"
          ],
          "macros_used": [
            "#define RCU_SEQ_STATE_MASK\t((1 << RCU_SEQ_CTR_SHIFT) - 1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_node_tree.h>\n#include <trace/events/rcu.h>\n\n#define RCU_SEQ_STATE_MASK\t((1 << RCU_SEQ_CTR_SHIFT) - 1)\n\nstatic inline unsigned long rcu_seq_snap(unsigned long *sp)\n{\n\tunsigned long s;\n\n\ts = (READ_ONCE(*sp) + 2 * RCU_SEQ_STATE_MASK + 1) & ~RCU_SEQ_STATE_MASK;\n\tsmp_mb(); /* Above access must not bleed into critical section. */\n\treturn s;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_rcu_segcb_stats",
          "args": [
            "&rdp->cblist",
            "TPS(\"SegCbPreAcc\")"
          ],
          "line": 1509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPS",
          "args": [
            "\"SegCbPreAcc\""
          ],
          "line": 1509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_segcblist_pend_cbs",
          "args": [
            "&rdp->cblist"
          ],
          "line": 1506
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_pend_cbs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.c",
          "lines": "288-292",
          "snippet": "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp)\n{\n\treturn rcu_segcblist_is_enabled(rsclp) &&\n\t       !rcu_segcblist_restempty(rsclp, RCU_DONE_TAIL);\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/cpu.h>\n\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp)\n{\n\treturn rcu_segcblist_is_enabled(rsclp) &&\n\t       !rcu_segcblist_restempty(rsclp, RCU_DONE_TAIL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_lockdep_assert_held_rcu_node",
          "args": [
            "rnp"
          ],
          "line": 1503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_lockdep_assert_cblist_protected",
          "args": [
            "rdp"
          ],
          "line": 1502
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_lockdep_assert_cblist_protected",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_nocb.h",
          "lines": "1486-1489",
          "snippet": "static void rcu_lockdep_assert_cblist_protected(struct rcu_data *rdp)\n{\n\tlockdep_assert_irqs_disabled();\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static void rcu_lockdep_assert_cblist_protected(struct rcu_data *rdp)\n{\n\tlockdep_assert_irqs_disabled();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};\nstatic struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void check_cb_ovld_locked(struct rcu_data *rdp, struct rcu_node *rnp);\nstatic bool rcu_rdp_is_offloaded(struct rcu_data *rdp);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nstatic bool rcu_accelerate_cbs(struct rcu_node *rnp, struct rcu_data *rdp)\n{\n\tunsigned long gp_seq_req;\n\tbool ret = false;\n\n\trcu_lockdep_assert_cblist_protected(rdp);\n\traw_lockdep_assert_held_rcu_node(rnp);\n\n\t/* If no pending (not yet ready to invoke) callbacks, nothing to do. */\n\tif (!rcu_segcblist_pend_cbs(&rdp->cblist))\n\t\treturn false;\n\n\ttrace_rcu_segcb_stats(&rdp->cblist, TPS(\"SegCbPreAcc\"));\n\n\t/*\n\t * Callbacks are often registered with incomplete grace-period\n\t * information.  Something about the fact that getting exact\n\t * information requires acquiring a global lock...  RCU therefore\n\t * makes a conservative estimate of the grace period number at which\n\t * a given callback will become ready to invoke.\tThe following\n\t * code checks this estimate and improves it when possible, thus\n\t * accelerating callback invocation to an earlier grace-period\n\t * number.\n\t */\n\tgp_seq_req = rcu_seq_snap(&rcu_state.gp_seq);\n\tif (rcu_segcblist_accelerate(&rdp->cblist, gp_seq_req))\n\t\tret = rcu_start_this_gp(rnp, rdp, gp_seq_req);\n\n\t/* Trace depending on how much we were able to accelerate. */\n\tif (rcu_segcblist_restempty(&rdp->cblist, RCU_WAIT_TAIL))\n\t\ttrace_rcu_grace_period(rcu_state.name, gp_seq_req, TPS(\"AccWaitCB\"));\n\telse\n\t\ttrace_rcu_grace_period(rcu_state.name, gp_seq_req, TPS(\"AccReadyCB\"));\n\n\ttrace_rcu_segcb_stats(&rdp->cblist, TPS(\"SegCbPostAcc\"));\n\n\treturn ret;\n}"
  },
  {
    "function_name": "rcu_gp_kthread_wake",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
    "lines": "1473-1483",
    "snippet": "static void rcu_gp_kthread_wake(void)\n{\n\tstruct task_struct *t = READ_ONCE(rcu_state.gp_kthread);\n\n\tif ((current == t && !in_hardirq() && !in_serving_softirq()) ||\n\t    !READ_ONCE(rcu_state.gp_flags) || !t)\n\t\treturn;\n\tWRITE_ONCE(rcu_state.gp_wake_time, jiffies);\n\tWRITE_ONCE(rcu_state.gp_wake_seq, READ_ONCE(rcu_state.gp_seq));\n\tswake_up_one(&rcu_state.gp_wq);\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_nocb.h\"",
      "#include \"tree_exp.h\"",
      "#include \"tree_stall.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <linux/kasan.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/panic_notifier.h>",
      "#include <linux/panic.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "swake_up_one",
          "args": [
            "&rcu_state.gp_wq"
          ],
          "line": 1482
        },
        "resolved": true,
        "details": {
          "function_name": "swake_up_one",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/swait.c",
          "lines": "48-55",
          "snippet": "void swake_up_one(struct swait_queue_head *q)\n{\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&q->lock, flags);\n\tswake_up_locked(q);\n\traw_spin_unlock_irqrestore(&q->lock, flags);\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nvoid swake_up_one(struct swait_queue_head *q)\n{\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&q->lock, flags);\n\tswake_up_locked(q);\n\traw_spin_unlock_irqrestore(&q->lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "rcu_state.gp_wake_seq",
            "READ_ONCE(rcu_state.gp_seq)"
          ],
          "line": 1481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rcu_state.gp_seq"
          ],
          "line": 1481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "rcu_state.gp_wake_time",
            "jiffies"
          ],
          "line": 1480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rcu_state.gp_flags"
          ],
          "line": 1478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_serving_softirq",
          "args": [],
          "line": 1477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_hardirq",
          "args": [],
          "line": 1477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rcu_state.gp_kthread"
          ],
          "line": 1475
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\n\nstatic void rcu_gp_kthread_wake(void)\n{\n\tstruct task_struct *t = READ_ONCE(rcu_state.gp_kthread);\n\n\tif ((current == t && !in_hardirq() && !in_serving_softirq()) ||\n\t    !READ_ONCE(rcu_state.gp_flags) || !t)\n\t\treturn;\n\tWRITE_ONCE(rcu_state.gp_wake_time, jiffies);\n\tWRITE_ONCE(rcu_state.gp_wake_seq, READ_ONCE(rcu_state.gp_seq));\n\tswake_up_one(&rcu_state.gp_wq);\n}"
  },
  {
    "function_name": "rcu_future_gp_cleanup",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
    "lines": "1445-1456",
    "snippet": "static bool rcu_future_gp_cleanup(struct rcu_node *rnp)\n{\n\tbool needmore;\n\tstruct rcu_data *rdp = this_cpu_ptr(&rcu_data);\n\n\tneedmore = ULONG_CMP_LT(rnp->gp_seq, rnp->gp_seq_needed);\n\tif (!needmore)\n\t\trnp->gp_seq_needed = rnp->gp_seq; /* Avoid counter wrap. */\n\ttrace_rcu_this_gp(rnp, rdp, rnp->gp_seq,\n\t\t\t  needmore ? TPS(\"CleanupMore\") : TPS(\"Cleanup\"));\n\treturn needmore;\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_nocb.h\"",
      "#include \"tree_exp.h\"",
      "#include \"tree_stall.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <linux/kasan.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/panic_notifier.h>",
      "#include <linux/panic.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};",
      "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
      "static void check_cb_ovld_locked(struct rcu_data *rdp, struct rcu_node *rnp);",
      "static bool rcu_rdp_is_offloaded(struct rcu_data *rdp);",
      "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_rcu_this_gp",
          "args": [
            "rnp",
            "rdp",
            "rnp->gp_seq",
            "needmore ? TPS(\"CleanupMore\") : TPS(\"Cleanup\")"
          ],
          "line": 1453
        },
        "resolved": true,
        "details": {
          "function_name": "trace_rcu_this_gp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "1346-1352",
          "snippet": "static void trace_rcu_this_gp(struct rcu_node *rnp, struct rcu_data *rdp,\n\t\t\t      unsigned long gp_seq_req, const char *s)\n{\n\ttrace_rcu_future_grace_period(rcu_state.name, READ_ONCE(rnp->gp_seq),\n\t\t\t\t      gp_seq_req, rnp->level,\n\t\t\t\t      rnp->grplo, rnp->grphi, s);\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};",
            "static struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};",
            "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
            "static void check_cb_ovld_locked(struct rcu_data *rdp, struct rcu_node *rnp);",
            "static bool rcu_rdp_is_offloaded(struct rcu_data *rdp);",
            "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};\nstatic struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void check_cb_ovld_locked(struct rcu_data *rdp, struct rcu_node *rnp);\nstatic bool rcu_rdp_is_offloaded(struct rcu_data *rdp);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nstatic void trace_rcu_this_gp(struct rcu_node *rnp, struct rcu_data *rdp,\n\t\t\t      unsigned long gp_seq_req, const char *s)\n{\n\ttrace_rcu_future_grace_period(rcu_state.name, READ_ONCE(rnp->gp_seq),\n\t\t\t\t      gp_seq_req, rnp->level,\n\t\t\t\t      rnp->grplo, rnp->grphi, s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "TPS",
          "args": [
            "\"Cleanup\""
          ],
          "line": 1454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPS",
          "args": [
            "\"CleanupMore\""
          ],
          "line": 1454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ULONG_CMP_LT",
          "args": [
            "rnp->gp_seq",
            "rnp->gp_seq_needed"
          ],
          "line": 1450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&rcu_data"
          ],
          "line": 1448
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void check_cb_ovld_locked(struct rcu_data *rdp, struct rcu_node *rnp);\nstatic bool rcu_rdp_is_offloaded(struct rcu_data *rdp);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nstatic bool rcu_future_gp_cleanup(struct rcu_node *rnp)\n{\n\tbool needmore;\n\tstruct rcu_data *rdp = this_cpu_ptr(&rcu_data);\n\n\tneedmore = ULONG_CMP_LT(rnp->gp_seq, rnp->gp_seq_needed);\n\tif (!needmore)\n\t\trnp->gp_seq_needed = rnp->gp_seq; /* Avoid counter wrap. */\n\ttrace_rcu_this_gp(rnp, rdp, rnp->gp_seq,\n\t\t\t  needmore ? TPS(\"CleanupMore\") : TPS(\"Cleanup\"));\n\treturn needmore;\n}"
  },
  {
    "function_name": "rcu_start_this_gp",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
    "lines": "1370-1439",
    "snippet": "static bool rcu_start_this_gp(struct rcu_node *rnp_start, struct rcu_data *rdp,\n\t\t\t      unsigned long gp_seq_req)\n{\n\tbool ret = false;\n\tstruct rcu_node *rnp;\n\n\t/*\n\t * Use funnel locking to either acquire the root rcu_node\n\t * structure's lock or bail out if the need for this grace period\n\t * has already been recorded -- or if that grace period has in\n\t * fact already started.  If there is already a grace period in\n\t * progress in a non-leaf node, no recording is needed because the\n\t * end of the grace period will scan the leaf rcu_node structures.\n\t * Note that rnp_start->lock must not be released.\n\t */\n\traw_lockdep_assert_held_rcu_node(rnp_start);\n\ttrace_rcu_this_gp(rnp_start, rdp, gp_seq_req, TPS(\"Startleaf\"));\n\tfor (rnp = rnp_start; 1; rnp = rnp->parent) {\n\t\tif (rnp != rnp_start)\n\t\t\traw_spin_lock_rcu_node(rnp);\n\t\tif (ULONG_CMP_GE(rnp->gp_seq_needed, gp_seq_req) ||\n\t\t    rcu_seq_started(&rnp->gp_seq, gp_seq_req) ||\n\t\t    (rnp != rnp_start &&\n\t\t     rcu_seq_state(rcu_seq_current(&rnp->gp_seq)))) {\n\t\t\ttrace_rcu_this_gp(rnp, rdp, gp_seq_req,\n\t\t\t\t\t  TPS(\"Prestarted\"));\n\t\t\tgoto unlock_out;\n\t\t}\n\t\tWRITE_ONCE(rnp->gp_seq_needed, gp_seq_req);\n\t\tif (rcu_seq_state(rcu_seq_current(&rnp->gp_seq))) {\n\t\t\t/*\n\t\t\t * We just marked the leaf or internal node, and a\n\t\t\t * grace period is in progress, which means that\n\t\t\t * rcu_gp_cleanup() will see the marking.  Bail to\n\t\t\t * reduce contention.\n\t\t\t */\n\t\t\ttrace_rcu_this_gp(rnp_start, rdp, gp_seq_req,\n\t\t\t\t\t  TPS(\"Startedleaf\"));\n\t\t\tgoto unlock_out;\n\t\t}\n\t\tif (rnp != rnp_start && rnp->parent != NULL)\n\t\t\traw_spin_unlock_rcu_node(rnp);\n\t\tif (!rnp->parent)\n\t\t\tbreak;  /* At root, and perhaps also leaf. */\n\t}\n\n\t/* If GP already in progress, just leave, otherwise start one. */\n\tif (rcu_gp_in_progress()) {\n\t\ttrace_rcu_this_gp(rnp, rdp, gp_seq_req, TPS(\"Startedleafroot\"));\n\t\tgoto unlock_out;\n\t}\n\ttrace_rcu_this_gp(rnp, rdp, gp_seq_req, TPS(\"Startedroot\"));\n\tWRITE_ONCE(rcu_state.gp_flags, rcu_state.gp_flags | RCU_GP_FLAG_INIT);\n\tWRITE_ONCE(rcu_state.gp_req_activity, jiffies);\n\tif (!READ_ONCE(rcu_state.gp_kthread)) {\n\t\ttrace_rcu_this_gp(rnp, rdp, gp_seq_req, TPS(\"NoGPkthread\"));\n\t\tgoto unlock_out;\n\t}\n\ttrace_rcu_grace_period(rcu_state.name, data_race(rcu_state.gp_seq), TPS(\"newreq\"));\n\tret = true;  /* Caller must wake GP kthread. */\nunlock_out:\n\t/* Push furthest requested GP to leaf node and rcu_data structure. */\n\tif (ULONG_CMP_LT(gp_seq_req, rnp->gp_seq_needed)) {\n\t\tWRITE_ONCE(rnp_start->gp_seq_needed, rnp->gp_seq_needed);\n\t\tWRITE_ONCE(rdp->gp_seq_needed, rnp->gp_seq_needed);\n\t}\n\tif (rnp != rnp_start)\n\t\traw_spin_unlock_rcu_node(rnp);\n\treturn ret;\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_nocb.h\"",
      "#include \"tree_exp.h\"",
      "#include \"tree_stall.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <linux/kasan.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/panic_notifier.h>",
      "#include <linux/panic.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};",
      "static struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};",
      "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
      "static void check_cb_ovld_locked(struct rcu_data *rdp, struct rcu_node *rnp);",
      "static bool rcu_rdp_is_offloaded(struct rcu_data *rdp);",
      "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock_rcu_node",
          "args": [
            "rnp"
          ],
          "line": 1437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "rdp->gp_seq_needed",
            "rnp->gp_seq_needed"
          ],
          "line": 1434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "rnp_start->gp_seq_needed",
            "rnp->gp_seq_needed"
          ],
          "line": 1433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ULONG_CMP_LT",
          "args": [
            "gp_seq_req",
            "rnp->gp_seq_needed"
          ],
          "line": 1432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_rcu_grace_period",
          "args": [
            "rcu_state.name",
            "data_race(rcu_state.gp_seq)",
            "TPS(\"newreq\")"
          ],
          "line": 1428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPS",
          "args": [
            "\"newreq\""
          ],
          "line": 1428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "data_race",
          "args": [
            "rcu_state.gp_seq"
          ],
          "line": 1428
        },
        "resolved": true,
        "details": {
          "function_name": "test_data_race",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/kcsan_test.c",
          "lines": "998-1008",
          "snippet": "__no_kcsan\nstatic void test_data_race(struct kunit *test)\n{\n\tbool match_never = false;\n\n\tbegin_test_checks(test_kernel_data_race, test_kernel_data_race);\n\tdo {\n\t\tmatch_never = report_available();\n\t} while (!end_test_checks(match_never));\n\tKUNIT_EXPECT_FALSE(test, match_never);\n}",
          "includes": [
            "#include <trace/events/printk.h>",
            "#include <linux/types.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/torture.h>",
            "#include <linux/timer.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kcsan-checks.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <kunit/test.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline const struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/printk.h>\n#include <linux/types.h>\n#include <linux/tracepoint.h>\n#include <linux/torture.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/seqlock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/kcsan-checks.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <kunit/test.h>\n\nstatic __always_inline const struct;\n\n__no_kcsan\nstatic void test_data_race(struct kunit *test)\n{\n\tbool match_never = false;\n\n\tbegin_test_checks(test_kernel_data_race, test_kernel_data_race);\n\tdo {\n\t\tmatch_never = report_available();\n\t} while (!end_test_checks(match_never));\n\tKUNIT_EXPECT_FALSE(test, match_never);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_rcu_this_gp",
          "args": [
            "rnp",
            "rdp",
            "gp_seq_req",
            "TPS(\"NoGPkthread\")"
          ],
          "line": 1425
        },
        "resolved": true,
        "details": {
          "function_name": "trace_rcu_this_gp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "1346-1352",
          "snippet": "static void trace_rcu_this_gp(struct rcu_node *rnp, struct rcu_data *rdp,\n\t\t\t      unsigned long gp_seq_req, const char *s)\n{\n\ttrace_rcu_future_grace_period(rcu_state.name, READ_ONCE(rnp->gp_seq),\n\t\t\t\t      gp_seq_req, rnp->level,\n\t\t\t\t      rnp->grplo, rnp->grphi, s);\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};",
            "static struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};",
            "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
            "static void check_cb_ovld_locked(struct rcu_data *rdp, struct rcu_node *rnp);",
            "static bool rcu_rdp_is_offloaded(struct rcu_data *rdp);",
            "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};\nstatic struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void check_cb_ovld_locked(struct rcu_data *rdp, struct rcu_node *rnp);\nstatic bool rcu_rdp_is_offloaded(struct rcu_data *rdp);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nstatic void trace_rcu_this_gp(struct rcu_node *rnp, struct rcu_data *rdp,\n\t\t\t      unsigned long gp_seq_req, const char *s)\n{\n\ttrace_rcu_future_grace_period(rcu_state.name, READ_ONCE(rnp->gp_seq),\n\t\t\t\t      gp_seq_req, rnp->level,\n\t\t\t\t      rnp->grplo, rnp->grphi, s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "TPS",
          "args": [
            "\"NoGPkthread\""
          ],
          "line": 1425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rcu_state.gp_kthread"
          ],
          "line": 1424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "rcu_state.gp_req_activity",
            "jiffies"
          ],
          "line": 1423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "rcu_state.gp_flags",
            "rcu_state.gp_flags | RCU_GP_FLAG_INIT"
          ],
          "line": 1422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPS",
          "args": [
            "\"Startedroot\""
          ],
          "line": 1421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPS",
          "args": [
            "\"Startedleafroot\""
          ],
          "line": 1418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_gp_in_progress",
          "args": [],
          "line": 1417
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_gp_in_progress",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "229-232",
          "snippet": "static int rcu_gp_in_progress(void)\n{\n\treturn rcu_seq_state(rcu_seq_current(&rcu_state.gp_seq));\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\n\nstatic int rcu_gp_in_progress(void)\n{\n\treturn rcu_seq_state(rcu_seq_current(&rcu_state.gp_seq));\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_rcu_node",
          "args": [
            "rnp"
          ],
          "line": 1411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPS",
          "args": [
            "\"Startedleaf\""
          ],
          "line": 1407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_seq_state",
          "args": [
            "rcu_seq_current(&rnp->gp_seq)"
          ],
          "line": 1399
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_seq_state",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu.h",
          "lines": "39-42",
          "snippet": "static inline int rcu_seq_state(unsigned long s)\n{\n\treturn s & RCU_SEQ_STATE_MASK;\n}",
          "includes": [
            "#include <linux/rcu_node_tree.h>",
            "#include <trace/events/rcu.h>"
          ],
          "macros_used": [
            "#define RCU_SEQ_STATE_MASK\t((1 << RCU_SEQ_CTR_SHIFT) - 1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_node_tree.h>\n#include <trace/events/rcu.h>\n\n#define RCU_SEQ_STATE_MASK\t((1 << RCU_SEQ_CTR_SHIFT) - 1)\n\nstatic inline int rcu_seq_state(unsigned long s)\n{\n\treturn s & RCU_SEQ_STATE_MASK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_seq_current",
          "args": [
            "&rnp->gp_seq"
          ],
          "line": 1399
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_seq_current",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu.h",
          "lines": "97-100",
          "snippet": "static inline unsigned long rcu_seq_current(unsigned long *sp)\n{\n\treturn READ_ONCE(*sp);\n}",
          "includes": [
            "#include <linux/rcu_node_tree.h>",
            "#include <trace/events/rcu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_node_tree.h>\n#include <trace/events/rcu.h>\n\nstatic inline unsigned long rcu_seq_current(unsigned long *sp)\n{\n\treturn READ_ONCE(*sp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "rnp->gp_seq_needed",
            "gp_seq_req"
          ],
          "line": 1398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPS",
          "args": [
            "\"Prestarted\""
          ],
          "line": 1395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_seq_started",
          "args": [
            "&rnp->gp_seq",
            "gp_seq_req"
          ],
          "line": 1391
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_seq_started",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu.h",
          "lines": "106-109",
          "snippet": "static inline bool rcu_seq_started(unsigned long *sp, unsigned long s)\n{\n\treturn ULONG_CMP_LT((s - 1) & ~RCU_SEQ_STATE_MASK, READ_ONCE(*sp));\n}",
          "includes": [
            "#include <linux/rcu_node_tree.h>",
            "#include <trace/events/rcu.h>"
          ],
          "macros_used": [
            "#define RCU_SEQ_STATE_MASK\t((1 << RCU_SEQ_CTR_SHIFT) - 1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_node_tree.h>\n#include <trace/events/rcu.h>\n\n#define RCU_SEQ_STATE_MASK\t((1 << RCU_SEQ_CTR_SHIFT) - 1)\n\nstatic inline bool rcu_seq_started(unsigned long *sp, unsigned long s)\n{\n\treturn ULONG_CMP_LT((s - 1) & ~RCU_SEQ_STATE_MASK, READ_ONCE(*sp));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ULONG_CMP_GE",
          "args": [
            "rnp->gp_seq_needed",
            "gp_seq_req"
          ],
          "line": 1390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_rcu_node",
          "args": [
            "rnp"
          ],
          "line": 1389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPS",
          "args": [
            "\"Startleaf\""
          ],
          "line": 1386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_lockdep_assert_held_rcu_node",
          "args": [
            "rnp_start"
          ],
          "line": 1385
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};\nstatic struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void check_cb_ovld_locked(struct rcu_data *rdp, struct rcu_node *rnp);\nstatic bool rcu_rdp_is_offloaded(struct rcu_data *rdp);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nstatic bool rcu_start_this_gp(struct rcu_node *rnp_start, struct rcu_data *rdp,\n\t\t\t      unsigned long gp_seq_req)\n{\n\tbool ret = false;\n\tstruct rcu_node *rnp;\n\n\t/*\n\t * Use funnel locking to either acquire the root rcu_node\n\t * structure's lock or bail out if the need for this grace period\n\t * has already been recorded -- or if that grace period has in\n\t * fact already started.  If there is already a grace period in\n\t * progress in a non-leaf node, no recording is needed because the\n\t * end of the grace period will scan the leaf rcu_node structures.\n\t * Note that rnp_start->lock must not be released.\n\t */\n\traw_lockdep_assert_held_rcu_node(rnp_start);\n\ttrace_rcu_this_gp(rnp_start, rdp, gp_seq_req, TPS(\"Startleaf\"));\n\tfor (rnp = rnp_start; 1; rnp = rnp->parent) {\n\t\tif (rnp != rnp_start)\n\t\t\traw_spin_lock_rcu_node(rnp);\n\t\tif (ULONG_CMP_GE(rnp->gp_seq_needed, gp_seq_req) ||\n\t\t    rcu_seq_started(&rnp->gp_seq, gp_seq_req) ||\n\t\t    (rnp != rnp_start &&\n\t\t     rcu_seq_state(rcu_seq_current(&rnp->gp_seq)))) {\n\t\t\ttrace_rcu_this_gp(rnp, rdp, gp_seq_req,\n\t\t\t\t\t  TPS(\"Prestarted\"));\n\t\t\tgoto unlock_out;\n\t\t}\n\t\tWRITE_ONCE(rnp->gp_seq_needed, gp_seq_req);\n\t\tif (rcu_seq_state(rcu_seq_current(&rnp->gp_seq))) {\n\t\t\t/*\n\t\t\t * We just marked the leaf or internal node, and a\n\t\t\t * grace period is in progress, which means that\n\t\t\t * rcu_gp_cleanup() will see the marking.  Bail to\n\t\t\t * reduce contention.\n\t\t\t */\n\t\t\ttrace_rcu_this_gp(rnp_start, rdp, gp_seq_req,\n\t\t\t\t\t  TPS(\"Startedleaf\"));\n\t\t\tgoto unlock_out;\n\t\t}\n\t\tif (rnp != rnp_start && rnp->parent != NULL)\n\t\t\traw_spin_unlock_rcu_node(rnp);\n\t\tif (!rnp->parent)\n\t\t\tbreak;  /* At root, and perhaps also leaf. */\n\t}\n\n\t/* If GP already in progress, just leave, otherwise start one. */\n\tif (rcu_gp_in_progress()) {\n\t\ttrace_rcu_this_gp(rnp, rdp, gp_seq_req, TPS(\"Startedleafroot\"));\n\t\tgoto unlock_out;\n\t}\n\ttrace_rcu_this_gp(rnp, rdp, gp_seq_req, TPS(\"Startedroot\"));\n\tWRITE_ONCE(rcu_state.gp_flags, rcu_state.gp_flags | RCU_GP_FLAG_INIT);\n\tWRITE_ONCE(rcu_state.gp_req_activity, jiffies);\n\tif (!READ_ONCE(rcu_state.gp_kthread)) {\n\t\ttrace_rcu_this_gp(rnp, rdp, gp_seq_req, TPS(\"NoGPkthread\"));\n\t\tgoto unlock_out;\n\t}\n\ttrace_rcu_grace_period(rcu_state.name, data_race(rcu_state.gp_seq), TPS(\"newreq\"));\n\tret = true;  /* Caller must wake GP kthread. */\nunlock_out:\n\t/* Push furthest requested GP to leaf node and rcu_data structure. */\n\tif (ULONG_CMP_LT(gp_seq_req, rnp->gp_seq_needed)) {\n\t\tWRITE_ONCE(rnp_start->gp_seq_needed, rnp->gp_seq_needed);\n\t\tWRITE_ONCE(rdp->gp_seq_needed, rnp->gp_seq_needed);\n\t}\n\tif (rnp != rnp_start)\n\t\traw_spin_unlock_rcu_node(rnp);\n\treturn ret;\n}"
  },
  {
    "function_name": "trace_rcu_this_gp",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
    "lines": "1346-1352",
    "snippet": "static void trace_rcu_this_gp(struct rcu_node *rnp, struct rcu_data *rdp,\n\t\t\t      unsigned long gp_seq_req, const char *s)\n{\n\ttrace_rcu_future_grace_period(rcu_state.name, READ_ONCE(rnp->gp_seq),\n\t\t\t\t      gp_seq_req, rnp->level,\n\t\t\t\t      rnp->grplo, rnp->grphi, s);\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_nocb.h\"",
      "#include \"tree_exp.h\"",
      "#include \"tree_stall.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <linux/kasan.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/panic_notifier.h>",
      "#include <linux/panic.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};",
      "static struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};",
      "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
      "static void check_cb_ovld_locked(struct rcu_data *rdp, struct rcu_node *rnp);",
      "static bool rcu_rdp_is_offloaded(struct rcu_data *rdp);",
      "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_rcu_future_grace_period",
          "args": [
            "rcu_state.name",
            "READ_ONCE(rnp->gp_seq)",
            "gp_seq_req",
            "rnp->level",
            "rnp->grplo",
            "rnp->grphi",
            "s"
          ],
          "line": 1349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rnp->gp_seq"
          ],
          "line": 1349
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};\nstatic struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void check_cb_ovld_locked(struct rcu_data *rdp, struct rcu_node *rnp);\nstatic bool rcu_rdp_is_offloaded(struct rcu_data *rdp);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nstatic void trace_rcu_this_gp(struct rcu_node *rnp, struct rcu_data *rdp,\n\t\t\t      unsigned long gp_seq_req, const char *s)\n{\n\ttrace_rcu_future_grace_period(rcu_state.name, READ_ONCE(rnp->gp_seq),\n\t\t\t\t      gp_seq_req, rnp->level,\n\t\t\t\t      rnp->grplo, rnp->grphi, s);\n}"
  },
  {
    "function_name": "rcu_implicit_dynticks_qs",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
    "lines": "1226-1343",
    "snippet": "static int rcu_implicit_dynticks_qs(struct rcu_data *rdp)\n{\n\tunsigned long jtsq;\n\tstruct rcu_node *rnp = rdp->mynode;\n\n\t/*\n\t * If the CPU passed through or entered a dynticks idle phase with\n\t * no active irq/NMI handlers, then we can safely pretend that the CPU\n\t * already acknowledged the request to pass through a quiescent\n\t * state.  Either way, that CPU cannot possibly be in an RCU\n\t * read-side critical section that started before the beginning\n\t * of the current RCU grace period.\n\t */\n\tif (rcu_dynticks_in_eqs_since(rdp, rdp->dynticks_snap)) {\n\t\ttrace_rcu_fqs(rcu_state.name, rdp->gp_seq, rdp->cpu, TPS(\"dti\"));\n\t\trcu_gpnum_ovf(rnp, rdp);\n\t\treturn 1;\n\t}\n\n\t/*\n\t * Complain if a CPU that is considered to be offline from RCU's\n\t * perspective has not yet reported a quiescent state.  After all,\n\t * the offline CPU should have reported a quiescent state during\n\t * the CPU-offline process, or, failing that, by rcu_gp_init()\n\t * if it ran concurrently with either the CPU going offline or the\n\t * last task on a leaf rcu_node structure exiting its RCU read-side\n\t * critical section while all CPUs corresponding to that structure\n\t * are offline.  This added warning detects bugs in any of these\n\t * code paths.\n\t *\n\t * The rcu_node structure's ->lock is held here, which excludes\n\t * the relevant portions the CPU-hotplug code, the grace-period\n\t * initialization code, and the rcu_read_unlock() code paths.\n\t *\n\t * For more detail, please refer to the \"Hotplug CPU\" section\n\t * of RCU's Requirements documentation.\n\t */\n\tif (WARN_ON_ONCE(!(rdp->grpmask & rcu_rnp_online_cpus(rnp)))) {\n\t\tbool onl;\n\t\tstruct rcu_node *rnp1;\n\n\t\tpr_info(\"%s: grp: %d-%d level: %d ->gp_seq %ld ->completedqs %ld\\n\",\n\t\t\t__func__, rnp->grplo, rnp->grphi, rnp->level,\n\t\t\t(long)rnp->gp_seq, (long)rnp->completedqs);\n\t\tfor (rnp1 = rnp; rnp1; rnp1 = rnp1->parent)\n\t\t\tpr_info(\"%s: %d:%d ->qsmask %#lx ->qsmaskinit %#lx ->qsmaskinitnext %#lx ->rcu_gp_init_mask %#lx\\n\",\n\t\t\t\t__func__, rnp1->grplo, rnp1->grphi, rnp1->qsmask, rnp1->qsmaskinit, rnp1->qsmaskinitnext, rnp1->rcu_gp_init_mask);\n\t\tonl = !!(rdp->grpmask & rcu_rnp_online_cpus(rnp));\n\t\tpr_info(\"%s %d: %c online: %ld(%d) offline: %ld(%d)\\n\",\n\t\t\t__func__, rdp->cpu, \".o\"[onl],\n\t\t\t(long)rdp->rcu_onl_gp_seq, rdp->rcu_onl_gp_flags,\n\t\t\t(long)rdp->rcu_ofl_gp_seq, rdp->rcu_ofl_gp_flags);\n\t\treturn 1; /* Break things loose after complaining. */\n\t}\n\n\t/*\n\t * A CPU running for an extended time within the kernel can\n\t * delay RCU grace periods: (1) At age jiffies_to_sched_qs,\n\t * set .rcu_urgent_qs, (2) At age 2*jiffies_to_sched_qs, set\n\t * both .rcu_need_heavy_qs and .rcu_urgent_qs.  Note that the\n\t * unsynchronized assignments to the per-CPU rcu_need_heavy_qs\n\t * variable are safe because the assignments are repeated if this\n\t * CPU failed to pass through a quiescent state.  This code\n\t * also checks .jiffies_resched in case jiffies_to_sched_qs\n\t * is set way high.\n\t */\n\tjtsq = READ_ONCE(jiffies_to_sched_qs);\n\tif (!READ_ONCE(rdp->rcu_need_heavy_qs) &&\n\t    (time_after(jiffies, rcu_state.gp_start + jtsq * 2) ||\n\t     time_after(jiffies, rcu_state.jiffies_resched) ||\n\t     rcu_state.cbovld)) {\n\t\tWRITE_ONCE(rdp->rcu_need_heavy_qs, true);\n\t\t/* Store rcu_need_heavy_qs before rcu_urgent_qs. */\n\t\tsmp_store_release(&rdp->rcu_urgent_qs, true);\n\t} else if (time_after(jiffies, rcu_state.gp_start + jtsq)) {\n\t\tWRITE_ONCE(rdp->rcu_urgent_qs, true);\n\t}\n\n\t/*\n\t * NO_HZ_FULL CPUs can run in-kernel without rcu_sched_clock_irq!\n\t * The above code handles this, but only for straight cond_resched().\n\t * And some in-kernel loops check need_resched() before calling\n\t * cond_resched(), which defeats the above code for CPUs that are\n\t * running in-kernel with scheduling-clock interrupts disabled.\n\t * So hit them over the head with the resched_cpu() hammer!\n\t */\n\tif (tick_nohz_full_cpu(rdp->cpu) &&\n\t    (time_after(jiffies, READ_ONCE(rdp->last_fqs_resched) + jtsq * 3) ||\n\t     rcu_state.cbovld)) {\n\t\tWRITE_ONCE(rdp->rcu_urgent_qs, true);\n\t\tresched_cpu(rdp->cpu);\n\t\tWRITE_ONCE(rdp->last_fqs_resched, jiffies);\n\t}\n\n\t/*\n\t * If more than halfway to RCU CPU stall-warning time, invoke\n\t * resched_cpu() more frequently to try to loosen things up a bit.\n\t * Also check to see if the CPU is getting hammered with interrupts,\n\t * but only once per grace period, just to keep the IPIs down to\n\t * a dull roar.\n\t */\n\tif (time_after(jiffies, rcu_state.jiffies_resched)) {\n\t\tif (time_after(jiffies,\n\t\t\t       READ_ONCE(rdp->last_fqs_resched) + jtsq)) {\n\t\t\tresched_cpu(rdp->cpu);\n\t\t\tWRITE_ONCE(rdp->last_fqs_resched, jiffies);\n\t\t}\n\t\tif (IS_ENABLED(CONFIG_IRQ_WORK) &&\n\t\t    !rdp->rcu_iw_pending && rdp->rcu_iw_gp_seq != rnp->gp_seq &&\n\t\t    (rnp->ffmask & rdp->grpmask)) {\n\t\t\trdp->rcu_iw_pending = true;\n\t\t\trdp->rcu_iw_gp_seq = rnp->gp_seq;\n\t\t\tirq_work_queue_on(&rdp->rcu_iw, rdp->cpu);\n\t\t}\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_nocb.h\"",
      "#include \"tree_exp.h\"",
      "#include \"tree_stall.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <linux/kasan.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/panic_notifier.h>",
      "#include <linux/panic.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};",
      "static struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};",
      "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
      "static void sync_sched_exp_online_cleanup(int cpu);",
      "static void check_cb_ovld_locked(struct rcu_data *rdp, struct rcu_node *rnp);",
      "static bool rcu_rdp_is_offloaded(struct rcu_data *rdp);",
      "static ulong jiffies_to_sched_qs;",
      "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "irq_work_queue_on",
          "args": [
            "&rdp->rcu_iw",
            "rdp->cpu"
          ],
          "line": 1338
        },
        "resolved": true,
        "details": {
          "function_name": "irq_work_queue_on",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq_work.c",
          "lines": "127-172",
          "snippet": "bool irq_work_queue_on(struct irq_work *work, int cpu)\n{\n#ifndef CONFIG_SMP\n\treturn irq_work_queue(work);\n\n#else /* CONFIG_SMP: */\n\t/* All work should have been flushed before going offline */\n\tWARN_ON_ONCE(cpu_is_offline(cpu));\n\n\t/* Only queue if not already pending */\n\tif (!irq_work_claim(work))\n\t\treturn false;\n\n\tkasan_record_aux_stack(work);\n\n\tpreempt_disable();\n\tif (cpu != smp_processor_id()) {\n\t\t/* Arch remote IPI send/receive backend aren't NMI safe */\n\t\tWARN_ON_ONCE(in_nmi());\n\n\t\t/*\n\t\t * On PREEMPT_RT the items which are not marked as\n\t\t * IRQ_WORK_HARD_IRQ are added to the lazy list and a HARD work\n\t\t * item is used on the remote CPU to wake the thread.\n\t\t */\n\t\tif (IS_ENABLED(CONFIG_PREEMPT_RT) &&\n\t\t    !(atomic_read(&work->node.a_flags) & IRQ_WORK_HARD_IRQ)) {\n\n\t\t\tif (!llist_add(&work->node.llist, &per_cpu(lazy_list, cpu)))\n\t\t\t\tgoto out;\n\n\t\t\twork = &per_cpu(irq_work_wakeup, cpu);\n\t\t\tif (!irq_work_claim(work))\n\t\t\t\tgoto out;\n\t\t}\n\n\t\t__smp_call_single_queue(cpu, &work->node.llist);\n\t} else {\n\t\t__irq_work_queue_local(work);\n\t}\nout:\n\tpreempt_enable();\n\n\treturn true;\n#endif /* CONFIG_SMP */\n}",
          "includes": [
            "#include <linux/kasan.h>",
            "#include <asm/processor.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/smp.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/tick.h>",
            "#include <linux/sched.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/percpu.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>",
            "#include <linux/bug.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct llist_head, lazy_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kasan.h>\n#include <asm/processor.h>\n#include <linux/smpboot.h>\n#include <linux/smp.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/tick.h>\n#include <linux/sched.h>\n#include <linux/irqflags.h>\n#include <linux/hardirq.h>\n#include <linux/percpu.h>\n#include <linux/irq_work.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/bug.h>\n\nstatic DEFINE_PER_CPU(struct llist_head, lazy_list);\n\nbool irq_work_queue_on(struct irq_work *work, int cpu)\n{\n#ifndef CONFIG_SMP\n\treturn irq_work_queue(work);\n\n#else /* CONFIG_SMP: */\n\t/* All work should have been flushed before going offline */\n\tWARN_ON_ONCE(cpu_is_offline(cpu));\n\n\t/* Only queue if not already pending */\n\tif (!irq_work_claim(work))\n\t\treturn false;\n\n\tkasan_record_aux_stack(work);\n\n\tpreempt_disable();\n\tif (cpu != smp_processor_id()) {\n\t\t/* Arch remote IPI send/receive backend aren't NMI safe */\n\t\tWARN_ON_ONCE(in_nmi());\n\n\t\t/*\n\t\t * On PREEMPT_RT the items which are not marked as\n\t\t * IRQ_WORK_HARD_IRQ are added to the lazy list and a HARD work\n\t\t * item is used on the remote CPU to wake the thread.\n\t\t */\n\t\tif (IS_ENABLED(CONFIG_PREEMPT_RT) &&\n\t\t    !(atomic_read(&work->node.a_flags) & IRQ_WORK_HARD_IRQ)) {\n\n\t\t\tif (!llist_add(&work->node.llist, &per_cpu(lazy_list, cpu)))\n\t\t\t\tgoto out;\n\n\t\t\twork = &per_cpu(irq_work_wakeup, cpu);\n\t\t\tif (!irq_work_claim(work))\n\t\t\t\tgoto out;\n\t\t}\n\n\t\t__smp_call_single_queue(cpu, &work->node.llist);\n\t} else {\n\t\t__irq_work_queue_local(work);\n\t}\nout:\n\tpreempt_enable();\n\n\treturn true;\n#endif /* CONFIG_SMP */\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_IRQ_WORK"
          ],
          "line": 1333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "rdp->last_fqs_resched",
            "jiffies"
          ],
          "line": 1331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "resched_cpu",
          "args": [
            "rdp->cpu"
          ],
          "line": 1330
        },
        "resolved": true,
        "details": {
          "function_name": "resched_cpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "1000-1009",
          "snippet": "void resched_cpu(int cpu)\n{\n\tstruct rq *rq = cpu_rq(cpu);\n\tunsigned long flags;\n\n\traw_spin_rq_lock_irqsave(rq, flags);\n\tif (cpu_online(cpu) || cpu == smp_processor_id())\n\t\tresched_curr(rq);\n\traw_spin_rq_unlock_irqrestore(rq, flags);\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\nvoid resched_cpu(int cpu)\n{\n\tstruct rq *rq = cpu_rq(cpu);\n\tunsigned long flags;\n\n\traw_spin_rq_lock_irqsave(rq, flags);\n\tif (cpu_online(cpu) || cpu == smp_processor_id())\n\t\tresched_curr(rq);\n\traw_spin_rq_unlock_irqrestore(rq, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "time_after",
          "args": [
            "jiffies",
            "READ_ONCE(rdp->last_fqs_resched) + jtsq"
          ],
          "line": 1328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rdp->last_fqs_resched"
          ],
          "line": 1329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time_after",
          "args": [
            "jiffies",
            "rcu_state.jiffies_resched"
          ],
          "line": 1327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "rdp->last_fqs_resched",
            "jiffies"
          ],
          "line": 1317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "rdp->rcu_urgent_qs",
            "true"
          ],
          "line": 1315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time_after",
          "args": [
            "jiffies",
            "READ_ONCE(rdp->last_fqs_resched) + jtsq * 3"
          ],
          "line": 1313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rdp->last_fqs_resched"
          ],
          "line": 1313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tick_nohz_full_cpu",
          "args": [
            "rdp->cpu"
          ],
          "line": 1312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "rdp->rcu_urgent_qs",
            "true"
          ],
          "line": 1301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time_after",
          "args": [
            "jiffies",
            "rcu_state.gp_start + jtsq"
          ],
          "line": 1300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_store_release",
          "args": [
            "&rdp->rcu_urgent_qs",
            "true"
          ],
          "line": 1299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "rdp->rcu_need_heavy_qs",
            "true"
          ],
          "line": 1297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time_after",
          "args": [
            "jiffies",
            "rcu_state.jiffies_resched"
          ],
          "line": 1295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time_after",
          "args": [
            "jiffies",
            "rcu_state.gp_start + jtsq * 2"
          ],
          "line": 1294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rdp->rcu_need_heavy_qs"
          ],
          "line": 1293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "jiffies_to_sched_qs"
          ],
          "line": 1292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"%s %d: %c online: %ld(%d) offline: %ld(%d)\\n\"",
            "__func__",
            "rdp->cpu",
            "\".o\"[onl]",
            "(long)rdp->rcu_onl_gp_seq",
            "rdp->rcu_onl_gp_flags",
            "(long)rdp->rcu_ofl_gp_seq",
            "rdp->rcu_ofl_gp_flags"
          ],
          "line": 1274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_rnp_online_cpus",
          "args": [
            "rnp"
          ],
          "line": 1273
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_rnp_online_cpus",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "219-222",
          "snippet": "static unsigned long rcu_rnp_online_cpus(struct rcu_node *rnp)\n{\n\treturn READ_ONCE(rnp->qsmaskinitnext);\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void check_cb_ovld_locked(struct rcu_data *rdp, struct rcu_node *rnp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic void check_cb_ovld_locked(struct rcu_data *rdp, struct rcu_node *rnp);\n\nstatic unsigned long rcu_rnp_online_cpus(struct rcu_node *rnp)\n{\n\treturn READ_ONCE(rnp->qsmaskinitnext);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"%s: %d:%d ->qsmask %#lx ->qsmaskinit %#lx ->qsmaskinitnext %#lx ->rcu_gp_init_mask %#lx\\n\"",
            "__func__",
            "rnp1->grplo",
            "rnp1->grphi",
            "rnp1->qsmask",
            "rnp1->qsmaskinit",
            "rnp1->qsmaskinitnext",
            "rnp1->rcu_gp_init_mask"
          ],
          "line": 1271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"%s: grp: %d-%d level: %d ->gp_seq %ld ->completedqs %ld\\n\"",
            "__func__",
            "rnp->grplo",
            "rnp->grphi",
            "rnp->level",
            "(long)rnp->gp_seq",
            "(long)rnp->completedqs"
          ],
          "line": 1267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!(rdp->grpmask & rcu_rnp_online_cpus(rnp))"
          ],
          "line": 1263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_gpnum_ovf",
          "args": [
            "rnp",
            "rdp"
          ],
          "line": 1241
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_gpnum_ovf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "1194-1202",
          "snippet": "static void rcu_gpnum_ovf(struct rcu_node *rnp, struct rcu_data *rdp)\n{\n\traw_lockdep_assert_held_rcu_node(rnp);\n\tif (ULONG_CMP_LT(rcu_seq_current(&rdp->gp_seq) + ULONG_MAX / 4,\n\t\t\t rnp->gp_seq))\n\t\tWRITE_ONCE(rdp->gpwrap, true);\n\tif (ULONG_CMP_LT(rdp->rcu_iw_gp_seq + ULONG_MAX / 4, rnp->gp_seq))\n\t\trdp->rcu_iw_gp_seq = rnp->gp_seq + ULONG_MAX / 4;\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};",
            "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
            "static void check_cb_ovld_locked(struct rcu_data *rdp, struct rcu_node *rnp);",
            "static bool rcu_rdp_is_offloaded(struct rcu_data *rdp);",
            "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void check_cb_ovld_locked(struct rcu_data *rdp, struct rcu_node *rnp);\nstatic bool rcu_rdp_is_offloaded(struct rcu_data *rdp);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nstatic void rcu_gpnum_ovf(struct rcu_node *rnp, struct rcu_data *rdp)\n{\n\traw_lockdep_assert_held_rcu_node(rnp);\n\tif (ULONG_CMP_LT(rcu_seq_current(&rdp->gp_seq) + ULONG_MAX / 4,\n\t\t\t rnp->gp_seq))\n\t\tWRITE_ONCE(rdp->gpwrap, true);\n\tif (ULONG_CMP_LT(rdp->rcu_iw_gp_seq + ULONG_MAX / 4, rnp->gp_seq))\n\t\trdp->rcu_iw_gp_seq = rnp->gp_seq + ULONG_MAX / 4;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_rcu_fqs",
          "args": [
            "rcu_state.name",
            "rdp->gp_seq",
            "rdp->cpu",
            "TPS(\"dti\")"
          ],
          "line": 1240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPS",
          "args": [
            "\"dti\""
          ],
          "line": 1240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_dynticks_in_eqs_since",
          "args": [
            "rdp",
            "rdp->dynticks_snap"
          ],
          "line": 1239
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_dynticks_in_eqs_since",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "365-368",
          "snippet": "static bool rcu_dynticks_in_eqs_since(struct rcu_data *rdp, int snap)\n{\n\treturn snap != rcu_dynticks_snap(rdp);\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};",
            "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
            "static bool rcu_rdp_is_offloaded(struct rcu_data *rdp);",
            "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic bool rcu_rdp_is_offloaded(struct rcu_data *rdp);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nstatic bool rcu_dynticks_in_eqs_since(struct rcu_data *rdp, int snap)\n{\n\treturn snap != rcu_dynticks_snap(rdp);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};\nstatic struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void sync_sched_exp_online_cleanup(int cpu);\nstatic void check_cb_ovld_locked(struct rcu_data *rdp, struct rcu_node *rnp);\nstatic bool rcu_rdp_is_offloaded(struct rcu_data *rdp);\nstatic ulong jiffies_to_sched_qs;\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nstatic int rcu_implicit_dynticks_qs(struct rcu_data *rdp)\n{\n\tunsigned long jtsq;\n\tstruct rcu_node *rnp = rdp->mynode;\n\n\t/*\n\t * If the CPU passed through or entered a dynticks idle phase with\n\t * no active irq/NMI handlers, then we can safely pretend that the CPU\n\t * already acknowledged the request to pass through a quiescent\n\t * state.  Either way, that CPU cannot possibly be in an RCU\n\t * read-side critical section that started before the beginning\n\t * of the current RCU grace period.\n\t */\n\tif (rcu_dynticks_in_eqs_since(rdp, rdp->dynticks_snap)) {\n\t\ttrace_rcu_fqs(rcu_state.name, rdp->gp_seq, rdp->cpu, TPS(\"dti\"));\n\t\trcu_gpnum_ovf(rnp, rdp);\n\t\treturn 1;\n\t}\n\n\t/*\n\t * Complain if a CPU that is considered to be offline from RCU's\n\t * perspective has not yet reported a quiescent state.  After all,\n\t * the offline CPU should have reported a quiescent state during\n\t * the CPU-offline process, or, failing that, by rcu_gp_init()\n\t * if it ran concurrently with either the CPU going offline or the\n\t * last task on a leaf rcu_node structure exiting its RCU read-side\n\t * critical section while all CPUs corresponding to that structure\n\t * are offline.  This added warning detects bugs in any of these\n\t * code paths.\n\t *\n\t * The rcu_node structure's ->lock is held here, which excludes\n\t * the relevant portions the CPU-hotplug code, the grace-period\n\t * initialization code, and the rcu_read_unlock() code paths.\n\t *\n\t * For more detail, please refer to the \"Hotplug CPU\" section\n\t * of RCU's Requirements documentation.\n\t */\n\tif (WARN_ON_ONCE(!(rdp->grpmask & rcu_rnp_online_cpus(rnp)))) {\n\t\tbool onl;\n\t\tstruct rcu_node *rnp1;\n\n\t\tpr_info(\"%s: grp: %d-%d level: %d ->gp_seq %ld ->completedqs %ld\\n\",\n\t\t\t__func__, rnp->grplo, rnp->grphi, rnp->level,\n\t\t\t(long)rnp->gp_seq, (long)rnp->completedqs);\n\t\tfor (rnp1 = rnp; rnp1; rnp1 = rnp1->parent)\n\t\t\tpr_info(\"%s: %d:%d ->qsmask %#lx ->qsmaskinit %#lx ->qsmaskinitnext %#lx ->rcu_gp_init_mask %#lx\\n\",\n\t\t\t\t__func__, rnp1->grplo, rnp1->grphi, rnp1->qsmask, rnp1->qsmaskinit, rnp1->qsmaskinitnext, rnp1->rcu_gp_init_mask);\n\t\tonl = !!(rdp->grpmask & rcu_rnp_online_cpus(rnp));\n\t\tpr_info(\"%s %d: %c online: %ld(%d) offline: %ld(%d)\\n\",\n\t\t\t__func__, rdp->cpu, \".o\"[onl],\n\t\t\t(long)rdp->rcu_onl_gp_seq, rdp->rcu_onl_gp_flags,\n\t\t\t(long)rdp->rcu_ofl_gp_seq, rdp->rcu_ofl_gp_flags);\n\t\treturn 1; /* Break things loose after complaining. */\n\t}\n\n\t/*\n\t * A CPU running for an extended time within the kernel can\n\t * delay RCU grace periods: (1) At age jiffies_to_sched_qs,\n\t * set .rcu_urgent_qs, (2) At age 2*jiffies_to_sched_qs, set\n\t * both .rcu_need_heavy_qs and .rcu_urgent_qs.  Note that the\n\t * unsynchronized assignments to the per-CPU rcu_need_heavy_qs\n\t * variable are safe because the assignments are repeated if this\n\t * CPU failed to pass through a quiescent state.  This code\n\t * also checks .jiffies_resched in case jiffies_to_sched_qs\n\t * is set way high.\n\t */\n\tjtsq = READ_ONCE(jiffies_to_sched_qs);\n\tif (!READ_ONCE(rdp->rcu_need_heavy_qs) &&\n\t    (time_after(jiffies, rcu_state.gp_start + jtsq * 2) ||\n\t     time_after(jiffies, rcu_state.jiffies_resched) ||\n\t     rcu_state.cbovld)) {\n\t\tWRITE_ONCE(rdp->rcu_need_heavy_qs, true);\n\t\t/* Store rcu_need_heavy_qs before rcu_urgent_qs. */\n\t\tsmp_store_release(&rdp->rcu_urgent_qs, true);\n\t} else if (time_after(jiffies, rcu_state.gp_start + jtsq)) {\n\t\tWRITE_ONCE(rdp->rcu_urgent_qs, true);\n\t}\n\n\t/*\n\t * NO_HZ_FULL CPUs can run in-kernel without rcu_sched_clock_irq!\n\t * The above code handles this, but only for straight cond_resched().\n\t * And some in-kernel loops check need_resched() before calling\n\t * cond_resched(), which defeats the above code for CPUs that are\n\t * running in-kernel with scheduling-clock interrupts disabled.\n\t * So hit them over the head with the resched_cpu() hammer!\n\t */\n\tif (tick_nohz_full_cpu(rdp->cpu) &&\n\t    (time_after(jiffies, READ_ONCE(rdp->last_fqs_resched) + jtsq * 3) ||\n\t     rcu_state.cbovld)) {\n\t\tWRITE_ONCE(rdp->rcu_urgent_qs, true);\n\t\tresched_cpu(rdp->cpu);\n\t\tWRITE_ONCE(rdp->last_fqs_resched, jiffies);\n\t}\n\n\t/*\n\t * If more than halfway to RCU CPU stall-warning time, invoke\n\t * resched_cpu() more frequently to try to loosen things up a bit.\n\t * Also check to see if the CPU is getting hammered with interrupts,\n\t * but only once per grace period, just to keep the IPIs down to\n\t * a dull roar.\n\t */\n\tif (time_after(jiffies, rcu_state.jiffies_resched)) {\n\t\tif (time_after(jiffies,\n\t\t\t       READ_ONCE(rdp->last_fqs_resched) + jtsq)) {\n\t\t\tresched_cpu(rdp->cpu);\n\t\t\tWRITE_ONCE(rdp->last_fqs_resched, jiffies);\n\t\t}\n\t\tif (IS_ENABLED(CONFIG_IRQ_WORK) &&\n\t\t    !rdp->rcu_iw_pending && rdp->rcu_iw_gp_seq != rnp->gp_seq &&\n\t\t    (rnp->ffmask & rdp->grpmask)) {\n\t\t\trdp->rcu_iw_pending = true;\n\t\t\trdp->rcu_iw_gp_seq = rnp->gp_seq;\n\t\t\tirq_work_queue_on(&rdp->rcu_iw, rdp->cpu);\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "dyntick_save_progress_counter",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
    "lines": "1209-1218",
    "snippet": "static int dyntick_save_progress_counter(struct rcu_data *rdp)\n{\n\trdp->dynticks_snap = rcu_dynticks_snap(rdp);\n\tif (rcu_dynticks_in_eqs(rdp->dynticks_snap)) {\n\t\ttrace_rcu_fqs(rcu_state.name, rdp->gp_seq, rdp->cpu, TPS(\"dti\"));\n\t\trcu_gpnum_ovf(rdp->mynode, rdp);\n\t\treturn 1;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_nocb.h\"",
      "#include \"tree_exp.h\"",
      "#include \"tree_stall.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <linux/kasan.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/panic_notifier.h>",
      "#include <linux/panic.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};",
      "static struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};",
      "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
      "static void sync_sched_exp_online_cleanup(int cpu);",
      "static bool rcu_rdp_is_offloaded(struct rcu_data *rdp);",
      "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_gpnum_ovf",
          "args": [
            "rdp->mynode",
            "rdp"
          ],
          "line": 1214
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_gpnum_ovf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "1194-1202",
          "snippet": "static void rcu_gpnum_ovf(struct rcu_node *rnp, struct rcu_data *rdp)\n{\n\traw_lockdep_assert_held_rcu_node(rnp);\n\tif (ULONG_CMP_LT(rcu_seq_current(&rdp->gp_seq) + ULONG_MAX / 4,\n\t\t\t rnp->gp_seq))\n\t\tWRITE_ONCE(rdp->gpwrap, true);\n\tif (ULONG_CMP_LT(rdp->rcu_iw_gp_seq + ULONG_MAX / 4, rnp->gp_seq))\n\t\trdp->rcu_iw_gp_seq = rnp->gp_seq + ULONG_MAX / 4;\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};",
            "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
            "static void check_cb_ovld_locked(struct rcu_data *rdp, struct rcu_node *rnp);",
            "static bool rcu_rdp_is_offloaded(struct rcu_data *rdp);",
            "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void check_cb_ovld_locked(struct rcu_data *rdp, struct rcu_node *rnp);\nstatic bool rcu_rdp_is_offloaded(struct rcu_data *rdp);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nstatic void rcu_gpnum_ovf(struct rcu_node *rnp, struct rcu_data *rdp)\n{\n\traw_lockdep_assert_held_rcu_node(rnp);\n\tif (ULONG_CMP_LT(rcu_seq_current(&rdp->gp_seq) + ULONG_MAX / 4,\n\t\t\t rnp->gp_seq))\n\t\tWRITE_ONCE(rdp->gpwrap, true);\n\tif (ULONG_CMP_LT(rdp->rcu_iw_gp_seq + ULONG_MAX / 4, rnp->gp_seq))\n\t\trdp->rcu_iw_gp_seq = rnp->gp_seq + ULONG_MAX / 4;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_rcu_fqs",
          "args": [
            "rcu_state.name",
            "rdp->gp_seq",
            "rdp->cpu",
            "TPS(\"dti\")"
          ],
          "line": 1213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPS",
          "args": [
            "\"dti\""
          ],
          "line": 1213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_dynticks_in_eqs",
          "args": [
            "rdp->dynticks_snap"
          ],
          "line": 1212
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_dynticks_in_eqs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "347-350",
          "snippet": "static bool rcu_dynticks_in_eqs(int snap)\n{\n\treturn !(snap & 0x1);\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic bool rcu_dynticks_in_eqs(int snap)\n{\n\treturn !(snap & 0x1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_dynticks_snap",
          "args": [
            "rdp"
          ],
          "line": 1211
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_dynticks_snap",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "337-341",
          "snippet": "static int rcu_dynticks_snap(struct rcu_data *rdp)\n{\n\tsmp_mb();  // Fundamental RCU ordering guarantee.\n\treturn atomic_read_acquire(&rdp->dynticks);\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};",
            "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
            "static bool rcu_rdp_is_offloaded(struct rcu_data *rdp);",
            "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic bool rcu_rdp_is_offloaded(struct rcu_data *rdp);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nstatic int rcu_dynticks_snap(struct rcu_data *rdp)\n{\n\tsmp_mb();  // Fundamental RCU ordering guarantee.\n\treturn atomic_read_acquire(&rdp->dynticks);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};\nstatic struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void sync_sched_exp_online_cleanup(int cpu);\nstatic bool rcu_rdp_is_offloaded(struct rcu_data *rdp);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nstatic int dyntick_save_progress_counter(struct rcu_data *rdp)\n{\n\trdp->dynticks_snap = rcu_dynticks_snap(rdp);\n\tif (rcu_dynticks_in_eqs(rdp->dynticks_snap)) {\n\t\ttrace_rcu_fqs(rcu_state.name, rdp->gp_seq, rdp->cpu, TPS(\"dti\"));\n\t\trcu_gpnum_ovf(rdp->mynode, rdp);\n\t\treturn 1;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "rcu_gpnum_ovf",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
    "lines": "1194-1202",
    "snippet": "static void rcu_gpnum_ovf(struct rcu_node *rnp, struct rcu_data *rdp)\n{\n\traw_lockdep_assert_held_rcu_node(rnp);\n\tif (ULONG_CMP_LT(rcu_seq_current(&rdp->gp_seq) + ULONG_MAX / 4,\n\t\t\t rnp->gp_seq))\n\t\tWRITE_ONCE(rdp->gpwrap, true);\n\tif (ULONG_CMP_LT(rdp->rcu_iw_gp_seq + ULONG_MAX / 4, rnp->gp_seq))\n\t\trdp->rcu_iw_gp_seq = rnp->gp_seq + ULONG_MAX / 4;\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_nocb.h\"",
      "#include \"tree_exp.h\"",
      "#include \"tree_stall.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <linux/kasan.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/panic_notifier.h>",
      "#include <linux/panic.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};",
      "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
      "static void check_cb_ovld_locked(struct rcu_data *rdp, struct rcu_node *rnp);",
      "static bool rcu_rdp_is_offloaded(struct rcu_data *rdp);",
      "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ULONG_CMP_LT",
          "args": [
            "rdp->rcu_iw_gp_seq + ULONG_MAX / 4",
            "rnp->gp_seq"
          ],
          "line": 1200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "rdp->gpwrap",
            "true"
          ],
          "line": 1199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ULONG_CMP_LT",
          "args": [
            "rcu_seq_current(&rdp->gp_seq) + ULONG_MAX / 4",
            "rnp->gp_seq"
          ],
          "line": 1197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_seq_current",
          "args": [
            "&rdp->gp_seq"
          ],
          "line": 1197
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_seq_current",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu.h",
          "lines": "97-100",
          "snippet": "static inline unsigned long rcu_seq_current(unsigned long *sp)\n{\n\treturn READ_ONCE(*sp);\n}",
          "includes": [
            "#include <linux/rcu_node_tree.h>",
            "#include <trace/events/rcu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_node_tree.h>\n#include <trace/events/rcu.h>\n\nstatic inline unsigned long rcu_seq_current(unsigned long *sp)\n{\n\treturn READ_ONCE(*sp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_lockdep_assert_held_rcu_node",
          "args": [
            "rnp"
          ],
          "line": 1196
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void check_cb_ovld_locked(struct rcu_data *rdp, struct rcu_node *rnp);\nstatic bool rcu_rdp_is_offloaded(struct rcu_data *rdp);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nstatic void rcu_gpnum_ovf(struct rcu_node *rnp, struct rcu_data *rdp)\n{\n\traw_lockdep_assert_held_rcu_node(rnp);\n\tif (ULONG_CMP_LT(rcu_seq_current(&rdp->gp_seq) + ULONG_MAX / 4,\n\t\t\t rnp->gp_seq))\n\t\tWRITE_ONCE(rdp->gpwrap, true);\n\tif (ULONG_CMP_LT(rdp->rcu_iw_gp_seq + ULONG_MAX / 4, rnp->gp_seq))\n\t\trdp->rcu_iw_gp_seq = rnp->gp_seq + ULONG_MAX / 4;\n}"
  },
  {
    "function_name": "rcu_lockdep_current_cpu_online",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
    "lines": "1167-1182",
    "snippet": "bool rcu_lockdep_current_cpu_online(void)\n{\n\tstruct rcu_data *rdp;\n\tstruct rcu_node *rnp;\n\tbool ret = false;\n\n\tif (in_nmi() || !rcu_scheduler_fully_active)\n\t\treturn true;\n\tpreempt_disable_notrace();\n\trdp = this_cpu_ptr(&rcu_data);\n\trnp = rdp->mynode;\n\tif (rdp->grpmask & rcu_rnp_online_cpus(rnp) || READ_ONCE(rnp->ofl_seq) & 0x1)\n\t\tret = true;\n\tpreempt_enable_notrace();\n\treturn ret;\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_nocb.h\"",
      "#include \"tree_exp.h\"",
      "#include \"tree_stall.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <linux/kasan.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/panic_notifier.h>",
      "#include <linux/panic.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};",
      "static int rcu_scheduler_fully_active",
      "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
      "static void check_cb_ovld_locked(struct rcu_data *rdp, struct rcu_node *rnp);",
      "static bool rcu_rdp_is_offloaded(struct rcu_data *rdp);",
      "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "preempt_enable_notrace",
          "args": [],
          "line": 1180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rnp->ofl_seq"
          ],
          "line": 1178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_rnp_online_cpus",
          "args": [
            "rnp"
          ],
          "line": 1178
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_rnp_online_cpus",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "219-222",
          "snippet": "static unsigned long rcu_rnp_online_cpus(struct rcu_node *rnp)\n{\n\treturn READ_ONCE(rnp->qsmaskinitnext);\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void check_cb_ovld_locked(struct rcu_data *rdp, struct rcu_node *rnp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic void check_cb_ovld_locked(struct rcu_data *rdp, struct rcu_node *rnp);\n\nstatic unsigned long rcu_rnp_online_cpus(struct rcu_node *rnp)\n{\n\treturn READ_ONCE(rnp->qsmaskinitnext);\n}"
        }
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&rcu_data"
          ],
          "line": 1176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preempt_disable_notrace",
          "args": [],
          "line": 1175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_nmi",
          "args": [],
          "line": 1173
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};\nstatic int rcu_scheduler_fully_active;\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void check_cb_ovld_locked(struct rcu_data *rdp, struct rcu_node *rnp);\nstatic bool rcu_rdp_is_offloaded(struct rcu_data *rdp);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nbool rcu_lockdep_current_cpu_online(void)\n{\n\tstruct rcu_data *rdp;\n\tstruct rcu_node *rnp;\n\tbool ret = false;\n\n\tif (in_nmi() || !rcu_scheduler_fully_active)\n\t\treturn true;\n\tpreempt_disable_notrace();\n\trdp = this_cpu_ptr(&rcu_data);\n\trnp = rdp->mynode;\n\tif (rdp->grpmask & rcu_rnp_online_cpus(rnp) || READ_ONCE(rnp->ofl_seq) & 0x1)\n\t\tret = true;\n\tpreempt_enable_notrace();\n\treturn ret;\n}"
  },
  {
    "function_name": "rcu_request_urgent_qs_task",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
    "lines": "1141-1150",
    "snippet": "void rcu_request_urgent_qs_task(struct task_struct *t)\n{\n\tint cpu;\n\n\tbarrier();\n\tcpu = task_cpu(t);\n\tif (!task_curr(t))\n\t\treturn; /* This task is not running on that CPU. */\n\tsmp_store_release(per_cpu_ptr(&rcu_data.rcu_urgent_qs, cpu), true);\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_nocb.h\"",
      "#include \"tree_exp.h\"",
      "#include \"tree_stall.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <linux/kasan.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/panic_notifier.h>",
      "#include <linux/panic.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};",
      "static void sync_sched_exp_online_cleanup(int cpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "smp_store_release",
          "args": [
            "per_cpu_ptr(&rcu_data.rcu_urgent_qs, cpu)",
            "true"
          ],
          "line": 1149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "&rcu_data.rcu_urgent_qs",
            "cpu"
          ],
          "line": 1149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_curr",
          "args": [
            "t"
          ],
          "line": 1147
        },
        "resolved": true,
        "details": {
          "function_name": "task_curr",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "2099-2102",
          "snippet": "inline int task_curr(const struct task_struct *p)\n{\n\treturn cpu_curr(task_cpu(p)) == p;\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\ninline int task_curr(const struct task_struct *p)\n{\n\treturn cpu_curr(task_cpu(p)) == p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_cpu",
          "args": [
            "t"
          ],
          "line": 1146
        },
        "resolved": true,
        "details": {
          "function_name": "ignore_task_cpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "7612-7633",
          "snippet": "static void ignore_task_cpu(void *data)\n{\n\tstruct trace_array *tr = data;\n\tstruct trace_pid_list *pid_list;\n\tstruct trace_pid_list *no_pid_list;\n\n\t/*\n\t * This function is called by on_each_cpu() while the\n\t * event_mutex is held.\n\t */\n\tpid_list = rcu_dereference_protected(tr->function_pids,\n\t\t\t\t\t     mutex_is_locked(&ftrace_lock));\n\tno_pid_list = rcu_dereference_protected(tr->function_no_pids,\n\t\t\t\t\t\tmutex_is_locked(&ftrace_lock));\n\n\tif (trace_ignore_this_task(pid_list, no_pid_list, current))\n\t\tthis_cpu_write(tr->array_buffer.data->ftrace_ignore_pid,\n\t\t\t       FTRACE_PID_IGNORE);\n\telse\n\t\tthis_cpu_write(tr->array_buffer.data->ftrace_ignore_pid,\n\t\t\t       current->pid);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ignore_task_cpu(void *data)\n{\n\tstruct trace_array *tr = data;\n\tstruct trace_pid_list *pid_list;\n\tstruct trace_pid_list *no_pid_list;\n\n\t/*\n\t * This function is called by on_each_cpu() while the\n\t * event_mutex is held.\n\t */\n\tpid_list = rcu_dereference_protected(tr->function_pids,\n\t\t\t\t\t     mutex_is_locked(&ftrace_lock));\n\tno_pid_list = rcu_dereference_protected(tr->function_no_pids,\n\t\t\t\t\t\tmutex_is_locked(&ftrace_lock));\n\n\tif (trace_ignore_this_task(pid_list, no_pid_list, current))\n\t\tthis_cpu_write(tr->array_buffer.data->ftrace_ignore_pid,\n\t\t\t       FTRACE_PID_IGNORE);\n\telse\n\t\tthis_cpu_write(tr->array_buffer.data->ftrace_ignore_pid,\n\t\t\t       current->pid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "barrier",
          "args": [],
          "line": 1145
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_barrier",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "4017-4099",
          "snippet": "void rcu_barrier(void)\n{\n\tuintptr_t cpu;\n\tstruct rcu_data *rdp;\n\tunsigned long s = rcu_seq_snap(&rcu_state.barrier_sequence);\n\n\trcu_barrier_trace(TPS(\"Begin\"), -1, s);\n\n\t/* Take mutex to serialize concurrent rcu_barrier() requests. */\n\tmutex_lock(&rcu_state.barrier_mutex);\n\n\t/* Did someone else do our work for us? */\n\tif (rcu_seq_done(&rcu_state.barrier_sequence, s)) {\n\t\trcu_barrier_trace(TPS(\"EarlyExit\"), -1,\n\t\t\t\t  rcu_state.barrier_sequence);\n\t\tsmp_mb(); /* caller's subsequent code after above check. */\n\t\tmutex_unlock(&rcu_state.barrier_mutex);\n\t\treturn;\n\t}\n\n\t/* Mark the start of the barrier operation. */\n\trcu_seq_start(&rcu_state.barrier_sequence);\n\trcu_barrier_trace(TPS(\"Inc1\"), -1, rcu_state.barrier_sequence);\n\n\t/*\n\t * Initialize the count to two rather than to zero in order\n\t * to avoid a too-soon return to zero in case of an immediate\n\t * invocation of the just-enqueued callback (or preemption of\n\t * this task).  Exclude CPU-hotplug operations to ensure that no\n\t * offline non-offloaded CPU has callbacks queued.\n\t */\n\tinit_completion(&rcu_state.barrier_completion);\n\tatomic_set(&rcu_state.barrier_cpu_count, 2);\n\tcpus_read_lock();\n\n\t/*\n\t * Force each CPU with callbacks to register a new callback.\n\t * When that callback is invoked, we will know that all of the\n\t * corresponding CPU's preceding callbacks have been invoked.\n\t */\n\tfor_each_possible_cpu(cpu) {\n\t\trdp = per_cpu_ptr(&rcu_data, cpu);\n\t\tif (cpu_is_offline(cpu) &&\n\t\t    !rcu_rdp_is_offloaded(rdp))\n\t\t\tcontinue;\n\t\tif (rcu_segcblist_n_cbs(&rdp->cblist) && cpu_online(cpu)) {\n\t\t\trcu_barrier_trace(TPS(\"OnlineQ\"), cpu,\n\t\t\t\t\t  rcu_state.barrier_sequence);\n\t\t\tsmp_call_function_single(cpu, rcu_barrier_func, (void *)cpu, 1);\n\t\t} else if (rcu_segcblist_n_cbs(&rdp->cblist) &&\n\t\t\t   cpu_is_offline(cpu)) {\n\t\t\trcu_barrier_trace(TPS(\"OfflineNoCBQ\"), cpu,\n\t\t\t\t\t  rcu_state.barrier_sequence);\n\t\t\tlocal_irq_disable();\n\t\t\trcu_barrier_func((void *)cpu);\n\t\t\tlocal_irq_enable();\n\t\t} else if (cpu_is_offline(cpu)) {\n\t\t\trcu_barrier_trace(TPS(\"OfflineNoCBNoQ\"), cpu,\n\t\t\t\t\t  rcu_state.barrier_sequence);\n\t\t} else {\n\t\t\trcu_barrier_trace(TPS(\"OnlineNQ\"), cpu,\n\t\t\t\t\t  rcu_state.barrier_sequence);\n\t\t}\n\t}\n\tcpus_read_unlock();\n\n\t/*\n\t * Now that we have an rcu_barrier_callback() callback on each\n\t * CPU, and thus each counted, remove the initial count.\n\t */\n\tif (atomic_sub_and_test(2, &rcu_state.barrier_cpu_count))\n\t\tcomplete(&rcu_state.barrier_completion);\n\n\t/* Wait for all rcu_barrier_callback() callbacks to be invoked. */\n\twait_for_completion(&rcu_state.barrier_completion);\n\n\t/* Mark the end of the barrier operation. */\n\trcu_barrier_trace(TPS(\"Inc2\"), -1, rcu_state.barrier_sequence);\n\trcu_seq_end(&rcu_state.barrier_sequence);\n\n\t/* Other rcu_barrier() invocations can now safely proceed. */\n\tmutex_unlock(&rcu_state.barrier_mutex);\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};",
            "static struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};",
            "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
            "static void sync_sched_exp_online_cleanup(int cpu);",
            "static bool rcu_rdp_is_offloaded(struct rcu_data *rdp);",
            "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};\nstatic struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void sync_sched_exp_online_cleanup(int cpu);\nstatic bool rcu_rdp_is_offloaded(struct rcu_data *rdp);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nvoid rcu_barrier(void)\n{\n\tuintptr_t cpu;\n\tstruct rcu_data *rdp;\n\tunsigned long s = rcu_seq_snap(&rcu_state.barrier_sequence);\n\n\trcu_barrier_trace(TPS(\"Begin\"), -1, s);\n\n\t/* Take mutex to serialize concurrent rcu_barrier() requests. */\n\tmutex_lock(&rcu_state.barrier_mutex);\n\n\t/* Did someone else do our work for us? */\n\tif (rcu_seq_done(&rcu_state.barrier_sequence, s)) {\n\t\trcu_barrier_trace(TPS(\"EarlyExit\"), -1,\n\t\t\t\t  rcu_state.barrier_sequence);\n\t\tsmp_mb(); /* caller's subsequent code after above check. */\n\t\tmutex_unlock(&rcu_state.barrier_mutex);\n\t\treturn;\n\t}\n\n\t/* Mark the start of the barrier operation. */\n\trcu_seq_start(&rcu_state.barrier_sequence);\n\trcu_barrier_trace(TPS(\"Inc1\"), -1, rcu_state.barrier_sequence);\n\n\t/*\n\t * Initialize the count to two rather than to zero in order\n\t * to avoid a too-soon return to zero in case of an immediate\n\t * invocation of the just-enqueued callback (or preemption of\n\t * this task).  Exclude CPU-hotplug operations to ensure that no\n\t * offline non-offloaded CPU has callbacks queued.\n\t */\n\tinit_completion(&rcu_state.barrier_completion);\n\tatomic_set(&rcu_state.barrier_cpu_count, 2);\n\tcpus_read_lock();\n\n\t/*\n\t * Force each CPU with callbacks to register a new callback.\n\t * When that callback is invoked, we will know that all of the\n\t * corresponding CPU's preceding callbacks have been invoked.\n\t */\n\tfor_each_possible_cpu(cpu) {\n\t\trdp = per_cpu_ptr(&rcu_data, cpu);\n\t\tif (cpu_is_offline(cpu) &&\n\t\t    !rcu_rdp_is_offloaded(rdp))\n\t\t\tcontinue;\n\t\tif (rcu_segcblist_n_cbs(&rdp->cblist) && cpu_online(cpu)) {\n\t\t\trcu_barrier_trace(TPS(\"OnlineQ\"), cpu,\n\t\t\t\t\t  rcu_state.barrier_sequence);\n\t\t\tsmp_call_function_single(cpu, rcu_barrier_func, (void *)cpu, 1);\n\t\t} else if (rcu_segcblist_n_cbs(&rdp->cblist) &&\n\t\t\t   cpu_is_offline(cpu)) {\n\t\t\trcu_barrier_trace(TPS(\"OfflineNoCBQ\"), cpu,\n\t\t\t\t\t  rcu_state.barrier_sequence);\n\t\t\tlocal_irq_disable();\n\t\t\trcu_barrier_func((void *)cpu);\n\t\t\tlocal_irq_enable();\n\t\t} else if (cpu_is_offline(cpu)) {\n\t\t\trcu_barrier_trace(TPS(\"OfflineNoCBNoQ\"), cpu,\n\t\t\t\t\t  rcu_state.barrier_sequence);\n\t\t} else {\n\t\t\trcu_barrier_trace(TPS(\"OnlineNQ\"), cpu,\n\t\t\t\t\t  rcu_state.barrier_sequence);\n\t\t}\n\t}\n\tcpus_read_unlock();\n\n\t/*\n\t * Now that we have an rcu_barrier_callback() callback on each\n\t * CPU, and thus each counted, remove the initial count.\n\t */\n\tif (atomic_sub_and_test(2, &rcu_state.barrier_cpu_count))\n\t\tcomplete(&rcu_state.barrier_completion);\n\n\t/* Wait for all rcu_barrier_callback() callbacks to be invoked. */\n\twait_for_completion(&rcu_state.barrier_completion);\n\n\t/* Mark the end of the barrier operation. */\n\trcu_barrier_trace(TPS(\"Inc2\"), -1, rcu_state.barrier_sequence);\n\trcu_seq_end(&rcu_state.barrier_sequence);\n\n\t/* Other rcu_barrier() invocations can now safely proceed. */\n\tmutex_unlock(&rcu_state.barrier_mutex);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};\nstatic void sync_sched_exp_online_cleanup(int cpu);\n\nvoid rcu_request_urgent_qs_task(struct task_struct *t)\n{\n\tint cpu;\n\n\tbarrier();\n\tcpu = task_cpu(t);\n\tif (!task_curr(t))\n\t\treturn; /* This task is not running on that CPU. */\n\tsmp_store_release(per_cpu_ptr(&rcu_data.rcu_urgent_qs, cpu), true);\n}"
  },
  {
    "function_name": "rcu_is_watching",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
    "lines": "1123-1131",
    "snippet": "notrace bool rcu_is_watching(void)\n{\n\tbool ret;\n\n\tpreempt_disable_notrace();\n\tret = !rcu_dynticks_curr_cpu_in_eqs();\n\tpreempt_enable_notrace();\n\treturn ret;\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_nocb.h\"",
      "#include \"tree_exp.h\"",
      "#include \"tree_stall.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <linux/kasan.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/panic_notifier.h>",
      "#include <linux/panic.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "preempt_enable_notrace",
          "args": [],
          "line": 1129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_dynticks_curr_cpu_in_eqs",
          "args": [],
          "line": 1128
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_dynticks_curr_cpu_in_eqs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "328-331",
          "snippet": "static __always_inline bool rcu_dynticks_curr_cpu_in_eqs(void)\n{\n\treturn !(arch_atomic_read(this_cpu_ptr(&rcu_data.dynticks)) & 0x1);\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};\n\nstatic __always_inline bool rcu_dynticks_curr_cpu_in_eqs(void)\n{\n\treturn !(arch_atomic_read(this_cpu_ptr(&rcu_data.dynticks)) & 0x1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "preempt_disable_notrace",
          "args": [],
          "line": 1127
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nnotrace bool rcu_is_watching(void)\n{\n\tbool ret;\n\n\tpreempt_disable_notrace();\n\tret = !rcu_dynticks_curr_cpu_in_eqs();\n\tpreempt_enable_notrace();\n\treturn ret;\n}"
  },
  {
    "function_name": "rcu_disable_urgency_upon_qs",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
    "lines": "1101-1110",
    "snippet": "static void rcu_disable_urgency_upon_qs(struct rcu_data *rdp)\n{\n\traw_lockdep_assert_held_rcu_node(rdp->mynode);\n\tWRITE_ONCE(rdp->rcu_urgent_qs, false);\n\tWRITE_ONCE(rdp->rcu_need_heavy_qs, false);\n\tif (tick_nohz_full_cpu(rdp->cpu) && rdp->rcu_forced_tick) {\n\t\ttick_dep_clear_cpu(rdp->cpu, TICK_DEP_BIT_RCU);\n\t\tWRITE_ONCE(rdp->rcu_forced_tick, false);\n\t}\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_nocb.h\"",
      "#include \"tree_exp.h\"",
      "#include \"tree_stall.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <linux/kasan.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/panic_notifier.h>",
      "#include <linux/panic.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};",
      "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
      "static void sync_sched_exp_online_cleanup(int cpu);",
      "static bool rcu_rdp_is_offloaded(struct rcu_data *rdp);",
      "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "rdp->rcu_forced_tick",
            "false"
          ],
          "line": 1108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tick_dep_clear_cpu",
          "args": [
            "rdp->cpu",
            "TICK_DEP_BIT_RCU"
          ],
          "line": 1107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tick_nohz_full_cpu",
          "args": [
            "rdp->cpu"
          ],
          "line": 1106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "rdp->rcu_need_heavy_qs",
            "false"
          ],
          "line": 1105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "rdp->rcu_urgent_qs",
            "false"
          ],
          "line": 1104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_lockdep_assert_held_rcu_node",
          "args": [
            "rdp->mynode"
          ],
          "line": 1103
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void sync_sched_exp_online_cleanup(int cpu);\nstatic bool rcu_rdp_is_offloaded(struct rcu_data *rdp);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nstatic void rcu_disable_urgency_upon_qs(struct rcu_data *rdp)\n{\n\traw_lockdep_assert_held_rcu_node(rdp->mynode);\n\tWRITE_ONCE(rdp->rcu_urgent_qs, false);\n\tWRITE_ONCE(rdp->rcu_need_heavy_qs, false);\n\tif (tick_nohz_full_cpu(rdp->cpu) && rdp->rcu_forced_tick) {\n\t\ttick_dep_clear_cpu(rdp->cpu, TICK_DEP_BIT_RCU);\n\t\tWRITE_ONCE(rdp->rcu_forced_tick, false);\n\t}\n}"
  },
  {
    "function_name": "rcu_needs_cpu",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
    "lines": "1089-1094",
    "snippet": "int rcu_needs_cpu(u64 basemono, u64 *nextevt)\n{\n\t*nextevt = KTIME_MAX;\n\treturn !rcu_segcblist_empty(&this_cpu_ptr(&rcu_data)->cblist) &&\n\t\t!rcu_rdp_is_offloaded(this_cpu_ptr(&rcu_data));\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_nocb.h\"",
      "#include \"tree_exp.h\"",
      "#include \"tree_stall.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <linux/kasan.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/panic_notifier.h>",
      "#include <linux/panic.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_rdp_is_offloaded",
          "args": [
            "this_cpu_ptr(&rcu_data)"
          ],
          "line": 1093
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_rdp_is_offloaded",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "16-38",
          "snippet": "static bool rcu_rdp_is_offloaded(struct rcu_data *rdp)\n{\n\t/*\n\t * In order to read the offloaded state of an rdp in a safe\n\t * and stable way and prevent from its value to be changed\n\t * under us, we must either hold the barrier mutex, the cpu\n\t * hotplug lock (read or write) or the nocb lock. Local\n\t * non-preemptible reads are also safe. NOCB kthreads and\n\t * timers have their own means of synchronization against the\n\t * offloaded state updaters.\n\t */\n\tRCU_LOCKDEP_WARN(\n\t\t!(lockdep_is_held(&rcu_state.barrier_mutex) ||\n\t\t  (IS_ENABLED(CONFIG_HOTPLUG_CPU) && lockdep_is_cpus_held()) ||\n\t\t  rcu_lockdep_is_held_nocb(rdp) ||\n\t\t  (rdp == this_cpu_ptr(&rcu_data) &&\n\t\t   !(IS_ENABLED(CONFIG_PREEMPT_COUNT) && preemptible())) ||\n\t\t  rcu_current_is_nocb_kthread(rdp)),\n\t\t\"Unsafe read of RCU_NOCB offloaded state\"\n\t);\n\n\treturn rcu_segcblist_is_offloaded(&rdp->cblist);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nstatic bool rcu_rdp_is_offloaded(struct rcu_data *rdp)\n{\n\t/*\n\t * In order to read the offloaded state of an rdp in a safe\n\t * and stable way and prevent from its value to be changed\n\t * under us, we must either hold the barrier mutex, the cpu\n\t * hotplug lock (read or write) or the nocb lock. Local\n\t * non-preemptible reads are also safe. NOCB kthreads and\n\t * timers have their own means of synchronization against the\n\t * offloaded state updaters.\n\t */\n\tRCU_LOCKDEP_WARN(\n\t\t!(lockdep_is_held(&rcu_state.barrier_mutex) ||\n\t\t  (IS_ENABLED(CONFIG_HOTPLUG_CPU) && lockdep_is_cpus_held()) ||\n\t\t  rcu_lockdep_is_held_nocb(rdp) ||\n\t\t  (rdp == this_cpu_ptr(&rcu_data) &&\n\t\t   !(IS_ENABLED(CONFIG_PREEMPT_COUNT) && preemptible())) ||\n\t\t  rcu_current_is_nocb_kthread(rdp)),\n\t\t\"Unsafe read of RCU_NOCB offloaded state\"\n\t);\n\n\treturn rcu_segcblist_is_offloaded(&rdp->cblist);\n}"
        }
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&rcu_data"
          ],
          "line": 1093
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_segcblist_empty",
          "args": [
            "&this_cpu_ptr(&rcu_data)->cblist"
          ],
          "line": 1092
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "41-44",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "long rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nlong rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&rcu_data"
          ],
          "line": 1092
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};\n\nint rcu_needs_cpu(u64 basemono, u64 *nextevt)\n{\n\t*nextevt = KTIME_MAX;\n\treturn !rcu_segcblist_empty(&this_cpu_ptr(&rcu_data)->cblist) &&\n\t\t!rcu_rdp_is_offloaded(this_cpu_ptr(&rcu_data));\n}"
  },
  {
    "function_name": "rcu_irq_enter_irqson",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
    "lines": "1069-1076",
    "snippet": "void rcu_irq_enter_irqson(void)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\trcu_irq_enter();\n\tlocal_irq_restore(flags);\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_nocb.h\"",
      "#include \"tree_exp.h\"",
      "#include \"tree_stall.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <linux/kasan.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/panic_notifier.h>",
      "#include <linux/panic.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 1075
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_irq_enter",
          "args": [],
          "line": 1074
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_irq_enter_irqson",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "1069-1076",
          "snippet": "void rcu_irq_enter_irqson(void)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\trcu_irq_enter();\n\tlocal_irq_restore(flags);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "local_irq_save",
          "args": [
            "flags"
          ],
          "line": 1073
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);\n\nvoid rcu_irq_enter_irqson(void)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\trcu_irq_enter();\n\tlocal_irq_restore(flags);\n}"
  },
  {
    "function_name": "rcu_irq_enter",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
    "lines": "1057-1061",
    "snippet": "noinstr void rcu_irq_enter(void)\n{\n\tlockdep_assert_irqs_disabled();\n\trcu_nmi_enter();\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_nocb.h\"",
      "#include \"tree_exp.h\"",
      "#include \"tree_stall.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <linux/kasan.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/panic_notifier.h>",
      "#include <linux/panic.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline noinstr"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_nmi_enter",
          "args": [],
          "line": 1060
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_nmi_enter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "987-1033",
          "snippet": "noinstr void rcu_nmi_enter(void)\n{\n\tlong incby = 2;\n\tstruct rcu_data *rdp = this_cpu_ptr(&rcu_data);\n\n\t/* Complain about underflow. */\n\tWARN_ON_ONCE(rdp->dynticks_nmi_nesting < 0);\n\n\t/*\n\t * If idle from RCU viewpoint, atomically increment ->dynticks\n\t * to mark non-idle and increment ->dynticks_nmi_nesting by one.\n\t * Otherwise, increment ->dynticks_nmi_nesting by two.  This means\n\t * if ->dynticks_nmi_nesting is equal to one, we are guaranteed\n\t * to be in the outermost NMI handler that interrupted an RCU-idle\n\t * period (observation due to Andy Lutomirski).\n\t */\n\tif (rcu_dynticks_curr_cpu_in_eqs()) {\n\n\t\tif (!in_nmi())\n\t\t\trcu_dynticks_task_exit();\n\n\t\t// RCU is not watching here ...\n\t\trcu_dynticks_eqs_exit();\n\t\t// ... but is watching here.\n\n\t\tinstrumentation_begin();\n\t\t// instrumentation for the noinstr rcu_dynticks_curr_cpu_in_eqs()\n\t\tinstrument_atomic_read(&rdp->dynticks, sizeof(rdp->dynticks));\n\t\t// instrumentation for the noinstr rcu_dynticks_eqs_exit()\n\t\tinstrument_atomic_write(&rdp->dynticks, sizeof(rdp->dynticks));\n\n\t\tincby = 1;\n\t} else if (!in_nmi()) {\n\t\tinstrumentation_begin();\n\t\trcu_irq_enter_check_tick();\n\t} else  {\n\t\tinstrumentation_begin();\n\t}\n\n\ttrace_rcu_dyntick(incby == 1 ? TPS(\"Endirq\") : TPS(\"++=\"),\n\t\t\t  rdp->dynticks_nmi_nesting,\n\t\t\t  rdp->dynticks_nmi_nesting + incby, atomic_read(&rdp->dynticks));\n\tinstrumentation_end();\n\tWRITE_ONCE(rdp->dynticks_nmi_nesting, /* Prevent store tearing. */\n\t\t   rdp->dynticks_nmi_nesting + incby);\n\tbarrier();\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};",
            "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
            "static bool rcu_rdp_is_offloaded(struct rcu_data *rdp);",
            "static noinline noinstr",
            "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic bool rcu_rdp_is_offloaded(struct rcu_data *rdp);\nstatic noinline noinstr;\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nnoinstr void rcu_nmi_enter(void)\n{\n\tlong incby = 2;\n\tstruct rcu_data *rdp = this_cpu_ptr(&rcu_data);\n\n\t/* Complain about underflow. */\n\tWARN_ON_ONCE(rdp->dynticks_nmi_nesting < 0);\n\n\t/*\n\t * If idle from RCU viewpoint, atomically increment ->dynticks\n\t * to mark non-idle and increment ->dynticks_nmi_nesting by one.\n\t * Otherwise, increment ->dynticks_nmi_nesting by two.  This means\n\t * if ->dynticks_nmi_nesting is equal to one, we are guaranteed\n\t * to be in the outermost NMI handler that interrupted an RCU-idle\n\t * period (observation due to Andy Lutomirski).\n\t */\n\tif (rcu_dynticks_curr_cpu_in_eqs()) {\n\n\t\tif (!in_nmi())\n\t\t\trcu_dynticks_task_exit();\n\n\t\t// RCU is not watching here ...\n\t\trcu_dynticks_eqs_exit();\n\t\t// ... but is watching here.\n\n\t\tinstrumentation_begin();\n\t\t// instrumentation for the noinstr rcu_dynticks_curr_cpu_in_eqs()\n\t\tinstrument_atomic_read(&rdp->dynticks, sizeof(rdp->dynticks));\n\t\t// instrumentation for the noinstr rcu_dynticks_eqs_exit()\n\t\tinstrument_atomic_write(&rdp->dynticks, sizeof(rdp->dynticks));\n\n\t\tincby = 1;\n\t} else if (!in_nmi()) {\n\t\tinstrumentation_begin();\n\t\trcu_irq_enter_check_tick();\n\t} else  {\n\t\tinstrumentation_begin();\n\t}\n\n\ttrace_rcu_dyntick(incby == 1 ? TPS(\"Endirq\") : TPS(\"++=\"),\n\t\t\t  rdp->dynticks_nmi_nesting,\n\t\t\t  rdp->dynticks_nmi_nesting + incby, atomic_read(&rdp->dynticks));\n\tinstrumentation_end();\n\tWRITE_ONCE(rdp->dynticks_nmi_nesting, /* Prevent store tearing. */\n\t\t   rdp->dynticks_nmi_nesting + incby);\n\tbarrier();\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_assert_irqs_disabled",
          "args": [],
          "line": 1059
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic noinline noinstr;\n\nnoinstr void rcu_irq_enter(void)\n{\n\tlockdep_assert_irqs_disabled();\n\trcu_nmi_enter();\n}"
  },
  {
    "function_name": "rcu_nmi_enter",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
    "lines": "987-1033",
    "snippet": "noinstr void rcu_nmi_enter(void)\n{\n\tlong incby = 2;\n\tstruct rcu_data *rdp = this_cpu_ptr(&rcu_data);\n\n\t/* Complain about underflow. */\n\tWARN_ON_ONCE(rdp->dynticks_nmi_nesting < 0);\n\n\t/*\n\t * If idle from RCU viewpoint, atomically increment ->dynticks\n\t * to mark non-idle and increment ->dynticks_nmi_nesting by one.\n\t * Otherwise, increment ->dynticks_nmi_nesting by two.  This means\n\t * if ->dynticks_nmi_nesting is equal to one, we are guaranteed\n\t * to be in the outermost NMI handler that interrupted an RCU-idle\n\t * period (observation due to Andy Lutomirski).\n\t */\n\tif (rcu_dynticks_curr_cpu_in_eqs()) {\n\n\t\tif (!in_nmi())\n\t\t\trcu_dynticks_task_exit();\n\n\t\t// RCU is not watching here ...\n\t\trcu_dynticks_eqs_exit();\n\t\t// ... but is watching here.\n\n\t\tinstrumentation_begin();\n\t\t// instrumentation for the noinstr rcu_dynticks_curr_cpu_in_eqs()\n\t\tinstrument_atomic_read(&rdp->dynticks, sizeof(rdp->dynticks));\n\t\t// instrumentation for the noinstr rcu_dynticks_eqs_exit()\n\t\tinstrument_atomic_write(&rdp->dynticks, sizeof(rdp->dynticks));\n\n\t\tincby = 1;\n\t} else if (!in_nmi()) {\n\t\tinstrumentation_begin();\n\t\trcu_irq_enter_check_tick();\n\t} else  {\n\t\tinstrumentation_begin();\n\t}\n\n\ttrace_rcu_dyntick(incby == 1 ? TPS(\"Endirq\") : TPS(\"++=\"),\n\t\t\t  rdp->dynticks_nmi_nesting,\n\t\t\t  rdp->dynticks_nmi_nesting + incby, atomic_read(&rdp->dynticks));\n\tinstrumentation_end();\n\tWRITE_ONCE(rdp->dynticks_nmi_nesting, /* Prevent store tearing. */\n\t\t   rdp->dynticks_nmi_nesting + incby);\n\tbarrier();\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_nocb.h\"",
      "#include \"tree_exp.h\"",
      "#include \"tree_stall.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <linux/kasan.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/panic_notifier.h>",
      "#include <linux/panic.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};",
      "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
      "static bool rcu_rdp_is_offloaded(struct rcu_data *rdp);",
      "static noinline noinstr",
      "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "barrier",
          "args": [],
          "line": 1032
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_barrier",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "4017-4099",
          "snippet": "void rcu_barrier(void)\n{\n\tuintptr_t cpu;\n\tstruct rcu_data *rdp;\n\tunsigned long s = rcu_seq_snap(&rcu_state.barrier_sequence);\n\n\trcu_barrier_trace(TPS(\"Begin\"), -1, s);\n\n\t/* Take mutex to serialize concurrent rcu_barrier() requests. */\n\tmutex_lock(&rcu_state.barrier_mutex);\n\n\t/* Did someone else do our work for us? */\n\tif (rcu_seq_done(&rcu_state.barrier_sequence, s)) {\n\t\trcu_barrier_trace(TPS(\"EarlyExit\"), -1,\n\t\t\t\t  rcu_state.barrier_sequence);\n\t\tsmp_mb(); /* caller's subsequent code after above check. */\n\t\tmutex_unlock(&rcu_state.barrier_mutex);\n\t\treturn;\n\t}\n\n\t/* Mark the start of the barrier operation. */\n\trcu_seq_start(&rcu_state.barrier_sequence);\n\trcu_barrier_trace(TPS(\"Inc1\"), -1, rcu_state.barrier_sequence);\n\n\t/*\n\t * Initialize the count to two rather than to zero in order\n\t * to avoid a too-soon return to zero in case of an immediate\n\t * invocation of the just-enqueued callback (or preemption of\n\t * this task).  Exclude CPU-hotplug operations to ensure that no\n\t * offline non-offloaded CPU has callbacks queued.\n\t */\n\tinit_completion(&rcu_state.barrier_completion);\n\tatomic_set(&rcu_state.barrier_cpu_count, 2);\n\tcpus_read_lock();\n\n\t/*\n\t * Force each CPU with callbacks to register a new callback.\n\t * When that callback is invoked, we will know that all of the\n\t * corresponding CPU's preceding callbacks have been invoked.\n\t */\n\tfor_each_possible_cpu(cpu) {\n\t\trdp = per_cpu_ptr(&rcu_data, cpu);\n\t\tif (cpu_is_offline(cpu) &&\n\t\t    !rcu_rdp_is_offloaded(rdp))\n\t\t\tcontinue;\n\t\tif (rcu_segcblist_n_cbs(&rdp->cblist) && cpu_online(cpu)) {\n\t\t\trcu_barrier_trace(TPS(\"OnlineQ\"), cpu,\n\t\t\t\t\t  rcu_state.barrier_sequence);\n\t\t\tsmp_call_function_single(cpu, rcu_barrier_func, (void *)cpu, 1);\n\t\t} else if (rcu_segcblist_n_cbs(&rdp->cblist) &&\n\t\t\t   cpu_is_offline(cpu)) {\n\t\t\trcu_barrier_trace(TPS(\"OfflineNoCBQ\"), cpu,\n\t\t\t\t\t  rcu_state.barrier_sequence);\n\t\t\tlocal_irq_disable();\n\t\t\trcu_barrier_func((void *)cpu);\n\t\t\tlocal_irq_enable();\n\t\t} else if (cpu_is_offline(cpu)) {\n\t\t\trcu_barrier_trace(TPS(\"OfflineNoCBNoQ\"), cpu,\n\t\t\t\t\t  rcu_state.barrier_sequence);\n\t\t} else {\n\t\t\trcu_barrier_trace(TPS(\"OnlineNQ\"), cpu,\n\t\t\t\t\t  rcu_state.barrier_sequence);\n\t\t}\n\t}\n\tcpus_read_unlock();\n\n\t/*\n\t * Now that we have an rcu_barrier_callback() callback on each\n\t * CPU, and thus each counted, remove the initial count.\n\t */\n\tif (atomic_sub_and_test(2, &rcu_state.barrier_cpu_count))\n\t\tcomplete(&rcu_state.barrier_completion);\n\n\t/* Wait for all rcu_barrier_callback() callbacks to be invoked. */\n\twait_for_completion(&rcu_state.barrier_completion);\n\n\t/* Mark the end of the barrier operation. */\n\trcu_barrier_trace(TPS(\"Inc2\"), -1, rcu_state.barrier_sequence);\n\trcu_seq_end(&rcu_state.barrier_sequence);\n\n\t/* Other rcu_barrier() invocations can now safely proceed. */\n\tmutex_unlock(&rcu_state.barrier_mutex);\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};",
            "static struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};",
            "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
            "static void sync_sched_exp_online_cleanup(int cpu);",
            "static bool rcu_rdp_is_offloaded(struct rcu_data *rdp);",
            "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};\nstatic struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void sync_sched_exp_online_cleanup(int cpu);\nstatic bool rcu_rdp_is_offloaded(struct rcu_data *rdp);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nvoid rcu_barrier(void)\n{\n\tuintptr_t cpu;\n\tstruct rcu_data *rdp;\n\tunsigned long s = rcu_seq_snap(&rcu_state.barrier_sequence);\n\n\trcu_barrier_trace(TPS(\"Begin\"), -1, s);\n\n\t/* Take mutex to serialize concurrent rcu_barrier() requests. */\n\tmutex_lock(&rcu_state.barrier_mutex);\n\n\t/* Did someone else do our work for us? */\n\tif (rcu_seq_done(&rcu_state.barrier_sequence, s)) {\n\t\trcu_barrier_trace(TPS(\"EarlyExit\"), -1,\n\t\t\t\t  rcu_state.barrier_sequence);\n\t\tsmp_mb(); /* caller's subsequent code after above check. */\n\t\tmutex_unlock(&rcu_state.barrier_mutex);\n\t\treturn;\n\t}\n\n\t/* Mark the start of the barrier operation. */\n\trcu_seq_start(&rcu_state.barrier_sequence);\n\trcu_barrier_trace(TPS(\"Inc1\"), -1, rcu_state.barrier_sequence);\n\n\t/*\n\t * Initialize the count to two rather than to zero in order\n\t * to avoid a too-soon return to zero in case of an immediate\n\t * invocation of the just-enqueued callback (or preemption of\n\t * this task).  Exclude CPU-hotplug operations to ensure that no\n\t * offline non-offloaded CPU has callbacks queued.\n\t */\n\tinit_completion(&rcu_state.barrier_completion);\n\tatomic_set(&rcu_state.barrier_cpu_count, 2);\n\tcpus_read_lock();\n\n\t/*\n\t * Force each CPU with callbacks to register a new callback.\n\t * When that callback is invoked, we will know that all of the\n\t * corresponding CPU's preceding callbacks have been invoked.\n\t */\n\tfor_each_possible_cpu(cpu) {\n\t\trdp = per_cpu_ptr(&rcu_data, cpu);\n\t\tif (cpu_is_offline(cpu) &&\n\t\t    !rcu_rdp_is_offloaded(rdp))\n\t\t\tcontinue;\n\t\tif (rcu_segcblist_n_cbs(&rdp->cblist) && cpu_online(cpu)) {\n\t\t\trcu_barrier_trace(TPS(\"OnlineQ\"), cpu,\n\t\t\t\t\t  rcu_state.barrier_sequence);\n\t\t\tsmp_call_function_single(cpu, rcu_barrier_func, (void *)cpu, 1);\n\t\t} else if (rcu_segcblist_n_cbs(&rdp->cblist) &&\n\t\t\t   cpu_is_offline(cpu)) {\n\t\t\trcu_barrier_trace(TPS(\"OfflineNoCBQ\"), cpu,\n\t\t\t\t\t  rcu_state.barrier_sequence);\n\t\t\tlocal_irq_disable();\n\t\t\trcu_barrier_func((void *)cpu);\n\t\t\tlocal_irq_enable();\n\t\t} else if (cpu_is_offline(cpu)) {\n\t\t\trcu_barrier_trace(TPS(\"OfflineNoCBNoQ\"), cpu,\n\t\t\t\t\t  rcu_state.barrier_sequence);\n\t\t} else {\n\t\t\trcu_barrier_trace(TPS(\"OnlineNQ\"), cpu,\n\t\t\t\t\t  rcu_state.barrier_sequence);\n\t\t}\n\t}\n\tcpus_read_unlock();\n\n\t/*\n\t * Now that we have an rcu_barrier_callback() callback on each\n\t * CPU, and thus each counted, remove the initial count.\n\t */\n\tif (atomic_sub_and_test(2, &rcu_state.barrier_cpu_count))\n\t\tcomplete(&rcu_state.barrier_completion);\n\n\t/* Wait for all rcu_barrier_callback() callbacks to be invoked. */\n\twait_for_completion(&rcu_state.barrier_completion);\n\n\t/* Mark the end of the barrier operation. */\n\trcu_barrier_trace(TPS(\"Inc2\"), -1, rcu_state.barrier_sequence);\n\trcu_seq_end(&rcu_state.barrier_sequence);\n\n\t/* Other rcu_barrier() invocations can now safely proceed. */\n\tmutex_unlock(&rcu_state.barrier_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "rdp->dynticks_nmi_nesting",
            "/* Prevent store tearing. */rdp->dynticks_nmi_nesting + incby"
          ],
          "line": 1030
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "instrumentation_end",
          "args": [],
          "line": 1029
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_rcu_dyntick",
          "args": [
            "incby == 1 ? TPS(\"Endirq\") : TPS(\"++=\")",
            "rdp->dynticks_nmi_nesting",
            "rdp->dynticks_nmi_nesting + incby",
            "atomic_read(&rdp->dynticks)"
          ],
          "line": 1026
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&rdp->dynticks"
          ],
          "line": 1028
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPS",
          "args": [
            "\"++=\""
          ],
          "line": 1026
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPS",
          "args": [
            "\"Endirq\""
          ],
          "line": 1026
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "instrumentation_begin",
          "args": [],
          "line": 1023
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_irq_enter_check_tick",
          "args": [],
          "line": 1021
        },
        "resolved": true,
        "details": {
          "function_name": "__rcu_irq_enter_check_tick",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "939-972",
          "snippet": "void __rcu_irq_enter_check_tick(void)\n{\n\tstruct rcu_data *rdp = this_cpu_ptr(&rcu_data);\n\n\t// If we're here from NMI there's nothing to do.\n\tif (in_nmi())\n\t\treturn;\n\n\tRCU_LOCKDEP_WARN(rcu_dynticks_curr_cpu_in_eqs(),\n\t\t\t \"Illegal rcu_irq_enter_check_tick() from extended quiescent state\");\n\n\tif (!tick_nohz_full_cpu(rdp->cpu) ||\n\t    !READ_ONCE(rdp->rcu_urgent_qs) ||\n\t    READ_ONCE(rdp->rcu_forced_tick)) {\n\t\t// RCU doesn't need nohz_full help from this CPU, or it is\n\t\t// already getting that help.\n\t\treturn;\n\t}\n\n\t// We get here only when not in an extended quiescent state and\n\t// from interrupts (as opposed to NMIs).  Therefore, (1) RCU is\n\t// already watching and (2) The fact that we are in an interrupt\n\t// handler and that the rcu_node lock is an irq-disabled lock\n\t// prevents self-deadlock.  So we can safely recheck under the lock.\n\t// Note that the nohz_full state currently cannot change.\n\traw_spin_lock_rcu_node(rdp->mynode);\n\tif (rdp->rcu_urgent_qs && !rdp->rcu_forced_tick) {\n\t\t// A nohz_full CPU is in the kernel and RCU needs a\n\t\t// quiescent state.  Turn on the tick!\n\t\tWRITE_ONCE(rdp->rcu_forced_tick, true);\n\t\ttick_dep_set_cpu(rdp->cpu, TICK_DEP_BIT_RCU);\n\t}\n\traw_spin_unlock_rcu_node(rdp->mynode);\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};",
            "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
            "static void sync_sched_exp_online_cleanup(int cpu);",
            "static bool rcu_rdp_is_offloaded(struct rcu_data *rdp);",
            "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void sync_sched_exp_online_cleanup(int cpu);\nstatic bool rcu_rdp_is_offloaded(struct rcu_data *rdp);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nvoid __rcu_irq_enter_check_tick(void)\n{\n\tstruct rcu_data *rdp = this_cpu_ptr(&rcu_data);\n\n\t// If we're here from NMI there's nothing to do.\n\tif (in_nmi())\n\t\treturn;\n\n\tRCU_LOCKDEP_WARN(rcu_dynticks_curr_cpu_in_eqs(),\n\t\t\t \"Illegal rcu_irq_enter_check_tick() from extended quiescent state\");\n\n\tif (!tick_nohz_full_cpu(rdp->cpu) ||\n\t    !READ_ONCE(rdp->rcu_urgent_qs) ||\n\t    READ_ONCE(rdp->rcu_forced_tick)) {\n\t\t// RCU doesn't need nohz_full help from this CPU, or it is\n\t\t// already getting that help.\n\t\treturn;\n\t}\n\n\t// We get here only when not in an extended quiescent state and\n\t// from interrupts (as opposed to NMIs).  Therefore, (1) RCU is\n\t// already watching and (2) The fact that we are in an interrupt\n\t// handler and that the rcu_node lock is an irq-disabled lock\n\t// prevents self-deadlock.  So we can safely recheck under the lock.\n\t// Note that the nohz_full state currently cannot change.\n\traw_spin_lock_rcu_node(rdp->mynode);\n\tif (rdp->rcu_urgent_qs && !rdp->rcu_forced_tick) {\n\t\t// A nohz_full CPU is in the kernel and RCU needs a\n\t\t// quiescent state.  Turn on the tick!\n\t\tWRITE_ONCE(rdp->rcu_forced_tick, true);\n\t\ttick_dep_set_cpu(rdp->cpu, TICK_DEP_BIT_RCU);\n\t}\n\traw_spin_unlock_rcu_node(rdp->mynode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "instrumentation_begin",
          "args": [],
          "line": 1020
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_nmi",
          "args": [],
          "line": 1019
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "instrument_atomic_write",
          "args": [
            "&rdp->dynticks",
            "sizeof(rdp->dynticks)"
          ],
          "line": 1016
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "instrument_atomic_read",
          "args": [
            "&rdp->dynticks",
            "sizeof(rdp->dynticks)"
          ],
          "line": 1014
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "instrumentation_begin",
          "args": [],
          "line": 1012
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_dynticks_eqs_exit",
          "args": [],
          "line": 1009
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_dynticks_eqs_exit",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "289-302",
          "snippet": "static noinstr void rcu_dynticks_eqs_exit(void)\n{\n\tint seq;\n\n\t/*\n\t * CPUs seeing atomic_add_return() must see prior idle sojourns,\n\t * and we also must force ordering with the next RCU read-side\n\t * critical section.\n\t */\n\tseq = rcu_dynticks_inc(1);\n\t// RCU is now watching.  Better not be in an extended quiescent state!\n\trcu_dynticks_task_trace_exit();  // After ->dynticks update!\n\tWARN_ON_ONCE(IS_ENABLED(CONFIG_RCU_EQS_DEBUG) && !(seq & 0x1));\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline noinstr"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic noinline noinstr;\n\nstatic noinstr void rcu_dynticks_eqs_exit(void)\n{\n\tint seq;\n\n\t/*\n\t * CPUs seeing atomic_add_return() must see prior idle sojourns,\n\t * and we also must force ordering with the next RCU read-side\n\t * critical section.\n\t */\n\tseq = rcu_dynticks_inc(1);\n\t// RCU is now watching.  Better not be in an extended quiescent state!\n\trcu_dynticks_task_trace_exit();  // After ->dynticks update!\n\tWARN_ON_ONCE(IS_ENABLED(CONFIG_RCU_EQS_DEBUG) && !(seq & 0x1));\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_dynticks_task_exit",
          "args": [],
          "line": 1006
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_dynticks_task_exit",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "1306-1311",
          "snippet": "static __always_inline void rcu_dynticks_task_exit(void)\n{\n#if defined(CONFIG_TASKS_RCU) && defined(CONFIG_NO_HZ_FULL)\n\tWRITE_ONCE(current->rcu_tasks_idle_cpu, -1);\n#endif /* #if defined(CONFIG_TASKS_RCU) && defined(CONFIG_NO_HZ_FULL) */\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nstatic __always_inline void rcu_dynticks_task_exit(void)\n{\n#if defined(CONFIG_TASKS_RCU) && defined(CONFIG_NO_HZ_FULL)\n\tWRITE_ONCE(current->rcu_tasks_idle_cpu, -1);\n#endif /* #if defined(CONFIG_TASKS_RCU) && defined(CONFIG_NO_HZ_FULL) */\n}"
        }
      },
      {
        "call_info": {
          "callee": "in_nmi",
          "args": [],
          "line": 1005
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_dynticks_curr_cpu_in_eqs",
          "args": [],
          "line": 1003
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_dynticks_curr_cpu_in_eqs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "328-331",
          "snippet": "static __always_inline bool rcu_dynticks_curr_cpu_in_eqs(void)\n{\n\treturn !(arch_atomic_read(this_cpu_ptr(&rcu_data.dynticks)) & 0x1);\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};\n\nstatic __always_inline bool rcu_dynticks_curr_cpu_in_eqs(void)\n{\n\treturn !(arch_atomic_read(this_cpu_ptr(&rcu_data.dynticks)) & 0x1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "rdp->dynticks_nmi_nesting < 0"
          ],
          "line": 993
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&rcu_data"
          ],
          "line": 990
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic bool rcu_rdp_is_offloaded(struct rcu_data *rdp);\nstatic noinline noinstr;\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nnoinstr void rcu_nmi_enter(void)\n{\n\tlong incby = 2;\n\tstruct rcu_data *rdp = this_cpu_ptr(&rcu_data);\n\n\t/* Complain about underflow. */\n\tWARN_ON_ONCE(rdp->dynticks_nmi_nesting < 0);\n\n\t/*\n\t * If idle from RCU viewpoint, atomically increment ->dynticks\n\t * to mark non-idle and increment ->dynticks_nmi_nesting by one.\n\t * Otherwise, increment ->dynticks_nmi_nesting by two.  This means\n\t * if ->dynticks_nmi_nesting is equal to one, we are guaranteed\n\t * to be in the outermost NMI handler that interrupted an RCU-idle\n\t * period (observation due to Andy Lutomirski).\n\t */\n\tif (rcu_dynticks_curr_cpu_in_eqs()) {\n\n\t\tif (!in_nmi())\n\t\t\trcu_dynticks_task_exit();\n\n\t\t// RCU is not watching here ...\n\t\trcu_dynticks_eqs_exit();\n\t\t// ... but is watching here.\n\n\t\tinstrumentation_begin();\n\t\t// instrumentation for the noinstr rcu_dynticks_curr_cpu_in_eqs()\n\t\tinstrument_atomic_read(&rdp->dynticks, sizeof(rdp->dynticks));\n\t\t// instrumentation for the noinstr rcu_dynticks_eqs_exit()\n\t\tinstrument_atomic_write(&rdp->dynticks, sizeof(rdp->dynticks));\n\n\t\tincby = 1;\n\t} else if (!in_nmi()) {\n\t\tinstrumentation_begin();\n\t\trcu_irq_enter_check_tick();\n\t} else  {\n\t\tinstrumentation_begin();\n\t}\n\n\ttrace_rcu_dyntick(incby == 1 ? TPS(\"Endirq\") : TPS(\"++=\"),\n\t\t\t  rdp->dynticks_nmi_nesting,\n\t\t\t  rdp->dynticks_nmi_nesting + incby, atomic_read(&rdp->dynticks));\n\tinstrumentation_end();\n\tWRITE_ONCE(rdp->dynticks_nmi_nesting, /* Prevent store tearing. */\n\t\t   rdp->dynticks_nmi_nesting + incby);\n\tbarrier();\n}"
  },
  {
    "function_name": "__rcu_irq_enter_check_tick",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
    "lines": "939-972",
    "snippet": "void __rcu_irq_enter_check_tick(void)\n{\n\tstruct rcu_data *rdp = this_cpu_ptr(&rcu_data);\n\n\t// If we're here from NMI there's nothing to do.\n\tif (in_nmi())\n\t\treturn;\n\n\tRCU_LOCKDEP_WARN(rcu_dynticks_curr_cpu_in_eqs(),\n\t\t\t \"Illegal rcu_irq_enter_check_tick() from extended quiescent state\");\n\n\tif (!tick_nohz_full_cpu(rdp->cpu) ||\n\t    !READ_ONCE(rdp->rcu_urgent_qs) ||\n\t    READ_ONCE(rdp->rcu_forced_tick)) {\n\t\t// RCU doesn't need nohz_full help from this CPU, or it is\n\t\t// already getting that help.\n\t\treturn;\n\t}\n\n\t// We get here only when not in an extended quiescent state and\n\t// from interrupts (as opposed to NMIs).  Therefore, (1) RCU is\n\t// already watching and (2) The fact that we are in an interrupt\n\t// handler and that the rcu_node lock is an irq-disabled lock\n\t// prevents self-deadlock.  So we can safely recheck under the lock.\n\t// Note that the nohz_full state currently cannot change.\n\traw_spin_lock_rcu_node(rdp->mynode);\n\tif (rdp->rcu_urgent_qs && !rdp->rcu_forced_tick) {\n\t\t// A nohz_full CPU is in the kernel and RCU needs a\n\t\t// quiescent state.  Turn on the tick!\n\t\tWRITE_ONCE(rdp->rcu_forced_tick, true);\n\t\ttick_dep_set_cpu(rdp->cpu, TICK_DEP_BIT_RCU);\n\t}\n\traw_spin_unlock_rcu_node(rdp->mynode);\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_nocb.h\"",
      "#include \"tree_exp.h\"",
      "#include \"tree_stall.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <linux/kasan.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/panic_notifier.h>",
      "#include <linux/panic.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};",
      "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
      "static void sync_sched_exp_online_cleanup(int cpu);",
      "static bool rcu_rdp_is_offloaded(struct rcu_data *rdp);",
      "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock_rcu_node",
          "args": [
            "rdp->mynode"
          ],
          "line": 971
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tick_dep_set_cpu",
          "args": [
            "rdp->cpu",
            "TICK_DEP_BIT_RCU"
          ],
          "line": 969
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "rdp->rcu_forced_tick",
            "true"
          ],
          "line": 968
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_rcu_node",
          "args": [
            "rdp->mynode"
          ],
          "line": 964
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rdp->rcu_forced_tick"
          ],
          "line": 952
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rdp->rcu_urgent_qs"
          ],
          "line": 951
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tick_nohz_full_cpu",
          "args": [
            "rdp->cpu"
          ],
          "line": 950
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RCU_LOCKDEP_WARN",
          "args": [
            "rcu_dynticks_curr_cpu_in_eqs()",
            "\"Illegal rcu_irq_enter_check_tick() from extended quiescent state\""
          ],
          "line": 947
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_dynticks_curr_cpu_in_eqs",
          "args": [],
          "line": 947
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_dynticks_curr_cpu_in_eqs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "328-331",
          "snippet": "static __always_inline bool rcu_dynticks_curr_cpu_in_eqs(void)\n{\n\treturn !(arch_atomic_read(this_cpu_ptr(&rcu_data.dynticks)) & 0x1);\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};\n\nstatic __always_inline bool rcu_dynticks_curr_cpu_in_eqs(void)\n{\n\treturn !(arch_atomic_read(this_cpu_ptr(&rcu_data.dynticks)) & 0x1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "in_nmi",
          "args": [],
          "line": 944
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&rcu_data"
          ],
          "line": 941
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void sync_sched_exp_online_cleanup(int cpu);\nstatic bool rcu_rdp_is_offloaded(struct rcu_data *rdp);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nvoid __rcu_irq_enter_check_tick(void)\n{\n\tstruct rcu_data *rdp = this_cpu_ptr(&rcu_data);\n\n\t// If we're here from NMI there's nothing to do.\n\tif (in_nmi())\n\t\treturn;\n\n\tRCU_LOCKDEP_WARN(rcu_dynticks_curr_cpu_in_eqs(),\n\t\t\t \"Illegal rcu_irq_enter_check_tick() from extended quiescent state\");\n\n\tif (!tick_nohz_full_cpu(rdp->cpu) ||\n\t    !READ_ONCE(rdp->rcu_urgent_qs) ||\n\t    READ_ONCE(rdp->rcu_forced_tick)) {\n\t\t// RCU doesn't need nohz_full help from this CPU, or it is\n\t\t// already getting that help.\n\t\treturn;\n\t}\n\n\t// We get here only when not in an extended quiescent state and\n\t// from interrupts (as opposed to NMIs).  Therefore, (1) RCU is\n\t// already watching and (2) The fact that we are in an interrupt\n\t// handler and that the rcu_node lock is an irq-disabled lock\n\t// prevents self-deadlock.  So we can safely recheck under the lock.\n\t// Note that the nohz_full state currently cannot change.\n\traw_spin_lock_rcu_node(rdp->mynode);\n\tif (rdp->rcu_urgent_qs && !rdp->rcu_forced_tick) {\n\t\t// A nohz_full CPU is in the kernel and RCU needs a\n\t\t// quiescent state.  Turn on the tick!\n\t\tWRITE_ONCE(rdp->rcu_forced_tick, true);\n\t\ttick_dep_set_cpu(rdp->cpu, TICK_DEP_BIT_RCU);\n\t}\n\traw_spin_unlock_rcu_node(rdp->mynode);\n}"
  },
  {
    "function_name": "rcu_user_exit",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
    "lines": "908-911",
    "snippet": "void noinstr rcu_user_exit(void)\n{\n\trcu_eqs_exit(true);\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_nocb.h\"",
      "#include \"tree_exp.h\"",
      "#include \"tree_stall.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <linux/kasan.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/panic_notifier.h>",
      "#include <linux/panic.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline noinstr"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_eqs_exit",
          "args": [
            "true"
          ],
          "line": 910
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_eqs_exit",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "848-877",
          "snippet": "static void noinstr rcu_eqs_exit(bool user)\n{\n\tstruct rcu_data *rdp;\n\tlong oldval;\n\n\tlockdep_assert_irqs_disabled();\n\trdp = this_cpu_ptr(&rcu_data);\n\toldval = rdp->dynticks_nesting;\n\tWARN_ON_ONCE(IS_ENABLED(CONFIG_RCU_EQS_DEBUG) && oldval < 0);\n\tif (oldval) {\n\t\t// RCU was already watching, so just do accounting and leave.\n\t\trdp->dynticks_nesting++;\n\t\treturn;\n\t}\n\trcu_dynticks_task_exit();\n\t// RCU is not watching here ...\n\trcu_dynticks_eqs_exit();\n\t// ... but is watching here.\n\tinstrumentation_begin();\n\n\t// instrumentation for the noinstr rcu_dynticks_eqs_exit()\n\tinstrument_atomic_write(&rdp->dynticks, sizeof(rdp->dynticks));\n\n\ttrace_rcu_dyntick(TPS(\"End\"), rdp->dynticks_nesting, 1, atomic_read(&rdp->dynticks));\n\tWARN_ON_ONCE(IS_ENABLED(CONFIG_RCU_EQS_DEBUG) && !user && !is_idle_task(current));\n\tWRITE_ONCE(rdp->dynticks_nesting, 1);\n\tWARN_ON_ONCE(rdp->dynticks_nmi_nesting);\n\tWRITE_ONCE(rdp->dynticks_nmi_nesting, DYNTICK_IRQ_NONIDLE);\n\tinstrumentation_end();\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};",
            "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
            "static bool rcu_rdp_is_offloaded(struct rcu_data *rdp);",
            "static noinline noinstr",
            "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));",
            "static int rcu_pending(int user);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic bool rcu_rdp_is_offloaded(struct rcu_data *rdp);\nstatic noinline noinstr;\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\nstatic int rcu_pending(int user);\n\nstatic void noinstr rcu_eqs_exit(bool user)\n{\n\tstruct rcu_data *rdp;\n\tlong oldval;\n\n\tlockdep_assert_irqs_disabled();\n\trdp = this_cpu_ptr(&rcu_data);\n\toldval = rdp->dynticks_nesting;\n\tWARN_ON_ONCE(IS_ENABLED(CONFIG_RCU_EQS_DEBUG) && oldval < 0);\n\tif (oldval) {\n\t\t// RCU was already watching, so just do accounting and leave.\n\t\trdp->dynticks_nesting++;\n\t\treturn;\n\t}\n\trcu_dynticks_task_exit();\n\t// RCU is not watching here ...\n\trcu_dynticks_eqs_exit();\n\t// ... but is watching here.\n\tinstrumentation_begin();\n\n\t// instrumentation for the noinstr rcu_dynticks_eqs_exit()\n\tinstrument_atomic_write(&rdp->dynticks, sizeof(rdp->dynticks));\n\n\ttrace_rcu_dyntick(TPS(\"End\"), rdp->dynticks_nesting, 1, atomic_read(&rdp->dynticks));\n\tWARN_ON_ONCE(IS_ENABLED(CONFIG_RCU_EQS_DEBUG) && !user && !is_idle_task(current));\n\tWRITE_ONCE(rdp->dynticks_nesting, 1);\n\tWARN_ON_ONCE(rdp->dynticks_nmi_nesting);\n\tWRITE_ONCE(rdp->dynticks_nmi_nesting, DYNTICK_IRQ_NONIDLE);\n\tinstrumentation_end();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic noinline noinstr;\n\nvoid noinstr rcu_user_exit(void)\n{\n\trcu_eqs_exit(true);\n}"
  },
  {
    "function_name": "rcu_idle_exit",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
    "lines": "888-895",
    "snippet": "void rcu_idle_exit(void)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\trcu_eqs_exit(false);\n\tlocal_irq_restore(flags);\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_nocb.h\"",
      "#include \"tree_exp.h\"",
      "#include \"tree_stall.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <linux/kasan.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/panic_notifier.h>",
      "#include <linux/panic.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 894
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_eqs_exit",
          "args": [
            "false"
          ],
          "line": 893
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_eqs_exit",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "848-877",
          "snippet": "static void noinstr rcu_eqs_exit(bool user)\n{\n\tstruct rcu_data *rdp;\n\tlong oldval;\n\n\tlockdep_assert_irqs_disabled();\n\trdp = this_cpu_ptr(&rcu_data);\n\toldval = rdp->dynticks_nesting;\n\tWARN_ON_ONCE(IS_ENABLED(CONFIG_RCU_EQS_DEBUG) && oldval < 0);\n\tif (oldval) {\n\t\t// RCU was already watching, so just do accounting and leave.\n\t\trdp->dynticks_nesting++;\n\t\treturn;\n\t}\n\trcu_dynticks_task_exit();\n\t// RCU is not watching here ...\n\trcu_dynticks_eqs_exit();\n\t// ... but is watching here.\n\tinstrumentation_begin();\n\n\t// instrumentation for the noinstr rcu_dynticks_eqs_exit()\n\tinstrument_atomic_write(&rdp->dynticks, sizeof(rdp->dynticks));\n\n\ttrace_rcu_dyntick(TPS(\"End\"), rdp->dynticks_nesting, 1, atomic_read(&rdp->dynticks));\n\tWARN_ON_ONCE(IS_ENABLED(CONFIG_RCU_EQS_DEBUG) && !user && !is_idle_task(current));\n\tWRITE_ONCE(rdp->dynticks_nesting, 1);\n\tWARN_ON_ONCE(rdp->dynticks_nmi_nesting);\n\tWRITE_ONCE(rdp->dynticks_nmi_nesting, DYNTICK_IRQ_NONIDLE);\n\tinstrumentation_end();\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};",
            "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
            "static bool rcu_rdp_is_offloaded(struct rcu_data *rdp);",
            "static noinline noinstr",
            "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));",
            "static int rcu_pending(int user);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic bool rcu_rdp_is_offloaded(struct rcu_data *rdp);\nstatic noinline noinstr;\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\nstatic int rcu_pending(int user);\n\nstatic void noinstr rcu_eqs_exit(bool user)\n{\n\tstruct rcu_data *rdp;\n\tlong oldval;\n\n\tlockdep_assert_irqs_disabled();\n\trdp = this_cpu_ptr(&rcu_data);\n\toldval = rdp->dynticks_nesting;\n\tWARN_ON_ONCE(IS_ENABLED(CONFIG_RCU_EQS_DEBUG) && oldval < 0);\n\tif (oldval) {\n\t\t// RCU was already watching, so just do accounting and leave.\n\t\trdp->dynticks_nesting++;\n\t\treturn;\n\t}\n\trcu_dynticks_task_exit();\n\t// RCU is not watching here ...\n\trcu_dynticks_eqs_exit();\n\t// ... but is watching here.\n\tinstrumentation_begin();\n\n\t// instrumentation for the noinstr rcu_dynticks_eqs_exit()\n\tinstrument_atomic_write(&rdp->dynticks, sizeof(rdp->dynticks));\n\n\ttrace_rcu_dyntick(TPS(\"End\"), rdp->dynticks_nesting, 1, atomic_read(&rdp->dynticks));\n\tWARN_ON_ONCE(IS_ENABLED(CONFIG_RCU_EQS_DEBUG) && !user && !is_idle_task(current));\n\tWRITE_ONCE(rdp->dynticks_nesting, 1);\n\tWARN_ON_ONCE(rdp->dynticks_nmi_nesting);\n\tWRITE_ONCE(rdp->dynticks_nmi_nesting, DYNTICK_IRQ_NONIDLE);\n\tinstrumentation_end();\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_irq_save",
          "args": [
            "flags"
          ],
          "line": 892
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);\n\nvoid rcu_idle_exit(void)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\trcu_eqs_exit(false);\n\tlocal_irq_restore(flags);\n}"
  },
  {
    "function_name": "rcu_eqs_exit",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
    "lines": "848-877",
    "snippet": "static void noinstr rcu_eqs_exit(bool user)\n{\n\tstruct rcu_data *rdp;\n\tlong oldval;\n\n\tlockdep_assert_irqs_disabled();\n\trdp = this_cpu_ptr(&rcu_data);\n\toldval = rdp->dynticks_nesting;\n\tWARN_ON_ONCE(IS_ENABLED(CONFIG_RCU_EQS_DEBUG) && oldval < 0);\n\tif (oldval) {\n\t\t// RCU was already watching, so just do accounting and leave.\n\t\trdp->dynticks_nesting++;\n\t\treturn;\n\t}\n\trcu_dynticks_task_exit();\n\t// RCU is not watching here ...\n\trcu_dynticks_eqs_exit();\n\t// ... but is watching here.\n\tinstrumentation_begin();\n\n\t// instrumentation for the noinstr rcu_dynticks_eqs_exit()\n\tinstrument_atomic_write(&rdp->dynticks, sizeof(rdp->dynticks));\n\n\ttrace_rcu_dyntick(TPS(\"End\"), rdp->dynticks_nesting, 1, atomic_read(&rdp->dynticks));\n\tWARN_ON_ONCE(IS_ENABLED(CONFIG_RCU_EQS_DEBUG) && !user && !is_idle_task(current));\n\tWRITE_ONCE(rdp->dynticks_nesting, 1);\n\tWARN_ON_ONCE(rdp->dynticks_nmi_nesting);\n\tWRITE_ONCE(rdp->dynticks_nmi_nesting, DYNTICK_IRQ_NONIDLE);\n\tinstrumentation_end();\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_nocb.h\"",
      "#include \"tree_exp.h\"",
      "#include \"tree_stall.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <linux/kasan.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/panic_notifier.h>",
      "#include <linux/panic.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};",
      "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
      "static bool rcu_rdp_is_offloaded(struct rcu_data *rdp);",
      "static noinline noinstr",
      "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));",
      "static int rcu_pending(int user);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "instrumentation_end",
          "args": [],
          "line": 876
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "rdp->dynticks_nmi_nesting",
            "DYNTICK_IRQ_NONIDLE"
          ],
          "line": 875
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "rdp->dynticks_nmi_nesting"
          ],
          "line": 874
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "rdp->dynticks_nesting",
            "1"
          ],
          "line": 873
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "IS_ENABLED(CONFIG_RCU_EQS_DEBUG) && !user && !is_idle_task(current)"
          ],
          "line": 872
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_idle_task",
          "args": [
            "current"
          ],
          "line": 872
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_RCU_EQS_DEBUG"
          ],
          "line": 872
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_rcu_dyntick",
          "args": [
            "TPS(\"End\")",
            "rdp->dynticks_nesting",
            "1",
            "atomic_read(&rdp->dynticks)"
          ],
          "line": 871
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&rdp->dynticks"
          ],
          "line": 871
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPS",
          "args": [
            "\"End\""
          ],
          "line": 871
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "instrument_atomic_write",
          "args": [
            "&rdp->dynticks",
            "sizeof(rdp->dynticks)"
          ],
          "line": 869
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "instrumentation_begin",
          "args": [],
          "line": 866
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_dynticks_eqs_exit",
          "args": [],
          "line": 864
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_dynticks_eqs_exit",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "289-302",
          "snippet": "static noinstr void rcu_dynticks_eqs_exit(void)\n{\n\tint seq;\n\n\t/*\n\t * CPUs seeing atomic_add_return() must see prior idle sojourns,\n\t * and we also must force ordering with the next RCU read-side\n\t * critical section.\n\t */\n\tseq = rcu_dynticks_inc(1);\n\t// RCU is now watching.  Better not be in an extended quiescent state!\n\trcu_dynticks_task_trace_exit();  // After ->dynticks update!\n\tWARN_ON_ONCE(IS_ENABLED(CONFIG_RCU_EQS_DEBUG) && !(seq & 0x1));\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline noinstr"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic noinline noinstr;\n\nstatic noinstr void rcu_dynticks_eqs_exit(void)\n{\n\tint seq;\n\n\t/*\n\t * CPUs seeing atomic_add_return() must see prior idle sojourns,\n\t * and we also must force ordering with the next RCU read-side\n\t * critical section.\n\t */\n\tseq = rcu_dynticks_inc(1);\n\t// RCU is now watching.  Better not be in an extended quiescent state!\n\trcu_dynticks_task_trace_exit();  // After ->dynticks update!\n\tWARN_ON_ONCE(IS_ENABLED(CONFIG_RCU_EQS_DEBUG) && !(seq & 0x1));\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_dynticks_task_exit",
          "args": [],
          "line": 862
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_dynticks_task_exit",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "1306-1311",
          "snippet": "static __always_inline void rcu_dynticks_task_exit(void)\n{\n#if defined(CONFIG_TASKS_RCU) && defined(CONFIG_NO_HZ_FULL)\n\tWRITE_ONCE(current->rcu_tasks_idle_cpu, -1);\n#endif /* #if defined(CONFIG_TASKS_RCU) && defined(CONFIG_NO_HZ_FULL) */\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nstatic __always_inline void rcu_dynticks_task_exit(void)\n{\n#if defined(CONFIG_TASKS_RCU) && defined(CONFIG_NO_HZ_FULL)\n\tWRITE_ONCE(current->rcu_tasks_idle_cpu, -1);\n#endif /* #if defined(CONFIG_TASKS_RCU) && defined(CONFIG_NO_HZ_FULL) */\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "IS_ENABLED(CONFIG_RCU_EQS_DEBUG) && oldval < 0"
          ],
          "line": 856
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_RCU_EQS_DEBUG"
          ],
          "line": 856
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&rcu_data"
          ],
          "line": 854
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_irqs_disabled",
          "args": [],
          "line": 853
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic bool rcu_rdp_is_offloaded(struct rcu_data *rdp);\nstatic noinline noinstr;\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\nstatic int rcu_pending(int user);\n\nstatic void noinstr rcu_eqs_exit(bool user)\n{\n\tstruct rcu_data *rdp;\n\tlong oldval;\n\n\tlockdep_assert_irqs_disabled();\n\trdp = this_cpu_ptr(&rcu_data);\n\toldval = rdp->dynticks_nesting;\n\tWARN_ON_ONCE(IS_ENABLED(CONFIG_RCU_EQS_DEBUG) && oldval < 0);\n\tif (oldval) {\n\t\t// RCU was already watching, so just do accounting and leave.\n\t\trdp->dynticks_nesting++;\n\t\treturn;\n\t}\n\trcu_dynticks_task_exit();\n\t// RCU is not watching here ...\n\trcu_dynticks_eqs_exit();\n\t// ... but is watching here.\n\tinstrumentation_begin();\n\n\t// instrumentation for the noinstr rcu_dynticks_eqs_exit()\n\tinstrument_atomic_write(&rdp->dynticks, sizeof(rdp->dynticks));\n\n\ttrace_rcu_dyntick(TPS(\"End\"), rdp->dynticks_nesting, 1, atomic_read(&rdp->dynticks));\n\tWARN_ON_ONCE(IS_ENABLED(CONFIG_RCU_EQS_DEBUG) && !user && !is_idle_task(current));\n\tWRITE_ONCE(rdp->dynticks_nesting, 1);\n\tWARN_ON_ONCE(rdp->dynticks_nmi_nesting);\n\tWRITE_ONCE(rdp->dynticks_nmi_nesting, DYNTICK_IRQ_NONIDLE);\n\tinstrumentation_end();\n}"
  },
  {
    "function_name": "rcu_irq_exit_irqson",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
    "lines": "831-838",
    "snippet": "void rcu_irq_exit_irqson(void)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\trcu_irq_exit();\n\tlocal_irq_restore(flags);\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_nocb.h\"",
      "#include \"tree_exp.h\"",
      "#include \"tree_stall.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <linux/kasan.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/panic_notifier.h>",
      "#include <linux/panic.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 837
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_irq_exit",
          "args": [],
          "line": 836
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_irq_exit_irqson",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "831-838",
          "snippet": "void rcu_irq_exit_irqson(void)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\trcu_irq_exit();\n\tlocal_irq_restore(flags);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "local_irq_save",
          "args": [
            "flags"
          ],
          "line": 835
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);\n\nvoid rcu_irq_exit_irqson(void)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\trcu_irq_exit();\n\tlocal_irq_restore(flags);\n}"
  },
  {
    "function_name": "rcu_irq_exit_check_preempt",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
    "lines": "811-822",
    "snippet": "void rcu_irq_exit_check_preempt(void)\n{\n\tlockdep_assert_irqs_disabled();\n\n\tRCU_LOCKDEP_WARN(__this_cpu_read(rcu_data.dynticks_nesting) <= 0,\n\t\t\t \"RCU dynticks_nesting counter underflow/zero!\");\n\tRCU_LOCKDEP_WARN(__this_cpu_read(rcu_data.dynticks_nmi_nesting) !=\n\t\t\t DYNTICK_IRQ_NONIDLE,\n\t\t\t \"Bad RCU  dynticks_nmi_nesting counter\\n\");\n\tRCU_LOCKDEP_WARN(rcu_dynticks_curr_cpu_in_eqs(),\n\t\t\t \"RCU in extended quiescent state!\");\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_nocb.h\"",
      "#include \"tree_exp.h\"",
      "#include \"tree_stall.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <linux/kasan.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/panic_notifier.h>",
      "#include <linux/panic.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "RCU_LOCKDEP_WARN",
          "args": [
            "rcu_dynticks_curr_cpu_in_eqs()",
            "\"RCU in extended quiescent state!\""
          ],
          "line": 820
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_dynticks_curr_cpu_in_eqs",
          "args": [],
          "line": 820
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_dynticks_curr_cpu_in_eqs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "328-331",
          "snippet": "static __always_inline bool rcu_dynticks_curr_cpu_in_eqs(void)\n{\n\treturn !(arch_atomic_read(this_cpu_ptr(&rcu_data.dynticks)) & 0x1);\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};\n\nstatic __always_inline bool rcu_dynticks_curr_cpu_in_eqs(void)\n{\n\treturn !(arch_atomic_read(this_cpu_ptr(&rcu_data.dynticks)) & 0x1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "RCU_LOCKDEP_WARN",
          "args": [
            "__this_cpu_read(rcu_data.dynticks_nmi_nesting) !=\n\t\t\t DYNTICK_IRQ_NONIDLE",
            "\"Bad RCU  dynticks_nmi_nesting counter\\n\""
          ],
          "line": 817
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__this_cpu_read",
          "args": [
            "rcu_data.dynticks_nmi_nesting"
          ],
          "line": 817
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RCU_LOCKDEP_WARN",
          "args": [
            "__this_cpu_read(rcu_data.dynticks_nesting) <= 0",
            "\"RCU dynticks_nesting counter underflow/zero!\""
          ],
          "line": 815
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__this_cpu_read",
          "args": [
            "rcu_data.dynticks_nesting"
          ],
          "line": 815
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_irqs_disabled",
          "args": [],
          "line": 813
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};\n\nvoid rcu_irq_exit_check_preempt(void)\n{\n\tlockdep_assert_irqs_disabled();\n\n\tRCU_LOCKDEP_WARN(__this_cpu_read(rcu_data.dynticks_nesting) <= 0,\n\t\t\t \"RCU dynticks_nesting counter underflow/zero!\");\n\tRCU_LOCKDEP_WARN(__this_cpu_read(rcu_data.dynticks_nmi_nesting) !=\n\t\t\t DYNTICK_IRQ_NONIDLE,\n\t\t\t \"Bad RCU  dynticks_nmi_nesting counter\\n\");\n\tRCU_LOCKDEP_WARN(rcu_dynticks_curr_cpu_in_eqs(),\n\t\t\t \"RCU in extended quiescent state!\");\n}"
  },
  {
    "function_name": "rcu_irq_exit",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
    "lines": "801-805",
    "snippet": "void noinstr rcu_irq_exit(void)\n{\n\tlockdep_assert_irqs_disabled();\n\trcu_nmi_exit();\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_nocb.h\"",
      "#include \"tree_exp.h\"",
      "#include \"tree_stall.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <linux/kasan.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/panic_notifier.h>",
      "#include <linux/panic.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline noinstr"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_nmi_exit",
          "args": [],
          "line": 804
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_nmi_exit",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "740-780",
          "snippet": "noinstr void rcu_nmi_exit(void)\n{\n\tstruct rcu_data *rdp = this_cpu_ptr(&rcu_data);\n\n\tinstrumentation_begin();\n\t/*\n\t * Check for ->dynticks_nmi_nesting underflow and bad ->dynticks.\n\t * (We are exiting an NMI handler, so RCU better be paying attention\n\t * to us!)\n\t */\n\tWARN_ON_ONCE(rdp->dynticks_nmi_nesting <= 0);\n\tWARN_ON_ONCE(rcu_dynticks_curr_cpu_in_eqs());\n\n\t/*\n\t * If the nesting level is not 1, the CPU wasn't RCU-idle, so\n\t * leave it in non-RCU-idle state.\n\t */\n\tif (rdp->dynticks_nmi_nesting != 1) {\n\t\ttrace_rcu_dyntick(TPS(\"--=\"), rdp->dynticks_nmi_nesting, rdp->dynticks_nmi_nesting - 2,\n\t\t\t\t  atomic_read(&rdp->dynticks));\n\t\tWRITE_ONCE(rdp->dynticks_nmi_nesting, /* No store tearing. */\n\t\t\t   rdp->dynticks_nmi_nesting - 2);\n\t\tinstrumentation_end();\n\t\treturn;\n\t}\n\n\t/* This NMI interrupted an RCU-idle CPU, restore RCU-idleness. */\n\ttrace_rcu_dyntick(TPS(\"Startirq\"), rdp->dynticks_nmi_nesting, 0, atomic_read(&rdp->dynticks));\n\tWRITE_ONCE(rdp->dynticks_nmi_nesting, 0); /* Avoid store tearing. */\n\n\t// instrumentation for the noinstr rcu_dynticks_eqs_enter()\n\tinstrument_atomic_write(&rdp->dynticks, sizeof(rdp->dynticks));\n\tinstrumentation_end();\n\n\t// RCU is watching here ...\n\trcu_dynticks_eqs_enter();\n\t// ... but is no longer watching here.\n\n\tif (!in_nmi())\n\t\trcu_dynticks_task_enter();\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};",
            "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
            "static bool rcu_rdp_is_offloaded(struct rcu_data *rdp);",
            "static noinline noinstr",
            "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic bool rcu_rdp_is_offloaded(struct rcu_data *rdp);\nstatic noinline noinstr;\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nnoinstr void rcu_nmi_exit(void)\n{\n\tstruct rcu_data *rdp = this_cpu_ptr(&rcu_data);\n\n\tinstrumentation_begin();\n\t/*\n\t * Check for ->dynticks_nmi_nesting underflow and bad ->dynticks.\n\t * (We are exiting an NMI handler, so RCU better be paying attention\n\t * to us!)\n\t */\n\tWARN_ON_ONCE(rdp->dynticks_nmi_nesting <= 0);\n\tWARN_ON_ONCE(rcu_dynticks_curr_cpu_in_eqs());\n\n\t/*\n\t * If the nesting level is not 1, the CPU wasn't RCU-idle, so\n\t * leave it in non-RCU-idle state.\n\t */\n\tif (rdp->dynticks_nmi_nesting != 1) {\n\t\ttrace_rcu_dyntick(TPS(\"--=\"), rdp->dynticks_nmi_nesting, rdp->dynticks_nmi_nesting - 2,\n\t\t\t\t  atomic_read(&rdp->dynticks));\n\t\tWRITE_ONCE(rdp->dynticks_nmi_nesting, /* No store tearing. */\n\t\t\t   rdp->dynticks_nmi_nesting - 2);\n\t\tinstrumentation_end();\n\t\treturn;\n\t}\n\n\t/* This NMI interrupted an RCU-idle CPU, restore RCU-idleness. */\n\ttrace_rcu_dyntick(TPS(\"Startirq\"), rdp->dynticks_nmi_nesting, 0, atomic_read(&rdp->dynticks));\n\tWRITE_ONCE(rdp->dynticks_nmi_nesting, 0); /* Avoid store tearing. */\n\n\t// instrumentation for the noinstr rcu_dynticks_eqs_enter()\n\tinstrument_atomic_write(&rdp->dynticks, sizeof(rdp->dynticks));\n\tinstrumentation_end();\n\n\t// RCU is watching here ...\n\trcu_dynticks_eqs_enter();\n\t// ... but is no longer watching here.\n\n\tif (!in_nmi())\n\t\trcu_dynticks_task_enter();\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_assert_irqs_disabled",
          "args": [],
          "line": 803
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic noinline noinstr;\n\nvoid noinstr rcu_irq_exit(void)\n{\n\tlockdep_assert_irqs_disabled();\n\trcu_nmi_exit();\n}"
  },
  {
    "function_name": "rcu_nmi_exit",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
    "lines": "740-780",
    "snippet": "noinstr void rcu_nmi_exit(void)\n{\n\tstruct rcu_data *rdp = this_cpu_ptr(&rcu_data);\n\n\tinstrumentation_begin();\n\t/*\n\t * Check for ->dynticks_nmi_nesting underflow and bad ->dynticks.\n\t * (We are exiting an NMI handler, so RCU better be paying attention\n\t * to us!)\n\t */\n\tWARN_ON_ONCE(rdp->dynticks_nmi_nesting <= 0);\n\tWARN_ON_ONCE(rcu_dynticks_curr_cpu_in_eqs());\n\n\t/*\n\t * If the nesting level is not 1, the CPU wasn't RCU-idle, so\n\t * leave it in non-RCU-idle state.\n\t */\n\tif (rdp->dynticks_nmi_nesting != 1) {\n\t\ttrace_rcu_dyntick(TPS(\"--=\"), rdp->dynticks_nmi_nesting, rdp->dynticks_nmi_nesting - 2,\n\t\t\t\t  atomic_read(&rdp->dynticks));\n\t\tWRITE_ONCE(rdp->dynticks_nmi_nesting, /* No store tearing. */\n\t\t\t   rdp->dynticks_nmi_nesting - 2);\n\t\tinstrumentation_end();\n\t\treturn;\n\t}\n\n\t/* This NMI interrupted an RCU-idle CPU, restore RCU-idleness. */\n\ttrace_rcu_dyntick(TPS(\"Startirq\"), rdp->dynticks_nmi_nesting, 0, atomic_read(&rdp->dynticks));\n\tWRITE_ONCE(rdp->dynticks_nmi_nesting, 0); /* Avoid store tearing. */\n\n\t// instrumentation for the noinstr rcu_dynticks_eqs_enter()\n\tinstrument_atomic_write(&rdp->dynticks, sizeof(rdp->dynticks));\n\tinstrumentation_end();\n\n\t// RCU is watching here ...\n\trcu_dynticks_eqs_enter();\n\t// ... but is no longer watching here.\n\n\tif (!in_nmi())\n\t\trcu_dynticks_task_enter();\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_nocb.h\"",
      "#include \"tree_exp.h\"",
      "#include \"tree_stall.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <linux/kasan.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/panic_notifier.h>",
      "#include <linux/panic.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};",
      "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
      "static bool rcu_rdp_is_offloaded(struct rcu_data *rdp);",
      "static noinline noinstr",
      "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_dynticks_task_enter",
          "args": [],
          "line": 779
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_dynticks_task_enter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "1298-1303",
          "snippet": "static __always_inline void rcu_dynticks_task_enter(void)\n{\n#if defined(CONFIG_TASKS_RCU) && defined(CONFIG_NO_HZ_FULL)\n\tWRITE_ONCE(current->rcu_tasks_idle_cpu, smp_processor_id());\n#endif /* #if defined(CONFIG_TASKS_RCU) && defined(CONFIG_NO_HZ_FULL) */\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nstatic __always_inline void rcu_dynticks_task_enter(void)\n{\n#if defined(CONFIG_TASKS_RCU) && defined(CONFIG_NO_HZ_FULL)\n\tWRITE_ONCE(current->rcu_tasks_idle_cpu, smp_processor_id());\n#endif /* #if defined(CONFIG_TASKS_RCU) && defined(CONFIG_NO_HZ_FULL) */\n}"
        }
      },
      {
        "call_info": {
          "callee": "in_nmi",
          "args": [],
          "line": 778
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_dynticks_eqs_enter",
          "args": [],
          "line": 775
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_dynticks_eqs_enter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "269-282",
          "snippet": "static noinstr void rcu_dynticks_eqs_enter(void)\n{\n\tint seq;\n\n\t/*\n\t * CPUs seeing atomic_add_return() must see prior RCU read-side\n\t * critical sections, and we also must force ordering with the\n\t * next idle sojourn.\n\t */\n\trcu_dynticks_task_trace_enter();  // Before ->dynticks update!\n\tseq = rcu_dynticks_inc(1);\n\t// RCU is no longer watching.  Better be in extended quiescent state!\n\tWARN_ON_ONCE(IS_ENABLED(CONFIG_RCU_EQS_DEBUG) && (seq & 0x1));\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline noinstr"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic noinline noinstr;\n\nstatic noinstr void rcu_dynticks_eqs_enter(void)\n{\n\tint seq;\n\n\t/*\n\t * CPUs seeing atomic_add_return() must see prior RCU read-side\n\t * critical sections, and we also must force ordering with the\n\t * next idle sojourn.\n\t */\n\trcu_dynticks_task_trace_enter();  // Before ->dynticks update!\n\tseq = rcu_dynticks_inc(1);\n\t// RCU is no longer watching.  Better be in extended quiescent state!\n\tWARN_ON_ONCE(IS_ENABLED(CONFIG_RCU_EQS_DEBUG) && (seq & 0x1));\n}"
        }
      },
      {
        "call_info": {
          "callee": "instrumentation_end",
          "args": [],
          "line": 772
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "instrument_atomic_write",
          "args": [
            "&rdp->dynticks",
            "sizeof(rdp->dynticks)"
          ],
          "line": 771
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "rdp->dynticks_nmi_nesting",
            "0"
          ],
          "line": 768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_rcu_dyntick",
          "args": [
            "TPS(\"Startirq\")",
            "rdp->dynticks_nmi_nesting",
            "0",
            "atomic_read(&rdp->dynticks)"
          ],
          "line": 767
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&rdp->dynticks"
          ],
          "line": 767
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPS",
          "args": [
            "\"Startirq\""
          ],
          "line": 767
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "instrumentation_end",
          "args": [],
          "line": 762
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "rdp->dynticks_nmi_nesting",
            "/* No store tearing. */rdp->dynticks_nmi_nesting - 2"
          ],
          "line": 760
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_rcu_dyntick",
          "args": [
            "TPS(\"--=\")",
            "rdp->dynticks_nmi_nesting",
            "rdp->dynticks_nmi_nesting - 2",
            "atomic_read(&rdp->dynticks)"
          ],
          "line": 758
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&rdp->dynticks"
          ],
          "line": 759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPS",
          "args": [
            "\"--=\""
          ],
          "line": 758
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "rcu_dynticks_curr_cpu_in_eqs()"
          ],
          "line": 751
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_dynticks_curr_cpu_in_eqs",
          "args": [],
          "line": 751
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_dynticks_curr_cpu_in_eqs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "328-331",
          "snippet": "static __always_inline bool rcu_dynticks_curr_cpu_in_eqs(void)\n{\n\treturn !(arch_atomic_read(this_cpu_ptr(&rcu_data.dynticks)) & 0x1);\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};\n\nstatic __always_inline bool rcu_dynticks_curr_cpu_in_eqs(void)\n{\n\treturn !(arch_atomic_read(this_cpu_ptr(&rcu_data.dynticks)) & 0x1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "rdp->dynticks_nmi_nesting <= 0"
          ],
          "line": 750
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "instrumentation_begin",
          "args": [],
          "line": 744
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&rcu_data"
          ],
          "line": 742
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic bool rcu_rdp_is_offloaded(struct rcu_data *rdp);\nstatic noinline noinstr;\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nnoinstr void rcu_nmi_exit(void)\n{\n\tstruct rcu_data *rdp = this_cpu_ptr(&rcu_data);\n\n\tinstrumentation_begin();\n\t/*\n\t * Check for ->dynticks_nmi_nesting underflow and bad ->dynticks.\n\t * (We are exiting an NMI handler, so RCU better be paying attention\n\t * to us!)\n\t */\n\tWARN_ON_ONCE(rdp->dynticks_nmi_nesting <= 0);\n\tWARN_ON_ONCE(rcu_dynticks_curr_cpu_in_eqs());\n\n\t/*\n\t * If the nesting level is not 1, the CPU wasn't RCU-idle, so\n\t * leave it in non-RCU-idle state.\n\t */\n\tif (rdp->dynticks_nmi_nesting != 1) {\n\t\ttrace_rcu_dyntick(TPS(\"--=\"), rdp->dynticks_nmi_nesting, rdp->dynticks_nmi_nesting - 2,\n\t\t\t\t  atomic_read(&rdp->dynticks));\n\t\tWRITE_ONCE(rdp->dynticks_nmi_nesting, /* No store tearing. */\n\t\t\t   rdp->dynticks_nmi_nesting - 2);\n\t\tinstrumentation_end();\n\t\treturn;\n\t}\n\n\t/* This NMI interrupted an RCU-idle CPU, restore RCU-idleness. */\n\ttrace_rcu_dyntick(TPS(\"Startirq\"), rdp->dynticks_nmi_nesting, 0, atomic_read(&rdp->dynticks));\n\tWRITE_ONCE(rdp->dynticks_nmi_nesting, 0); /* Avoid store tearing. */\n\n\t// instrumentation for the noinstr rcu_dynticks_eqs_enter()\n\tinstrument_atomic_write(&rdp->dynticks, sizeof(rdp->dynticks));\n\tinstrumentation_end();\n\n\t// RCU is watching here ...\n\trcu_dynticks_eqs_enter();\n\t// ... but is no longer watching here.\n\n\tif (!in_nmi())\n\t\trcu_dynticks_task_enter();\n}"
  },
  {
    "function_name": "rcu_user_enter",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
    "lines": "714-725",
    "snippet": "noinstr void rcu_user_enter(void)\n{\n\tlockdep_assert_irqs_disabled();\n\n\t/*\n\t * Other than generic entry implementation, we may be past the last\n\t * rescheduling opportunity in the entry code. Trigger a self IPI\n\t * that will fire and reschedule once we resume in user/guest mode.\n\t */\n\trcu_irq_work_resched();\n\trcu_eqs_enter(true);\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_nocb.h\"",
      "#include \"tree_exp.h\"",
      "#include \"tree_stall.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <linux/kasan.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/panic_notifier.h>",
      "#include <linux/panic.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline noinstr",
      "static int rcu_pending(int user);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_eqs_enter",
          "args": [
            "true"
          ],
          "line": 724
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_eqs_enter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "609-638",
          "snippet": "static noinstr void rcu_eqs_enter(bool user)\n{\n\tstruct rcu_data *rdp = this_cpu_ptr(&rcu_data);\n\n\tWARN_ON_ONCE(rdp->dynticks_nmi_nesting != DYNTICK_IRQ_NONIDLE);\n\tWRITE_ONCE(rdp->dynticks_nmi_nesting, 0);\n\tWARN_ON_ONCE(IS_ENABLED(CONFIG_RCU_EQS_DEBUG) &&\n\t\t     rdp->dynticks_nesting == 0);\n\tif (rdp->dynticks_nesting != 1) {\n\t\t// RCU will still be watching, so just do accounting and leave.\n\t\trdp->dynticks_nesting--;\n\t\treturn;\n\t}\n\n\tlockdep_assert_irqs_disabled();\n\tinstrumentation_begin();\n\ttrace_rcu_dyntick(TPS(\"Start\"), rdp->dynticks_nesting, 0, atomic_read(&rdp->dynticks));\n\tWARN_ON_ONCE(IS_ENABLED(CONFIG_RCU_EQS_DEBUG) && !user && !is_idle_task(current));\n\trcu_preempt_deferred_qs(current);\n\n\t// instrumentation for the noinstr rcu_dynticks_eqs_enter()\n\tinstrument_atomic_write(&rdp->dynticks, sizeof(rdp->dynticks));\n\n\tinstrumentation_end();\n\tWRITE_ONCE(rdp->dynticks_nesting, 0); /* Avoid irq-access tearing. */\n\t// RCU is watching here ...\n\trcu_dynticks_eqs_enter();\n\t// ... but is no longer watching here.\n\trcu_dynticks_task_enter();\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};",
            "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
            "static bool rcu_rdp_is_offloaded(struct rcu_data *rdp);",
            "static noinline noinstr",
            "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));",
            "static int rcu_pending(int user);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic bool rcu_rdp_is_offloaded(struct rcu_data *rdp);\nstatic noinline noinstr;\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\nstatic int rcu_pending(int user);\n\nstatic noinstr void rcu_eqs_enter(bool user)\n{\n\tstruct rcu_data *rdp = this_cpu_ptr(&rcu_data);\n\n\tWARN_ON_ONCE(rdp->dynticks_nmi_nesting != DYNTICK_IRQ_NONIDLE);\n\tWRITE_ONCE(rdp->dynticks_nmi_nesting, 0);\n\tWARN_ON_ONCE(IS_ENABLED(CONFIG_RCU_EQS_DEBUG) &&\n\t\t     rdp->dynticks_nesting == 0);\n\tif (rdp->dynticks_nesting != 1) {\n\t\t// RCU will still be watching, so just do accounting and leave.\n\t\trdp->dynticks_nesting--;\n\t\treturn;\n\t}\n\n\tlockdep_assert_irqs_disabled();\n\tinstrumentation_begin();\n\ttrace_rcu_dyntick(TPS(\"Start\"), rdp->dynticks_nesting, 0, atomic_read(&rdp->dynticks));\n\tWARN_ON_ONCE(IS_ENABLED(CONFIG_RCU_EQS_DEBUG) && !user && !is_idle_task(current));\n\trcu_preempt_deferred_qs(current);\n\n\t// instrumentation for the noinstr rcu_dynticks_eqs_enter()\n\tinstrument_atomic_write(&rdp->dynticks, sizeof(rdp->dynticks));\n\n\tinstrumentation_end();\n\tWRITE_ONCE(rdp->dynticks_nesting, 0); /* Avoid irq-access tearing. */\n\t// RCU is watching here ...\n\trcu_dynticks_eqs_enter();\n\t// ... but is no longer watching here.\n\trcu_dynticks_task_enter();\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_irq_work_resched",
          "args": [],
          "line": 723
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_irq_work_resched",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "700-700",
          "snippet": "static inline void rcu_irq_work_resched(void) { }",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic inline void rcu_irq_work_resched(void) { }"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_assert_irqs_disabled",
          "args": [],
          "line": 716
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic noinline noinstr;\nstatic int rcu_pending(int user);\n\nnoinstr void rcu_user_enter(void)\n{\n\tlockdep_assert_irqs_disabled();\n\n\t/*\n\t * Other than generic entry implementation, we may be past the last\n\t * rescheduling opportunity in the entry code. Trigger a self IPI\n\t * that will fire and reschedule once we resume in user/guest mode.\n\t */\n\trcu_irq_work_resched();\n\trcu_eqs_enter(true);\n}"
  },
  {
    "function_name": "rcu_irq_work_resched",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
    "lines": "700-700",
    "snippet": "static inline void rcu_irq_work_resched(void) { }",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_nocb.h\"",
      "#include \"tree_exp.h\"",
      "#include \"tree_stall.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <linux/kasan.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/panic_notifier.h>",
      "#include <linux/panic.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic inline void rcu_irq_work_resched(void) { }"
  },
  {
    "function_name": "rcu_irq_work_resched",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
    "lines": "682-697",
    "snippet": "noinstr static void rcu_irq_work_resched(void)\n{\n\tstruct rcu_data *rdp = this_cpu_ptr(&rcu_data);\n\n\tif (IS_ENABLED(CONFIG_GENERIC_ENTRY) && !(current->flags & PF_VCPU))\n\t\treturn;\n\n\tif (IS_ENABLED(CONFIG_KVM_XFER_TO_GUEST_WORK) && (current->flags & PF_VCPU))\n\t\treturn;\n\n\tinstrumentation_begin();\n\tif (do_nocb_deferred_wakeup(rdp) && need_resched()) {\n\t\tirq_work_queue(this_cpu_ptr(&late_wakeup_work));\n\t}\n\tinstrumentation_end();\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_nocb.h\"",
      "#include \"tree_exp.h\"",
      "#include \"tree_stall.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <linux/kasan.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/panic_notifier.h>",
      "#include <linux/panic.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};",
      "static void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);",
      "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
      "static bool rcu_rdp_is_offloaded(struct rcu_data *rdp);",
      "static noinline noinstr",
      "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "instrumentation_end",
          "args": [],
          "line": 696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_work_queue",
          "args": [
            "this_cpu_ptr(&late_wakeup_work)"
          ],
          "line": 694
        },
        "resolved": true,
        "details": {
          "function_name": "irq_work_queue",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq_work.c",
          "lines": "106-118",
          "snippet": "bool irq_work_queue(struct irq_work *work)\n{\n\t/* Only queue if not already pending */\n\tif (!irq_work_claim(work))\n\t\treturn false;\n\n\t/* Queue the entry and raise the IPI if needed. */\n\tpreempt_disable();\n\t__irq_work_queue_local(work);\n\tpreempt_enable();\n\n\treturn true;\n}",
          "includes": [
            "#include <linux/kasan.h>",
            "#include <asm/processor.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/smp.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/tick.h>",
            "#include <linux/sched.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/percpu.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>",
            "#include <linux/bug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kasan.h>\n#include <asm/processor.h>\n#include <linux/smpboot.h>\n#include <linux/smp.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/tick.h>\n#include <linux/sched.h>\n#include <linux/irqflags.h>\n#include <linux/hardirq.h>\n#include <linux/percpu.h>\n#include <linux/irq_work.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/bug.h>\n\nbool irq_work_queue(struct irq_work *work)\n{\n\t/* Only queue if not already pending */\n\tif (!irq_work_claim(work))\n\t\treturn false;\n\n\t/* Queue the entry and raise the IPI if needed. */\n\tpreempt_disable();\n\t__irq_work_queue_local(work);\n\tpreempt_enable();\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&late_wakeup_work"
          ],
          "line": 694
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "need_resched",
          "args": [],
          "line": 693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_nocb_deferred_wakeup",
          "args": [
            "rdp"
          ],
          "line": 693
        },
        "resolved": true,
        "details": {
          "function_name": "do_nocb_deferred_wakeup",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_nocb.h",
          "lines": "1531-1534",
          "snippet": "static bool do_nocb_deferred_wakeup(struct rcu_data *rdp)\n{\n\treturn false;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static bool do_nocb_deferred_wakeup(struct rcu_data *rdp)\n{\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "instrumentation_begin",
          "args": [],
          "line": 692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_KVM_XFER_TO_GUEST_WORK"
          ],
          "line": 689
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_GENERIC_ENTRY"
          ],
          "line": 686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&rcu_data"
          ],
          "line": 684
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};\nstatic void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic bool rcu_rdp_is_offloaded(struct rcu_data *rdp);\nstatic noinline noinstr;\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nnoinstr static void rcu_irq_work_resched(void)\n{\n\tstruct rcu_data *rdp = this_cpu_ptr(&rcu_data);\n\n\tif (IS_ENABLED(CONFIG_GENERIC_ENTRY) && !(current->flags & PF_VCPU))\n\t\treturn;\n\n\tif (IS_ENABLED(CONFIG_KVM_XFER_TO_GUEST_WORK) && (current->flags & PF_VCPU))\n\t\treturn;\n\n\tinstrumentation_begin();\n\tif (do_nocb_deferred_wakeup(rdp) && need_resched()) {\n\t\tirq_work_queue(this_cpu_ptr(&late_wakeup_work));\n\t}\n\tinstrumentation_end();\n}"
  },
  {
    "function_name": "late_wakeup_func",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
    "lines": "665-667",
    "snippet": "static void late_wakeup_func(struct irq_work *work)\n{\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_nocb.h\"",
      "#include \"tree_exp.h\"",
      "#include \"tree_stall.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <linux/kasan.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/panic_notifier.h>",
      "#include <linux/panic.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic void late_wakeup_func(struct irq_work *work)\n{\n}"
  },
  {
    "function_name": "rcu_idle_enter",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
    "lines": "651-655",
    "snippet": "void rcu_idle_enter(void)\n{\n\tlockdep_assert_irqs_disabled();\n\trcu_eqs_enter(false);\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_nocb.h\"",
      "#include \"tree_exp.h\"",
      "#include \"tree_stall.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <linux/kasan.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/panic_notifier.h>",
      "#include <linux/panic.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_eqs_enter",
          "args": [
            "false"
          ],
          "line": 654
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_eqs_enter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "609-638",
          "snippet": "static noinstr void rcu_eqs_enter(bool user)\n{\n\tstruct rcu_data *rdp = this_cpu_ptr(&rcu_data);\n\n\tWARN_ON_ONCE(rdp->dynticks_nmi_nesting != DYNTICK_IRQ_NONIDLE);\n\tWRITE_ONCE(rdp->dynticks_nmi_nesting, 0);\n\tWARN_ON_ONCE(IS_ENABLED(CONFIG_RCU_EQS_DEBUG) &&\n\t\t     rdp->dynticks_nesting == 0);\n\tif (rdp->dynticks_nesting != 1) {\n\t\t// RCU will still be watching, so just do accounting and leave.\n\t\trdp->dynticks_nesting--;\n\t\treturn;\n\t}\n\n\tlockdep_assert_irqs_disabled();\n\tinstrumentation_begin();\n\ttrace_rcu_dyntick(TPS(\"Start\"), rdp->dynticks_nesting, 0, atomic_read(&rdp->dynticks));\n\tWARN_ON_ONCE(IS_ENABLED(CONFIG_RCU_EQS_DEBUG) && !user && !is_idle_task(current));\n\trcu_preempt_deferred_qs(current);\n\n\t// instrumentation for the noinstr rcu_dynticks_eqs_enter()\n\tinstrument_atomic_write(&rdp->dynticks, sizeof(rdp->dynticks));\n\n\tinstrumentation_end();\n\tWRITE_ONCE(rdp->dynticks_nesting, 0); /* Avoid irq-access tearing. */\n\t// RCU is watching here ...\n\trcu_dynticks_eqs_enter();\n\t// ... but is no longer watching here.\n\trcu_dynticks_task_enter();\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};",
            "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
            "static bool rcu_rdp_is_offloaded(struct rcu_data *rdp);",
            "static noinline noinstr",
            "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));",
            "static int rcu_pending(int user);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic bool rcu_rdp_is_offloaded(struct rcu_data *rdp);\nstatic noinline noinstr;\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\nstatic int rcu_pending(int user);\n\nstatic noinstr void rcu_eqs_enter(bool user)\n{\n\tstruct rcu_data *rdp = this_cpu_ptr(&rcu_data);\n\n\tWARN_ON_ONCE(rdp->dynticks_nmi_nesting != DYNTICK_IRQ_NONIDLE);\n\tWRITE_ONCE(rdp->dynticks_nmi_nesting, 0);\n\tWARN_ON_ONCE(IS_ENABLED(CONFIG_RCU_EQS_DEBUG) &&\n\t\t     rdp->dynticks_nesting == 0);\n\tif (rdp->dynticks_nesting != 1) {\n\t\t// RCU will still be watching, so just do accounting and leave.\n\t\trdp->dynticks_nesting--;\n\t\treturn;\n\t}\n\n\tlockdep_assert_irqs_disabled();\n\tinstrumentation_begin();\n\ttrace_rcu_dyntick(TPS(\"Start\"), rdp->dynticks_nesting, 0, atomic_read(&rdp->dynticks));\n\tWARN_ON_ONCE(IS_ENABLED(CONFIG_RCU_EQS_DEBUG) && !user && !is_idle_task(current));\n\trcu_preempt_deferred_qs(current);\n\n\t// instrumentation for the noinstr rcu_dynticks_eqs_enter()\n\tinstrument_atomic_write(&rdp->dynticks, sizeof(rdp->dynticks));\n\n\tinstrumentation_end();\n\tWRITE_ONCE(rdp->dynticks_nesting, 0); /* Avoid irq-access tearing. */\n\t// RCU is watching here ...\n\trcu_dynticks_eqs_enter();\n\t// ... but is no longer watching here.\n\trcu_dynticks_task_enter();\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_assert_irqs_disabled",
          "args": [],
          "line": 653
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nvoid rcu_idle_enter(void)\n{\n\tlockdep_assert_irqs_disabled();\n\trcu_eqs_enter(false);\n}"
  },
  {
    "function_name": "rcu_eqs_enter",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
    "lines": "609-638",
    "snippet": "static noinstr void rcu_eqs_enter(bool user)\n{\n\tstruct rcu_data *rdp = this_cpu_ptr(&rcu_data);\n\n\tWARN_ON_ONCE(rdp->dynticks_nmi_nesting != DYNTICK_IRQ_NONIDLE);\n\tWRITE_ONCE(rdp->dynticks_nmi_nesting, 0);\n\tWARN_ON_ONCE(IS_ENABLED(CONFIG_RCU_EQS_DEBUG) &&\n\t\t     rdp->dynticks_nesting == 0);\n\tif (rdp->dynticks_nesting != 1) {\n\t\t// RCU will still be watching, so just do accounting and leave.\n\t\trdp->dynticks_nesting--;\n\t\treturn;\n\t}\n\n\tlockdep_assert_irqs_disabled();\n\tinstrumentation_begin();\n\ttrace_rcu_dyntick(TPS(\"Start\"), rdp->dynticks_nesting, 0, atomic_read(&rdp->dynticks));\n\tWARN_ON_ONCE(IS_ENABLED(CONFIG_RCU_EQS_DEBUG) && !user && !is_idle_task(current));\n\trcu_preempt_deferred_qs(current);\n\n\t// instrumentation for the noinstr rcu_dynticks_eqs_enter()\n\tinstrument_atomic_write(&rdp->dynticks, sizeof(rdp->dynticks));\n\n\tinstrumentation_end();\n\tWRITE_ONCE(rdp->dynticks_nesting, 0); /* Avoid irq-access tearing. */\n\t// RCU is watching here ...\n\trcu_dynticks_eqs_enter();\n\t// ... but is no longer watching here.\n\trcu_dynticks_task_enter();\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_nocb.h\"",
      "#include \"tree_exp.h\"",
      "#include \"tree_stall.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <linux/kasan.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/panic_notifier.h>",
      "#include <linux/panic.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};",
      "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
      "static bool rcu_rdp_is_offloaded(struct rcu_data *rdp);",
      "static noinline noinstr",
      "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));",
      "static int rcu_pending(int user);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_dynticks_task_enter",
          "args": [],
          "line": 637
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_dynticks_task_enter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "1298-1303",
          "snippet": "static __always_inline void rcu_dynticks_task_enter(void)\n{\n#if defined(CONFIG_TASKS_RCU) && defined(CONFIG_NO_HZ_FULL)\n\tWRITE_ONCE(current->rcu_tasks_idle_cpu, smp_processor_id());\n#endif /* #if defined(CONFIG_TASKS_RCU) && defined(CONFIG_NO_HZ_FULL) */\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nstatic __always_inline void rcu_dynticks_task_enter(void)\n{\n#if defined(CONFIG_TASKS_RCU) && defined(CONFIG_NO_HZ_FULL)\n\tWRITE_ONCE(current->rcu_tasks_idle_cpu, smp_processor_id());\n#endif /* #if defined(CONFIG_TASKS_RCU) && defined(CONFIG_NO_HZ_FULL) */\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_dynticks_eqs_enter",
          "args": [],
          "line": 635
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_dynticks_eqs_enter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "269-282",
          "snippet": "static noinstr void rcu_dynticks_eqs_enter(void)\n{\n\tint seq;\n\n\t/*\n\t * CPUs seeing atomic_add_return() must see prior RCU read-side\n\t * critical sections, and we also must force ordering with the\n\t * next idle sojourn.\n\t */\n\trcu_dynticks_task_trace_enter();  // Before ->dynticks update!\n\tseq = rcu_dynticks_inc(1);\n\t// RCU is no longer watching.  Better be in extended quiescent state!\n\tWARN_ON_ONCE(IS_ENABLED(CONFIG_RCU_EQS_DEBUG) && (seq & 0x1));\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline noinstr"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic noinline noinstr;\n\nstatic noinstr void rcu_dynticks_eqs_enter(void)\n{\n\tint seq;\n\n\t/*\n\t * CPUs seeing atomic_add_return() must see prior RCU read-side\n\t * critical sections, and we also must force ordering with the\n\t * next idle sojourn.\n\t */\n\trcu_dynticks_task_trace_enter();  // Before ->dynticks update!\n\tseq = rcu_dynticks_inc(1);\n\t// RCU is no longer watching.  Better be in extended quiescent state!\n\tWARN_ON_ONCE(IS_ENABLED(CONFIG_RCU_EQS_DEBUG) && (seq & 0x1));\n}"
        }
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "rdp->dynticks_nesting",
            "0"
          ],
          "line": 633
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "instrumentation_end",
          "args": [],
          "line": 632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "instrument_atomic_write",
          "args": [
            "&rdp->dynticks",
            "sizeof(rdp->dynticks)"
          ],
          "line": 630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_preempt_deferred_qs",
          "args": [
            "current"
          ],
          "line": 627
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_preempt_deferred_qs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "933-939",
          "snippet": "static void rcu_preempt_deferred_qs(struct task_struct *t)\n{\n\tstruct rcu_data *rdp = this_cpu_ptr(&rcu_data);\n\n\tif (rdp->cpu_no_qs.b.exp)\n\t\trcu_report_exp_rdp(rdp);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nstatic void rcu_preempt_deferred_qs(struct task_struct *t)\n{\n\tstruct rcu_data *rdp = this_cpu_ptr(&rcu_data);\n\n\tif (rdp->cpu_no_qs.b.exp)\n\t\trcu_report_exp_rdp(rdp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "IS_ENABLED(CONFIG_RCU_EQS_DEBUG) && !user && !is_idle_task(current)"
          ],
          "line": 626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_idle_task",
          "args": [
            "current"
          ],
          "line": 626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_RCU_EQS_DEBUG"
          ],
          "line": 626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_rcu_dyntick",
          "args": [
            "TPS(\"Start\")",
            "rdp->dynticks_nesting",
            "0",
            "atomic_read(&rdp->dynticks)"
          ],
          "line": 625
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&rdp->dynticks"
          ],
          "line": 625
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPS",
          "args": [
            "\"Start\""
          ],
          "line": 625
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "instrumentation_begin",
          "args": [],
          "line": 624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_irqs_disabled",
          "args": [],
          "line": 623
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "IS_ENABLED(CONFIG_RCU_EQS_DEBUG) &&\n\t\t     rdp->dynticks_nesting == 0"
          ],
          "line": 615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_RCU_EQS_DEBUG"
          ],
          "line": 615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "rdp->dynticks_nmi_nesting",
            "0"
          ],
          "line": 614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "rdp->dynticks_nmi_nesting != DYNTICK_IRQ_NONIDLE"
          ],
          "line": 613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&rcu_data"
          ],
          "line": 611
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic bool rcu_rdp_is_offloaded(struct rcu_data *rdp);\nstatic noinline noinstr;\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\nstatic int rcu_pending(int user);\n\nstatic noinstr void rcu_eqs_enter(bool user)\n{\n\tstruct rcu_data *rdp = this_cpu_ptr(&rcu_data);\n\n\tWARN_ON_ONCE(rdp->dynticks_nmi_nesting != DYNTICK_IRQ_NONIDLE);\n\tWRITE_ONCE(rdp->dynticks_nmi_nesting, 0);\n\tWARN_ON_ONCE(IS_ENABLED(CONFIG_RCU_EQS_DEBUG) &&\n\t\t     rdp->dynticks_nesting == 0);\n\tif (rdp->dynticks_nesting != 1) {\n\t\t// RCU will still be watching, so just do accounting and leave.\n\t\trdp->dynticks_nesting--;\n\t\treturn;\n\t}\n\n\tlockdep_assert_irqs_disabled();\n\tinstrumentation_begin();\n\ttrace_rcu_dyntick(TPS(\"Start\"), rdp->dynticks_nesting, 0, atomic_read(&rdp->dynticks));\n\tWARN_ON_ONCE(IS_ENABLED(CONFIG_RCU_EQS_DEBUG) && !user && !is_idle_task(current));\n\trcu_preempt_deferred_qs(current);\n\n\t// instrumentation for the noinstr rcu_dynticks_eqs_enter()\n\tinstrument_atomic_write(&rdp->dynticks, sizeof(rdp->dynticks));\n\n\tinstrumentation_end();\n\tWRITE_ONCE(rdp->dynticks_nesting, 0); /* Avoid irq-access tearing. */\n\t// RCU is watching here ...\n\trcu_dynticks_eqs_enter();\n\t// ... but is no longer watching here.\n\trcu_dynticks_task_enter();\n}"
  },
  {
    "function_name": "rcutorture_get_gp_data",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
    "lines": "587-598",
    "snippet": "void rcutorture_get_gp_data(enum rcutorture_type test_type, int *flags,\n\t\t\t    unsigned long *gp_seq)\n{\n\tswitch (test_type) {\n\tcase RCU_FLAVOR:\n\t\t*flags = READ_ONCE(rcu_state.gp_flags);\n\t\t*gp_seq = rcu_seq_current(&rcu_state.gp_seq);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_nocb.h\"",
      "#include \"tree_exp.h\"",
      "#include \"tree_stall.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <linux/kasan.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/panic_notifier.h>",
      "#include <linux/panic.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};",
      "static void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_seq_current",
          "args": [
            "&rcu_state.gp_seq"
          ],
          "line": 593
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_seq_current",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu.h",
          "lines": "97-100",
          "snippet": "static inline unsigned long rcu_seq_current(unsigned long *sp)\n{\n\treturn READ_ONCE(*sp);\n}",
          "includes": [
            "#include <linux/rcu_node_tree.h>",
            "#include <trace/events/rcu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_node_tree.h>\n#include <trace/events/rcu.h>\n\nstatic inline unsigned long rcu_seq_current(unsigned long *sp)\n{\n\treturn READ_ONCE(*sp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rcu_state.gp_flags"
          ],
          "line": 592
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\nstatic void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);\n\nvoid rcutorture_get_gp_data(enum rcutorture_type test_type, int *flags,\n\t\t\t    unsigned long *gp_seq)\n{\n\tswitch (test_type) {\n\tcase RCU_FLAVOR:\n\t\t*flags = READ_ONCE(rcu_state.gp_flags);\n\t\t*gp_seq = rcu_seq_current(&rcu_state.gp_seq);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}"
  },
  {
    "function_name": "rcu_get_root",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
    "lines": "579-582",
    "snippet": "static struct rcu_node *rcu_get_root(void)\n{\n\treturn &rcu_state.node[0];\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_nocb.h\"",
      "#include \"tree_exp.h\"",
      "#include \"tree_stall.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <linux/kasan.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/panic_notifier.h>",
      "#include <linux/panic.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\n\nstatic struct rcu_node *rcu_get_root(void)\n{\n\treturn &rcu_state.node[0];\n}"
  },
  {
    "function_name": "rcu_exp_batches_completed",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
    "lines": "570-573",
    "snippet": "unsigned long rcu_exp_batches_completed(void)\n{\n\treturn rcu_state.expedited_sequence;\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_nocb.h\"",
      "#include \"tree_exp.h\"",
      "#include \"tree_stall.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <linux/kasan.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/panic_notifier.h>",
      "#include <linux/panic.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\n\nunsigned long rcu_exp_batches_completed(void)\n{\n\treturn rcu_state.expedited_sequence;\n}"
  },
  {
    "function_name": "rcu_get_gp_seq",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
    "lines": "558-561",
    "snippet": "unsigned long rcu_get_gp_seq(void)\n{\n\treturn READ_ONCE(rcu_state.gp_seq);\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_nocb.h\"",
      "#include \"tree_exp.h\"",
      "#include \"tree_stall.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <linux/kasan.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/panic_notifier.h>",
      "#include <linux/panic.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rcu_state.gp_seq"
          ],
          "line": 560
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\n\nunsigned long rcu_get_gp_seq(void)\n{\n\treturn READ_ONCE(rcu_state.gp_seq);\n}"
  },
  {
    "function_name": "param_set_next_fqs_jiffies",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
    "lines": "526-536",
    "snippet": "static int param_set_next_fqs_jiffies(const char *val, const struct kernel_param *kp)\n{\n\tulong j;\n\tint ret = kstrtoul(val, 0, &j);\n\n\tif (!ret) {\n\t\tWRITE_ONCE(*(ulong *)kp->arg, (j > HZ) ? HZ : (j ?: 1));\n\t\tadjust_jiffies_till_sched_qs();\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_nocb.h\"",
      "#include \"tree_exp.h\"",
      "#include \"tree_stall.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <linux/kasan.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/panic_notifier.h>",
      "#include <linux/panic.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "adjust_jiffies_till_sched_qs",
          "args": [],
          "line": 533
        },
        "resolved": true,
        "details": {
          "function_name": "adjust_jiffies_till_sched_qs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "496-512",
          "snippet": "static void adjust_jiffies_till_sched_qs(void)\n{\n\tunsigned long j;\n\n\t/* If jiffies_till_sched_qs was specified, respect the request. */\n\tif (jiffies_till_sched_qs != ULONG_MAX) {\n\t\tWRITE_ONCE(jiffies_to_sched_qs, jiffies_till_sched_qs);\n\t\treturn;\n\t}\n\t/* Otherwise, set to third fqs scan, but bound below on large system. */\n\tj = READ_ONCE(jiffies_till_first_fqs) +\n\t\t      2 * READ_ONCE(jiffies_till_next_fqs);\n\tif (j < HZ / 10 + nr_cpu_ids / RCU_JIFFIES_FQS_DIV)\n\t\tj = HZ / 10 + nr_cpu_ids / RCU_JIFFIES_FQS_DIV;\n\tpr_info(\"RCU calculated value of scheduler-enlistment delay is %ld jiffies.\\n\", j);\n\tWRITE_ONCE(jiffies_to_sched_qs, j);\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static ulong jiffies_till_first_fqs = IS_ENABLED(CONFIG_RCU_STRICT_GRACE_PERIOD) ? 0 : ULONG_MAX;",
            "static ulong jiffies_till_next_fqs = ULONG_MAX;",
            "static ulong jiffies_till_sched_qs = ULONG_MAX;",
            "static ulong jiffies_to_sched_qs;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic ulong jiffies_till_first_fqs = IS_ENABLED(CONFIG_RCU_STRICT_GRACE_PERIOD) ? 0 : ULONG_MAX;\nstatic ulong jiffies_till_next_fqs = ULONG_MAX;\nstatic ulong jiffies_till_sched_qs = ULONG_MAX;\nstatic ulong jiffies_to_sched_qs;\n\nstatic void adjust_jiffies_till_sched_qs(void)\n{\n\tunsigned long j;\n\n\t/* If jiffies_till_sched_qs was specified, respect the request. */\n\tif (jiffies_till_sched_qs != ULONG_MAX) {\n\t\tWRITE_ONCE(jiffies_to_sched_qs, jiffies_till_sched_qs);\n\t\treturn;\n\t}\n\t/* Otherwise, set to third fqs scan, but bound below on large system. */\n\tj = READ_ONCE(jiffies_till_first_fqs) +\n\t\t      2 * READ_ONCE(jiffies_till_next_fqs);\n\tif (j < HZ / 10 + nr_cpu_ids / RCU_JIFFIES_FQS_DIV)\n\t\tj = HZ / 10 + nr_cpu_ids / RCU_JIFFIES_FQS_DIV;\n\tpr_info(\"RCU calculated value of scheduler-enlistment delay is %ld jiffies.\\n\", j);\n\tWRITE_ONCE(jiffies_to_sched_qs, j);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "*(ulong *)kp->arg",
            "(j > HZ) ? HZ : (j ?: 1)"
          ],
          "line": 532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrtoul",
          "args": [
            "val",
            "0",
            "&j"
          ],
          "line": 529
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic int param_set_next_fqs_jiffies(const char *val, const struct kernel_param *kp)\n{\n\tulong j;\n\tint ret = kstrtoul(val, 0, &j);\n\n\tif (!ret) {\n\t\tWRITE_ONCE(*(ulong *)kp->arg, (j > HZ) ? HZ : (j ?: 1));\n\t\tadjust_jiffies_till_sched_qs();\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "param_set_first_fqs_jiffies",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
    "lines": "514-524",
    "snippet": "static int param_set_first_fqs_jiffies(const char *val, const struct kernel_param *kp)\n{\n\tulong j;\n\tint ret = kstrtoul(val, 0, &j);\n\n\tif (!ret) {\n\t\tWRITE_ONCE(*(ulong *)kp->arg, (j > HZ) ? HZ : j);\n\t\tadjust_jiffies_till_sched_qs();\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_nocb.h\"",
      "#include \"tree_exp.h\"",
      "#include \"tree_stall.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <linux/kasan.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/panic_notifier.h>",
      "#include <linux/panic.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "adjust_jiffies_till_sched_qs",
          "args": [],
          "line": 521
        },
        "resolved": true,
        "details": {
          "function_name": "adjust_jiffies_till_sched_qs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "496-512",
          "snippet": "static void adjust_jiffies_till_sched_qs(void)\n{\n\tunsigned long j;\n\n\t/* If jiffies_till_sched_qs was specified, respect the request. */\n\tif (jiffies_till_sched_qs != ULONG_MAX) {\n\t\tWRITE_ONCE(jiffies_to_sched_qs, jiffies_till_sched_qs);\n\t\treturn;\n\t}\n\t/* Otherwise, set to third fqs scan, but bound below on large system. */\n\tj = READ_ONCE(jiffies_till_first_fqs) +\n\t\t      2 * READ_ONCE(jiffies_till_next_fqs);\n\tif (j < HZ / 10 + nr_cpu_ids / RCU_JIFFIES_FQS_DIV)\n\t\tj = HZ / 10 + nr_cpu_ids / RCU_JIFFIES_FQS_DIV;\n\tpr_info(\"RCU calculated value of scheduler-enlistment delay is %ld jiffies.\\n\", j);\n\tWRITE_ONCE(jiffies_to_sched_qs, j);\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static ulong jiffies_till_first_fqs = IS_ENABLED(CONFIG_RCU_STRICT_GRACE_PERIOD) ? 0 : ULONG_MAX;",
            "static ulong jiffies_till_next_fqs = ULONG_MAX;",
            "static ulong jiffies_till_sched_qs = ULONG_MAX;",
            "static ulong jiffies_to_sched_qs;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic ulong jiffies_till_first_fqs = IS_ENABLED(CONFIG_RCU_STRICT_GRACE_PERIOD) ? 0 : ULONG_MAX;\nstatic ulong jiffies_till_next_fqs = ULONG_MAX;\nstatic ulong jiffies_till_sched_qs = ULONG_MAX;\nstatic ulong jiffies_to_sched_qs;\n\nstatic void adjust_jiffies_till_sched_qs(void)\n{\n\tunsigned long j;\n\n\t/* If jiffies_till_sched_qs was specified, respect the request. */\n\tif (jiffies_till_sched_qs != ULONG_MAX) {\n\t\tWRITE_ONCE(jiffies_to_sched_qs, jiffies_till_sched_qs);\n\t\treturn;\n\t}\n\t/* Otherwise, set to third fqs scan, but bound below on large system. */\n\tj = READ_ONCE(jiffies_till_first_fqs) +\n\t\t      2 * READ_ONCE(jiffies_till_next_fqs);\n\tif (j < HZ / 10 + nr_cpu_ids / RCU_JIFFIES_FQS_DIV)\n\t\tj = HZ / 10 + nr_cpu_ids / RCU_JIFFIES_FQS_DIV;\n\tpr_info(\"RCU calculated value of scheduler-enlistment delay is %ld jiffies.\\n\", j);\n\tWRITE_ONCE(jiffies_to_sched_qs, j);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "*(ulong *)kp->arg",
            "(j > HZ) ? HZ : j"
          ],
          "line": 520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrtoul",
          "args": [
            "val",
            "0",
            "&j"
          ],
          "line": 517
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic int param_set_first_fqs_jiffies(const char *val, const struct kernel_param *kp)\n{\n\tulong j;\n\tint ret = kstrtoul(val, 0, &j);\n\n\tif (!ret) {\n\t\tWRITE_ONCE(*(ulong *)kp->arg, (j > HZ) ? HZ : j);\n\t\tadjust_jiffies_till_sched_qs();\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "adjust_jiffies_till_sched_qs",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
    "lines": "496-512",
    "snippet": "static void adjust_jiffies_till_sched_qs(void)\n{\n\tunsigned long j;\n\n\t/* If jiffies_till_sched_qs was specified, respect the request. */\n\tif (jiffies_till_sched_qs != ULONG_MAX) {\n\t\tWRITE_ONCE(jiffies_to_sched_qs, jiffies_till_sched_qs);\n\t\treturn;\n\t}\n\t/* Otherwise, set to third fqs scan, but bound below on large system. */\n\tj = READ_ONCE(jiffies_till_first_fqs) +\n\t\t      2 * READ_ONCE(jiffies_till_next_fqs);\n\tif (j < HZ / 10 + nr_cpu_ids / RCU_JIFFIES_FQS_DIV)\n\t\tj = HZ / 10 + nr_cpu_ids / RCU_JIFFIES_FQS_DIV;\n\tpr_info(\"RCU calculated value of scheduler-enlistment delay is %ld jiffies.\\n\", j);\n\tWRITE_ONCE(jiffies_to_sched_qs, j);\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_nocb.h\"",
      "#include \"tree_exp.h\"",
      "#include \"tree_stall.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <linux/kasan.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/panic_notifier.h>",
      "#include <linux/panic.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static ulong jiffies_till_first_fqs = IS_ENABLED(CONFIG_RCU_STRICT_GRACE_PERIOD) ? 0 : ULONG_MAX;",
      "static ulong jiffies_till_next_fqs = ULONG_MAX;",
      "static ulong jiffies_till_sched_qs = ULONG_MAX;",
      "static ulong jiffies_to_sched_qs;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "jiffies_to_sched_qs",
            "j"
          ],
          "line": 511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"RCU calculated value of scheduler-enlistment delay is %ld jiffies.\\n\"",
            "j"
          ],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "jiffies_till_next_fqs"
          ],
          "line": 507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "jiffies_till_first_fqs"
          ],
          "line": 506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "jiffies_to_sched_qs",
            "jiffies_till_sched_qs"
          ],
          "line": 502
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic ulong jiffies_till_first_fqs = IS_ENABLED(CONFIG_RCU_STRICT_GRACE_PERIOD) ? 0 : ULONG_MAX;\nstatic ulong jiffies_till_next_fqs = ULONG_MAX;\nstatic ulong jiffies_till_sched_qs = ULONG_MAX;\nstatic ulong jiffies_to_sched_qs;\n\nstatic void adjust_jiffies_till_sched_qs(void)\n{\n\tunsigned long j;\n\n\t/* If jiffies_till_sched_qs was specified, respect the request. */\n\tif (jiffies_till_sched_qs != ULONG_MAX) {\n\t\tWRITE_ONCE(jiffies_to_sched_qs, jiffies_till_sched_qs);\n\t\treturn;\n\t}\n\t/* Otherwise, set to third fqs scan, but bound below on large system. */\n\tj = READ_ONCE(jiffies_till_first_fqs) +\n\t\t      2 * READ_ONCE(jiffies_till_next_fqs);\n\tif (j < HZ / 10 + nr_cpu_ids / RCU_JIFFIES_FQS_DIV)\n\t\tj = HZ / 10 + nr_cpu_ids / RCU_JIFFIES_FQS_DIV;\n\tpr_info(\"RCU calculated value of scheduler-enlistment delay is %ld jiffies.\\n\", j);\n\tWRITE_ONCE(jiffies_to_sched_qs, j);\n}"
  },
  {
    "function_name": "rcu_is_cpu_rrupt_from_idle",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
    "lines": "422-451",
    "snippet": "static int rcu_is_cpu_rrupt_from_idle(void)\n{\n\tlong nesting;\n\n\t/*\n\t * Usually called from the tick; but also used from smp_function_call()\n\t * for expedited grace periods. This latter can result in running from\n\t * the idle task, instead of an actual IPI.\n\t */\n\tlockdep_assert_irqs_disabled();\n\n\t/* Check for counter underflows */\n\tRCU_LOCKDEP_WARN(__this_cpu_read(rcu_data.dynticks_nesting) < 0,\n\t\t\t \"RCU dynticks_nesting counter underflow!\");\n\tRCU_LOCKDEP_WARN(__this_cpu_read(rcu_data.dynticks_nmi_nesting) <= 0,\n\t\t\t \"RCU dynticks_nmi_nesting counter underflow/zero!\");\n\n\t/* Are we at first interrupt nesting level? */\n\tnesting = __this_cpu_read(rcu_data.dynticks_nmi_nesting);\n\tif (nesting > 1)\n\t\treturn false;\n\n\t/*\n\t * If we're not in an interrupt, we must be in the idle task!\n\t */\n\tWARN_ON_ONCE(!nesting && !is_idle_task(current));\n\n\t/* Does CPU appear to be idle from an RCU standpoint? */\n\treturn __this_cpu_read(rcu_data.dynticks_nesting) == 0;\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_nocb.h\"",
      "#include \"tree_exp.h\"",
      "#include \"tree_stall.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <linux/kasan.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/panic_notifier.h>",
      "#include <linux/panic.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__this_cpu_read",
          "args": [
            "rcu_data.dynticks_nesting"
          ],
          "line": 450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!nesting && !is_idle_task(current)"
          ],
          "line": 447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_idle_task",
          "args": [
            "current"
          ],
          "line": 447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__this_cpu_read",
          "args": [
            "rcu_data.dynticks_nmi_nesting"
          ],
          "line": 440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RCU_LOCKDEP_WARN",
          "args": [
            "__this_cpu_read(rcu_data.dynticks_nmi_nesting) <= 0",
            "\"RCU dynticks_nmi_nesting counter underflow/zero!\""
          ],
          "line": 436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__this_cpu_read",
          "args": [
            "rcu_data.dynticks_nmi_nesting"
          ],
          "line": 436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RCU_LOCKDEP_WARN",
          "args": [
            "__this_cpu_read(rcu_data.dynticks_nesting) < 0",
            "\"RCU dynticks_nesting counter underflow!\""
          ],
          "line": 434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__this_cpu_read",
          "args": [
            "rcu_data.dynticks_nesting"
          ],
          "line": 434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_irqs_disabled",
          "args": [],
          "line": 431
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};\n\nstatic int rcu_is_cpu_rrupt_from_idle(void)\n{\n\tlong nesting;\n\n\t/*\n\t * Usually called from the tick; but also used from smp_function_call()\n\t * for expedited grace periods. This latter can result in running from\n\t * the idle task, instead of an actual IPI.\n\t */\n\tlockdep_assert_irqs_disabled();\n\n\t/* Check for counter underflows */\n\tRCU_LOCKDEP_WARN(__this_cpu_read(rcu_data.dynticks_nesting) < 0,\n\t\t\t \"RCU dynticks_nesting counter underflow!\");\n\tRCU_LOCKDEP_WARN(__this_cpu_read(rcu_data.dynticks_nmi_nesting) <= 0,\n\t\t\t \"RCU dynticks_nmi_nesting counter underflow/zero!\");\n\n\t/* Are we at first interrupt nesting level? */\n\tnesting = __this_cpu_read(rcu_data.dynticks_nmi_nesting);\n\tif (nesting > 1)\n\t\treturn false;\n\n\t/*\n\t * If we're not in an interrupt, we must be in the idle task!\n\t */\n\tWARN_ON_ONCE(!nesting && !is_idle_task(current));\n\n\t/* Does CPU appear to be idle from an RCU standpoint? */\n\treturn __this_cpu_read(rcu_data.dynticks_nesting) == 0;\n}"
  },
  {
    "function_name": "rcu_momentary_dyntick_idle",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
    "lines": "402-411",
    "snippet": "notrace void rcu_momentary_dyntick_idle(void)\n{\n\tint seq;\n\n\traw_cpu_write(rcu_data.rcu_need_heavy_qs, false);\n\tseq = rcu_dynticks_inc(2);\n\t/* It is illegal to call this from idle state. */\n\tWARN_ON_ONCE(!(seq & 0x1));\n\trcu_preempt_deferred_qs(current);\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_nocb.h\"",
      "#include \"tree_exp.h\"",
      "#include \"tree_stall.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <linux/kasan.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/panic_notifier.h>",
      "#include <linux/panic.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_preempt_deferred_qs",
          "args": [
            "current"
          ],
          "line": 410
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_preempt_deferred_qs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "933-939",
          "snippet": "static void rcu_preempt_deferred_qs(struct task_struct *t)\n{\n\tstruct rcu_data *rdp = this_cpu_ptr(&rcu_data);\n\n\tif (rdp->cpu_no_qs.b.exp)\n\t\trcu_report_exp_rdp(rdp);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nstatic void rcu_preempt_deferred_qs(struct task_struct *t)\n{\n\tstruct rcu_data *rdp = this_cpu_ptr(&rcu_data);\n\n\tif (rdp->cpu_no_qs.b.exp)\n\t\trcu_report_exp_rdp(rdp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!(seq & 0x1)"
          ],
          "line": 409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_dynticks_inc",
          "args": [
            "2"
          ],
          "line": 407
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_dynticks_inc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "258-261",
          "snippet": "unsigned long rcu_dynticks_inc(int incby)\n{\n\treturn arch_atomic_add_return(incby, this_cpu_ptr(&rcu_data.dynticks));\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};\n\nunsigned long rcu_dynticks_inc(int incby)\n{\n\treturn arch_atomic_add_return(incby, this_cpu_ptr(&rcu_data.dynticks));\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_cpu_write",
          "args": [
            "rcu_data.rcu_need_heavy_qs",
            "false"
          ],
          "line": 406
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};\n\nnotrace void rcu_momentary_dyntick_idle(void)\n{\n\tint seq;\n\n\traw_cpu_write(rcu_data.rcu_need_heavy_qs, false);\n\tseq = rcu_dynticks_inc(2);\n\t/* It is illegal to call this from idle state. */\n\tWARN_ON_ONCE(!(seq & 0x1));\n\trcu_preempt_deferred_qs(current);\n}"
  },
  {
    "function_name": "rcu_dynticks_zero_in_eqs",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
    "lines": "374-389",
    "snippet": "bool rcu_dynticks_zero_in_eqs(int cpu, int *vp)\n{\n\tstruct rcu_data *rdp = per_cpu_ptr(&rcu_data, cpu);\n\tint snap;\n\n\t// If not quiescent, force back to earlier extended quiescent state.\n\tsnap = atomic_read(&rdp->dynticks) & ~0x1;\n\n\tsmp_rmb(); // Order ->dynticks and *vp reads.\n\tif (READ_ONCE(*vp))\n\t\treturn false;  // Non-zero, so report failure;\n\tsmp_rmb(); // Order *vp read and ->dynticks re-read.\n\n\t// If still in the same extended quiescent state, we are good!\n\treturn snap == atomic_read(&rdp->dynticks);\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_nocb.h\"",
      "#include \"tree_exp.h\"",
      "#include \"tree_stall.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <linux/kasan.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/panic_notifier.h>",
      "#include <linux/panic.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};",
      "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
      "static void sync_sched_exp_online_cleanup(int cpu);",
      "static bool rcu_rdp_is_offloaded(struct rcu_data *rdp);",
      "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&rdp->dynticks"
          ],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_rmb",
          "args": [],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "*vp"
          ],
          "line": 383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_rmb",
          "args": [],
          "line": 382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&rdp->dynticks"
          ],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "&rcu_data",
            "cpu"
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void sync_sched_exp_online_cleanup(int cpu);\nstatic bool rcu_rdp_is_offloaded(struct rcu_data *rdp);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nbool rcu_dynticks_zero_in_eqs(int cpu, int *vp)\n{\n\tstruct rcu_data *rdp = per_cpu_ptr(&rcu_data, cpu);\n\tint snap;\n\n\t// If not quiescent, force back to earlier extended quiescent state.\n\tsnap = atomic_read(&rdp->dynticks) & ~0x1;\n\n\tsmp_rmb(); // Order ->dynticks and *vp reads.\n\tif (READ_ONCE(*vp))\n\t\treturn false;  // Non-zero, so report failure;\n\tsmp_rmb(); // Order *vp read and ->dynticks re-read.\n\n\t// If still in the same extended quiescent state, we are good!\n\treturn snap == atomic_read(&rdp->dynticks);\n}"
  },
  {
    "function_name": "rcu_dynticks_in_eqs_since",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
    "lines": "365-368",
    "snippet": "static bool rcu_dynticks_in_eqs_since(struct rcu_data *rdp, int snap)\n{\n\treturn snap != rcu_dynticks_snap(rdp);\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_nocb.h\"",
      "#include \"tree_exp.h\"",
      "#include \"tree_stall.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <linux/kasan.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/panic_notifier.h>",
      "#include <linux/panic.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};",
      "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
      "static bool rcu_rdp_is_offloaded(struct rcu_data *rdp);",
      "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_dynticks_snap",
          "args": [
            "rdp"
          ],
          "line": 367
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_dynticks_snap",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "337-341",
          "snippet": "static int rcu_dynticks_snap(struct rcu_data *rdp)\n{\n\tsmp_mb();  // Fundamental RCU ordering guarantee.\n\treturn atomic_read_acquire(&rdp->dynticks);\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};",
            "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
            "static bool rcu_rdp_is_offloaded(struct rcu_data *rdp);",
            "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic bool rcu_rdp_is_offloaded(struct rcu_data *rdp);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nstatic int rcu_dynticks_snap(struct rcu_data *rdp)\n{\n\tsmp_mb();  // Fundamental RCU ordering guarantee.\n\treturn atomic_read_acquire(&rdp->dynticks);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic bool rcu_rdp_is_offloaded(struct rcu_data *rdp);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nstatic bool rcu_dynticks_in_eqs_since(struct rcu_data *rdp, int snap)\n{\n\treturn snap != rcu_dynticks_snap(rdp);\n}"
  },
  {
    "function_name": "rcu_is_idle_cpu",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
    "lines": "353-358",
    "snippet": "bool rcu_is_idle_cpu(int cpu)\n{\n\tstruct rcu_data *rdp = per_cpu_ptr(&rcu_data, cpu);\n\n\treturn rcu_dynticks_in_eqs(rcu_dynticks_snap(rdp));\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_nocb.h\"",
      "#include \"tree_exp.h\"",
      "#include \"tree_stall.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <linux/kasan.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/panic_notifier.h>",
      "#include <linux/panic.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};",
      "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
      "static void sync_sched_exp_online_cleanup(int cpu);",
      "static bool rcu_rdp_is_offloaded(struct rcu_data *rdp);",
      "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_dynticks_in_eqs",
          "args": [
            "rcu_dynticks_snap(rdp)"
          ],
          "line": 357
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_dynticks_in_eqs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "347-350",
          "snippet": "static bool rcu_dynticks_in_eqs(int snap)\n{\n\treturn !(snap & 0x1);\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic bool rcu_dynticks_in_eqs(int snap)\n{\n\treturn !(snap & 0x1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_dynticks_snap",
          "args": [
            "rdp"
          ],
          "line": 357
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_dynticks_snap",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "337-341",
          "snippet": "static int rcu_dynticks_snap(struct rcu_data *rdp)\n{\n\tsmp_mb();  // Fundamental RCU ordering guarantee.\n\treturn atomic_read_acquire(&rdp->dynticks);\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};",
            "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
            "static bool rcu_rdp_is_offloaded(struct rcu_data *rdp);",
            "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic bool rcu_rdp_is_offloaded(struct rcu_data *rdp);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nstatic int rcu_dynticks_snap(struct rcu_data *rdp)\n{\n\tsmp_mb();  // Fundamental RCU ordering guarantee.\n\treturn atomic_read_acquire(&rdp->dynticks);\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "&rcu_data",
            "cpu"
          ],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void sync_sched_exp_online_cleanup(int cpu);\nstatic bool rcu_rdp_is_offloaded(struct rcu_data *rdp);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nbool rcu_is_idle_cpu(int cpu)\n{\n\tstruct rcu_data *rdp = per_cpu_ptr(&rcu_data, cpu);\n\n\treturn rcu_dynticks_in_eqs(rcu_dynticks_snap(rdp));\n}"
  },
  {
    "function_name": "rcu_dynticks_in_eqs",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
    "lines": "347-350",
    "snippet": "static bool rcu_dynticks_in_eqs(int snap)\n{\n\treturn !(snap & 0x1);\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_nocb.h\"",
      "#include \"tree_exp.h\"",
      "#include \"tree_stall.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <linux/kasan.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/panic_notifier.h>",
      "#include <linux/panic.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic bool rcu_dynticks_in_eqs(int snap)\n{\n\treturn !(snap & 0x1);\n}"
  },
  {
    "function_name": "rcu_dynticks_snap",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
    "lines": "337-341",
    "snippet": "static int rcu_dynticks_snap(struct rcu_data *rdp)\n{\n\tsmp_mb();  // Fundamental RCU ordering guarantee.\n\treturn atomic_read_acquire(&rdp->dynticks);\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_nocb.h\"",
      "#include \"tree_exp.h\"",
      "#include \"tree_stall.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <linux/kasan.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/panic_notifier.h>",
      "#include <linux/panic.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};",
      "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
      "static bool rcu_rdp_is_offloaded(struct rcu_data *rdp);",
      "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_read_acquire",
          "args": [
            "&rdp->dynticks"
          ],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_mb",
          "args": [],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic bool rcu_rdp_is_offloaded(struct rcu_data *rdp);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nstatic int rcu_dynticks_snap(struct rcu_data *rdp)\n{\n\tsmp_mb();  // Fundamental RCU ordering guarantee.\n\treturn atomic_read_acquire(&rdp->dynticks);\n}"
  },
  {
    "function_name": "rcu_dynticks_curr_cpu_in_eqs",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
    "lines": "328-331",
    "snippet": "static __always_inline bool rcu_dynticks_curr_cpu_in_eqs(void)\n{\n\treturn !(arch_atomic_read(this_cpu_ptr(&rcu_data.dynticks)) & 0x1);\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_nocb.h\"",
      "#include \"tree_exp.h\"",
      "#include \"tree_stall.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <linux/kasan.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/panic_notifier.h>",
      "#include <linux/panic.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "arch_atomic_read",
          "args": [
            "this_cpu_ptr(&rcu_data.dynticks)"
          ],
          "line": 330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&rcu_data.dynticks"
          ],
          "line": 330
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};\n\nstatic __always_inline bool rcu_dynticks_curr_cpu_in_eqs(void)\n{\n\treturn !(arch_atomic_read(this_cpu_ptr(&rcu_data.dynticks)) & 0x1);\n}"
  },
  {
    "function_name": "rcu_dynticks_eqs_online",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
    "lines": "314-321",
    "snippet": "static void rcu_dynticks_eqs_online(void)\n{\n\tstruct rcu_data *rdp = this_cpu_ptr(&rcu_data);\n\n\tif (atomic_read(&rdp->dynticks) & 0x1)\n\t\treturn;\n\trcu_dynticks_inc(1);\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_nocb.h\"",
      "#include \"tree_exp.h\"",
      "#include \"tree_stall.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <linux/kasan.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/panic_notifier.h>",
      "#include <linux/panic.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};",
      "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
      "static bool rcu_rdp_is_offloaded(struct rcu_data *rdp);",
      "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_dynticks_inc",
          "args": [
            "1"
          ],
          "line": 320
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_dynticks_inc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "258-261",
          "snippet": "unsigned long rcu_dynticks_inc(int incby)\n{\n\treturn arch_atomic_add_return(incby, this_cpu_ptr(&rcu_data.dynticks));\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};\n\nunsigned long rcu_dynticks_inc(int incby)\n{\n\treturn arch_atomic_add_return(incby, this_cpu_ptr(&rcu_data.dynticks));\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&rdp->dynticks"
          ],
          "line": 318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&rcu_data"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic bool rcu_rdp_is_offloaded(struct rcu_data *rdp);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nstatic void rcu_dynticks_eqs_online(void)\n{\n\tstruct rcu_data *rdp = this_cpu_ptr(&rcu_data);\n\n\tif (atomic_read(&rdp->dynticks) & 0x1)\n\t\treturn;\n\trcu_dynticks_inc(1);\n}"
  },
  {
    "function_name": "rcu_dynticks_eqs_exit",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
    "lines": "289-302",
    "snippet": "static noinstr void rcu_dynticks_eqs_exit(void)\n{\n\tint seq;\n\n\t/*\n\t * CPUs seeing atomic_add_return() must see prior idle sojourns,\n\t * and we also must force ordering with the next RCU read-side\n\t * critical section.\n\t */\n\tseq = rcu_dynticks_inc(1);\n\t// RCU is now watching.  Better not be in an extended quiescent state!\n\trcu_dynticks_task_trace_exit();  // After ->dynticks update!\n\tWARN_ON_ONCE(IS_ENABLED(CONFIG_RCU_EQS_DEBUG) && !(seq & 0x1));\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_nocb.h\"",
      "#include \"tree_exp.h\"",
      "#include \"tree_stall.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <linux/kasan.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/panic_notifier.h>",
      "#include <linux/panic.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline noinstr"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "IS_ENABLED(CONFIG_RCU_EQS_DEBUG) && !(seq & 0x1)"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_RCU_EQS_DEBUG"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_dynticks_task_trace_exit",
          "args": [],
          "line": 300
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_dynticks_task_trace_exit",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "1323-1329",
          "snippet": "static __always_inline void rcu_dynticks_task_trace_exit(void)\n{\n#ifdef CONFIG_TASKS_TRACE_RCU\n\tif (IS_ENABLED(CONFIG_TASKS_TRACE_RCU_READ_MB))\n\t\tcurrent->trc_reader_special.b.need_mb = false;\n#endif /* #ifdef CONFIG_TASKS_TRACE_RCU */\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nstatic __always_inline void rcu_dynticks_task_trace_exit(void)\n{\n#ifdef CONFIG_TASKS_TRACE_RCU\n\tif (IS_ENABLED(CONFIG_TASKS_TRACE_RCU_READ_MB))\n\t\tcurrent->trc_reader_special.b.need_mb = false;\n#endif /* #ifdef CONFIG_TASKS_TRACE_RCU */\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_dynticks_inc",
          "args": [
            "1"
          ],
          "line": 298
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_dynticks_inc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "258-261",
          "snippet": "unsigned long rcu_dynticks_inc(int incby)\n{\n\treturn arch_atomic_add_return(incby, this_cpu_ptr(&rcu_data.dynticks));\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};\n\nunsigned long rcu_dynticks_inc(int incby)\n{\n\treturn arch_atomic_add_return(incby, this_cpu_ptr(&rcu_data.dynticks));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic noinline noinstr;\n\nstatic noinstr void rcu_dynticks_eqs_exit(void)\n{\n\tint seq;\n\n\t/*\n\t * CPUs seeing atomic_add_return() must see prior idle sojourns,\n\t * and we also must force ordering with the next RCU read-side\n\t * critical section.\n\t */\n\tseq = rcu_dynticks_inc(1);\n\t// RCU is now watching.  Better not be in an extended quiescent state!\n\trcu_dynticks_task_trace_exit();  // After ->dynticks update!\n\tWARN_ON_ONCE(IS_ENABLED(CONFIG_RCU_EQS_DEBUG) && !(seq & 0x1));\n}"
  },
  {
    "function_name": "rcu_dynticks_eqs_enter",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
    "lines": "269-282",
    "snippet": "static noinstr void rcu_dynticks_eqs_enter(void)\n{\n\tint seq;\n\n\t/*\n\t * CPUs seeing atomic_add_return() must see prior RCU read-side\n\t * critical sections, and we also must force ordering with the\n\t * next idle sojourn.\n\t */\n\trcu_dynticks_task_trace_enter();  // Before ->dynticks update!\n\tseq = rcu_dynticks_inc(1);\n\t// RCU is no longer watching.  Better be in extended quiescent state!\n\tWARN_ON_ONCE(IS_ENABLED(CONFIG_RCU_EQS_DEBUG) && (seq & 0x1));\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_nocb.h\"",
      "#include \"tree_exp.h\"",
      "#include \"tree_stall.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <linux/kasan.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/panic_notifier.h>",
      "#include <linux/panic.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline noinstr"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "IS_ENABLED(CONFIG_RCU_EQS_DEBUG) && (seq & 0x1)"
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_RCU_EQS_DEBUG"
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_dynticks_inc",
          "args": [
            "1"
          ],
          "line": 279
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_dynticks_inc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "258-261",
          "snippet": "unsigned long rcu_dynticks_inc(int incby)\n{\n\treturn arch_atomic_add_return(incby, this_cpu_ptr(&rcu_data.dynticks));\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};\n\nunsigned long rcu_dynticks_inc(int incby)\n{\n\treturn arch_atomic_add_return(incby, this_cpu_ptr(&rcu_data.dynticks));\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_dynticks_task_trace_enter",
          "args": [],
          "line": 278
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_dynticks_task_trace_enter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "1314-1320",
          "snippet": "static __always_inline void rcu_dynticks_task_trace_enter(void)\n{\n#ifdef CONFIG_TASKS_TRACE_RCU\n\tif (IS_ENABLED(CONFIG_TASKS_TRACE_RCU_READ_MB))\n\t\tcurrent->trc_reader_special.b.need_mb = true;\n#endif /* #ifdef CONFIG_TASKS_TRACE_RCU */\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nstatic __always_inline void rcu_dynticks_task_trace_enter(void)\n{\n#ifdef CONFIG_TASKS_TRACE_RCU\n\tif (IS_ENABLED(CONFIG_TASKS_TRACE_RCU_READ_MB))\n\t\tcurrent->trc_reader_special.b.need_mb = true;\n#endif /* #ifdef CONFIG_TASKS_TRACE_RCU */\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic noinline noinstr;\n\nstatic noinstr void rcu_dynticks_eqs_enter(void)\n{\n\tint seq;\n\n\t/*\n\t * CPUs seeing atomic_add_return() must see prior RCU read-side\n\t * critical sections, and we also must force ordering with the\n\t * next idle sojourn.\n\t */\n\trcu_dynticks_task_trace_enter();  // Before ->dynticks update!\n\tseq = rcu_dynticks_inc(1);\n\t// RCU is no longer watching.  Better be in extended quiescent state!\n\tWARN_ON_ONCE(IS_ENABLED(CONFIG_RCU_EQS_DEBUG) && (seq & 0x1));\n}"
  },
  {
    "function_name": "rcu_dynticks_inc",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
    "lines": "258-261",
    "snippet": "unsigned long rcu_dynticks_inc(int incby)\n{\n\treturn arch_atomic_add_return(incby, this_cpu_ptr(&rcu_data.dynticks));\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_nocb.h\"",
      "#include \"tree_exp.h\"",
      "#include \"tree_stall.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <linux/kasan.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/panic_notifier.h>",
      "#include <linux/panic.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "arch_atomic_add_return",
          "args": [
            "incby",
            "this_cpu_ptr(&rcu_data.dynticks)"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&rcu_data.dynticks"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};\n\nunsigned long rcu_dynticks_inc(int incby)\n{\n\treturn arch_atomic_add_return(incby, this_cpu_ptr(&rcu_data.dynticks));\n}"
  },
  {
    "function_name": "rcu_softirq_qs",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
    "lines": "247-252",
    "snippet": "void rcu_softirq_qs(void)\n{\n\trcu_qs();\n\trcu_preempt_deferred_qs(current);\n\trcu_tasks_qs(current, false);\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_nocb.h\"",
      "#include \"tree_exp.h\"",
      "#include \"tree_stall.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <linux/kasan.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/panic_notifier.h>",
      "#include <linux/panic.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_tasks_qs",
          "args": [
            "current",
            "false"
          ],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_preempt_deferred_qs",
          "args": [
            "current"
          ],
          "line": 250
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_preempt_deferred_qs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "933-939",
          "snippet": "static void rcu_preempt_deferred_qs(struct task_struct *t)\n{\n\tstruct rcu_data *rdp = this_cpu_ptr(&rcu_data);\n\n\tif (rdp->cpu_no_qs.b.exp)\n\t\trcu_report_exp_rdp(rdp);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nstatic void rcu_preempt_deferred_qs(struct task_struct *t)\n{\n\tstruct rcu_data *rdp = this_cpu_ptr(&rcu_data);\n\n\tif (rdp->cpu_no_qs.b.exp)\n\t\trcu_report_exp_rdp(rdp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_qs",
          "args": [],
          "line": 249
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_qs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "842-852",
          "snippet": "static void rcu_qs(void)\n{\n\tRCU_LOCKDEP_WARN(preemptible(), \"rcu_qs() invoked with preemption enabled!!!\");\n\tif (!__this_cpu_read(rcu_data.cpu_no_qs.s))\n\t\treturn;\n\ttrace_rcu_grace_period(TPS(\"rcu_sched\"),\n\t\t\t       __this_cpu_read(rcu_data.gp_seq), TPS(\"cpuqs\"));\n\t__this_cpu_write(rcu_data.cpu_no_qs.b.norm, false);\n\tif (__this_cpu_read(rcu_data.cpu_no_qs.b.exp))\n\t\trcu_report_exp_rdp(this_cpu_ptr(&rcu_data));\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nstatic void rcu_qs(void)\n{\n\tRCU_LOCKDEP_WARN(preemptible(), \"rcu_qs() invoked with preemption enabled!!!\");\n\tif (!__this_cpu_read(rcu_data.cpu_no_qs.s))\n\t\treturn;\n\ttrace_rcu_grace_period(TPS(\"rcu_sched\"),\n\t\t\t       __this_cpu_read(rcu_data.gp_seq), TPS(\"cpuqs\"));\n\t__this_cpu_write(rcu_data.cpu_no_qs.b.norm, false);\n\tif (__this_cpu_read(rcu_data.cpu_no_qs.b.exp))\n\t\trcu_report_exp_rdp(this_cpu_ptr(&rcu_data));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nvoid rcu_softirq_qs(void)\n{\n\trcu_qs();\n\trcu_preempt_deferred_qs(current);\n\trcu_tasks_qs(current, false);\n}"
  },
  {
    "function_name": "rcu_get_n_cbs_cpu",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
    "lines": "238-245",
    "snippet": "static long rcu_get_n_cbs_cpu(int cpu)\n{\n\tstruct rcu_data *rdp = per_cpu_ptr(&rcu_data, cpu);\n\n\tif (rcu_segcblist_is_enabled(&rdp->cblist))\n\t\treturn rcu_segcblist_n_cbs(&rdp->cblist);\n\treturn 0;\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_nocb.h\"",
      "#include \"tree_exp.h\"",
      "#include \"tree_stall.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <linux/kasan.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/panic_notifier.h>",
      "#include <linux/panic.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};",
      "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
      "static void sync_sched_exp_online_cleanup(int cpu);",
      "static bool rcu_rdp_is_offloaded(struct rcu_data *rdp);",
      "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_segcblist_n_cbs",
          "args": [
            "&rdp->cblist"
          ],
          "line": 243
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_n_cbs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "47-54",
          "snippet": "static inline long rcu_segcblist_n_cbs(struct rcu_segcblist *rsclp)\n{\n#ifdef CONFIG_RCU_NOCB_CPU\n\treturn atomic_long_read(&rsclp->len);\n#else\n\treturn READ_ONCE(rsclp->len);\n#endif\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "long rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nlong rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline long rcu_segcblist_n_cbs(struct rcu_segcblist *rsclp)\n{\n#ifdef CONFIG_RCU_NOCB_CPU\n\treturn atomic_long_read(&rsclp->len);\n#else\n\treturn READ_ONCE(rsclp->len);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_segcblist_is_enabled",
          "args": [
            "&rdp->cblist"
          ],
          "line": 242
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_is_enabled",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "78-81",
          "snippet": "static inline bool rcu_segcblist_is_enabled(struct rcu_segcblist *rsclp)\n{\n\treturn rcu_segcblist_test_flags(rsclp, SEGCBLIST_ENABLED);\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "long rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nlong rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_is_enabled(struct rcu_segcblist *rsclp)\n{\n\treturn rcu_segcblist_test_flags(rsclp, SEGCBLIST_ENABLED);\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "&rcu_data",
            "cpu"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void sync_sched_exp_online_cleanup(int cpu);\nstatic bool rcu_rdp_is_offloaded(struct rcu_data *rdp);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nstatic long rcu_get_n_cbs_cpu(int cpu)\n{\n\tstruct rcu_data *rdp = per_cpu_ptr(&rcu_data, cpu);\n\n\tif (rcu_segcblist_is_enabled(&rdp->cblist))\n\t\treturn rcu_segcblist_n_cbs(&rdp->cblist);\n\treturn 0;\n}"
  },
  {
    "function_name": "rcu_gp_in_progress",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
    "lines": "229-232",
    "snippet": "static int rcu_gp_in_progress(void)\n{\n\treturn rcu_seq_state(rcu_seq_current(&rcu_state.gp_seq));\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_nocb.h\"",
      "#include \"tree_exp.h\"",
      "#include \"tree_stall.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <linux/kasan.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/panic_notifier.h>",
      "#include <linux/panic.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_seq_state",
          "args": [
            "rcu_seq_current(&rcu_state.gp_seq)"
          ],
          "line": 231
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_seq_state",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu.h",
          "lines": "39-42",
          "snippet": "static inline int rcu_seq_state(unsigned long s)\n{\n\treturn s & RCU_SEQ_STATE_MASK;\n}",
          "includes": [
            "#include <linux/rcu_node_tree.h>",
            "#include <trace/events/rcu.h>"
          ],
          "macros_used": [
            "#define RCU_SEQ_STATE_MASK\t((1 << RCU_SEQ_CTR_SHIFT) - 1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_node_tree.h>\n#include <trace/events/rcu.h>\n\n#define RCU_SEQ_STATE_MASK\t((1 << RCU_SEQ_CTR_SHIFT) - 1)\n\nstatic inline int rcu_seq_state(unsigned long s)\n{\n\treturn s & RCU_SEQ_STATE_MASK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_seq_current",
          "args": [
            "&rcu_state.gp_seq"
          ],
          "line": 231
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_seq_current",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu.h",
          "lines": "97-100",
          "snippet": "static inline unsigned long rcu_seq_current(unsigned long *sp)\n{\n\treturn READ_ONCE(*sp);\n}",
          "includes": [
            "#include <linux/rcu_node_tree.h>",
            "#include <trace/events/rcu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_node_tree.h>\n#include <trace/events/rcu.h>\n\nstatic inline unsigned long rcu_seq_current(unsigned long *sp)\n{\n\treturn READ_ONCE(*sp);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\n\nstatic int rcu_gp_in_progress(void)\n{\n\treturn rcu_seq_state(rcu_seq_current(&rcu_state.gp_seq));\n}"
  },
  {
    "function_name": "rcu_rnp_online_cpus",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
    "lines": "219-222",
    "snippet": "static unsigned long rcu_rnp_online_cpus(struct rcu_node *rnp)\n{\n\treturn READ_ONCE(rnp->qsmaskinitnext);\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_nocb.h\"",
      "#include \"tree_exp.h\"",
      "#include \"tree_stall.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <linux/kasan.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/panic_notifier.h>",
      "#include <linux/panic.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void check_cb_ovld_locked(struct rcu_data *rdp, struct rcu_node *rnp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rnp->qsmaskinitnext"
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic void check_cb_ovld_locked(struct rcu_data *rdp, struct rcu_node *rnp);\n\nstatic unsigned long rcu_rnp_online_cpus(struct rcu_node *rnp)\n{\n\treturn READ_ONCE(rnp->qsmaskinitnext);\n}"
  },
  {
    "function_name": "rcu_get_gp_kthreads_prio",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
    "lines": "196-199",
    "snippet": "int rcu_get_gp_kthreads_prio(void)\n{\n\treturn kthread_prio;\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_nocb.h\"",
      "#include \"tree_exp.h\"",
      "#include \"tree_stall.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <linux/kasan.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/panic_notifier.h>",
      "#include <linux/panic.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int kthread_prio = IS_ENABLED(CONFIG_RCU_BOOST) ? 1 : 0;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic int kthread_prio = IS_ENABLED(CONFIG_RCU_BOOST) ? 1 : 0;\n\nint rcu_get_gp_kthreads_prio(void)\n{\n\treturn kthread_prio;\n}"
  }
]