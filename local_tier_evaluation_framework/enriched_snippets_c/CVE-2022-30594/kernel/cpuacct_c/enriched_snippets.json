[
  {
    "function_name": "cpuacct_account_field",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/cpuacct.c",
    "lines": "352-360",
    "snippet": "void cpuacct_account_field(struct task_struct *tsk, int index, u64 val)\n{\n\tstruct cpuacct *ca;\n\n\trcu_read_lock();\n\tfor (ca = task_ca(tsk); ca != &root_cpuacct; ca = parent_ca(ca))\n\t\t__this_cpu_add(ca->cpustat->cpustat[index], val);\n\trcu_read_unlock();\n}",
    "includes": [
      "#include \"sched.h\"",
      "#include <asm/irq_regs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct cpuacct root_cpuacct = {\n\t.cpustat\t= &kernel_cpustat,\n\t.cpuusage\t= &root_cpuacct_cpuusage,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 359
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_unlock_strict",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "815-824",
          "snippet": "void rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nvoid rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__this_cpu_add",
          "args": [
            "ca->cpustat->cpustat[index]",
            "val"
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parent_ca",
          "args": [
            "ca"
          ],
          "line": 357
        },
        "resolved": true,
        "details": {
          "function_name": "parent_ca",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/cpuacct.c",
          "lines": "43-46",
          "snippet": "static inline struct cpuacct *parent_ca(struct cpuacct *ca)\n{\n\treturn css_ca(ca->css.parent);\n}",
          "includes": [
            "#include \"sched.h\"",
            "#include <asm/irq_regs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n#include <asm/irq_regs.h>\n\nstatic inline struct cpuacct *parent_ca(struct cpuacct *ca)\n{\n\treturn css_ca(ca->css.parent);\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_ca",
          "args": [
            "tsk"
          ],
          "line": 357
        },
        "resolved": true,
        "details": {
          "function_name": "task_ca",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/cpuacct.c",
          "lines": "38-41",
          "snippet": "static inline struct cpuacct *task_ca(struct task_struct *tsk)\n{\n\treturn css_ca(task_css(tsk, cpuacct_cgrp_id));\n}",
          "includes": [
            "#include \"sched.h\"",
            "#include <asm/irq_regs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n#include <asm/irq_regs.h>\n\nstatic inline struct cpuacct *task_ca(struct task_struct *tsk)\n{\n\treturn css_ca(task_css(tsk, cpuacct_cgrp_id));\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 356
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_any_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "340-351",
          "snippet": "int rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n#include <asm/irq_regs.h>\n\nstatic struct cpuacct root_cpuacct = {\n\t.cpustat\t= &kernel_cpustat,\n\t.cpuusage\t= &root_cpuacct_cpuusage,\n};\n\nvoid cpuacct_account_field(struct task_struct *tsk, int index, u64 val)\n{\n\tstruct cpuacct *ca;\n\n\trcu_read_lock();\n\tfor (ca = task_ca(tsk); ca != &root_cpuacct; ca = parent_ca(ca))\n\t\t__this_cpu_add(ca->cpustat->cpustat[index], val);\n\trcu_read_unlock();\n}"
  },
  {
    "function_name": "cpuacct_charge",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/cpuacct.c",
    "lines": "335-345",
    "snippet": "void cpuacct_charge(struct task_struct *tsk, u64 cputime)\n{\n\tstruct cpuacct *ca;\n\n\trcu_read_lock();\n\n\tfor (ca = task_ca(tsk); ca; ca = parent_ca(ca))\n\t\t__this_cpu_add(*ca->cpuusage, cputime);\n\n\trcu_read_unlock();\n}",
    "includes": [
      "#include \"sched.h\"",
      "#include <asm/irq_regs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 344
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_unlock_strict",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "815-824",
          "snippet": "void rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nvoid rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__this_cpu_add",
          "args": [
            "*ca->cpuusage",
            "cputime"
          ],
          "line": 342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parent_ca",
          "args": [
            "ca"
          ],
          "line": 341
        },
        "resolved": true,
        "details": {
          "function_name": "parent_ca",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/cpuacct.c",
          "lines": "43-46",
          "snippet": "static inline struct cpuacct *parent_ca(struct cpuacct *ca)\n{\n\treturn css_ca(ca->css.parent);\n}",
          "includes": [
            "#include \"sched.h\"",
            "#include <asm/irq_regs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n#include <asm/irq_regs.h>\n\nstatic inline struct cpuacct *parent_ca(struct cpuacct *ca)\n{\n\treturn css_ca(ca->css.parent);\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_ca",
          "args": [
            "tsk"
          ],
          "line": 341
        },
        "resolved": true,
        "details": {
          "function_name": "task_ca",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/cpuacct.c",
          "lines": "38-41",
          "snippet": "static inline struct cpuacct *task_ca(struct task_struct *tsk)\n{\n\treturn css_ca(task_css(tsk, cpuacct_cgrp_id));\n}",
          "includes": [
            "#include \"sched.h\"",
            "#include <asm/irq_regs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n#include <asm/irq_regs.h>\n\nstatic inline struct cpuacct *task_ca(struct task_struct *tsk)\n{\n\treturn css_ca(task_css(tsk, cpuacct_cgrp_id));\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 339
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_any_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "340-351",
          "snippet": "int rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n#include <asm/irq_regs.h>\n\nvoid cpuacct_charge(struct task_struct *tsk, u64 cputime)\n{\n\tstruct cpuacct *ca;\n\n\trcu_read_lock();\n\n\tfor (ca = task_ca(tsk); ca; ca = parent_ca(ca))\n\t\t__this_cpu_add(*ca->cpuusage, cputime);\n\n\trcu_read_unlock();\n}"
  },
  {
    "function_name": "cpuacct_stats_show",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/cpuacct.c",
    "lines": "261-291",
    "snippet": "static int cpuacct_stats_show(struct seq_file *sf, void *v)\n{\n\tstruct cpuacct *ca = css_ca(seq_css(sf));\n\tstruct task_cputime cputime;\n\tu64 val[CPUACCT_STAT_NSTATS];\n\tint cpu;\n\tint stat;\n\n\tmemset(&cputime, 0, sizeof(cputime));\n\tfor_each_possible_cpu(cpu) {\n\t\tu64 *cpustat = per_cpu_ptr(ca->cpustat, cpu)->cpustat;\n\n\t\tcputime.utime += cpustat[CPUTIME_USER];\n\t\tcputime.utime += cpustat[CPUTIME_NICE];\n\t\tcputime.stime += cpustat[CPUTIME_SYSTEM];\n\t\tcputime.stime += cpustat[CPUTIME_IRQ];\n\t\tcputime.stime += cpustat[CPUTIME_SOFTIRQ];\n\n\t\tcputime.sum_exec_runtime += *per_cpu_ptr(ca->cpuusage, cpu);\n\t}\n\n\tcputime_adjust(&cputime, &seq_css(sf)->cgroup->prev_cputime,\n\t\t&val[CPUACCT_STAT_USER], &val[CPUACCT_STAT_SYSTEM]);\n\n\tfor (stat = 0; stat < CPUACCT_STAT_NSTATS; stat++) {\n\t\tseq_printf(sf, \"%s %llu\\n\", cpuacct_stat_desc[stat],\n\t\t\tnsec_to_clock_t(val[stat]));\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"sched.h\"",
      "#include <asm/irq_regs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const char * const cpuacct_stat_desc[] = {\n\t[CPUACCT_STAT_USER] = \"user\",\n\t[CPUACCT_STAT_SYSTEM] = \"system\",\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "sf",
            "\"%s %llu\\n\"",
            "cpuacct_stat_desc[stat]",
            "nsec_to_clock_t(val[stat])"
          ],
          "line": 286
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "81-100",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "nsec_to_clock_t",
          "args": [
            "val[stat]"
          ],
          "line": 287
        },
        "resolved": true,
        "details": {
          "function_name": "nsec_to_clock_t",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/time.c",
          "lines": "674-688",
          "snippet": "u64 nsec_to_clock_t(u64 x)\n{\n#if (NSEC_PER_SEC % USER_HZ) == 0\n\treturn div_u64(x, NSEC_PER_SEC / USER_HZ);\n#elif (USER_HZ % 512) == 0\n\treturn div_u64(x * USER_HZ / 512, NSEC_PER_SEC / 512);\n#else\n\t/*\n         * max relative error 5.7e-8 (1.8s per year) for USER_HZ <= 1024,\n         * overflow after 64.99 years.\n         * exact for HZ=60, 72, 90, 120, 144, 180, 300, 600, 900, ...\n         */\n\treturn div_u64(x * 9, (9ull * NSEC_PER_SEC + (USER_HZ / 2)) / USER_HZ);\n#endif\n}",
          "includes": [
            "#include \"timekeeping.h\"",
            "#include <generated/timeconst.h>",
            "#include <asm/unistd.h>",
            "#include <linux/compat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/math64.h>",
            "#include <linux/fs.h>",
            "#include <linux/security.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/errno.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/capability.h>",
            "#include <linux/timex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping.h\"\n#include <generated/timeconst.h>\n#include <asm/unistd.h>\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/math64.h>\n#include <linux/fs.h>\n#include <linux/security.h>\n#include <linux/syscalls.h>\n#include <linux/errno.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/capability.h>\n#include <linux/timex.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nu64 nsec_to_clock_t(u64 x)\n{\n#if (NSEC_PER_SEC % USER_HZ) == 0\n\treturn div_u64(x, NSEC_PER_SEC / USER_HZ);\n#elif (USER_HZ % 512) == 0\n\treturn div_u64(x * USER_HZ / 512, NSEC_PER_SEC / 512);\n#else\n\t/*\n         * max relative error 5.7e-8 (1.8s per year) for USER_HZ <= 1024,\n         * overflow after 64.99 years.\n         * exact for HZ=60, 72, 90, 120, 144, 180, 300, 600, 900, ...\n         */\n\treturn div_u64(x * 9, (9ull * NSEC_PER_SEC + (USER_HZ / 2)) / USER_HZ);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "cputime_adjust",
          "args": [
            "&cputime",
            "&seq_css(sf)->cgroup->prev_cputime",
            "&val[CPUACCT_STAT_USER]",
            "&val[CPUACCT_STAT_SYSTEM]"
          ],
          "line": 282
        },
        "resolved": true,
        "details": {
          "function_name": "cputime_adjust",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/cputime.c",
          "lines": "540-610",
          "snippet": "void cputime_adjust(struct task_cputime *curr, struct prev_cputime *prev,\n\t\t    u64 *ut, u64 *st)\n{\n\tu64 rtime, stime, utime;\n\tunsigned long flags;\n\n\t/* Serialize concurrent callers such that we can honour our guarantees */\n\traw_spin_lock_irqsave(&prev->lock, flags);\n\trtime = curr->sum_exec_runtime;\n\n\t/*\n\t * This is possible under two circumstances:\n\t *  - rtime isn't monotonic after all (a bug);\n\t *  - we got reordered by the lock.\n\t *\n\t * In both cases this acts as a filter such that the rest of the code\n\t * can assume it is monotonic regardless of anything else.\n\t */\n\tif (prev->stime + prev->utime >= rtime)\n\t\tgoto out;\n\n\tstime = curr->stime;\n\tutime = curr->utime;\n\n\t/*\n\t * If either stime or utime are 0, assume all runtime is userspace.\n\t * Once a task gets some ticks, the monotonicity code at 'update:'\n\t * will ensure things converge to the observed ratio.\n\t */\n\tif (stime == 0) {\n\t\tutime = rtime;\n\t\tgoto update;\n\t}\n\n\tif (utime == 0) {\n\t\tstime = rtime;\n\t\tgoto update;\n\t}\n\n\tstime = mul_u64_u64_div_u64(stime, rtime, stime + utime);\n\nupdate:\n\t/*\n\t * Make sure stime doesn't go backwards; this preserves monotonicity\n\t * for utime because rtime is monotonic.\n\t *\n\t *  utime_i+1 = rtime_i+1 - stime_i\n\t *            = rtime_i+1 - (rtime_i - utime_i)\n\t *            = (rtime_i+1 - rtime_i) + utime_i\n\t *            >= utime_i\n\t */\n\tif (stime < prev->stime)\n\t\tstime = prev->stime;\n\tutime = rtime - stime;\n\n\t/*\n\t * Make sure utime doesn't go backwards; this still preserves\n\t * monotonicity for stime, analogous argument to above.\n\t */\n\tif (utime < prev->utime) {\n\t\tutime = prev->utime;\n\t\tstime = rtime - utime;\n\t}\n\n\tprev->stime = stime;\n\tprev->utime = utime;\nout:\n\t*ut = prev->utime;\n\t*st = prev->stime;\n\traw_spin_unlock_irqrestore(&prev->lock, flags);\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nvoid cputime_adjust(struct task_cputime *curr, struct prev_cputime *prev,\n\t\t    u64 *ut, u64 *st)\n{\n\tu64 rtime, stime, utime;\n\tunsigned long flags;\n\n\t/* Serialize concurrent callers such that we can honour our guarantees */\n\traw_spin_lock_irqsave(&prev->lock, flags);\n\trtime = curr->sum_exec_runtime;\n\n\t/*\n\t * This is possible under two circumstances:\n\t *  - rtime isn't monotonic after all (a bug);\n\t *  - we got reordered by the lock.\n\t *\n\t * In both cases this acts as a filter such that the rest of the code\n\t * can assume it is monotonic regardless of anything else.\n\t */\n\tif (prev->stime + prev->utime >= rtime)\n\t\tgoto out;\n\n\tstime = curr->stime;\n\tutime = curr->utime;\n\n\t/*\n\t * If either stime or utime are 0, assume all runtime is userspace.\n\t * Once a task gets some ticks, the monotonicity code at 'update:'\n\t * will ensure things converge to the observed ratio.\n\t */\n\tif (stime == 0) {\n\t\tutime = rtime;\n\t\tgoto update;\n\t}\n\n\tif (utime == 0) {\n\t\tstime = rtime;\n\t\tgoto update;\n\t}\n\n\tstime = mul_u64_u64_div_u64(stime, rtime, stime + utime);\n\nupdate:\n\t/*\n\t * Make sure stime doesn't go backwards; this preserves monotonicity\n\t * for utime because rtime is monotonic.\n\t *\n\t *  utime_i+1 = rtime_i+1 - stime_i\n\t *            = rtime_i+1 - (rtime_i - utime_i)\n\t *            = (rtime_i+1 - rtime_i) + utime_i\n\t *            >= utime_i\n\t */\n\tif (stime < prev->stime)\n\t\tstime = prev->stime;\n\tutime = rtime - stime;\n\n\t/*\n\t * Make sure utime doesn't go backwards; this still preserves\n\t * monotonicity for stime, analogous argument to above.\n\t */\n\tif (utime < prev->utime) {\n\t\tutime = prev->utime;\n\t\tstime = rtime - utime;\n\t}\n\n\tprev->stime = stime;\n\tprev->utime = utime;\nout:\n\t*ut = prev->utime;\n\t*st = prev->stime;\n\traw_spin_unlock_irqrestore(&prev->lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_css",
          "args": [
            "sf"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "ca->cpuusage",
            "cpu"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "ca->cpustat",
            "cpu"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&cputime",
            "0",
            "sizeof(cputime)"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "css_ca",
          "args": [
            "seq_css(sf)"
          ],
          "line": 263
        },
        "resolved": true,
        "details": {
          "function_name": "css_ca",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/cpuacct.c",
          "lines": "32-35",
          "snippet": "static inline struct cpuacct *css_ca(struct cgroup_subsys_state *css)\n{\n\treturn css ? container_of(css, struct cpuacct, css) : NULL;\n}",
          "includes": [
            "#include \"sched.h\"",
            "#include <asm/irq_regs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n#include <asm/irq_regs.h>\n\nstatic inline struct cpuacct *css_ca(struct cgroup_subsys_state *css)\n{\n\treturn css ? container_of(css, struct cpuacct, css) : NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_css",
          "args": [
            "sf"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n#include <asm/irq_regs.h>\n\nstatic const char * const cpuacct_stat_desc[] = {\n\t[CPUACCT_STAT_USER] = \"user\",\n\t[CPUACCT_STAT_SYSTEM] = \"system\",\n};\n\nstatic int cpuacct_stats_show(struct seq_file *sf, void *v)\n{\n\tstruct cpuacct *ca = css_ca(seq_css(sf));\n\tstruct task_cputime cputime;\n\tu64 val[CPUACCT_STAT_NSTATS];\n\tint cpu;\n\tint stat;\n\n\tmemset(&cputime, 0, sizeof(cputime));\n\tfor_each_possible_cpu(cpu) {\n\t\tu64 *cpustat = per_cpu_ptr(ca->cpustat, cpu)->cpustat;\n\n\t\tcputime.utime += cpustat[CPUTIME_USER];\n\t\tcputime.utime += cpustat[CPUTIME_NICE];\n\t\tcputime.stime += cpustat[CPUTIME_SYSTEM];\n\t\tcputime.stime += cpustat[CPUTIME_IRQ];\n\t\tcputime.stime += cpustat[CPUTIME_SOFTIRQ];\n\n\t\tcputime.sum_exec_runtime += *per_cpu_ptr(ca->cpuusage, cpu);\n\t}\n\n\tcputime_adjust(&cputime, &seq_css(sf)->cgroup->prev_cputime,\n\t\t&val[CPUACCT_STAT_USER], &val[CPUACCT_STAT_SYSTEM]);\n\n\tfor (stat = 0; stat < CPUACCT_STAT_NSTATS; stat++) {\n\t\tseq_printf(sf, \"%s %llu\\n\", cpuacct_stat_desc[stat],\n\t\t\tnsec_to_clock_t(val[stat]));\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "cpuacct_all_seq_show",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/cpuacct.c",
    "lines": "240-259",
    "snippet": "static int cpuacct_all_seq_show(struct seq_file *m, void *V)\n{\n\tstruct cpuacct *ca = css_ca(seq_css(m));\n\tint index;\n\tint cpu;\n\n\tseq_puts(m, \"cpu\");\n\tfor (index = 0; index < CPUACCT_STAT_NSTATS; index++)\n\t\tseq_printf(m, \" %s\", cpuacct_stat_desc[index]);\n\tseq_puts(m, \"\\n\");\n\n\tfor_each_possible_cpu(cpu) {\n\t\tseq_printf(m, \"%d\", cpu);\n\t\tfor (index = 0; index < CPUACCT_STAT_NSTATS; index++)\n\t\t\tseq_printf(m, \" %llu\",\n\t\t\t\t   cpuacct_cpuusage_read(ca, cpu, index));\n\t\tseq_puts(m, \"\\n\");\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"sched.h\"",
      "#include <asm/irq_regs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const char * const cpuacct_stat_desc[] = {\n\t[CPUACCT_STAT_USER] = \"user\",\n\t[CPUACCT_STAT_SYSTEM] = \"system\",\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "m",
            "\"\\n\""
          ],
          "line": 256
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_puts",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "205-220",
          "snippet": "void trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\" %llu\"",
            "cpuacct_cpuusage_read(ca, cpu, index)"
          ],
          "line": 254
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "81-100",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpuacct_cpuusage_read",
          "args": [
            "ca",
            "cpu",
            "index"
          ],
          "line": 255
        },
        "resolved": true,
        "details": {
          "function_name": "cpuacct_cpuusage_read",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/cpuacct.c",
          "lines": "95-134",
          "snippet": "static u64 cpuacct_cpuusage_read(struct cpuacct *ca, int cpu,\n\t\t\t\t enum cpuacct_stat_index index)\n{\n\tu64 *cpuusage = per_cpu_ptr(ca->cpuusage, cpu);\n\tu64 *cpustat = per_cpu_ptr(ca->cpustat, cpu)->cpustat;\n\tu64 data;\n\n\t/*\n\t * We allow index == CPUACCT_STAT_NSTATS here to read\n\t * the sum of usages.\n\t */\n\tif (WARN_ON_ONCE(index > CPUACCT_STAT_NSTATS))\n\t\treturn 0;\n\n#ifndef CONFIG_64BIT\n\t/*\n\t * Take rq->lock to make 64-bit read safe on 32-bit platforms.\n\t */\n\traw_spin_rq_lock_irq(cpu_rq(cpu));\n#endif\n\n\tswitch (index) {\n\tcase CPUACCT_STAT_USER:\n\t\tdata = cpustat[CPUTIME_USER] + cpustat[CPUTIME_NICE];\n\t\tbreak;\n\tcase CPUACCT_STAT_SYSTEM:\n\t\tdata = cpustat[CPUTIME_SYSTEM] + cpustat[CPUTIME_IRQ] +\n\t\t\tcpustat[CPUTIME_SOFTIRQ];\n\t\tbreak;\n\tcase CPUACCT_STAT_NSTATS:\n\t\tdata = *cpuusage;\n\t\tbreak;\n\t}\n\n#ifndef CONFIG_64BIT\n\traw_spin_rq_unlock_irq(cpu_rq(cpu));\n#endif\n\n\treturn data;\n}",
          "includes": [
            "#include \"sched.h\"",
            "#include <asm/irq_regs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n#include <asm/irq_regs.h>\n\nstatic u64 cpuacct_cpuusage_read(struct cpuacct *ca, int cpu,\n\t\t\t\t enum cpuacct_stat_index index)\n{\n\tu64 *cpuusage = per_cpu_ptr(ca->cpuusage, cpu);\n\tu64 *cpustat = per_cpu_ptr(ca->cpustat, cpu)->cpustat;\n\tu64 data;\n\n\t/*\n\t * We allow index == CPUACCT_STAT_NSTATS here to read\n\t * the sum of usages.\n\t */\n\tif (WARN_ON_ONCE(index > CPUACCT_STAT_NSTATS))\n\t\treturn 0;\n\n#ifndef CONFIG_64BIT\n\t/*\n\t * Take rq->lock to make 64-bit read safe on 32-bit platforms.\n\t */\n\traw_spin_rq_lock_irq(cpu_rq(cpu));\n#endif\n\n\tswitch (index) {\n\tcase CPUACCT_STAT_USER:\n\t\tdata = cpustat[CPUTIME_USER] + cpustat[CPUTIME_NICE];\n\t\tbreak;\n\tcase CPUACCT_STAT_SYSTEM:\n\t\tdata = cpustat[CPUTIME_SYSTEM] + cpustat[CPUTIME_IRQ] +\n\t\t\tcpustat[CPUTIME_SOFTIRQ];\n\t\tbreak;\n\tcase CPUACCT_STAT_NSTATS:\n\t\tdata = *cpuusage;\n\t\tbreak;\n\t}\n\n#ifndef CONFIG_64BIT\n\traw_spin_rq_unlock_irq(cpu_rq(cpu));\n#endif\n\n\treturn data;\n}"
        }
      },
      {
        "call_info": {
          "callee": "css_ca",
          "args": [
            "seq_css(m)"
          ],
          "line": 242
        },
        "resolved": true,
        "details": {
          "function_name": "css_ca",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/cpuacct.c",
          "lines": "32-35",
          "snippet": "static inline struct cpuacct *css_ca(struct cgroup_subsys_state *css)\n{\n\treturn css ? container_of(css, struct cpuacct, css) : NULL;\n}",
          "includes": [
            "#include \"sched.h\"",
            "#include <asm/irq_regs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n#include <asm/irq_regs.h>\n\nstatic inline struct cpuacct *css_ca(struct cgroup_subsys_state *css)\n{\n\treturn css ? container_of(css, struct cpuacct, css) : NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_css",
          "args": [
            "m"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n#include <asm/irq_regs.h>\n\nstatic const char * const cpuacct_stat_desc[] = {\n\t[CPUACCT_STAT_USER] = \"user\",\n\t[CPUACCT_STAT_SYSTEM] = \"system\",\n};\n\nstatic int cpuacct_all_seq_show(struct seq_file *m, void *V)\n{\n\tstruct cpuacct *ca = css_ca(seq_css(m));\n\tint index;\n\tint cpu;\n\n\tseq_puts(m, \"cpu\");\n\tfor (index = 0; index < CPUACCT_STAT_NSTATS; index++)\n\t\tseq_printf(m, \" %s\", cpuacct_stat_desc[index]);\n\tseq_puts(m, \"\\n\");\n\n\tfor_each_possible_cpu(cpu) {\n\t\tseq_printf(m, \"%d\", cpu);\n\t\tfor (index = 0; index < CPUACCT_STAT_NSTATS; index++)\n\t\t\tseq_printf(m, \" %llu\",\n\t\t\t\t   cpuacct_cpuusage_read(ca, cpu, index));\n\t\tseq_puts(m, \"\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "cpuacct_percpu_seq_show",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/cpuacct.c",
    "lines": "235-238",
    "snippet": "static int cpuacct_percpu_seq_show(struct seq_file *m, void *V)\n{\n\treturn __cpuacct_percpu_seq_show(m, CPUACCT_STAT_NSTATS);\n}",
    "includes": [
      "#include \"sched.h\"",
      "#include <asm/irq_regs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__cpuacct_percpu_seq_show",
          "args": [
            "m",
            "CPUACCT_STAT_NSTATS"
          ],
          "line": 237
        },
        "resolved": true,
        "details": {
          "function_name": "__cpuacct_percpu_seq_show",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/cpuacct.c",
          "lines": "210-223",
          "snippet": "static int __cpuacct_percpu_seq_show(struct seq_file *m,\n\t\t\t\t     enum cpuacct_stat_index index)\n{\n\tstruct cpuacct *ca = css_ca(seq_css(m));\n\tu64 percpu;\n\tint i;\n\n\tfor_each_possible_cpu(i) {\n\t\tpercpu = cpuacct_cpuusage_read(ca, i, index);\n\t\tseq_printf(m, \"%llu \", (unsigned long long) percpu);\n\t}\n\tseq_printf(m, \"\\n\");\n\treturn 0;\n}",
          "includes": [
            "#include \"sched.h\"",
            "#include <asm/irq_regs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n#include <asm/irq_regs.h>\n\nstatic int __cpuacct_percpu_seq_show(struct seq_file *m,\n\t\t\t\t     enum cpuacct_stat_index index)\n{\n\tstruct cpuacct *ca = css_ca(seq_css(m));\n\tu64 percpu;\n\tint i;\n\n\tfor_each_possible_cpu(i) {\n\t\tpercpu = cpuacct_cpuusage_read(ca, i, index);\n\t\tseq_printf(m, \"%llu \", (unsigned long long) percpu);\n\t}\n\tseq_printf(m, \"\\n\");\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n#include <asm/irq_regs.h>\n\nstatic int cpuacct_percpu_seq_show(struct seq_file *m, void *V)\n{\n\treturn __cpuacct_percpu_seq_show(m, CPUACCT_STAT_NSTATS);\n}"
  },
  {
    "function_name": "cpuacct_percpu_sys_seq_show",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/cpuacct.c",
    "lines": "230-233",
    "snippet": "static int cpuacct_percpu_sys_seq_show(struct seq_file *m, void *V)\n{\n\treturn __cpuacct_percpu_seq_show(m, CPUACCT_STAT_SYSTEM);\n}",
    "includes": [
      "#include \"sched.h\"",
      "#include <asm/irq_regs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__cpuacct_percpu_seq_show",
          "args": [
            "m",
            "CPUACCT_STAT_SYSTEM"
          ],
          "line": 232
        },
        "resolved": true,
        "details": {
          "function_name": "__cpuacct_percpu_seq_show",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/cpuacct.c",
          "lines": "210-223",
          "snippet": "static int __cpuacct_percpu_seq_show(struct seq_file *m,\n\t\t\t\t     enum cpuacct_stat_index index)\n{\n\tstruct cpuacct *ca = css_ca(seq_css(m));\n\tu64 percpu;\n\tint i;\n\n\tfor_each_possible_cpu(i) {\n\t\tpercpu = cpuacct_cpuusage_read(ca, i, index);\n\t\tseq_printf(m, \"%llu \", (unsigned long long) percpu);\n\t}\n\tseq_printf(m, \"\\n\");\n\treturn 0;\n}",
          "includes": [
            "#include \"sched.h\"",
            "#include <asm/irq_regs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n#include <asm/irq_regs.h>\n\nstatic int __cpuacct_percpu_seq_show(struct seq_file *m,\n\t\t\t\t     enum cpuacct_stat_index index)\n{\n\tstruct cpuacct *ca = css_ca(seq_css(m));\n\tu64 percpu;\n\tint i;\n\n\tfor_each_possible_cpu(i) {\n\t\tpercpu = cpuacct_cpuusage_read(ca, i, index);\n\t\tseq_printf(m, \"%llu \", (unsigned long long) percpu);\n\t}\n\tseq_printf(m, \"\\n\");\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n#include <asm/irq_regs.h>\n\nstatic int cpuacct_percpu_sys_seq_show(struct seq_file *m, void *V)\n{\n\treturn __cpuacct_percpu_seq_show(m, CPUACCT_STAT_SYSTEM);\n}"
  },
  {
    "function_name": "cpuacct_percpu_user_seq_show",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/cpuacct.c",
    "lines": "225-228",
    "snippet": "static int cpuacct_percpu_user_seq_show(struct seq_file *m, void *V)\n{\n\treturn __cpuacct_percpu_seq_show(m, CPUACCT_STAT_USER);\n}",
    "includes": [
      "#include \"sched.h\"",
      "#include <asm/irq_regs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__cpuacct_percpu_seq_show",
          "args": [
            "m",
            "CPUACCT_STAT_USER"
          ],
          "line": 227
        },
        "resolved": true,
        "details": {
          "function_name": "__cpuacct_percpu_seq_show",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/cpuacct.c",
          "lines": "210-223",
          "snippet": "static int __cpuacct_percpu_seq_show(struct seq_file *m,\n\t\t\t\t     enum cpuacct_stat_index index)\n{\n\tstruct cpuacct *ca = css_ca(seq_css(m));\n\tu64 percpu;\n\tint i;\n\n\tfor_each_possible_cpu(i) {\n\t\tpercpu = cpuacct_cpuusage_read(ca, i, index);\n\t\tseq_printf(m, \"%llu \", (unsigned long long) percpu);\n\t}\n\tseq_printf(m, \"\\n\");\n\treturn 0;\n}",
          "includes": [
            "#include \"sched.h\"",
            "#include <asm/irq_regs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n#include <asm/irq_regs.h>\n\nstatic int __cpuacct_percpu_seq_show(struct seq_file *m,\n\t\t\t\t     enum cpuacct_stat_index index)\n{\n\tstruct cpuacct *ca = css_ca(seq_css(m));\n\tu64 percpu;\n\tint i;\n\n\tfor_each_possible_cpu(i) {\n\t\tpercpu = cpuacct_cpuusage_read(ca, i, index);\n\t\tseq_printf(m, \"%llu \", (unsigned long long) percpu);\n\t}\n\tseq_printf(m, \"\\n\");\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n#include <asm/irq_regs.h>\n\nstatic int cpuacct_percpu_user_seq_show(struct seq_file *m, void *V)\n{\n\treturn __cpuacct_percpu_seq_show(m, CPUACCT_STAT_USER);\n}"
  },
  {
    "function_name": "__cpuacct_percpu_seq_show",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/cpuacct.c",
    "lines": "210-223",
    "snippet": "static int __cpuacct_percpu_seq_show(struct seq_file *m,\n\t\t\t\t     enum cpuacct_stat_index index)\n{\n\tstruct cpuacct *ca = css_ca(seq_css(m));\n\tu64 percpu;\n\tint i;\n\n\tfor_each_possible_cpu(i) {\n\t\tpercpu = cpuacct_cpuusage_read(ca, i, index);\n\t\tseq_printf(m, \"%llu \", (unsigned long long) percpu);\n\t}\n\tseq_printf(m, \"\\n\");\n\treturn 0;\n}",
    "includes": [
      "#include \"sched.h\"",
      "#include <asm/irq_regs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"\\n\""
          ],
          "line": 221
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "81-100",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpuacct_cpuusage_read",
          "args": [
            "ca",
            "i",
            "index"
          ],
          "line": 218
        },
        "resolved": true,
        "details": {
          "function_name": "cpuacct_cpuusage_read",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/cpuacct.c",
          "lines": "95-134",
          "snippet": "static u64 cpuacct_cpuusage_read(struct cpuacct *ca, int cpu,\n\t\t\t\t enum cpuacct_stat_index index)\n{\n\tu64 *cpuusage = per_cpu_ptr(ca->cpuusage, cpu);\n\tu64 *cpustat = per_cpu_ptr(ca->cpustat, cpu)->cpustat;\n\tu64 data;\n\n\t/*\n\t * We allow index == CPUACCT_STAT_NSTATS here to read\n\t * the sum of usages.\n\t */\n\tif (WARN_ON_ONCE(index > CPUACCT_STAT_NSTATS))\n\t\treturn 0;\n\n#ifndef CONFIG_64BIT\n\t/*\n\t * Take rq->lock to make 64-bit read safe on 32-bit platforms.\n\t */\n\traw_spin_rq_lock_irq(cpu_rq(cpu));\n#endif\n\n\tswitch (index) {\n\tcase CPUACCT_STAT_USER:\n\t\tdata = cpustat[CPUTIME_USER] + cpustat[CPUTIME_NICE];\n\t\tbreak;\n\tcase CPUACCT_STAT_SYSTEM:\n\t\tdata = cpustat[CPUTIME_SYSTEM] + cpustat[CPUTIME_IRQ] +\n\t\t\tcpustat[CPUTIME_SOFTIRQ];\n\t\tbreak;\n\tcase CPUACCT_STAT_NSTATS:\n\t\tdata = *cpuusage;\n\t\tbreak;\n\t}\n\n#ifndef CONFIG_64BIT\n\traw_spin_rq_unlock_irq(cpu_rq(cpu));\n#endif\n\n\treturn data;\n}",
          "includes": [
            "#include \"sched.h\"",
            "#include <asm/irq_regs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n#include <asm/irq_regs.h>\n\nstatic u64 cpuacct_cpuusage_read(struct cpuacct *ca, int cpu,\n\t\t\t\t enum cpuacct_stat_index index)\n{\n\tu64 *cpuusage = per_cpu_ptr(ca->cpuusage, cpu);\n\tu64 *cpustat = per_cpu_ptr(ca->cpustat, cpu)->cpustat;\n\tu64 data;\n\n\t/*\n\t * We allow index == CPUACCT_STAT_NSTATS here to read\n\t * the sum of usages.\n\t */\n\tif (WARN_ON_ONCE(index > CPUACCT_STAT_NSTATS))\n\t\treturn 0;\n\n#ifndef CONFIG_64BIT\n\t/*\n\t * Take rq->lock to make 64-bit read safe on 32-bit platforms.\n\t */\n\traw_spin_rq_lock_irq(cpu_rq(cpu));\n#endif\n\n\tswitch (index) {\n\tcase CPUACCT_STAT_USER:\n\t\tdata = cpustat[CPUTIME_USER] + cpustat[CPUTIME_NICE];\n\t\tbreak;\n\tcase CPUACCT_STAT_SYSTEM:\n\t\tdata = cpustat[CPUTIME_SYSTEM] + cpustat[CPUTIME_IRQ] +\n\t\t\tcpustat[CPUTIME_SOFTIRQ];\n\t\tbreak;\n\tcase CPUACCT_STAT_NSTATS:\n\t\tdata = *cpuusage;\n\t\tbreak;\n\t}\n\n#ifndef CONFIG_64BIT\n\traw_spin_rq_unlock_irq(cpu_rq(cpu));\n#endif\n\n\treturn data;\n}"
        }
      },
      {
        "call_info": {
          "callee": "css_ca",
          "args": [
            "seq_css(m)"
          ],
          "line": 213
        },
        "resolved": true,
        "details": {
          "function_name": "css_ca",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/cpuacct.c",
          "lines": "32-35",
          "snippet": "static inline struct cpuacct *css_ca(struct cgroup_subsys_state *css)\n{\n\treturn css ? container_of(css, struct cpuacct, css) : NULL;\n}",
          "includes": [
            "#include \"sched.h\"",
            "#include <asm/irq_regs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n#include <asm/irq_regs.h>\n\nstatic inline struct cpuacct *css_ca(struct cgroup_subsys_state *css)\n{\n\treturn css ? container_of(css, struct cpuacct, css) : NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_css",
          "args": [
            "m"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n#include <asm/irq_regs.h>\n\nstatic int __cpuacct_percpu_seq_show(struct seq_file *m,\n\t\t\t\t     enum cpuacct_stat_index index)\n{\n\tstruct cpuacct *ca = css_ca(seq_css(m));\n\tu64 percpu;\n\tint i;\n\n\tfor_each_possible_cpu(i) {\n\t\tpercpu = cpuacct_cpuusage_read(ca, i, index);\n\t\tseq_printf(m, \"%llu \", (unsigned long long) percpu);\n\t}\n\tseq_printf(m, \"\\n\");\n\treturn 0;\n}"
  },
  {
    "function_name": "cpuusage_write",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/cpuacct.c",
    "lines": "192-208",
    "snippet": "static int cpuusage_write(struct cgroup_subsys_state *css, struct cftype *cft,\n\t\t\t  u64 val)\n{\n\tstruct cpuacct *ca = css_ca(css);\n\tint cpu;\n\n\t/*\n\t * Only allow '0' here to do a reset.\n\t */\n\tif (val)\n\t\treturn -EINVAL;\n\n\tfor_each_possible_cpu(cpu)\n\t\tcpuacct_cpuusage_write(ca, cpu);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"sched.h\"",
      "#include <asm/irq_regs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "css_ca",
          "args": [
            "css"
          ],
          "line": 195
        },
        "resolved": true,
        "details": {
          "function_name": "css_ca",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/cpuacct.c",
          "lines": "32-35",
          "snippet": "static inline struct cpuacct *css_ca(struct cgroup_subsys_state *css)\n{\n\treturn css ? container_of(css, struct cpuacct, css) : NULL;\n}",
          "includes": [
            "#include \"sched.h\"",
            "#include <asm/irq_regs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n#include <asm/irq_regs.h>\n\nstatic inline struct cpuacct *css_ca(struct cgroup_subsys_state *css)\n{\n\treturn css ? container_of(css, struct cpuacct, css) : NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n#include <asm/irq_regs.h>\n\nstatic int cpuusage_write(struct cgroup_subsys_state *css, struct cftype *cft,\n\t\t\t  u64 val)\n{\n\tstruct cpuacct *ca = css_ca(css);\n\tint cpu;\n\n\t/*\n\t * Only allow '0' here to do a reset.\n\t */\n\tif (val)\n\t\treturn -EINVAL;\n\n\tfor_each_possible_cpu(cpu)\n\t\tcpuacct_cpuusage_write(ca, cpu);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "cpuusage_read",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/cpuacct.c",
    "lines": "187-190",
    "snippet": "static u64 cpuusage_read(struct cgroup_subsys_state *css, struct cftype *cft)\n{\n\treturn __cpuusage_read(css, CPUACCT_STAT_NSTATS);\n}",
    "includes": [
      "#include \"sched.h\"",
      "#include <asm/irq_regs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__cpuusage_read",
          "args": [
            "css",
            "CPUACCT_STAT_NSTATS"
          ],
          "line": 189
        },
        "resolved": true,
        "details": {
          "function_name": "__cpuusage_read",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/cpuacct.c",
          "lines": "162-173",
          "snippet": "static u64 __cpuusage_read(struct cgroup_subsys_state *css,\n\t\t\t   enum cpuacct_stat_index index)\n{\n\tstruct cpuacct *ca = css_ca(css);\n\tu64 totalcpuusage = 0;\n\tint i;\n\n\tfor_each_possible_cpu(i)\n\t\ttotalcpuusage += cpuacct_cpuusage_read(ca, i, index);\n\n\treturn totalcpuusage;\n}",
          "includes": [
            "#include \"sched.h\"",
            "#include <asm/irq_regs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n#include <asm/irq_regs.h>\n\nstatic u64 __cpuusage_read(struct cgroup_subsys_state *css,\n\t\t\t   enum cpuacct_stat_index index)\n{\n\tstruct cpuacct *ca = css_ca(css);\n\tu64 totalcpuusage = 0;\n\tint i;\n\n\tfor_each_possible_cpu(i)\n\t\ttotalcpuusage += cpuacct_cpuusage_read(ca, i, index);\n\n\treturn totalcpuusage;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n#include <asm/irq_regs.h>\n\nstatic u64 cpuusage_read(struct cgroup_subsys_state *css, struct cftype *cft)\n{\n\treturn __cpuusage_read(css, CPUACCT_STAT_NSTATS);\n}"
  },
  {
    "function_name": "cpuusage_sys_read",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/cpuacct.c",
    "lines": "181-185",
    "snippet": "static u64 cpuusage_sys_read(struct cgroup_subsys_state *css,\n\t\t\t     struct cftype *cft)\n{\n\treturn __cpuusage_read(css, CPUACCT_STAT_SYSTEM);\n}",
    "includes": [
      "#include \"sched.h\"",
      "#include <asm/irq_regs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__cpuusage_read",
          "args": [
            "css",
            "CPUACCT_STAT_SYSTEM"
          ],
          "line": 184
        },
        "resolved": true,
        "details": {
          "function_name": "__cpuusage_read",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/cpuacct.c",
          "lines": "162-173",
          "snippet": "static u64 __cpuusage_read(struct cgroup_subsys_state *css,\n\t\t\t   enum cpuacct_stat_index index)\n{\n\tstruct cpuacct *ca = css_ca(css);\n\tu64 totalcpuusage = 0;\n\tint i;\n\n\tfor_each_possible_cpu(i)\n\t\ttotalcpuusage += cpuacct_cpuusage_read(ca, i, index);\n\n\treturn totalcpuusage;\n}",
          "includes": [
            "#include \"sched.h\"",
            "#include <asm/irq_regs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n#include <asm/irq_regs.h>\n\nstatic u64 __cpuusage_read(struct cgroup_subsys_state *css,\n\t\t\t   enum cpuacct_stat_index index)\n{\n\tstruct cpuacct *ca = css_ca(css);\n\tu64 totalcpuusage = 0;\n\tint i;\n\n\tfor_each_possible_cpu(i)\n\t\ttotalcpuusage += cpuacct_cpuusage_read(ca, i, index);\n\n\treturn totalcpuusage;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n#include <asm/irq_regs.h>\n\nstatic u64 cpuusage_sys_read(struct cgroup_subsys_state *css,\n\t\t\t     struct cftype *cft)\n{\n\treturn __cpuusage_read(css, CPUACCT_STAT_SYSTEM);\n}"
  },
  {
    "function_name": "cpuusage_user_read",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/cpuacct.c",
    "lines": "175-179",
    "snippet": "static u64 cpuusage_user_read(struct cgroup_subsys_state *css,\n\t\t\t      struct cftype *cft)\n{\n\treturn __cpuusage_read(css, CPUACCT_STAT_USER);\n}",
    "includes": [
      "#include \"sched.h\"",
      "#include <asm/irq_regs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__cpuusage_read",
          "args": [
            "css",
            "CPUACCT_STAT_USER"
          ],
          "line": 178
        },
        "resolved": true,
        "details": {
          "function_name": "__cpuusage_read",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/cpuacct.c",
          "lines": "162-173",
          "snippet": "static u64 __cpuusage_read(struct cgroup_subsys_state *css,\n\t\t\t   enum cpuacct_stat_index index)\n{\n\tstruct cpuacct *ca = css_ca(css);\n\tu64 totalcpuusage = 0;\n\tint i;\n\n\tfor_each_possible_cpu(i)\n\t\ttotalcpuusage += cpuacct_cpuusage_read(ca, i, index);\n\n\treturn totalcpuusage;\n}",
          "includes": [
            "#include \"sched.h\"",
            "#include <asm/irq_regs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n#include <asm/irq_regs.h>\n\nstatic u64 __cpuusage_read(struct cgroup_subsys_state *css,\n\t\t\t   enum cpuacct_stat_index index)\n{\n\tstruct cpuacct *ca = css_ca(css);\n\tu64 totalcpuusage = 0;\n\tint i;\n\n\tfor_each_possible_cpu(i)\n\t\ttotalcpuusage += cpuacct_cpuusage_read(ca, i, index);\n\n\treturn totalcpuusage;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n#include <asm/irq_regs.h>\n\nstatic u64 cpuusage_user_read(struct cgroup_subsys_state *css,\n\t\t\t      struct cftype *cft)\n{\n\treturn __cpuusage_read(css, CPUACCT_STAT_USER);\n}"
  },
  {
    "function_name": "__cpuusage_read",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/cpuacct.c",
    "lines": "162-173",
    "snippet": "static u64 __cpuusage_read(struct cgroup_subsys_state *css,\n\t\t\t   enum cpuacct_stat_index index)\n{\n\tstruct cpuacct *ca = css_ca(css);\n\tu64 totalcpuusage = 0;\n\tint i;\n\n\tfor_each_possible_cpu(i)\n\t\ttotalcpuusage += cpuacct_cpuusage_read(ca, i, index);\n\n\treturn totalcpuusage;\n}",
    "includes": [
      "#include \"sched.h\"",
      "#include <asm/irq_regs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "css_ca",
          "args": [
            "css"
          ],
          "line": 165
        },
        "resolved": true,
        "details": {
          "function_name": "css_ca",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/cpuacct.c",
          "lines": "32-35",
          "snippet": "static inline struct cpuacct *css_ca(struct cgroup_subsys_state *css)\n{\n\treturn css ? container_of(css, struct cpuacct, css) : NULL;\n}",
          "includes": [
            "#include \"sched.h\"",
            "#include <asm/irq_regs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n#include <asm/irq_regs.h>\n\nstatic inline struct cpuacct *css_ca(struct cgroup_subsys_state *css)\n{\n\treturn css ? container_of(css, struct cpuacct, css) : NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n#include <asm/irq_regs.h>\n\nstatic u64 __cpuusage_read(struct cgroup_subsys_state *css,\n\t\t\t   enum cpuacct_stat_index index)\n{\n\tstruct cpuacct *ca = css_ca(css);\n\tu64 totalcpuusage = 0;\n\tint i;\n\n\tfor_each_possible_cpu(i)\n\t\ttotalcpuusage += cpuacct_cpuusage_read(ca, i, index);\n\n\treturn totalcpuusage;\n}"
  },
  {
    "function_name": "cpuacct_cpuusage_write",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/cpuacct.c",
    "lines": "136-159",
    "snippet": "static void cpuacct_cpuusage_write(struct cpuacct *ca, int cpu)\n{\n\tu64 *cpuusage = per_cpu_ptr(ca->cpuusage, cpu);\n\tu64 *cpustat = per_cpu_ptr(ca->cpustat, cpu)->cpustat;\n\n\t/* Don't allow to reset global kernel_cpustat */\n\tif (ca == &root_cpuacct)\n\t\treturn;\n\n#ifndef CONFIG_64BIT\n\t/*\n\t * Take rq->lock to make 64-bit write safe on 32-bit platforms.\n\t */\n\traw_spin_rq_lock_irq(cpu_rq(cpu));\n#endif\n\t*cpuusage = 0;\n\tcpustat[CPUTIME_USER] = cpustat[CPUTIME_NICE] = 0;\n\tcpustat[CPUTIME_SYSTEM] = cpustat[CPUTIME_IRQ] = 0;\n\tcpustat[CPUTIME_SOFTIRQ] = 0;\n\n#ifndef CONFIG_64BIT\n\traw_spin_rq_unlock_irq(cpu_rq(cpu));\n#endif\n}",
    "includes": [
      "#include \"sched.h\"",
      "#include <asm/irq_regs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct cpuacct root_cpuacct = {\n\t.cpustat\t= &kernel_cpustat,\n\t.cpuusage\t= &root_cpuacct_cpuusage,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_rq_unlock_irq",
          "args": [
            "cpu_rq(cpu)"
          ],
          "line": 157
        },
        "resolved": true,
        "details": {
          "function_name": "raw_spin_rq_unlock_irq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/sched.h",
          "lines": "1327-1331",
          "snippet": "static inline void raw_spin_rq_unlock_irq(struct rq *rq)\n{\n\traw_spin_rq_unlock(rq);\n\tlocal_irq_enable();\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include <trace/events/sched.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/energy_model.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/bitops.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern bool raw_spin_rq_trylock(struct rq *rq);",
            "extern void raw_spin_rq_unlock(struct rq *rq);",
            "extern void update_rq_clock(struct rq *rq);",
            "extern struct task_struct *pick_next_task_idle(struct rq *rq);",
            "extern void resched_curr(struct rq *rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include <trace/events/sched.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/ratelimit.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/energy_model.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/bitops.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nextern bool raw_spin_rq_trylock(struct rq *rq);\nextern void raw_spin_rq_unlock(struct rq *rq);\nextern void update_rq_clock(struct rq *rq);\nextern struct task_struct *pick_next_task_idle(struct rq *rq);\nextern void resched_curr(struct rq *rq);\n\nstatic inline void raw_spin_rq_unlock_irq(struct rq *rq)\n{\n\traw_spin_rq_unlock(rq);\n\tlocal_irq_enable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_rq",
          "args": [
            "cpu"
          ],
          "line": 157
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_rq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "5032-5048",
          "snippet": "for_each_possible_cpu(i)\n\t\tsum += cpu_rq(i)->nr_switches;\n\n\treturn sum;\n}\n\n/*\n * Consumers of these two interfaces, like for example the cpuidle menu\n * governor, are using nonsensical data. Preferring shallow idle state selection\n * for a CPU that has IO-wait which might not even end up running the task when\n * it does become runnable.\n */\n\nunsigned int nr_iowait_cpu(int cpu)\n{\n\treturn atomic_read(&cpu_rq(cpu)->nr_iowait);\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int i;",
            "unsigned long long sum = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nint i;\nunsigned long long sum = 0;\n\nfor_each_possible_cpu(i)\n\t\tsum += cpu_rq(i)->nr_switches;\n\n\treturn sum;\n}\n\n/*\n * Consumers of these two interfaces, like for example the cpuidle menu\n * governor, are using nonsensical data. Preferring shallow idle state selection\n * for a CPU that has IO-wait which might not even end up running the task when\n * it does become runnable.\n */\n\nunsigned int nr_iowait_cpu(int cpu)\n{\n\treturn atomic_read(&cpu_rq(cpu)->nr_iowait);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_rq_lock_irq",
          "args": [
            "cpu_rq(cpu)"
          ],
          "line": 149
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_rq_lock_irqsave",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/sched.h",
          "lines": "1333-1339",
          "snippet": "static inline unsigned long _raw_spin_rq_lock_irqsave(struct rq *rq)\n{\n\tunsigned long flags;\n\tlocal_irq_save(flags);\n\traw_spin_rq_lock(rq);\n\treturn flags;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include <trace/events/sched.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/energy_model.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/bitops.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern bool raw_spin_rq_trylock(struct rq *rq);",
            "extern void raw_spin_rq_unlock(struct rq *rq);",
            "extern void update_rq_clock(struct rq *rq);",
            "extern struct task_struct *pick_next_task_idle(struct rq *rq);",
            "extern void resched_curr(struct rq *rq);",
            "extern void activate_task(struct rq *rq, struct task_struct *p, int flags);",
            "extern void deactivate_task(struct rq *rq, struct task_struct *p, int flags);",
            "extern void check_preempt_curr(struct rq *rq, struct task_struct *p, int flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include <trace/events/sched.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/ratelimit.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/energy_model.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/bitops.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nextern bool raw_spin_rq_trylock(struct rq *rq);\nextern void raw_spin_rq_unlock(struct rq *rq);\nextern void update_rq_clock(struct rq *rq);\nextern struct task_struct *pick_next_task_idle(struct rq *rq);\nextern void resched_curr(struct rq *rq);\nextern void activate_task(struct rq *rq, struct task_struct *p, int flags);\nextern void deactivate_task(struct rq *rq, struct task_struct *p, int flags);\nextern void check_preempt_curr(struct rq *rq, struct task_struct *p, int flags);\n\nstatic inline unsigned long _raw_spin_rq_lock_irqsave(struct rq *rq)\n{\n\tunsigned long flags;\n\tlocal_irq_save(flags);\n\traw_spin_rq_lock(rq);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "ca->cpustat",
            "cpu"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "ca->cpuusage",
            "cpu"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n#include <asm/irq_regs.h>\n\nstatic struct cpuacct root_cpuacct = {\n\t.cpustat\t= &kernel_cpustat,\n\t.cpuusage\t= &root_cpuacct_cpuusage,\n};\n\nstatic void cpuacct_cpuusage_write(struct cpuacct *ca, int cpu)\n{\n\tu64 *cpuusage = per_cpu_ptr(ca->cpuusage, cpu);\n\tu64 *cpustat = per_cpu_ptr(ca->cpustat, cpu)->cpustat;\n\n\t/* Don't allow to reset global kernel_cpustat */\n\tif (ca == &root_cpuacct)\n\t\treturn;\n\n#ifndef CONFIG_64BIT\n\t/*\n\t * Take rq->lock to make 64-bit write safe on 32-bit platforms.\n\t */\n\traw_spin_rq_lock_irq(cpu_rq(cpu));\n#endif\n\t*cpuusage = 0;\n\tcpustat[CPUTIME_USER] = cpustat[CPUTIME_NICE] = 0;\n\tcpustat[CPUTIME_SYSTEM] = cpustat[CPUTIME_IRQ] = 0;\n\tcpustat[CPUTIME_SOFTIRQ] = 0;\n\n#ifndef CONFIG_64BIT\n\traw_spin_rq_unlock_irq(cpu_rq(cpu));\n#endif\n}"
  },
  {
    "function_name": "cpuacct_cpuusage_read",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/cpuacct.c",
    "lines": "95-134",
    "snippet": "static u64 cpuacct_cpuusage_read(struct cpuacct *ca, int cpu,\n\t\t\t\t enum cpuacct_stat_index index)\n{\n\tu64 *cpuusage = per_cpu_ptr(ca->cpuusage, cpu);\n\tu64 *cpustat = per_cpu_ptr(ca->cpustat, cpu)->cpustat;\n\tu64 data;\n\n\t/*\n\t * We allow index == CPUACCT_STAT_NSTATS here to read\n\t * the sum of usages.\n\t */\n\tif (WARN_ON_ONCE(index > CPUACCT_STAT_NSTATS))\n\t\treturn 0;\n\n#ifndef CONFIG_64BIT\n\t/*\n\t * Take rq->lock to make 64-bit read safe on 32-bit platforms.\n\t */\n\traw_spin_rq_lock_irq(cpu_rq(cpu));\n#endif\n\n\tswitch (index) {\n\tcase CPUACCT_STAT_USER:\n\t\tdata = cpustat[CPUTIME_USER] + cpustat[CPUTIME_NICE];\n\t\tbreak;\n\tcase CPUACCT_STAT_SYSTEM:\n\t\tdata = cpustat[CPUTIME_SYSTEM] + cpustat[CPUTIME_IRQ] +\n\t\t\tcpustat[CPUTIME_SOFTIRQ];\n\t\tbreak;\n\tcase CPUACCT_STAT_NSTATS:\n\t\tdata = *cpuusage;\n\t\tbreak;\n\t}\n\n#ifndef CONFIG_64BIT\n\traw_spin_rq_unlock_irq(cpu_rq(cpu));\n#endif\n\n\treturn data;\n}",
    "includes": [
      "#include \"sched.h\"",
      "#include <asm/irq_regs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_rq_unlock_irq",
          "args": [
            "cpu_rq(cpu)"
          ],
          "line": 130
        },
        "resolved": true,
        "details": {
          "function_name": "raw_spin_rq_unlock_irq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/sched.h",
          "lines": "1327-1331",
          "snippet": "static inline void raw_spin_rq_unlock_irq(struct rq *rq)\n{\n\traw_spin_rq_unlock(rq);\n\tlocal_irq_enable();\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include <trace/events/sched.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/energy_model.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/bitops.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern bool raw_spin_rq_trylock(struct rq *rq);",
            "extern void raw_spin_rq_unlock(struct rq *rq);",
            "extern void update_rq_clock(struct rq *rq);",
            "extern struct task_struct *pick_next_task_idle(struct rq *rq);",
            "extern void resched_curr(struct rq *rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include <trace/events/sched.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/ratelimit.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/energy_model.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/bitops.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nextern bool raw_spin_rq_trylock(struct rq *rq);\nextern void raw_spin_rq_unlock(struct rq *rq);\nextern void update_rq_clock(struct rq *rq);\nextern struct task_struct *pick_next_task_idle(struct rq *rq);\nextern void resched_curr(struct rq *rq);\n\nstatic inline void raw_spin_rq_unlock_irq(struct rq *rq)\n{\n\traw_spin_rq_unlock(rq);\n\tlocal_irq_enable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_rq",
          "args": [
            "cpu"
          ],
          "line": 130
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_rq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "5032-5048",
          "snippet": "for_each_possible_cpu(i)\n\t\tsum += cpu_rq(i)->nr_switches;\n\n\treturn sum;\n}\n\n/*\n * Consumers of these two interfaces, like for example the cpuidle menu\n * governor, are using nonsensical data. Preferring shallow idle state selection\n * for a CPU that has IO-wait which might not even end up running the task when\n * it does become runnable.\n */\n\nunsigned int nr_iowait_cpu(int cpu)\n{\n\treturn atomic_read(&cpu_rq(cpu)->nr_iowait);\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int i;",
            "unsigned long long sum = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nint i;\nunsigned long long sum = 0;\n\nfor_each_possible_cpu(i)\n\t\tsum += cpu_rq(i)->nr_switches;\n\n\treturn sum;\n}\n\n/*\n * Consumers of these two interfaces, like for example the cpuidle menu\n * governor, are using nonsensical data. Preferring shallow idle state selection\n * for a CPU that has IO-wait which might not even end up running the task when\n * it does become runnable.\n */\n\nunsigned int nr_iowait_cpu(int cpu)\n{\n\treturn atomic_read(&cpu_rq(cpu)->nr_iowait);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_rq_lock_irq",
          "args": [
            "cpu_rq(cpu)"
          ],
          "line": 113
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_rq_lock_irqsave",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/sched.h",
          "lines": "1333-1339",
          "snippet": "static inline unsigned long _raw_spin_rq_lock_irqsave(struct rq *rq)\n{\n\tunsigned long flags;\n\tlocal_irq_save(flags);\n\traw_spin_rq_lock(rq);\n\treturn flags;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include <trace/events/sched.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/energy_model.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/bitops.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern bool raw_spin_rq_trylock(struct rq *rq);",
            "extern void raw_spin_rq_unlock(struct rq *rq);",
            "extern void update_rq_clock(struct rq *rq);",
            "extern struct task_struct *pick_next_task_idle(struct rq *rq);",
            "extern void resched_curr(struct rq *rq);",
            "extern void activate_task(struct rq *rq, struct task_struct *p, int flags);",
            "extern void deactivate_task(struct rq *rq, struct task_struct *p, int flags);",
            "extern void check_preempt_curr(struct rq *rq, struct task_struct *p, int flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include <trace/events/sched.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/ratelimit.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/energy_model.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/bitops.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nextern bool raw_spin_rq_trylock(struct rq *rq);\nextern void raw_spin_rq_unlock(struct rq *rq);\nextern void update_rq_clock(struct rq *rq);\nextern struct task_struct *pick_next_task_idle(struct rq *rq);\nextern void resched_curr(struct rq *rq);\nextern void activate_task(struct rq *rq, struct task_struct *p, int flags);\nextern void deactivate_task(struct rq *rq, struct task_struct *p, int flags);\nextern void check_preempt_curr(struct rq *rq, struct task_struct *p, int flags);\n\nstatic inline unsigned long _raw_spin_rq_lock_irqsave(struct rq *rq)\n{\n\tunsigned long flags;\n\tlocal_irq_save(flags);\n\traw_spin_rq_lock(rq);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "index > CPUACCT_STAT_NSTATS"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "ca->cpustat",
            "cpu"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "ca->cpuusage",
            "cpu"
          ],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n#include <asm/irq_regs.h>\n\nstatic u64 cpuacct_cpuusage_read(struct cpuacct *ca, int cpu,\n\t\t\t\t enum cpuacct_stat_index index)\n{\n\tu64 *cpuusage = per_cpu_ptr(ca->cpuusage, cpu);\n\tu64 *cpustat = per_cpu_ptr(ca->cpustat, cpu)->cpustat;\n\tu64 data;\n\n\t/*\n\t * We allow index == CPUACCT_STAT_NSTATS here to read\n\t * the sum of usages.\n\t */\n\tif (WARN_ON_ONCE(index > CPUACCT_STAT_NSTATS))\n\t\treturn 0;\n\n#ifndef CONFIG_64BIT\n\t/*\n\t * Take rq->lock to make 64-bit read safe on 32-bit platforms.\n\t */\n\traw_spin_rq_lock_irq(cpu_rq(cpu));\n#endif\n\n\tswitch (index) {\n\tcase CPUACCT_STAT_USER:\n\t\tdata = cpustat[CPUTIME_USER] + cpustat[CPUTIME_NICE];\n\t\tbreak;\n\tcase CPUACCT_STAT_SYSTEM:\n\t\tdata = cpustat[CPUTIME_SYSTEM] + cpustat[CPUTIME_IRQ] +\n\t\t\tcpustat[CPUTIME_SOFTIRQ];\n\t\tbreak;\n\tcase CPUACCT_STAT_NSTATS:\n\t\tdata = *cpuusage;\n\t\tbreak;\n\t}\n\n#ifndef CONFIG_64BIT\n\traw_spin_rq_unlock_irq(cpu_rq(cpu));\n#endif\n\n\treturn data;\n}"
  },
  {
    "function_name": "cpuacct_css_free",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/cpuacct.c",
    "lines": "86-93",
    "snippet": "static void cpuacct_css_free(struct cgroup_subsys_state *css)\n{\n\tstruct cpuacct *ca = css_ca(css);\n\n\tfree_percpu(ca->cpustat);\n\tfree_percpu(ca->cpuusage);\n\tkfree(ca);\n}",
    "includes": [
      "#include \"sched.h\"",
      "#include <asm/irq_regs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ca"
          ],
          "line": 92
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_percpu",
          "args": [
            "ca->cpuusage"
          ],
          "line": 91
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_array_free_percpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/arraymap.c",
          "lines": "21-29",
          "snippet": "static void bpf_array_free_percpu(struct bpf_array *array)\n{\n\tint i;\n\n\tfor (i = 0; i < array->map.max_entries; i++) {\n\t\tfree_percpu(array->pptrs[i]);\n\t\tcond_resched();\n\t}\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/filter.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include <linux/rcupdate_trace.h>\n#include <uapi/linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/filter.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic void bpf_array_free_percpu(struct bpf_array *array)\n{\n\tint i;\n\n\tfor (i = 0; i < array->map.max_entries; i++) {\n\t\tfree_percpu(array->pptrs[i]);\n\t\tcond_resched();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "css_ca",
          "args": [
            "css"
          ],
          "line": 88
        },
        "resolved": true,
        "details": {
          "function_name": "css_ca",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/cpuacct.c",
          "lines": "32-35",
          "snippet": "static inline struct cpuacct *css_ca(struct cgroup_subsys_state *css)\n{\n\treturn css ? container_of(css, struct cpuacct, css) : NULL;\n}",
          "includes": [
            "#include \"sched.h\"",
            "#include <asm/irq_regs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n#include <asm/irq_regs.h>\n\nstatic inline struct cpuacct *css_ca(struct cgroup_subsys_state *css)\n{\n\treturn css ? container_of(css, struct cpuacct, css) : NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n#include <asm/irq_regs.h>\n\nstatic void cpuacct_css_free(struct cgroup_subsys_state *css)\n{\n\tstruct cpuacct *ca = css_ca(css);\n\n\tfree_percpu(ca->cpustat);\n\tfree_percpu(ca->cpuusage);\n\tkfree(ca);\n}"
  },
  {
    "function_name": "cpuacct_css_alloc",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/cpuacct.c",
    "lines": "55-83",
    "snippet": "static struct cgroup_subsys_state *\ncpuacct_css_alloc(struct cgroup_subsys_state *parent_css)\n{\n\tstruct cpuacct *ca;\n\n\tif (!parent_css)\n\t\treturn &root_cpuacct.css;\n\n\tca = kzalloc(sizeof(*ca), GFP_KERNEL);\n\tif (!ca)\n\t\tgoto out;\n\n\tca->cpuusage = alloc_percpu(u64);\n\tif (!ca->cpuusage)\n\t\tgoto out_free_ca;\n\n\tca->cpustat = alloc_percpu(struct kernel_cpustat);\n\tif (!ca->cpustat)\n\t\tgoto out_free_cpuusage;\n\n\treturn &ca->css;\n\nout_free_cpuusage:\n\tfree_percpu(ca->cpuusage);\nout_free_ca:\n\tkfree(ca);\nout:\n\treturn ERR_PTR(-ENOMEM);\n}",
    "includes": [
      "#include \"sched.h\"",
      "#include <asm/irq_regs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct cpuacct root_cpuacct = {\n\t.cpustat\t= &kernel_cpustat,\n\t.cpuusage\t= &root_cpuacct_cpuusage,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ca"
          ],
          "line": 80
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_percpu",
          "args": [
            "ca->cpuusage"
          ],
          "line": 78
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_array_free_percpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/arraymap.c",
          "lines": "21-29",
          "snippet": "static void bpf_array_free_percpu(struct bpf_array *array)\n{\n\tint i;\n\n\tfor (i = 0; i < array->map.max_entries; i++) {\n\t\tfree_percpu(array->pptrs[i]);\n\t\tcond_resched();\n\t}\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/filter.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include <linux/rcupdate_trace.h>\n#include <uapi/linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/filter.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic void bpf_array_free_percpu(struct bpf_array *array)\n{\n\tint i;\n\n\tfor (i = 0; i < array->map.max_entries; i++) {\n\t\tfree_percpu(array->pptrs[i]);\n\t\tcond_resched();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_percpu",
          "args": [
            "structkernel_cpustat"
          ],
          "line": 71
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_array_alloc_percpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/arraymap.c",
          "lines": "31-48",
          "snippet": "static int bpf_array_alloc_percpu(struct bpf_array *array)\n{\n\tvoid __percpu *ptr;\n\tint i;\n\n\tfor (i = 0; i < array->map.max_entries; i++) {\n\t\tptr = bpf_map_alloc_percpu(&array->map, array->elem_size, 8,\n\t\t\t\t\t   GFP_USER | __GFP_NOWARN);\n\t\tif (!ptr) {\n\t\t\tbpf_array_free_percpu(array);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tarray->pptrs[i] = ptr;\n\t\tcond_resched();\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/filter.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include <linux/rcupdate_trace.h>\n#include <uapi/linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/filter.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic int bpf_array_alloc_percpu(struct bpf_array *array)\n{\n\tvoid __percpu *ptr;\n\tint i;\n\n\tfor (i = 0; i < array->map.max_entries; i++) {\n\t\tptr = bpf_map_alloc_percpu(&array->map, array->elem_size, 8,\n\t\t\t\t\t   GFP_USER | __GFP_NOWARN);\n\t\tif (!ptr) {\n\t\t\tbpf_array_free_percpu(array);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tarray->pptrs[i] = ptr;\n\t\tcond_resched();\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*ca)",
            "GFP_KERNEL"
          ],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n#include <asm/irq_regs.h>\n\nstatic struct cpuacct root_cpuacct = {\n\t.cpustat\t= &kernel_cpustat,\n\t.cpuusage\t= &root_cpuacct_cpuusage,\n};\n\nstatic struct cgroup_subsys_state *\ncpuacct_css_alloc(struct cgroup_subsys_state *parent_css)\n{\n\tstruct cpuacct *ca;\n\n\tif (!parent_css)\n\t\treturn &root_cpuacct.css;\n\n\tca = kzalloc(sizeof(*ca), GFP_KERNEL);\n\tif (!ca)\n\t\tgoto out;\n\n\tca->cpuusage = alloc_percpu(u64);\n\tif (!ca->cpuusage)\n\t\tgoto out_free_ca;\n\n\tca->cpustat = alloc_percpu(struct kernel_cpustat);\n\tif (!ca->cpustat)\n\t\tgoto out_free_cpuusage;\n\n\treturn &ca->css;\n\nout_free_cpuusage:\n\tfree_percpu(ca->cpuusage);\nout_free_ca:\n\tkfree(ca);\nout:\n\treturn ERR_PTR(-ENOMEM);\n}"
  },
  {
    "function_name": "parent_ca",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/cpuacct.c",
    "lines": "43-46",
    "snippet": "static inline struct cpuacct *parent_ca(struct cpuacct *ca)\n{\n\treturn css_ca(ca->css.parent);\n}",
    "includes": [
      "#include \"sched.h\"",
      "#include <asm/irq_regs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "css_ca",
          "args": [
            "ca->css.parent"
          ],
          "line": 45
        },
        "resolved": true,
        "details": {
          "function_name": "css_ca",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/cpuacct.c",
          "lines": "32-35",
          "snippet": "static inline struct cpuacct *css_ca(struct cgroup_subsys_state *css)\n{\n\treturn css ? container_of(css, struct cpuacct, css) : NULL;\n}",
          "includes": [
            "#include \"sched.h\"",
            "#include <asm/irq_regs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n#include <asm/irq_regs.h>\n\nstatic inline struct cpuacct *css_ca(struct cgroup_subsys_state *css)\n{\n\treturn css ? container_of(css, struct cpuacct, css) : NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n#include <asm/irq_regs.h>\n\nstatic inline struct cpuacct *parent_ca(struct cpuacct *ca)\n{\n\treturn css_ca(ca->css.parent);\n}"
  },
  {
    "function_name": "task_ca",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/cpuacct.c",
    "lines": "38-41",
    "snippet": "static inline struct cpuacct *task_ca(struct task_struct *tsk)\n{\n\treturn css_ca(task_css(tsk, cpuacct_cgrp_id));\n}",
    "includes": [
      "#include \"sched.h\"",
      "#include <asm/irq_regs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "css_ca",
          "args": [
            "task_css(tsk, cpuacct_cgrp_id)"
          ],
          "line": 40
        },
        "resolved": true,
        "details": {
          "function_name": "css_ca",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/cpuacct.c",
          "lines": "32-35",
          "snippet": "static inline struct cpuacct *css_ca(struct cgroup_subsys_state *css)\n{\n\treturn css ? container_of(css, struct cpuacct, css) : NULL;\n}",
          "includes": [
            "#include \"sched.h\"",
            "#include <asm/irq_regs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n#include <asm/irq_regs.h>\n\nstatic inline struct cpuacct *css_ca(struct cgroup_subsys_state *css)\n{\n\treturn css ? container_of(css, struct cpuacct, css) : NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_css",
          "args": [
            "tsk",
            "cpuacct_cgrp_id"
          ],
          "line": 40
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n#include <asm/irq_regs.h>\n\nstatic inline struct cpuacct *task_ca(struct task_struct *tsk)\n{\n\treturn css_ca(task_css(tsk, cpuacct_cgrp_id));\n}"
  },
  {
    "function_name": "css_ca",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/cpuacct.c",
    "lines": "32-35",
    "snippet": "static inline struct cpuacct *css_ca(struct cgroup_subsys_state *css)\n{\n\treturn css ? container_of(css, struct cpuacct, css) : NULL;\n}",
    "includes": [
      "#include \"sched.h\"",
      "#include <asm/irq_regs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "css",
            "structcpuacct",
            "css"
          ],
          "line": 34
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n#include <asm/irq_regs.h>\n\nstatic inline struct cpuacct *css_ca(struct cgroup_subsys_state *css)\n{\n\treturn css ? container_of(css, struct cpuacct, css) : NULL;\n}"
  }
]