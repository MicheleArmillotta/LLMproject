[
  {
    "function_name": "kcsan_test_exit",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/kcsan_test.c",
    "lines": "1606-1611",
    "snippet": "static void kcsan_test_exit(void)\n{\n\t__kunit_test_suites_exit(kcsan_test_suites);\n\tfor_each_kernel_tracepoint(unregister_tracepoints, NULL);\n\ttracepoint_synchronize_unregister();\n}",
    "includes": [
      "#include <trace/events/printk.h>",
      "#include <linux/types.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/torture.h>",
      "#include <linux/timer.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kcsan-checks.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <kunit/test.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kunit_suite *kcsan_test_suites[] = { &kcsan_test_suite, NULL };"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tracepoint_synchronize_unregister",
          "args": [],
          "line": 1610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_kernel_tracepoint",
          "args": [
            "unregister_tracepoints",
            "NULL"
          ],
          "line": 1609
        },
        "resolved": true,
        "details": {
          "function_name": "for_each_kernel_tracepoint",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/tracepoint.c",
          "lines": "746-751",
          "snippet": "void for_each_kernel_tracepoint(void (*fct)(struct tracepoint *tp, void *priv),\n\t\tvoid *priv)\n{\n\tfor_each_tracepoint_range(__start___tracepoints_ptrs,\n\t\t__stop___tracepoints_ptrs, fct, priv);\n}",
          "includes": [
            "#include <linux/static_key.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list.h>",
            "#include <linux/jhash.h>",
            "#include <linux/types.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern tracepoint_ptr_t __start___tracepoints_ptrs[];",
            "extern tracepoint_ptr_t __stop___tracepoints_ptrs[];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/static_key.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/tracepoint.h>\n#include <linux/rcupdate.h>\n#include <linux/list.h>\n#include <linux/jhash.h>\n#include <linux/types.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nextern tracepoint_ptr_t __start___tracepoints_ptrs[];\nextern tracepoint_ptr_t __stop___tracepoints_ptrs[];\n\nvoid for_each_kernel_tracepoint(void (*fct)(struct tracepoint *tp, void *priv),\n\t\tvoid *priv)\n{\n\tfor_each_tracepoint_range(__start___tracepoints_ptrs,\n\t\t__stop___tracepoints_ptrs, fct, priv);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__kunit_test_suites_exit",
          "args": [
            "kcsan_test_suites"
          ],
          "line": 1608
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/printk.h>\n#include <linux/types.h>\n#include <linux/tracepoint.h>\n#include <linux/torture.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/seqlock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/kcsan-checks.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <kunit/test.h>\n\nstatic struct kunit_suite *kcsan_test_suites[] = { &kcsan_test_suite, NULL };\n\nstatic void kcsan_test_exit(void)\n{\n\t__kunit_test_suites_exit(kcsan_test_suites);\n\tfor_each_kernel_tracepoint(unregister_tracepoints, NULL);\n\ttracepoint_synchronize_unregister();\n}"
  },
  {
    "function_name": "kcsan_test_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/kcsan_test.c",
    "lines": "1595-1604",
    "snippet": "static int __init kcsan_test_init(void)\n{\n\t/*\n\t * Because we want to be able to build the test as a module, we need to\n\t * iterate through all known tracepoints, since the static registration\n\t * won't work here.\n\t */\n\tfor_each_kernel_tracepoint(register_tracepoints, NULL);\n\treturn __kunit_test_suites_init(kcsan_test_suites);\n}",
    "includes": [
      "#include <trace/events/printk.h>",
      "#include <linux/types.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/torture.h>",
      "#include <linux/timer.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kcsan-checks.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <kunit/test.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kunit_suite *kcsan_test_suites[] = { &kcsan_test_suite, NULL };"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__kunit_test_suites_init",
          "args": [
            "kcsan_test_suites"
          ],
          "line": 1603
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_kernel_tracepoint",
          "args": [
            "register_tracepoints",
            "NULL"
          ],
          "line": 1602
        },
        "resolved": true,
        "details": {
          "function_name": "for_each_kernel_tracepoint",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/tracepoint.c",
          "lines": "746-751",
          "snippet": "void for_each_kernel_tracepoint(void (*fct)(struct tracepoint *tp, void *priv),\n\t\tvoid *priv)\n{\n\tfor_each_tracepoint_range(__start___tracepoints_ptrs,\n\t\t__stop___tracepoints_ptrs, fct, priv);\n}",
          "includes": [
            "#include <linux/static_key.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list.h>",
            "#include <linux/jhash.h>",
            "#include <linux/types.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern tracepoint_ptr_t __start___tracepoints_ptrs[];",
            "extern tracepoint_ptr_t __stop___tracepoints_ptrs[];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/static_key.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/tracepoint.h>\n#include <linux/rcupdate.h>\n#include <linux/list.h>\n#include <linux/jhash.h>\n#include <linux/types.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nextern tracepoint_ptr_t __start___tracepoints_ptrs[];\nextern tracepoint_ptr_t __stop___tracepoints_ptrs[];\n\nvoid for_each_kernel_tracepoint(void (*fct)(struct tracepoint *tp, void *priv),\n\t\tvoid *priv)\n{\n\tfor_each_tracepoint_range(__start___tracepoints_ptrs,\n\t\t__stop___tracepoints_ptrs, fct, priv);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/printk.h>\n#include <linux/types.h>\n#include <linux/tracepoint.h>\n#include <linux/torture.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/seqlock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/kcsan-checks.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <kunit/test.h>\n\nstatic struct kunit_suite *kcsan_test_suites[] = { &kcsan_test_suite, NULL };\n\nstatic int __init kcsan_test_init(void)\n{\n\t/*\n\t * Because we want to be able to build the test as a module, we need to\n\t * iterate through all known tracepoints, since the static registration\n\t * won't work here.\n\t */\n\tfor_each_kernel_tracepoint(register_tracepoints, NULL);\n\treturn __kunit_test_suites_init(kcsan_test_suites);\n}"
  },
  {
    "function_name": "unregister_tracepoints",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/kcsan_test.c",
    "lines": "1584-1589",
    "snippet": "__no_kcsan\nstatic void unregister_tracepoints(struct tracepoint *tp, void *ignore)\n{\n\tif (!strcmp(tp->name, \"console\"))\n\t\ttracepoint_probe_unregister(tp, probe_console, NULL);\n}",
    "includes": [
      "#include <trace/events/printk.h>",
      "#include <linux/types.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/torture.h>",
      "#include <linux/timer.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kcsan-checks.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <kunit/test.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline const struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tracepoint_probe_unregister",
          "args": [
            "tp",
            "probe_console",
            "NULL"
          ],
          "line": 1588
        },
        "resolved": true,
        "details": {
          "function_name": "tracepoint_probe_unregister",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/tracepoint.c",
          "lines": "543-554",
          "snippet": "int tracepoint_probe_unregister(struct tracepoint *tp, void *probe, void *data)\n{\n\tstruct tracepoint_func tp_func;\n\tint ret;\n\n\tmutex_lock(&tracepoints_mutex);\n\ttp_func.func = probe;\n\ttp_func.data = data;\n\tret = tracepoint_remove_func(tp, &tp_func);\n\tmutex_unlock(&tracepoints_mutex);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/static_key.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list.h>",
            "#include <linux/jhash.h>",
            "#include <linux/types.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(tracepoints_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/static_key.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/tracepoint.h>\n#include <linux/rcupdate.h>\n#include <linux/list.h>\n#include <linux/jhash.h>\n#include <linux/types.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nstatic DEFINE_MUTEX(tracepoints_mutex);\n\nint tracepoint_probe_unregister(struct tracepoint *tp, void *probe, void *data)\n{\n\tstruct tracepoint_func tp_func;\n\tint ret;\n\n\tmutex_lock(&tracepoints_mutex);\n\ttp_func.func = probe;\n\ttp_func.data = data;\n\tret = tracepoint_remove_func(tp, &tp_func);\n\tmutex_unlock(&tracepoints_mutex);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "tp->name",
            "\"console\""
          ],
          "line": 1587
        },
        "resolved": true,
        "details": {
          "function_name": "sym_strcmp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/report.c",
          "lines": "356-365",
          "snippet": "static int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}",
          "includes": [
            "#include \"encoding.h\"",
            "#include \"kcsan.h\"",
            "#include <linux/stacktrace.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/delay.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"encoding.h\"\n#include \"kcsan.h\"\n#include <linux/stacktrace.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/lockdep.h>\n#include <linux/kernel.h>\n#include <linux/kallsyms.h>\n#include <linux/jiffies.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n\nstatic int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/printk.h>\n#include <linux/types.h>\n#include <linux/tracepoint.h>\n#include <linux/torture.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/seqlock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/kcsan-checks.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <kunit/test.h>\n\nstatic __always_inline const struct;\n\n__no_kcsan\nstatic void unregister_tracepoints(struct tracepoint *tp, void *ignore)\n{\n\tif (!strcmp(tp->name, \"console\"))\n\t\ttracepoint_probe_unregister(tp, probe_console, NULL);\n}"
  },
  {
    "function_name": "register_tracepoints",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/kcsan_test.c",
    "lines": "1576-1582",
    "snippet": "__no_kcsan\nstatic void register_tracepoints(struct tracepoint *tp, void *ignore)\n{\n\tcheck_trace_callback_type_console(probe_console);\n\tif (!strcmp(tp->name, \"console\"))\n\t\tWARN_ON(tracepoint_probe_register(tp, probe_console, NULL));\n}",
    "includes": [
      "#include <trace/events/printk.h>",
      "#include <linux/types.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/torture.h>",
      "#include <linux/timer.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kcsan-checks.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <kunit/test.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline const struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "tracepoint_probe_register(tp, probe_console, NULL)"
          ],
          "line": 1581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tracepoint_probe_register",
          "args": [
            "tp",
            "probe_console",
            "NULL"
          ],
          "line": 1581
        },
        "resolved": true,
        "details": {
          "function_name": "tracepoint_probe_register",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/tracepoint.c",
          "lines": "529-532",
          "snippet": "int tracepoint_probe_register(struct tracepoint *tp, void *probe, void *data)\n{\n\treturn tracepoint_probe_register_prio(tp, probe, data, TRACEPOINT_DEFAULT_PRIO);\n}",
          "includes": [
            "#include <linux/static_key.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list.h>",
            "#include <linux/jhash.h>",
            "#include <linux/types.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/static_key.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/tracepoint.h>\n#include <linux/rcupdate.h>\n#include <linux/list.h>\n#include <linux/jhash.h>\n#include <linux/types.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nint tracepoint_probe_register(struct tracepoint *tp, void *probe, void *data)\n{\n\treturn tracepoint_probe_register_prio(tp, probe, data, TRACEPOINT_DEFAULT_PRIO);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "tp->name",
            "\"console\""
          ],
          "line": 1580
        },
        "resolved": true,
        "details": {
          "function_name": "sym_strcmp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/report.c",
          "lines": "356-365",
          "snippet": "static int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}",
          "includes": [
            "#include \"encoding.h\"",
            "#include \"kcsan.h\"",
            "#include <linux/stacktrace.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/delay.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"encoding.h\"\n#include \"kcsan.h\"\n#include <linux/stacktrace.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/lockdep.h>\n#include <linux/kernel.h>\n#include <linux/kallsyms.h>\n#include <linux/jiffies.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n\nstatic int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_trace_callback_type_console",
          "args": [
            "probe_console"
          ],
          "line": 1579
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/printk.h>\n#include <linux/types.h>\n#include <linux/tracepoint.h>\n#include <linux/torture.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/seqlock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/kcsan-checks.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <kunit/test.h>\n\nstatic __always_inline const struct;\n\n__no_kcsan\nstatic void register_tracepoints(struct tracepoint *tp, void *ignore)\n{\n\tcheck_trace_callback_type_console(probe_console);\n\tif (!strcmp(tp->name, \"console\"))\n\t\tWARN_ON(tracepoint_probe_register(tp, probe_console, NULL));\n}"
  },
  {
    "function_name": "test_exit",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/kcsan_test.c",
    "lines": "1542-1566",
    "snippet": "__no_kcsan\nstatic void test_exit(struct kunit *test)\n{\n\tstruct task_struct **stop_thread;\n\tint i;\n\n\tif (strstr(test->name, \"nothreads\"))\n\t\treturn;\n\n\tif (torture_cleanup_begin())\n\t\treturn;\n\n\tfor (i = 0; i < ARRAY_SIZE(access_kernels); ++i)\n\t\tWRITE_ONCE(access_kernels[i], NULL);\n\n\tif (threads) {\n\t\tfor (stop_thread = threads; *stop_thread; stop_thread++)\n\t\t\ttorture_stop_kthread(reader_thread, *stop_thread);\n\n\t\tkfree(threads);\n\t\tthreads = NULL;\n\t}\n\n\ttorture_cleanup_end();\n}",
    "includes": [
      "#include <trace/events/printk.h>",
      "#include <linux/types.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/torture.h>",
      "#include <linux/timer.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kcsan-checks.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <kunit/test.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void (*access_kernels[2])(void);",
      "static struct task_struct **threads;",
      "static __always_inline const struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "torture_cleanup_end",
          "args": [],
          "line": 1565
        },
        "resolved": true,
        "details": {
          "function_name": "torture_cleanup_end",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/torture.c",
          "lines": "876-881",
          "snippet": "void torture_cleanup_end(void)\n{\n\tmutex_lock(&fullstop_mutex);\n\ttorture_type = NULL;\n\tmutex_unlock(&fullstop_mutex);\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char *torture_type;",
            "static DEFINE_MUTEX(fullstop_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic char *torture_type;\nstatic DEFINE_MUTEX(fullstop_mutex);\n\nvoid torture_cleanup_end(void)\n{\n\tmutex_lock(&fullstop_mutex);\n\ttorture_type = NULL;\n\tmutex_unlock(&fullstop_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "threads"
          ],
          "line": 1561
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "torture_stop_kthread",
          "args": [
            "reader_thread",
            "*stop_thread"
          ],
          "line": 1559
        },
        "resolved": true,
        "details": {
          "function_name": "_torture_stop_kthread",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/torture.c",
          "lines": "948-955",
          "snippet": "void _torture_stop_kthread(char *m, struct task_struct **tp)\n{\n\tif (*tp == NULL)\n\t\treturn;\n\tVERBOSE_TOROUT_STRING(m);\n\tkthread_stop(*tp);\n\t*tp = NULL;\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nvoid _torture_stop_kthread(char *m, struct task_struct **tp)\n{\n\tif (*tp == NULL)\n\t\treturn;\n\tVERBOSE_TOROUT_STRING(m);\n\tkthread_stop(*tp);\n\t*tp = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "access_kernels[i]",
            "NULL"
          ],
          "line": 1555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "access_kernels"
          ],
          "line": 1554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "torture_cleanup_begin",
          "args": [],
          "line": 1551
        },
        "resolved": true,
        "details": {
          "function_name": "torture_cleanup_begin",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/torture.c",
          "lines": "857-873",
          "snippet": "bool torture_cleanup_begin(void)\n{\n\tmutex_lock(&fullstop_mutex);\n\tif (READ_ONCE(fullstop) == FULLSTOP_SHUTDOWN) {\n\t\tpr_warn(\"Concurrent rmmod and shutdown illegal!\\n\");\n\t\tmutex_unlock(&fullstop_mutex);\n\t\tschedule_timeout_uninterruptible(10);\n\t\treturn true;\n\t}\n\tWRITE_ONCE(fullstop, FULLSTOP_RMMOD);\n\tmutex_unlock(&fullstop_mutex);\n\ttorture_shutdown_cleanup();\n\ttorture_shuffle_cleanup();\n\ttorture_stutter_cleanup();\n\ttorture_onoff_cleanup();\n\treturn false;\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define FULLSTOP_RMMOD    2\t/* Normal rmmod of torture. */",
            "#define FULLSTOP_SHUTDOWN 1\t/* System shutdown with torture running. */"
          ],
          "globals_used": [
            "static int fullstop = FULLSTOP_RMMOD;",
            "static DEFINE_MUTEX(fullstop_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define FULLSTOP_RMMOD    2\t/* Normal rmmod of torture. */\n#define FULLSTOP_SHUTDOWN 1\t/* System shutdown with torture running. */\n\nstatic int fullstop = FULLSTOP_RMMOD;\nstatic DEFINE_MUTEX(fullstop_mutex);\n\nbool torture_cleanup_begin(void)\n{\n\tmutex_lock(&fullstop_mutex);\n\tif (READ_ONCE(fullstop) == FULLSTOP_SHUTDOWN) {\n\t\tpr_warn(\"Concurrent rmmod and shutdown illegal!\\n\");\n\t\tmutex_unlock(&fullstop_mutex);\n\t\tschedule_timeout_uninterruptible(10);\n\t\treturn true;\n\t}\n\tWRITE_ONCE(fullstop, FULLSTOP_RMMOD);\n\tmutex_unlock(&fullstop_mutex);\n\ttorture_shutdown_cleanup();\n\ttorture_shuffle_cleanup();\n\ttorture_stutter_cleanup();\n\ttorture_onoff_cleanup();\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "test->name",
            "\"nothreads\""
          ],
          "line": 1548
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/printk.h>\n#include <linux/types.h>\n#include <linux/tracepoint.h>\n#include <linux/torture.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/seqlock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/kcsan-checks.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <kunit/test.h>\n\nstatic void (*access_kernels[2])(void);\nstatic struct task_struct **threads;\nstatic __always_inline const struct;\n\n__no_kcsan\nstatic void test_exit(struct kunit *test)\n{\n\tstruct task_struct **stop_thread;\n\tint i;\n\n\tif (strstr(test->name, \"nothreads\"))\n\t\treturn;\n\n\tif (torture_cleanup_begin())\n\t\treturn;\n\n\tfor (i = 0; i < ARRAY_SIZE(access_kernels); ++i)\n\t\tWRITE_ONCE(access_kernels[i], NULL);\n\n\tif (threads) {\n\t\tfor (stop_thread = threads; *stop_thread; stop_thread++)\n\t\t\ttorture_stop_kthread(reader_thread, *stop_thread);\n\n\t\tkfree(threads);\n\t\tthreads = NULL;\n\t}\n\n\ttorture_cleanup_end();\n}"
  },
  {
    "function_name": "test_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/kcsan_test.c",
    "lines": "1490-1540",
    "snippet": "__no_kcsan\nstatic int test_init(struct kunit *test)\n{\n\tunsigned long flags;\n\tint nthreads;\n\tint i;\n\n\tspin_lock_irqsave(&observed.lock, flags);\n\tfor (i = 0; i < ARRAY_SIZE(observed.lines); ++i)\n\t\tobserved.lines[i][0] = '\\0';\n\tobserved.nlines = 0;\n\tspin_unlock_irqrestore(&observed.lock, flags);\n\n\tif (strstr(test->name, \"nothreads\"))\n\t\treturn 0;\n\n\tif (!torture_init_begin((char *)test->name, 1))\n\t\treturn -EBUSY;\n\n\tif (WARN_ON(threads))\n\t\tgoto err;\n\n\tfor (i = 0; i < ARRAY_SIZE(access_kernels); ++i) {\n\t\tif (WARN_ON(access_kernels[i]))\n\t\t\tgoto err;\n\t}\n\n\tnthreads = abs((long)test->param_value);\n\tif (WARN_ON(!nthreads))\n\t\tgoto err;\n\n\tthreads = kcalloc(nthreads + 1, sizeof(struct task_struct *), GFP_KERNEL);\n\tif (WARN_ON(!threads))\n\t\tgoto err;\n\n\tthreads[nthreads] = NULL;\n\tfor (i = 0; i < nthreads; ++i) {\n\t\tif (torture_create_kthread(access_thread, NULL, threads[i]))\n\t\t\tgoto err;\n\t}\n\n\ttorture_init_end();\n\n\treturn 0;\n\nerr:\n\tkfree(threads);\n\tthreads = NULL;\n\ttorture_init_end();\n\treturn -EINVAL;\n}",
    "includes": [
      "#include <trace/events/printk.h>",
      "#include <linux/types.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/torture.h>",
      "#include <linux/timer.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kcsan-checks.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <kunit/test.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void (*access_kernels[2])(void);",
      "static struct task_struct **threads;",
      "static struct {\n\tspinlock_t lock;\n\tint nlines;\n\tchar lines[3][512];\n} observed = {\n\t.lock = __SPIN_LOCK_UNLOCKED(observed.lock),\n};",
      "static __always_inline const struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "torture_init_end",
          "args": [],
          "line": 1538
        },
        "resolved": true,
        "details": {
          "function_name": "torture_init_end",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/torture.c",
          "lines": "835-839",
          "snippet": "void torture_init_end(void)\n{\n\tmutex_unlock(&fullstop_mutex);\n\tregister_reboot_notifier(&torture_shutdown_nb);\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(fullstop_mutex);",
            "static struct notifier_block torture_shutdown_nb = {\n\t.notifier_call = torture_shutdown_notify,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_MUTEX(fullstop_mutex);\nstatic struct notifier_block torture_shutdown_nb = {\n\t.notifier_call = torture_shutdown_notify,\n};\n\nvoid torture_init_end(void)\n{\n\tmutex_unlock(&fullstop_mutex);\n\tregister_reboot_notifier(&torture_shutdown_nb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "threads"
          ],
          "line": 1536
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "torture_create_kthread",
          "args": [
            "access_thread",
            "NULL",
            "threads[i]"
          ],
          "line": 1527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!threads"
          ],
          "line": 1522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kcalloc",
          "args": [
            "nthreads + 1",
            "sizeof(struct task_struct *)",
            "GFP_KERNEL"
          ],
          "line": 1521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!nthreads"
          ],
          "line": 1518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "abs",
          "args": [
            "(long)test->param_value"
          ],
          "line": 1517
        },
        "resolved": true,
        "details": {
          "function_name": "torture_shutdown_absorb",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/torture.c",
          "lines": "608-615",
          "snippet": "void torture_shutdown_absorb(const char *title)\n{\n\twhile (READ_ONCE(fullstop) == FULLSTOP_SHUTDOWN) {\n\t\tpr_notice(\"torture thread %s parking due to system shutdown\\n\",\n\t\t\t  title);\n\t\tschedule_timeout_uninterruptible(MAX_SCHEDULE_TIMEOUT);\n\t}\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define FULLSTOP_SHUTDOWN 1\t/* System shutdown with torture running. */"
          ],
          "globals_used": [
            "static int fullstop = FULLSTOP_RMMOD;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define FULLSTOP_SHUTDOWN 1\t/* System shutdown with torture running. */\n\nstatic int fullstop = FULLSTOP_RMMOD;\n\nvoid torture_shutdown_absorb(const char *title)\n{\n\twhile (READ_ONCE(fullstop) == FULLSTOP_SHUTDOWN) {\n\t\tpr_notice(\"torture thread %s parking due to system shutdown\\n\",\n\t\t\t  title);\n\t\tschedule_timeout_uninterruptible(MAX_SCHEDULE_TIMEOUT);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "access_kernels[i]"
          ],
          "line": 1513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "access_kernels"
          ],
          "line": 1512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "threads"
          ],
          "line": 1509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "torture_init_begin",
          "args": [
            "(char *)test->name",
            "1"
          ],
          "line": 1506
        },
        "resolved": true,
        "details": {
          "function_name": "torture_init_begin",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/torture.c",
          "lines": "815-829",
          "snippet": "bool torture_init_begin(char *ttype, int v)\n{\n\tmutex_lock(&fullstop_mutex);\n\tif (torture_type != NULL) {\n\t\tpr_alert(\"%s: Refusing %s init: %s running.\\n\",\n\t\t\t  __func__, ttype, torture_type);\n\t\tpr_alert(\"%s: One torture test at a time!\\n\", __func__);\n\t\tmutex_unlock(&fullstop_mutex);\n\t\treturn false;\n\t}\n\ttorture_type = ttype;\n\tverbose = v;\n\tfullstop = FULLSTOP_DONTSTOP;\n\treturn true;\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define FULLSTOP_DONTSTOP 0\t/* Normal operation. */"
          ],
          "globals_used": [
            "static char *torture_type;",
            "static int verbose;",
            "static int fullstop = FULLSTOP_RMMOD;",
            "static DEFINE_MUTEX(fullstop_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define FULLSTOP_DONTSTOP 0\t/* Normal operation. */\n\nstatic char *torture_type;\nstatic int verbose;\nstatic int fullstop = FULLSTOP_RMMOD;\nstatic DEFINE_MUTEX(fullstop_mutex);\n\nbool torture_init_begin(char *ttype, int v)\n{\n\tmutex_lock(&fullstop_mutex);\n\tif (torture_type != NULL) {\n\t\tpr_alert(\"%s: Refusing %s init: %s running.\\n\",\n\t\t\t  __func__, ttype, torture_type);\n\t\tpr_alert(\"%s: One torture test at a time!\\n\", __func__);\n\t\tmutex_unlock(&fullstop_mutex);\n\t\treturn false;\n\t}\n\ttorture_type = ttype;\n\tverbose = v;\n\tfullstop = FULLSTOP_DONTSTOP;\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "test->name",
            "\"nothreads\""
          ],
          "line": 1503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&observed.lock",
            "flags"
          ],
          "line": 1501
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "192-195",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "observed.lines"
          ],
          "line": 1498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&observed.lock",
            "flags"
          ],
          "line": 1497
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "383-393",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/printk.h>\n#include <linux/types.h>\n#include <linux/tracepoint.h>\n#include <linux/torture.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/seqlock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/kcsan-checks.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <kunit/test.h>\n\nstatic void (*access_kernels[2])(void);\nstatic struct task_struct **threads;\nstatic struct {\n\tspinlock_t lock;\n\tint nlines;\n\tchar lines[3][512];\n} observed = {\n\t.lock = __SPIN_LOCK_UNLOCKED(observed.lock),\n};\nstatic __always_inline const struct;\n\n__no_kcsan\nstatic int test_init(struct kunit *test)\n{\n\tunsigned long flags;\n\tint nthreads;\n\tint i;\n\n\tspin_lock_irqsave(&observed.lock, flags);\n\tfor (i = 0; i < ARRAY_SIZE(observed.lines); ++i)\n\t\tobserved.lines[i][0] = '\\0';\n\tobserved.nlines = 0;\n\tspin_unlock_irqrestore(&observed.lock, flags);\n\n\tif (strstr(test->name, \"nothreads\"))\n\t\treturn 0;\n\n\tif (!torture_init_begin((char *)test->name, 1))\n\t\treturn -EBUSY;\n\n\tif (WARN_ON(threads))\n\t\tgoto err;\n\n\tfor (i = 0; i < ARRAY_SIZE(access_kernels); ++i) {\n\t\tif (WARN_ON(access_kernels[i]))\n\t\t\tgoto err;\n\t}\n\n\tnthreads = abs((long)test->param_value);\n\tif (WARN_ON(!nthreads))\n\t\tgoto err;\n\n\tthreads = kcalloc(nthreads + 1, sizeof(struct task_struct *), GFP_KERNEL);\n\tif (WARN_ON(!threads))\n\t\tgoto err;\n\n\tthreads[nthreads] = NULL;\n\tfor (i = 0; i < nthreads; ++i) {\n\t\tif (torture_create_kthread(access_thread, NULL, threads[i]))\n\t\t\tgoto err;\n\t}\n\n\ttorture_init_end();\n\n\treturn 0;\n\nerr:\n\tkfree(threads);\n\tthreads = NULL;\n\ttorture_init_end();\n\treturn -EINVAL;\n}"
  },
  {
    "function_name": "access_thread",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/kcsan_test.c",
    "lines": "1460-1488",
    "snippet": "__no_kcsan\nstatic int access_thread(void *arg)\n{\n\tstruct timer_list timer;\n\tunsigned int cnt = 0;\n\tunsigned int idx;\n\tvoid (*func)(void);\n\n\ttimer_setup_on_stack(&timer, access_thread_timer, 0);\n\tdo {\n\t\tmight_sleep();\n\n\t\tif (!timer_pending(&timer))\n\t\t\tmod_timer(&timer, jiffies + 1);\n\t\telse {\n\t\t\t/* Iterate through all kernels. */\n\t\t\tidx = cnt++ % ARRAY_SIZE(access_kernels);\n\t\t\t/* Acquire potential initialization. */\n\t\t\tfunc = smp_load_acquire(&access_kernels[idx]);\n\t\t\tif (func)\n\t\t\t\tfunc();\n\t\t}\n\t} while (!torture_must_stop());\n\tdel_timer_sync(&timer);\n\tdestroy_timer_on_stack(&timer);\n\n\ttorture_kthread_stopping(\"access_thread\");\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/printk.h>",
      "#include <linux/types.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/torture.h>",
      "#include <linux/timer.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kcsan-checks.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <kunit/test.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void (*access_kernels[2])(void);",
      "static __always_inline const struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "torture_kthread_stopping",
          "args": [
            "\"access_thread\""
          ],
          "line": 1486
        },
        "resolved": true,
        "details": {
          "function_name": "torture_kthread_stopping",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/torture.c",
          "lines": "910-920",
          "snippet": "void torture_kthread_stopping(char *title)\n{\n\tchar buf[128];\n\n\tsnprintf(buf, sizeof(buf), \"Stopping %s\", title);\n\tVERBOSE_TOROUT_STRING(buf);\n\twhile (!kthread_should_stop()) {\n\t\ttorture_shutdown_absorb(title);\n\t\tschedule_timeout_uninterruptible(1);\n\t}\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nvoid torture_kthread_stopping(char *title)\n{\n\tchar buf[128];\n\n\tsnprintf(buf, sizeof(buf), \"Stopping %s\", title);\n\tVERBOSE_TOROUT_STRING(buf);\n\twhile (!kthread_should_stop()) {\n\t\ttorture_shutdown_absorb(title);\n\t\tschedule_timeout_uninterruptible(1);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "destroy_timer_on_stack",
          "args": [
            "&timer"
          ],
          "line": 1484
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_timer_on_stack",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timer.c",
          "lines": "757-760",
          "snippet": "void destroy_timer_on_stack(struct timer_list *timer)\n{\n\tdebug_object_free(timer, &timer_debug_descr);\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/random.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/random.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nvoid destroy_timer_on_stack(struct timer_list *timer)\n{\n\tdebug_object_free(timer, &timer_debug_descr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "del_timer_sync",
          "args": [
            "&timer"
          ],
          "line": 1483
        },
        "resolved": true,
        "details": {
          "function_name": "del_timer_sync",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timer.c",
          "lines": "1352-1391",
          "snippet": "int del_timer_sync(struct timer_list *timer)\n{\n\tint ret;\n\n#ifdef CONFIG_LOCKDEP\n\tunsigned long flags;\n\n\t/*\n\t * If lockdep gives a backtrace here, please reference\n\t * the synchronization rules above.\n\t */\n\tlocal_irq_save(flags);\n\tlock_map_acquire(&timer->lockdep_map);\n\tlock_map_release(&timer->lockdep_map);\n\tlocal_irq_restore(flags);\n#endif\n\t/*\n\t * don't use it in hardirq context, because it\n\t * could lead to deadlock.\n\t */\n\tWARN_ON(in_irq() && !(timer->flags & TIMER_IRQSAFE));\n\n\t/*\n\t * Must be able to sleep on PREEMPT_RT because of the slowpath in\n\t * del_timer_wait_running().\n\t */\n\tif (IS_ENABLED(CONFIG_PREEMPT_RT) && !(timer->flags & TIMER_IRQSAFE))\n\t\tlockdep_assert_preemption_enabled();\n\n\tdo {\n\t\tret = try_to_del_timer_sync(timer);\n\n\t\tif (unlikely(ret < 0)) {\n\t\t\tdel_timer_wait_running(timer);\n\t\t\tcpu_relax();\n\t\t}\n\t} while (ret < 0);\n\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/random.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/random.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nint del_timer_sync(struct timer_list *timer)\n{\n\tint ret;\n\n#ifdef CONFIG_LOCKDEP\n\tunsigned long flags;\n\n\t/*\n\t * If lockdep gives a backtrace here, please reference\n\t * the synchronization rules above.\n\t */\n\tlocal_irq_save(flags);\n\tlock_map_acquire(&timer->lockdep_map);\n\tlock_map_release(&timer->lockdep_map);\n\tlocal_irq_restore(flags);\n#endif\n\t/*\n\t * don't use it in hardirq context, because it\n\t * could lead to deadlock.\n\t */\n\tWARN_ON(in_irq() && !(timer->flags & TIMER_IRQSAFE));\n\n\t/*\n\t * Must be able to sleep on PREEMPT_RT because of the slowpath in\n\t * del_timer_wait_running().\n\t */\n\tif (IS_ENABLED(CONFIG_PREEMPT_RT) && !(timer->flags & TIMER_IRQSAFE))\n\t\tlockdep_assert_preemption_enabled();\n\n\tdo {\n\t\tret = try_to_del_timer_sync(timer);\n\n\t\tif (unlikely(ret < 0)) {\n\t\t\tdel_timer_wait_running(timer);\n\t\t\tcpu_relax();\n\t\t}\n\t} while (ret < 0);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "torture_must_stop",
          "args": [],
          "line": 1482
        },
        "resolved": true,
        "details": {
          "function_name": "torture_must_stop_irq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/torture.c",
          "lines": "897-900",
          "snippet": "bool torture_must_stop_irq(void)\n{\n\treturn READ_ONCE(fullstop) != FULLSTOP_DONTSTOP;\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define FULLSTOP_DONTSTOP 0\t/* Normal operation. */"
          ],
          "globals_used": [
            "static int fullstop = FULLSTOP_RMMOD;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define FULLSTOP_DONTSTOP 0\t/* Normal operation. */\n\nstatic int fullstop = FULLSTOP_RMMOD;\n\nbool torture_must_stop_irq(void)\n{\n\treturn READ_ONCE(fullstop) != FULLSTOP_DONTSTOP;\n}"
        }
      },
      {
        "call_info": {
          "callee": "func",
          "args": [],
          "line": 1480
        },
        "resolved": true,
        "details": {
          "function_name": "__tsan_func_exit",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/core.c",
          "lines": "1100-1126",
          "snippet": "noinline void __tsan_func_exit(void)\n{\n\tstruct kcsan_scoped_access *reorder_access;\n\n\tif (!IS_ENABLED(CONFIG_KCSAN_WEAK_MEMORY))\n\t\treturn;\n\n\treorder_access = get_reorder_access(get_ctx());\n\tif (!reorder_access)\n\t\tgoto out;\n\n\tif (get_kcsan_stack_depth() <= reorder_access->stack_depth) {\n\t\t/*\n\t\t * Access check to catch cases where write without a barrier\n\t\t * (supposed release) was last access in function: because\n\t\t * instrumentation is inserted before the real access, a data\n\t\t * race due to the write giving up a c-s would only be caught if\n\t\t * we do the conflicting access after.\n\t\t */\n\t\tcheck_access(reorder_access->ptr, reorder_access->size,\n\t\t\t     reorder_access->type, reorder_access->ip);\n\t\treorder_access->size = 0;\n\t\treorder_access->stack_depth = INT_MIN;\n\t}\nout:\n\tadd_kcsan_stack_depth(-1);\n}",
          "includes": [
            "#include \"permissive.h\"",
            "#include \"kcsan.h\"",
            "#include \"encoding.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/sched.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/bug.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct",
            "static __always_inline void\ncheck_access(const volatile void *ptr, size_t size, int type, unsigned long ip);",
            "static __always_inline struct",
            "void __tsan_read_range(void *ptr, size_t size);",
            "void __tsan_write_range(void *ptr, size_t size);",
            "void __tsan_func_exit(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"permissive.h\"\n#include \"kcsan.h\"\n#include \"encoding.h\"\n#include <linux/uaccess.h>\n#include <linux/sched.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/bug.h>\n#include <linux/atomic.h>\n\nstatic __always_inline struct;\nstatic __always_inline void\ncheck_access(const volatile void *ptr, size_t size, int type, unsigned long ip);\nstatic __always_inline struct;\nvoid __tsan_read_range(void *ptr, size_t size);\nvoid __tsan_write_range(void *ptr, size_t size);\nvoid __tsan_func_exit(void);\n\nnoinline void __tsan_func_exit(void)\n{\n\tstruct kcsan_scoped_access *reorder_access;\n\n\tif (!IS_ENABLED(CONFIG_KCSAN_WEAK_MEMORY))\n\t\treturn;\n\n\treorder_access = get_reorder_access(get_ctx());\n\tif (!reorder_access)\n\t\tgoto out;\n\n\tif (get_kcsan_stack_depth() <= reorder_access->stack_depth) {\n\t\t/*\n\t\t * Access check to catch cases where write without a barrier\n\t\t * (supposed release) was last access in function: because\n\t\t * instrumentation is inserted before the real access, a data\n\t\t * race due to the write giving up a c-s would only be caught if\n\t\t * we do the conflicting access after.\n\t\t */\n\t\tcheck_access(reorder_access->ptr, reorder_access->size,\n\t\t\t     reorder_access->type, reorder_access->ip);\n\t\treorder_access->size = 0;\n\t\treorder_access->stack_depth = INT_MIN;\n\t}\nout:\n\tadd_kcsan_stack_depth(-1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_load_acquire",
          "args": [
            "&access_kernels[idx]"
          ],
          "line": 1478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "access_kernels"
          ],
          "line": 1476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mod_timer",
          "args": [
            "&timer",
            "jiffies + 1"
          ],
          "line": 1473
        },
        "resolved": true,
        "details": {
          "function_name": "mod_timer",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timer.c",
          "lines": "1106-1109",
          "snippet": "int mod_timer(struct timer_list *timer, unsigned long expires)\n{\n\treturn __mod_timer(timer, expires, 0);\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/random.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/random.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nint mod_timer(struct timer_list *timer, unsigned long expires)\n{\n\treturn __mod_timer(timer, expires, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "timer_pending",
          "args": [
            "&timer"
          ],
          "line": 1472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "might_sleep",
          "args": [],
          "line": 1470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timer_setup_on_stack",
          "args": [
            "&timer",
            "access_thread_timer",
            "0"
          ],
          "line": 1468
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/printk.h>\n#include <linux/types.h>\n#include <linux/tracepoint.h>\n#include <linux/torture.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/seqlock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/kcsan-checks.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <kunit/test.h>\n\nstatic void (*access_kernels[2])(void);\nstatic __always_inline const struct;\n\n__no_kcsan\nstatic int access_thread(void *arg)\n{\n\tstruct timer_list timer;\n\tunsigned int cnt = 0;\n\tunsigned int idx;\n\tvoid (*func)(void);\n\n\ttimer_setup_on_stack(&timer, access_thread_timer, 0);\n\tdo {\n\t\tmight_sleep();\n\n\t\tif (!timer_pending(&timer))\n\t\t\tmod_timer(&timer, jiffies + 1);\n\t\telse {\n\t\t\t/* Iterate through all kernels. */\n\t\t\tidx = cnt++ % ARRAY_SIZE(access_kernels);\n\t\t\t/* Acquire potential initialization. */\n\t\t\tfunc = smp_load_acquire(&access_kernels[idx]);\n\t\t\tif (func)\n\t\t\t\tfunc();\n\t\t}\n\t} while (!torture_must_stop());\n\tdel_timer_sync(&timer);\n\tdestroy_timer_on_stack(&timer);\n\n\ttorture_kthread_stopping(\"access_thread\");\n\treturn 0;\n}"
  },
  {
    "function_name": "access_thread_timer",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/kcsan_test.c",
    "lines": "1445-1457",
    "snippet": "__no_kcsan\nstatic void access_thread_timer(struct timer_list *timer)\n{\n\tstatic atomic_t cnt = ATOMIC_INIT(0);\n\tunsigned int idx;\n\tvoid (*func)(void);\n\n\tidx = (unsigned int)atomic_inc_return(&cnt) % ARRAY_SIZE(access_kernels);\n\t/* Acquire potential initialization. */\n\tfunc = smp_load_acquire(&access_kernels[idx]);\n\tif (func)\n\t\tfunc();\n}",
    "includes": [
      "#include <trace/events/printk.h>",
      "#include <linux/types.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/torture.h>",
      "#include <linux/timer.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kcsan-checks.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <kunit/test.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void (*access_kernels[2])(void);",
      "static __always_inline const struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "func",
          "args": [],
          "line": 1456
        },
        "resolved": true,
        "details": {
          "function_name": "__tsan_func_exit",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/core.c",
          "lines": "1100-1126",
          "snippet": "noinline void __tsan_func_exit(void)\n{\n\tstruct kcsan_scoped_access *reorder_access;\n\n\tif (!IS_ENABLED(CONFIG_KCSAN_WEAK_MEMORY))\n\t\treturn;\n\n\treorder_access = get_reorder_access(get_ctx());\n\tif (!reorder_access)\n\t\tgoto out;\n\n\tif (get_kcsan_stack_depth() <= reorder_access->stack_depth) {\n\t\t/*\n\t\t * Access check to catch cases where write without a barrier\n\t\t * (supposed release) was last access in function: because\n\t\t * instrumentation is inserted before the real access, a data\n\t\t * race due to the write giving up a c-s would only be caught if\n\t\t * we do the conflicting access after.\n\t\t */\n\t\tcheck_access(reorder_access->ptr, reorder_access->size,\n\t\t\t     reorder_access->type, reorder_access->ip);\n\t\treorder_access->size = 0;\n\t\treorder_access->stack_depth = INT_MIN;\n\t}\nout:\n\tadd_kcsan_stack_depth(-1);\n}",
          "includes": [
            "#include \"permissive.h\"",
            "#include \"kcsan.h\"",
            "#include \"encoding.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/sched.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/bug.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct",
            "static __always_inline void\ncheck_access(const volatile void *ptr, size_t size, int type, unsigned long ip);",
            "static __always_inline struct",
            "void __tsan_read_range(void *ptr, size_t size);",
            "void __tsan_write_range(void *ptr, size_t size);",
            "void __tsan_func_exit(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"permissive.h\"\n#include \"kcsan.h\"\n#include \"encoding.h\"\n#include <linux/uaccess.h>\n#include <linux/sched.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/bug.h>\n#include <linux/atomic.h>\n\nstatic __always_inline struct;\nstatic __always_inline void\ncheck_access(const volatile void *ptr, size_t size, int type, unsigned long ip);\nstatic __always_inline struct;\nvoid __tsan_read_range(void *ptr, size_t size);\nvoid __tsan_write_range(void *ptr, size_t size);\nvoid __tsan_func_exit(void);\n\nnoinline void __tsan_func_exit(void)\n{\n\tstruct kcsan_scoped_access *reorder_access;\n\n\tif (!IS_ENABLED(CONFIG_KCSAN_WEAK_MEMORY))\n\t\treturn;\n\n\treorder_access = get_reorder_access(get_ctx());\n\tif (!reorder_access)\n\t\tgoto out;\n\n\tif (get_kcsan_stack_depth() <= reorder_access->stack_depth) {\n\t\t/*\n\t\t * Access check to catch cases where write without a barrier\n\t\t * (supposed release) was last access in function: because\n\t\t * instrumentation is inserted before the real access, a data\n\t\t * race due to the write giving up a c-s would only be caught if\n\t\t * we do the conflicting access after.\n\t\t */\n\t\tcheck_access(reorder_access->ptr, reorder_access->size,\n\t\t\t     reorder_access->type, reorder_access->ip);\n\t\treorder_access->size = 0;\n\t\treorder_access->stack_depth = INT_MIN;\n\t}\nout:\n\tadd_kcsan_stack_depth(-1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_load_acquire",
          "args": [
            "&access_kernels[idx]"
          ],
          "line": 1454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "access_kernels"
          ],
          "line": 1452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc_return",
          "args": [
            "&cnt"
          ],
          "line": 1452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ATOMIC_INIT",
          "args": [
            "0"
          ],
          "line": 1448
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/printk.h>\n#include <linux/types.h>\n#include <linux/tracepoint.h>\n#include <linux/torture.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/seqlock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/kcsan-checks.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <kunit/test.h>\n\nstatic void (*access_kernels[2])(void);\nstatic __always_inline const struct;\n\n__no_kcsan\nstatic void access_thread_timer(struct timer_list *timer)\n{\n\tstatic atomic_t cnt = ATOMIC_INIT(0);\n\tunsigned int idx;\n\tvoid (*func)(void);\n\n\tidx = (unsigned int)atomic_inc_return(&cnt) % ARRAY_SIZE(access_kernels);\n\t/* Acquire potential initialization. */\n\tfunc = smp_load_acquire(&access_kernels[idx]);\n\tif (func)\n\t\tfunc();\n}"
  },
  {
    "function_name": "nthreads_gen_params",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/kcsan_test.c",
    "lines": "1368-1406",
    "snippet": "static const void *nthreads_gen_params(const void *prev, char *desc)\n{\n\tlong nthreads = (long)prev;\n\n\tif (nthreads < 0 || nthreads >= 32)\n\t\tnthreads = 0; /* stop */\n\telse if (!nthreads)\n\t\tnthreads = 2; /* initial value */\n\telse if (nthreads < 5)\n\t\tnthreads++;\n\telse if (nthreads == 5)\n\t\tnthreads = 8;\n\telse\n\t\tnthreads *= 2;\n\n\tif (!IS_ENABLED(CONFIG_PREEMPT) || !IS_ENABLED(CONFIG_KCSAN_INTERRUPT_WATCHER)) {\n\t\t/*\n\t\t * Without any preemption, keep 2 CPUs free for other tasks, one\n\t\t * of which is the main test case function checking for\n\t\t * completion or failure.\n\t\t */\n\t\tconst long min_unused_cpus = IS_ENABLED(CONFIG_PREEMPT_NONE) ? 2 : 0;\n\t\tconst long min_required_cpus = 2 + min_unused_cpus;\n\n\t\tif (num_online_cpus() < min_required_cpus) {\n\t\t\tpr_err_once(\"Too few online CPUs (%u < %ld) for test\\n\",\n\t\t\t\t    num_online_cpus(), min_required_cpus);\n\t\t\tnthreads = 0;\n\t\t} else if (nthreads >= num_online_cpus() - min_unused_cpus) {\n\t\t\t/* Use negative value to indicate last param. */\n\t\t\tnthreads = -(num_online_cpus() - min_unused_cpus);\n\t\t\tpr_warn_once(\"Limiting number of threads to %ld (only %d online CPUs)\\n\",\n\t\t\t\t     -nthreads, num_online_cpus());\n\t\t}\n\t}\n\n\tsnprintf(desc, KUNIT_PARAM_DESC_SIZE, \"threads=%ld\", abs(nthreads));\n\treturn (void *)nthreads;\n}",
    "includes": [
      "#include <trace/events/printk.h>",
      "#include <linux/types.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/torture.h>",
      "#include <linux/timer.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kcsan-checks.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <kunit/test.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct task_struct **threads;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "desc",
            "KUNIT_PARAM_DESC_SIZE",
            "\"threads=%ld\"",
            "abs(nthreads)"
          ],
          "line": 1404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "abs",
          "args": [
            "nthreads"
          ],
          "line": 1404
        },
        "resolved": true,
        "details": {
          "function_name": "torture_shutdown_absorb",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/torture.c",
          "lines": "608-615",
          "snippet": "void torture_shutdown_absorb(const char *title)\n{\n\twhile (READ_ONCE(fullstop) == FULLSTOP_SHUTDOWN) {\n\t\tpr_notice(\"torture thread %s parking due to system shutdown\\n\",\n\t\t\t  title);\n\t\tschedule_timeout_uninterruptible(MAX_SCHEDULE_TIMEOUT);\n\t}\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define FULLSTOP_SHUTDOWN 1\t/* System shutdown with torture running. */"
          ],
          "globals_used": [
            "static int fullstop = FULLSTOP_RMMOD;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define FULLSTOP_SHUTDOWN 1\t/* System shutdown with torture running. */\n\nstatic int fullstop = FULLSTOP_RMMOD;\n\nvoid torture_shutdown_absorb(const char *title)\n{\n\twhile (READ_ONCE(fullstop) == FULLSTOP_SHUTDOWN) {\n\t\tpr_notice(\"torture thread %s parking due to system shutdown\\n\",\n\t\t\t  title);\n\t\tschedule_timeout_uninterruptible(MAX_SCHEDULE_TIMEOUT);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn_once",
          "args": [
            "\"Limiting number of threads to %ld (only %d online CPUs)\\n\"",
            "-nthreads",
            "num_online_cpus()"
          ],
          "line": 1399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "num_online_cpus",
          "args": [],
          "line": 1400
        },
        "resolved": true,
        "details": {
          "function_name": "torture_num_online_cpus",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/torture.c",
          "lines": "185-188",
          "snippet": "int torture_num_online_cpus(void)\n{\n\treturn READ_ONCE(torture_online_cpus);\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint torture_num_online_cpus(void)\n{\n\treturn READ_ONCE(torture_online_cpus);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err_once",
          "args": [
            "\"Too few online CPUs (%u < %ld) for test\\n\"",
            "num_online_cpus()",
            "min_required_cpus"
          ],
          "line": 1393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_PREEMPT_NONE"
          ],
          "line": 1389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_KCSAN_INTERRUPT_WATCHER"
          ],
          "line": 1383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_PREEMPT"
          ],
          "line": 1383
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/printk.h>\n#include <linux/types.h>\n#include <linux/tracepoint.h>\n#include <linux/torture.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/seqlock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/kcsan-checks.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <kunit/test.h>\n\nstatic struct task_struct **threads;\n\nstatic const void *nthreads_gen_params(const void *prev, char *desc)\n{\n\tlong nthreads = (long)prev;\n\n\tif (nthreads < 0 || nthreads >= 32)\n\t\tnthreads = 0; /* stop */\n\telse if (!nthreads)\n\t\tnthreads = 2; /* initial value */\n\telse if (nthreads < 5)\n\t\tnthreads++;\n\telse if (nthreads == 5)\n\t\tnthreads = 8;\n\telse\n\t\tnthreads *= 2;\n\n\tif (!IS_ENABLED(CONFIG_PREEMPT) || !IS_ENABLED(CONFIG_KCSAN_INTERRUPT_WATCHER)) {\n\t\t/*\n\t\t * Without any preemption, keep 2 CPUs free for other tasks, one\n\t\t * of which is the main test case function checking for\n\t\t * completion or failure.\n\t\t */\n\t\tconst long min_unused_cpus = IS_ENABLED(CONFIG_PREEMPT_NONE) ? 2 : 0;\n\t\tconst long min_required_cpus = 2 + min_unused_cpus;\n\n\t\tif (num_online_cpus() < min_required_cpus) {\n\t\t\tpr_err_once(\"Too few online CPUs (%u < %ld) for test\\n\",\n\t\t\t\t    num_online_cpus(), min_required_cpus);\n\t\t\tnthreads = 0;\n\t\t} else if (nthreads >= num_online_cpus() - min_unused_cpus) {\n\t\t\t/* Use negative value to indicate last param. */\n\t\t\tnthreads = -(num_online_cpus() - min_unused_cpus);\n\t\t\tpr_warn_once(\"Limiting number of threads to %ld (only %d online CPUs)\\n\",\n\t\t\t\t     -nthreads, num_online_cpus());\n\t\t}\n\t}\n\n\tsnprintf(desc, KUNIT_PARAM_DESC_SIZE, \"threads=%ld\", abs(nthreads));\n\treturn (void *)nthreads;\n}"
  },
  {
    "function_name": "test_atomic_builtins_missing_barrier",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/kcsan_test.c",
    "lines": "1338-1359",
    "snippet": "__no_kcsan\nstatic void test_atomic_builtins_missing_barrier(struct kunit *test)\n{\n\tstruct expect_report expect = {\n\t\t.access = {\n\t\t\t{ test_kernel_atomic_builtin_wrong_memorder, &test_var, sizeof(test_var), __KCSAN_ACCESS_RW(KCSAN_ACCESS_WRITE) },\n\t\t\t{ test_kernel_atomic_builtin_wrong_memorder, &test_var, sizeof(test_var), __KCSAN_ACCESS_RW(0) },\n\t\t},\n\t};\n\tbool match_expect = false;\n\n\ttest_struct.val[0] = 0; /* init unlocked */\n\tbegin_test_checks(test_kernel_atomic_builtin_wrong_memorder,\n\t\t\t  test_kernel_atomic_builtin_wrong_memorder);\n\tdo {\n\t\tmatch_expect = report_matches_any_reordered(&expect);\n\t} while (!end_test_checks(match_expect));\n\tif (IS_ENABLED(CONFIG_KCSAN_WEAK_MEMORY))\n\t\tKUNIT_EXPECT_TRUE(test, match_expect);\n\telse\n\t\tKUNIT_EXPECT_FALSE(test, match_expect);\n}",
    "includes": [
      "#include <trace/events/printk.h>",
      "#include <linux/types.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/torture.h>",
      "#include <linux/timer.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kcsan-checks.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <kunit/test.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline const struct",
      "static long test_var;",
      "static struct {\n\tlong val[8];\n} test_struct;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "KUNIT_EXPECT_FALSE",
          "args": [
            "test",
            "match_expect"
          ],
          "line": 1358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KUNIT_EXPECT_TRUE",
          "args": [
            "test",
            "match_expect"
          ],
          "line": 1356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_KCSAN_WEAK_MEMORY"
          ],
          "line": 1355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "end_test_checks",
          "args": [
            "match_expect"
          ],
          "line": 1354
        },
        "resolved": true,
        "details": {
          "function_name": "end_test_checks",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/kcsan_test.c",
          "lines": "79-90",
          "snippet": "static __no_kcsan inline bool\nend_test_checks(bool stop)\n{\n\tif (!stop && time_before(jiffies, end_time)) {\n\t\t/* Continue checking */\n\t\tmight_sleep();\n\t\treturn false;\n\t}\n\n\tkcsan_enable_current();\n\treturn true;\n}",
          "includes": [
            "#include <trace/events/printk.h>",
            "#include <linux/types.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/torture.h>",
            "#include <linux/timer.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kcsan-checks.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <kunit/test.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned long end_time;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/printk.h>\n#include <linux/types.h>\n#include <linux/tracepoint.h>\n#include <linux/torture.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/seqlock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/kcsan-checks.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <kunit/test.h>\n\nstatic unsigned long end_time;\n\nstatic __no_kcsan inline bool\nend_test_checks(bool stop)\n{\n\tif (!stop && time_before(jiffies, end_time)) {\n\t\t/* Continue checking */\n\t\tmight_sleep();\n\t\treturn false;\n\t}\n\n\tkcsan_enable_current();\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "report_matches_any_reordered",
          "args": [
            "&expect"
          ],
          "line": 1353
        },
        "resolved": true,
        "details": {
          "function_name": "report_matches_any_reordered",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/kcsan_test.c",
          "lines": "277-284",
          "snippet": "__no_kcsan\nstatic bool report_matches_any_reordered(struct expect_report *r)\n{\n\treturn __report_matches(__report_set_scoped(r, 0)) ||\n\t       __report_matches(__report_set_scoped(r, 1)) ||\n\t       __report_matches(__report_set_scoped(r, 2)) ||\n\t       __report_matches(__report_set_scoped(r, 3));\n}",
          "includes": [
            "#include <trace/events/printk.h>",
            "#include <linux/types.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/torture.h>",
            "#include <linux/timer.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kcsan-checks.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <kunit/test.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline const struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/printk.h>\n#include <linux/types.h>\n#include <linux/tracepoint.h>\n#include <linux/torture.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/seqlock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/kcsan-checks.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <kunit/test.h>\n\nstatic __always_inline const struct;\n\n__no_kcsan\nstatic bool report_matches_any_reordered(struct expect_report *r)\n{\n\treturn __report_matches(__report_set_scoped(r, 0)) ||\n\t       __report_matches(__report_set_scoped(r, 1)) ||\n\t       __report_matches(__report_set_scoped(r, 2)) ||\n\t       __report_matches(__report_set_scoped(r, 3));\n}"
        }
      },
      {
        "call_info": {
          "callee": "begin_test_checks",
          "args": [
            "test_kernel_atomic_builtin_wrong_memorder",
            "test_kernel_atomic_builtin_wrong_memorder"
          ],
          "line": 1350
        },
        "resolved": true,
        "details": {
          "function_name": "begin_test_checks",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/kcsan_test.c",
          "lines": "62-76",
          "snippet": "static __no_kcsan inline void\nbegin_test_checks(void (*func1)(void), void (*func2)(void))\n{\n\tkcsan_disable_current();\n\n\t/*\n\t * Require at least as long as KCSAN_REPORT_ONCE_IN_MS, to ensure at\n\t * least one race is reported.\n\t */\n\tend_time = jiffies + msecs_to_jiffies(CONFIG_KCSAN_REPORT_ONCE_IN_MS + 500);\n\n\t/* Signal start; release potential initialization of shared data. */\n\tsmp_store_release(&access_kernels[0], func1);\n\tsmp_store_release(&access_kernels[1], func2);\n}",
          "includes": [
            "#include <trace/events/printk.h>",
            "#include <linux/types.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/torture.h>",
            "#include <linux/timer.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kcsan-checks.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <kunit/test.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void (*access_kernels[2])(void);",
            "static unsigned long end_time;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/printk.h>\n#include <linux/types.h>\n#include <linux/tracepoint.h>\n#include <linux/torture.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/seqlock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/kcsan-checks.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <kunit/test.h>\n\nstatic void (*access_kernels[2])(void);\nstatic unsigned long end_time;\n\nstatic __no_kcsan inline void\nbegin_test_checks(void (*func1)(void), void (*func2)(void))\n{\n\tkcsan_disable_current();\n\n\t/*\n\t * Require at least as long as KCSAN_REPORT_ONCE_IN_MS, to ensure at\n\t * least one race is reported.\n\t */\n\tend_time = jiffies + msecs_to_jiffies(CONFIG_KCSAN_REPORT_ONCE_IN_MS + 500);\n\n\t/* Signal start; release potential initialization of shared data. */\n\tsmp_store_release(&access_kernels[0], func1);\n\tsmp_store_release(&access_kernels[1], func2);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__KCSAN_ACCESS_RW",
          "args": [
            "0"
          ],
          "line": 1344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__KCSAN_ACCESS_RW",
          "args": [
            "KCSAN_ACCESS_WRITE"
          ],
          "line": 1343
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/printk.h>\n#include <linux/types.h>\n#include <linux/tracepoint.h>\n#include <linux/torture.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/seqlock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/kcsan-checks.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <kunit/test.h>\n\nstatic __always_inline const struct;\nstatic long test_var;\nstatic struct {\n\tlong val[8];\n} test_struct;\n\n__no_kcsan\nstatic void test_atomic_builtins_missing_barrier(struct kunit *test)\n{\n\tstruct expect_report expect = {\n\t\t.access = {\n\t\t\t{ test_kernel_atomic_builtin_wrong_memorder, &test_var, sizeof(test_var), __KCSAN_ACCESS_RW(KCSAN_ACCESS_WRITE) },\n\t\t\t{ test_kernel_atomic_builtin_wrong_memorder, &test_var, sizeof(test_var), __KCSAN_ACCESS_RW(0) },\n\t\t},\n\t};\n\tbool match_expect = false;\n\n\ttest_struct.val[0] = 0; /* init unlocked */\n\tbegin_test_checks(test_kernel_atomic_builtin_wrong_memorder,\n\t\t\t  test_kernel_atomic_builtin_wrong_memorder);\n\tdo {\n\t\tmatch_expect = report_matches_any_reordered(&expect);\n\t} while (!end_test_checks(match_expect));\n\tif (IS_ENABLED(CONFIG_KCSAN_WEAK_MEMORY))\n\t\tKUNIT_EXPECT_TRUE(test, match_expect);\n\telse\n\t\tKUNIT_EXPECT_FALSE(test, match_expect);\n}"
  },
  {
    "function_name": "test_atomic_builtins_correct_barrier",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/kcsan_test.c",
    "lines": "1318-1336",
    "snippet": "__no_kcsan\nstatic void test_atomic_builtins_correct_barrier(struct kunit *test)\n{\n\tstruct expect_report expect = {\n\t\t.access = {\n\t\t\t{ test_kernel_atomic_builtin_with_memorder, &test_var, sizeof(test_var), __KCSAN_ACCESS_RW(KCSAN_ACCESS_WRITE) },\n\t\t\t{ test_kernel_atomic_builtin_with_memorder, &test_var, sizeof(test_var), __KCSAN_ACCESS_RW(0) },\n\t\t},\n\t};\n\tbool match_expect = false;\n\n\ttest_struct.val[0] = 0; /* init unlocked */\n\tbegin_test_checks(test_kernel_atomic_builtin_with_memorder,\n\t\t\t  test_kernel_atomic_builtin_with_memorder);\n\tdo {\n\t\tmatch_expect = report_matches_any_reordered(&expect);\n\t} while (!end_test_checks(match_expect));\n\tKUNIT_EXPECT_FALSE(test, match_expect);\n}",
    "includes": [
      "#include <trace/events/printk.h>",
      "#include <linux/types.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/torture.h>",
      "#include <linux/timer.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kcsan-checks.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <kunit/test.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline const struct",
      "static long test_var;",
      "static struct {\n\tlong val[8];\n} test_struct;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "KUNIT_EXPECT_FALSE",
          "args": [
            "test",
            "match_expect"
          ],
          "line": 1335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "end_test_checks",
          "args": [
            "match_expect"
          ],
          "line": 1334
        },
        "resolved": true,
        "details": {
          "function_name": "end_test_checks",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/kcsan_test.c",
          "lines": "79-90",
          "snippet": "static __no_kcsan inline bool\nend_test_checks(bool stop)\n{\n\tif (!stop && time_before(jiffies, end_time)) {\n\t\t/* Continue checking */\n\t\tmight_sleep();\n\t\treturn false;\n\t}\n\n\tkcsan_enable_current();\n\treturn true;\n}",
          "includes": [
            "#include <trace/events/printk.h>",
            "#include <linux/types.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/torture.h>",
            "#include <linux/timer.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kcsan-checks.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <kunit/test.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned long end_time;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/printk.h>\n#include <linux/types.h>\n#include <linux/tracepoint.h>\n#include <linux/torture.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/seqlock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/kcsan-checks.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <kunit/test.h>\n\nstatic unsigned long end_time;\n\nstatic __no_kcsan inline bool\nend_test_checks(bool stop)\n{\n\tif (!stop && time_before(jiffies, end_time)) {\n\t\t/* Continue checking */\n\t\tmight_sleep();\n\t\treturn false;\n\t}\n\n\tkcsan_enable_current();\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "report_matches_any_reordered",
          "args": [
            "&expect"
          ],
          "line": 1333
        },
        "resolved": true,
        "details": {
          "function_name": "report_matches_any_reordered",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/kcsan_test.c",
          "lines": "277-284",
          "snippet": "__no_kcsan\nstatic bool report_matches_any_reordered(struct expect_report *r)\n{\n\treturn __report_matches(__report_set_scoped(r, 0)) ||\n\t       __report_matches(__report_set_scoped(r, 1)) ||\n\t       __report_matches(__report_set_scoped(r, 2)) ||\n\t       __report_matches(__report_set_scoped(r, 3));\n}",
          "includes": [
            "#include <trace/events/printk.h>",
            "#include <linux/types.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/torture.h>",
            "#include <linux/timer.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kcsan-checks.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <kunit/test.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline const struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/printk.h>\n#include <linux/types.h>\n#include <linux/tracepoint.h>\n#include <linux/torture.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/seqlock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/kcsan-checks.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <kunit/test.h>\n\nstatic __always_inline const struct;\n\n__no_kcsan\nstatic bool report_matches_any_reordered(struct expect_report *r)\n{\n\treturn __report_matches(__report_set_scoped(r, 0)) ||\n\t       __report_matches(__report_set_scoped(r, 1)) ||\n\t       __report_matches(__report_set_scoped(r, 2)) ||\n\t       __report_matches(__report_set_scoped(r, 3));\n}"
        }
      },
      {
        "call_info": {
          "callee": "begin_test_checks",
          "args": [
            "test_kernel_atomic_builtin_with_memorder",
            "test_kernel_atomic_builtin_with_memorder"
          ],
          "line": 1330
        },
        "resolved": true,
        "details": {
          "function_name": "begin_test_checks",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/kcsan_test.c",
          "lines": "62-76",
          "snippet": "static __no_kcsan inline void\nbegin_test_checks(void (*func1)(void), void (*func2)(void))\n{\n\tkcsan_disable_current();\n\n\t/*\n\t * Require at least as long as KCSAN_REPORT_ONCE_IN_MS, to ensure at\n\t * least one race is reported.\n\t */\n\tend_time = jiffies + msecs_to_jiffies(CONFIG_KCSAN_REPORT_ONCE_IN_MS + 500);\n\n\t/* Signal start; release potential initialization of shared data. */\n\tsmp_store_release(&access_kernels[0], func1);\n\tsmp_store_release(&access_kernels[1], func2);\n}",
          "includes": [
            "#include <trace/events/printk.h>",
            "#include <linux/types.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/torture.h>",
            "#include <linux/timer.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kcsan-checks.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <kunit/test.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void (*access_kernels[2])(void);",
            "static unsigned long end_time;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/printk.h>\n#include <linux/types.h>\n#include <linux/tracepoint.h>\n#include <linux/torture.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/seqlock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/kcsan-checks.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <kunit/test.h>\n\nstatic void (*access_kernels[2])(void);\nstatic unsigned long end_time;\n\nstatic __no_kcsan inline void\nbegin_test_checks(void (*func1)(void), void (*func2)(void))\n{\n\tkcsan_disable_current();\n\n\t/*\n\t * Require at least as long as KCSAN_REPORT_ONCE_IN_MS, to ensure at\n\t * least one race is reported.\n\t */\n\tend_time = jiffies + msecs_to_jiffies(CONFIG_KCSAN_REPORT_ONCE_IN_MS + 500);\n\n\t/* Signal start; release potential initialization of shared data. */\n\tsmp_store_release(&access_kernels[0], func1);\n\tsmp_store_release(&access_kernels[1], func2);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__KCSAN_ACCESS_RW",
          "args": [
            "0"
          ],
          "line": 1324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__KCSAN_ACCESS_RW",
          "args": [
            "KCSAN_ACCESS_WRITE"
          ],
          "line": 1323
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/printk.h>\n#include <linux/types.h>\n#include <linux/tracepoint.h>\n#include <linux/torture.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/seqlock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/kcsan-checks.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <kunit/test.h>\n\nstatic __always_inline const struct;\nstatic long test_var;\nstatic struct {\n\tlong val[8];\n} test_struct;\n\n__no_kcsan\nstatic void test_atomic_builtins_correct_barrier(struct kunit *test)\n{\n\tstruct expect_report expect = {\n\t\t.access = {\n\t\t\t{ test_kernel_atomic_builtin_with_memorder, &test_var, sizeof(test_var), __KCSAN_ACCESS_RW(KCSAN_ACCESS_WRITE) },\n\t\t\t{ test_kernel_atomic_builtin_with_memorder, &test_var, sizeof(test_var), __KCSAN_ACCESS_RW(0) },\n\t\t},\n\t};\n\tbool match_expect = false;\n\n\ttest_struct.val[0] = 0; /* init unlocked */\n\tbegin_test_checks(test_kernel_atomic_builtin_with_memorder,\n\t\t\t  test_kernel_atomic_builtin_with_memorder);\n\tdo {\n\t\tmatch_expect = report_matches_any_reordered(&expect);\n\t} while (!end_test_checks(match_expect));\n\tKUNIT_EXPECT_FALSE(test, match_expect);\n}"
  },
  {
    "function_name": "test_missing_barrier",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/kcsan_test.c",
    "lines": "1296-1316",
    "snippet": "__no_kcsan\nstatic void test_missing_barrier(struct kunit *test)\n{\n\tstruct expect_report expect = {\n\t\t.access = {\n\t\t\t{ test_kernel_wrong_memorder, &test_var, sizeof(test_var), __KCSAN_ACCESS_RW(KCSAN_ACCESS_WRITE) },\n\t\t\t{ test_kernel_wrong_memorder, &test_var, sizeof(test_var), __KCSAN_ACCESS_RW(0) },\n\t\t},\n\t};\n\tbool match_expect = false;\n\n\ttest_struct.val[0] = 0; /* init unlocked */\n\tbegin_test_checks(test_kernel_wrong_memorder, test_kernel_wrong_memorder);\n\tdo {\n\t\tmatch_expect = report_matches_any_reordered(&expect);\n\t} while (!end_test_checks(match_expect));\n\tif (IS_ENABLED(CONFIG_KCSAN_WEAK_MEMORY))\n\t\tKUNIT_EXPECT_TRUE(test, match_expect);\n\telse\n\t\tKUNIT_EXPECT_FALSE(test, match_expect);\n}",
    "includes": [
      "#include <trace/events/printk.h>",
      "#include <linux/types.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/torture.h>",
      "#include <linux/timer.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kcsan-checks.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <kunit/test.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline const struct",
      "static long test_var;",
      "static struct {\n\tlong val[8];\n} test_struct;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "KUNIT_EXPECT_FALSE",
          "args": [
            "test",
            "match_expect"
          ],
          "line": 1315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KUNIT_EXPECT_TRUE",
          "args": [
            "test",
            "match_expect"
          ],
          "line": 1313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_KCSAN_WEAK_MEMORY"
          ],
          "line": 1312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "end_test_checks",
          "args": [
            "match_expect"
          ],
          "line": 1311
        },
        "resolved": true,
        "details": {
          "function_name": "end_test_checks",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/kcsan_test.c",
          "lines": "79-90",
          "snippet": "static __no_kcsan inline bool\nend_test_checks(bool stop)\n{\n\tif (!stop && time_before(jiffies, end_time)) {\n\t\t/* Continue checking */\n\t\tmight_sleep();\n\t\treturn false;\n\t}\n\n\tkcsan_enable_current();\n\treturn true;\n}",
          "includes": [
            "#include <trace/events/printk.h>",
            "#include <linux/types.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/torture.h>",
            "#include <linux/timer.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kcsan-checks.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <kunit/test.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned long end_time;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/printk.h>\n#include <linux/types.h>\n#include <linux/tracepoint.h>\n#include <linux/torture.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/seqlock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/kcsan-checks.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <kunit/test.h>\n\nstatic unsigned long end_time;\n\nstatic __no_kcsan inline bool\nend_test_checks(bool stop)\n{\n\tif (!stop && time_before(jiffies, end_time)) {\n\t\t/* Continue checking */\n\t\tmight_sleep();\n\t\treturn false;\n\t}\n\n\tkcsan_enable_current();\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "report_matches_any_reordered",
          "args": [
            "&expect"
          ],
          "line": 1310
        },
        "resolved": true,
        "details": {
          "function_name": "report_matches_any_reordered",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/kcsan_test.c",
          "lines": "277-284",
          "snippet": "__no_kcsan\nstatic bool report_matches_any_reordered(struct expect_report *r)\n{\n\treturn __report_matches(__report_set_scoped(r, 0)) ||\n\t       __report_matches(__report_set_scoped(r, 1)) ||\n\t       __report_matches(__report_set_scoped(r, 2)) ||\n\t       __report_matches(__report_set_scoped(r, 3));\n}",
          "includes": [
            "#include <trace/events/printk.h>",
            "#include <linux/types.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/torture.h>",
            "#include <linux/timer.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kcsan-checks.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <kunit/test.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline const struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/printk.h>\n#include <linux/types.h>\n#include <linux/tracepoint.h>\n#include <linux/torture.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/seqlock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/kcsan-checks.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <kunit/test.h>\n\nstatic __always_inline const struct;\n\n__no_kcsan\nstatic bool report_matches_any_reordered(struct expect_report *r)\n{\n\treturn __report_matches(__report_set_scoped(r, 0)) ||\n\t       __report_matches(__report_set_scoped(r, 1)) ||\n\t       __report_matches(__report_set_scoped(r, 2)) ||\n\t       __report_matches(__report_set_scoped(r, 3));\n}"
        }
      },
      {
        "call_info": {
          "callee": "begin_test_checks",
          "args": [
            "test_kernel_wrong_memorder",
            "test_kernel_wrong_memorder"
          ],
          "line": 1308
        },
        "resolved": true,
        "details": {
          "function_name": "begin_test_checks",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/kcsan_test.c",
          "lines": "62-76",
          "snippet": "static __no_kcsan inline void\nbegin_test_checks(void (*func1)(void), void (*func2)(void))\n{\n\tkcsan_disable_current();\n\n\t/*\n\t * Require at least as long as KCSAN_REPORT_ONCE_IN_MS, to ensure at\n\t * least one race is reported.\n\t */\n\tend_time = jiffies + msecs_to_jiffies(CONFIG_KCSAN_REPORT_ONCE_IN_MS + 500);\n\n\t/* Signal start; release potential initialization of shared data. */\n\tsmp_store_release(&access_kernels[0], func1);\n\tsmp_store_release(&access_kernels[1], func2);\n}",
          "includes": [
            "#include <trace/events/printk.h>",
            "#include <linux/types.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/torture.h>",
            "#include <linux/timer.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kcsan-checks.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <kunit/test.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void (*access_kernels[2])(void);",
            "static unsigned long end_time;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/printk.h>\n#include <linux/types.h>\n#include <linux/tracepoint.h>\n#include <linux/torture.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/seqlock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/kcsan-checks.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <kunit/test.h>\n\nstatic void (*access_kernels[2])(void);\nstatic unsigned long end_time;\n\nstatic __no_kcsan inline void\nbegin_test_checks(void (*func1)(void), void (*func2)(void))\n{\n\tkcsan_disable_current();\n\n\t/*\n\t * Require at least as long as KCSAN_REPORT_ONCE_IN_MS, to ensure at\n\t * least one race is reported.\n\t */\n\tend_time = jiffies + msecs_to_jiffies(CONFIG_KCSAN_REPORT_ONCE_IN_MS + 500);\n\n\t/* Signal start; release potential initialization of shared data. */\n\tsmp_store_release(&access_kernels[0], func1);\n\tsmp_store_release(&access_kernels[1], func2);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__KCSAN_ACCESS_RW",
          "args": [
            "0"
          ],
          "line": 1302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__KCSAN_ACCESS_RW",
          "args": [
            "KCSAN_ACCESS_WRITE"
          ],
          "line": 1301
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/printk.h>\n#include <linux/types.h>\n#include <linux/tracepoint.h>\n#include <linux/torture.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/seqlock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/kcsan-checks.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <kunit/test.h>\n\nstatic __always_inline const struct;\nstatic long test_var;\nstatic struct {\n\tlong val[8];\n} test_struct;\n\n__no_kcsan\nstatic void test_missing_barrier(struct kunit *test)\n{\n\tstruct expect_report expect = {\n\t\t.access = {\n\t\t\t{ test_kernel_wrong_memorder, &test_var, sizeof(test_var), __KCSAN_ACCESS_RW(KCSAN_ACCESS_WRITE) },\n\t\t\t{ test_kernel_wrong_memorder, &test_var, sizeof(test_var), __KCSAN_ACCESS_RW(0) },\n\t\t},\n\t};\n\tbool match_expect = false;\n\n\ttest_struct.val[0] = 0; /* init unlocked */\n\tbegin_test_checks(test_kernel_wrong_memorder, test_kernel_wrong_memorder);\n\tdo {\n\t\tmatch_expect = report_matches_any_reordered(&expect);\n\t} while (!end_test_checks(match_expect));\n\tif (IS_ENABLED(CONFIG_KCSAN_WEAK_MEMORY))\n\t\tKUNIT_EXPECT_TRUE(test, match_expect);\n\telse\n\t\tKUNIT_EXPECT_FALSE(test, match_expect);\n}"
  },
  {
    "function_name": "test_correct_barrier",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/kcsan_test.c",
    "lines": "1277-1294",
    "snippet": "__no_kcsan\nstatic void test_correct_barrier(struct kunit *test)\n{\n\tstruct expect_report expect = {\n\t\t.access = {\n\t\t\t{ test_kernel_with_memorder, &test_var, sizeof(test_var), __KCSAN_ACCESS_RW(KCSAN_ACCESS_WRITE) },\n\t\t\t{ test_kernel_with_memorder, &test_var, sizeof(test_var), __KCSAN_ACCESS_RW(0) },\n\t\t},\n\t};\n\tbool match_expect = false;\n\n\ttest_struct.val[0] = 0; /* init unlocked */\n\tbegin_test_checks(test_kernel_with_memorder, test_kernel_with_memorder);\n\tdo {\n\t\tmatch_expect = report_matches_any_reordered(&expect);\n\t} while (!end_test_checks(match_expect));\n\tKUNIT_EXPECT_FALSE(test, match_expect);\n}",
    "includes": [
      "#include <trace/events/printk.h>",
      "#include <linux/types.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/torture.h>",
      "#include <linux/timer.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kcsan-checks.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <kunit/test.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline const struct",
      "static long test_var;",
      "static struct {\n\tlong val[8];\n} test_struct;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "KUNIT_EXPECT_FALSE",
          "args": [
            "test",
            "match_expect"
          ],
          "line": 1293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "end_test_checks",
          "args": [
            "match_expect"
          ],
          "line": 1292
        },
        "resolved": true,
        "details": {
          "function_name": "end_test_checks",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/kcsan_test.c",
          "lines": "79-90",
          "snippet": "static __no_kcsan inline bool\nend_test_checks(bool stop)\n{\n\tif (!stop && time_before(jiffies, end_time)) {\n\t\t/* Continue checking */\n\t\tmight_sleep();\n\t\treturn false;\n\t}\n\n\tkcsan_enable_current();\n\treturn true;\n}",
          "includes": [
            "#include <trace/events/printk.h>",
            "#include <linux/types.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/torture.h>",
            "#include <linux/timer.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kcsan-checks.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <kunit/test.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned long end_time;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/printk.h>\n#include <linux/types.h>\n#include <linux/tracepoint.h>\n#include <linux/torture.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/seqlock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/kcsan-checks.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <kunit/test.h>\n\nstatic unsigned long end_time;\n\nstatic __no_kcsan inline bool\nend_test_checks(bool stop)\n{\n\tif (!stop && time_before(jiffies, end_time)) {\n\t\t/* Continue checking */\n\t\tmight_sleep();\n\t\treturn false;\n\t}\n\n\tkcsan_enable_current();\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "report_matches_any_reordered",
          "args": [
            "&expect"
          ],
          "line": 1291
        },
        "resolved": true,
        "details": {
          "function_name": "report_matches_any_reordered",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/kcsan_test.c",
          "lines": "277-284",
          "snippet": "__no_kcsan\nstatic bool report_matches_any_reordered(struct expect_report *r)\n{\n\treturn __report_matches(__report_set_scoped(r, 0)) ||\n\t       __report_matches(__report_set_scoped(r, 1)) ||\n\t       __report_matches(__report_set_scoped(r, 2)) ||\n\t       __report_matches(__report_set_scoped(r, 3));\n}",
          "includes": [
            "#include <trace/events/printk.h>",
            "#include <linux/types.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/torture.h>",
            "#include <linux/timer.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kcsan-checks.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <kunit/test.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline const struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/printk.h>\n#include <linux/types.h>\n#include <linux/tracepoint.h>\n#include <linux/torture.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/seqlock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/kcsan-checks.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <kunit/test.h>\n\nstatic __always_inline const struct;\n\n__no_kcsan\nstatic bool report_matches_any_reordered(struct expect_report *r)\n{\n\treturn __report_matches(__report_set_scoped(r, 0)) ||\n\t       __report_matches(__report_set_scoped(r, 1)) ||\n\t       __report_matches(__report_set_scoped(r, 2)) ||\n\t       __report_matches(__report_set_scoped(r, 3));\n}"
        }
      },
      {
        "call_info": {
          "callee": "begin_test_checks",
          "args": [
            "test_kernel_with_memorder",
            "test_kernel_with_memorder"
          ],
          "line": 1289
        },
        "resolved": true,
        "details": {
          "function_name": "begin_test_checks",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/kcsan_test.c",
          "lines": "62-76",
          "snippet": "static __no_kcsan inline void\nbegin_test_checks(void (*func1)(void), void (*func2)(void))\n{\n\tkcsan_disable_current();\n\n\t/*\n\t * Require at least as long as KCSAN_REPORT_ONCE_IN_MS, to ensure at\n\t * least one race is reported.\n\t */\n\tend_time = jiffies + msecs_to_jiffies(CONFIG_KCSAN_REPORT_ONCE_IN_MS + 500);\n\n\t/* Signal start; release potential initialization of shared data. */\n\tsmp_store_release(&access_kernels[0], func1);\n\tsmp_store_release(&access_kernels[1], func2);\n}",
          "includes": [
            "#include <trace/events/printk.h>",
            "#include <linux/types.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/torture.h>",
            "#include <linux/timer.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kcsan-checks.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <kunit/test.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void (*access_kernels[2])(void);",
            "static unsigned long end_time;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/printk.h>\n#include <linux/types.h>\n#include <linux/tracepoint.h>\n#include <linux/torture.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/seqlock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/kcsan-checks.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <kunit/test.h>\n\nstatic void (*access_kernels[2])(void);\nstatic unsigned long end_time;\n\nstatic __no_kcsan inline void\nbegin_test_checks(void (*func1)(void), void (*func2)(void))\n{\n\tkcsan_disable_current();\n\n\t/*\n\t * Require at least as long as KCSAN_REPORT_ONCE_IN_MS, to ensure at\n\t * least one race is reported.\n\t */\n\tend_time = jiffies + msecs_to_jiffies(CONFIG_KCSAN_REPORT_ONCE_IN_MS + 500);\n\n\t/* Signal start; release potential initialization of shared data. */\n\tsmp_store_release(&access_kernels[0], func1);\n\tsmp_store_release(&access_kernels[1], func2);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__KCSAN_ACCESS_RW",
          "args": [
            "0"
          ],
          "line": 1283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__KCSAN_ACCESS_RW",
          "args": [
            "KCSAN_ACCESS_WRITE"
          ],
          "line": 1282
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/printk.h>\n#include <linux/types.h>\n#include <linux/tracepoint.h>\n#include <linux/torture.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/seqlock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/kcsan-checks.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <kunit/test.h>\n\nstatic __always_inline const struct;\nstatic long test_var;\nstatic struct {\n\tlong val[8];\n} test_struct;\n\n__no_kcsan\nstatic void test_correct_barrier(struct kunit *test)\n{\n\tstruct expect_report expect = {\n\t\t.access = {\n\t\t\t{ test_kernel_with_memorder, &test_var, sizeof(test_var), __KCSAN_ACCESS_RW(KCSAN_ACCESS_WRITE) },\n\t\t\t{ test_kernel_with_memorder, &test_var, sizeof(test_var), __KCSAN_ACCESS_RW(0) },\n\t\t},\n\t};\n\tbool match_expect = false;\n\n\ttest_struct.val[0] = 0; /* init unlocked */\n\tbegin_test_checks(test_kernel_with_memorder, test_kernel_with_memorder);\n\tdo {\n\t\tmatch_expect = report_matches_any_reordered(&expect);\n\t} while (!end_test_checks(match_expect));\n\tKUNIT_EXPECT_FALSE(test, match_expect);\n}"
  },
  {
    "function_name": "test_1bit_value_change",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/kcsan_test.c",
    "lines": "1254-1275",
    "snippet": "__no_kcsan\nstatic void test_1bit_value_change(struct kunit *test)\n{\n\tstruct expect_report expect = {\n\t\t.access = {\n\t\t\t{ test_kernel_read, &test_var, sizeof(test_var), 0 },\n\t\t\t{ test_kernel_xor_1bit, &test_var, sizeof(test_var), __KCSAN_ACCESS_RW(KCSAN_ACCESS_WRITE) },\n\t\t},\n\t};\n\tbool match = false;\n\n\tbegin_test_checks(test_kernel_read, test_kernel_xor_1bit);\n\tdo {\n\t\tmatch = IS_ENABLED(CONFIG_KCSAN_PERMISSIVE)\n\t\t\t\t? report_available()\n\t\t\t\t: report_matches(&expect);\n\t} while (!end_test_checks(match));\n\tif (IS_ENABLED(CONFIG_KCSAN_PERMISSIVE))\n\t\tKUNIT_EXPECT_FALSE(test, match);\n\telse\n\t\tKUNIT_EXPECT_TRUE(test, match);\n}",
    "includes": [
      "#include <trace/events/printk.h>",
      "#include <linux/types.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/torture.h>",
      "#include <linux/timer.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kcsan-checks.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <kunit/test.h>"
    ],
    "macros_used": [
      "#define report_matches __report_matches",
      "#define report_matches report_matches_any_reordered"
    ],
    "globals_used": [
      "static __always_inline const struct",
      "static long test_var;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "KUNIT_EXPECT_TRUE",
          "args": [
            "test",
            "match"
          ],
          "line": 1274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KUNIT_EXPECT_FALSE",
          "args": [
            "test",
            "match"
          ],
          "line": 1272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_KCSAN_PERMISSIVE"
          ],
          "line": 1271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "end_test_checks",
          "args": [
            "match"
          ],
          "line": 1270
        },
        "resolved": true,
        "details": {
          "function_name": "end_test_checks",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/kcsan_test.c",
          "lines": "79-90",
          "snippet": "static __no_kcsan inline bool\nend_test_checks(bool stop)\n{\n\tif (!stop && time_before(jiffies, end_time)) {\n\t\t/* Continue checking */\n\t\tmight_sleep();\n\t\treturn false;\n\t}\n\n\tkcsan_enable_current();\n\treturn true;\n}",
          "includes": [
            "#include <trace/events/printk.h>",
            "#include <linux/types.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/torture.h>",
            "#include <linux/timer.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kcsan-checks.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <kunit/test.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned long end_time;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/printk.h>\n#include <linux/types.h>\n#include <linux/tracepoint.h>\n#include <linux/torture.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/seqlock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/kcsan-checks.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <kunit/test.h>\n\nstatic unsigned long end_time;\n\nstatic __no_kcsan inline bool\nend_test_checks(bool stop)\n{\n\tif (!stop && time_before(jiffies, end_time)) {\n\t\t/* Continue checking */\n\t\tmight_sleep();\n\t\treturn false;\n\t}\n\n\tkcsan_enable_current();\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "report_matches",
          "args": [
            "&expect"
          ],
          "line": 1269
        },
        "resolved": true,
        "details": {
          "function_name": "report_matches_any_reordered",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/kcsan_test.c",
          "lines": "277-284",
          "snippet": "__no_kcsan\nstatic bool report_matches_any_reordered(struct expect_report *r)\n{\n\treturn __report_matches(__report_set_scoped(r, 0)) ||\n\t       __report_matches(__report_set_scoped(r, 1)) ||\n\t       __report_matches(__report_set_scoped(r, 2)) ||\n\t       __report_matches(__report_set_scoped(r, 3));\n}",
          "includes": [
            "#include <trace/events/printk.h>",
            "#include <linux/types.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/torture.h>",
            "#include <linux/timer.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kcsan-checks.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <kunit/test.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline const struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/printk.h>\n#include <linux/types.h>\n#include <linux/tracepoint.h>\n#include <linux/torture.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/seqlock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/kcsan-checks.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <kunit/test.h>\n\nstatic __always_inline const struct;\n\n__no_kcsan\nstatic bool report_matches_any_reordered(struct expect_report *r)\n{\n\treturn __report_matches(__report_set_scoped(r, 0)) ||\n\t       __report_matches(__report_set_scoped(r, 1)) ||\n\t       __report_matches(__report_set_scoped(r, 2)) ||\n\t       __report_matches(__report_set_scoped(r, 3));\n}"
        }
      },
      {
        "call_info": {
          "callee": "report_available",
          "args": [],
          "line": 1268
        },
        "resolved": true,
        "details": {
          "function_name": "report_available",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/kcsan_test.c",
          "lines": "138-142",
          "snippet": "__no_kcsan\nstatic bool report_available(void)\n{\n\treturn READ_ONCE(observed.nlines) == ARRAY_SIZE(observed.lines);\n}",
          "includes": [
            "#include <trace/events/printk.h>",
            "#include <linux/types.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/torture.h>",
            "#include <linux/timer.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kcsan-checks.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <kunit/test.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct {\n\tspinlock_t lock;\n\tint nlines;\n\tchar lines[3][512];\n} observed = {\n\t.lock = __SPIN_LOCK_UNLOCKED(observed.lock),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/printk.h>\n#include <linux/types.h>\n#include <linux/tracepoint.h>\n#include <linux/torture.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/seqlock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/kcsan-checks.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <kunit/test.h>\n\nstatic struct {\n\tspinlock_t lock;\n\tint nlines;\n\tchar lines[3][512];\n} observed = {\n\t.lock = __SPIN_LOCK_UNLOCKED(observed.lock),\n};\n\n__no_kcsan\nstatic bool report_available(void)\n{\n\treturn READ_ONCE(observed.nlines) == ARRAY_SIZE(observed.lines);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_KCSAN_PERMISSIVE"
          ],
          "line": 1267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "begin_test_checks",
          "args": [
            "test_kernel_read",
            "test_kernel_xor_1bit"
          ],
          "line": 1265
        },
        "resolved": true,
        "details": {
          "function_name": "begin_test_checks",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/kcsan_test.c",
          "lines": "62-76",
          "snippet": "static __no_kcsan inline void\nbegin_test_checks(void (*func1)(void), void (*func2)(void))\n{\n\tkcsan_disable_current();\n\n\t/*\n\t * Require at least as long as KCSAN_REPORT_ONCE_IN_MS, to ensure at\n\t * least one race is reported.\n\t */\n\tend_time = jiffies + msecs_to_jiffies(CONFIG_KCSAN_REPORT_ONCE_IN_MS + 500);\n\n\t/* Signal start; release potential initialization of shared data. */\n\tsmp_store_release(&access_kernels[0], func1);\n\tsmp_store_release(&access_kernels[1], func2);\n}",
          "includes": [
            "#include <trace/events/printk.h>",
            "#include <linux/types.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/torture.h>",
            "#include <linux/timer.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kcsan-checks.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <kunit/test.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void (*access_kernels[2])(void);",
            "static unsigned long end_time;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/printk.h>\n#include <linux/types.h>\n#include <linux/tracepoint.h>\n#include <linux/torture.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/seqlock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/kcsan-checks.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <kunit/test.h>\n\nstatic void (*access_kernels[2])(void);\nstatic unsigned long end_time;\n\nstatic __no_kcsan inline void\nbegin_test_checks(void (*func1)(void), void (*func2)(void))\n{\n\tkcsan_disable_current();\n\n\t/*\n\t * Require at least as long as KCSAN_REPORT_ONCE_IN_MS, to ensure at\n\t * least one race is reported.\n\t */\n\tend_time = jiffies + msecs_to_jiffies(CONFIG_KCSAN_REPORT_ONCE_IN_MS + 500);\n\n\t/* Signal start; release potential initialization of shared data. */\n\tsmp_store_release(&access_kernels[0], func1);\n\tsmp_store_release(&access_kernels[1], func2);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__KCSAN_ACCESS_RW",
          "args": [
            "KCSAN_ACCESS_WRITE"
          ],
          "line": 1260
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/printk.h>\n#include <linux/types.h>\n#include <linux/tracepoint.h>\n#include <linux/torture.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/seqlock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/kcsan-checks.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <kunit/test.h>\n\n#define report_matches __report_matches\n#define report_matches report_matches_any_reordered\n\nstatic __always_inline const struct;\nstatic long test_var;\n\n__no_kcsan\nstatic void test_1bit_value_change(struct kunit *test)\n{\n\tstruct expect_report expect = {\n\t\t.access = {\n\t\t\t{ test_kernel_read, &test_var, sizeof(test_var), 0 },\n\t\t\t{ test_kernel_xor_1bit, &test_var, sizeof(test_var), __KCSAN_ACCESS_RW(KCSAN_ACCESS_WRITE) },\n\t\t},\n\t};\n\tbool match = false;\n\n\tbegin_test_checks(test_kernel_read, test_kernel_xor_1bit);\n\tdo {\n\t\tmatch = IS_ENABLED(CONFIG_KCSAN_PERMISSIVE)\n\t\t\t\t? report_available()\n\t\t\t\t: report_matches(&expect);\n\t} while (!end_test_checks(match));\n\tif (IS_ENABLED(CONFIG_KCSAN_PERMISSIVE))\n\t\tKUNIT_EXPECT_FALSE(test, match);\n\telse\n\t\tKUNIT_EXPECT_TRUE(test, match);\n}"
  },
  {
    "function_name": "test_atomic_builtins",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/kcsan_test.c",
    "lines": "1208-1252",
    "snippet": "static void test_atomic_builtins(struct kunit *test)\n{\n\tbool match_never = false;\n\n\tbegin_test_checks(test_kernel_atomic_builtins, test_kernel_atomic_builtins);\n\tdo {\n\t\tlong tmp;\n\n\t\tkcsan_enable_current();\n\n\t\t__atomic_store_n(&test_var, 42L, __ATOMIC_RELAXED);\n\t\tKUNIT_EXPECT_EQ(test, 42L, __atomic_load_n(&test_var, __ATOMIC_RELAXED));\n\n\t\tKUNIT_EXPECT_EQ(test, 42L, __atomic_exchange_n(&test_var, 20, __ATOMIC_RELAXED));\n\t\tKUNIT_EXPECT_EQ(test, 20L, test_var);\n\n\t\ttmp = 20L;\n\t\tKUNIT_EXPECT_TRUE(test, __atomic_compare_exchange_n(&test_var, &tmp, 30L,\n\t\t\t\t\t\t\t\t    0, __ATOMIC_RELAXED,\n\t\t\t\t\t\t\t\t    __ATOMIC_RELAXED));\n\t\tKUNIT_EXPECT_EQ(test, tmp, 20L);\n\t\tKUNIT_EXPECT_EQ(test, test_var, 30L);\n\t\tKUNIT_EXPECT_FALSE(test, __atomic_compare_exchange_n(&test_var, &tmp, 40L,\n\t\t\t\t\t\t\t\t     1, __ATOMIC_RELAXED,\n\t\t\t\t\t\t\t\t     __ATOMIC_RELAXED));\n\t\tKUNIT_EXPECT_EQ(test, tmp, 30L);\n\t\tKUNIT_EXPECT_EQ(test, test_var, 30L);\n\n\t\tKUNIT_EXPECT_EQ(test, 30L, __atomic_fetch_add(&test_var, 1, __ATOMIC_RELAXED));\n\t\tKUNIT_EXPECT_EQ(test, 31L, __atomic_fetch_sub(&test_var, 1, __ATOMIC_RELAXED));\n\t\tKUNIT_EXPECT_EQ(test, 30L, __atomic_fetch_and(&test_var, 0xf, __ATOMIC_RELAXED));\n\t\tKUNIT_EXPECT_EQ(test, 14L, __atomic_fetch_xor(&test_var, 0xf, __ATOMIC_RELAXED));\n\t\tKUNIT_EXPECT_EQ(test, 1L, __atomic_fetch_or(&test_var, 0xf0, __ATOMIC_RELAXED));\n\t\tKUNIT_EXPECT_EQ(test, 241L, __atomic_fetch_nand(&test_var, 0xf, __ATOMIC_RELAXED));\n\t\tKUNIT_EXPECT_EQ(test, -2L, test_var);\n\n\t\t__atomic_thread_fence(__ATOMIC_SEQ_CST);\n\t\t__atomic_signal_fence(__ATOMIC_SEQ_CST);\n\n\t\tkcsan_disable_current();\n\n\t\tmatch_never = report_available();\n\t} while (!end_test_checks(match_never));\n\tKUNIT_EXPECT_FALSE(test, match_never);\n}",
    "includes": [
      "#include <trace/events/printk.h>",
      "#include <linux/types.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/torture.h>",
      "#include <linux/timer.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kcsan-checks.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <kunit/test.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline const struct",
      "static long test_var;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "KUNIT_EXPECT_FALSE",
          "args": [
            "test",
            "match_never"
          ],
          "line": 1251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "end_test_checks",
          "args": [
            "match_never"
          ],
          "line": 1250
        },
        "resolved": true,
        "details": {
          "function_name": "end_test_checks",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/kcsan_test.c",
          "lines": "79-90",
          "snippet": "static __no_kcsan inline bool\nend_test_checks(bool stop)\n{\n\tif (!stop && time_before(jiffies, end_time)) {\n\t\t/* Continue checking */\n\t\tmight_sleep();\n\t\treturn false;\n\t}\n\n\tkcsan_enable_current();\n\treturn true;\n}",
          "includes": [
            "#include <trace/events/printk.h>",
            "#include <linux/types.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/torture.h>",
            "#include <linux/timer.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kcsan-checks.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <kunit/test.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned long end_time;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/printk.h>\n#include <linux/types.h>\n#include <linux/tracepoint.h>\n#include <linux/torture.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/seqlock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/kcsan-checks.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <kunit/test.h>\n\nstatic unsigned long end_time;\n\nstatic __no_kcsan inline bool\nend_test_checks(bool stop)\n{\n\tif (!stop && time_before(jiffies, end_time)) {\n\t\t/* Continue checking */\n\t\tmight_sleep();\n\t\treturn false;\n\t}\n\n\tkcsan_enable_current();\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "report_available",
          "args": [],
          "line": 1249
        },
        "resolved": true,
        "details": {
          "function_name": "report_available",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/kcsan_test.c",
          "lines": "138-142",
          "snippet": "__no_kcsan\nstatic bool report_available(void)\n{\n\treturn READ_ONCE(observed.nlines) == ARRAY_SIZE(observed.lines);\n}",
          "includes": [
            "#include <trace/events/printk.h>",
            "#include <linux/types.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/torture.h>",
            "#include <linux/timer.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kcsan-checks.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <kunit/test.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct {\n\tspinlock_t lock;\n\tint nlines;\n\tchar lines[3][512];\n} observed = {\n\t.lock = __SPIN_LOCK_UNLOCKED(observed.lock),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/printk.h>\n#include <linux/types.h>\n#include <linux/tracepoint.h>\n#include <linux/torture.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/seqlock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/kcsan-checks.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <kunit/test.h>\n\nstatic struct {\n\tspinlock_t lock;\n\tint nlines;\n\tchar lines[3][512];\n} observed = {\n\t.lock = __SPIN_LOCK_UNLOCKED(observed.lock),\n};\n\n__no_kcsan\nstatic bool report_available(void)\n{\n\treturn READ_ONCE(observed.nlines) == ARRAY_SIZE(observed.lines);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kcsan_disable_current",
          "args": [],
          "line": 1247
        },
        "resolved": true,
        "details": {
          "function_name": "kcsan_disable_current",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/core.c",
          "lines": "813-816",
          "snippet": "void kcsan_disable_current(void)\n{\n\t++get_ctx()->disable_count;\n}",
          "includes": [
            "#include \"permissive.h\"",
            "#include \"kcsan.h\"",
            "#include \"encoding.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/sched.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/bug.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"permissive.h\"\n#include \"kcsan.h\"\n#include \"encoding.h\"\n#include <linux/uaccess.h>\n#include <linux/sched.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/bug.h>\n#include <linux/atomic.h>\n\nvoid kcsan_disable_current(void)\n{\n\t++get_ctx()->disable_count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__atomic_signal_fence",
          "args": [
            "__ATOMIC_SEQ_CST"
          ],
          "line": 1245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__atomic_thread_fence",
          "args": [
            "__ATOMIC_SEQ_CST"
          ],
          "line": 1244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KUNIT_EXPECT_EQ",
          "args": [
            "test",
            "-2L",
            "test_var"
          ],
          "line": 1242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KUNIT_EXPECT_EQ",
          "args": [
            "test",
            "241L",
            "__atomic_fetch_nand(&test_var, 0xf, __ATOMIC_RELAXED)"
          ],
          "line": 1241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__atomic_fetch_nand",
          "args": [
            "&test_var",
            "0xf",
            "__ATOMIC_RELAXED"
          ],
          "line": 1241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KUNIT_EXPECT_EQ",
          "args": [
            "test",
            "1L",
            "__atomic_fetch_or(&test_var, 0xf0, __ATOMIC_RELAXED)"
          ],
          "line": 1240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__atomic_fetch_or",
          "args": [
            "&test_var",
            "0xf0",
            "__ATOMIC_RELAXED"
          ],
          "line": 1240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KUNIT_EXPECT_EQ",
          "args": [
            "test",
            "14L",
            "__atomic_fetch_xor(&test_var, 0xf, __ATOMIC_RELAXED)"
          ],
          "line": 1239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__atomic_fetch_xor",
          "args": [
            "&test_var",
            "0xf",
            "__ATOMIC_RELAXED"
          ],
          "line": 1239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KUNIT_EXPECT_EQ",
          "args": [
            "test",
            "30L",
            "__atomic_fetch_and(&test_var, 0xf, __ATOMIC_RELAXED)"
          ],
          "line": 1238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__atomic_fetch_and",
          "args": [
            "&test_var",
            "0xf",
            "__ATOMIC_RELAXED"
          ],
          "line": 1238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KUNIT_EXPECT_EQ",
          "args": [
            "test",
            "31L",
            "__atomic_fetch_sub(&test_var, 1, __ATOMIC_RELAXED)"
          ],
          "line": 1237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__atomic_fetch_sub",
          "args": [
            "&test_var",
            "1",
            "__ATOMIC_RELAXED"
          ],
          "line": 1237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KUNIT_EXPECT_EQ",
          "args": [
            "test",
            "30L",
            "__atomic_fetch_add(&test_var, 1, __ATOMIC_RELAXED)"
          ],
          "line": 1236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__atomic_fetch_add",
          "args": [
            "&test_var",
            "1",
            "__ATOMIC_RELAXED"
          ],
          "line": 1236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KUNIT_EXPECT_EQ",
          "args": [
            "test",
            "test_var",
            "30L"
          ],
          "line": 1234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KUNIT_EXPECT_EQ",
          "args": [
            "test",
            "tmp",
            "30L"
          ],
          "line": 1233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KUNIT_EXPECT_FALSE",
          "args": [
            "test",
            "__atomic_compare_exchange_n(&test_var, &tmp, 40L,\n\t\t\t\t\t\t\t\t     1, __ATOMIC_RELAXED,\n\t\t\t\t\t\t\t\t     __ATOMIC_RELAXED)"
          ],
          "line": 1230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__atomic_compare_exchange_n",
          "args": [
            "&test_var",
            "&tmp",
            "40L",
            "1",
            "__ATOMIC_RELAXED",
            "__ATOMIC_RELAXED"
          ],
          "line": 1230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KUNIT_EXPECT_EQ",
          "args": [
            "test",
            "test_var",
            "30L"
          ],
          "line": 1229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KUNIT_EXPECT_EQ",
          "args": [
            "test",
            "tmp",
            "20L"
          ],
          "line": 1228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KUNIT_EXPECT_TRUE",
          "args": [
            "test",
            "__atomic_compare_exchange_n(&test_var, &tmp, 30L,\n\t\t\t\t\t\t\t\t    0, __ATOMIC_RELAXED,\n\t\t\t\t\t\t\t\t    __ATOMIC_RELAXED)"
          ],
          "line": 1225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__atomic_compare_exchange_n",
          "args": [
            "&test_var",
            "&tmp",
            "30L",
            "0",
            "__ATOMIC_RELAXED",
            "__ATOMIC_RELAXED"
          ],
          "line": 1225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KUNIT_EXPECT_EQ",
          "args": [
            "test",
            "20L",
            "test_var"
          ],
          "line": 1222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KUNIT_EXPECT_EQ",
          "args": [
            "test",
            "42L",
            "__atomic_exchange_n(&test_var, 20, __ATOMIC_RELAXED)"
          ],
          "line": 1221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__atomic_exchange_n",
          "args": [
            "&test_var",
            "20",
            "__ATOMIC_RELAXED"
          ],
          "line": 1221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KUNIT_EXPECT_EQ",
          "args": [
            "test",
            "42L",
            "__atomic_load_n(&test_var, __ATOMIC_RELAXED)"
          ],
          "line": 1219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__atomic_load_n",
          "args": [
            "&test_var",
            "__ATOMIC_RELAXED"
          ],
          "line": 1219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__atomic_store_n",
          "args": [
            "&test_var",
            "42L",
            "__ATOMIC_RELAXED"
          ],
          "line": 1218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kcsan_enable_current",
          "args": [],
          "line": 1216
        },
        "resolved": true,
        "details": {
          "function_name": "kcsan_enable_current_nowarn",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/core.c",
          "lines": "835-839",
          "snippet": "void kcsan_enable_current_nowarn(void)\n{\n\tif (get_ctx()->disable_count-- == 0)\n\t\tkcsan_disable_current();\n}",
          "includes": [
            "#include \"permissive.h\"",
            "#include \"kcsan.h\"",
            "#include \"encoding.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/sched.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/bug.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"permissive.h\"\n#include \"kcsan.h\"\n#include \"encoding.h\"\n#include <linux/uaccess.h>\n#include <linux/sched.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/bug.h>\n#include <linux/atomic.h>\n\nvoid kcsan_enable_current_nowarn(void)\n{\n\tif (get_ctx()->disable_count-- == 0)\n\t\tkcsan_disable_current();\n}"
        }
      },
      {
        "call_info": {
          "callee": "begin_test_checks",
          "args": [
            "test_kernel_atomic_builtins",
            "test_kernel_atomic_builtins"
          ],
          "line": 1212
        },
        "resolved": true,
        "details": {
          "function_name": "begin_test_checks",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/kcsan_test.c",
          "lines": "62-76",
          "snippet": "static __no_kcsan inline void\nbegin_test_checks(void (*func1)(void), void (*func2)(void))\n{\n\tkcsan_disable_current();\n\n\t/*\n\t * Require at least as long as KCSAN_REPORT_ONCE_IN_MS, to ensure at\n\t * least one race is reported.\n\t */\n\tend_time = jiffies + msecs_to_jiffies(CONFIG_KCSAN_REPORT_ONCE_IN_MS + 500);\n\n\t/* Signal start; release potential initialization of shared data. */\n\tsmp_store_release(&access_kernels[0], func1);\n\tsmp_store_release(&access_kernels[1], func2);\n}",
          "includes": [
            "#include <trace/events/printk.h>",
            "#include <linux/types.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/torture.h>",
            "#include <linux/timer.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kcsan-checks.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <kunit/test.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void (*access_kernels[2])(void);",
            "static unsigned long end_time;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/printk.h>\n#include <linux/types.h>\n#include <linux/tracepoint.h>\n#include <linux/torture.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/seqlock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/kcsan-checks.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <kunit/test.h>\n\nstatic void (*access_kernels[2])(void);\nstatic unsigned long end_time;\n\nstatic __no_kcsan inline void\nbegin_test_checks(void (*func1)(void), void (*func2)(void))\n{\n\tkcsan_disable_current();\n\n\t/*\n\t * Require at least as long as KCSAN_REPORT_ONCE_IN_MS, to ensure at\n\t * least one race is reported.\n\t */\n\tend_time = jiffies + msecs_to_jiffies(CONFIG_KCSAN_REPORT_ONCE_IN_MS + 500);\n\n\t/* Signal start; release potential initialization of shared data. */\n\tsmp_store_release(&access_kernels[0], func1);\n\tsmp_store_release(&access_kernels[1], func2);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/printk.h>\n#include <linux/types.h>\n#include <linux/tracepoint.h>\n#include <linux/torture.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/seqlock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/kcsan-checks.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <kunit/test.h>\n\nstatic __always_inline const struct;\nstatic long test_var;\n\nstatic void test_atomic_builtins(struct kunit *test)\n{\n\tbool match_never = false;\n\n\tbegin_test_checks(test_kernel_atomic_builtins, test_kernel_atomic_builtins);\n\tdo {\n\t\tlong tmp;\n\n\t\tkcsan_enable_current();\n\n\t\t__atomic_store_n(&test_var, 42L, __ATOMIC_RELAXED);\n\t\tKUNIT_EXPECT_EQ(test, 42L, __atomic_load_n(&test_var, __ATOMIC_RELAXED));\n\n\t\tKUNIT_EXPECT_EQ(test, 42L, __atomic_exchange_n(&test_var, 20, __ATOMIC_RELAXED));\n\t\tKUNIT_EXPECT_EQ(test, 20L, test_var);\n\n\t\ttmp = 20L;\n\t\tKUNIT_EXPECT_TRUE(test, __atomic_compare_exchange_n(&test_var, &tmp, 30L,\n\t\t\t\t\t\t\t\t    0, __ATOMIC_RELAXED,\n\t\t\t\t\t\t\t\t    __ATOMIC_RELAXED));\n\t\tKUNIT_EXPECT_EQ(test, tmp, 20L);\n\t\tKUNIT_EXPECT_EQ(test, test_var, 30L);\n\t\tKUNIT_EXPECT_FALSE(test, __atomic_compare_exchange_n(&test_var, &tmp, 40L,\n\t\t\t\t\t\t\t\t     1, __ATOMIC_RELAXED,\n\t\t\t\t\t\t\t\t     __ATOMIC_RELAXED));\n\t\tKUNIT_EXPECT_EQ(test, tmp, 30L);\n\t\tKUNIT_EXPECT_EQ(test, test_var, 30L);\n\n\t\tKUNIT_EXPECT_EQ(test, 30L, __atomic_fetch_add(&test_var, 1, __ATOMIC_RELAXED));\n\t\tKUNIT_EXPECT_EQ(test, 31L, __atomic_fetch_sub(&test_var, 1, __ATOMIC_RELAXED));\n\t\tKUNIT_EXPECT_EQ(test, 30L, __atomic_fetch_and(&test_var, 0xf, __ATOMIC_RELAXED));\n\t\tKUNIT_EXPECT_EQ(test, 14L, __atomic_fetch_xor(&test_var, 0xf, __ATOMIC_RELAXED));\n\t\tKUNIT_EXPECT_EQ(test, 1L, __atomic_fetch_or(&test_var, 0xf0, __ATOMIC_RELAXED));\n\t\tKUNIT_EXPECT_EQ(test, 241L, __atomic_fetch_nand(&test_var, 0xf, __ATOMIC_RELAXED));\n\t\tKUNIT_EXPECT_EQ(test, -2L, test_var);\n\n\t\t__atomic_thread_fence(__ATOMIC_SEQ_CST);\n\t\t__atomic_signal_fence(__ATOMIC_SEQ_CST);\n\n\t\tkcsan_disable_current();\n\n\t\tmatch_never = report_available();\n\t} while (!end_test_checks(match_never));\n\tKUNIT_EXPECT_FALSE(test, match_never);\n}"
  },
  {
    "function_name": "test_seqlock_noreport",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/kcsan_test.c",
    "lines": "1189-1199",
    "snippet": "__no_kcsan\nstatic void test_seqlock_noreport(struct kunit *test)\n{\n\tbool match_never = false;\n\n\tbegin_test_checks(test_kernel_seqlock_reader, test_kernel_seqlock_writer);\n\tdo {\n\t\tmatch_never = report_available();\n\t} while (!end_test_checks(match_never));\n\tKUNIT_EXPECT_FALSE(test, match_never);\n}",
    "includes": [
      "#include <trace/events/printk.h>",
      "#include <linux/types.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/torture.h>",
      "#include <linux/timer.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kcsan-checks.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <kunit/test.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline const struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "KUNIT_EXPECT_FALSE",
          "args": [
            "test",
            "match_never"
          ],
          "line": 1198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "end_test_checks",
          "args": [
            "match_never"
          ],
          "line": 1197
        },
        "resolved": true,
        "details": {
          "function_name": "end_test_checks",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/kcsan_test.c",
          "lines": "79-90",
          "snippet": "static __no_kcsan inline bool\nend_test_checks(bool stop)\n{\n\tif (!stop && time_before(jiffies, end_time)) {\n\t\t/* Continue checking */\n\t\tmight_sleep();\n\t\treturn false;\n\t}\n\n\tkcsan_enable_current();\n\treturn true;\n}",
          "includes": [
            "#include <trace/events/printk.h>",
            "#include <linux/types.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/torture.h>",
            "#include <linux/timer.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kcsan-checks.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <kunit/test.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned long end_time;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/printk.h>\n#include <linux/types.h>\n#include <linux/tracepoint.h>\n#include <linux/torture.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/seqlock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/kcsan-checks.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <kunit/test.h>\n\nstatic unsigned long end_time;\n\nstatic __no_kcsan inline bool\nend_test_checks(bool stop)\n{\n\tif (!stop && time_before(jiffies, end_time)) {\n\t\t/* Continue checking */\n\t\tmight_sleep();\n\t\treturn false;\n\t}\n\n\tkcsan_enable_current();\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "report_available",
          "args": [],
          "line": 1196
        },
        "resolved": true,
        "details": {
          "function_name": "report_available",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/kcsan_test.c",
          "lines": "138-142",
          "snippet": "__no_kcsan\nstatic bool report_available(void)\n{\n\treturn READ_ONCE(observed.nlines) == ARRAY_SIZE(observed.lines);\n}",
          "includes": [
            "#include <trace/events/printk.h>",
            "#include <linux/types.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/torture.h>",
            "#include <linux/timer.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kcsan-checks.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <kunit/test.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct {\n\tspinlock_t lock;\n\tint nlines;\n\tchar lines[3][512];\n} observed = {\n\t.lock = __SPIN_LOCK_UNLOCKED(observed.lock),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/printk.h>\n#include <linux/types.h>\n#include <linux/tracepoint.h>\n#include <linux/torture.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/seqlock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/kcsan-checks.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <kunit/test.h>\n\nstatic struct {\n\tspinlock_t lock;\n\tint nlines;\n\tchar lines[3][512];\n} observed = {\n\t.lock = __SPIN_LOCK_UNLOCKED(observed.lock),\n};\n\n__no_kcsan\nstatic bool report_available(void)\n{\n\treturn READ_ONCE(observed.nlines) == ARRAY_SIZE(observed.lines);\n}"
        }
      },
      {
        "call_info": {
          "callee": "begin_test_checks",
          "args": [
            "test_kernel_seqlock_reader",
            "test_kernel_seqlock_writer"
          ],
          "line": 1194
        },
        "resolved": true,
        "details": {
          "function_name": "begin_test_checks",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/kcsan_test.c",
          "lines": "62-76",
          "snippet": "static __no_kcsan inline void\nbegin_test_checks(void (*func1)(void), void (*func2)(void))\n{\n\tkcsan_disable_current();\n\n\t/*\n\t * Require at least as long as KCSAN_REPORT_ONCE_IN_MS, to ensure at\n\t * least one race is reported.\n\t */\n\tend_time = jiffies + msecs_to_jiffies(CONFIG_KCSAN_REPORT_ONCE_IN_MS + 500);\n\n\t/* Signal start; release potential initialization of shared data. */\n\tsmp_store_release(&access_kernels[0], func1);\n\tsmp_store_release(&access_kernels[1], func2);\n}",
          "includes": [
            "#include <trace/events/printk.h>",
            "#include <linux/types.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/torture.h>",
            "#include <linux/timer.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kcsan-checks.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <kunit/test.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void (*access_kernels[2])(void);",
            "static unsigned long end_time;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/printk.h>\n#include <linux/types.h>\n#include <linux/tracepoint.h>\n#include <linux/torture.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/seqlock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/kcsan-checks.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <kunit/test.h>\n\nstatic void (*access_kernels[2])(void);\nstatic unsigned long end_time;\n\nstatic __no_kcsan inline void\nbegin_test_checks(void (*func1)(void), void (*func2)(void))\n{\n\tkcsan_disable_current();\n\n\t/*\n\t * Require at least as long as KCSAN_REPORT_ONCE_IN_MS, to ensure at\n\t * least one race is reported.\n\t */\n\tend_time = jiffies + msecs_to_jiffies(CONFIG_KCSAN_REPORT_ONCE_IN_MS + 500);\n\n\t/* Signal start; release potential initialization of shared data. */\n\tsmp_store_release(&access_kernels[0], func1);\n\tsmp_store_release(&access_kernels[1], func2);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/printk.h>\n#include <linux/types.h>\n#include <linux/tracepoint.h>\n#include <linux/torture.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/seqlock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/kcsan-checks.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <kunit/test.h>\n\nstatic __always_inline const struct;\n\n__no_kcsan\nstatic void test_seqlock_noreport(struct kunit *test)\n{\n\tbool match_never = false;\n\n\tbegin_test_checks(test_kernel_seqlock_reader, test_kernel_seqlock_writer);\n\tdo {\n\t\tmatch_never = report_available();\n\t} while (!end_test_checks(match_never));\n\tKUNIT_EXPECT_FALSE(test, match_never);\n}"
  },
  {
    "function_name": "test_jiffies_noreport",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/kcsan_test.c",
    "lines": "1176-1186",
    "snippet": "__no_kcsan\nstatic void test_jiffies_noreport(struct kunit *test)\n{\n\tbool match_never = false;\n\n\tbegin_test_checks(test_kernel_jiffies_reader, test_kernel_jiffies_reader);\n\tdo {\n\t\tmatch_never = report_available();\n\t} while (!end_test_checks(match_never));\n\tKUNIT_EXPECT_FALSE(test, match_never);\n}",
    "includes": [
      "#include <trace/events/printk.h>",
      "#include <linux/types.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/torture.h>",
      "#include <linux/timer.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kcsan-checks.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <kunit/test.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline const struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "KUNIT_EXPECT_FALSE",
          "args": [
            "test",
            "match_never"
          ],
          "line": 1185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "end_test_checks",
          "args": [
            "match_never"
          ],
          "line": 1184
        },
        "resolved": true,
        "details": {
          "function_name": "end_test_checks",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/kcsan_test.c",
          "lines": "79-90",
          "snippet": "static __no_kcsan inline bool\nend_test_checks(bool stop)\n{\n\tif (!stop && time_before(jiffies, end_time)) {\n\t\t/* Continue checking */\n\t\tmight_sleep();\n\t\treturn false;\n\t}\n\n\tkcsan_enable_current();\n\treturn true;\n}",
          "includes": [
            "#include <trace/events/printk.h>",
            "#include <linux/types.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/torture.h>",
            "#include <linux/timer.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kcsan-checks.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <kunit/test.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned long end_time;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/printk.h>\n#include <linux/types.h>\n#include <linux/tracepoint.h>\n#include <linux/torture.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/seqlock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/kcsan-checks.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <kunit/test.h>\n\nstatic unsigned long end_time;\n\nstatic __no_kcsan inline bool\nend_test_checks(bool stop)\n{\n\tif (!stop && time_before(jiffies, end_time)) {\n\t\t/* Continue checking */\n\t\tmight_sleep();\n\t\treturn false;\n\t}\n\n\tkcsan_enable_current();\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "report_available",
          "args": [],
          "line": 1183
        },
        "resolved": true,
        "details": {
          "function_name": "report_available",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/kcsan_test.c",
          "lines": "138-142",
          "snippet": "__no_kcsan\nstatic bool report_available(void)\n{\n\treturn READ_ONCE(observed.nlines) == ARRAY_SIZE(observed.lines);\n}",
          "includes": [
            "#include <trace/events/printk.h>",
            "#include <linux/types.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/torture.h>",
            "#include <linux/timer.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kcsan-checks.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <kunit/test.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct {\n\tspinlock_t lock;\n\tint nlines;\n\tchar lines[3][512];\n} observed = {\n\t.lock = __SPIN_LOCK_UNLOCKED(observed.lock),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/printk.h>\n#include <linux/types.h>\n#include <linux/tracepoint.h>\n#include <linux/torture.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/seqlock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/kcsan-checks.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <kunit/test.h>\n\nstatic struct {\n\tspinlock_t lock;\n\tint nlines;\n\tchar lines[3][512];\n} observed = {\n\t.lock = __SPIN_LOCK_UNLOCKED(observed.lock),\n};\n\n__no_kcsan\nstatic bool report_available(void)\n{\n\treturn READ_ONCE(observed.nlines) == ARRAY_SIZE(observed.lines);\n}"
        }
      },
      {
        "call_info": {
          "callee": "begin_test_checks",
          "args": [
            "test_kernel_jiffies_reader",
            "test_kernel_jiffies_reader"
          ],
          "line": 1181
        },
        "resolved": true,
        "details": {
          "function_name": "begin_test_checks",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/kcsan_test.c",
          "lines": "62-76",
          "snippet": "static __no_kcsan inline void\nbegin_test_checks(void (*func1)(void), void (*func2)(void))\n{\n\tkcsan_disable_current();\n\n\t/*\n\t * Require at least as long as KCSAN_REPORT_ONCE_IN_MS, to ensure at\n\t * least one race is reported.\n\t */\n\tend_time = jiffies + msecs_to_jiffies(CONFIG_KCSAN_REPORT_ONCE_IN_MS + 500);\n\n\t/* Signal start; release potential initialization of shared data. */\n\tsmp_store_release(&access_kernels[0], func1);\n\tsmp_store_release(&access_kernels[1], func2);\n}",
          "includes": [
            "#include <trace/events/printk.h>",
            "#include <linux/types.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/torture.h>",
            "#include <linux/timer.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kcsan-checks.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <kunit/test.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void (*access_kernels[2])(void);",
            "static unsigned long end_time;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/printk.h>\n#include <linux/types.h>\n#include <linux/tracepoint.h>\n#include <linux/torture.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/seqlock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/kcsan-checks.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <kunit/test.h>\n\nstatic void (*access_kernels[2])(void);\nstatic unsigned long end_time;\n\nstatic __no_kcsan inline void\nbegin_test_checks(void (*func1)(void), void (*func2)(void))\n{\n\tkcsan_disable_current();\n\n\t/*\n\t * Require at least as long as KCSAN_REPORT_ONCE_IN_MS, to ensure at\n\t * least one race is reported.\n\t */\n\tend_time = jiffies + msecs_to_jiffies(CONFIG_KCSAN_REPORT_ONCE_IN_MS + 500);\n\n\t/* Signal start; release potential initialization of shared data. */\n\tsmp_store_release(&access_kernels[0], func1);\n\tsmp_store_release(&access_kernels[1], func2);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/printk.h>\n#include <linux/types.h>\n#include <linux/tracepoint.h>\n#include <linux/torture.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/seqlock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/kcsan-checks.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <kunit/test.h>\n\nstatic __always_inline const struct;\n\n__no_kcsan\nstatic void test_jiffies_noreport(struct kunit *test)\n{\n\tbool match_never = false;\n\n\tbegin_test_checks(test_kernel_jiffies_reader, test_kernel_jiffies_reader);\n\tdo {\n\t\tmatch_never = report_available();\n\t} while (!end_test_checks(match_never));\n\tKUNIT_EXPECT_FALSE(test, match_never);\n}"
  },
  {
    "function_name": "test_assert_exclusive_access_scoped",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/kcsan_test.c",
    "lines": "1140-1169",
    "snippet": "__no_kcsan\nstatic void test_assert_exclusive_access_scoped(struct kunit *test)\n{\n\tstruct expect_report expect_start1 = {\n\t\t.access = {\n\t\t\t{ test_kernel_assert_access_scoped, &test_var, sizeof(test_var), KCSAN_ACCESS_ASSERT | KCSAN_ACCESS_WRITE | KCSAN_ACCESS_SCOPED },\n\t\t\t{ test_kernel_read, &test_var, sizeof(test_var), 0 },\n\t\t},\n\t};\n\tstruct expect_report expect_start2 = {\n\t\t.access = { expect_start1.access[0], expect_start1.access[0] },\n\t};\n\tstruct expect_report expect_inscope = {\n\t\t.access = {\n\t\t\t{ test_enter_scope, &test_var, sizeof(test_var), KCSAN_ACCESS_ASSERT | KCSAN_ACCESS_WRITE | KCSAN_ACCESS_SCOPED },\n\t\t\t{ test_kernel_read, &test_var, sizeof(test_var), 0 },\n\t\t},\n\t};\n\tbool match_expect_start = false;\n\tbool match_expect_inscope = false;\n\n\tbegin_test_checks(test_kernel_assert_access_scoped, test_kernel_read);\n\tend_time += msecs_to_jiffies(1000); /* This test requires a bit more time. */\n\tdo {\n\t\tmatch_expect_start |= report_matches(&expect_start1) || report_matches(&expect_start2);\n\t\tmatch_expect_inscope |= report_matches(&expect_inscope);\n\t} while (!end_test_checks(match_expect_inscope));\n\tKUNIT_EXPECT_TRUE(test, match_expect_start);\n\tKUNIT_EXPECT_FALSE(test, match_expect_inscope);\n}",
    "includes": [
      "#include <trace/events/printk.h>",
      "#include <linux/types.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/torture.h>",
      "#include <linux/timer.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kcsan-checks.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <kunit/test.h>"
    ],
    "macros_used": [
      "#define report_matches __report_matches",
      "#define report_matches report_matches_any_reordered"
    ],
    "globals_used": [
      "static unsigned long end_time;",
      "static __always_inline const struct",
      "static long test_var;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "KUNIT_EXPECT_FALSE",
          "args": [
            "test",
            "match_expect_inscope"
          ],
          "line": 1168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KUNIT_EXPECT_TRUE",
          "args": [
            "test",
            "match_expect_start"
          ],
          "line": 1167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "end_test_checks",
          "args": [
            "match_expect_inscope"
          ],
          "line": 1166
        },
        "resolved": true,
        "details": {
          "function_name": "end_test_checks",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/kcsan_test.c",
          "lines": "79-90",
          "snippet": "static __no_kcsan inline bool\nend_test_checks(bool stop)\n{\n\tif (!stop && time_before(jiffies, end_time)) {\n\t\t/* Continue checking */\n\t\tmight_sleep();\n\t\treturn false;\n\t}\n\n\tkcsan_enable_current();\n\treturn true;\n}",
          "includes": [
            "#include <trace/events/printk.h>",
            "#include <linux/types.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/torture.h>",
            "#include <linux/timer.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kcsan-checks.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <kunit/test.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned long end_time;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/printk.h>\n#include <linux/types.h>\n#include <linux/tracepoint.h>\n#include <linux/torture.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/seqlock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/kcsan-checks.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <kunit/test.h>\n\nstatic unsigned long end_time;\n\nstatic __no_kcsan inline bool\nend_test_checks(bool stop)\n{\n\tif (!stop && time_before(jiffies, end_time)) {\n\t\t/* Continue checking */\n\t\tmight_sleep();\n\t\treturn false;\n\t}\n\n\tkcsan_enable_current();\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "report_matches",
          "args": [
            "&expect_inscope"
          ],
          "line": 1165
        },
        "resolved": true,
        "details": {
          "function_name": "report_matches_any_reordered",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/kcsan_test.c",
          "lines": "277-284",
          "snippet": "__no_kcsan\nstatic bool report_matches_any_reordered(struct expect_report *r)\n{\n\treturn __report_matches(__report_set_scoped(r, 0)) ||\n\t       __report_matches(__report_set_scoped(r, 1)) ||\n\t       __report_matches(__report_set_scoped(r, 2)) ||\n\t       __report_matches(__report_set_scoped(r, 3));\n}",
          "includes": [
            "#include <trace/events/printk.h>",
            "#include <linux/types.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/torture.h>",
            "#include <linux/timer.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kcsan-checks.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <kunit/test.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline const struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/printk.h>\n#include <linux/types.h>\n#include <linux/tracepoint.h>\n#include <linux/torture.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/seqlock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/kcsan-checks.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <kunit/test.h>\n\nstatic __always_inline const struct;\n\n__no_kcsan\nstatic bool report_matches_any_reordered(struct expect_report *r)\n{\n\treturn __report_matches(__report_set_scoped(r, 0)) ||\n\t       __report_matches(__report_set_scoped(r, 1)) ||\n\t       __report_matches(__report_set_scoped(r, 2)) ||\n\t       __report_matches(__report_set_scoped(r, 3));\n}"
        }
      },
      {
        "call_info": {
          "callee": "msecs_to_jiffies",
          "args": [
            "1000"
          ],
          "line": 1162
        },
        "resolved": true,
        "details": {
          "function_name": "__msecs_to_jiffies",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/time.c",
          "lines": "552-560",
          "snippet": "unsigned long __msecs_to_jiffies(const unsigned int m)\n{\n\t/*\n\t * Negative value, means infinite timeout:\n\t */\n\tif ((int)m < 0)\n\t\treturn MAX_JIFFY_OFFSET;\n\treturn _msecs_to_jiffies(m);\n}",
          "includes": [
            "#include \"timekeeping.h\"",
            "#include <generated/timeconst.h>",
            "#include <asm/unistd.h>",
            "#include <linux/compat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/math64.h>",
            "#include <linux/fs.h>",
            "#include <linux/security.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/errno.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/capability.h>",
            "#include <linux/timex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping.h\"\n#include <generated/timeconst.h>\n#include <asm/unistd.h>\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/math64.h>\n#include <linux/fs.h>\n#include <linux/security.h>\n#include <linux/syscalls.h>\n#include <linux/errno.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/capability.h>\n#include <linux/timex.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nunsigned long __msecs_to_jiffies(const unsigned int m)\n{\n\t/*\n\t * Negative value, means infinite timeout:\n\t */\n\tif ((int)m < 0)\n\t\treturn MAX_JIFFY_OFFSET;\n\treturn _msecs_to_jiffies(m);\n}"
        }
      },
      {
        "call_info": {
          "callee": "begin_test_checks",
          "args": [
            "test_kernel_assert_access_scoped",
            "test_kernel_read"
          ],
          "line": 1161
        },
        "resolved": true,
        "details": {
          "function_name": "begin_test_checks",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/kcsan_test.c",
          "lines": "62-76",
          "snippet": "static __no_kcsan inline void\nbegin_test_checks(void (*func1)(void), void (*func2)(void))\n{\n\tkcsan_disable_current();\n\n\t/*\n\t * Require at least as long as KCSAN_REPORT_ONCE_IN_MS, to ensure at\n\t * least one race is reported.\n\t */\n\tend_time = jiffies + msecs_to_jiffies(CONFIG_KCSAN_REPORT_ONCE_IN_MS + 500);\n\n\t/* Signal start; release potential initialization of shared data. */\n\tsmp_store_release(&access_kernels[0], func1);\n\tsmp_store_release(&access_kernels[1], func2);\n}",
          "includes": [
            "#include <trace/events/printk.h>",
            "#include <linux/types.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/torture.h>",
            "#include <linux/timer.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kcsan-checks.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <kunit/test.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void (*access_kernels[2])(void);",
            "static unsigned long end_time;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/printk.h>\n#include <linux/types.h>\n#include <linux/tracepoint.h>\n#include <linux/torture.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/seqlock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/kcsan-checks.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <kunit/test.h>\n\nstatic void (*access_kernels[2])(void);\nstatic unsigned long end_time;\n\nstatic __no_kcsan inline void\nbegin_test_checks(void (*func1)(void), void (*func2)(void))\n{\n\tkcsan_disable_current();\n\n\t/*\n\t * Require at least as long as KCSAN_REPORT_ONCE_IN_MS, to ensure at\n\t * least one race is reported.\n\t */\n\tend_time = jiffies + msecs_to_jiffies(CONFIG_KCSAN_REPORT_ONCE_IN_MS + 500);\n\n\t/* Signal start; release potential initialization of shared data. */\n\tsmp_store_release(&access_kernels[0], func1);\n\tsmp_store_release(&access_kernels[1], func2);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/printk.h>\n#include <linux/types.h>\n#include <linux/tracepoint.h>\n#include <linux/torture.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/seqlock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/kcsan-checks.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <kunit/test.h>\n\n#define report_matches __report_matches\n#define report_matches report_matches_any_reordered\n\nstatic unsigned long end_time;\nstatic __always_inline const struct;\nstatic long test_var;\n\n__no_kcsan\nstatic void test_assert_exclusive_access_scoped(struct kunit *test)\n{\n\tstruct expect_report expect_start1 = {\n\t\t.access = {\n\t\t\t{ test_kernel_assert_access_scoped, &test_var, sizeof(test_var), KCSAN_ACCESS_ASSERT | KCSAN_ACCESS_WRITE | KCSAN_ACCESS_SCOPED },\n\t\t\t{ test_kernel_read, &test_var, sizeof(test_var), 0 },\n\t\t},\n\t};\n\tstruct expect_report expect_start2 = {\n\t\t.access = { expect_start1.access[0], expect_start1.access[0] },\n\t};\n\tstruct expect_report expect_inscope = {\n\t\t.access = {\n\t\t\t{ test_enter_scope, &test_var, sizeof(test_var), KCSAN_ACCESS_ASSERT | KCSAN_ACCESS_WRITE | KCSAN_ACCESS_SCOPED },\n\t\t\t{ test_kernel_read, &test_var, sizeof(test_var), 0 },\n\t\t},\n\t};\n\tbool match_expect_start = false;\n\tbool match_expect_inscope = false;\n\n\tbegin_test_checks(test_kernel_assert_access_scoped, test_kernel_read);\n\tend_time += msecs_to_jiffies(1000); /* This test requires a bit more time. */\n\tdo {\n\t\tmatch_expect_start |= report_matches(&expect_start1) || report_matches(&expect_start2);\n\t\tmatch_expect_inscope |= report_matches(&expect_inscope);\n\t} while (!end_test_checks(match_expect_inscope));\n\tKUNIT_EXPECT_TRUE(test, match_expect_start);\n\tKUNIT_EXPECT_FALSE(test, match_expect_inscope);\n}"
  },
  {
    "function_name": "test_assert_exclusive_writer_scoped",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/kcsan_test.c",
    "lines": "1113-1138",
    "snippet": "__no_kcsan\nstatic void test_assert_exclusive_writer_scoped(struct kunit *test)\n{\n\tstruct expect_report expect_start = {\n\t\t.access = {\n\t\t\t{ test_kernel_assert_writer_scoped, &test_var, sizeof(test_var), KCSAN_ACCESS_ASSERT | KCSAN_ACCESS_SCOPED },\n\t\t\t{ test_kernel_write_nochange, &test_var, sizeof(test_var), KCSAN_ACCESS_WRITE },\n\t\t},\n\t};\n\tstruct expect_report expect_inscope = {\n\t\t.access = {\n\t\t\t{ test_enter_scope, &test_var, sizeof(test_var), KCSAN_ACCESS_ASSERT | KCSAN_ACCESS_SCOPED },\n\t\t\t{ test_kernel_write_nochange, &test_var, sizeof(test_var), KCSAN_ACCESS_WRITE },\n\t\t},\n\t};\n\tbool match_expect_start = false;\n\tbool match_expect_inscope = false;\n\n\tbegin_test_checks(test_kernel_assert_writer_scoped, test_kernel_write_nochange);\n\tdo {\n\t\tmatch_expect_start |= report_matches(&expect_start);\n\t\tmatch_expect_inscope |= report_matches(&expect_inscope);\n\t} while (!end_test_checks(match_expect_inscope));\n\tKUNIT_EXPECT_TRUE(test, match_expect_start);\n\tKUNIT_EXPECT_FALSE(test, match_expect_inscope);\n}",
    "includes": [
      "#include <trace/events/printk.h>",
      "#include <linux/types.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/torture.h>",
      "#include <linux/timer.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kcsan-checks.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <kunit/test.h>"
    ],
    "macros_used": [
      "#define report_matches __report_matches",
      "#define report_matches report_matches_any_reordered"
    ],
    "globals_used": [
      "static __always_inline const struct",
      "static long test_var;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "KUNIT_EXPECT_FALSE",
          "args": [
            "test",
            "match_expect_inscope"
          ],
          "line": 1137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KUNIT_EXPECT_TRUE",
          "args": [
            "test",
            "match_expect_start"
          ],
          "line": 1136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "end_test_checks",
          "args": [
            "match_expect_inscope"
          ],
          "line": 1135
        },
        "resolved": true,
        "details": {
          "function_name": "end_test_checks",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/kcsan_test.c",
          "lines": "79-90",
          "snippet": "static __no_kcsan inline bool\nend_test_checks(bool stop)\n{\n\tif (!stop && time_before(jiffies, end_time)) {\n\t\t/* Continue checking */\n\t\tmight_sleep();\n\t\treturn false;\n\t}\n\n\tkcsan_enable_current();\n\treturn true;\n}",
          "includes": [
            "#include <trace/events/printk.h>",
            "#include <linux/types.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/torture.h>",
            "#include <linux/timer.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kcsan-checks.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <kunit/test.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned long end_time;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/printk.h>\n#include <linux/types.h>\n#include <linux/tracepoint.h>\n#include <linux/torture.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/seqlock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/kcsan-checks.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <kunit/test.h>\n\nstatic unsigned long end_time;\n\nstatic __no_kcsan inline bool\nend_test_checks(bool stop)\n{\n\tif (!stop && time_before(jiffies, end_time)) {\n\t\t/* Continue checking */\n\t\tmight_sleep();\n\t\treturn false;\n\t}\n\n\tkcsan_enable_current();\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "report_matches",
          "args": [
            "&expect_inscope"
          ],
          "line": 1134
        },
        "resolved": true,
        "details": {
          "function_name": "report_matches_any_reordered",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/kcsan_test.c",
          "lines": "277-284",
          "snippet": "__no_kcsan\nstatic bool report_matches_any_reordered(struct expect_report *r)\n{\n\treturn __report_matches(__report_set_scoped(r, 0)) ||\n\t       __report_matches(__report_set_scoped(r, 1)) ||\n\t       __report_matches(__report_set_scoped(r, 2)) ||\n\t       __report_matches(__report_set_scoped(r, 3));\n}",
          "includes": [
            "#include <trace/events/printk.h>",
            "#include <linux/types.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/torture.h>",
            "#include <linux/timer.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kcsan-checks.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <kunit/test.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline const struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/printk.h>\n#include <linux/types.h>\n#include <linux/tracepoint.h>\n#include <linux/torture.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/seqlock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/kcsan-checks.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <kunit/test.h>\n\nstatic __always_inline const struct;\n\n__no_kcsan\nstatic bool report_matches_any_reordered(struct expect_report *r)\n{\n\treturn __report_matches(__report_set_scoped(r, 0)) ||\n\t       __report_matches(__report_set_scoped(r, 1)) ||\n\t       __report_matches(__report_set_scoped(r, 2)) ||\n\t       __report_matches(__report_set_scoped(r, 3));\n}"
        }
      },
      {
        "call_info": {
          "callee": "begin_test_checks",
          "args": [
            "test_kernel_assert_writer_scoped",
            "test_kernel_write_nochange"
          ],
          "line": 1131
        },
        "resolved": true,
        "details": {
          "function_name": "begin_test_checks",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/kcsan_test.c",
          "lines": "62-76",
          "snippet": "static __no_kcsan inline void\nbegin_test_checks(void (*func1)(void), void (*func2)(void))\n{\n\tkcsan_disable_current();\n\n\t/*\n\t * Require at least as long as KCSAN_REPORT_ONCE_IN_MS, to ensure at\n\t * least one race is reported.\n\t */\n\tend_time = jiffies + msecs_to_jiffies(CONFIG_KCSAN_REPORT_ONCE_IN_MS + 500);\n\n\t/* Signal start; release potential initialization of shared data. */\n\tsmp_store_release(&access_kernels[0], func1);\n\tsmp_store_release(&access_kernels[1], func2);\n}",
          "includes": [
            "#include <trace/events/printk.h>",
            "#include <linux/types.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/torture.h>",
            "#include <linux/timer.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kcsan-checks.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <kunit/test.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void (*access_kernels[2])(void);",
            "static unsigned long end_time;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/printk.h>\n#include <linux/types.h>\n#include <linux/tracepoint.h>\n#include <linux/torture.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/seqlock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/kcsan-checks.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <kunit/test.h>\n\nstatic void (*access_kernels[2])(void);\nstatic unsigned long end_time;\n\nstatic __no_kcsan inline void\nbegin_test_checks(void (*func1)(void), void (*func2)(void))\n{\n\tkcsan_disable_current();\n\n\t/*\n\t * Require at least as long as KCSAN_REPORT_ONCE_IN_MS, to ensure at\n\t * least one race is reported.\n\t */\n\tend_time = jiffies + msecs_to_jiffies(CONFIG_KCSAN_REPORT_ONCE_IN_MS + 500);\n\n\t/* Signal start; release potential initialization of shared data. */\n\tsmp_store_release(&access_kernels[0], func1);\n\tsmp_store_release(&access_kernels[1], func2);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/printk.h>\n#include <linux/types.h>\n#include <linux/tracepoint.h>\n#include <linux/torture.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/seqlock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/kcsan-checks.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <kunit/test.h>\n\n#define report_matches __report_matches\n#define report_matches report_matches_any_reordered\n\nstatic __always_inline const struct;\nstatic long test_var;\n\n__no_kcsan\nstatic void test_assert_exclusive_writer_scoped(struct kunit *test)\n{\n\tstruct expect_report expect_start = {\n\t\t.access = {\n\t\t\t{ test_kernel_assert_writer_scoped, &test_var, sizeof(test_var), KCSAN_ACCESS_ASSERT | KCSAN_ACCESS_SCOPED },\n\t\t\t{ test_kernel_write_nochange, &test_var, sizeof(test_var), KCSAN_ACCESS_WRITE },\n\t\t},\n\t};\n\tstruct expect_report expect_inscope = {\n\t\t.access = {\n\t\t\t{ test_enter_scope, &test_var, sizeof(test_var), KCSAN_ACCESS_ASSERT | KCSAN_ACCESS_SCOPED },\n\t\t\t{ test_kernel_write_nochange, &test_var, sizeof(test_var), KCSAN_ACCESS_WRITE },\n\t\t},\n\t};\n\tbool match_expect_start = false;\n\tbool match_expect_inscope = false;\n\n\tbegin_test_checks(test_kernel_assert_writer_scoped, test_kernel_write_nochange);\n\tdo {\n\t\tmatch_expect_start |= report_matches(&expect_start);\n\t\tmatch_expect_inscope |= report_matches(&expect_inscope);\n\t} while (!end_test_checks(match_expect_inscope));\n\tKUNIT_EXPECT_TRUE(test, match_expect_start);\n\tKUNIT_EXPECT_FALSE(test, match_expect_inscope);\n}"
  },
  {
    "function_name": "test_assert_exclusive_bits_nochange",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/kcsan_test.c",
    "lines": "1101-1111",
    "snippet": "__no_kcsan\nstatic void test_assert_exclusive_bits_nochange(struct kunit *test)\n{\n\tbool match_never = false;\n\n\tbegin_test_checks(test_kernel_assert_bits_nochange, test_kernel_change_bits);\n\tdo {\n\t\tmatch_never = report_available();\n\t} while (!end_test_checks(match_never));\n\tKUNIT_EXPECT_FALSE(test, match_never);\n}",
    "includes": [
      "#include <trace/events/printk.h>",
      "#include <linux/types.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/torture.h>",
      "#include <linux/timer.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kcsan-checks.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <kunit/test.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline const struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "KUNIT_EXPECT_FALSE",
          "args": [
            "test",
            "match_never"
          ],
          "line": 1110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "end_test_checks",
          "args": [
            "match_never"
          ],
          "line": 1109
        },
        "resolved": true,
        "details": {
          "function_name": "end_test_checks",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/kcsan_test.c",
          "lines": "79-90",
          "snippet": "static __no_kcsan inline bool\nend_test_checks(bool stop)\n{\n\tif (!stop && time_before(jiffies, end_time)) {\n\t\t/* Continue checking */\n\t\tmight_sleep();\n\t\treturn false;\n\t}\n\n\tkcsan_enable_current();\n\treturn true;\n}",
          "includes": [
            "#include <trace/events/printk.h>",
            "#include <linux/types.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/torture.h>",
            "#include <linux/timer.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kcsan-checks.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <kunit/test.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned long end_time;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/printk.h>\n#include <linux/types.h>\n#include <linux/tracepoint.h>\n#include <linux/torture.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/seqlock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/kcsan-checks.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <kunit/test.h>\n\nstatic unsigned long end_time;\n\nstatic __no_kcsan inline bool\nend_test_checks(bool stop)\n{\n\tif (!stop && time_before(jiffies, end_time)) {\n\t\t/* Continue checking */\n\t\tmight_sleep();\n\t\treturn false;\n\t}\n\n\tkcsan_enable_current();\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "report_available",
          "args": [],
          "line": 1108
        },
        "resolved": true,
        "details": {
          "function_name": "report_available",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/kcsan_test.c",
          "lines": "138-142",
          "snippet": "__no_kcsan\nstatic bool report_available(void)\n{\n\treturn READ_ONCE(observed.nlines) == ARRAY_SIZE(observed.lines);\n}",
          "includes": [
            "#include <trace/events/printk.h>",
            "#include <linux/types.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/torture.h>",
            "#include <linux/timer.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kcsan-checks.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <kunit/test.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct {\n\tspinlock_t lock;\n\tint nlines;\n\tchar lines[3][512];\n} observed = {\n\t.lock = __SPIN_LOCK_UNLOCKED(observed.lock),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/printk.h>\n#include <linux/types.h>\n#include <linux/tracepoint.h>\n#include <linux/torture.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/seqlock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/kcsan-checks.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <kunit/test.h>\n\nstatic struct {\n\tspinlock_t lock;\n\tint nlines;\n\tchar lines[3][512];\n} observed = {\n\t.lock = __SPIN_LOCK_UNLOCKED(observed.lock),\n};\n\n__no_kcsan\nstatic bool report_available(void)\n{\n\treturn READ_ONCE(observed.nlines) == ARRAY_SIZE(observed.lines);\n}"
        }
      },
      {
        "call_info": {
          "callee": "begin_test_checks",
          "args": [
            "test_kernel_assert_bits_nochange",
            "test_kernel_change_bits"
          ],
          "line": 1106
        },
        "resolved": true,
        "details": {
          "function_name": "begin_test_checks",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/kcsan_test.c",
          "lines": "62-76",
          "snippet": "static __no_kcsan inline void\nbegin_test_checks(void (*func1)(void), void (*func2)(void))\n{\n\tkcsan_disable_current();\n\n\t/*\n\t * Require at least as long as KCSAN_REPORT_ONCE_IN_MS, to ensure at\n\t * least one race is reported.\n\t */\n\tend_time = jiffies + msecs_to_jiffies(CONFIG_KCSAN_REPORT_ONCE_IN_MS + 500);\n\n\t/* Signal start; release potential initialization of shared data. */\n\tsmp_store_release(&access_kernels[0], func1);\n\tsmp_store_release(&access_kernels[1], func2);\n}",
          "includes": [
            "#include <trace/events/printk.h>",
            "#include <linux/types.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/torture.h>",
            "#include <linux/timer.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kcsan-checks.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <kunit/test.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void (*access_kernels[2])(void);",
            "static unsigned long end_time;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/printk.h>\n#include <linux/types.h>\n#include <linux/tracepoint.h>\n#include <linux/torture.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/seqlock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/kcsan-checks.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <kunit/test.h>\n\nstatic void (*access_kernels[2])(void);\nstatic unsigned long end_time;\n\nstatic __no_kcsan inline void\nbegin_test_checks(void (*func1)(void), void (*func2)(void))\n{\n\tkcsan_disable_current();\n\n\t/*\n\t * Require at least as long as KCSAN_REPORT_ONCE_IN_MS, to ensure at\n\t * least one race is reported.\n\t */\n\tend_time = jiffies + msecs_to_jiffies(CONFIG_KCSAN_REPORT_ONCE_IN_MS + 500);\n\n\t/* Signal start; release potential initialization of shared data. */\n\tsmp_store_release(&access_kernels[0], func1);\n\tsmp_store_release(&access_kernels[1], func2);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/printk.h>\n#include <linux/types.h>\n#include <linux/tracepoint.h>\n#include <linux/torture.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/seqlock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/kcsan-checks.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <kunit/test.h>\n\nstatic __always_inline const struct;\n\n__no_kcsan\nstatic void test_assert_exclusive_bits_nochange(struct kunit *test)\n{\n\tbool match_never = false;\n\n\tbegin_test_checks(test_kernel_assert_bits_nochange, test_kernel_change_bits);\n\tdo {\n\t\tmatch_never = report_available();\n\t} while (!end_test_checks(match_never));\n\tKUNIT_EXPECT_FALSE(test, match_never);\n}"
  },
  {
    "function_name": "test_assert_exclusive_bits_change",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/kcsan_test.c",
    "lines": "1082-1099",
    "snippet": "__no_kcsan\nstatic void test_assert_exclusive_bits_change(struct kunit *test)\n{\n\tstruct expect_report expect = {\n\t\t.access = {\n\t\t\t{ test_kernel_assert_bits_change, &test_var, sizeof(test_var), KCSAN_ACCESS_ASSERT },\n\t\t\t{ test_kernel_change_bits, &test_var, sizeof(test_var),\n\t\t\t\tKCSAN_ACCESS_WRITE | (IS_ENABLED(CONFIG_KCSAN_IGNORE_ATOMICS) ? 0 : KCSAN_ACCESS_ATOMIC) },\n\t\t},\n\t};\n\tbool match_expect = false;\n\n\tbegin_test_checks(test_kernel_assert_bits_change, test_kernel_change_bits);\n\tdo {\n\t\tmatch_expect = report_matches(&expect);\n\t} while (!end_test_checks(match_expect));\n\tKUNIT_EXPECT_TRUE(test, match_expect);\n}",
    "includes": [
      "#include <trace/events/printk.h>",
      "#include <linux/types.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/torture.h>",
      "#include <linux/timer.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kcsan-checks.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <kunit/test.h>"
    ],
    "macros_used": [
      "#define report_matches __report_matches",
      "#define report_matches report_matches_any_reordered"
    ],
    "globals_used": [
      "static __always_inline const struct",
      "static long test_var;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "KUNIT_EXPECT_TRUE",
          "args": [
            "test",
            "match_expect"
          ],
          "line": 1098
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "end_test_checks",
          "args": [
            "match_expect"
          ],
          "line": 1097
        },
        "resolved": true,
        "details": {
          "function_name": "end_test_checks",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/kcsan_test.c",
          "lines": "79-90",
          "snippet": "static __no_kcsan inline bool\nend_test_checks(bool stop)\n{\n\tif (!stop && time_before(jiffies, end_time)) {\n\t\t/* Continue checking */\n\t\tmight_sleep();\n\t\treturn false;\n\t}\n\n\tkcsan_enable_current();\n\treturn true;\n}",
          "includes": [
            "#include <trace/events/printk.h>",
            "#include <linux/types.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/torture.h>",
            "#include <linux/timer.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kcsan-checks.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <kunit/test.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned long end_time;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/printk.h>\n#include <linux/types.h>\n#include <linux/tracepoint.h>\n#include <linux/torture.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/seqlock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/kcsan-checks.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <kunit/test.h>\n\nstatic unsigned long end_time;\n\nstatic __no_kcsan inline bool\nend_test_checks(bool stop)\n{\n\tif (!stop && time_before(jiffies, end_time)) {\n\t\t/* Continue checking */\n\t\tmight_sleep();\n\t\treturn false;\n\t}\n\n\tkcsan_enable_current();\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "report_matches",
          "args": [
            "&expect"
          ],
          "line": 1096
        },
        "resolved": true,
        "details": {
          "function_name": "report_matches_any_reordered",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/kcsan_test.c",
          "lines": "277-284",
          "snippet": "__no_kcsan\nstatic bool report_matches_any_reordered(struct expect_report *r)\n{\n\treturn __report_matches(__report_set_scoped(r, 0)) ||\n\t       __report_matches(__report_set_scoped(r, 1)) ||\n\t       __report_matches(__report_set_scoped(r, 2)) ||\n\t       __report_matches(__report_set_scoped(r, 3));\n}",
          "includes": [
            "#include <trace/events/printk.h>",
            "#include <linux/types.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/torture.h>",
            "#include <linux/timer.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kcsan-checks.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <kunit/test.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline const struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/printk.h>\n#include <linux/types.h>\n#include <linux/tracepoint.h>\n#include <linux/torture.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/seqlock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/kcsan-checks.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <kunit/test.h>\n\nstatic __always_inline const struct;\n\n__no_kcsan\nstatic bool report_matches_any_reordered(struct expect_report *r)\n{\n\treturn __report_matches(__report_set_scoped(r, 0)) ||\n\t       __report_matches(__report_set_scoped(r, 1)) ||\n\t       __report_matches(__report_set_scoped(r, 2)) ||\n\t       __report_matches(__report_set_scoped(r, 3));\n}"
        }
      },
      {
        "call_info": {
          "callee": "begin_test_checks",
          "args": [
            "test_kernel_assert_bits_change",
            "test_kernel_change_bits"
          ],
          "line": 1094
        },
        "resolved": true,
        "details": {
          "function_name": "begin_test_checks",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/kcsan_test.c",
          "lines": "62-76",
          "snippet": "static __no_kcsan inline void\nbegin_test_checks(void (*func1)(void), void (*func2)(void))\n{\n\tkcsan_disable_current();\n\n\t/*\n\t * Require at least as long as KCSAN_REPORT_ONCE_IN_MS, to ensure at\n\t * least one race is reported.\n\t */\n\tend_time = jiffies + msecs_to_jiffies(CONFIG_KCSAN_REPORT_ONCE_IN_MS + 500);\n\n\t/* Signal start; release potential initialization of shared data. */\n\tsmp_store_release(&access_kernels[0], func1);\n\tsmp_store_release(&access_kernels[1], func2);\n}",
          "includes": [
            "#include <trace/events/printk.h>",
            "#include <linux/types.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/torture.h>",
            "#include <linux/timer.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kcsan-checks.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <kunit/test.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void (*access_kernels[2])(void);",
            "static unsigned long end_time;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/printk.h>\n#include <linux/types.h>\n#include <linux/tracepoint.h>\n#include <linux/torture.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/seqlock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/kcsan-checks.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <kunit/test.h>\n\nstatic void (*access_kernels[2])(void);\nstatic unsigned long end_time;\n\nstatic __no_kcsan inline void\nbegin_test_checks(void (*func1)(void), void (*func2)(void))\n{\n\tkcsan_disable_current();\n\n\t/*\n\t * Require at least as long as KCSAN_REPORT_ONCE_IN_MS, to ensure at\n\t * least one race is reported.\n\t */\n\tend_time = jiffies + msecs_to_jiffies(CONFIG_KCSAN_REPORT_ONCE_IN_MS + 500);\n\n\t/* Signal start; release potential initialization of shared data. */\n\tsmp_store_release(&access_kernels[0], func1);\n\tsmp_store_release(&access_kernels[1], func2);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_KCSAN_IGNORE_ATOMICS"
          ],
          "line": 1089
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/printk.h>\n#include <linux/types.h>\n#include <linux/tracepoint.h>\n#include <linux/torture.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/seqlock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/kcsan-checks.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <kunit/test.h>\n\n#define report_matches __report_matches\n#define report_matches report_matches_any_reordered\n\nstatic __always_inline const struct;\nstatic long test_var;\n\n__no_kcsan\nstatic void test_assert_exclusive_bits_change(struct kunit *test)\n{\n\tstruct expect_report expect = {\n\t\t.access = {\n\t\t\t{ test_kernel_assert_bits_change, &test_var, sizeof(test_var), KCSAN_ACCESS_ASSERT },\n\t\t\t{ test_kernel_change_bits, &test_var, sizeof(test_var),\n\t\t\t\tKCSAN_ACCESS_WRITE | (IS_ENABLED(CONFIG_KCSAN_IGNORE_ATOMICS) ? 0 : KCSAN_ACCESS_ATOMIC) },\n\t\t},\n\t};\n\tbool match_expect = false;\n\n\tbegin_test_checks(test_kernel_assert_bits_change, test_kernel_change_bits);\n\tdo {\n\t\tmatch_expect = report_matches(&expect);\n\t} while (!end_test_checks(match_expect));\n\tKUNIT_EXPECT_TRUE(test, match_expect);\n}"
  },
  {
    "function_name": "test_assert_exclusive_access_writer",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/kcsan_test.c",
    "lines": "1046-1080",
    "snippet": "__no_kcsan\nstatic void test_assert_exclusive_access_writer(struct kunit *test)\n{\n\tstruct expect_report expect_access_writer = {\n\t\t.access = {\n\t\t\t{ test_kernel_assert_access, &test_var, sizeof(test_var), KCSAN_ACCESS_ASSERT | KCSAN_ACCESS_WRITE },\n\t\t\t{ test_kernel_assert_writer, &test_var, sizeof(test_var), KCSAN_ACCESS_ASSERT },\n\t\t},\n\t};\n\tstruct expect_report expect_access_access = {\n\t\t.access = {\n\t\t\t{ test_kernel_assert_access, &test_var, sizeof(test_var), KCSAN_ACCESS_ASSERT | KCSAN_ACCESS_WRITE },\n\t\t\t{ test_kernel_assert_access, &test_var, sizeof(test_var), KCSAN_ACCESS_ASSERT | KCSAN_ACCESS_WRITE },\n\t\t},\n\t};\n\tstruct expect_report never = {\n\t\t.access = {\n\t\t\t{ test_kernel_assert_writer, &test_var, sizeof(test_var), KCSAN_ACCESS_ASSERT },\n\t\t\t{ test_kernel_assert_writer, &test_var, sizeof(test_var), KCSAN_ACCESS_ASSERT },\n\t\t},\n\t};\n\tbool match_expect_access_writer = false;\n\tbool match_expect_access_access = false;\n\tbool match_never = false;\n\n\tbegin_test_checks(test_kernel_assert_access, test_kernel_assert_writer);\n\tdo {\n\t\tmatch_expect_access_writer |= report_matches(&expect_access_writer);\n\t\tmatch_expect_access_access |= report_matches(&expect_access_access);\n\t\tmatch_never |= report_matches(&never);\n\t} while (!end_test_checks(match_never));\n\tKUNIT_EXPECT_TRUE(test, match_expect_access_writer);\n\tKUNIT_EXPECT_TRUE(test, match_expect_access_access);\n\tKUNIT_EXPECT_FALSE(test, match_never);\n}",
    "includes": [
      "#include <trace/events/printk.h>",
      "#include <linux/types.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/torture.h>",
      "#include <linux/timer.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kcsan-checks.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <kunit/test.h>"
    ],
    "macros_used": [
      "#define report_matches __report_matches",
      "#define report_matches report_matches_any_reordered"
    ],
    "globals_used": [
      "static __always_inline const struct",
      "static long test_var;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "KUNIT_EXPECT_FALSE",
          "args": [
            "test",
            "match_never"
          ],
          "line": 1079
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KUNIT_EXPECT_TRUE",
          "args": [
            "test",
            "match_expect_access_access"
          ],
          "line": 1078
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KUNIT_EXPECT_TRUE",
          "args": [
            "test",
            "match_expect_access_writer"
          ],
          "line": 1077
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "end_test_checks",
          "args": [
            "match_never"
          ],
          "line": 1076
        },
        "resolved": true,
        "details": {
          "function_name": "end_test_checks",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/kcsan_test.c",
          "lines": "79-90",
          "snippet": "static __no_kcsan inline bool\nend_test_checks(bool stop)\n{\n\tif (!stop && time_before(jiffies, end_time)) {\n\t\t/* Continue checking */\n\t\tmight_sleep();\n\t\treturn false;\n\t}\n\n\tkcsan_enable_current();\n\treturn true;\n}",
          "includes": [
            "#include <trace/events/printk.h>",
            "#include <linux/types.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/torture.h>",
            "#include <linux/timer.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kcsan-checks.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <kunit/test.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned long end_time;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/printk.h>\n#include <linux/types.h>\n#include <linux/tracepoint.h>\n#include <linux/torture.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/seqlock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/kcsan-checks.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <kunit/test.h>\n\nstatic unsigned long end_time;\n\nstatic __no_kcsan inline bool\nend_test_checks(bool stop)\n{\n\tif (!stop && time_before(jiffies, end_time)) {\n\t\t/* Continue checking */\n\t\tmight_sleep();\n\t\treturn false;\n\t}\n\n\tkcsan_enable_current();\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "report_matches",
          "args": [
            "&never"
          ],
          "line": 1075
        },
        "resolved": true,
        "details": {
          "function_name": "report_matches_any_reordered",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/kcsan_test.c",
          "lines": "277-284",
          "snippet": "__no_kcsan\nstatic bool report_matches_any_reordered(struct expect_report *r)\n{\n\treturn __report_matches(__report_set_scoped(r, 0)) ||\n\t       __report_matches(__report_set_scoped(r, 1)) ||\n\t       __report_matches(__report_set_scoped(r, 2)) ||\n\t       __report_matches(__report_set_scoped(r, 3));\n}",
          "includes": [
            "#include <trace/events/printk.h>",
            "#include <linux/types.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/torture.h>",
            "#include <linux/timer.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kcsan-checks.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <kunit/test.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline const struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/printk.h>\n#include <linux/types.h>\n#include <linux/tracepoint.h>\n#include <linux/torture.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/seqlock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/kcsan-checks.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <kunit/test.h>\n\nstatic __always_inline const struct;\n\n__no_kcsan\nstatic bool report_matches_any_reordered(struct expect_report *r)\n{\n\treturn __report_matches(__report_set_scoped(r, 0)) ||\n\t       __report_matches(__report_set_scoped(r, 1)) ||\n\t       __report_matches(__report_set_scoped(r, 2)) ||\n\t       __report_matches(__report_set_scoped(r, 3));\n}"
        }
      },
      {
        "call_info": {
          "callee": "begin_test_checks",
          "args": [
            "test_kernel_assert_access",
            "test_kernel_assert_writer"
          ],
          "line": 1071
        },
        "resolved": true,
        "details": {
          "function_name": "begin_test_checks",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/kcsan_test.c",
          "lines": "62-76",
          "snippet": "static __no_kcsan inline void\nbegin_test_checks(void (*func1)(void), void (*func2)(void))\n{\n\tkcsan_disable_current();\n\n\t/*\n\t * Require at least as long as KCSAN_REPORT_ONCE_IN_MS, to ensure at\n\t * least one race is reported.\n\t */\n\tend_time = jiffies + msecs_to_jiffies(CONFIG_KCSAN_REPORT_ONCE_IN_MS + 500);\n\n\t/* Signal start; release potential initialization of shared data. */\n\tsmp_store_release(&access_kernels[0], func1);\n\tsmp_store_release(&access_kernels[1], func2);\n}",
          "includes": [
            "#include <trace/events/printk.h>",
            "#include <linux/types.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/torture.h>",
            "#include <linux/timer.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kcsan-checks.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <kunit/test.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void (*access_kernels[2])(void);",
            "static unsigned long end_time;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/printk.h>\n#include <linux/types.h>\n#include <linux/tracepoint.h>\n#include <linux/torture.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/seqlock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/kcsan-checks.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <kunit/test.h>\n\nstatic void (*access_kernels[2])(void);\nstatic unsigned long end_time;\n\nstatic __no_kcsan inline void\nbegin_test_checks(void (*func1)(void), void (*func2)(void))\n{\n\tkcsan_disable_current();\n\n\t/*\n\t * Require at least as long as KCSAN_REPORT_ONCE_IN_MS, to ensure at\n\t * least one race is reported.\n\t */\n\tend_time = jiffies + msecs_to_jiffies(CONFIG_KCSAN_REPORT_ONCE_IN_MS + 500);\n\n\t/* Signal start; release potential initialization of shared data. */\n\tsmp_store_release(&access_kernels[0], func1);\n\tsmp_store_release(&access_kernels[1], func2);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/printk.h>\n#include <linux/types.h>\n#include <linux/tracepoint.h>\n#include <linux/torture.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/seqlock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/kcsan-checks.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <kunit/test.h>\n\n#define report_matches __report_matches\n#define report_matches report_matches_any_reordered\n\nstatic __always_inline const struct;\nstatic long test_var;\n\n__no_kcsan\nstatic void test_assert_exclusive_access_writer(struct kunit *test)\n{\n\tstruct expect_report expect_access_writer = {\n\t\t.access = {\n\t\t\t{ test_kernel_assert_access, &test_var, sizeof(test_var), KCSAN_ACCESS_ASSERT | KCSAN_ACCESS_WRITE },\n\t\t\t{ test_kernel_assert_writer, &test_var, sizeof(test_var), KCSAN_ACCESS_ASSERT },\n\t\t},\n\t};\n\tstruct expect_report expect_access_access = {\n\t\t.access = {\n\t\t\t{ test_kernel_assert_access, &test_var, sizeof(test_var), KCSAN_ACCESS_ASSERT | KCSAN_ACCESS_WRITE },\n\t\t\t{ test_kernel_assert_access, &test_var, sizeof(test_var), KCSAN_ACCESS_ASSERT | KCSAN_ACCESS_WRITE },\n\t\t},\n\t};\n\tstruct expect_report never = {\n\t\t.access = {\n\t\t\t{ test_kernel_assert_writer, &test_var, sizeof(test_var), KCSAN_ACCESS_ASSERT },\n\t\t\t{ test_kernel_assert_writer, &test_var, sizeof(test_var), KCSAN_ACCESS_ASSERT },\n\t\t},\n\t};\n\tbool match_expect_access_writer = false;\n\tbool match_expect_access_access = false;\n\tbool match_never = false;\n\n\tbegin_test_checks(test_kernel_assert_access, test_kernel_assert_writer);\n\tdo {\n\t\tmatch_expect_access_writer |= report_matches(&expect_access_writer);\n\t\tmatch_expect_access_access |= report_matches(&expect_access_access);\n\t\tmatch_never |= report_matches(&never);\n\t} while (!end_test_checks(match_never));\n\tKUNIT_EXPECT_TRUE(test, match_expect_access_writer);\n\tKUNIT_EXPECT_TRUE(test, match_expect_access_access);\n\tKUNIT_EXPECT_FALSE(test, match_never);\n}"
  },
  {
    "function_name": "test_assert_exclusive_access",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/kcsan_test.c",
    "lines": "1028-1044",
    "snippet": "__no_kcsan\nstatic void test_assert_exclusive_access(struct kunit *test)\n{\n\tstruct expect_report expect = {\n\t\t.access = {\n\t\t\t{ test_kernel_assert_access, &test_var, sizeof(test_var), KCSAN_ACCESS_ASSERT | KCSAN_ACCESS_WRITE },\n\t\t\t{ test_kernel_read, &test_var, sizeof(test_var), 0 },\n\t\t},\n\t};\n\tbool match_expect = false;\n\n\tbegin_test_checks(test_kernel_assert_access, test_kernel_read);\n\tdo {\n\t\tmatch_expect = report_matches(&expect);\n\t} while (!end_test_checks(match_expect));\n\tKUNIT_EXPECT_TRUE(test, match_expect);\n}",
    "includes": [
      "#include <trace/events/printk.h>",
      "#include <linux/types.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/torture.h>",
      "#include <linux/timer.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kcsan-checks.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <kunit/test.h>"
    ],
    "macros_used": [
      "#define report_matches __report_matches",
      "#define report_matches report_matches_any_reordered"
    ],
    "globals_used": [
      "static __always_inline const struct",
      "static long test_var;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "KUNIT_EXPECT_TRUE",
          "args": [
            "test",
            "match_expect"
          ],
          "line": 1043
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "end_test_checks",
          "args": [
            "match_expect"
          ],
          "line": 1042
        },
        "resolved": true,
        "details": {
          "function_name": "end_test_checks",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/kcsan_test.c",
          "lines": "79-90",
          "snippet": "static __no_kcsan inline bool\nend_test_checks(bool stop)\n{\n\tif (!stop && time_before(jiffies, end_time)) {\n\t\t/* Continue checking */\n\t\tmight_sleep();\n\t\treturn false;\n\t}\n\n\tkcsan_enable_current();\n\treturn true;\n}",
          "includes": [
            "#include <trace/events/printk.h>",
            "#include <linux/types.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/torture.h>",
            "#include <linux/timer.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kcsan-checks.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <kunit/test.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned long end_time;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/printk.h>\n#include <linux/types.h>\n#include <linux/tracepoint.h>\n#include <linux/torture.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/seqlock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/kcsan-checks.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <kunit/test.h>\n\nstatic unsigned long end_time;\n\nstatic __no_kcsan inline bool\nend_test_checks(bool stop)\n{\n\tif (!stop && time_before(jiffies, end_time)) {\n\t\t/* Continue checking */\n\t\tmight_sleep();\n\t\treturn false;\n\t}\n\n\tkcsan_enable_current();\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "report_matches",
          "args": [
            "&expect"
          ],
          "line": 1041
        },
        "resolved": true,
        "details": {
          "function_name": "report_matches_any_reordered",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/kcsan_test.c",
          "lines": "277-284",
          "snippet": "__no_kcsan\nstatic bool report_matches_any_reordered(struct expect_report *r)\n{\n\treturn __report_matches(__report_set_scoped(r, 0)) ||\n\t       __report_matches(__report_set_scoped(r, 1)) ||\n\t       __report_matches(__report_set_scoped(r, 2)) ||\n\t       __report_matches(__report_set_scoped(r, 3));\n}",
          "includes": [
            "#include <trace/events/printk.h>",
            "#include <linux/types.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/torture.h>",
            "#include <linux/timer.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kcsan-checks.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <kunit/test.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline const struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/printk.h>\n#include <linux/types.h>\n#include <linux/tracepoint.h>\n#include <linux/torture.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/seqlock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/kcsan-checks.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <kunit/test.h>\n\nstatic __always_inline const struct;\n\n__no_kcsan\nstatic bool report_matches_any_reordered(struct expect_report *r)\n{\n\treturn __report_matches(__report_set_scoped(r, 0)) ||\n\t       __report_matches(__report_set_scoped(r, 1)) ||\n\t       __report_matches(__report_set_scoped(r, 2)) ||\n\t       __report_matches(__report_set_scoped(r, 3));\n}"
        }
      },
      {
        "call_info": {
          "callee": "begin_test_checks",
          "args": [
            "test_kernel_assert_access",
            "test_kernel_read"
          ],
          "line": 1039
        },
        "resolved": true,
        "details": {
          "function_name": "begin_test_checks",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/kcsan_test.c",
          "lines": "62-76",
          "snippet": "static __no_kcsan inline void\nbegin_test_checks(void (*func1)(void), void (*func2)(void))\n{\n\tkcsan_disable_current();\n\n\t/*\n\t * Require at least as long as KCSAN_REPORT_ONCE_IN_MS, to ensure at\n\t * least one race is reported.\n\t */\n\tend_time = jiffies + msecs_to_jiffies(CONFIG_KCSAN_REPORT_ONCE_IN_MS + 500);\n\n\t/* Signal start; release potential initialization of shared data. */\n\tsmp_store_release(&access_kernels[0], func1);\n\tsmp_store_release(&access_kernels[1], func2);\n}",
          "includes": [
            "#include <trace/events/printk.h>",
            "#include <linux/types.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/torture.h>",
            "#include <linux/timer.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kcsan-checks.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <kunit/test.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void (*access_kernels[2])(void);",
            "static unsigned long end_time;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/printk.h>\n#include <linux/types.h>\n#include <linux/tracepoint.h>\n#include <linux/torture.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/seqlock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/kcsan-checks.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <kunit/test.h>\n\nstatic void (*access_kernels[2])(void);\nstatic unsigned long end_time;\n\nstatic __no_kcsan inline void\nbegin_test_checks(void (*func1)(void), void (*func2)(void))\n{\n\tkcsan_disable_current();\n\n\t/*\n\t * Require at least as long as KCSAN_REPORT_ONCE_IN_MS, to ensure at\n\t * least one race is reported.\n\t */\n\tend_time = jiffies + msecs_to_jiffies(CONFIG_KCSAN_REPORT_ONCE_IN_MS + 500);\n\n\t/* Signal start; release potential initialization of shared data. */\n\tsmp_store_release(&access_kernels[0], func1);\n\tsmp_store_release(&access_kernels[1], func2);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/printk.h>\n#include <linux/types.h>\n#include <linux/tracepoint.h>\n#include <linux/torture.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/seqlock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/kcsan-checks.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <kunit/test.h>\n\n#define report_matches __report_matches\n#define report_matches report_matches_any_reordered\n\nstatic __always_inline const struct;\nstatic long test_var;\n\n__no_kcsan\nstatic void test_assert_exclusive_access(struct kunit *test)\n{\n\tstruct expect_report expect = {\n\t\t.access = {\n\t\t\t{ test_kernel_assert_access, &test_var, sizeof(test_var), KCSAN_ACCESS_ASSERT | KCSAN_ACCESS_WRITE },\n\t\t\t{ test_kernel_read, &test_var, sizeof(test_var), 0 },\n\t\t},\n\t};\n\tbool match_expect = false;\n\n\tbegin_test_checks(test_kernel_assert_access, test_kernel_read);\n\tdo {\n\t\tmatch_expect = report_matches(&expect);\n\t} while (!end_test_checks(match_expect));\n\tKUNIT_EXPECT_TRUE(test, match_expect);\n}"
  },
  {
    "function_name": "test_assert_exclusive_writer",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/kcsan_test.c",
    "lines": "1010-1026",
    "snippet": "__no_kcsan\nstatic void test_assert_exclusive_writer(struct kunit *test)\n{\n\tstruct expect_report expect = {\n\t\t.access = {\n\t\t\t{ test_kernel_assert_writer, &test_var, sizeof(test_var), KCSAN_ACCESS_ASSERT },\n\t\t\t{ test_kernel_write_nochange, &test_var, sizeof(test_var), KCSAN_ACCESS_WRITE },\n\t\t},\n\t};\n\tbool match_expect = false;\n\n\tbegin_test_checks(test_kernel_assert_writer, test_kernel_write_nochange);\n\tdo {\n\t\tmatch_expect = report_matches(&expect);\n\t} while (!end_test_checks(match_expect));\n\tKUNIT_EXPECT_TRUE(test, match_expect);\n}",
    "includes": [
      "#include <trace/events/printk.h>",
      "#include <linux/types.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/torture.h>",
      "#include <linux/timer.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kcsan-checks.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <kunit/test.h>"
    ],
    "macros_used": [
      "#define report_matches __report_matches",
      "#define report_matches report_matches_any_reordered"
    ],
    "globals_used": [
      "static __always_inline const struct",
      "static long test_var;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "KUNIT_EXPECT_TRUE",
          "args": [
            "test",
            "match_expect"
          ],
          "line": 1025
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "end_test_checks",
          "args": [
            "match_expect"
          ],
          "line": 1024
        },
        "resolved": true,
        "details": {
          "function_name": "end_test_checks",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/kcsan_test.c",
          "lines": "79-90",
          "snippet": "static __no_kcsan inline bool\nend_test_checks(bool stop)\n{\n\tif (!stop && time_before(jiffies, end_time)) {\n\t\t/* Continue checking */\n\t\tmight_sleep();\n\t\treturn false;\n\t}\n\n\tkcsan_enable_current();\n\treturn true;\n}",
          "includes": [
            "#include <trace/events/printk.h>",
            "#include <linux/types.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/torture.h>",
            "#include <linux/timer.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kcsan-checks.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <kunit/test.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned long end_time;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/printk.h>\n#include <linux/types.h>\n#include <linux/tracepoint.h>\n#include <linux/torture.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/seqlock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/kcsan-checks.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <kunit/test.h>\n\nstatic unsigned long end_time;\n\nstatic __no_kcsan inline bool\nend_test_checks(bool stop)\n{\n\tif (!stop && time_before(jiffies, end_time)) {\n\t\t/* Continue checking */\n\t\tmight_sleep();\n\t\treturn false;\n\t}\n\n\tkcsan_enable_current();\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "report_matches",
          "args": [
            "&expect"
          ],
          "line": 1023
        },
        "resolved": true,
        "details": {
          "function_name": "report_matches_any_reordered",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/kcsan_test.c",
          "lines": "277-284",
          "snippet": "__no_kcsan\nstatic bool report_matches_any_reordered(struct expect_report *r)\n{\n\treturn __report_matches(__report_set_scoped(r, 0)) ||\n\t       __report_matches(__report_set_scoped(r, 1)) ||\n\t       __report_matches(__report_set_scoped(r, 2)) ||\n\t       __report_matches(__report_set_scoped(r, 3));\n}",
          "includes": [
            "#include <trace/events/printk.h>",
            "#include <linux/types.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/torture.h>",
            "#include <linux/timer.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kcsan-checks.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <kunit/test.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline const struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/printk.h>\n#include <linux/types.h>\n#include <linux/tracepoint.h>\n#include <linux/torture.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/seqlock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/kcsan-checks.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <kunit/test.h>\n\nstatic __always_inline const struct;\n\n__no_kcsan\nstatic bool report_matches_any_reordered(struct expect_report *r)\n{\n\treturn __report_matches(__report_set_scoped(r, 0)) ||\n\t       __report_matches(__report_set_scoped(r, 1)) ||\n\t       __report_matches(__report_set_scoped(r, 2)) ||\n\t       __report_matches(__report_set_scoped(r, 3));\n}"
        }
      },
      {
        "call_info": {
          "callee": "begin_test_checks",
          "args": [
            "test_kernel_assert_writer",
            "test_kernel_write_nochange"
          ],
          "line": 1021
        },
        "resolved": true,
        "details": {
          "function_name": "begin_test_checks",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/kcsan_test.c",
          "lines": "62-76",
          "snippet": "static __no_kcsan inline void\nbegin_test_checks(void (*func1)(void), void (*func2)(void))\n{\n\tkcsan_disable_current();\n\n\t/*\n\t * Require at least as long as KCSAN_REPORT_ONCE_IN_MS, to ensure at\n\t * least one race is reported.\n\t */\n\tend_time = jiffies + msecs_to_jiffies(CONFIG_KCSAN_REPORT_ONCE_IN_MS + 500);\n\n\t/* Signal start; release potential initialization of shared data. */\n\tsmp_store_release(&access_kernels[0], func1);\n\tsmp_store_release(&access_kernels[1], func2);\n}",
          "includes": [
            "#include <trace/events/printk.h>",
            "#include <linux/types.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/torture.h>",
            "#include <linux/timer.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kcsan-checks.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <kunit/test.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void (*access_kernels[2])(void);",
            "static unsigned long end_time;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/printk.h>\n#include <linux/types.h>\n#include <linux/tracepoint.h>\n#include <linux/torture.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/seqlock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/kcsan-checks.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <kunit/test.h>\n\nstatic void (*access_kernels[2])(void);\nstatic unsigned long end_time;\n\nstatic __no_kcsan inline void\nbegin_test_checks(void (*func1)(void), void (*func2)(void))\n{\n\tkcsan_disable_current();\n\n\t/*\n\t * Require at least as long as KCSAN_REPORT_ONCE_IN_MS, to ensure at\n\t * least one race is reported.\n\t */\n\tend_time = jiffies + msecs_to_jiffies(CONFIG_KCSAN_REPORT_ONCE_IN_MS + 500);\n\n\t/* Signal start; release potential initialization of shared data. */\n\tsmp_store_release(&access_kernels[0], func1);\n\tsmp_store_release(&access_kernels[1], func2);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/printk.h>\n#include <linux/types.h>\n#include <linux/tracepoint.h>\n#include <linux/torture.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/seqlock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/kcsan-checks.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <kunit/test.h>\n\n#define report_matches __report_matches\n#define report_matches report_matches_any_reordered\n\nstatic __always_inline const struct;\nstatic long test_var;\n\n__no_kcsan\nstatic void test_assert_exclusive_writer(struct kunit *test)\n{\n\tstruct expect_report expect = {\n\t\t.access = {\n\t\t\t{ test_kernel_assert_writer, &test_var, sizeof(test_var), KCSAN_ACCESS_ASSERT },\n\t\t\t{ test_kernel_write_nochange, &test_var, sizeof(test_var), KCSAN_ACCESS_WRITE },\n\t\t},\n\t};\n\tbool match_expect = false;\n\n\tbegin_test_checks(test_kernel_assert_writer, test_kernel_write_nochange);\n\tdo {\n\t\tmatch_expect = report_matches(&expect);\n\t} while (!end_test_checks(match_expect));\n\tKUNIT_EXPECT_TRUE(test, match_expect);\n}"
  },
  {
    "function_name": "test_data_race",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/kcsan_test.c",
    "lines": "998-1008",
    "snippet": "__no_kcsan\nstatic void test_data_race(struct kunit *test)\n{\n\tbool match_never = false;\n\n\tbegin_test_checks(test_kernel_data_race, test_kernel_data_race);\n\tdo {\n\t\tmatch_never = report_available();\n\t} while (!end_test_checks(match_never));\n\tKUNIT_EXPECT_FALSE(test, match_never);\n}",
    "includes": [
      "#include <trace/events/printk.h>",
      "#include <linux/types.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/torture.h>",
      "#include <linux/timer.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kcsan-checks.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <kunit/test.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline const struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "KUNIT_EXPECT_FALSE",
          "args": [
            "test",
            "match_never"
          ],
          "line": 1007
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "end_test_checks",
          "args": [
            "match_never"
          ],
          "line": 1006
        },
        "resolved": true,
        "details": {
          "function_name": "end_test_checks",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/kcsan_test.c",
          "lines": "79-90",
          "snippet": "static __no_kcsan inline bool\nend_test_checks(bool stop)\n{\n\tif (!stop && time_before(jiffies, end_time)) {\n\t\t/* Continue checking */\n\t\tmight_sleep();\n\t\treturn false;\n\t}\n\n\tkcsan_enable_current();\n\treturn true;\n}",
          "includes": [
            "#include <trace/events/printk.h>",
            "#include <linux/types.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/torture.h>",
            "#include <linux/timer.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kcsan-checks.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <kunit/test.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned long end_time;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/printk.h>\n#include <linux/types.h>\n#include <linux/tracepoint.h>\n#include <linux/torture.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/seqlock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/kcsan-checks.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <kunit/test.h>\n\nstatic unsigned long end_time;\n\nstatic __no_kcsan inline bool\nend_test_checks(bool stop)\n{\n\tif (!stop && time_before(jiffies, end_time)) {\n\t\t/* Continue checking */\n\t\tmight_sleep();\n\t\treturn false;\n\t}\n\n\tkcsan_enable_current();\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "report_available",
          "args": [],
          "line": 1005
        },
        "resolved": true,
        "details": {
          "function_name": "report_available",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/kcsan_test.c",
          "lines": "138-142",
          "snippet": "__no_kcsan\nstatic bool report_available(void)\n{\n\treturn READ_ONCE(observed.nlines) == ARRAY_SIZE(observed.lines);\n}",
          "includes": [
            "#include <trace/events/printk.h>",
            "#include <linux/types.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/torture.h>",
            "#include <linux/timer.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kcsan-checks.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <kunit/test.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct {\n\tspinlock_t lock;\n\tint nlines;\n\tchar lines[3][512];\n} observed = {\n\t.lock = __SPIN_LOCK_UNLOCKED(observed.lock),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/printk.h>\n#include <linux/types.h>\n#include <linux/tracepoint.h>\n#include <linux/torture.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/seqlock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/kcsan-checks.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <kunit/test.h>\n\nstatic struct {\n\tspinlock_t lock;\n\tint nlines;\n\tchar lines[3][512];\n} observed = {\n\t.lock = __SPIN_LOCK_UNLOCKED(observed.lock),\n};\n\n__no_kcsan\nstatic bool report_available(void)\n{\n\treturn READ_ONCE(observed.nlines) == ARRAY_SIZE(observed.lines);\n}"
        }
      },
      {
        "call_info": {
          "callee": "begin_test_checks",
          "args": [
            "test_kernel_data_race",
            "test_kernel_data_race"
          ],
          "line": 1003
        },
        "resolved": true,
        "details": {
          "function_name": "begin_test_checks",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/kcsan_test.c",
          "lines": "62-76",
          "snippet": "static __no_kcsan inline void\nbegin_test_checks(void (*func1)(void), void (*func2)(void))\n{\n\tkcsan_disable_current();\n\n\t/*\n\t * Require at least as long as KCSAN_REPORT_ONCE_IN_MS, to ensure at\n\t * least one race is reported.\n\t */\n\tend_time = jiffies + msecs_to_jiffies(CONFIG_KCSAN_REPORT_ONCE_IN_MS + 500);\n\n\t/* Signal start; release potential initialization of shared data. */\n\tsmp_store_release(&access_kernels[0], func1);\n\tsmp_store_release(&access_kernels[1], func2);\n}",
          "includes": [
            "#include <trace/events/printk.h>",
            "#include <linux/types.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/torture.h>",
            "#include <linux/timer.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kcsan-checks.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <kunit/test.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void (*access_kernels[2])(void);",
            "static unsigned long end_time;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/printk.h>\n#include <linux/types.h>\n#include <linux/tracepoint.h>\n#include <linux/torture.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/seqlock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/kcsan-checks.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <kunit/test.h>\n\nstatic void (*access_kernels[2])(void);\nstatic unsigned long end_time;\n\nstatic __no_kcsan inline void\nbegin_test_checks(void (*func1)(void), void (*func2)(void))\n{\n\tkcsan_disable_current();\n\n\t/*\n\t * Require at least as long as KCSAN_REPORT_ONCE_IN_MS, to ensure at\n\t * least one race is reported.\n\t */\n\tend_time = jiffies + msecs_to_jiffies(CONFIG_KCSAN_REPORT_ONCE_IN_MS + 500);\n\n\t/* Signal start; release potential initialization of shared data. */\n\tsmp_store_release(&access_kernels[0], func1);\n\tsmp_store_release(&access_kernels[1], func2);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/printk.h>\n#include <linux/types.h>\n#include <linux/tracepoint.h>\n#include <linux/torture.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/seqlock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/kcsan-checks.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <kunit/test.h>\n\nstatic __always_inline const struct;\n\n__no_kcsan\nstatic void test_data_race(struct kunit *test)\n{\n\tbool match_never = false;\n\n\tbegin_test_checks(test_kernel_data_race, test_kernel_data_race);\n\tdo {\n\t\tmatch_never = report_available();\n\t} while (!end_test_checks(match_never));\n\tKUNIT_EXPECT_FALSE(test, match_never);\n}"
  },
  {
    "function_name": "test_zero_size_access",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/kcsan_test.c",
    "lines": "970-995",
    "snippet": "__no_kcsan\nstatic void test_zero_size_access(struct kunit *test)\n{\n\tstruct expect_report expect = {\n\t\t.access = {\n\t\t\t{ test_kernel_write_struct, &test_struct, sizeof(test_struct), KCSAN_ACCESS_WRITE },\n\t\t\t{ test_kernel_write_struct, &test_struct, sizeof(test_struct), KCSAN_ACCESS_WRITE },\n\t\t},\n\t};\n\tstruct expect_report never = {\n\t\t.access = {\n\t\t\t{ test_kernel_write_struct, &test_struct, sizeof(test_struct), KCSAN_ACCESS_WRITE },\n\t\t\t{ test_kernel_read_struct_zero_size, &test_struct.val[3], 0, 0 },\n\t\t},\n\t};\n\tbool match_expect = false;\n\tbool match_never = false;\n\n\tbegin_test_checks(test_kernel_write_struct, test_kernel_read_struct_zero_size);\n\tdo {\n\t\tmatch_expect |= report_matches(&expect);\n\t\tmatch_never = report_matches(&never);\n\t} while (!end_test_checks(match_never));\n\tKUNIT_EXPECT_TRUE(test, match_expect); /* Sanity check. */\n\tKUNIT_EXPECT_FALSE(test, match_never);\n}",
    "includes": [
      "#include <trace/events/printk.h>",
      "#include <linux/types.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/torture.h>",
      "#include <linux/timer.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kcsan-checks.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <kunit/test.h>"
    ],
    "macros_used": [
      "#define report_matches __report_matches",
      "#define report_matches report_matches_any_reordered"
    ],
    "globals_used": [
      "static __always_inline const struct",
      "static struct {\n\tlong val[8];\n} test_struct;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "KUNIT_EXPECT_FALSE",
          "args": [
            "test",
            "match_never"
          ],
          "line": 994
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KUNIT_EXPECT_TRUE",
          "args": [
            "test",
            "match_expect"
          ],
          "line": 993
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "end_test_checks",
          "args": [
            "match_never"
          ],
          "line": 992
        },
        "resolved": true,
        "details": {
          "function_name": "end_test_checks",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/kcsan_test.c",
          "lines": "79-90",
          "snippet": "static __no_kcsan inline bool\nend_test_checks(bool stop)\n{\n\tif (!stop && time_before(jiffies, end_time)) {\n\t\t/* Continue checking */\n\t\tmight_sleep();\n\t\treturn false;\n\t}\n\n\tkcsan_enable_current();\n\treturn true;\n}",
          "includes": [
            "#include <trace/events/printk.h>",
            "#include <linux/types.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/torture.h>",
            "#include <linux/timer.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kcsan-checks.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <kunit/test.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned long end_time;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/printk.h>\n#include <linux/types.h>\n#include <linux/tracepoint.h>\n#include <linux/torture.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/seqlock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/kcsan-checks.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <kunit/test.h>\n\nstatic unsigned long end_time;\n\nstatic __no_kcsan inline bool\nend_test_checks(bool stop)\n{\n\tif (!stop && time_before(jiffies, end_time)) {\n\t\t/* Continue checking */\n\t\tmight_sleep();\n\t\treturn false;\n\t}\n\n\tkcsan_enable_current();\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "report_matches",
          "args": [
            "&never"
          ],
          "line": 991
        },
        "resolved": true,
        "details": {
          "function_name": "report_matches_any_reordered",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/kcsan_test.c",
          "lines": "277-284",
          "snippet": "__no_kcsan\nstatic bool report_matches_any_reordered(struct expect_report *r)\n{\n\treturn __report_matches(__report_set_scoped(r, 0)) ||\n\t       __report_matches(__report_set_scoped(r, 1)) ||\n\t       __report_matches(__report_set_scoped(r, 2)) ||\n\t       __report_matches(__report_set_scoped(r, 3));\n}",
          "includes": [
            "#include <trace/events/printk.h>",
            "#include <linux/types.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/torture.h>",
            "#include <linux/timer.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kcsan-checks.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <kunit/test.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline const struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/printk.h>\n#include <linux/types.h>\n#include <linux/tracepoint.h>\n#include <linux/torture.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/seqlock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/kcsan-checks.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <kunit/test.h>\n\nstatic __always_inline const struct;\n\n__no_kcsan\nstatic bool report_matches_any_reordered(struct expect_report *r)\n{\n\treturn __report_matches(__report_set_scoped(r, 0)) ||\n\t       __report_matches(__report_set_scoped(r, 1)) ||\n\t       __report_matches(__report_set_scoped(r, 2)) ||\n\t       __report_matches(__report_set_scoped(r, 3));\n}"
        }
      },
      {
        "call_info": {
          "callee": "begin_test_checks",
          "args": [
            "test_kernel_write_struct",
            "test_kernel_read_struct_zero_size"
          ],
          "line": 988
        },
        "resolved": true,
        "details": {
          "function_name": "begin_test_checks",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/kcsan_test.c",
          "lines": "62-76",
          "snippet": "static __no_kcsan inline void\nbegin_test_checks(void (*func1)(void), void (*func2)(void))\n{\n\tkcsan_disable_current();\n\n\t/*\n\t * Require at least as long as KCSAN_REPORT_ONCE_IN_MS, to ensure at\n\t * least one race is reported.\n\t */\n\tend_time = jiffies + msecs_to_jiffies(CONFIG_KCSAN_REPORT_ONCE_IN_MS + 500);\n\n\t/* Signal start; release potential initialization of shared data. */\n\tsmp_store_release(&access_kernels[0], func1);\n\tsmp_store_release(&access_kernels[1], func2);\n}",
          "includes": [
            "#include <trace/events/printk.h>",
            "#include <linux/types.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/torture.h>",
            "#include <linux/timer.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kcsan-checks.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <kunit/test.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void (*access_kernels[2])(void);",
            "static unsigned long end_time;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/printk.h>\n#include <linux/types.h>\n#include <linux/tracepoint.h>\n#include <linux/torture.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/seqlock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/kcsan-checks.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <kunit/test.h>\n\nstatic void (*access_kernels[2])(void);\nstatic unsigned long end_time;\n\nstatic __no_kcsan inline void\nbegin_test_checks(void (*func1)(void), void (*func2)(void))\n{\n\tkcsan_disable_current();\n\n\t/*\n\t * Require at least as long as KCSAN_REPORT_ONCE_IN_MS, to ensure at\n\t * least one race is reported.\n\t */\n\tend_time = jiffies + msecs_to_jiffies(CONFIG_KCSAN_REPORT_ONCE_IN_MS + 500);\n\n\t/* Signal start; release potential initialization of shared data. */\n\tsmp_store_release(&access_kernels[0], func1);\n\tsmp_store_release(&access_kernels[1], func2);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/printk.h>\n#include <linux/types.h>\n#include <linux/tracepoint.h>\n#include <linux/torture.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/seqlock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/kcsan-checks.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <kunit/test.h>\n\n#define report_matches __report_matches\n#define report_matches report_matches_any_reordered\n\nstatic __always_inline const struct;\nstatic struct {\n\tlong val[8];\n} test_struct;\n\n__no_kcsan\nstatic void test_zero_size_access(struct kunit *test)\n{\n\tstruct expect_report expect = {\n\t\t.access = {\n\t\t\t{ test_kernel_write_struct, &test_struct, sizeof(test_struct), KCSAN_ACCESS_WRITE },\n\t\t\t{ test_kernel_write_struct, &test_struct, sizeof(test_struct), KCSAN_ACCESS_WRITE },\n\t\t},\n\t};\n\tstruct expect_report never = {\n\t\t.access = {\n\t\t\t{ test_kernel_write_struct, &test_struct, sizeof(test_struct), KCSAN_ACCESS_WRITE },\n\t\t\t{ test_kernel_read_struct_zero_size, &test_struct.val[3], 0, 0 },\n\t\t},\n\t};\n\tbool match_expect = false;\n\tbool match_never = false;\n\n\tbegin_test_checks(test_kernel_write_struct, test_kernel_read_struct_zero_size);\n\tdo {\n\t\tmatch_expect |= report_matches(&expect);\n\t\tmatch_never = report_matches(&never);\n\t} while (!end_test_checks(match_never));\n\tKUNIT_EXPECT_TRUE(test, match_expect); /* Sanity check. */\n\tKUNIT_EXPECT_FALSE(test, match_never);\n}"
  },
  {
    "function_name": "test_read_plain_atomic_rmw",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/kcsan_test.c",
    "lines": "948-967",
    "snippet": "__no_kcsan\nstatic void test_read_plain_atomic_rmw(struct kunit *test)\n{\n\tstruct expect_report expect = {\n\t\t.access = {\n\t\t\t{ test_kernel_read, &test_var, sizeof(test_var), 0 },\n\t\t\t{ test_kernel_atomic_rmw, &test_var, sizeof(test_var),\n\t\t\t\tKCSAN_ACCESS_COMPOUND | KCSAN_ACCESS_WRITE | KCSAN_ACCESS_ATOMIC },\n\t\t},\n\t};\n\tbool match_expect = false;\n\n\tKCSAN_TEST_REQUIRES(test, !IS_ENABLED(CONFIG_KCSAN_IGNORE_ATOMICS));\n\n\tbegin_test_checks(test_kernel_read, test_kernel_atomic_rmw);\n\tdo {\n\t\tmatch_expect = report_matches(&expect);\n\t} while (!end_test_checks(match_expect));\n\tKUNIT_EXPECT_TRUE(test, match_expect);\n}",
    "includes": [
      "#include <trace/events/printk.h>",
      "#include <linux/types.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/torture.h>",
      "#include <linux/timer.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kcsan-checks.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <kunit/test.h>"
    ],
    "macros_used": [
      "#define report_matches __report_matches",
      "#define report_matches report_matches_any_reordered"
    ],
    "globals_used": [
      "static __always_inline const struct",
      "static long test_var;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "KUNIT_EXPECT_TRUE",
          "args": [
            "test",
            "match_expect"
          ],
          "line": 966
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "end_test_checks",
          "args": [
            "match_expect"
          ],
          "line": 965
        },
        "resolved": true,
        "details": {
          "function_name": "end_test_checks",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/kcsan_test.c",
          "lines": "79-90",
          "snippet": "static __no_kcsan inline bool\nend_test_checks(bool stop)\n{\n\tif (!stop && time_before(jiffies, end_time)) {\n\t\t/* Continue checking */\n\t\tmight_sleep();\n\t\treturn false;\n\t}\n\n\tkcsan_enable_current();\n\treturn true;\n}",
          "includes": [
            "#include <trace/events/printk.h>",
            "#include <linux/types.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/torture.h>",
            "#include <linux/timer.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kcsan-checks.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <kunit/test.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned long end_time;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/printk.h>\n#include <linux/types.h>\n#include <linux/tracepoint.h>\n#include <linux/torture.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/seqlock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/kcsan-checks.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <kunit/test.h>\n\nstatic unsigned long end_time;\n\nstatic __no_kcsan inline bool\nend_test_checks(bool stop)\n{\n\tif (!stop && time_before(jiffies, end_time)) {\n\t\t/* Continue checking */\n\t\tmight_sleep();\n\t\treturn false;\n\t}\n\n\tkcsan_enable_current();\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "report_matches",
          "args": [
            "&expect"
          ],
          "line": 964
        },
        "resolved": true,
        "details": {
          "function_name": "report_matches_any_reordered",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/kcsan_test.c",
          "lines": "277-284",
          "snippet": "__no_kcsan\nstatic bool report_matches_any_reordered(struct expect_report *r)\n{\n\treturn __report_matches(__report_set_scoped(r, 0)) ||\n\t       __report_matches(__report_set_scoped(r, 1)) ||\n\t       __report_matches(__report_set_scoped(r, 2)) ||\n\t       __report_matches(__report_set_scoped(r, 3));\n}",
          "includes": [
            "#include <trace/events/printk.h>",
            "#include <linux/types.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/torture.h>",
            "#include <linux/timer.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kcsan-checks.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <kunit/test.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline const struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/printk.h>\n#include <linux/types.h>\n#include <linux/tracepoint.h>\n#include <linux/torture.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/seqlock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/kcsan-checks.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <kunit/test.h>\n\nstatic __always_inline const struct;\n\n__no_kcsan\nstatic bool report_matches_any_reordered(struct expect_report *r)\n{\n\treturn __report_matches(__report_set_scoped(r, 0)) ||\n\t       __report_matches(__report_set_scoped(r, 1)) ||\n\t       __report_matches(__report_set_scoped(r, 2)) ||\n\t       __report_matches(__report_set_scoped(r, 3));\n}"
        }
      },
      {
        "call_info": {
          "callee": "begin_test_checks",
          "args": [
            "test_kernel_read",
            "test_kernel_atomic_rmw"
          ],
          "line": 962
        },
        "resolved": true,
        "details": {
          "function_name": "begin_test_checks",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/kcsan_test.c",
          "lines": "62-76",
          "snippet": "static __no_kcsan inline void\nbegin_test_checks(void (*func1)(void), void (*func2)(void))\n{\n\tkcsan_disable_current();\n\n\t/*\n\t * Require at least as long as KCSAN_REPORT_ONCE_IN_MS, to ensure at\n\t * least one race is reported.\n\t */\n\tend_time = jiffies + msecs_to_jiffies(CONFIG_KCSAN_REPORT_ONCE_IN_MS + 500);\n\n\t/* Signal start; release potential initialization of shared data. */\n\tsmp_store_release(&access_kernels[0], func1);\n\tsmp_store_release(&access_kernels[1], func2);\n}",
          "includes": [
            "#include <trace/events/printk.h>",
            "#include <linux/types.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/torture.h>",
            "#include <linux/timer.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kcsan-checks.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <kunit/test.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void (*access_kernels[2])(void);",
            "static unsigned long end_time;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/printk.h>\n#include <linux/types.h>\n#include <linux/tracepoint.h>\n#include <linux/torture.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/seqlock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/kcsan-checks.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <kunit/test.h>\n\nstatic void (*access_kernels[2])(void);\nstatic unsigned long end_time;\n\nstatic __no_kcsan inline void\nbegin_test_checks(void (*func1)(void), void (*func2)(void))\n{\n\tkcsan_disable_current();\n\n\t/*\n\t * Require at least as long as KCSAN_REPORT_ONCE_IN_MS, to ensure at\n\t * least one race is reported.\n\t */\n\tend_time = jiffies + msecs_to_jiffies(CONFIG_KCSAN_REPORT_ONCE_IN_MS + 500);\n\n\t/* Signal start; release potential initialization of shared data. */\n\tsmp_store_release(&access_kernels[0], func1);\n\tsmp_store_release(&access_kernels[1], func2);\n}"
        }
      },
      {
        "call_info": {
          "callee": "KCSAN_TEST_REQUIRES",
          "args": [
            "test",
            "!IS_ENABLED(CONFIG_KCSAN_IGNORE_ATOMICS)"
          ],
          "line": 960
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_KCSAN_IGNORE_ATOMICS"
          ],
          "line": 960
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/printk.h>\n#include <linux/types.h>\n#include <linux/tracepoint.h>\n#include <linux/torture.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/seqlock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/kcsan-checks.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <kunit/test.h>\n\n#define report_matches __report_matches\n#define report_matches report_matches_any_reordered\n\nstatic __always_inline const struct;\nstatic long test_var;\n\n__no_kcsan\nstatic void test_read_plain_atomic_rmw(struct kunit *test)\n{\n\tstruct expect_report expect = {\n\t\t.access = {\n\t\t\t{ test_kernel_read, &test_var, sizeof(test_var), 0 },\n\t\t\t{ test_kernel_atomic_rmw, &test_var, sizeof(test_var),\n\t\t\t\tKCSAN_ACCESS_COMPOUND | KCSAN_ACCESS_WRITE | KCSAN_ACCESS_ATOMIC },\n\t\t},\n\t};\n\tbool match_expect = false;\n\n\tKCSAN_TEST_REQUIRES(test, !IS_ENABLED(CONFIG_KCSAN_IGNORE_ATOMICS));\n\n\tbegin_test_checks(test_kernel_read, test_kernel_atomic_rmw);\n\tdo {\n\t\tmatch_expect = report_matches(&expect);\n\t} while (!end_test_checks(match_expect));\n\tKUNIT_EXPECT_TRUE(test, match_expect);\n}"
  },
  {
    "function_name": "test_read_plain_atomic_write",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/kcsan_test.c",
    "lines": "927-945",
    "snippet": "__no_kcsan\nstatic void test_read_plain_atomic_write(struct kunit *test)\n{\n\tstruct expect_report expect = {\n\t\t.access = {\n\t\t\t{ test_kernel_read, &test_var, sizeof(test_var), 0 },\n\t\t\t{ test_kernel_write_atomic, &test_var, sizeof(test_var), KCSAN_ACCESS_WRITE | KCSAN_ACCESS_ATOMIC },\n\t\t},\n\t};\n\tbool match_expect = false;\n\n\tKCSAN_TEST_REQUIRES(test, !IS_ENABLED(CONFIG_KCSAN_IGNORE_ATOMICS));\n\n\tbegin_test_checks(test_kernel_read, test_kernel_write_atomic);\n\tdo {\n\t\tmatch_expect = report_matches(&expect);\n\t} while (!end_test_checks(match_expect));\n\tKUNIT_EXPECT_TRUE(test, match_expect);\n}",
    "includes": [
      "#include <trace/events/printk.h>",
      "#include <linux/types.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/torture.h>",
      "#include <linux/timer.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kcsan-checks.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <kunit/test.h>"
    ],
    "macros_used": [
      "#define report_matches __report_matches",
      "#define report_matches report_matches_any_reordered"
    ],
    "globals_used": [
      "static __always_inline const struct",
      "static long test_var;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "KUNIT_EXPECT_TRUE",
          "args": [
            "test",
            "match_expect"
          ],
          "line": 944
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "end_test_checks",
          "args": [
            "match_expect"
          ],
          "line": 943
        },
        "resolved": true,
        "details": {
          "function_name": "end_test_checks",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/kcsan_test.c",
          "lines": "79-90",
          "snippet": "static __no_kcsan inline bool\nend_test_checks(bool stop)\n{\n\tif (!stop && time_before(jiffies, end_time)) {\n\t\t/* Continue checking */\n\t\tmight_sleep();\n\t\treturn false;\n\t}\n\n\tkcsan_enable_current();\n\treturn true;\n}",
          "includes": [
            "#include <trace/events/printk.h>",
            "#include <linux/types.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/torture.h>",
            "#include <linux/timer.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kcsan-checks.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <kunit/test.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned long end_time;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/printk.h>\n#include <linux/types.h>\n#include <linux/tracepoint.h>\n#include <linux/torture.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/seqlock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/kcsan-checks.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <kunit/test.h>\n\nstatic unsigned long end_time;\n\nstatic __no_kcsan inline bool\nend_test_checks(bool stop)\n{\n\tif (!stop && time_before(jiffies, end_time)) {\n\t\t/* Continue checking */\n\t\tmight_sleep();\n\t\treturn false;\n\t}\n\n\tkcsan_enable_current();\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "report_matches",
          "args": [
            "&expect"
          ],
          "line": 942
        },
        "resolved": true,
        "details": {
          "function_name": "report_matches_any_reordered",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/kcsan_test.c",
          "lines": "277-284",
          "snippet": "__no_kcsan\nstatic bool report_matches_any_reordered(struct expect_report *r)\n{\n\treturn __report_matches(__report_set_scoped(r, 0)) ||\n\t       __report_matches(__report_set_scoped(r, 1)) ||\n\t       __report_matches(__report_set_scoped(r, 2)) ||\n\t       __report_matches(__report_set_scoped(r, 3));\n}",
          "includes": [
            "#include <trace/events/printk.h>",
            "#include <linux/types.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/torture.h>",
            "#include <linux/timer.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kcsan-checks.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <kunit/test.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline const struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/printk.h>\n#include <linux/types.h>\n#include <linux/tracepoint.h>\n#include <linux/torture.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/seqlock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/kcsan-checks.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <kunit/test.h>\n\nstatic __always_inline const struct;\n\n__no_kcsan\nstatic bool report_matches_any_reordered(struct expect_report *r)\n{\n\treturn __report_matches(__report_set_scoped(r, 0)) ||\n\t       __report_matches(__report_set_scoped(r, 1)) ||\n\t       __report_matches(__report_set_scoped(r, 2)) ||\n\t       __report_matches(__report_set_scoped(r, 3));\n}"
        }
      },
      {
        "call_info": {
          "callee": "begin_test_checks",
          "args": [
            "test_kernel_read",
            "test_kernel_write_atomic"
          ],
          "line": 940
        },
        "resolved": true,
        "details": {
          "function_name": "begin_test_checks",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/kcsan_test.c",
          "lines": "62-76",
          "snippet": "static __no_kcsan inline void\nbegin_test_checks(void (*func1)(void), void (*func2)(void))\n{\n\tkcsan_disable_current();\n\n\t/*\n\t * Require at least as long as KCSAN_REPORT_ONCE_IN_MS, to ensure at\n\t * least one race is reported.\n\t */\n\tend_time = jiffies + msecs_to_jiffies(CONFIG_KCSAN_REPORT_ONCE_IN_MS + 500);\n\n\t/* Signal start; release potential initialization of shared data. */\n\tsmp_store_release(&access_kernels[0], func1);\n\tsmp_store_release(&access_kernels[1], func2);\n}",
          "includes": [
            "#include <trace/events/printk.h>",
            "#include <linux/types.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/torture.h>",
            "#include <linux/timer.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kcsan-checks.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <kunit/test.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void (*access_kernels[2])(void);",
            "static unsigned long end_time;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/printk.h>\n#include <linux/types.h>\n#include <linux/tracepoint.h>\n#include <linux/torture.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/seqlock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/kcsan-checks.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <kunit/test.h>\n\nstatic void (*access_kernels[2])(void);\nstatic unsigned long end_time;\n\nstatic __no_kcsan inline void\nbegin_test_checks(void (*func1)(void), void (*func2)(void))\n{\n\tkcsan_disable_current();\n\n\t/*\n\t * Require at least as long as KCSAN_REPORT_ONCE_IN_MS, to ensure at\n\t * least one race is reported.\n\t */\n\tend_time = jiffies + msecs_to_jiffies(CONFIG_KCSAN_REPORT_ONCE_IN_MS + 500);\n\n\t/* Signal start; release potential initialization of shared data. */\n\tsmp_store_release(&access_kernels[0], func1);\n\tsmp_store_release(&access_kernels[1], func2);\n}"
        }
      },
      {
        "call_info": {
          "callee": "KCSAN_TEST_REQUIRES",
          "args": [
            "test",
            "!IS_ENABLED(CONFIG_KCSAN_IGNORE_ATOMICS)"
          ],
          "line": 938
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_KCSAN_IGNORE_ATOMICS"
          ],
          "line": 938
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/printk.h>\n#include <linux/types.h>\n#include <linux/tracepoint.h>\n#include <linux/torture.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/seqlock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/kcsan-checks.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <kunit/test.h>\n\n#define report_matches __report_matches\n#define report_matches report_matches_any_reordered\n\nstatic __always_inline const struct;\nstatic long test_var;\n\n__no_kcsan\nstatic void test_read_plain_atomic_write(struct kunit *test)\n{\n\tstruct expect_report expect = {\n\t\t.access = {\n\t\t\t{ test_kernel_read, &test_var, sizeof(test_var), 0 },\n\t\t\t{ test_kernel_write_atomic, &test_var, sizeof(test_var), KCSAN_ACCESS_WRITE | KCSAN_ACCESS_ATOMIC },\n\t\t},\n\t};\n\tbool match_expect = false;\n\n\tKCSAN_TEST_REQUIRES(test, !IS_ENABLED(CONFIG_KCSAN_IGNORE_ATOMICS));\n\n\tbegin_test_checks(test_kernel_read, test_kernel_write_atomic);\n\tdo {\n\t\tmatch_expect = report_matches(&expect);\n\t} while (!end_test_checks(match_expect));\n\tKUNIT_EXPECT_TRUE(test, match_expect);\n}"
  },
  {
    "function_name": "test_read_atomic_write_atomic",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/kcsan_test.c",
    "lines": "914-924",
    "snippet": "__no_kcsan\nstatic void test_read_atomic_write_atomic(struct kunit *test)\n{\n\tbool match_never = false;\n\n\tbegin_test_checks(test_kernel_read_atomic, test_kernel_write_atomic);\n\tdo {\n\t\tmatch_never = report_available();\n\t} while (!end_test_checks(match_never));\n\tKUNIT_EXPECT_FALSE(test, match_never);\n}",
    "includes": [
      "#include <trace/events/printk.h>",
      "#include <linux/types.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/torture.h>",
      "#include <linux/timer.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kcsan-checks.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <kunit/test.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline const struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "KUNIT_EXPECT_FALSE",
          "args": [
            "test",
            "match_never"
          ],
          "line": 923
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "end_test_checks",
          "args": [
            "match_never"
          ],
          "line": 922
        },
        "resolved": true,
        "details": {
          "function_name": "end_test_checks",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/kcsan_test.c",
          "lines": "79-90",
          "snippet": "static __no_kcsan inline bool\nend_test_checks(bool stop)\n{\n\tif (!stop && time_before(jiffies, end_time)) {\n\t\t/* Continue checking */\n\t\tmight_sleep();\n\t\treturn false;\n\t}\n\n\tkcsan_enable_current();\n\treturn true;\n}",
          "includes": [
            "#include <trace/events/printk.h>",
            "#include <linux/types.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/torture.h>",
            "#include <linux/timer.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kcsan-checks.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <kunit/test.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned long end_time;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/printk.h>\n#include <linux/types.h>\n#include <linux/tracepoint.h>\n#include <linux/torture.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/seqlock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/kcsan-checks.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <kunit/test.h>\n\nstatic unsigned long end_time;\n\nstatic __no_kcsan inline bool\nend_test_checks(bool stop)\n{\n\tif (!stop && time_before(jiffies, end_time)) {\n\t\t/* Continue checking */\n\t\tmight_sleep();\n\t\treturn false;\n\t}\n\n\tkcsan_enable_current();\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "report_available",
          "args": [],
          "line": 921
        },
        "resolved": true,
        "details": {
          "function_name": "report_available",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/kcsan_test.c",
          "lines": "138-142",
          "snippet": "__no_kcsan\nstatic bool report_available(void)\n{\n\treturn READ_ONCE(observed.nlines) == ARRAY_SIZE(observed.lines);\n}",
          "includes": [
            "#include <trace/events/printk.h>",
            "#include <linux/types.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/torture.h>",
            "#include <linux/timer.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kcsan-checks.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <kunit/test.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct {\n\tspinlock_t lock;\n\tint nlines;\n\tchar lines[3][512];\n} observed = {\n\t.lock = __SPIN_LOCK_UNLOCKED(observed.lock),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/printk.h>\n#include <linux/types.h>\n#include <linux/tracepoint.h>\n#include <linux/torture.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/seqlock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/kcsan-checks.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <kunit/test.h>\n\nstatic struct {\n\tspinlock_t lock;\n\tint nlines;\n\tchar lines[3][512];\n} observed = {\n\t.lock = __SPIN_LOCK_UNLOCKED(observed.lock),\n};\n\n__no_kcsan\nstatic bool report_available(void)\n{\n\treturn READ_ONCE(observed.nlines) == ARRAY_SIZE(observed.lines);\n}"
        }
      },
      {
        "call_info": {
          "callee": "begin_test_checks",
          "args": [
            "test_kernel_read_atomic",
            "test_kernel_write_atomic"
          ],
          "line": 919
        },
        "resolved": true,
        "details": {
          "function_name": "begin_test_checks",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/kcsan_test.c",
          "lines": "62-76",
          "snippet": "static __no_kcsan inline void\nbegin_test_checks(void (*func1)(void), void (*func2)(void))\n{\n\tkcsan_disable_current();\n\n\t/*\n\t * Require at least as long as KCSAN_REPORT_ONCE_IN_MS, to ensure at\n\t * least one race is reported.\n\t */\n\tend_time = jiffies + msecs_to_jiffies(CONFIG_KCSAN_REPORT_ONCE_IN_MS + 500);\n\n\t/* Signal start; release potential initialization of shared data. */\n\tsmp_store_release(&access_kernels[0], func1);\n\tsmp_store_release(&access_kernels[1], func2);\n}",
          "includes": [
            "#include <trace/events/printk.h>",
            "#include <linux/types.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/torture.h>",
            "#include <linux/timer.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kcsan-checks.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <kunit/test.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void (*access_kernels[2])(void);",
            "static unsigned long end_time;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/printk.h>\n#include <linux/types.h>\n#include <linux/tracepoint.h>\n#include <linux/torture.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/seqlock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/kcsan-checks.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <kunit/test.h>\n\nstatic void (*access_kernels[2])(void);\nstatic unsigned long end_time;\n\nstatic __no_kcsan inline void\nbegin_test_checks(void (*func1)(void), void (*func2)(void))\n{\n\tkcsan_disable_current();\n\n\t/*\n\t * Require at least as long as KCSAN_REPORT_ONCE_IN_MS, to ensure at\n\t * least one race is reported.\n\t */\n\tend_time = jiffies + msecs_to_jiffies(CONFIG_KCSAN_REPORT_ONCE_IN_MS + 500);\n\n\t/* Signal start; release potential initialization of shared data. */\n\tsmp_store_release(&access_kernels[0], func1);\n\tsmp_store_release(&access_kernels[1], func2);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/printk.h>\n#include <linux/types.h>\n#include <linux/tracepoint.h>\n#include <linux/torture.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/seqlock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/kcsan-checks.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <kunit/test.h>\n\nstatic __always_inline const struct;\n\n__no_kcsan\nstatic void test_read_atomic_write_atomic(struct kunit *test)\n{\n\tbool match_never = false;\n\n\tbegin_test_checks(test_kernel_read_atomic, test_kernel_write_atomic);\n\tdo {\n\t\tmatch_never = report_available();\n\t} while (!end_test_checks(match_never));\n\tKUNIT_EXPECT_FALSE(test, match_never);\n}"
  },
  {
    "function_name": "test_write_write_struct_part",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/kcsan_test.c",
    "lines": "895-911",
    "snippet": "__no_kcsan\nstatic void test_write_write_struct_part(struct kunit *test)\n{\n\tstruct expect_report expect = {\n\t\t.access = {\n\t\t\t{ test_kernel_write_struct, &test_struct, sizeof(test_struct), KCSAN_ACCESS_WRITE },\n\t\t\t{ test_kernel_write_struct_part, &test_struct.val[3], sizeof(test_struct.val[3]), KCSAN_ACCESS_WRITE },\n\t\t},\n\t};\n\tbool match_expect = false;\n\n\tbegin_test_checks(test_kernel_write_struct, test_kernel_write_struct_part);\n\tdo {\n\t\tmatch_expect = report_matches(&expect);\n\t} while (!end_test_checks(match_expect));\n\tKUNIT_EXPECT_TRUE(test, match_expect);\n}",
    "includes": [
      "#include <trace/events/printk.h>",
      "#include <linux/types.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/torture.h>",
      "#include <linux/timer.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kcsan-checks.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <kunit/test.h>"
    ],
    "macros_used": [
      "#define report_matches __report_matches",
      "#define report_matches report_matches_any_reordered"
    ],
    "globals_used": [
      "static __always_inline const struct",
      "static struct {\n\tlong val[8];\n} test_struct;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "KUNIT_EXPECT_TRUE",
          "args": [
            "test",
            "match_expect"
          ],
          "line": 910
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "end_test_checks",
          "args": [
            "match_expect"
          ],
          "line": 909
        },
        "resolved": true,
        "details": {
          "function_name": "end_test_checks",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/kcsan_test.c",
          "lines": "79-90",
          "snippet": "static __no_kcsan inline bool\nend_test_checks(bool stop)\n{\n\tif (!stop && time_before(jiffies, end_time)) {\n\t\t/* Continue checking */\n\t\tmight_sleep();\n\t\treturn false;\n\t}\n\n\tkcsan_enable_current();\n\treturn true;\n}",
          "includes": [
            "#include <trace/events/printk.h>",
            "#include <linux/types.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/torture.h>",
            "#include <linux/timer.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kcsan-checks.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <kunit/test.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned long end_time;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/printk.h>\n#include <linux/types.h>\n#include <linux/tracepoint.h>\n#include <linux/torture.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/seqlock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/kcsan-checks.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <kunit/test.h>\n\nstatic unsigned long end_time;\n\nstatic __no_kcsan inline bool\nend_test_checks(bool stop)\n{\n\tif (!stop && time_before(jiffies, end_time)) {\n\t\t/* Continue checking */\n\t\tmight_sleep();\n\t\treturn false;\n\t}\n\n\tkcsan_enable_current();\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "report_matches",
          "args": [
            "&expect"
          ],
          "line": 908
        },
        "resolved": true,
        "details": {
          "function_name": "report_matches_any_reordered",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/kcsan_test.c",
          "lines": "277-284",
          "snippet": "__no_kcsan\nstatic bool report_matches_any_reordered(struct expect_report *r)\n{\n\treturn __report_matches(__report_set_scoped(r, 0)) ||\n\t       __report_matches(__report_set_scoped(r, 1)) ||\n\t       __report_matches(__report_set_scoped(r, 2)) ||\n\t       __report_matches(__report_set_scoped(r, 3));\n}",
          "includes": [
            "#include <trace/events/printk.h>",
            "#include <linux/types.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/torture.h>",
            "#include <linux/timer.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kcsan-checks.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <kunit/test.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline const struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/printk.h>\n#include <linux/types.h>\n#include <linux/tracepoint.h>\n#include <linux/torture.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/seqlock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/kcsan-checks.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <kunit/test.h>\n\nstatic __always_inline const struct;\n\n__no_kcsan\nstatic bool report_matches_any_reordered(struct expect_report *r)\n{\n\treturn __report_matches(__report_set_scoped(r, 0)) ||\n\t       __report_matches(__report_set_scoped(r, 1)) ||\n\t       __report_matches(__report_set_scoped(r, 2)) ||\n\t       __report_matches(__report_set_scoped(r, 3));\n}"
        }
      },
      {
        "call_info": {
          "callee": "begin_test_checks",
          "args": [
            "test_kernel_write_struct",
            "test_kernel_write_struct_part"
          ],
          "line": 906
        },
        "resolved": true,
        "details": {
          "function_name": "begin_test_checks",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/kcsan_test.c",
          "lines": "62-76",
          "snippet": "static __no_kcsan inline void\nbegin_test_checks(void (*func1)(void), void (*func2)(void))\n{\n\tkcsan_disable_current();\n\n\t/*\n\t * Require at least as long as KCSAN_REPORT_ONCE_IN_MS, to ensure at\n\t * least one race is reported.\n\t */\n\tend_time = jiffies + msecs_to_jiffies(CONFIG_KCSAN_REPORT_ONCE_IN_MS + 500);\n\n\t/* Signal start; release potential initialization of shared data. */\n\tsmp_store_release(&access_kernels[0], func1);\n\tsmp_store_release(&access_kernels[1], func2);\n}",
          "includes": [
            "#include <trace/events/printk.h>",
            "#include <linux/types.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/torture.h>",
            "#include <linux/timer.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kcsan-checks.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <kunit/test.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void (*access_kernels[2])(void);",
            "static unsigned long end_time;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/printk.h>\n#include <linux/types.h>\n#include <linux/tracepoint.h>\n#include <linux/torture.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/seqlock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/kcsan-checks.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <kunit/test.h>\n\nstatic void (*access_kernels[2])(void);\nstatic unsigned long end_time;\n\nstatic __no_kcsan inline void\nbegin_test_checks(void (*func1)(void), void (*func2)(void))\n{\n\tkcsan_disable_current();\n\n\t/*\n\t * Require at least as long as KCSAN_REPORT_ONCE_IN_MS, to ensure at\n\t * least one race is reported.\n\t */\n\tend_time = jiffies + msecs_to_jiffies(CONFIG_KCSAN_REPORT_ONCE_IN_MS + 500);\n\n\t/* Signal start; release potential initialization of shared data. */\n\tsmp_store_release(&access_kernels[0], func1);\n\tsmp_store_release(&access_kernels[1], func2);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/printk.h>\n#include <linux/types.h>\n#include <linux/tracepoint.h>\n#include <linux/torture.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/seqlock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/kcsan-checks.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <kunit/test.h>\n\n#define report_matches __report_matches\n#define report_matches report_matches_any_reordered\n\nstatic __always_inline const struct;\nstatic struct {\n\tlong val[8];\n} test_struct;\n\n__no_kcsan\nstatic void test_write_write_struct_part(struct kunit *test)\n{\n\tstruct expect_report expect = {\n\t\t.access = {\n\t\t\t{ test_kernel_write_struct, &test_struct, sizeof(test_struct), KCSAN_ACCESS_WRITE },\n\t\t\t{ test_kernel_write_struct_part, &test_struct.val[3], sizeof(test_struct.val[3]), KCSAN_ACCESS_WRITE },\n\t\t},\n\t};\n\tbool match_expect = false;\n\n\tbegin_test_checks(test_kernel_write_struct, test_kernel_write_struct_part);\n\tdo {\n\t\tmatch_expect = report_matches(&expect);\n\t} while (!end_test_checks(match_expect));\n\tKUNIT_EXPECT_TRUE(test, match_expect);\n}"
  },
  {
    "function_name": "test_write_write_struct",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/kcsan_test.c",
    "lines": "873-889",
    "snippet": "__no_kcsan\nstatic void test_write_write_struct(struct kunit *test)\n{\n\tstruct expect_report expect = {\n\t\t.access = {\n\t\t\t{ test_kernel_write_struct, &test_struct, sizeof(test_struct), KCSAN_ACCESS_WRITE },\n\t\t\t{ test_kernel_write_struct, &test_struct, sizeof(test_struct), KCSAN_ACCESS_WRITE },\n\t\t},\n\t};\n\tbool match_expect = false;\n\n\tbegin_test_checks(test_kernel_write_struct, test_kernel_write_struct);\n\tdo {\n\t\tmatch_expect = report_matches(&expect);\n\t} while (!end_test_checks(match_expect));\n\tKUNIT_EXPECT_TRUE(test, match_expect);\n}",
    "includes": [
      "#include <trace/events/printk.h>",
      "#include <linux/types.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/torture.h>",
      "#include <linux/timer.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kcsan-checks.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <kunit/test.h>"
    ],
    "macros_used": [
      "#define report_matches __report_matches",
      "#define report_matches report_matches_any_reordered"
    ],
    "globals_used": [
      "static __always_inline const struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "KUNIT_EXPECT_TRUE",
          "args": [
            "test",
            "match_expect"
          ],
          "line": 888
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "end_test_checks",
          "args": [
            "match_expect"
          ],
          "line": 887
        },
        "resolved": true,
        "details": {
          "function_name": "end_test_checks",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/kcsan_test.c",
          "lines": "79-90",
          "snippet": "static __no_kcsan inline bool\nend_test_checks(bool stop)\n{\n\tif (!stop && time_before(jiffies, end_time)) {\n\t\t/* Continue checking */\n\t\tmight_sleep();\n\t\treturn false;\n\t}\n\n\tkcsan_enable_current();\n\treturn true;\n}",
          "includes": [
            "#include <trace/events/printk.h>",
            "#include <linux/types.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/torture.h>",
            "#include <linux/timer.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kcsan-checks.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <kunit/test.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned long end_time;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/printk.h>\n#include <linux/types.h>\n#include <linux/tracepoint.h>\n#include <linux/torture.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/seqlock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/kcsan-checks.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <kunit/test.h>\n\nstatic unsigned long end_time;\n\nstatic __no_kcsan inline bool\nend_test_checks(bool stop)\n{\n\tif (!stop && time_before(jiffies, end_time)) {\n\t\t/* Continue checking */\n\t\tmight_sleep();\n\t\treturn false;\n\t}\n\n\tkcsan_enable_current();\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "report_matches",
          "args": [
            "&expect"
          ],
          "line": 886
        },
        "resolved": true,
        "details": {
          "function_name": "report_matches_any_reordered",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/kcsan_test.c",
          "lines": "277-284",
          "snippet": "__no_kcsan\nstatic bool report_matches_any_reordered(struct expect_report *r)\n{\n\treturn __report_matches(__report_set_scoped(r, 0)) ||\n\t       __report_matches(__report_set_scoped(r, 1)) ||\n\t       __report_matches(__report_set_scoped(r, 2)) ||\n\t       __report_matches(__report_set_scoped(r, 3));\n}",
          "includes": [
            "#include <trace/events/printk.h>",
            "#include <linux/types.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/torture.h>",
            "#include <linux/timer.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kcsan-checks.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <kunit/test.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline const struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/printk.h>\n#include <linux/types.h>\n#include <linux/tracepoint.h>\n#include <linux/torture.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/seqlock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/kcsan-checks.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <kunit/test.h>\n\nstatic __always_inline const struct;\n\n__no_kcsan\nstatic bool report_matches_any_reordered(struct expect_report *r)\n{\n\treturn __report_matches(__report_set_scoped(r, 0)) ||\n\t       __report_matches(__report_set_scoped(r, 1)) ||\n\t       __report_matches(__report_set_scoped(r, 2)) ||\n\t       __report_matches(__report_set_scoped(r, 3));\n}"
        }
      },
      {
        "call_info": {
          "callee": "begin_test_checks",
          "args": [
            "test_kernel_write_struct",
            "test_kernel_write_struct"
          ],
          "line": 884
        },
        "resolved": true,
        "details": {
          "function_name": "begin_test_checks",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/kcsan_test.c",
          "lines": "62-76",
          "snippet": "static __no_kcsan inline void\nbegin_test_checks(void (*func1)(void), void (*func2)(void))\n{\n\tkcsan_disable_current();\n\n\t/*\n\t * Require at least as long as KCSAN_REPORT_ONCE_IN_MS, to ensure at\n\t * least one race is reported.\n\t */\n\tend_time = jiffies + msecs_to_jiffies(CONFIG_KCSAN_REPORT_ONCE_IN_MS + 500);\n\n\t/* Signal start; release potential initialization of shared data. */\n\tsmp_store_release(&access_kernels[0], func1);\n\tsmp_store_release(&access_kernels[1], func2);\n}",
          "includes": [
            "#include <trace/events/printk.h>",
            "#include <linux/types.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/torture.h>",
            "#include <linux/timer.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kcsan-checks.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <kunit/test.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void (*access_kernels[2])(void);",
            "static unsigned long end_time;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/printk.h>\n#include <linux/types.h>\n#include <linux/tracepoint.h>\n#include <linux/torture.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/seqlock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/kcsan-checks.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <kunit/test.h>\n\nstatic void (*access_kernels[2])(void);\nstatic unsigned long end_time;\n\nstatic __no_kcsan inline void\nbegin_test_checks(void (*func1)(void), void (*func2)(void))\n{\n\tkcsan_disable_current();\n\n\t/*\n\t * Require at least as long as KCSAN_REPORT_ONCE_IN_MS, to ensure at\n\t * least one race is reported.\n\t */\n\tend_time = jiffies + msecs_to_jiffies(CONFIG_KCSAN_REPORT_ONCE_IN_MS + 500);\n\n\t/* Signal start; release potential initialization of shared data. */\n\tsmp_store_release(&access_kernels[0], func1);\n\tsmp_store_release(&access_kernels[1], func2);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/printk.h>\n#include <linux/types.h>\n#include <linux/tracepoint.h>\n#include <linux/torture.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/seqlock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/kcsan-checks.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <kunit/test.h>\n\n#define report_matches __report_matches\n#define report_matches report_matches_any_reordered\n\nstatic __always_inline const struct;\n\n__no_kcsan\nstatic void test_write_write_struct(struct kunit *test)\n{\n\tstruct expect_report expect = {\n\t\t.access = {\n\t\t\t{ test_kernel_write_struct, &test_struct, sizeof(test_struct), KCSAN_ACCESS_WRITE },\n\t\t\t{ test_kernel_write_struct, &test_struct, sizeof(test_struct), KCSAN_ACCESS_WRITE },\n\t\t},\n\t};\n\tbool match_expect = false;\n\n\tbegin_test_checks(test_kernel_write_struct, test_kernel_write_struct);\n\tdo {\n\t\tmatch_expect = report_matches(&expect);\n\t} while (!end_test_checks(match_expect));\n\tKUNIT_EXPECT_TRUE(test, match_expect);\n}"
  },
  {
    "function_name": "test_write_write_assume_atomic",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/kcsan_test.c",
    "lines": "847-867",
    "snippet": "__no_kcsan\nstatic void test_write_write_assume_atomic(struct kunit *test)\n{\n\tstruct expect_report expect = {\n\t\t.access = {\n\t\t\t{ test_kernel_write, &test_var, sizeof(test_var), KCSAN_ACCESS_WRITE },\n\t\t\t{ test_kernel_write, &test_var, sizeof(test_var), KCSAN_ACCESS_WRITE },\n\t\t},\n\t};\n\tbool match_expect = false;\n\n\tbegin_test_checks(test_kernel_write, test_kernel_write);\n\tdo {\n\t\tsink_value(READ_ONCE(test_var)); /* induce value-change */\n\t\tmatch_expect = report_matches(&expect);\n\t} while (!end_test_checks(match_expect));\n\tif (IS_ENABLED(CONFIG_KCSAN_ASSUME_PLAIN_WRITES_ATOMIC))\n\t\tKUNIT_EXPECT_FALSE(test, match_expect);\n\telse\n\t\tKUNIT_EXPECT_TRUE(test, match_expect);\n}",
    "includes": [
      "#include <trace/events/printk.h>",
      "#include <linux/types.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/torture.h>",
      "#include <linux/timer.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kcsan-checks.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <kunit/test.h>"
    ],
    "macros_used": [
      "#define report_matches __report_matches",
      "#define report_matches report_matches_any_reordered"
    ],
    "globals_used": [
      "static __always_inline const struct",
      "static long test_var;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "KUNIT_EXPECT_TRUE",
          "args": [
            "test",
            "match_expect"
          ],
          "line": 866
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KUNIT_EXPECT_FALSE",
          "args": [
            "test",
            "match_expect"
          ],
          "line": 864
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_KCSAN_ASSUME_PLAIN_WRITES_ATOMIC"
          ],
          "line": 863
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "end_test_checks",
          "args": [
            "match_expect"
          ],
          "line": 862
        },
        "resolved": true,
        "details": {
          "function_name": "end_test_checks",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/kcsan_test.c",
          "lines": "79-90",
          "snippet": "static __no_kcsan inline bool\nend_test_checks(bool stop)\n{\n\tif (!stop && time_before(jiffies, end_time)) {\n\t\t/* Continue checking */\n\t\tmight_sleep();\n\t\treturn false;\n\t}\n\n\tkcsan_enable_current();\n\treturn true;\n}",
          "includes": [
            "#include <trace/events/printk.h>",
            "#include <linux/types.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/torture.h>",
            "#include <linux/timer.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kcsan-checks.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <kunit/test.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned long end_time;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/printk.h>\n#include <linux/types.h>\n#include <linux/tracepoint.h>\n#include <linux/torture.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/seqlock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/kcsan-checks.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <kunit/test.h>\n\nstatic unsigned long end_time;\n\nstatic __no_kcsan inline bool\nend_test_checks(bool stop)\n{\n\tif (!stop && time_before(jiffies, end_time)) {\n\t\t/* Continue checking */\n\t\tmight_sleep();\n\t\treturn false;\n\t}\n\n\tkcsan_enable_current();\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "report_matches",
          "args": [
            "&expect"
          ],
          "line": 861
        },
        "resolved": true,
        "details": {
          "function_name": "report_matches_any_reordered",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/kcsan_test.c",
          "lines": "277-284",
          "snippet": "__no_kcsan\nstatic bool report_matches_any_reordered(struct expect_report *r)\n{\n\treturn __report_matches(__report_set_scoped(r, 0)) ||\n\t       __report_matches(__report_set_scoped(r, 1)) ||\n\t       __report_matches(__report_set_scoped(r, 2)) ||\n\t       __report_matches(__report_set_scoped(r, 3));\n}",
          "includes": [
            "#include <trace/events/printk.h>",
            "#include <linux/types.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/torture.h>",
            "#include <linux/timer.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kcsan-checks.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <kunit/test.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline const struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/printk.h>\n#include <linux/types.h>\n#include <linux/tracepoint.h>\n#include <linux/torture.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/seqlock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/kcsan-checks.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <kunit/test.h>\n\nstatic __always_inline const struct;\n\n__no_kcsan\nstatic bool report_matches_any_reordered(struct expect_report *r)\n{\n\treturn __report_matches(__report_set_scoped(r, 0)) ||\n\t       __report_matches(__report_set_scoped(r, 1)) ||\n\t       __report_matches(__report_set_scoped(r, 2)) ||\n\t       __report_matches(__report_set_scoped(r, 3));\n}"
        }
      },
      {
        "call_info": {
          "callee": "sink_value",
          "args": [
            "READ_ONCE(test_var)"
          ],
          "line": 860
        },
        "resolved": true,
        "details": {
          "function_name": "sink_value",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/kcsan_test.c",
          "lines": "311-311",
          "snippet": "void sink_value(long v) { WRITE_ONCE(test_sink, v); }",
          "includes": [
            "#include <trace/events/printk.h>",
            "#include <linux/types.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/torture.h>",
            "#include <linux/timer.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kcsan-checks.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <kunit/test.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static long test_sink;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/printk.h>\n#include <linux/types.h>\n#include <linux/tracepoint.h>\n#include <linux/torture.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/seqlock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/kcsan-checks.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <kunit/test.h>\n\nstatic long test_sink;\n\nvoid sink_value(long v) { WRITE_ONCE(test_sink, v); }"
        }
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "test_var"
          ],
          "line": 860
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "begin_test_checks",
          "args": [
            "test_kernel_write",
            "test_kernel_write"
          ],
          "line": 858
        },
        "resolved": true,
        "details": {
          "function_name": "begin_test_checks",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/kcsan_test.c",
          "lines": "62-76",
          "snippet": "static __no_kcsan inline void\nbegin_test_checks(void (*func1)(void), void (*func2)(void))\n{\n\tkcsan_disable_current();\n\n\t/*\n\t * Require at least as long as KCSAN_REPORT_ONCE_IN_MS, to ensure at\n\t * least one race is reported.\n\t */\n\tend_time = jiffies + msecs_to_jiffies(CONFIG_KCSAN_REPORT_ONCE_IN_MS + 500);\n\n\t/* Signal start; release potential initialization of shared data. */\n\tsmp_store_release(&access_kernels[0], func1);\n\tsmp_store_release(&access_kernels[1], func2);\n}",
          "includes": [
            "#include <trace/events/printk.h>",
            "#include <linux/types.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/torture.h>",
            "#include <linux/timer.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kcsan-checks.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <kunit/test.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void (*access_kernels[2])(void);",
            "static unsigned long end_time;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/printk.h>\n#include <linux/types.h>\n#include <linux/tracepoint.h>\n#include <linux/torture.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/seqlock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/kcsan-checks.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <kunit/test.h>\n\nstatic void (*access_kernels[2])(void);\nstatic unsigned long end_time;\n\nstatic __no_kcsan inline void\nbegin_test_checks(void (*func1)(void), void (*func2)(void))\n{\n\tkcsan_disable_current();\n\n\t/*\n\t * Require at least as long as KCSAN_REPORT_ONCE_IN_MS, to ensure at\n\t * least one race is reported.\n\t */\n\tend_time = jiffies + msecs_to_jiffies(CONFIG_KCSAN_REPORT_ONCE_IN_MS + 500);\n\n\t/* Signal start; release potential initialization of shared data. */\n\tsmp_store_release(&access_kernels[0], func1);\n\tsmp_store_release(&access_kernels[1], func2);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/printk.h>\n#include <linux/types.h>\n#include <linux/tracepoint.h>\n#include <linux/torture.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/seqlock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/kcsan-checks.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <kunit/test.h>\n\n#define report_matches __report_matches\n#define report_matches report_matches_any_reordered\n\nstatic __always_inline const struct;\nstatic long test_var;\n\n__no_kcsan\nstatic void test_write_write_assume_atomic(struct kunit *test)\n{\n\tstruct expect_report expect = {\n\t\t.access = {\n\t\t\t{ test_kernel_write, &test_var, sizeof(test_var), KCSAN_ACCESS_WRITE },\n\t\t\t{ test_kernel_write, &test_var, sizeof(test_var), KCSAN_ACCESS_WRITE },\n\t\t},\n\t};\n\tbool match_expect = false;\n\n\tbegin_test_checks(test_kernel_write, test_kernel_write);\n\tdo {\n\t\tsink_value(READ_ONCE(test_var)); /* induce value-change */\n\t\tmatch_expect = report_matches(&expect);\n\t} while (!end_test_checks(match_expect));\n\tif (IS_ENABLED(CONFIG_KCSAN_ASSUME_PLAIN_WRITES_ATOMIC))\n\t\tKUNIT_EXPECT_FALSE(test, match_expect);\n\telse\n\t\tKUNIT_EXPECT_TRUE(test, match_expect);\n}"
  },
  {
    "function_name": "test_unknown_origin",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/kcsan_test.c",
    "lines": "825-844",
    "snippet": "__no_kcsan\nstatic void test_unknown_origin(struct kunit *test)\n{\n\tstruct expect_report expect = {\n\t\t.access = {\n\t\t\t{ test_kernel_read, &test_var, sizeof(test_var), 0 },\n\t\t\t{ NULL },\n\t\t},\n\t};\n\tbool match_expect = false;\n\n\tbegin_test_checks(test_kernel_write_uninstrumented, test_kernel_read);\n\tdo {\n\t\tmatch_expect = report_matches(&expect);\n\t} while (!end_test_checks(match_expect));\n\tif (IS_ENABLED(CONFIG_KCSAN_REPORT_RACE_UNKNOWN_ORIGIN))\n\t\tKUNIT_EXPECT_TRUE(test, match_expect);\n\telse\n\t\tKUNIT_EXPECT_FALSE(test, match_expect);\n}",
    "includes": [
      "#include <trace/events/printk.h>",
      "#include <linux/types.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/torture.h>",
      "#include <linux/timer.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kcsan-checks.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <kunit/test.h>"
    ],
    "macros_used": [
      "#define report_matches __report_matches",
      "#define report_matches report_matches_any_reordered"
    ],
    "globals_used": [
      "static __always_inline const struct",
      "static long test_var;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "KUNIT_EXPECT_FALSE",
          "args": [
            "test",
            "match_expect"
          ],
          "line": 843
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KUNIT_EXPECT_TRUE",
          "args": [
            "test",
            "match_expect"
          ],
          "line": 841
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_KCSAN_REPORT_RACE_UNKNOWN_ORIGIN"
          ],
          "line": 840
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "end_test_checks",
          "args": [
            "match_expect"
          ],
          "line": 839
        },
        "resolved": true,
        "details": {
          "function_name": "end_test_checks",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/kcsan_test.c",
          "lines": "79-90",
          "snippet": "static __no_kcsan inline bool\nend_test_checks(bool stop)\n{\n\tif (!stop && time_before(jiffies, end_time)) {\n\t\t/* Continue checking */\n\t\tmight_sleep();\n\t\treturn false;\n\t}\n\n\tkcsan_enable_current();\n\treturn true;\n}",
          "includes": [
            "#include <trace/events/printk.h>",
            "#include <linux/types.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/torture.h>",
            "#include <linux/timer.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kcsan-checks.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <kunit/test.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned long end_time;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/printk.h>\n#include <linux/types.h>\n#include <linux/tracepoint.h>\n#include <linux/torture.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/seqlock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/kcsan-checks.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <kunit/test.h>\n\nstatic unsigned long end_time;\n\nstatic __no_kcsan inline bool\nend_test_checks(bool stop)\n{\n\tif (!stop && time_before(jiffies, end_time)) {\n\t\t/* Continue checking */\n\t\tmight_sleep();\n\t\treturn false;\n\t}\n\n\tkcsan_enable_current();\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "report_matches",
          "args": [
            "&expect"
          ],
          "line": 838
        },
        "resolved": true,
        "details": {
          "function_name": "report_matches_any_reordered",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/kcsan_test.c",
          "lines": "277-284",
          "snippet": "__no_kcsan\nstatic bool report_matches_any_reordered(struct expect_report *r)\n{\n\treturn __report_matches(__report_set_scoped(r, 0)) ||\n\t       __report_matches(__report_set_scoped(r, 1)) ||\n\t       __report_matches(__report_set_scoped(r, 2)) ||\n\t       __report_matches(__report_set_scoped(r, 3));\n}",
          "includes": [
            "#include <trace/events/printk.h>",
            "#include <linux/types.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/torture.h>",
            "#include <linux/timer.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kcsan-checks.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <kunit/test.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline const struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/printk.h>\n#include <linux/types.h>\n#include <linux/tracepoint.h>\n#include <linux/torture.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/seqlock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/kcsan-checks.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <kunit/test.h>\n\nstatic __always_inline const struct;\n\n__no_kcsan\nstatic bool report_matches_any_reordered(struct expect_report *r)\n{\n\treturn __report_matches(__report_set_scoped(r, 0)) ||\n\t       __report_matches(__report_set_scoped(r, 1)) ||\n\t       __report_matches(__report_set_scoped(r, 2)) ||\n\t       __report_matches(__report_set_scoped(r, 3));\n}"
        }
      },
      {
        "call_info": {
          "callee": "begin_test_checks",
          "args": [
            "test_kernel_write_uninstrumented",
            "test_kernel_read"
          ],
          "line": 836
        },
        "resolved": true,
        "details": {
          "function_name": "begin_test_checks",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/kcsan_test.c",
          "lines": "62-76",
          "snippet": "static __no_kcsan inline void\nbegin_test_checks(void (*func1)(void), void (*func2)(void))\n{\n\tkcsan_disable_current();\n\n\t/*\n\t * Require at least as long as KCSAN_REPORT_ONCE_IN_MS, to ensure at\n\t * least one race is reported.\n\t */\n\tend_time = jiffies + msecs_to_jiffies(CONFIG_KCSAN_REPORT_ONCE_IN_MS + 500);\n\n\t/* Signal start; release potential initialization of shared data. */\n\tsmp_store_release(&access_kernels[0], func1);\n\tsmp_store_release(&access_kernels[1], func2);\n}",
          "includes": [
            "#include <trace/events/printk.h>",
            "#include <linux/types.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/torture.h>",
            "#include <linux/timer.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kcsan-checks.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <kunit/test.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void (*access_kernels[2])(void);",
            "static unsigned long end_time;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/printk.h>\n#include <linux/types.h>\n#include <linux/tracepoint.h>\n#include <linux/torture.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/seqlock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/kcsan-checks.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <kunit/test.h>\n\nstatic void (*access_kernels[2])(void);\nstatic unsigned long end_time;\n\nstatic __no_kcsan inline void\nbegin_test_checks(void (*func1)(void), void (*func2)(void))\n{\n\tkcsan_disable_current();\n\n\t/*\n\t * Require at least as long as KCSAN_REPORT_ONCE_IN_MS, to ensure at\n\t * least one race is reported.\n\t */\n\tend_time = jiffies + msecs_to_jiffies(CONFIG_KCSAN_REPORT_ONCE_IN_MS + 500);\n\n\t/* Signal start; release potential initialization of shared data. */\n\tsmp_store_release(&access_kernels[0], func1);\n\tsmp_store_release(&access_kernels[1], func2);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/printk.h>\n#include <linux/types.h>\n#include <linux/tracepoint.h>\n#include <linux/torture.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/seqlock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/kcsan-checks.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <kunit/test.h>\n\n#define report_matches __report_matches\n#define report_matches report_matches_any_reordered\n\nstatic __always_inline const struct;\nstatic long test_var;\n\n__no_kcsan\nstatic void test_unknown_origin(struct kunit *test)\n{\n\tstruct expect_report expect = {\n\t\t.access = {\n\t\t\t{ test_kernel_read, &test_var, sizeof(test_var), 0 },\n\t\t\t{ NULL },\n\t\t},\n\t};\n\tbool match_expect = false;\n\n\tbegin_test_checks(test_kernel_write_uninstrumented, test_kernel_read);\n\tdo {\n\t\tmatch_expect = report_matches(&expect);\n\t} while (!end_test_checks(match_expect));\n\tif (IS_ENABLED(CONFIG_KCSAN_REPORT_RACE_UNKNOWN_ORIGIN))\n\t\tKUNIT_EXPECT_TRUE(test, match_expect);\n\telse\n\t\tKUNIT_EXPECT_FALSE(test, match_expect);\n}"
  },
  {
    "function_name": "test_novalue_change_exception",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/kcsan_test.c",
    "lines": "799-822",
    "snippet": "__no_kcsan\nstatic void test_novalue_change_exception(struct kunit *test)\n{\n\tstruct expect_report expect_rw = {\n\t\t.access = {\n\t\t\t{ test_kernel_write_nochange_rcu, &test_var, sizeof(test_var), KCSAN_ACCESS_WRITE },\n\t\t\t{ test_kernel_read, &test_var, sizeof(test_var), 0 },\n\t\t},\n\t};\n\tstruct expect_report expect_ww = {\n\t\t.access = {\n\t\t\t{ test_kernel_write_nochange_rcu, &test_var, sizeof(test_var), KCSAN_ACCESS_WRITE },\n\t\t\t{ test_kernel_write_nochange_rcu, &test_var, sizeof(test_var), KCSAN_ACCESS_WRITE },\n\t\t},\n\t};\n\tbool match_expect = false;\n\n\ttest_kernel_write_nochange_rcu(); /* Reset value. */\n\tbegin_test_checks(test_kernel_write_nochange_rcu, test_kernel_read);\n\tdo {\n\t\tmatch_expect = report_matches(&expect_rw) || report_matches(&expect_ww);\n\t} while (!end_test_checks(match_expect));\n\tKUNIT_EXPECT_TRUE(test, match_expect);\n}",
    "includes": [
      "#include <trace/events/printk.h>",
      "#include <linux/types.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/torture.h>",
      "#include <linux/timer.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kcsan-checks.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <kunit/test.h>"
    ],
    "macros_used": [
      "#define report_matches __report_matches",
      "#define report_matches report_matches_any_reordered"
    ],
    "globals_used": [
      "static __always_inline const struct",
      "static long test_var;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "KUNIT_EXPECT_TRUE",
          "args": [
            "test",
            "match_expect"
          ],
          "line": 821
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "end_test_checks",
          "args": [
            "match_expect"
          ],
          "line": 820
        },
        "resolved": true,
        "details": {
          "function_name": "end_test_checks",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/kcsan_test.c",
          "lines": "79-90",
          "snippet": "static __no_kcsan inline bool\nend_test_checks(bool stop)\n{\n\tif (!stop && time_before(jiffies, end_time)) {\n\t\t/* Continue checking */\n\t\tmight_sleep();\n\t\treturn false;\n\t}\n\n\tkcsan_enable_current();\n\treturn true;\n}",
          "includes": [
            "#include <trace/events/printk.h>",
            "#include <linux/types.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/torture.h>",
            "#include <linux/timer.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kcsan-checks.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <kunit/test.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned long end_time;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/printk.h>\n#include <linux/types.h>\n#include <linux/tracepoint.h>\n#include <linux/torture.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/seqlock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/kcsan-checks.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <kunit/test.h>\n\nstatic unsigned long end_time;\n\nstatic __no_kcsan inline bool\nend_test_checks(bool stop)\n{\n\tif (!stop && time_before(jiffies, end_time)) {\n\t\t/* Continue checking */\n\t\tmight_sleep();\n\t\treturn false;\n\t}\n\n\tkcsan_enable_current();\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "report_matches",
          "args": [
            "&expect_ww"
          ],
          "line": 819
        },
        "resolved": true,
        "details": {
          "function_name": "report_matches_any_reordered",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/kcsan_test.c",
          "lines": "277-284",
          "snippet": "__no_kcsan\nstatic bool report_matches_any_reordered(struct expect_report *r)\n{\n\treturn __report_matches(__report_set_scoped(r, 0)) ||\n\t       __report_matches(__report_set_scoped(r, 1)) ||\n\t       __report_matches(__report_set_scoped(r, 2)) ||\n\t       __report_matches(__report_set_scoped(r, 3));\n}",
          "includes": [
            "#include <trace/events/printk.h>",
            "#include <linux/types.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/torture.h>",
            "#include <linux/timer.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kcsan-checks.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <kunit/test.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline const struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/printk.h>\n#include <linux/types.h>\n#include <linux/tracepoint.h>\n#include <linux/torture.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/seqlock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/kcsan-checks.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <kunit/test.h>\n\nstatic __always_inline const struct;\n\n__no_kcsan\nstatic bool report_matches_any_reordered(struct expect_report *r)\n{\n\treturn __report_matches(__report_set_scoped(r, 0)) ||\n\t       __report_matches(__report_set_scoped(r, 1)) ||\n\t       __report_matches(__report_set_scoped(r, 2)) ||\n\t       __report_matches(__report_set_scoped(r, 3));\n}"
        }
      },
      {
        "call_info": {
          "callee": "begin_test_checks",
          "args": [
            "test_kernel_write_nochange_rcu",
            "test_kernel_read"
          ],
          "line": 817
        },
        "resolved": true,
        "details": {
          "function_name": "begin_test_checks",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/kcsan_test.c",
          "lines": "62-76",
          "snippet": "static __no_kcsan inline void\nbegin_test_checks(void (*func1)(void), void (*func2)(void))\n{\n\tkcsan_disable_current();\n\n\t/*\n\t * Require at least as long as KCSAN_REPORT_ONCE_IN_MS, to ensure at\n\t * least one race is reported.\n\t */\n\tend_time = jiffies + msecs_to_jiffies(CONFIG_KCSAN_REPORT_ONCE_IN_MS + 500);\n\n\t/* Signal start; release potential initialization of shared data. */\n\tsmp_store_release(&access_kernels[0], func1);\n\tsmp_store_release(&access_kernels[1], func2);\n}",
          "includes": [
            "#include <trace/events/printk.h>",
            "#include <linux/types.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/torture.h>",
            "#include <linux/timer.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kcsan-checks.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <kunit/test.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void (*access_kernels[2])(void);",
            "static unsigned long end_time;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/printk.h>\n#include <linux/types.h>\n#include <linux/tracepoint.h>\n#include <linux/torture.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/seqlock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/kcsan-checks.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <kunit/test.h>\n\nstatic void (*access_kernels[2])(void);\nstatic unsigned long end_time;\n\nstatic __no_kcsan inline void\nbegin_test_checks(void (*func1)(void), void (*func2)(void))\n{\n\tkcsan_disable_current();\n\n\t/*\n\t * Require at least as long as KCSAN_REPORT_ONCE_IN_MS, to ensure at\n\t * least one race is reported.\n\t */\n\tend_time = jiffies + msecs_to_jiffies(CONFIG_KCSAN_REPORT_ONCE_IN_MS + 500);\n\n\t/* Signal start; release potential initialization of shared data. */\n\tsmp_store_release(&access_kernels[0], func1);\n\tsmp_store_release(&access_kernels[1], func2);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_kernel_write_nochange_rcu",
          "args": [],
          "line": 816
        },
        "resolved": true,
        "details": {
          "function_name": "test_kernel_write_nochange_rcu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/kcsan_test.c",
          "lines": "333-333",
          "snippet": "static noinline void test_kernel_write_nochange_rcu(void) { test_var = 42; }",
          "includes": [
            "#include <trace/events/printk.h>",
            "#include <linux/types.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/torture.h>",
            "#include <linux/timer.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kcsan-checks.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <kunit/test.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static long test_var;",
            "__no_kcsan\nstatic noinline",
            "__no_kcsan\nstatic noinline"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/printk.h>\n#include <linux/types.h>\n#include <linux/tracepoint.h>\n#include <linux/torture.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/seqlock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/kcsan-checks.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <kunit/test.h>\n\nstatic long test_var;\n__no_kcsan\nstatic noinline;\n__no_kcsan\nstatic noinline;\n\nstatic noinline void test_kernel_write_nochange_rcu(void) { test_var = 42; }"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/printk.h>\n#include <linux/types.h>\n#include <linux/tracepoint.h>\n#include <linux/torture.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/seqlock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/kcsan-checks.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <kunit/test.h>\n\n#define report_matches __report_matches\n#define report_matches report_matches_any_reordered\n\nstatic __always_inline const struct;\nstatic long test_var;\n\n__no_kcsan\nstatic void test_novalue_change_exception(struct kunit *test)\n{\n\tstruct expect_report expect_rw = {\n\t\t.access = {\n\t\t\t{ test_kernel_write_nochange_rcu, &test_var, sizeof(test_var), KCSAN_ACCESS_WRITE },\n\t\t\t{ test_kernel_read, &test_var, sizeof(test_var), 0 },\n\t\t},\n\t};\n\tstruct expect_report expect_ww = {\n\t\t.access = {\n\t\t\t{ test_kernel_write_nochange_rcu, &test_var, sizeof(test_var), KCSAN_ACCESS_WRITE },\n\t\t\t{ test_kernel_write_nochange_rcu, &test_var, sizeof(test_var), KCSAN_ACCESS_WRITE },\n\t\t},\n\t};\n\tbool match_expect = false;\n\n\ttest_kernel_write_nochange_rcu(); /* Reset value. */\n\tbegin_test_checks(test_kernel_write_nochange_rcu, test_kernel_read);\n\tdo {\n\t\tmatch_expect = report_matches(&expect_rw) || report_matches(&expect_ww);\n\t} while (!end_test_checks(match_expect));\n\tKUNIT_EXPECT_TRUE(test, match_expect);\n}"
  },
  {
    "function_name": "test_novalue_change",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/kcsan_test.c",
    "lines": "767-793",
    "snippet": "__no_kcsan\nstatic void test_novalue_change(struct kunit *test)\n{\n\tstruct expect_report expect_rw = {\n\t\t.access = {\n\t\t\t{ test_kernel_write_nochange, &test_var, sizeof(test_var), KCSAN_ACCESS_WRITE },\n\t\t\t{ test_kernel_read, &test_var, sizeof(test_var), 0 },\n\t\t},\n\t};\n\tstruct expect_report expect_ww = {\n\t\t.access = {\n\t\t\t{ test_kernel_write_nochange, &test_var, sizeof(test_var), KCSAN_ACCESS_WRITE },\n\t\t\t{ test_kernel_write_nochange, &test_var, sizeof(test_var), KCSAN_ACCESS_WRITE },\n\t\t},\n\t};\n\tbool match_expect = false;\n\n\ttest_kernel_write_nochange(); /* Reset value. */\n\tbegin_test_checks(test_kernel_write_nochange, test_kernel_read);\n\tdo {\n\t\tmatch_expect = report_matches(&expect_rw) || report_matches(&expect_ww);\n\t} while (!end_test_checks(match_expect));\n\tif (IS_ENABLED(CONFIG_KCSAN_REPORT_VALUE_CHANGE_ONLY))\n\t\tKUNIT_EXPECT_FALSE(test, match_expect);\n\telse\n\t\tKUNIT_EXPECT_TRUE(test, match_expect);\n}",
    "includes": [
      "#include <trace/events/printk.h>",
      "#include <linux/types.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/torture.h>",
      "#include <linux/timer.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kcsan-checks.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <kunit/test.h>"
    ],
    "macros_used": [
      "#define report_matches __report_matches",
      "#define report_matches report_matches_any_reordered"
    ],
    "globals_used": [
      "static __always_inline const struct",
      "static long test_var;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "KUNIT_EXPECT_TRUE",
          "args": [
            "test",
            "match_expect"
          ],
          "line": 792
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KUNIT_EXPECT_FALSE",
          "args": [
            "test",
            "match_expect"
          ],
          "line": 790
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_KCSAN_REPORT_VALUE_CHANGE_ONLY"
          ],
          "line": 789
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "end_test_checks",
          "args": [
            "match_expect"
          ],
          "line": 788
        },
        "resolved": true,
        "details": {
          "function_name": "end_test_checks",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/kcsan_test.c",
          "lines": "79-90",
          "snippet": "static __no_kcsan inline bool\nend_test_checks(bool stop)\n{\n\tif (!stop && time_before(jiffies, end_time)) {\n\t\t/* Continue checking */\n\t\tmight_sleep();\n\t\treturn false;\n\t}\n\n\tkcsan_enable_current();\n\treturn true;\n}",
          "includes": [
            "#include <trace/events/printk.h>",
            "#include <linux/types.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/torture.h>",
            "#include <linux/timer.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kcsan-checks.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <kunit/test.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned long end_time;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/printk.h>\n#include <linux/types.h>\n#include <linux/tracepoint.h>\n#include <linux/torture.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/seqlock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/kcsan-checks.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <kunit/test.h>\n\nstatic unsigned long end_time;\n\nstatic __no_kcsan inline bool\nend_test_checks(bool stop)\n{\n\tif (!stop && time_before(jiffies, end_time)) {\n\t\t/* Continue checking */\n\t\tmight_sleep();\n\t\treturn false;\n\t}\n\n\tkcsan_enable_current();\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "report_matches",
          "args": [
            "&expect_ww"
          ],
          "line": 787
        },
        "resolved": true,
        "details": {
          "function_name": "report_matches_any_reordered",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/kcsan_test.c",
          "lines": "277-284",
          "snippet": "__no_kcsan\nstatic bool report_matches_any_reordered(struct expect_report *r)\n{\n\treturn __report_matches(__report_set_scoped(r, 0)) ||\n\t       __report_matches(__report_set_scoped(r, 1)) ||\n\t       __report_matches(__report_set_scoped(r, 2)) ||\n\t       __report_matches(__report_set_scoped(r, 3));\n}",
          "includes": [
            "#include <trace/events/printk.h>",
            "#include <linux/types.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/torture.h>",
            "#include <linux/timer.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kcsan-checks.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <kunit/test.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline const struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/printk.h>\n#include <linux/types.h>\n#include <linux/tracepoint.h>\n#include <linux/torture.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/seqlock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/kcsan-checks.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <kunit/test.h>\n\nstatic __always_inline const struct;\n\n__no_kcsan\nstatic bool report_matches_any_reordered(struct expect_report *r)\n{\n\treturn __report_matches(__report_set_scoped(r, 0)) ||\n\t       __report_matches(__report_set_scoped(r, 1)) ||\n\t       __report_matches(__report_set_scoped(r, 2)) ||\n\t       __report_matches(__report_set_scoped(r, 3));\n}"
        }
      },
      {
        "call_info": {
          "callee": "begin_test_checks",
          "args": [
            "test_kernel_write_nochange",
            "test_kernel_read"
          ],
          "line": 785
        },
        "resolved": true,
        "details": {
          "function_name": "begin_test_checks",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/kcsan_test.c",
          "lines": "62-76",
          "snippet": "static __no_kcsan inline void\nbegin_test_checks(void (*func1)(void), void (*func2)(void))\n{\n\tkcsan_disable_current();\n\n\t/*\n\t * Require at least as long as KCSAN_REPORT_ONCE_IN_MS, to ensure at\n\t * least one race is reported.\n\t */\n\tend_time = jiffies + msecs_to_jiffies(CONFIG_KCSAN_REPORT_ONCE_IN_MS + 500);\n\n\t/* Signal start; release potential initialization of shared data. */\n\tsmp_store_release(&access_kernels[0], func1);\n\tsmp_store_release(&access_kernels[1], func2);\n}",
          "includes": [
            "#include <trace/events/printk.h>",
            "#include <linux/types.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/torture.h>",
            "#include <linux/timer.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kcsan-checks.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <kunit/test.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void (*access_kernels[2])(void);",
            "static unsigned long end_time;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/printk.h>\n#include <linux/types.h>\n#include <linux/tracepoint.h>\n#include <linux/torture.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/seqlock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/kcsan-checks.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <kunit/test.h>\n\nstatic void (*access_kernels[2])(void);\nstatic unsigned long end_time;\n\nstatic __no_kcsan inline void\nbegin_test_checks(void (*func1)(void), void (*func2)(void))\n{\n\tkcsan_disable_current();\n\n\t/*\n\t * Require at least as long as KCSAN_REPORT_ONCE_IN_MS, to ensure at\n\t * least one race is reported.\n\t */\n\tend_time = jiffies + msecs_to_jiffies(CONFIG_KCSAN_REPORT_ONCE_IN_MS + 500);\n\n\t/* Signal start; release potential initialization of shared data. */\n\tsmp_store_release(&access_kernels[0], func1);\n\tsmp_store_release(&access_kernels[1], func2);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_kernel_write_nochange",
          "args": [],
          "line": 784
        },
        "resolved": true,
        "details": {
          "function_name": "test_kernel_write_nochange_rcu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/kcsan_test.c",
          "lines": "333-333",
          "snippet": "static noinline void test_kernel_write_nochange_rcu(void) { test_var = 42; }",
          "includes": [
            "#include <trace/events/printk.h>",
            "#include <linux/types.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/torture.h>",
            "#include <linux/timer.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kcsan-checks.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <kunit/test.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static long test_var;",
            "__no_kcsan\nstatic noinline",
            "__no_kcsan\nstatic noinline"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/printk.h>\n#include <linux/types.h>\n#include <linux/tracepoint.h>\n#include <linux/torture.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/seqlock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/kcsan-checks.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <kunit/test.h>\n\nstatic long test_var;\n__no_kcsan\nstatic noinline;\n__no_kcsan\nstatic noinline;\n\nstatic noinline void test_kernel_write_nochange_rcu(void) { test_var = 42; }"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/printk.h>\n#include <linux/types.h>\n#include <linux/tracepoint.h>\n#include <linux/torture.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/seqlock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/kcsan-checks.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <kunit/test.h>\n\n#define report_matches __report_matches\n#define report_matches report_matches_any_reordered\n\nstatic __always_inline const struct;\nstatic long test_var;\n\n__no_kcsan\nstatic void test_novalue_change(struct kunit *test)\n{\n\tstruct expect_report expect_rw = {\n\t\t.access = {\n\t\t\t{ test_kernel_write_nochange, &test_var, sizeof(test_var), KCSAN_ACCESS_WRITE },\n\t\t\t{ test_kernel_read, &test_var, sizeof(test_var), 0 },\n\t\t},\n\t};\n\tstruct expect_report expect_ww = {\n\t\t.access = {\n\t\t\t{ test_kernel_write_nochange, &test_var, sizeof(test_var), KCSAN_ACCESS_WRITE },\n\t\t\t{ test_kernel_write_nochange, &test_var, sizeof(test_var), KCSAN_ACCESS_WRITE },\n\t\t},\n\t};\n\tbool match_expect = false;\n\n\ttest_kernel_write_nochange(); /* Reset value. */\n\tbegin_test_checks(test_kernel_write_nochange, test_kernel_read);\n\tdo {\n\t\tmatch_expect = report_matches(&expect_rw) || report_matches(&expect_ww);\n\t} while (!end_test_checks(match_expect));\n\tif (IS_ENABLED(CONFIG_KCSAN_REPORT_VALUE_CHANGE_ONLY))\n\t\tKUNIT_EXPECT_FALSE(test, match_expect);\n\telse\n\t\tKUNIT_EXPECT_TRUE(test, match_expect);\n}"
  },
  {
    "function_name": "test_concurrent_races",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/kcsan_test.c",
    "lines": "738-764",
    "snippet": "__no_kcsan\nstatic void test_concurrent_races(struct kunit *test)\n{\n\tstruct expect_report expect = {\n\t\t.access = {\n\t\t\t/* NULL will match any address. */\n\t\t\t{ test_kernel_rmw_array, NULL, 0, __KCSAN_ACCESS_RW(KCSAN_ACCESS_WRITE) },\n\t\t\t{ test_kernel_rmw_array, NULL, 0, __KCSAN_ACCESS_RW(0) },\n\t\t},\n\t};\n\tstruct expect_report never = {\n\t\t.access = {\n\t\t\t{ test_kernel_rmw_array, NULL, 0, 0 },\n\t\t\t{ test_kernel_rmw_array, NULL, 0, 0 },\n\t\t},\n\t};\n\tbool match_expect = false;\n\tbool match_never = false;\n\n\tbegin_test_checks(test_kernel_rmw_array, test_kernel_rmw_array);\n\tdo {\n\t\tmatch_expect |= report_matches(&expect);\n\t\tmatch_never |= report_matches(&never);\n\t} while (!end_test_checks(false));\n\tKUNIT_EXPECT_TRUE(test, match_expect); /* Sanity check matches exist. */\n\tKUNIT_EXPECT_FALSE(test, match_never);\n}",
    "includes": [
      "#include <trace/events/printk.h>",
      "#include <linux/types.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/torture.h>",
      "#include <linux/timer.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kcsan-checks.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <kunit/test.h>"
    ],
    "macros_used": [
      "#define report_matches __report_matches",
      "#define report_matches report_matches_any_reordered"
    ],
    "globals_used": [
      "static __always_inline const struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "KUNIT_EXPECT_FALSE",
          "args": [
            "test",
            "match_never"
          ],
          "line": 763
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KUNIT_EXPECT_TRUE",
          "args": [
            "test",
            "match_expect"
          ],
          "line": 762
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "end_test_checks",
          "args": [
            "false"
          ],
          "line": 761
        },
        "resolved": true,
        "details": {
          "function_name": "end_test_checks",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/kcsan_test.c",
          "lines": "79-90",
          "snippet": "static __no_kcsan inline bool\nend_test_checks(bool stop)\n{\n\tif (!stop && time_before(jiffies, end_time)) {\n\t\t/* Continue checking */\n\t\tmight_sleep();\n\t\treturn false;\n\t}\n\n\tkcsan_enable_current();\n\treturn true;\n}",
          "includes": [
            "#include <trace/events/printk.h>",
            "#include <linux/types.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/torture.h>",
            "#include <linux/timer.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kcsan-checks.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <kunit/test.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned long end_time;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/printk.h>\n#include <linux/types.h>\n#include <linux/tracepoint.h>\n#include <linux/torture.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/seqlock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/kcsan-checks.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <kunit/test.h>\n\nstatic unsigned long end_time;\n\nstatic __no_kcsan inline bool\nend_test_checks(bool stop)\n{\n\tif (!stop && time_before(jiffies, end_time)) {\n\t\t/* Continue checking */\n\t\tmight_sleep();\n\t\treturn false;\n\t}\n\n\tkcsan_enable_current();\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "report_matches",
          "args": [
            "&never"
          ],
          "line": 760
        },
        "resolved": true,
        "details": {
          "function_name": "report_matches_any_reordered",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/kcsan_test.c",
          "lines": "277-284",
          "snippet": "__no_kcsan\nstatic bool report_matches_any_reordered(struct expect_report *r)\n{\n\treturn __report_matches(__report_set_scoped(r, 0)) ||\n\t       __report_matches(__report_set_scoped(r, 1)) ||\n\t       __report_matches(__report_set_scoped(r, 2)) ||\n\t       __report_matches(__report_set_scoped(r, 3));\n}",
          "includes": [
            "#include <trace/events/printk.h>",
            "#include <linux/types.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/torture.h>",
            "#include <linux/timer.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kcsan-checks.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <kunit/test.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline const struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/printk.h>\n#include <linux/types.h>\n#include <linux/tracepoint.h>\n#include <linux/torture.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/seqlock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/kcsan-checks.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <kunit/test.h>\n\nstatic __always_inline const struct;\n\n__no_kcsan\nstatic bool report_matches_any_reordered(struct expect_report *r)\n{\n\treturn __report_matches(__report_set_scoped(r, 0)) ||\n\t       __report_matches(__report_set_scoped(r, 1)) ||\n\t       __report_matches(__report_set_scoped(r, 2)) ||\n\t       __report_matches(__report_set_scoped(r, 3));\n}"
        }
      },
      {
        "call_info": {
          "callee": "begin_test_checks",
          "args": [
            "test_kernel_rmw_array",
            "test_kernel_rmw_array"
          ],
          "line": 757
        },
        "resolved": true,
        "details": {
          "function_name": "begin_test_checks",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/kcsan_test.c",
          "lines": "62-76",
          "snippet": "static __no_kcsan inline void\nbegin_test_checks(void (*func1)(void), void (*func2)(void))\n{\n\tkcsan_disable_current();\n\n\t/*\n\t * Require at least as long as KCSAN_REPORT_ONCE_IN_MS, to ensure at\n\t * least one race is reported.\n\t */\n\tend_time = jiffies + msecs_to_jiffies(CONFIG_KCSAN_REPORT_ONCE_IN_MS + 500);\n\n\t/* Signal start; release potential initialization of shared data. */\n\tsmp_store_release(&access_kernels[0], func1);\n\tsmp_store_release(&access_kernels[1], func2);\n}",
          "includes": [
            "#include <trace/events/printk.h>",
            "#include <linux/types.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/torture.h>",
            "#include <linux/timer.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kcsan-checks.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <kunit/test.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void (*access_kernels[2])(void);",
            "static unsigned long end_time;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/printk.h>\n#include <linux/types.h>\n#include <linux/tracepoint.h>\n#include <linux/torture.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/seqlock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/kcsan-checks.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <kunit/test.h>\n\nstatic void (*access_kernels[2])(void);\nstatic unsigned long end_time;\n\nstatic __no_kcsan inline void\nbegin_test_checks(void (*func1)(void), void (*func2)(void))\n{\n\tkcsan_disable_current();\n\n\t/*\n\t * Require at least as long as KCSAN_REPORT_ONCE_IN_MS, to ensure at\n\t * least one race is reported.\n\t */\n\tend_time = jiffies + msecs_to_jiffies(CONFIG_KCSAN_REPORT_ONCE_IN_MS + 500);\n\n\t/* Signal start; release potential initialization of shared data. */\n\tsmp_store_release(&access_kernels[0], func1);\n\tsmp_store_release(&access_kernels[1], func2);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__KCSAN_ACCESS_RW",
          "args": [
            "0"
          ],
          "line": 745
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__KCSAN_ACCESS_RW",
          "args": [
            "KCSAN_ACCESS_WRITE"
          ],
          "line": 744
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/printk.h>\n#include <linux/types.h>\n#include <linux/tracepoint.h>\n#include <linux/torture.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/seqlock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/kcsan-checks.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <kunit/test.h>\n\n#define report_matches __report_matches\n#define report_matches report_matches_any_reordered\n\nstatic __always_inline const struct;\n\n__no_kcsan\nstatic void test_concurrent_races(struct kunit *test)\n{\n\tstruct expect_report expect = {\n\t\t.access = {\n\t\t\t/* NULL will match any address. */\n\t\t\t{ test_kernel_rmw_array, NULL, 0, __KCSAN_ACCESS_RW(KCSAN_ACCESS_WRITE) },\n\t\t\t{ test_kernel_rmw_array, NULL, 0, __KCSAN_ACCESS_RW(0) },\n\t\t},\n\t};\n\tstruct expect_report never = {\n\t\t.access = {\n\t\t\t{ test_kernel_rmw_array, NULL, 0, 0 },\n\t\t\t{ test_kernel_rmw_array, NULL, 0, 0 },\n\t\t},\n\t};\n\tbool match_expect = false;\n\tbool match_never = false;\n\n\tbegin_test_checks(test_kernel_rmw_array, test_kernel_rmw_array);\n\tdo {\n\t\tmatch_expect |= report_matches(&expect);\n\t\tmatch_never |= report_matches(&never);\n\t} while (!end_test_checks(false));\n\tKUNIT_EXPECT_TRUE(test, match_expect); /* Sanity check matches exist. */\n\tKUNIT_EXPECT_FALSE(test, match_never);\n}"
  },
  {
    "function_name": "test_basic",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/kcsan_test.c",
    "lines": "707-732",
    "snippet": "__no_kcsan\nstatic void test_basic(struct kunit *test)\n{\n\tstruct expect_report expect = {\n\t\t.access = {\n\t\t\t{ test_kernel_write, &test_var, sizeof(test_var), KCSAN_ACCESS_WRITE },\n\t\t\t{ test_kernel_read, &test_var, sizeof(test_var), 0 },\n\t\t},\n\t};\n\tstruct expect_report never = {\n\t\t.access = {\n\t\t\t{ test_kernel_read, &test_var, sizeof(test_var), 0 },\n\t\t\t{ test_kernel_read, &test_var, sizeof(test_var), 0 },\n\t\t},\n\t};\n\tbool match_expect = false;\n\tbool match_never = false;\n\n\tbegin_test_checks(test_kernel_write, test_kernel_read);\n\tdo {\n\t\tmatch_expect |= report_matches(&expect);\n\t\tmatch_never = report_matches(&never);\n\t} while (!end_test_checks(match_never));\n\tKUNIT_EXPECT_TRUE(test, match_expect);\n\tKUNIT_EXPECT_FALSE(test, match_never);\n}",
    "includes": [
      "#include <trace/events/printk.h>",
      "#include <linux/types.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/torture.h>",
      "#include <linux/timer.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kcsan-checks.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <kunit/test.h>"
    ],
    "macros_used": [
      "#define report_matches __report_matches",
      "#define report_matches report_matches_any_reordered"
    ],
    "globals_used": [
      "static __always_inline const struct",
      "static long test_var;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "KUNIT_EXPECT_FALSE",
          "args": [
            "test",
            "match_never"
          ],
          "line": 731
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KUNIT_EXPECT_TRUE",
          "args": [
            "test",
            "match_expect"
          ],
          "line": 730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "end_test_checks",
          "args": [
            "match_never"
          ],
          "line": 729
        },
        "resolved": true,
        "details": {
          "function_name": "end_test_checks",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/kcsan_test.c",
          "lines": "79-90",
          "snippet": "static __no_kcsan inline bool\nend_test_checks(bool stop)\n{\n\tif (!stop && time_before(jiffies, end_time)) {\n\t\t/* Continue checking */\n\t\tmight_sleep();\n\t\treturn false;\n\t}\n\n\tkcsan_enable_current();\n\treturn true;\n}",
          "includes": [
            "#include <trace/events/printk.h>",
            "#include <linux/types.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/torture.h>",
            "#include <linux/timer.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kcsan-checks.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <kunit/test.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned long end_time;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/printk.h>\n#include <linux/types.h>\n#include <linux/tracepoint.h>\n#include <linux/torture.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/seqlock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/kcsan-checks.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <kunit/test.h>\n\nstatic unsigned long end_time;\n\nstatic __no_kcsan inline bool\nend_test_checks(bool stop)\n{\n\tif (!stop && time_before(jiffies, end_time)) {\n\t\t/* Continue checking */\n\t\tmight_sleep();\n\t\treturn false;\n\t}\n\n\tkcsan_enable_current();\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "report_matches",
          "args": [
            "&never"
          ],
          "line": 728
        },
        "resolved": true,
        "details": {
          "function_name": "report_matches_any_reordered",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/kcsan_test.c",
          "lines": "277-284",
          "snippet": "__no_kcsan\nstatic bool report_matches_any_reordered(struct expect_report *r)\n{\n\treturn __report_matches(__report_set_scoped(r, 0)) ||\n\t       __report_matches(__report_set_scoped(r, 1)) ||\n\t       __report_matches(__report_set_scoped(r, 2)) ||\n\t       __report_matches(__report_set_scoped(r, 3));\n}",
          "includes": [
            "#include <trace/events/printk.h>",
            "#include <linux/types.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/torture.h>",
            "#include <linux/timer.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kcsan-checks.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <kunit/test.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline const struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/printk.h>\n#include <linux/types.h>\n#include <linux/tracepoint.h>\n#include <linux/torture.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/seqlock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/kcsan-checks.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <kunit/test.h>\n\nstatic __always_inline const struct;\n\n__no_kcsan\nstatic bool report_matches_any_reordered(struct expect_report *r)\n{\n\treturn __report_matches(__report_set_scoped(r, 0)) ||\n\t       __report_matches(__report_set_scoped(r, 1)) ||\n\t       __report_matches(__report_set_scoped(r, 2)) ||\n\t       __report_matches(__report_set_scoped(r, 3));\n}"
        }
      },
      {
        "call_info": {
          "callee": "begin_test_checks",
          "args": [
            "test_kernel_write",
            "test_kernel_read"
          ],
          "line": 725
        },
        "resolved": true,
        "details": {
          "function_name": "begin_test_checks",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/kcsan_test.c",
          "lines": "62-76",
          "snippet": "static __no_kcsan inline void\nbegin_test_checks(void (*func1)(void), void (*func2)(void))\n{\n\tkcsan_disable_current();\n\n\t/*\n\t * Require at least as long as KCSAN_REPORT_ONCE_IN_MS, to ensure at\n\t * least one race is reported.\n\t */\n\tend_time = jiffies + msecs_to_jiffies(CONFIG_KCSAN_REPORT_ONCE_IN_MS + 500);\n\n\t/* Signal start; release potential initialization of shared data. */\n\tsmp_store_release(&access_kernels[0], func1);\n\tsmp_store_release(&access_kernels[1], func2);\n}",
          "includes": [
            "#include <trace/events/printk.h>",
            "#include <linux/types.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/torture.h>",
            "#include <linux/timer.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kcsan-checks.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <kunit/test.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void (*access_kernels[2])(void);",
            "static unsigned long end_time;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/printk.h>\n#include <linux/types.h>\n#include <linux/tracepoint.h>\n#include <linux/torture.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/seqlock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/kcsan-checks.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <kunit/test.h>\n\nstatic void (*access_kernels[2])(void);\nstatic unsigned long end_time;\n\nstatic __no_kcsan inline void\nbegin_test_checks(void (*func1)(void), void (*func2)(void))\n{\n\tkcsan_disable_current();\n\n\t/*\n\t * Require at least as long as KCSAN_REPORT_ONCE_IN_MS, to ensure at\n\t * least one race is reported.\n\t */\n\tend_time = jiffies + msecs_to_jiffies(CONFIG_KCSAN_REPORT_ONCE_IN_MS + 500);\n\n\t/* Signal start; release potential initialization of shared data. */\n\tsmp_store_release(&access_kernels[0], func1);\n\tsmp_store_release(&access_kernels[1], func2);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/printk.h>\n#include <linux/types.h>\n#include <linux/tracepoint.h>\n#include <linux/torture.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/seqlock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/kcsan-checks.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <kunit/test.h>\n\n#define report_matches __report_matches\n#define report_matches report_matches_any_reordered\n\nstatic __always_inline const struct;\nstatic long test_var;\n\n__no_kcsan\nstatic void test_basic(struct kunit *test)\n{\n\tstruct expect_report expect = {\n\t\t.access = {\n\t\t\t{ test_kernel_write, &test_var, sizeof(test_var), KCSAN_ACCESS_WRITE },\n\t\t\t{ test_kernel_read, &test_var, sizeof(test_var), 0 },\n\t\t},\n\t};\n\tstruct expect_report never = {\n\t\t.access = {\n\t\t\t{ test_kernel_read, &test_var, sizeof(test_var), 0 },\n\t\t\t{ test_kernel_read, &test_var, sizeof(test_var), 0 },\n\t\t},\n\t};\n\tbool match_expect = false;\n\tbool match_never = false;\n\n\tbegin_test_checks(test_kernel_write, test_kernel_read);\n\tdo {\n\t\tmatch_expect |= report_matches(&expect);\n\t\tmatch_never = report_matches(&never);\n\t} while (!end_test_checks(match_never));\n\tKUNIT_EXPECT_TRUE(test, match_expect);\n\tKUNIT_EXPECT_FALSE(test, match_never);\n}"
  },
  {
    "function_name": "test_barrier_nothreads",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/kcsan_test.c",
    "lines": "520-704",
    "snippet": "static void test_barrier_nothreads(struct kunit *test)\n{\n#ifdef CONFIG_KCSAN_WEAK_MEMORY\n\tstruct kcsan_scoped_access *reorder_access = &current->kcsan_ctx.reorder_access;\n#else\n\tstruct kcsan_scoped_access *reorder_access = NULL;\n#endif\n\tarch_spinlock_t arch_spinlock = __ARCH_SPIN_LOCK_UNLOCKED;\n\tatomic_t dummy;\n\n\tKCSAN_TEST_REQUIRES(test, reorder_access != NULL);\n\tKCSAN_TEST_REQUIRES(test, IS_ENABLED(CONFIG_SMP));\n\n#define __KCSAN_EXPECT_BARRIER(access_type, barrier, order_before, name)\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\t\t\t\\\n\t\treorder_access->type = (access_type) | KCSAN_ACCESS_SCOPED;\t\t\t\\\n\t\treorder_access->size = sizeof(test_var);\t\t\t\t\t\\\n\t\tbarrier;\t\t\t\t\t\t\t\t\t\\\n\t\tKUNIT_EXPECT_EQ_MSG(test, reorder_access->size,\t\t\t\t\t\\\n\t\t\t\t    order_before ? 0 : sizeof(test_var),\t\t\t\\\n\t\t\t\t    \"improperly instrumented type=(\" #access_type \"): \" name);\t\\\n\t} while (0)\n#define KCSAN_EXPECT_READ_BARRIER(b, o)  __KCSAN_EXPECT_BARRIER(0, b, o, #b)\n#define KCSAN_EXPECT_WRITE_BARRIER(b, o) __KCSAN_EXPECT_BARRIER(KCSAN_ACCESS_WRITE, b, o, #b)\n#define KCSAN_EXPECT_RW_BARRIER(b, o)    __KCSAN_EXPECT_BARRIER(KCSAN_ACCESS_COMPOUND | KCSAN_ACCESS_WRITE, b, o, #b)\n\n\t/*\n\t * Lockdep initialization can strengthen certain locking operations due\n\t * to calling into instrumented files; \"warm up\" our locks.\n\t */\n\tspin_lock(&test_spinlock);\n\tspin_unlock(&test_spinlock);\n\tmutex_lock(&test_mutex);\n\tmutex_unlock(&test_mutex);\n\n\t/* Force creating a valid entry in reorder_access first. */\n\ttest_var = 0;\n\twhile (test_var++ < 1000000 && reorder_access->size != sizeof(test_var))\n\t\t__kcsan_check_read(&test_var, sizeof(test_var));\n\tKUNIT_ASSERT_EQ(test, reorder_access->size, sizeof(test_var));\n\n\tkcsan_nestable_atomic_begin(); /* No watchpoints in called functions. */\n\n\tKCSAN_EXPECT_READ_BARRIER(mb(), true);\n\tKCSAN_EXPECT_READ_BARRIER(wmb(), false);\n\tKCSAN_EXPECT_READ_BARRIER(rmb(), true);\n\tKCSAN_EXPECT_READ_BARRIER(smp_mb(), true);\n\tKCSAN_EXPECT_READ_BARRIER(smp_wmb(), false);\n\tKCSAN_EXPECT_READ_BARRIER(smp_rmb(), true);\n\tKCSAN_EXPECT_READ_BARRIER(dma_wmb(), false);\n\tKCSAN_EXPECT_READ_BARRIER(dma_rmb(), true);\n\tKCSAN_EXPECT_READ_BARRIER(smp_mb__before_atomic(), true);\n\tKCSAN_EXPECT_READ_BARRIER(smp_mb__after_atomic(), true);\n\tKCSAN_EXPECT_READ_BARRIER(smp_mb__after_spinlock(), true);\n\tKCSAN_EXPECT_READ_BARRIER(smp_store_mb(test_var, 0), true);\n\tKCSAN_EXPECT_READ_BARRIER(smp_load_acquire(&test_var), false);\n\tKCSAN_EXPECT_READ_BARRIER(smp_store_release(&test_var, 0), true);\n\tKCSAN_EXPECT_READ_BARRIER(xchg(&test_var, 0), true);\n\tKCSAN_EXPECT_READ_BARRIER(xchg_release(&test_var, 0), true);\n\tKCSAN_EXPECT_READ_BARRIER(xchg_relaxed(&test_var, 0), false);\n\tKCSAN_EXPECT_READ_BARRIER(cmpxchg(&test_var, 0,  0), true);\n\tKCSAN_EXPECT_READ_BARRIER(cmpxchg_release(&test_var, 0,  0), true);\n\tKCSAN_EXPECT_READ_BARRIER(cmpxchg_relaxed(&test_var, 0,  0), false);\n\tKCSAN_EXPECT_READ_BARRIER(atomic_read(&dummy), false);\n\tKCSAN_EXPECT_READ_BARRIER(atomic_read_acquire(&dummy), false);\n\tKCSAN_EXPECT_READ_BARRIER(atomic_set(&dummy, 0), false);\n\tKCSAN_EXPECT_READ_BARRIER(atomic_set_release(&dummy, 0), true);\n\tKCSAN_EXPECT_READ_BARRIER(atomic_add(1, &dummy), false);\n\tKCSAN_EXPECT_READ_BARRIER(atomic_add_return(1, &dummy), true);\n\tKCSAN_EXPECT_READ_BARRIER(atomic_add_return_acquire(1, &dummy), false);\n\tKCSAN_EXPECT_READ_BARRIER(atomic_add_return_release(1, &dummy), true);\n\tKCSAN_EXPECT_READ_BARRIER(atomic_add_return_relaxed(1, &dummy), false);\n\tKCSAN_EXPECT_READ_BARRIER(atomic_fetch_add(1, &dummy), true);\n\tKCSAN_EXPECT_READ_BARRIER(atomic_fetch_add_acquire(1, &dummy), false);\n\tKCSAN_EXPECT_READ_BARRIER(atomic_fetch_add_release(1, &dummy), true);\n\tKCSAN_EXPECT_READ_BARRIER(atomic_fetch_add_relaxed(1, &dummy), false);\n\tKCSAN_EXPECT_READ_BARRIER(test_and_set_bit(0, &test_var), true);\n\tKCSAN_EXPECT_READ_BARRIER(test_and_clear_bit(0, &test_var), true);\n\tKCSAN_EXPECT_READ_BARRIER(test_and_change_bit(0, &test_var), true);\n\tKCSAN_EXPECT_READ_BARRIER(clear_bit_unlock(0, &test_var), true);\n\tKCSAN_EXPECT_READ_BARRIER(__clear_bit_unlock(0, &test_var), true);\n\tKCSAN_EXPECT_READ_BARRIER(arch_spin_lock(&arch_spinlock), false);\n\tKCSAN_EXPECT_READ_BARRIER(arch_spin_unlock(&arch_spinlock), true);\n\tKCSAN_EXPECT_READ_BARRIER(spin_lock(&test_spinlock), false);\n\tKCSAN_EXPECT_READ_BARRIER(spin_unlock(&test_spinlock), true);\n\tKCSAN_EXPECT_READ_BARRIER(mutex_lock(&test_mutex), false);\n\tKCSAN_EXPECT_READ_BARRIER(mutex_unlock(&test_mutex), true);\n\n\tKCSAN_EXPECT_WRITE_BARRIER(mb(), true);\n\tKCSAN_EXPECT_WRITE_BARRIER(wmb(), true);\n\tKCSAN_EXPECT_WRITE_BARRIER(rmb(), false);\n\tKCSAN_EXPECT_WRITE_BARRIER(smp_mb(), true);\n\tKCSAN_EXPECT_WRITE_BARRIER(smp_wmb(), true);\n\tKCSAN_EXPECT_WRITE_BARRIER(smp_rmb(), false);\n\tKCSAN_EXPECT_WRITE_BARRIER(dma_wmb(), true);\n\tKCSAN_EXPECT_WRITE_BARRIER(dma_rmb(), false);\n\tKCSAN_EXPECT_WRITE_BARRIER(smp_mb__before_atomic(), true);\n\tKCSAN_EXPECT_WRITE_BARRIER(smp_mb__after_atomic(), true);\n\tKCSAN_EXPECT_WRITE_BARRIER(smp_mb__after_spinlock(), true);\n\tKCSAN_EXPECT_WRITE_BARRIER(smp_store_mb(test_var, 0), true);\n\tKCSAN_EXPECT_WRITE_BARRIER(smp_load_acquire(&test_var), false);\n\tKCSAN_EXPECT_WRITE_BARRIER(smp_store_release(&test_var, 0), true);\n\tKCSAN_EXPECT_WRITE_BARRIER(xchg(&test_var, 0), true);\n\tKCSAN_EXPECT_WRITE_BARRIER(xchg_release(&test_var, 0), true);\n\tKCSAN_EXPECT_WRITE_BARRIER(xchg_relaxed(&test_var, 0), false);\n\tKCSAN_EXPECT_WRITE_BARRIER(cmpxchg(&test_var, 0,  0), true);\n\tKCSAN_EXPECT_WRITE_BARRIER(cmpxchg_release(&test_var, 0,  0), true);\n\tKCSAN_EXPECT_WRITE_BARRIER(cmpxchg_relaxed(&test_var, 0,  0), false);\n\tKCSAN_EXPECT_WRITE_BARRIER(atomic_read(&dummy), false);\n\tKCSAN_EXPECT_WRITE_BARRIER(atomic_read_acquire(&dummy), false);\n\tKCSAN_EXPECT_WRITE_BARRIER(atomic_set(&dummy, 0), false);\n\tKCSAN_EXPECT_WRITE_BARRIER(atomic_set_release(&dummy, 0), true);\n\tKCSAN_EXPECT_WRITE_BARRIER(atomic_add(1, &dummy), false);\n\tKCSAN_EXPECT_WRITE_BARRIER(atomic_add_return(1, &dummy), true);\n\tKCSAN_EXPECT_WRITE_BARRIER(atomic_add_return_acquire(1, &dummy), false);\n\tKCSAN_EXPECT_WRITE_BARRIER(atomic_add_return_release(1, &dummy), true);\n\tKCSAN_EXPECT_WRITE_BARRIER(atomic_add_return_relaxed(1, &dummy), false);\n\tKCSAN_EXPECT_WRITE_BARRIER(atomic_fetch_add(1, &dummy), true);\n\tKCSAN_EXPECT_WRITE_BARRIER(atomic_fetch_add_acquire(1, &dummy), false);\n\tKCSAN_EXPECT_WRITE_BARRIER(atomic_fetch_add_release(1, &dummy), true);\n\tKCSAN_EXPECT_WRITE_BARRIER(atomic_fetch_add_relaxed(1, &dummy), false);\n\tKCSAN_EXPECT_WRITE_BARRIER(test_and_set_bit(0, &test_var), true);\n\tKCSAN_EXPECT_WRITE_BARRIER(test_and_clear_bit(0, &test_var), true);\n\tKCSAN_EXPECT_WRITE_BARRIER(test_and_change_bit(0, &test_var), true);\n\tKCSAN_EXPECT_WRITE_BARRIER(clear_bit_unlock(0, &test_var), true);\n\tKCSAN_EXPECT_WRITE_BARRIER(__clear_bit_unlock(0, &test_var), true);\n\tKCSAN_EXPECT_WRITE_BARRIER(arch_spin_lock(&arch_spinlock), false);\n\tKCSAN_EXPECT_WRITE_BARRIER(arch_spin_unlock(&arch_spinlock), true);\n\tKCSAN_EXPECT_WRITE_BARRIER(spin_lock(&test_spinlock), false);\n\tKCSAN_EXPECT_WRITE_BARRIER(spin_unlock(&test_spinlock), true);\n\tKCSAN_EXPECT_WRITE_BARRIER(mutex_lock(&test_mutex), false);\n\tKCSAN_EXPECT_WRITE_BARRIER(mutex_unlock(&test_mutex), true);\n\n\tKCSAN_EXPECT_RW_BARRIER(mb(), true);\n\tKCSAN_EXPECT_RW_BARRIER(wmb(), true);\n\tKCSAN_EXPECT_RW_BARRIER(rmb(), true);\n\tKCSAN_EXPECT_RW_BARRIER(smp_mb(), true);\n\tKCSAN_EXPECT_RW_BARRIER(smp_wmb(), true);\n\tKCSAN_EXPECT_RW_BARRIER(smp_rmb(), true);\n\tKCSAN_EXPECT_RW_BARRIER(dma_wmb(), true);\n\tKCSAN_EXPECT_RW_BARRIER(dma_rmb(), true);\n\tKCSAN_EXPECT_RW_BARRIER(smp_mb__before_atomic(), true);\n\tKCSAN_EXPECT_RW_BARRIER(smp_mb__after_atomic(), true);\n\tKCSAN_EXPECT_RW_BARRIER(smp_mb__after_spinlock(), true);\n\tKCSAN_EXPECT_RW_BARRIER(smp_store_mb(test_var, 0), true);\n\tKCSAN_EXPECT_RW_BARRIER(smp_load_acquire(&test_var), false);\n\tKCSAN_EXPECT_RW_BARRIER(smp_store_release(&test_var, 0), true);\n\tKCSAN_EXPECT_RW_BARRIER(xchg(&test_var, 0), true);\n\tKCSAN_EXPECT_RW_BARRIER(xchg_release(&test_var, 0), true);\n\tKCSAN_EXPECT_RW_BARRIER(xchg_relaxed(&test_var, 0), false);\n\tKCSAN_EXPECT_RW_BARRIER(cmpxchg(&test_var, 0,  0), true);\n\tKCSAN_EXPECT_RW_BARRIER(cmpxchg_release(&test_var, 0,  0), true);\n\tKCSAN_EXPECT_RW_BARRIER(cmpxchg_relaxed(&test_var, 0,  0), false);\n\tKCSAN_EXPECT_RW_BARRIER(atomic_read(&dummy), false);\n\tKCSAN_EXPECT_RW_BARRIER(atomic_read_acquire(&dummy), false);\n\tKCSAN_EXPECT_RW_BARRIER(atomic_set(&dummy, 0), false);\n\tKCSAN_EXPECT_RW_BARRIER(atomic_set_release(&dummy, 0), true);\n\tKCSAN_EXPECT_RW_BARRIER(atomic_add(1, &dummy), false);\n\tKCSAN_EXPECT_RW_BARRIER(atomic_add_return(1, &dummy), true);\n\tKCSAN_EXPECT_RW_BARRIER(atomic_add_return_acquire(1, &dummy), false);\n\tKCSAN_EXPECT_RW_BARRIER(atomic_add_return_release(1, &dummy), true);\n\tKCSAN_EXPECT_RW_BARRIER(atomic_add_return_relaxed(1, &dummy), false);\n\tKCSAN_EXPECT_RW_BARRIER(atomic_fetch_add(1, &dummy), true);\n\tKCSAN_EXPECT_RW_BARRIER(atomic_fetch_add_acquire(1, &dummy), false);\n\tKCSAN_EXPECT_RW_BARRIER(atomic_fetch_add_release(1, &dummy), true);\n\tKCSAN_EXPECT_RW_BARRIER(atomic_fetch_add_relaxed(1, &dummy), false);\n\tKCSAN_EXPECT_RW_BARRIER(test_and_set_bit(0, &test_var), true);\n\tKCSAN_EXPECT_RW_BARRIER(test_and_clear_bit(0, &test_var), true);\n\tKCSAN_EXPECT_RW_BARRIER(test_and_change_bit(0, &test_var), true);\n\tKCSAN_EXPECT_RW_BARRIER(clear_bit_unlock(0, &test_var), true);\n\tKCSAN_EXPECT_RW_BARRIER(__clear_bit_unlock(0, &test_var), true);\n\tKCSAN_EXPECT_RW_BARRIER(arch_spin_lock(&arch_spinlock), false);\n\tKCSAN_EXPECT_RW_BARRIER(arch_spin_unlock(&arch_spinlock), true);\n\tKCSAN_EXPECT_RW_BARRIER(spin_lock(&test_spinlock), false);\n\tKCSAN_EXPECT_RW_BARRIER(spin_unlock(&test_spinlock), true);\n\tKCSAN_EXPECT_RW_BARRIER(mutex_lock(&test_mutex), false);\n\tKCSAN_EXPECT_RW_BARRIER(mutex_unlock(&test_mutex), true);\n\n#ifdef clear_bit_unlock_is_negative_byte\n\tKCSAN_EXPECT_READ_BARRIER(clear_bit_unlock_is_negative_byte(0, &test_var), true);\n\tKCSAN_EXPECT_WRITE_BARRIER(clear_bit_unlock_is_negative_byte(0, &test_var), true);\n\tKCSAN_EXPECT_RW_BARRIER(clear_bit_unlock_is_negative_byte(0, &test_var), true);\n#endif\n\tkcsan_nestable_atomic_end();\n}",
    "includes": [
      "#include <trace/events/printk.h>",
      "#include <linux/types.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/torture.h>",
      "#include <linux/timer.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kcsan-checks.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <kunit/test.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline const struct",
      "static long test_var;",
      "static DEFINE_SPINLOCK(test_spinlock);",
      "static DEFINE_MUTEX(test_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kcsan_nestable_atomic_end",
          "args": [],
          "line": 703
        },
        "resolved": true,
        "details": {
          "function_name": "kcsan_nestable_atomic_end",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/core.c",
          "lines": "855-868",
          "snippet": "void kcsan_nestable_atomic_end(void)\n{\n\tif (get_ctx()->atomic_nest_count-- == 0) {\n\t\t/*\n\t\t * Warn if kcsan_nestable_atomic_end() calls are unbalanced with\n\t\t * kcsan_nestable_atomic_begin() calls, which causes\n\t\t * atomic_nest_count to become negative and should not happen.\n\t\t */\n\t\tkcsan_nestable_atomic_begin(); /* restore to 0 */\n\t\tkcsan_disable_current(); /* disable to generate warning */\n\t\tWARN(1, \"Unbalanced %s()\", __func__);\n\t\tkcsan_enable_current();\n\t}\n}",
          "includes": [
            "#include \"permissive.h\"",
            "#include \"kcsan.h\"",
            "#include \"encoding.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/sched.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/bug.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"permissive.h\"\n#include \"kcsan.h\"\n#include \"encoding.h\"\n#include <linux/uaccess.h>\n#include <linux/sched.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/bug.h>\n#include <linux/atomic.h>\n\nvoid kcsan_nestable_atomic_end(void)\n{\n\tif (get_ctx()->atomic_nest_count-- == 0) {\n\t\t/*\n\t\t * Warn if kcsan_nestable_atomic_end() calls are unbalanced with\n\t\t * kcsan_nestable_atomic_begin() calls, which causes\n\t\t * atomic_nest_count to become negative and should not happen.\n\t\t */\n\t\tkcsan_nestable_atomic_begin(); /* restore to 0 */\n\t\tkcsan_disable_current(); /* disable to generate warning */\n\t\tWARN(1, \"Unbalanced %s()\", __func__);\n\t\tkcsan_enable_current();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "KCSAN_EXPECT_RW_BARRIER",
          "args": [
            "clear_bit_unlock_is_negative_byte(0, &test_var)",
            "true"
          ],
          "line": 701
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_bit_unlock_is_negative_byte",
          "args": [
            "0",
            "&test_var"
          ],
          "line": 701
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KCSAN_EXPECT_WRITE_BARRIER",
          "args": [
            "clear_bit_unlock_is_negative_byte(0, &test_var)",
            "true"
          ],
          "line": 700
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_bit_unlock_is_negative_byte",
          "args": [
            "0",
            "&test_var"
          ],
          "line": 700
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KCSAN_EXPECT_READ_BARRIER",
          "args": [
            "clear_bit_unlock_is_negative_byte(0, &test_var)",
            "true"
          ],
          "line": 699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_bit_unlock_is_negative_byte",
          "args": [
            "0",
            "&test_var"
          ],
          "line": 699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KCSAN_EXPECT_RW_BARRIER",
          "args": [
            "mutex_unlock(&test_mutex)",
            "true"
          ],
          "line": 696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&test_mutex"
          ],
          "line": 696
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "KCSAN_EXPECT_RW_BARRIER",
          "args": [
            "mutex_lock(&test_mutex)",
            "false"
          ],
          "line": 695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&test_mutex"
          ],
          "line": 695
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "KCSAN_EXPECT_RW_BARRIER",
          "args": [
            "spin_unlock(&test_spinlock)",
            "true"
          ],
          "line": 694
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&test_spinlock"
          ],
          "line": 694
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
          "lines": "315-322",
          "snippet": "static inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"../../lib/kstrtox.h\"",
            "#include <linux/security.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/ctype.h>",
            "#include <linux/filter.h>",
            "#include <linux/uidgid.h>",
            "#include <linux/sched.h>",
            "#include <linux/ktime.h>",
            "#include <linux/topology.h>",
            "#include <linux/smp.h>",
            "#include <linux/random.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned long, irqsave_flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_PER_CPU(unsigned long, irqsave_flags);\n\nstatic inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "KCSAN_EXPECT_RW_BARRIER",
          "args": [
            "spin_lock(&test_spinlock)",
            "false"
          ],
          "line": 693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&test_spinlock"
          ],
          "line": 693
        },
        "resolved": true,
        "details": {
          "function_name": "reg_may_point_to_spin_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/verifier.c",
          "lines": "445-449",
          "snippet": "static bool reg_may_point_to_spin_lock(const struct bpf_reg_state *reg)\n{\n\treturn reg->type == PTR_TO_MAP_VALUE &&\n\t\tmap_value_has_spin_lock(reg->map_ptr);\n}",
          "includes": [
            "#include \"disasm.h\"",
            "#include <linux/btf_ids.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/error-injection.h>",
            "#include <linux/ctype.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/stringify.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/file.h>",
            "#include <net/netlink.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __mark_reg_not_init(const struct bpf_verifier_env *env,\n\t\t\t\tstruct bpf_reg_state *reg);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"disasm.h\"\n#include <linux/btf_ids.h>\n#include <linux/bpf_lsm.h>\n#include <linux/error-injection.h>\n#include <linux/ctype.h>\n#include <linux/perf_event.h>\n#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/stringify.h>\n#include <linux/vmalloc.h>\n#include <linux/file.h>\n#include <net/netlink.h>\n#include <linux/filter.h>\n#include <linux/bpf_verifier.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/bpf-cgroup.h>\n#include <uapi/linux/btf.h>\n\nstatic void __mark_reg_not_init(const struct bpf_verifier_env *env,\n\t\t\t\tstruct bpf_reg_state *reg);\n\nstatic bool reg_may_point_to_spin_lock(const struct bpf_reg_state *reg)\n{\n\treturn reg->type == PTR_TO_MAP_VALUE &&\n\t\tmap_value_has_spin_lock(reg->map_ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "KCSAN_EXPECT_RW_BARRIER",
          "args": [
            "arch_spin_unlock(&arch_spinlock)",
            "true"
          ],
          "line": 692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_spin_unlock",
          "args": [
            "&arch_spinlock"
          ],
          "line": 692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KCSAN_EXPECT_RW_BARRIER",
          "args": [
            "arch_spin_lock(&arch_spinlock)",
            "false"
          ],
          "line": 691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_spin_lock",
          "args": [
            "&arch_spinlock"
          ],
          "line": 691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KCSAN_EXPECT_RW_BARRIER",
          "args": [
            "__clear_bit_unlock(0, &test_var)",
            "true"
          ],
          "line": 690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__clear_bit_unlock",
          "args": [
            "0",
            "&test_var"
          ],
          "line": 690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KCSAN_EXPECT_RW_BARRIER",
          "args": [
            "clear_bit_unlock(0, &test_var)",
            "true"
          ],
          "line": 689
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_bit_unlock",
          "args": [
            "0",
            "&test_var"
          ],
          "line": 689
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KCSAN_EXPECT_RW_BARRIER",
          "args": [
            "test_and_change_bit(0, &test_var)",
            "true"
          ],
          "line": 688
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_and_change_bit",
          "args": [
            "0",
            "&test_var"
          ],
          "line": 688
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KCSAN_EXPECT_RW_BARRIER",
          "args": [
            "test_and_clear_bit(0, &test_var)",
            "true"
          ],
          "line": 687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_and_clear_bit",
          "args": [
            "0",
            "&test_var"
          ],
          "line": 687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KCSAN_EXPECT_RW_BARRIER",
          "args": [
            "test_and_set_bit(0, &test_var)",
            "true"
          ],
          "line": 686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_and_set_bit",
          "args": [
            "0",
            "&test_var"
          ],
          "line": 686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KCSAN_EXPECT_RW_BARRIER",
          "args": [
            "atomic_fetch_add_relaxed(1, &dummy)",
            "false"
          ],
          "line": 685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_fetch_add_relaxed",
          "args": [
            "1",
            "&dummy"
          ],
          "line": 685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KCSAN_EXPECT_RW_BARRIER",
          "args": [
            "atomic_fetch_add_release(1, &dummy)",
            "true"
          ],
          "line": 684
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_fetch_add_release",
          "args": [
            "1",
            "&dummy"
          ],
          "line": 684
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KCSAN_EXPECT_RW_BARRIER",
          "args": [
            "atomic_fetch_add_acquire(1, &dummy)",
            "false"
          ],
          "line": 683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_fetch_add_acquire",
          "args": [
            "1",
            "&dummy"
          ],
          "line": 683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KCSAN_EXPECT_RW_BARRIER",
          "args": [
            "atomic_fetch_add(1, &dummy)",
            "true"
          ],
          "line": 682
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_fetch_add",
          "args": [
            "1",
            "&dummy"
          ],
          "line": 682
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KCSAN_EXPECT_RW_BARRIER",
          "args": [
            "atomic_add_return_relaxed(1, &dummy)",
            "false"
          ],
          "line": 681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_add_return_relaxed",
          "args": [
            "1",
            "&dummy"
          ],
          "line": 681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KCSAN_EXPECT_RW_BARRIER",
          "args": [
            "atomic_add_return_release(1, &dummy)",
            "true"
          ],
          "line": 680
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_add_return_release",
          "args": [
            "1",
            "&dummy"
          ],
          "line": 680
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KCSAN_EXPECT_RW_BARRIER",
          "args": [
            "atomic_add_return_acquire(1, &dummy)",
            "false"
          ],
          "line": 679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_add_return_acquire",
          "args": [
            "1",
            "&dummy"
          ],
          "line": 679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KCSAN_EXPECT_RW_BARRIER",
          "args": [
            "atomic_add_return(1, &dummy)",
            "true"
          ],
          "line": 678
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_add_return",
          "args": [
            "1",
            "&dummy"
          ],
          "line": 678
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KCSAN_EXPECT_RW_BARRIER",
          "args": [
            "atomic_add(1, &dummy)",
            "false"
          ],
          "line": 677
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_add",
          "args": [
            "1",
            "&dummy"
          ],
          "line": 677
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KCSAN_EXPECT_RW_BARRIER",
          "args": [
            "atomic_set_release(&dummy, 0)",
            "true"
          ],
          "line": 676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set_release",
          "args": [
            "&dummy",
            "0"
          ],
          "line": 676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KCSAN_EXPECT_RW_BARRIER",
          "args": [
            "atomic_set(&dummy, 0)",
            "false"
          ],
          "line": 675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&dummy",
            "0"
          ],
          "line": 675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KCSAN_EXPECT_RW_BARRIER",
          "args": [
            "atomic_read_acquire(&dummy)",
            "false"
          ],
          "line": 674
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read_acquire",
          "args": [
            "&dummy"
          ],
          "line": 674
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KCSAN_EXPECT_RW_BARRIER",
          "args": [
            "atomic_read(&dummy)",
            "false"
          ],
          "line": 673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&dummy"
          ],
          "line": 673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KCSAN_EXPECT_RW_BARRIER",
          "args": [
            "cmpxchg_relaxed(&test_var, 0,  0)",
            "false"
          ],
          "line": 672
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cmpxchg_relaxed",
          "args": [
            "&test_var",
            "0",
            "0"
          ],
          "line": 672
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KCSAN_EXPECT_RW_BARRIER",
          "args": [
            "cmpxchg_release(&test_var, 0,  0)",
            "true"
          ],
          "line": 671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cmpxchg_release",
          "args": [
            "&test_var",
            "0",
            "0"
          ],
          "line": 671
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_cmpxchg_release",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "261-266",
          "snippet": "static __always_inline bool rt_mutex_cmpxchg_release(struct rt_mutex_base *lock,\n\t\t\t\t\t\t     struct task_struct *old,\n\t\t\t\t\t\t     struct task_struct *new)\n{\n\treturn false;\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline bool rt_mutex_cmpxchg_release(struct rt_mutex_base *lock,\n\t\t\t\t\t\t     struct task_struct *old,\n\t\t\t\t\t\t     struct task_struct *new)\n{\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "KCSAN_EXPECT_RW_BARRIER",
          "args": [
            "cmpxchg(&test_var, 0,  0)",
            "true"
          ],
          "line": 670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cmpxchg",
          "args": [
            "&test_var",
            "0",
            "0"
          ],
          "line": 670
        },
        "resolved": true,
        "details": {
          "function_name": "rb_time_cmpxchg",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ring_buffer.c",
          "lines": "737-742",
          "snippet": "static bool rb_time_cmpxchg(rb_time_t *t, u64 expect, u64 set)\n{\n\tu64 val;\n\tval = local64_cmpxchg(&t->time, expect, set);\n\treturn val == expect;\n}",
          "includes": [
            "#include <asm/local64.h>",
            "#include <asm/local.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/list.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/delay.h>",
            "#include <linux/mutex.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>\t/* for self test */",
            "#include <linux/hardirq.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/security.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_recursion.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/local64.h>\n#include <asm/local.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/mutex.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\t/* for self test */\n#include <linux/hardirq.h>\n#include <linux/uaccess.h>\n#include <linux/security.h>\n#include <linux/irq_work.h>\n#include <linux/spinlock.h>\n#include <linux/trace_seq.h>\n#include <linux/sched/clock.h>\n#include <linux/trace_clock.h>\n#include <linux/ring_buffer.h>\n#include <linux/trace_events.h>\n#include <linux/trace_recursion.h>\n\nstatic bool rb_time_cmpxchg(rb_time_t *t, u64 expect, u64 set)\n{\n\tu64 val;\n\tval = local64_cmpxchg(&t->time, expect, set);\n\treturn val == expect;\n}"
        }
      },
      {
        "call_info": {
          "callee": "KCSAN_EXPECT_RW_BARRIER",
          "args": [
            "xchg_relaxed(&test_var, 0)",
            "false"
          ],
          "line": 669
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xchg_relaxed",
          "args": [
            "&test_var",
            "0"
          ],
          "line": 669
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KCSAN_EXPECT_RW_BARRIER",
          "args": [
            "xchg_release(&test_var, 0)",
            "true"
          ],
          "line": 668
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xchg_release",
          "args": [
            "&test_var",
            "0"
          ],
          "line": 668
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KCSAN_EXPECT_RW_BARRIER",
          "args": [
            "xchg(&test_var, 0)",
            "true"
          ],
          "line": 667
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xchg",
          "args": [
            "&test_var",
            "0"
          ],
          "line": 667
        },
        "resolved": true,
        "details": {
          "function_name": "xchg_tail",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/qspinlock.c",
          "lines": "220-238",
          "snippet": "static __always_inline u32 xchg_tail(struct qspinlock *lock, u32 tail)\n{\n\tu32 old, new, val = atomic_read(&lock->val);\n\n\tfor (;;) {\n\t\tnew = (val & _Q_LOCKED_PENDING_MASK) | tail;\n\t\t/*\n\t\t * We can use relaxed semantics since the caller ensures that\n\t\t * the MCS node is properly initialized before updating the\n\t\t * tail.\n\t\t */\n\t\told = atomic_cmpxchg_relaxed(&lock->val, val, new);\n\t\tif (old == val)\n\t\t\tbreak;\n\n\t\tval = old;\n\t}\n\treturn old;\n}",
          "includes": [
            "#include \"qspinlock.c\"",
            "#include \"qspinlock_paravirt.h\"",
            "#include \"mcs_spinlock.h\"",
            "#include \"qspinlock_stat.h\"",
            "#include <asm/qspinlock.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/percpu.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/bug.h>",
            "#include <linux/smp.h>"
          ],
          "macros_used": [
            "#define _Q_LOCKED_PENDING_MASK (_Q_LOCKED_MASK | _Q_PENDING_MASK)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qspinlock.c\"\n#include \"qspinlock_paravirt.h\"\n#include \"mcs_spinlock.h\"\n#include \"qspinlock_stat.h\"\n#include <asm/qspinlock.h>\n#include <asm/byteorder.h>\n#include <linux/prefetch.h>\n#include <linux/mutex.h>\n#include <linux/hardirq.h>\n#include <linux/percpu.h>\n#include <linux/cpumask.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n\n#define _Q_LOCKED_PENDING_MASK (_Q_LOCKED_MASK | _Q_PENDING_MASK)\n\nstatic __always_inline u32 xchg_tail(struct qspinlock *lock, u32 tail)\n{\n\tu32 old, new, val = atomic_read(&lock->val);\n\n\tfor (;;) {\n\t\tnew = (val & _Q_LOCKED_PENDING_MASK) | tail;\n\t\t/*\n\t\t * We can use relaxed semantics since the caller ensures that\n\t\t * the MCS node is properly initialized before updating the\n\t\t * tail.\n\t\t */\n\t\told = atomic_cmpxchg_relaxed(&lock->val, val, new);\n\t\tif (old == val)\n\t\t\tbreak;\n\n\t\tval = old;\n\t}\n\treturn old;\n}"
        }
      },
      {
        "call_info": {
          "callee": "KCSAN_EXPECT_RW_BARRIER",
          "args": [
            "smp_store_release(&test_var, 0)",
            "true"
          ],
          "line": 666
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_store_release",
          "args": [
            "&test_var",
            "0"
          ],
          "line": 666
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KCSAN_EXPECT_RW_BARRIER",
          "args": [
            "smp_load_acquire(&test_var)",
            "false"
          ],
          "line": 665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_load_acquire",
          "args": [
            "&test_var"
          ],
          "line": 665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KCSAN_EXPECT_RW_BARRIER",
          "args": [
            "smp_store_mb(test_var, 0)",
            "true"
          ],
          "line": 664
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_store_mb",
          "args": [
            "test_var",
            "0"
          ],
          "line": 664
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KCSAN_EXPECT_RW_BARRIER",
          "args": [
            "smp_mb__after_spinlock()",
            "true"
          ],
          "line": 663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_mb__after_spinlock",
          "args": [],
          "line": 663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KCSAN_EXPECT_RW_BARRIER",
          "args": [
            "smp_mb__after_atomic()",
            "true"
          ],
          "line": 662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_mb__after_atomic",
          "args": [],
          "line": 662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KCSAN_EXPECT_RW_BARRIER",
          "args": [
            "smp_mb__before_atomic()",
            "true"
          ],
          "line": 661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_mb__before_atomic",
          "args": [],
          "line": 661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KCSAN_EXPECT_RW_BARRIER",
          "args": [
            "dma_rmb()",
            "true"
          ],
          "line": 660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dma_rmb",
          "args": [],
          "line": 660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KCSAN_EXPECT_RW_BARRIER",
          "args": [
            "dma_wmb()",
            "true"
          ],
          "line": 659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dma_wmb",
          "args": [],
          "line": 659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KCSAN_EXPECT_RW_BARRIER",
          "args": [
            "smp_rmb()",
            "true"
          ],
          "line": 658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_rmb",
          "args": [],
          "line": 658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KCSAN_EXPECT_RW_BARRIER",
          "args": [
            "smp_wmb()",
            "true"
          ],
          "line": 657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_wmb",
          "args": [],
          "line": 657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KCSAN_EXPECT_RW_BARRIER",
          "args": [
            "smp_mb()",
            "true"
          ],
          "line": 656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_mb",
          "args": [],
          "line": 656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KCSAN_EXPECT_RW_BARRIER",
          "args": [
            "rmb()",
            "true"
          ],
          "line": 655
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rmb",
          "args": [],
          "line": 655
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KCSAN_EXPECT_RW_BARRIER",
          "args": [
            "wmb()",
            "true"
          ],
          "line": 654
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wmb",
          "args": [],
          "line": 654
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KCSAN_EXPECT_RW_BARRIER",
          "args": [
            "mb()",
            "true"
          ],
          "line": 653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mb",
          "args": [],
          "line": 653
        },
        "resolved": true,
        "details": {
          "function_name": "decrement_wakelocks_number",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/wakelock.c",
          "lines": "81-81",
          "snippet": "static inline void decrement_wakelocks_number(void) {}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/list.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/ctype.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/list.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/ctype.h>\n#include <linux/capability.h>\n\nstatic inline void decrement_wakelocks_number(void) {}"
        }
      },
      {
        "call_info": {
          "callee": "KCSAN_EXPECT_WRITE_BARRIER",
          "args": [
            "mutex_unlock(&test_mutex)",
            "true"
          ],
          "line": 651
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KCSAN_EXPECT_WRITE_BARRIER",
          "args": [
            "mutex_lock(&test_mutex)",
            "false"
          ],
          "line": 650
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KCSAN_EXPECT_WRITE_BARRIER",
          "args": [
            "spin_unlock(&test_spinlock)",
            "true"
          ],
          "line": 649
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KCSAN_EXPECT_WRITE_BARRIER",
          "args": [
            "spin_lock(&test_spinlock)",
            "false"
          ],
          "line": 648
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KCSAN_EXPECT_WRITE_BARRIER",
          "args": [
            "arch_spin_unlock(&arch_spinlock)",
            "true"
          ],
          "line": 647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_spin_unlock",
          "args": [
            "&arch_spinlock"
          ],
          "line": 647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KCSAN_EXPECT_WRITE_BARRIER",
          "args": [
            "arch_spin_lock(&arch_spinlock)",
            "false"
          ],
          "line": 646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_spin_lock",
          "args": [
            "&arch_spinlock"
          ],
          "line": 646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KCSAN_EXPECT_WRITE_BARRIER",
          "args": [
            "__clear_bit_unlock(0, &test_var)",
            "true"
          ],
          "line": 645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__clear_bit_unlock",
          "args": [
            "0",
            "&test_var"
          ],
          "line": 645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KCSAN_EXPECT_WRITE_BARRIER",
          "args": [
            "clear_bit_unlock(0, &test_var)",
            "true"
          ],
          "line": 644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_bit_unlock",
          "args": [
            "0",
            "&test_var"
          ],
          "line": 644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KCSAN_EXPECT_WRITE_BARRIER",
          "args": [
            "test_and_change_bit(0, &test_var)",
            "true"
          ],
          "line": 643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_and_change_bit",
          "args": [
            "0",
            "&test_var"
          ],
          "line": 643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KCSAN_EXPECT_WRITE_BARRIER",
          "args": [
            "test_and_clear_bit(0, &test_var)",
            "true"
          ],
          "line": 642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_and_clear_bit",
          "args": [
            "0",
            "&test_var"
          ],
          "line": 642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KCSAN_EXPECT_WRITE_BARRIER",
          "args": [
            "test_and_set_bit(0, &test_var)",
            "true"
          ],
          "line": 641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_and_set_bit",
          "args": [
            "0",
            "&test_var"
          ],
          "line": 641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KCSAN_EXPECT_WRITE_BARRIER",
          "args": [
            "atomic_fetch_add_relaxed(1, &dummy)",
            "false"
          ],
          "line": 640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_fetch_add_relaxed",
          "args": [
            "1",
            "&dummy"
          ],
          "line": 640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KCSAN_EXPECT_WRITE_BARRIER",
          "args": [
            "atomic_fetch_add_release(1, &dummy)",
            "true"
          ],
          "line": 639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_fetch_add_release",
          "args": [
            "1",
            "&dummy"
          ],
          "line": 639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KCSAN_EXPECT_WRITE_BARRIER",
          "args": [
            "atomic_fetch_add_acquire(1, &dummy)",
            "false"
          ],
          "line": 638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_fetch_add_acquire",
          "args": [
            "1",
            "&dummy"
          ],
          "line": 638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KCSAN_EXPECT_WRITE_BARRIER",
          "args": [
            "atomic_fetch_add(1, &dummy)",
            "true"
          ],
          "line": 637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_fetch_add",
          "args": [
            "1",
            "&dummy"
          ],
          "line": 637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KCSAN_EXPECT_WRITE_BARRIER",
          "args": [
            "atomic_add_return_relaxed(1, &dummy)",
            "false"
          ],
          "line": 636
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_add_return_relaxed",
          "args": [
            "1",
            "&dummy"
          ],
          "line": 636
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KCSAN_EXPECT_WRITE_BARRIER",
          "args": [
            "atomic_add_return_release(1, &dummy)",
            "true"
          ],
          "line": 635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_add_return_release",
          "args": [
            "1",
            "&dummy"
          ],
          "line": 635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KCSAN_EXPECT_WRITE_BARRIER",
          "args": [
            "atomic_add_return_acquire(1, &dummy)",
            "false"
          ],
          "line": 634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_add_return_acquire",
          "args": [
            "1",
            "&dummy"
          ],
          "line": 634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KCSAN_EXPECT_WRITE_BARRIER",
          "args": [
            "atomic_add_return(1, &dummy)",
            "true"
          ],
          "line": 633
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_add_return",
          "args": [
            "1",
            "&dummy"
          ],
          "line": 633
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KCSAN_EXPECT_WRITE_BARRIER",
          "args": [
            "atomic_add(1, &dummy)",
            "false"
          ],
          "line": 632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_add",
          "args": [
            "1",
            "&dummy"
          ],
          "line": 632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KCSAN_EXPECT_WRITE_BARRIER",
          "args": [
            "atomic_set_release(&dummy, 0)",
            "true"
          ],
          "line": 631
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set_release",
          "args": [
            "&dummy",
            "0"
          ],
          "line": 631
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KCSAN_EXPECT_WRITE_BARRIER",
          "args": [
            "atomic_set(&dummy, 0)",
            "false"
          ],
          "line": 630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&dummy",
            "0"
          ],
          "line": 630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KCSAN_EXPECT_WRITE_BARRIER",
          "args": [
            "atomic_read_acquire(&dummy)",
            "false"
          ],
          "line": 629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read_acquire",
          "args": [
            "&dummy"
          ],
          "line": 629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KCSAN_EXPECT_WRITE_BARRIER",
          "args": [
            "atomic_read(&dummy)",
            "false"
          ],
          "line": 628
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&dummy"
          ],
          "line": 628
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KCSAN_EXPECT_WRITE_BARRIER",
          "args": [
            "cmpxchg_relaxed(&test_var, 0,  0)",
            "false"
          ],
          "line": 627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cmpxchg_relaxed",
          "args": [
            "&test_var",
            "0",
            "0"
          ],
          "line": 627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KCSAN_EXPECT_WRITE_BARRIER",
          "args": [
            "cmpxchg_release(&test_var, 0,  0)",
            "true"
          ],
          "line": 626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KCSAN_EXPECT_WRITE_BARRIER",
          "args": [
            "cmpxchg(&test_var, 0,  0)",
            "true"
          ],
          "line": 625
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KCSAN_EXPECT_WRITE_BARRIER",
          "args": [
            "xchg_relaxed(&test_var, 0)",
            "false"
          ],
          "line": 624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xchg_relaxed",
          "args": [
            "&test_var",
            "0"
          ],
          "line": 624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KCSAN_EXPECT_WRITE_BARRIER",
          "args": [
            "xchg_release(&test_var, 0)",
            "true"
          ],
          "line": 623
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xchg_release",
          "args": [
            "&test_var",
            "0"
          ],
          "line": 623
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KCSAN_EXPECT_WRITE_BARRIER",
          "args": [
            "xchg(&test_var, 0)",
            "true"
          ],
          "line": 622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KCSAN_EXPECT_WRITE_BARRIER",
          "args": [
            "smp_store_release(&test_var, 0)",
            "true"
          ],
          "line": 621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_store_release",
          "args": [
            "&test_var",
            "0"
          ],
          "line": 621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KCSAN_EXPECT_WRITE_BARRIER",
          "args": [
            "smp_load_acquire(&test_var)",
            "false"
          ],
          "line": 620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_load_acquire",
          "args": [
            "&test_var"
          ],
          "line": 620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KCSAN_EXPECT_WRITE_BARRIER",
          "args": [
            "smp_store_mb(test_var, 0)",
            "true"
          ],
          "line": 619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_store_mb",
          "args": [
            "test_var",
            "0"
          ],
          "line": 619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KCSAN_EXPECT_WRITE_BARRIER",
          "args": [
            "smp_mb__after_spinlock()",
            "true"
          ],
          "line": 618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_mb__after_spinlock",
          "args": [],
          "line": 618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KCSAN_EXPECT_WRITE_BARRIER",
          "args": [
            "smp_mb__after_atomic()",
            "true"
          ],
          "line": 617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_mb__after_atomic",
          "args": [],
          "line": 617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KCSAN_EXPECT_WRITE_BARRIER",
          "args": [
            "smp_mb__before_atomic()",
            "true"
          ],
          "line": 616
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_mb__before_atomic",
          "args": [],
          "line": 616
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KCSAN_EXPECT_WRITE_BARRIER",
          "args": [
            "dma_rmb()",
            "false"
          ],
          "line": 615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dma_rmb",
          "args": [],
          "line": 615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KCSAN_EXPECT_WRITE_BARRIER",
          "args": [
            "dma_wmb()",
            "true"
          ],
          "line": 614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dma_wmb",
          "args": [],
          "line": 614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KCSAN_EXPECT_WRITE_BARRIER",
          "args": [
            "smp_rmb()",
            "false"
          ],
          "line": 613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_rmb",
          "args": [],
          "line": 613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KCSAN_EXPECT_WRITE_BARRIER",
          "args": [
            "smp_wmb()",
            "true"
          ],
          "line": 612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_wmb",
          "args": [],
          "line": 612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KCSAN_EXPECT_WRITE_BARRIER",
          "args": [
            "smp_mb()",
            "true"
          ],
          "line": 611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_mb",
          "args": [],
          "line": 611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KCSAN_EXPECT_WRITE_BARRIER",
          "args": [
            "rmb()",
            "false"
          ],
          "line": 610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rmb",
          "args": [],
          "line": 610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KCSAN_EXPECT_WRITE_BARRIER",
          "args": [
            "wmb()",
            "true"
          ],
          "line": 609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wmb",
          "args": [],
          "line": 609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KCSAN_EXPECT_WRITE_BARRIER",
          "args": [
            "mb()",
            "true"
          ],
          "line": 608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KCSAN_EXPECT_READ_BARRIER",
          "args": [
            "mutex_unlock(&test_mutex)",
            "true"
          ],
          "line": 606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KCSAN_EXPECT_READ_BARRIER",
          "args": [
            "mutex_lock(&test_mutex)",
            "false"
          ],
          "line": 605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KCSAN_EXPECT_READ_BARRIER",
          "args": [
            "spin_unlock(&test_spinlock)",
            "true"
          ],
          "line": 604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KCSAN_EXPECT_READ_BARRIER",
          "args": [
            "spin_lock(&test_spinlock)",
            "false"
          ],
          "line": 603
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KCSAN_EXPECT_READ_BARRIER",
          "args": [
            "arch_spin_unlock(&arch_spinlock)",
            "true"
          ],
          "line": 602
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_spin_unlock",
          "args": [
            "&arch_spinlock"
          ],
          "line": 602
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KCSAN_EXPECT_READ_BARRIER",
          "args": [
            "arch_spin_lock(&arch_spinlock)",
            "false"
          ],
          "line": 601
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_spin_lock",
          "args": [
            "&arch_spinlock"
          ],
          "line": 601
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KCSAN_EXPECT_READ_BARRIER",
          "args": [
            "__clear_bit_unlock(0, &test_var)",
            "true"
          ],
          "line": 600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__clear_bit_unlock",
          "args": [
            "0",
            "&test_var"
          ],
          "line": 600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KCSAN_EXPECT_READ_BARRIER",
          "args": [
            "clear_bit_unlock(0, &test_var)",
            "true"
          ],
          "line": 599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_bit_unlock",
          "args": [
            "0",
            "&test_var"
          ],
          "line": 599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KCSAN_EXPECT_READ_BARRIER",
          "args": [
            "test_and_change_bit(0, &test_var)",
            "true"
          ],
          "line": 598
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_and_change_bit",
          "args": [
            "0",
            "&test_var"
          ],
          "line": 598
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KCSAN_EXPECT_READ_BARRIER",
          "args": [
            "test_and_clear_bit(0, &test_var)",
            "true"
          ],
          "line": 597
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_and_clear_bit",
          "args": [
            "0",
            "&test_var"
          ],
          "line": 597
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KCSAN_EXPECT_READ_BARRIER",
          "args": [
            "test_and_set_bit(0, &test_var)",
            "true"
          ],
          "line": 596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_and_set_bit",
          "args": [
            "0",
            "&test_var"
          ],
          "line": 596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KCSAN_EXPECT_READ_BARRIER",
          "args": [
            "atomic_fetch_add_relaxed(1, &dummy)",
            "false"
          ],
          "line": 595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_fetch_add_relaxed",
          "args": [
            "1",
            "&dummy"
          ],
          "line": 595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KCSAN_EXPECT_READ_BARRIER",
          "args": [
            "atomic_fetch_add_release(1, &dummy)",
            "true"
          ],
          "line": 594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_fetch_add_release",
          "args": [
            "1",
            "&dummy"
          ],
          "line": 594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KCSAN_EXPECT_READ_BARRIER",
          "args": [
            "atomic_fetch_add_acquire(1, &dummy)",
            "false"
          ],
          "line": 593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_fetch_add_acquire",
          "args": [
            "1",
            "&dummy"
          ],
          "line": 593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KCSAN_EXPECT_READ_BARRIER",
          "args": [
            "atomic_fetch_add(1, &dummy)",
            "true"
          ],
          "line": 592
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_fetch_add",
          "args": [
            "1",
            "&dummy"
          ],
          "line": 592
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KCSAN_EXPECT_READ_BARRIER",
          "args": [
            "atomic_add_return_relaxed(1, &dummy)",
            "false"
          ],
          "line": 591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_add_return_relaxed",
          "args": [
            "1",
            "&dummy"
          ],
          "line": 591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KCSAN_EXPECT_READ_BARRIER",
          "args": [
            "atomic_add_return_release(1, &dummy)",
            "true"
          ],
          "line": 590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_add_return_release",
          "args": [
            "1",
            "&dummy"
          ],
          "line": 590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KCSAN_EXPECT_READ_BARRIER",
          "args": [
            "atomic_add_return_acquire(1, &dummy)",
            "false"
          ],
          "line": 589
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_add_return_acquire",
          "args": [
            "1",
            "&dummy"
          ],
          "line": 589
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KCSAN_EXPECT_READ_BARRIER",
          "args": [
            "atomic_add_return(1, &dummy)",
            "true"
          ],
          "line": 588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_add_return",
          "args": [
            "1",
            "&dummy"
          ],
          "line": 588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KCSAN_EXPECT_READ_BARRIER",
          "args": [
            "atomic_add(1, &dummy)",
            "false"
          ],
          "line": 587
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_add",
          "args": [
            "1",
            "&dummy"
          ],
          "line": 587
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KCSAN_EXPECT_READ_BARRIER",
          "args": [
            "atomic_set_release(&dummy, 0)",
            "true"
          ],
          "line": 586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set_release",
          "args": [
            "&dummy",
            "0"
          ],
          "line": 586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KCSAN_EXPECT_READ_BARRIER",
          "args": [
            "atomic_set(&dummy, 0)",
            "false"
          ],
          "line": 585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&dummy",
            "0"
          ],
          "line": 585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KCSAN_EXPECT_READ_BARRIER",
          "args": [
            "atomic_read_acquire(&dummy)",
            "false"
          ],
          "line": 584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read_acquire",
          "args": [
            "&dummy"
          ],
          "line": 584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KCSAN_EXPECT_READ_BARRIER",
          "args": [
            "atomic_read(&dummy)",
            "false"
          ],
          "line": 583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&dummy"
          ],
          "line": 583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KCSAN_EXPECT_READ_BARRIER",
          "args": [
            "cmpxchg_relaxed(&test_var, 0,  0)",
            "false"
          ],
          "line": 582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cmpxchg_relaxed",
          "args": [
            "&test_var",
            "0",
            "0"
          ],
          "line": 582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KCSAN_EXPECT_READ_BARRIER",
          "args": [
            "cmpxchg_release(&test_var, 0,  0)",
            "true"
          ],
          "line": 581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KCSAN_EXPECT_READ_BARRIER",
          "args": [
            "cmpxchg(&test_var, 0,  0)",
            "true"
          ],
          "line": 580
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KCSAN_EXPECT_READ_BARRIER",
          "args": [
            "xchg_relaxed(&test_var, 0)",
            "false"
          ],
          "line": 579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xchg_relaxed",
          "args": [
            "&test_var",
            "0"
          ],
          "line": 579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KCSAN_EXPECT_READ_BARRIER",
          "args": [
            "xchg_release(&test_var, 0)",
            "true"
          ],
          "line": 578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xchg_release",
          "args": [
            "&test_var",
            "0"
          ],
          "line": 578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KCSAN_EXPECT_READ_BARRIER",
          "args": [
            "xchg(&test_var, 0)",
            "true"
          ],
          "line": 577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KCSAN_EXPECT_READ_BARRIER",
          "args": [
            "smp_store_release(&test_var, 0)",
            "true"
          ],
          "line": 576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_store_release",
          "args": [
            "&test_var",
            "0"
          ],
          "line": 576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KCSAN_EXPECT_READ_BARRIER",
          "args": [
            "smp_load_acquire(&test_var)",
            "false"
          ],
          "line": 575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_load_acquire",
          "args": [
            "&test_var"
          ],
          "line": 575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KCSAN_EXPECT_READ_BARRIER",
          "args": [
            "smp_store_mb(test_var, 0)",
            "true"
          ],
          "line": 574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_store_mb",
          "args": [
            "test_var",
            "0"
          ],
          "line": 574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KCSAN_EXPECT_READ_BARRIER",
          "args": [
            "smp_mb__after_spinlock()",
            "true"
          ],
          "line": 573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_mb__after_spinlock",
          "args": [],
          "line": 573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KCSAN_EXPECT_READ_BARRIER",
          "args": [
            "smp_mb__after_atomic()",
            "true"
          ],
          "line": 572
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_mb__after_atomic",
          "args": [],
          "line": 572
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KCSAN_EXPECT_READ_BARRIER",
          "args": [
            "smp_mb__before_atomic()",
            "true"
          ],
          "line": 571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_mb__before_atomic",
          "args": [],
          "line": 571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KCSAN_EXPECT_READ_BARRIER",
          "args": [
            "dma_rmb()",
            "true"
          ],
          "line": 570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dma_rmb",
          "args": [],
          "line": 570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KCSAN_EXPECT_READ_BARRIER",
          "args": [
            "dma_wmb()",
            "false"
          ],
          "line": 569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dma_wmb",
          "args": [],
          "line": 569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KCSAN_EXPECT_READ_BARRIER",
          "args": [
            "smp_rmb()",
            "true"
          ],
          "line": 568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_rmb",
          "args": [],
          "line": 568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KCSAN_EXPECT_READ_BARRIER",
          "args": [
            "smp_wmb()",
            "false"
          ],
          "line": 567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_wmb",
          "args": [],
          "line": 567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KCSAN_EXPECT_READ_BARRIER",
          "args": [
            "smp_mb()",
            "true"
          ],
          "line": 566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_mb",
          "args": [],
          "line": 566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KCSAN_EXPECT_READ_BARRIER",
          "args": [
            "rmb()",
            "true"
          ],
          "line": 565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rmb",
          "args": [],
          "line": 565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KCSAN_EXPECT_READ_BARRIER",
          "args": [
            "wmb()",
            "false"
          ],
          "line": 564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wmb",
          "args": [],
          "line": 564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KCSAN_EXPECT_READ_BARRIER",
          "args": [
            "mb()",
            "true"
          ],
          "line": 563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kcsan_nestable_atomic_begin",
          "args": [],
          "line": 561
        },
        "resolved": true,
        "details": {
          "function_name": "kcsan_nestable_atomic_begin",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/core.c",
          "lines": "842-852",
          "snippet": "void kcsan_nestable_atomic_begin(void)\n{\n\t/*\n\t * Do *not* check and warn if we are in a flat atomic region: nestable\n\t * and flat atomic regions are independent from each other.\n\t * See include/linux/kcsan.h: struct kcsan_ctx comments for more\n\t * comments.\n\t */\n\n\t++get_ctx()->atomic_nest_count;\n}",
          "includes": [
            "#include \"permissive.h\"",
            "#include \"kcsan.h\"",
            "#include \"encoding.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/sched.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/bug.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"permissive.h\"\n#include \"kcsan.h\"\n#include \"encoding.h\"\n#include <linux/uaccess.h>\n#include <linux/sched.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/bug.h>\n#include <linux/atomic.h>\n\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nvoid kcsan_nestable_atomic_begin(void)\n{\n\t/*\n\t * Do *not* check and warn if we are in a flat atomic region: nestable\n\t * and flat atomic regions are independent from each other.\n\t * See include/linux/kcsan.h: struct kcsan_ctx comments for more\n\t * comments.\n\t */\n\n\t++get_ctx()->atomic_nest_count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "KUNIT_ASSERT_EQ",
          "args": [
            "test",
            "reorder_access->size",
            "sizeof(test_var)"
          ],
          "line": 559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__kcsan_check_read",
          "args": [
            "&test_var",
            "sizeof(test_var)"
          ],
          "line": 558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KCSAN_TEST_REQUIRES",
          "args": [
            "test",
            "IS_ENABLED(CONFIG_SMP)"
          ],
          "line": 531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_SMP"
          ],
          "line": 531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KCSAN_TEST_REQUIRES",
          "args": [
            "test",
            "reorder_access != NULL"
          ],
          "line": 530
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/printk.h>\n#include <linux/types.h>\n#include <linux/tracepoint.h>\n#include <linux/torture.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/seqlock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/kcsan-checks.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <kunit/test.h>\n\nstatic __always_inline const struct;\nstatic long test_var;\nstatic DEFINE_SPINLOCK(test_spinlock);\nstatic DEFINE_MUTEX(test_mutex);\n\nstatic void test_barrier_nothreads(struct kunit *test)\n{\n#ifdef CONFIG_KCSAN_WEAK_MEMORY\n\tstruct kcsan_scoped_access *reorder_access = &current->kcsan_ctx.reorder_access;\n#else\n\tstruct kcsan_scoped_access *reorder_access = NULL;\n#endif\n\tarch_spinlock_t arch_spinlock = __ARCH_SPIN_LOCK_UNLOCKED;\n\tatomic_t dummy;\n\n\tKCSAN_TEST_REQUIRES(test, reorder_access != NULL);\n\tKCSAN_TEST_REQUIRES(test, IS_ENABLED(CONFIG_SMP));\n\n#define __KCSAN_EXPECT_BARRIER(access_type, barrier, order_before, name)\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\t\t\t\\\n\t\treorder_access->type = (access_type) | KCSAN_ACCESS_SCOPED;\t\t\t\\\n\t\treorder_access->size = sizeof(test_var);\t\t\t\t\t\\\n\t\tbarrier;\t\t\t\t\t\t\t\t\t\\\n\t\tKUNIT_EXPECT_EQ_MSG(test, reorder_access->size,\t\t\t\t\t\\\n\t\t\t\t    order_before ? 0 : sizeof(test_var),\t\t\t\\\n\t\t\t\t    \"improperly instrumented type=(\" #access_type \"): \" name);\t\\\n\t} while (0)\n#define KCSAN_EXPECT_READ_BARRIER(b, o)  __KCSAN_EXPECT_BARRIER(0, b, o, #b)\n#define KCSAN_EXPECT_WRITE_BARRIER(b, o) __KCSAN_EXPECT_BARRIER(KCSAN_ACCESS_WRITE, b, o, #b)\n#define KCSAN_EXPECT_RW_BARRIER(b, o)    __KCSAN_EXPECT_BARRIER(KCSAN_ACCESS_COMPOUND | KCSAN_ACCESS_WRITE, b, o, #b)\n\n\t/*\n\t * Lockdep initialization can strengthen certain locking operations due\n\t * to calling into instrumented files; \"warm up\" our locks.\n\t */\n\tspin_lock(&test_spinlock);\n\tspin_unlock(&test_spinlock);\n\tmutex_lock(&test_mutex);\n\tmutex_unlock(&test_mutex);\n\n\t/* Force creating a valid entry in reorder_access first. */\n\ttest_var = 0;\n\twhile (test_var++ < 1000000 && reorder_access->size != sizeof(test_var))\n\t\t__kcsan_check_read(&test_var, sizeof(test_var));\n\tKUNIT_ASSERT_EQ(test, reorder_access->size, sizeof(test_var));\n\n\tkcsan_nestable_atomic_begin(); /* No watchpoints in called functions. */\n\n\tKCSAN_EXPECT_READ_BARRIER(mb(), true);\n\tKCSAN_EXPECT_READ_BARRIER(wmb(), false);\n\tKCSAN_EXPECT_READ_BARRIER(rmb(), true);\n\tKCSAN_EXPECT_READ_BARRIER(smp_mb(), true);\n\tKCSAN_EXPECT_READ_BARRIER(smp_wmb(), false);\n\tKCSAN_EXPECT_READ_BARRIER(smp_rmb(), true);\n\tKCSAN_EXPECT_READ_BARRIER(dma_wmb(), false);\n\tKCSAN_EXPECT_READ_BARRIER(dma_rmb(), true);\n\tKCSAN_EXPECT_READ_BARRIER(smp_mb__before_atomic(), true);\n\tKCSAN_EXPECT_READ_BARRIER(smp_mb__after_atomic(), true);\n\tKCSAN_EXPECT_READ_BARRIER(smp_mb__after_spinlock(), true);\n\tKCSAN_EXPECT_READ_BARRIER(smp_store_mb(test_var, 0), true);\n\tKCSAN_EXPECT_READ_BARRIER(smp_load_acquire(&test_var), false);\n\tKCSAN_EXPECT_READ_BARRIER(smp_store_release(&test_var, 0), true);\n\tKCSAN_EXPECT_READ_BARRIER(xchg(&test_var, 0), true);\n\tKCSAN_EXPECT_READ_BARRIER(xchg_release(&test_var, 0), true);\n\tKCSAN_EXPECT_READ_BARRIER(xchg_relaxed(&test_var, 0), false);\n\tKCSAN_EXPECT_READ_BARRIER(cmpxchg(&test_var, 0,  0), true);\n\tKCSAN_EXPECT_READ_BARRIER(cmpxchg_release(&test_var, 0,  0), true);\n\tKCSAN_EXPECT_READ_BARRIER(cmpxchg_relaxed(&test_var, 0,  0), false);\n\tKCSAN_EXPECT_READ_BARRIER(atomic_read(&dummy), false);\n\tKCSAN_EXPECT_READ_BARRIER(atomic_read_acquire(&dummy), false);\n\tKCSAN_EXPECT_READ_BARRIER(atomic_set(&dummy, 0), false);\n\tKCSAN_EXPECT_READ_BARRIER(atomic_set_release(&dummy, 0), true);\n\tKCSAN_EXPECT_READ_BARRIER(atomic_add(1, &dummy), false);\n\tKCSAN_EXPECT_READ_BARRIER(atomic_add_return(1, &dummy), true);\n\tKCSAN_EXPECT_READ_BARRIER(atomic_add_return_acquire(1, &dummy), false);\n\tKCSAN_EXPECT_READ_BARRIER(atomic_add_return_release(1, &dummy), true);\n\tKCSAN_EXPECT_READ_BARRIER(atomic_add_return_relaxed(1, &dummy), false);\n\tKCSAN_EXPECT_READ_BARRIER(atomic_fetch_add(1, &dummy), true);\n\tKCSAN_EXPECT_READ_BARRIER(atomic_fetch_add_acquire(1, &dummy), false);\n\tKCSAN_EXPECT_READ_BARRIER(atomic_fetch_add_release(1, &dummy), true);\n\tKCSAN_EXPECT_READ_BARRIER(atomic_fetch_add_relaxed(1, &dummy), false);\n\tKCSAN_EXPECT_READ_BARRIER(test_and_set_bit(0, &test_var), true);\n\tKCSAN_EXPECT_READ_BARRIER(test_and_clear_bit(0, &test_var), true);\n\tKCSAN_EXPECT_READ_BARRIER(test_and_change_bit(0, &test_var), true);\n\tKCSAN_EXPECT_READ_BARRIER(clear_bit_unlock(0, &test_var), true);\n\tKCSAN_EXPECT_READ_BARRIER(__clear_bit_unlock(0, &test_var), true);\n\tKCSAN_EXPECT_READ_BARRIER(arch_spin_lock(&arch_spinlock), false);\n\tKCSAN_EXPECT_READ_BARRIER(arch_spin_unlock(&arch_spinlock), true);\n\tKCSAN_EXPECT_READ_BARRIER(spin_lock(&test_spinlock), false);\n\tKCSAN_EXPECT_READ_BARRIER(spin_unlock(&test_spinlock), true);\n\tKCSAN_EXPECT_READ_BARRIER(mutex_lock(&test_mutex), false);\n\tKCSAN_EXPECT_READ_BARRIER(mutex_unlock(&test_mutex), true);\n\n\tKCSAN_EXPECT_WRITE_BARRIER(mb(), true);\n\tKCSAN_EXPECT_WRITE_BARRIER(wmb(), true);\n\tKCSAN_EXPECT_WRITE_BARRIER(rmb(), false);\n\tKCSAN_EXPECT_WRITE_BARRIER(smp_mb(), true);\n\tKCSAN_EXPECT_WRITE_BARRIER(smp_wmb(), true);\n\tKCSAN_EXPECT_WRITE_BARRIER(smp_rmb(), false);\n\tKCSAN_EXPECT_WRITE_BARRIER(dma_wmb(), true);\n\tKCSAN_EXPECT_WRITE_BARRIER(dma_rmb(), false);\n\tKCSAN_EXPECT_WRITE_BARRIER(smp_mb__before_atomic(), true);\n\tKCSAN_EXPECT_WRITE_BARRIER(smp_mb__after_atomic(), true);\n\tKCSAN_EXPECT_WRITE_BARRIER(smp_mb__after_spinlock(), true);\n\tKCSAN_EXPECT_WRITE_BARRIER(smp_store_mb(test_var, 0), true);\n\tKCSAN_EXPECT_WRITE_BARRIER(smp_load_acquire(&test_var), false);\n\tKCSAN_EXPECT_WRITE_BARRIER(smp_store_release(&test_var, 0), true);\n\tKCSAN_EXPECT_WRITE_BARRIER(xchg(&test_var, 0), true);\n\tKCSAN_EXPECT_WRITE_BARRIER(xchg_release(&test_var, 0), true);\n\tKCSAN_EXPECT_WRITE_BARRIER(xchg_relaxed(&test_var, 0), false);\n\tKCSAN_EXPECT_WRITE_BARRIER(cmpxchg(&test_var, 0,  0), true);\n\tKCSAN_EXPECT_WRITE_BARRIER(cmpxchg_release(&test_var, 0,  0), true);\n\tKCSAN_EXPECT_WRITE_BARRIER(cmpxchg_relaxed(&test_var, 0,  0), false);\n\tKCSAN_EXPECT_WRITE_BARRIER(atomic_read(&dummy), false);\n\tKCSAN_EXPECT_WRITE_BARRIER(atomic_read_acquire(&dummy), false);\n\tKCSAN_EXPECT_WRITE_BARRIER(atomic_set(&dummy, 0), false);\n\tKCSAN_EXPECT_WRITE_BARRIER(atomic_set_release(&dummy, 0), true);\n\tKCSAN_EXPECT_WRITE_BARRIER(atomic_add(1, &dummy), false);\n\tKCSAN_EXPECT_WRITE_BARRIER(atomic_add_return(1, &dummy), true);\n\tKCSAN_EXPECT_WRITE_BARRIER(atomic_add_return_acquire(1, &dummy), false);\n\tKCSAN_EXPECT_WRITE_BARRIER(atomic_add_return_release(1, &dummy), true);\n\tKCSAN_EXPECT_WRITE_BARRIER(atomic_add_return_relaxed(1, &dummy), false);\n\tKCSAN_EXPECT_WRITE_BARRIER(atomic_fetch_add(1, &dummy), true);\n\tKCSAN_EXPECT_WRITE_BARRIER(atomic_fetch_add_acquire(1, &dummy), false);\n\tKCSAN_EXPECT_WRITE_BARRIER(atomic_fetch_add_release(1, &dummy), true);\n\tKCSAN_EXPECT_WRITE_BARRIER(atomic_fetch_add_relaxed(1, &dummy), false);\n\tKCSAN_EXPECT_WRITE_BARRIER(test_and_set_bit(0, &test_var), true);\n\tKCSAN_EXPECT_WRITE_BARRIER(test_and_clear_bit(0, &test_var), true);\n\tKCSAN_EXPECT_WRITE_BARRIER(test_and_change_bit(0, &test_var), true);\n\tKCSAN_EXPECT_WRITE_BARRIER(clear_bit_unlock(0, &test_var), true);\n\tKCSAN_EXPECT_WRITE_BARRIER(__clear_bit_unlock(0, &test_var), true);\n\tKCSAN_EXPECT_WRITE_BARRIER(arch_spin_lock(&arch_spinlock), false);\n\tKCSAN_EXPECT_WRITE_BARRIER(arch_spin_unlock(&arch_spinlock), true);\n\tKCSAN_EXPECT_WRITE_BARRIER(spin_lock(&test_spinlock), false);\n\tKCSAN_EXPECT_WRITE_BARRIER(spin_unlock(&test_spinlock), true);\n\tKCSAN_EXPECT_WRITE_BARRIER(mutex_lock(&test_mutex), false);\n\tKCSAN_EXPECT_WRITE_BARRIER(mutex_unlock(&test_mutex), true);\n\n\tKCSAN_EXPECT_RW_BARRIER(mb(), true);\n\tKCSAN_EXPECT_RW_BARRIER(wmb(), true);\n\tKCSAN_EXPECT_RW_BARRIER(rmb(), true);\n\tKCSAN_EXPECT_RW_BARRIER(smp_mb(), true);\n\tKCSAN_EXPECT_RW_BARRIER(smp_wmb(), true);\n\tKCSAN_EXPECT_RW_BARRIER(smp_rmb(), true);\n\tKCSAN_EXPECT_RW_BARRIER(dma_wmb(), true);\n\tKCSAN_EXPECT_RW_BARRIER(dma_rmb(), true);\n\tKCSAN_EXPECT_RW_BARRIER(smp_mb__before_atomic(), true);\n\tKCSAN_EXPECT_RW_BARRIER(smp_mb__after_atomic(), true);\n\tKCSAN_EXPECT_RW_BARRIER(smp_mb__after_spinlock(), true);\n\tKCSAN_EXPECT_RW_BARRIER(smp_store_mb(test_var, 0), true);\n\tKCSAN_EXPECT_RW_BARRIER(smp_load_acquire(&test_var), false);\n\tKCSAN_EXPECT_RW_BARRIER(smp_store_release(&test_var, 0), true);\n\tKCSAN_EXPECT_RW_BARRIER(xchg(&test_var, 0), true);\n\tKCSAN_EXPECT_RW_BARRIER(xchg_release(&test_var, 0), true);\n\tKCSAN_EXPECT_RW_BARRIER(xchg_relaxed(&test_var, 0), false);\n\tKCSAN_EXPECT_RW_BARRIER(cmpxchg(&test_var, 0,  0), true);\n\tKCSAN_EXPECT_RW_BARRIER(cmpxchg_release(&test_var, 0,  0), true);\n\tKCSAN_EXPECT_RW_BARRIER(cmpxchg_relaxed(&test_var, 0,  0), false);\n\tKCSAN_EXPECT_RW_BARRIER(atomic_read(&dummy), false);\n\tKCSAN_EXPECT_RW_BARRIER(atomic_read_acquire(&dummy), false);\n\tKCSAN_EXPECT_RW_BARRIER(atomic_set(&dummy, 0), false);\n\tKCSAN_EXPECT_RW_BARRIER(atomic_set_release(&dummy, 0), true);\n\tKCSAN_EXPECT_RW_BARRIER(atomic_add(1, &dummy), false);\n\tKCSAN_EXPECT_RW_BARRIER(atomic_add_return(1, &dummy), true);\n\tKCSAN_EXPECT_RW_BARRIER(atomic_add_return_acquire(1, &dummy), false);\n\tKCSAN_EXPECT_RW_BARRIER(atomic_add_return_release(1, &dummy), true);\n\tKCSAN_EXPECT_RW_BARRIER(atomic_add_return_relaxed(1, &dummy), false);\n\tKCSAN_EXPECT_RW_BARRIER(atomic_fetch_add(1, &dummy), true);\n\tKCSAN_EXPECT_RW_BARRIER(atomic_fetch_add_acquire(1, &dummy), false);\n\tKCSAN_EXPECT_RW_BARRIER(atomic_fetch_add_release(1, &dummy), true);\n\tKCSAN_EXPECT_RW_BARRIER(atomic_fetch_add_relaxed(1, &dummy), false);\n\tKCSAN_EXPECT_RW_BARRIER(test_and_set_bit(0, &test_var), true);\n\tKCSAN_EXPECT_RW_BARRIER(test_and_clear_bit(0, &test_var), true);\n\tKCSAN_EXPECT_RW_BARRIER(test_and_change_bit(0, &test_var), true);\n\tKCSAN_EXPECT_RW_BARRIER(clear_bit_unlock(0, &test_var), true);\n\tKCSAN_EXPECT_RW_BARRIER(__clear_bit_unlock(0, &test_var), true);\n\tKCSAN_EXPECT_RW_BARRIER(arch_spin_lock(&arch_spinlock), false);\n\tKCSAN_EXPECT_RW_BARRIER(arch_spin_unlock(&arch_spinlock), true);\n\tKCSAN_EXPECT_RW_BARRIER(spin_lock(&test_spinlock), false);\n\tKCSAN_EXPECT_RW_BARRIER(spin_unlock(&test_spinlock), true);\n\tKCSAN_EXPECT_RW_BARRIER(mutex_lock(&test_mutex), false);\n\tKCSAN_EXPECT_RW_BARRIER(mutex_unlock(&test_mutex), true);\n\n#ifdef clear_bit_unlock_is_negative_byte\n\tKCSAN_EXPECT_READ_BARRIER(clear_bit_unlock_is_negative_byte(0, &test_var), true);\n\tKCSAN_EXPECT_WRITE_BARRIER(clear_bit_unlock_is_negative_byte(0, &test_var), true);\n\tKCSAN_EXPECT_RW_BARRIER(clear_bit_unlock_is_negative_byte(0, &test_var), true);\n#endif\n\tkcsan_nestable_atomic_end();\n}"
  },
  {
    "function_name": "test_kernel_xor_1bit",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/kcsan_test.c",
    "lines": "476-482",
    "snippet": "static noinline void test_kernel_xor_1bit(void)\n{\n\t/* Do not report data races between the read-writes. */\n\tkcsan_nestable_atomic_begin();\n\ttest_var ^= 0x10000;\n\tkcsan_nestable_atomic_end();\n}",
    "includes": [
      "#include <trace/events/printk.h>",
      "#include <linux/types.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/torture.h>",
      "#include <linux/timer.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kcsan-checks.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <kunit/test.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static long test_var;",
      "__no_kcsan\nstatic noinline",
      "__no_kcsan\nstatic noinline"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kcsan_nestable_atomic_end",
          "args": [],
          "line": 481
        },
        "resolved": true,
        "details": {
          "function_name": "kcsan_nestable_atomic_end",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/core.c",
          "lines": "855-868",
          "snippet": "void kcsan_nestable_atomic_end(void)\n{\n\tif (get_ctx()->atomic_nest_count-- == 0) {\n\t\t/*\n\t\t * Warn if kcsan_nestable_atomic_end() calls are unbalanced with\n\t\t * kcsan_nestable_atomic_begin() calls, which causes\n\t\t * atomic_nest_count to become negative and should not happen.\n\t\t */\n\t\tkcsan_nestable_atomic_begin(); /* restore to 0 */\n\t\tkcsan_disable_current(); /* disable to generate warning */\n\t\tWARN(1, \"Unbalanced %s()\", __func__);\n\t\tkcsan_enable_current();\n\t}\n}",
          "includes": [
            "#include \"permissive.h\"",
            "#include \"kcsan.h\"",
            "#include \"encoding.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/sched.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/bug.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"permissive.h\"\n#include \"kcsan.h\"\n#include \"encoding.h\"\n#include <linux/uaccess.h>\n#include <linux/sched.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/bug.h>\n#include <linux/atomic.h>\n\nvoid kcsan_nestable_atomic_end(void)\n{\n\tif (get_ctx()->atomic_nest_count-- == 0) {\n\t\t/*\n\t\t * Warn if kcsan_nestable_atomic_end() calls are unbalanced with\n\t\t * kcsan_nestable_atomic_begin() calls, which causes\n\t\t * atomic_nest_count to become negative and should not happen.\n\t\t */\n\t\tkcsan_nestable_atomic_begin(); /* restore to 0 */\n\t\tkcsan_disable_current(); /* disable to generate warning */\n\t\tWARN(1, \"Unbalanced %s()\", __func__);\n\t\tkcsan_enable_current();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kcsan_nestable_atomic_begin",
          "args": [],
          "line": 479
        },
        "resolved": true,
        "details": {
          "function_name": "kcsan_nestable_atomic_begin",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/core.c",
          "lines": "842-852",
          "snippet": "void kcsan_nestable_atomic_begin(void)\n{\n\t/*\n\t * Do *not* check and warn if we are in a flat atomic region: nestable\n\t * and flat atomic regions are independent from each other.\n\t * See include/linux/kcsan.h: struct kcsan_ctx comments for more\n\t * comments.\n\t */\n\n\t++get_ctx()->atomic_nest_count;\n}",
          "includes": [
            "#include \"permissive.h\"",
            "#include \"kcsan.h\"",
            "#include \"encoding.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/sched.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/bug.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"permissive.h\"\n#include \"kcsan.h\"\n#include \"encoding.h\"\n#include <linux/uaccess.h>\n#include <linux/sched.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/bug.h>\n#include <linux/atomic.h>\n\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nvoid kcsan_nestable_atomic_begin(void)\n{\n\t/*\n\t * Do *not* check and warn if we are in a flat atomic region: nestable\n\t * and flat atomic regions are independent from each other.\n\t * See include/linux/kcsan.h: struct kcsan_ctx comments for more\n\t * comments.\n\t */\n\n\t++get_ctx()->atomic_nest_count;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/printk.h>\n#include <linux/types.h>\n#include <linux/tracepoint.h>\n#include <linux/torture.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/seqlock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/kcsan-checks.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <kunit/test.h>\n\nstatic long test_var;\n__no_kcsan\nstatic noinline;\n__no_kcsan\nstatic noinline;\n\nstatic noinline void test_kernel_xor_1bit(void)\n{\n\t/* Do not report data races between the read-writes. */\n\tkcsan_nestable_atomic_begin();\n\ttest_var ^= 0x10000;\n\tkcsan_nestable_atomic_end();\n}"
  },
  {
    "function_name": "test_kernel_atomic_builtins",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/kcsan_test.c",
    "lines": "467-474",
    "snippet": "static noinline void test_kernel_atomic_builtins(void)\n{\n\t/*\n\t * Generate concurrent accesses, expecting no reports, ensuring KCSAN\n\t * treats builtin atomics as actually atomic.\n\t */\n\t__atomic_load_n(&test_var, __ATOMIC_RELAXED);\n}",
    "includes": [
      "#include <trace/events/printk.h>",
      "#include <linux/types.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/torture.h>",
      "#include <linux/timer.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kcsan-checks.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <kunit/test.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static long test_var;",
      "__no_kcsan\nstatic noinline",
      "__no_kcsan\nstatic noinline"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__atomic_load_n",
          "args": [
            "&test_var",
            "__ATOMIC_RELAXED"
          ],
          "line": 473
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/printk.h>\n#include <linux/types.h>\n#include <linux/tracepoint.h>\n#include <linux/torture.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/seqlock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/kcsan-checks.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <kunit/test.h>\n\nstatic long test_var;\n__no_kcsan\nstatic noinline;\n__no_kcsan\nstatic noinline;\n\nstatic noinline void test_kernel_atomic_builtins(void)\n{\n\t/*\n\t * Generate concurrent accesses, expecting no reports, ensuring KCSAN\n\t * treats builtin atomics as actually atomic.\n\t */\n\t__atomic_load_n(&test_var, __ATOMIC_RELAXED);\n}"
  },
  {
    "function_name": "test_kernel_seqlock_writer",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/kcsan_test.c",
    "lines": "458-465",
    "snippet": "static noinline void test_kernel_seqlock_writer(void)\n{\n\tunsigned long flags;\n\n\twrite_seqlock_irqsave(&test_seqlock, flags);\n\ttest_var++;\n\twrite_sequnlock_irqrestore(&test_seqlock, flags);\n}",
    "includes": [
      "#include <trace/events/printk.h>",
      "#include <linux/types.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/torture.h>",
      "#include <linux/timer.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kcsan-checks.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <kunit/test.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static long test_var;",
      "static DEFINE_SEQLOCK(test_seqlock);",
      "__no_kcsan\nstatic noinline",
      "__no_kcsan\nstatic noinline"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "write_sequnlock_irqrestore",
          "args": [
            "&test_seqlock",
            "flags"
          ],
          "line": 464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_seqlock_irqsave",
          "args": [
            "&test_seqlock",
            "flags"
          ],
          "line": 462
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/printk.h>\n#include <linux/types.h>\n#include <linux/tracepoint.h>\n#include <linux/torture.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/seqlock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/kcsan-checks.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <kunit/test.h>\n\nstatic long test_var;\nstatic DEFINE_SEQLOCK(test_seqlock);\n__no_kcsan\nstatic noinline;\n__no_kcsan\nstatic noinline;\n\nstatic noinline void test_kernel_seqlock_writer(void)\n{\n\tunsigned long flags;\n\n\twrite_seqlock_irqsave(&test_seqlock, flags);\n\ttest_var++;\n\twrite_sequnlock_irqrestore(&test_seqlock, flags);\n}"
  },
  {
    "function_name": "test_kernel_seqlock_reader",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/kcsan_test.c",
    "lines": "448-456",
    "snippet": "static noinline void test_kernel_seqlock_reader(void)\n{\n\tunsigned int seq;\n\n\tdo {\n\t\tseq = read_seqbegin(&test_seqlock);\n\t\tsink_value(test_var);\n\t} while (read_seqretry(&test_seqlock, seq));\n}",
    "includes": [
      "#include <trace/events/printk.h>",
      "#include <linux/types.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/torture.h>",
      "#include <linux/timer.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kcsan-checks.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <kunit/test.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static long test_var;",
      "static DEFINE_SEQLOCK(test_seqlock);",
      "__no_kcsan\nstatic noinline",
      "__no_kcsan\nstatic noinline"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "read_seqretry",
          "args": [
            "&test_seqlock",
            "seq"
          ],
          "line": 455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sink_value",
          "args": [
            "test_var"
          ],
          "line": 454
        },
        "resolved": true,
        "details": {
          "function_name": "sink_value",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/kcsan_test.c",
          "lines": "311-311",
          "snippet": "void sink_value(long v) { WRITE_ONCE(test_sink, v); }",
          "includes": [
            "#include <trace/events/printk.h>",
            "#include <linux/types.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/torture.h>",
            "#include <linux/timer.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kcsan-checks.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <kunit/test.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static long test_sink;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/printk.h>\n#include <linux/types.h>\n#include <linux/tracepoint.h>\n#include <linux/torture.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/seqlock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/kcsan-checks.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <kunit/test.h>\n\nstatic long test_sink;\n\nvoid sink_value(long v) { WRITE_ONCE(test_sink, v); }"
        }
      },
      {
        "call_info": {
          "callee": "read_seqbegin",
          "args": [
            "&test_seqlock"
          ],
          "line": 453
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/printk.h>\n#include <linux/types.h>\n#include <linux/tracepoint.h>\n#include <linux/torture.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/seqlock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/kcsan-checks.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <kunit/test.h>\n\nstatic long test_var;\nstatic DEFINE_SEQLOCK(test_seqlock);\n__no_kcsan\nstatic noinline;\n__no_kcsan\nstatic noinline;\n\nstatic noinline void test_kernel_seqlock_reader(void)\n{\n\tunsigned int seq;\n\n\tdo {\n\t\tseq = read_seqbegin(&test_seqlock);\n\t\tsink_value(test_var);\n\t} while (read_seqretry(&test_seqlock, seq));\n}"
  },
  {
    "function_name": "test_kernel_jiffies_reader",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/kcsan_test.c",
    "lines": "443-446",
    "snippet": "static noinline void test_kernel_jiffies_reader(void)\n{\n\tsink_value((long)jiffies);\n}",
    "includes": [
      "#include <trace/events/printk.h>",
      "#include <linux/types.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/torture.h>",
      "#include <linux/timer.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kcsan-checks.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <kunit/test.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "__no_kcsan\nstatic noinline",
      "__no_kcsan\nstatic noinline"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sink_value",
          "args": [
            "(long)jiffies"
          ],
          "line": 445
        },
        "resolved": true,
        "details": {
          "function_name": "sink_value",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/kcsan_test.c",
          "lines": "311-311",
          "snippet": "void sink_value(long v) { WRITE_ONCE(test_sink, v); }",
          "includes": [
            "#include <trace/events/printk.h>",
            "#include <linux/types.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/torture.h>",
            "#include <linux/timer.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kcsan-checks.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <kunit/test.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static long test_sink;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/printk.h>\n#include <linux/types.h>\n#include <linux/tracepoint.h>\n#include <linux/torture.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/seqlock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/kcsan-checks.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <kunit/test.h>\n\nstatic long test_sink;\n\nvoid sink_value(long v) { WRITE_ONCE(test_sink, v); }"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/printk.h>\n#include <linux/types.h>\n#include <linux/tracepoint.h>\n#include <linux/torture.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/seqlock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/kcsan-checks.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <kunit/test.h>\n\n__no_kcsan\nstatic noinline;\n__no_kcsan\nstatic noinline;\n\nstatic noinline void test_kernel_jiffies_reader(void)\n{\n\tsink_value((long)jiffies);\n}"
  },
  {
    "function_name": "test_kernel_read_struct_zero_size",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/kcsan_test.c",
    "lines": "438-441",
    "snippet": "static noinline void test_kernel_read_struct_zero_size(void)\n{\n\tkcsan_check_read(&test_struct.val[3], 0);\n}",
    "includes": [
      "#include <trace/events/printk.h>",
      "#include <linux/types.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/torture.h>",
      "#include <linux/timer.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kcsan-checks.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <kunit/test.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct {\n\tlong val[8];\n} test_struct;",
      "__no_kcsan\nstatic noinline",
      "__no_kcsan\nstatic noinline"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kcsan_check_read",
          "args": [
            "&test_struct.val[3]",
            "0"
          ],
          "line": 440
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/printk.h>\n#include <linux/types.h>\n#include <linux/tracepoint.h>\n#include <linux/torture.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/seqlock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/kcsan-checks.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <kunit/test.h>\n\nstatic struct {\n\tlong val[8];\n} test_struct;\n__no_kcsan\nstatic noinline;\n__no_kcsan\nstatic noinline;\n\nstatic noinline void test_kernel_read_struct_zero_size(void)\n{\n\tkcsan_check_read(&test_struct.val[3], 0);\n}"
  },
  {
    "function_name": "test_kernel_write_struct_part",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/kcsan_test.c",
    "lines": "433-436",
    "snippet": "static noinline void test_kernel_write_struct_part(void)\n{\n\ttest_struct.val[3] = 42;\n}",
    "includes": [
      "#include <trace/events/printk.h>",
      "#include <linux/types.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/torture.h>",
      "#include <linux/timer.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kcsan-checks.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <kunit/test.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct {\n\tlong val[8];\n} test_struct;",
      "__no_kcsan\nstatic noinline",
      "__no_kcsan\nstatic noinline"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/printk.h>\n#include <linux/types.h>\n#include <linux/tracepoint.h>\n#include <linux/torture.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/seqlock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/kcsan-checks.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <kunit/test.h>\n\nstatic struct {\n\tlong val[8];\n} test_struct;\n__no_kcsan\nstatic noinline;\n__no_kcsan\nstatic noinline;\n\nstatic noinline void test_kernel_write_struct_part(void)\n{\n\ttest_struct.val[3] = 42;\n}"
  },
  {
    "function_name": "test_kernel_write_struct",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/kcsan_test.c",
    "lines": "425-431",
    "snippet": "static noinline void test_kernel_write_struct(void)\n{\n\tkcsan_check_write(&test_struct, sizeof(test_struct));\n\tkcsan_disable_current();\n\ttest_struct.val[3]++; /* induce value change */\n\tkcsan_enable_current();\n}",
    "includes": [
      "#include <trace/events/printk.h>",
      "#include <linux/types.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/torture.h>",
      "#include <linux/timer.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kcsan-checks.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <kunit/test.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct {\n\tlong val[8];\n} test_struct;",
      "__no_kcsan\nstatic noinline",
      "__no_kcsan\nstatic noinline"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kcsan_enable_current",
          "args": [],
          "line": 430
        },
        "resolved": true,
        "details": {
          "function_name": "kcsan_enable_current_nowarn",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/core.c",
          "lines": "835-839",
          "snippet": "void kcsan_enable_current_nowarn(void)\n{\n\tif (get_ctx()->disable_count-- == 0)\n\t\tkcsan_disable_current();\n}",
          "includes": [
            "#include \"permissive.h\"",
            "#include \"kcsan.h\"",
            "#include \"encoding.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/sched.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/bug.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"permissive.h\"\n#include \"kcsan.h\"\n#include \"encoding.h\"\n#include <linux/uaccess.h>\n#include <linux/sched.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/bug.h>\n#include <linux/atomic.h>\n\nvoid kcsan_enable_current_nowarn(void)\n{\n\tif (get_ctx()->disable_count-- == 0)\n\t\tkcsan_disable_current();\n}"
        }
      },
      {
        "call_info": {
          "callee": "kcsan_disable_current",
          "args": [],
          "line": 428
        },
        "resolved": true,
        "details": {
          "function_name": "kcsan_disable_current",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/core.c",
          "lines": "813-816",
          "snippet": "void kcsan_disable_current(void)\n{\n\t++get_ctx()->disable_count;\n}",
          "includes": [
            "#include \"permissive.h\"",
            "#include \"kcsan.h\"",
            "#include \"encoding.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/sched.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/bug.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"permissive.h\"\n#include \"kcsan.h\"\n#include \"encoding.h\"\n#include <linux/uaccess.h>\n#include <linux/sched.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/bug.h>\n#include <linux/atomic.h>\n\nvoid kcsan_disable_current(void)\n{\n\t++get_ctx()->disable_count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kcsan_check_write",
          "args": [
            "&test_struct",
            "sizeof(test_struct)"
          ],
          "line": 427
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/printk.h>\n#include <linux/types.h>\n#include <linux/tracepoint.h>\n#include <linux/torture.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/seqlock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/kcsan-checks.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <kunit/test.h>\n\nstatic struct {\n\tlong val[8];\n} test_struct;\n__no_kcsan\nstatic noinline;\n__no_kcsan\nstatic noinline;\n\nstatic noinline void test_kernel_write_struct(void)\n{\n\tkcsan_check_write(&test_struct, sizeof(test_struct));\n\tkcsan_disable_current();\n\ttest_struct.val[3]++; /* induce value change */\n\tkcsan_enable_current();\n}"
  },
  {
    "function_name": "test_kernel_rmw_array",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/kcsan_test.c",
    "lines": "417-423",
    "snippet": "static noinline void test_kernel_rmw_array(void)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(test_array); ++i)\n\t\ttest_array[i]++;\n}",
    "includes": [
      "#include <trace/events/printk.h>",
      "#include <linux/types.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/torture.h>",
      "#include <linux/timer.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kcsan-checks.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <kunit/test.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static long test_array[3 * PAGE_SIZE / sizeof(long)];",
      "__no_kcsan\nstatic noinline",
      "__no_kcsan\nstatic noinline"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "test_array"
          ],
          "line": 421
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/printk.h>\n#include <linux/types.h>\n#include <linux/tracepoint.h>\n#include <linux/torture.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/seqlock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/kcsan-checks.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <kunit/test.h>\n\nstatic long test_array[3 * PAGE_SIZE / sizeof(long)];\n__no_kcsan\nstatic noinline;\n__no_kcsan\nstatic noinline;\n\nstatic noinline void test_kernel_rmw_array(void)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(test_array); ++i)\n\t\ttest_array[i]++;\n}"
  },
  {
    "function_name": "test_kernel_assert_access_scoped",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/kcsan_test.c",
    "lines": "411-415",
    "snippet": "static noinline void test_kernel_assert_access_scoped(void)\n{\n\tASSERT_EXCLUSIVE_ACCESS_SCOPED(test_var);\n\ttest_enter_scope();\n}",
    "includes": [
      "#include <trace/events/printk.h>",
      "#include <linux/types.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/torture.h>",
      "#include <linux/timer.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kcsan-checks.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <kunit/test.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static long test_var;",
      "__no_kcsan\nstatic noinline",
      "__no_kcsan\nstatic noinline"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "test_enter_scope",
          "args": [],
          "line": 414
        },
        "resolved": true,
        "details": {
          "function_name": "test_enter_scope",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/kcsan_test.c",
          "lines": "396-403",
          "snippet": "static noinline void test_enter_scope(void)\n{\n\tint x = 0;\n\n\t/* Unrelated accesses to scoped assert. */\n\tREAD_ONCE(test_sink);\n\tkcsan_check_read(&x, sizeof(x));\n}",
          "includes": [
            "#include <trace/events/printk.h>",
            "#include <linux/types.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/torture.h>",
            "#include <linux/timer.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kcsan-checks.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <kunit/test.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static long test_sink;",
            "__no_kcsan\nstatic noinline",
            "__no_kcsan\nstatic noinline"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/printk.h>\n#include <linux/types.h>\n#include <linux/tracepoint.h>\n#include <linux/torture.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/seqlock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/kcsan-checks.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <kunit/test.h>\n\nstatic long test_sink;\n__no_kcsan\nstatic noinline;\n__no_kcsan\nstatic noinline;\n\nstatic noinline void test_enter_scope(void)\n{\n\tint x = 0;\n\n\t/* Unrelated accesses to scoped assert. */\n\tREAD_ONCE(test_sink);\n\tkcsan_check_read(&x, sizeof(x));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT_EXCLUSIVE_ACCESS_SCOPED",
          "args": [
            "test_var"
          ],
          "line": 413
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/printk.h>\n#include <linux/types.h>\n#include <linux/tracepoint.h>\n#include <linux/torture.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/seqlock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/kcsan-checks.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <kunit/test.h>\n\nstatic long test_var;\n__no_kcsan\nstatic noinline;\n__no_kcsan\nstatic noinline;\n\nstatic noinline void test_kernel_assert_access_scoped(void)\n{\n\tASSERT_EXCLUSIVE_ACCESS_SCOPED(test_var);\n\ttest_enter_scope();\n}"
  },
  {
    "function_name": "test_kernel_assert_writer_scoped",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/kcsan_test.c",
    "lines": "405-409",
    "snippet": "static noinline void test_kernel_assert_writer_scoped(void)\n{\n\tASSERT_EXCLUSIVE_WRITER_SCOPED(test_var);\n\ttest_enter_scope();\n}",
    "includes": [
      "#include <trace/events/printk.h>",
      "#include <linux/types.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/torture.h>",
      "#include <linux/timer.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kcsan-checks.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <kunit/test.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static long test_var;",
      "__no_kcsan\nstatic noinline",
      "__no_kcsan\nstatic noinline"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "test_enter_scope",
          "args": [],
          "line": 408
        },
        "resolved": true,
        "details": {
          "function_name": "test_enter_scope",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/kcsan_test.c",
          "lines": "396-403",
          "snippet": "static noinline void test_enter_scope(void)\n{\n\tint x = 0;\n\n\t/* Unrelated accesses to scoped assert. */\n\tREAD_ONCE(test_sink);\n\tkcsan_check_read(&x, sizeof(x));\n}",
          "includes": [
            "#include <trace/events/printk.h>",
            "#include <linux/types.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/torture.h>",
            "#include <linux/timer.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kcsan-checks.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <kunit/test.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static long test_sink;",
            "__no_kcsan\nstatic noinline",
            "__no_kcsan\nstatic noinline"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/printk.h>\n#include <linux/types.h>\n#include <linux/tracepoint.h>\n#include <linux/torture.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/seqlock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/kcsan-checks.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <kunit/test.h>\n\nstatic long test_sink;\n__no_kcsan\nstatic noinline;\n__no_kcsan\nstatic noinline;\n\nstatic noinline void test_enter_scope(void)\n{\n\tint x = 0;\n\n\t/* Unrelated accesses to scoped assert. */\n\tREAD_ONCE(test_sink);\n\tkcsan_check_read(&x, sizeof(x));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT_EXCLUSIVE_WRITER_SCOPED",
          "args": [
            "test_var"
          ],
          "line": 407
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/printk.h>\n#include <linux/types.h>\n#include <linux/tracepoint.h>\n#include <linux/torture.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/seqlock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/kcsan-checks.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <kunit/test.h>\n\nstatic long test_var;\n__no_kcsan\nstatic noinline;\n__no_kcsan\nstatic noinline;\n\nstatic noinline void test_kernel_assert_writer_scoped(void)\n{\n\tASSERT_EXCLUSIVE_WRITER_SCOPED(test_var);\n\ttest_enter_scope();\n}"
  },
  {
    "function_name": "test_enter_scope",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/kcsan_test.c",
    "lines": "396-403",
    "snippet": "static noinline void test_enter_scope(void)\n{\n\tint x = 0;\n\n\t/* Unrelated accesses to scoped assert. */\n\tREAD_ONCE(test_sink);\n\tkcsan_check_read(&x, sizeof(x));\n}",
    "includes": [
      "#include <trace/events/printk.h>",
      "#include <linux/types.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/torture.h>",
      "#include <linux/timer.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kcsan-checks.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <kunit/test.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static long test_sink;",
      "__no_kcsan\nstatic noinline",
      "__no_kcsan\nstatic noinline"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kcsan_check_read",
          "args": [
            "&x",
            "sizeof(x)"
          ],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "test_sink"
          ],
          "line": 401
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/printk.h>\n#include <linux/types.h>\n#include <linux/tracepoint.h>\n#include <linux/torture.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/seqlock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/kcsan-checks.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <kunit/test.h>\n\nstatic long test_sink;\n__no_kcsan\nstatic noinline;\n__no_kcsan\nstatic noinline;\n\nstatic noinline void test_enter_scope(void)\n{\n\tint x = 0;\n\n\t/* Unrelated accesses to scoped assert. */\n\tREAD_ONCE(test_sink);\n\tkcsan_check_read(&x, sizeof(x));\n}"
  },
  {
    "function_name": "test_kernel_assert_bits_nochange",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/kcsan_test.c",
    "lines": "387-390",
    "snippet": "static noinline void test_kernel_assert_bits_nochange(void)\n{\n\tASSERT_EXCLUSIVE_BITS(test_var, ~TEST_CHANGE_BITS);\n}",
    "includes": [
      "#include <trace/events/printk.h>",
      "#include <linux/types.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/torture.h>",
      "#include <linux/timer.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kcsan-checks.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <kunit/test.h>"
    ],
    "macros_used": [
      "#define TEST_CHANGE_BITS 0xff00ff00"
    ],
    "globals_used": [
      "static long test_var;",
      "__no_kcsan\nstatic noinline",
      "__no_kcsan\nstatic noinline"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ASSERT_EXCLUSIVE_BITS",
          "args": [
            "test_var",
            "~TEST_CHANGE_BITS"
          ],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/printk.h>\n#include <linux/types.h>\n#include <linux/tracepoint.h>\n#include <linux/torture.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/seqlock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/kcsan-checks.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <kunit/test.h>\n\n#define TEST_CHANGE_BITS 0xff00ff00\n\nstatic long test_var;\n__no_kcsan\nstatic noinline;\n__no_kcsan\nstatic noinline;\n\nstatic noinline void test_kernel_assert_bits_nochange(void)\n{\n\tASSERT_EXCLUSIVE_BITS(test_var, ~TEST_CHANGE_BITS);\n}"
  },
  {
    "function_name": "test_kernel_assert_bits_change",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/kcsan_test.c",
    "lines": "382-385",
    "snippet": "static noinline void test_kernel_assert_bits_change(void)\n{\n\tASSERT_EXCLUSIVE_BITS(test_var, TEST_CHANGE_BITS);\n}",
    "includes": [
      "#include <trace/events/printk.h>",
      "#include <linux/types.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/torture.h>",
      "#include <linux/timer.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kcsan-checks.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <kunit/test.h>"
    ],
    "macros_used": [
      "#define TEST_CHANGE_BITS 0xff00ff00"
    ],
    "globals_used": [
      "static long test_var;",
      "__no_kcsan\nstatic noinline",
      "__no_kcsan\nstatic noinline"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ASSERT_EXCLUSIVE_BITS",
          "args": [
            "test_var",
            "TEST_CHANGE_BITS"
          ],
          "line": 384
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/printk.h>\n#include <linux/types.h>\n#include <linux/tracepoint.h>\n#include <linux/torture.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/seqlock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/kcsan-checks.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <kunit/test.h>\n\n#define TEST_CHANGE_BITS 0xff00ff00\n\nstatic long test_var;\n__no_kcsan\nstatic noinline;\n__no_kcsan\nstatic noinline;\n\nstatic noinline void test_kernel_assert_bits_change(void)\n{\n\tASSERT_EXCLUSIVE_BITS(test_var, TEST_CHANGE_BITS);\n}"
  },
  {
    "function_name": "test_kernel_change_bits",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/kcsan_test.c",
    "lines": "368-380",
    "snippet": "static noinline void test_kernel_change_bits(void)\n{\n\tif (IS_ENABLED(CONFIG_KCSAN_IGNORE_ATOMICS)) {\n\t\t/*\n\t\t * Avoid race of unknown origin for this test, just pretend they\n\t\t * are atomic.\n\t\t */\n\t\tkcsan_nestable_atomic_begin();\n\t\ttest_var ^= TEST_CHANGE_BITS;\n\t\tkcsan_nestable_atomic_end();\n\t} else\n\t\tWRITE_ONCE(test_var, READ_ONCE(test_var) ^ TEST_CHANGE_BITS);\n}",
    "includes": [
      "#include <trace/events/printk.h>",
      "#include <linux/types.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/torture.h>",
      "#include <linux/timer.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kcsan-checks.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <kunit/test.h>"
    ],
    "macros_used": [
      "#define TEST_CHANGE_BITS 0xff00ff00"
    ],
    "globals_used": [
      "static long test_var;",
      "__no_kcsan\nstatic noinline",
      "__no_kcsan\nstatic noinline"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "test_var",
            "READ_ONCE(test_var) ^ TEST_CHANGE_BITS"
          ],
          "line": 379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "test_var"
          ],
          "line": 379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kcsan_nestable_atomic_end",
          "args": [],
          "line": 377
        },
        "resolved": true,
        "details": {
          "function_name": "kcsan_nestable_atomic_end",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/core.c",
          "lines": "855-868",
          "snippet": "void kcsan_nestable_atomic_end(void)\n{\n\tif (get_ctx()->atomic_nest_count-- == 0) {\n\t\t/*\n\t\t * Warn if kcsan_nestable_atomic_end() calls are unbalanced with\n\t\t * kcsan_nestable_atomic_begin() calls, which causes\n\t\t * atomic_nest_count to become negative and should not happen.\n\t\t */\n\t\tkcsan_nestable_atomic_begin(); /* restore to 0 */\n\t\tkcsan_disable_current(); /* disable to generate warning */\n\t\tWARN(1, \"Unbalanced %s()\", __func__);\n\t\tkcsan_enable_current();\n\t}\n}",
          "includes": [
            "#include \"permissive.h\"",
            "#include \"kcsan.h\"",
            "#include \"encoding.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/sched.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/bug.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"permissive.h\"\n#include \"kcsan.h\"\n#include \"encoding.h\"\n#include <linux/uaccess.h>\n#include <linux/sched.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/bug.h>\n#include <linux/atomic.h>\n\nvoid kcsan_nestable_atomic_end(void)\n{\n\tif (get_ctx()->atomic_nest_count-- == 0) {\n\t\t/*\n\t\t * Warn if kcsan_nestable_atomic_end() calls are unbalanced with\n\t\t * kcsan_nestable_atomic_begin() calls, which causes\n\t\t * atomic_nest_count to become negative and should not happen.\n\t\t */\n\t\tkcsan_nestable_atomic_begin(); /* restore to 0 */\n\t\tkcsan_disable_current(); /* disable to generate warning */\n\t\tWARN(1, \"Unbalanced %s()\", __func__);\n\t\tkcsan_enable_current();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kcsan_nestable_atomic_begin",
          "args": [],
          "line": 375
        },
        "resolved": true,
        "details": {
          "function_name": "kcsan_nestable_atomic_begin",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/core.c",
          "lines": "842-852",
          "snippet": "void kcsan_nestable_atomic_begin(void)\n{\n\t/*\n\t * Do *not* check and warn if we are in a flat atomic region: nestable\n\t * and flat atomic regions are independent from each other.\n\t * See include/linux/kcsan.h: struct kcsan_ctx comments for more\n\t * comments.\n\t */\n\n\t++get_ctx()->atomic_nest_count;\n}",
          "includes": [
            "#include \"permissive.h\"",
            "#include \"kcsan.h\"",
            "#include \"encoding.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/sched.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/bug.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"permissive.h\"\n#include \"kcsan.h\"\n#include \"encoding.h\"\n#include <linux/uaccess.h>\n#include <linux/sched.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/bug.h>\n#include <linux/atomic.h>\n\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nvoid kcsan_nestable_atomic_begin(void)\n{\n\t/*\n\t * Do *not* check and warn if we are in a flat atomic region: nestable\n\t * and flat atomic regions are independent from each other.\n\t * See include/linux/kcsan.h: struct kcsan_ctx comments for more\n\t * comments.\n\t */\n\n\t++get_ctx()->atomic_nest_count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_KCSAN_IGNORE_ATOMICS"
          ],
          "line": 370
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/printk.h>\n#include <linux/types.h>\n#include <linux/tracepoint.h>\n#include <linux/torture.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/seqlock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/kcsan-checks.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <kunit/test.h>\n\n#define TEST_CHANGE_BITS 0xff00ff00\n\nstatic long test_var;\n__no_kcsan\nstatic noinline;\n__no_kcsan\nstatic noinline;\n\nstatic noinline void test_kernel_change_bits(void)\n{\n\tif (IS_ENABLED(CONFIG_KCSAN_IGNORE_ATOMICS)) {\n\t\t/*\n\t\t * Avoid race of unknown origin for this test, just pretend they\n\t\t * are atomic.\n\t\t */\n\t\tkcsan_nestable_atomic_begin();\n\t\ttest_var ^= TEST_CHANGE_BITS;\n\t\tkcsan_nestable_atomic_end();\n\t} else\n\t\tWRITE_ONCE(test_var, READ_ONCE(test_var) ^ TEST_CHANGE_BITS);\n}"
  },
  {
    "function_name": "test_kernel_assert_access",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/kcsan_test.c",
    "lines": "361-364",
    "snippet": "static noinline void test_kernel_assert_access(void)\n{\n\tASSERT_EXCLUSIVE_ACCESS(test_var);\n}",
    "includes": [
      "#include <trace/events/printk.h>",
      "#include <linux/types.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/torture.h>",
      "#include <linux/timer.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kcsan-checks.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <kunit/test.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static long test_var;",
      "__no_kcsan\nstatic noinline",
      "__no_kcsan\nstatic noinline"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ASSERT_EXCLUSIVE_ACCESS",
          "args": [
            "test_var"
          ],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/printk.h>\n#include <linux/types.h>\n#include <linux/tracepoint.h>\n#include <linux/torture.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/seqlock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/kcsan-checks.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <kunit/test.h>\n\nstatic long test_var;\n__no_kcsan\nstatic noinline;\n__no_kcsan\nstatic noinline;\n\nstatic noinline void test_kernel_assert_access(void)\n{\n\tASSERT_EXCLUSIVE_ACCESS(test_var);\n}"
  },
  {
    "function_name": "test_kernel_assert_writer",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/kcsan_test.c",
    "lines": "356-359",
    "snippet": "static noinline void test_kernel_assert_writer(void)\n{\n\tASSERT_EXCLUSIVE_WRITER(test_var);\n}",
    "includes": [
      "#include <trace/events/printk.h>",
      "#include <linux/types.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/torture.h>",
      "#include <linux/timer.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kcsan-checks.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <kunit/test.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static long test_var;",
      "__no_kcsan\nstatic noinline",
      "__no_kcsan\nstatic noinline"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ASSERT_EXCLUSIVE_WRITER",
          "args": [
            "test_var"
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/printk.h>\n#include <linux/types.h>\n#include <linux/tracepoint.h>\n#include <linux/torture.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/seqlock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/kcsan-checks.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <kunit/test.h>\n\nstatic long test_var;\n__no_kcsan\nstatic noinline;\n__no_kcsan\nstatic noinline;\n\nstatic noinline void test_kernel_assert_writer(void)\n{\n\tASSERT_EXCLUSIVE_WRITER(test_var);\n}"
  },
  {
    "function_name": "test_kernel_data_race",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/kcsan_test.c",
    "lines": "354-354",
    "snippet": "static noinline void test_kernel_data_race(void) { data_race(test_var++); }",
    "includes": [
      "#include <trace/events/printk.h>",
      "#include <linux/types.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/torture.h>",
      "#include <linux/timer.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kcsan-checks.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <kunit/test.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static long test_var;",
      "__no_kcsan\nstatic noinline",
      "__no_kcsan\nstatic noinline"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "data_race",
          "args": [
            "test_var++"
          ],
          "line": 354
        },
        "resolved": true,
        "details": {
          "function_name": "test_data_race",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/kcsan_test.c",
          "lines": "998-1008",
          "snippet": "__no_kcsan\nstatic void test_data_race(struct kunit *test)\n{\n\tbool match_never = false;\n\n\tbegin_test_checks(test_kernel_data_race, test_kernel_data_race);\n\tdo {\n\t\tmatch_never = report_available();\n\t} while (!end_test_checks(match_never));\n\tKUNIT_EXPECT_FALSE(test, match_never);\n}",
          "includes": [
            "#include <trace/events/printk.h>",
            "#include <linux/types.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/torture.h>",
            "#include <linux/timer.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kcsan-checks.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <kunit/test.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline const struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/printk.h>\n#include <linux/types.h>\n#include <linux/tracepoint.h>\n#include <linux/torture.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/seqlock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/kcsan-checks.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <kunit/test.h>\n\nstatic __always_inline const struct;\n\n__no_kcsan\nstatic void test_data_race(struct kunit *test)\n{\n\tbool match_never = false;\n\n\tbegin_test_checks(test_kernel_data_race, test_kernel_data_race);\n\tdo {\n\t\tmatch_never = report_available();\n\t} while (!end_test_checks(match_never));\n\tKUNIT_EXPECT_FALSE(test, match_never);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/printk.h>\n#include <linux/types.h>\n#include <linux/tracepoint.h>\n#include <linux/torture.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/seqlock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/kcsan-checks.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <kunit/test.h>\n\nstatic long test_var;\n__no_kcsan\nstatic noinline;\n__no_kcsan\nstatic noinline;\n\nstatic noinline void test_kernel_data_race(void) { data_race(test_var++); }"
  },
  {
    "function_name": "test_kernel_write_uninstrumented",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/kcsan_test.c",
    "lines": "352-352",
    "snippet": "void test_kernel_write_uninstrumented(void) { test_var++; }",
    "includes": [
      "#include <trace/events/printk.h>",
      "#include <linux/types.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/torture.h>",
      "#include <linux/timer.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kcsan-checks.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <kunit/test.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static long test_var;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/printk.h>\n#include <linux/types.h>\n#include <linux/tracepoint.h>\n#include <linux/torture.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/seqlock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/kcsan-checks.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <kunit/test.h>\n\nstatic long test_var;\n\nvoid test_kernel_write_uninstrumented(void) { test_var++; }"
  },
  {
    "function_name": "test_kernel_atomic_rmw",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/kcsan_test.c",
    "lines": "345-349",
    "snippet": "static noinline void test_kernel_atomic_rmw(void)\n{\n\t/* Use builtin, so we can set up the \"bad\" atomic/non-atomic scenario. */\n\t__atomic_fetch_add(&test_var, 1, __ATOMIC_RELAXED);\n}",
    "includes": [
      "#include <trace/events/printk.h>",
      "#include <linux/types.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/torture.h>",
      "#include <linux/timer.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kcsan-checks.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <kunit/test.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static long test_var;",
      "__no_kcsan\nstatic noinline",
      "__no_kcsan\nstatic noinline"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__atomic_fetch_add",
          "args": [
            "&test_var",
            "1",
            "__ATOMIC_RELAXED"
          ],
          "line": 348
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/printk.h>\n#include <linux/types.h>\n#include <linux/tracepoint.h>\n#include <linux/torture.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/seqlock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/kcsan-checks.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <kunit/test.h>\n\nstatic long test_var;\n__no_kcsan\nstatic noinline;\n__no_kcsan\nstatic noinline;\n\nstatic noinline void test_kernel_atomic_rmw(void)\n{\n\t/* Use builtin, so we can set up the \"bad\" atomic/non-atomic scenario. */\n\t__atomic_fetch_add(&test_var, 1, __ATOMIC_RELAXED);\n}"
  },
  {
    "function_name": "test_kernel_write_atomic",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/kcsan_test.c",
    "lines": "340-343",
    "snippet": "static noinline void test_kernel_write_atomic(void)\n{\n\tWRITE_ONCE(test_var, READ_ONCE_NOCHECK(test_sink) + 1);\n}",
    "includes": [
      "#include <trace/events/printk.h>",
      "#include <linux/types.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/torture.h>",
      "#include <linux/timer.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kcsan-checks.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <kunit/test.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static long test_sink;",
      "static long test_var;",
      "__no_kcsan\nstatic noinline",
      "__no_kcsan\nstatic noinline"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "test_var",
            "READ_ONCE_NOCHECK(test_sink) + 1"
          ],
          "line": 342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE_NOCHECK",
          "args": [
            "test_sink"
          ],
          "line": 342
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/printk.h>\n#include <linux/types.h>\n#include <linux/tracepoint.h>\n#include <linux/torture.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/seqlock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/kcsan-checks.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <kunit/test.h>\n\nstatic long test_sink;\nstatic long test_var;\n__no_kcsan\nstatic noinline;\n__no_kcsan\nstatic noinline;\n\nstatic noinline void test_kernel_write_atomic(void)\n{\n\tWRITE_ONCE(test_var, READ_ONCE_NOCHECK(test_sink) + 1);\n}"
  },
  {
    "function_name": "test_kernel_read_atomic",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/kcsan_test.c",
    "lines": "335-338",
    "snippet": "static noinline void test_kernel_read_atomic(void)\n{\n\tsink_value(READ_ONCE(test_var));\n}",
    "includes": [
      "#include <trace/events/printk.h>",
      "#include <linux/types.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/torture.h>",
      "#include <linux/timer.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kcsan-checks.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <kunit/test.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static long test_var;",
      "__no_kcsan\nstatic noinline",
      "__no_kcsan\nstatic noinline"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sink_value",
          "args": [
            "READ_ONCE(test_var)"
          ],
          "line": 337
        },
        "resolved": true,
        "details": {
          "function_name": "sink_value",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/kcsan_test.c",
          "lines": "311-311",
          "snippet": "void sink_value(long v) { WRITE_ONCE(test_sink, v); }",
          "includes": [
            "#include <trace/events/printk.h>",
            "#include <linux/types.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/torture.h>",
            "#include <linux/timer.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kcsan-checks.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <kunit/test.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static long test_sink;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/printk.h>\n#include <linux/types.h>\n#include <linux/tracepoint.h>\n#include <linux/torture.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/seqlock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/kcsan-checks.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <kunit/test.h>\n\nstatic long test_sink;\n\nvoid sink_value(long v) { WRITE_ONCE(test_sink, v); }"
        }
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "test_var"
          ],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/printk.h>\n#include <linux/types.h>\n#include <linux/tracepoint.h>\n#include <linux/torture.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/seqlock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/kcsan-checks.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <kunit/test.h>\n\nstatic long test_var;\n__no_kcsan\nstatic noinline;\n__no_kcsan\nstatic noinline;\n\nstatic noinline void test_kernel_read_atomic(void)\n{\n\tsink_value(READ_ONCE(test_var));\n}"
  },
  {
    "function_name": "test_kernel_write_nochange_rcu",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/kcsan_test.c",
    "lines": "333-333",
    "snippet": "static noinline void test_kernel_write_nochange_rcu(void) { test_var = 42; }",
    "includes": [
      "#include <trace/events/printk.h>",
      "#include <linux/types.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/torture.h>",
      "#include <linux/timer.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kcsan-checks.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <kunit/test.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static long test_var;",
      "__no_kcsan\nstatic noinline",
      "__no_kcsan\nstatic noinline"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/printk.h>\n#include <linux/types.h>\n#include <linux/tracepoint.h>\n#include <linux/torture.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/seqlock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/kcsan-checks.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <kunit/test.h>\n\nstatic long test_var;\n__no_kcsan\nstatic noinline;\n__no_kcsan\nstatic noinline;\n\nstatic noinline void test_kernel_write_nochange_rcu(void) { test_var = 42; }"
  },
  {
    "function_name": "test_kernel_write_nochange",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/kcsan_test.c",
    "lines": "330-330",
    "snippet": "static noinline void test_kernel_write_nochange(void) { test_var = 42; }",
    "includes": [
      "#include <trace/events/printk.h>",
      "#include <linux/types.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/torture.h>",
      "#include <linux/timer.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kcsan-checks.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <kunit/test.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static long test_var;",
      "__no_kcsan\nstatic noinline",
      "__no_kcsan\nstatic noinline"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/printk.h>\n#include <linux/types.h>\n#include <linux/tracepoint.h>\n#include <linux/torture.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/seqlock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/kcsan-checks.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <kunit/test.h>\n\nstatic long test_var;\n__no_kcsan\nstatic noinline;\n__no_kcsan\nstatic noinline;\n\nstatic noinline void test_kernel_write_nochange(void) { test_var = 42; }"
  },
  {
    "function_name": "test_kernel_write",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/kcsan_test.c",
    "lines": "325-328",
    "snippet": "static noinline void test_kernel_write(void)\n{\n\ttest_var = READ_ONCE_NOCHECK(test_sink) + 1;\n}",
    "includes": [
      "#include <trace/events/printk.h>",
      "#include <linux/types.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/torture.h>",
      "#include <linux/timer.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kcsan-checks.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <kunit/test.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static long test_sink;",
      "static long test_var;",
      "__no_kcsan\nstatic noinline",
      "__no_kcsan\nstatic noinline"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "READ_ONCE_NOCHECK",
          "args": [
            "test_sink"
          ],
          "line": 327
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/printk.h>\n#include <linux/types.h>\n#include <linux/tracepoint.h>\n#include <linux/torture.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/seqlock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/kcsan-checks.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <kunit/test.h>\n\nstatic long test_sink;\nstatic long test_var;\n__no_kcsan\nstatic noinline;\n__no_kcsan\nstatic noinline;\n\nstatic noinline void test_kernel_write(void)\n{\n\ttest_var = READ_ONCE_NOCHECK(test_sink) + 1;\n}"
  },
  {
    "function_name": "test_kernel_read",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/kcsan_test.c",
    "lines": "323-323",
    "snippet": "static noinline void test_kernel_read(void) { sink_value(test_var); }",
    "includes": [
      "#include <trace/events/printk.h>",
      "#include <linux/types.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/torture.h>",
      "#include <linux/timer.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kcsan-checks.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <kunit/test.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static long test_var;",
      "__no_kcsan\nstatic noinline",
      "__no_kcsan\nstatic noinline"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sink_value",
          "args": [
            "test_var"
          ],
          "line": 323
        },
        "resolved": true,
        "details": {
          "function_name": "sink_value",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/kcsan_test.c",
          "lines": "311-311",
          "snippet": "void sink_value(long v) { WRITE_ONCE(test_sink, v); }",
          "includes": [
            "#include <trace/events/printk.h>",
            "#include <linux/types.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/torture.h>",
            "#include <linux/timer.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kcsan-checks.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <kunit/test.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static long test_sink;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/printk.h>\n#include <linux/types.h>\n#include <linux/tracepoint.h>\n#include <linux/torture.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/seqlock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/kcsan-checks.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <kunit/test.h>\n\nstatic long test_sink;\n\nvoid sink_value(long v) { WRITE_ONCE(test_sink, v); }"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/printk.h>\n#include <linux/types.h>\n#include <linux/tracepoint.h>\n#include <linux/torture.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/seqlock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/kcsan-checks.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <kunit/test.h>\n\nstatic long test_var;\n__no_kcsan\nstatic noinline;\n__no_kcsan\nstatic noinline;\n\nstatic noinline void test_kernel_read(void) { sink_value(test_var); }"
  },
  {
    "function_name": "test_delay",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/kcsan_test.c",
    "lines": "317-321",
    "snippet": "static noinline void test_delay(int iter)\n{\n\twhile (iter--)\n\t\tsink_value(READ_ONCE(test_sink));\n}",
    "includes": [
      "#include <trace/events/printk.h>",
      "#include <linux/types.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/torture.h>",
      "#include <linux/timer.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kcsan-checks.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <kunit/test.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static long test_sink;",
      "__no_kcsan\nstatic noinline",
      "__no_kcsan\nstatic noinline"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sink_value",
          "args": [
            "READ_ONCE(test_sink)"
          ],
          "line": 320
        },
        "resolved": true,
        "details": {
          "function_name": "sink_value",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/kcsan_test.c",
          "lines": "311-311",
          "snippet": "void sink_value(long v) { WRITE_ONCE(test_sink, v); }",
          "includes": [
            "#include <trace/events/printk.h>",
            "#include <linux/types.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/torture.h>",
            "#include <linux/timer.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kcsan-checks.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <kunit/test.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static long test_sink;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/printk.h>\n#include <linux/types.h>\n#include <linux/tracepoint.h>\n#include <linux/torture.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/seqlock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/kcsan-checks.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <kunit/test.h>\n\nstatic long test_sink;\n\nvoid sink_value(long v) { WRITE_ONCE(test_sink, v); }"
        }
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "test_sink"
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/printk.h>\n#include <linux/types.h>\n#include <linux/tracepoint.h>\n#include <linux/torture.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/seqlock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/kcsan-checks.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <kunit/test.h>\n\nstatic long test_sink;\n__no_kcsan\nstatic noinline;\n__no_kcsan\nstatic noinline;\n\nstatic noinline void test_delay(int iter)\n{\n\twhile (iter--)\n\t\tsink_value(READ_ONCE(test_sink));\n}"
  },
  {
    "function_name": "sink_value",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/kcsan_test.c",
    "lines": "311-311",
    "snippet": "void sink_value(long v) { WRITE_ONCE(test_sink, v); }",
    "includes": [
      "#include <trace/events/printk.h>",
      "#include <linux/types.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/torture.h>",
      "#include <linux/timer.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kcsan-checks.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <kunit/test.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static long test_sink;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "test_sink",
            "v"
          ],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/printk.h>\n#include <linux/types.h>\n#include <linux/tracepoint.h>\n#include <linux/torture.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/seqlock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/kcsan-checks.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <kunit/test.h>\n\nstatic long test_sink;\n\nvoid sink_value(long v) { WRITE_ONCE(test_sink, v); }"
  },
  {
    "function_name": "report_matches_any_reordered",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/kcsan_test.c",
    "lines": "277-284",
    "snippet": "__no_kcsan\nstatic bool report_matches_any_reordered(struct expect_report *r)\n{\n\treturn __report_matches(__report_set_scoped(r, 0)) ||\n\t       __report_matches(__report_set_scoped(r, 1)) ||\n\t       __report_matches(__report_set_scoped(r, 2)) ||\n\t       __report_matches(__report_set_scoped(r, 3));\n}",
    "includes": [
      "#include <trace/events/printk.h>",
      "#include <linux/types.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/torture.h>",
      "#include <linux/timer.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kcsan-checks.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <kunit/test.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline const struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__report_matches",
          "args": [
            "__report_set_scoped(r, 3)"
          ],
          "line": 283
        },
        "resolved": true,
        "details": {
          "function_name": "__report_matches",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/kcsan_test.c",
          "lines": "156-257",
          "snippet": "__no_kcsan\nstatic bool __report_matches(const struct expect_report *r)\n{\n\tconst bool is_assert = (r->access[0].type | r->access[1].type) & KCSAN_ACCESS_ASSERT;\n\tbool ret = false;\n\tunsigned long flags;\n\ttypeof(observed.lines) expect;\n\tconst char *end;\n\tchar *cur;\n\tint i;\n\n\t/* Doubled-checked locking. */\n\tif (!report_available())\n\t\treturn false;\n\n\t/* Generate expected report contents. */\n\n\t/* Title */\n\tcur = expect[0];\n\tend = &expect[0][sizeof(expect[0]) - 1];\n\tcur += scnprintf(cur, end - cur, \"BUG: KCSAN: %s in \",\n\t\t\t is_assert ? \"assert: race\" : \"data-race\");\n\tif (r->access[1].fn) {\n\t\tchar tmp[2][64];\n\t\tint cmp;\n\n\t\t/* Expect lexographically sorted function names in title. */\n\t\tscnprintf(tmp[0], sizeof(tmp[0]), \"%pS\", r->access[0].fn);\n\t\tscnprintf(tmp[1], sizeof(tmp[1]), \"%pS\", r->access[1].fn);\n\t\tcmp = strcmp(tmp[0], tmp[1]);\n\t\tcur += scnprintf(cur, end - cur, \"%ps / %ps\",\n\t\t\t\t cmp < 0 ? r->access[0].fn : r->access[1].fn,\n\t\t\t\t cmp < 0 ? r->access[1].fn : r->access[0].fn);\n\t} else {\n\t\tscnprintf(cur, end - cur, \"%pS\", r->access[0].fn);\n\t\t/* The exact offset won't match, remove it. */\n\t\tcur = strchr(expect[0], '+');\n\t\tif (cur)\n\t\t\t*cur = '\\0';\n\t}\n\n\t/* Access 1 */\n\tcur = expect[1];\n\tend = &expect[1][sizeof(expect[1]) - 1];\n\tif (!r->access[1].fn)\n\t\tcur += scnprintf(cur, end - cur, \"race at unknown origin, with \");\n\n\t/* Access 1 & 2 */\n\tfor (i = 0; i < 2; ++i) {\n\t\tconst int ty = r->access[i].type;\n\t\tconst char *const access_type =\n\t\t\t(ty & KCSAN_ACCESS_ASSERT) ?\n\t\t\t\t      ((ty & KCSAN_ACCESS_WRITE) ?\n\t\t\t\t\t       \"assert no accesses\" :\n\t\t\t\t\t       \"assert no writes\") :\n\t\t\t\t      ((ty & KCSAN_ACCESS_WRITE) ?\n\t\t\t\t\t       ((ty & KCSAN_ACCESS_COMPOUND) ?\n\t\t\t\t\t\t\t\"read-write\" :\n\t\t\t\t\t\t\t\"write\") :\n\t\t\t\t\t       \"read\");\n\t\tconst bool is_atomic = (ty & KCSAN_ACCESS_ATOMIC);\n\t\tconst bool is_scoped = (ty & KCSAN_ACCESS_SCOPED);\n\t\tconst char *const access_type_aux =\n\t\t\t\t(is_atomic && is_scoped)\t? \" (marked, reordered)\"\n\t\t\t\t: (is_atomic\t\t\t? \" (marked)\"\n\t\t\t\t   : (is_scoped\t\t\t? \" (reordered)\" : \"\"));\n\n\t\tif (i == 1) {\n\t\t\t/* Access 2 */\n\t\t\tcur = expect[2];\n\t\t\tend = &expect[2][sizeof(expect[2]) - 1];\n\n\t\t\tif (!r->access[1].fn) {\n\t\t\t\t/* Dummy string if no second access is available. */\n\t\t\t\tstrcpy(cur, \"<none>\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tcur += scnprintf(cur, end - cur, \"%s%s to \", access_type,\n\t\t\t\t access_type_aux);\n\n\t\tif (r->access[i].addr) /* Address is optional. */\n\t\t\tcur += scnprintf(cur, end - cur, \"0x%px of %zu bytes\",\n\t\t\t\t\t r->access[i].addr, r->access[i].size);\n\t}\n\n\tspin_lock_irqsave(&observed.lock, flags);\n\tif (!report_available())\n\t\tgoto out; /* A new report is being captured. */\n\n\t/* Finally match expected output to what we actually observed. */\n\tret = strstr(observed.lines[0], expect[0]) &&\n\t      /* Access info may appear in any order. */\n\t      ((strstr(observed.lines[1], expect[1]) &&\n\t\tstrstr(observed.lines[2], expect[2])) ||\n\t       (strstr(observed.lines[1], expect[2]) &&\n\t\tstrstr(observed.lines[2], expect[1])));\nout:\n\tspin_unlock_irqrestore(&observed.lock, flags);\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/printk.h>",
            "#include <linux/types.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/torture.h>",
            "#include <linux/timer.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kcsan-checks.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <kunit/test.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct {\n\tspinlock_t lock;\n\tint nlines;\n\tchar lines[3][512];\n} observed = {\n\t.lock = __SPIN_LOCK_UNLOCKED(observed.lock),\n};",
            "static __always_inline const struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/printk.h>\n#include <linux/types.h>\n#include <linux/tracepoint.h>\n#include <linux/torture.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/seqlock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/kcsan-checks.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <kunit/test.h>\n\nstatic struct {\n\tspinlock_t lock;\n\tint nlines;\n\tchar lines[3][512];\n} observed = {\n\t.lock = __SPIN_LOCK_UNLOCKED(observed.lock),\n};\nstatic __always_inline const struct;\n\n__no_kcsan\nstatic bool __report_matches(const struct expect_report *r)\n{\n\tconst bool is_assert = (r->access[0].type | r->access[1].type) & KCSAN_ACCESS_ASSERT;\n\tbool ret = false;\n\tunsigned long flags;\n\ttypeof(observed.lines) expect;\n\tconst char *end;\n\tchar *cur;\n\tint i;\n\n\t/* Doubled-checked locking. */\n\tif (!report_available())\n\t\treturn false;\n\n\t/* Generate expected report contents. */\n\n\t/* Title */\n\tcur = expect[0];\n\tend = &expect[0][sizeof(expect[0]) - 1];\n\tcur += scnprintf(cur, end - cur, \"BUG: KCSAN: %s in \",\n\t\t\t is_assert ? \"assert: race\" : \"data-race\");\n\tif (r->access[1].fn) {\n\t\tchar tmp[2][64];\n\t\tint cmp;\n\n\t\t/* Expect lexographically sorted function names in title. */\n\t\tscnprintf(tmp[0], sizeof(tmp[0]), \"%pS\", r->access[0].fn);\n\t\tscnprintf(tmp[1], sizeof(tmp[1]), \"%pS\", r->access[1].fn);\n\t\tcmp = strcmp(tmp[0], tmp[1]);\n\t\tcur += scnprintf(cur, end - cur, \"%ps / %ps\",\n\t\t\t\t cmp < 0 ? r->access[0].fn : r->access[1].fn,\n\t\t\t\t cmp < 0 ? r->access[1].fn : r->access[0].fn);\n\t} else {\n\t\tscnprintf(cur, end - cur, \"%pS\", r->access[0].fn);\n\t\t/* The exact offset won't match, remove it. */\n\t\tcur = strchr(expect[0], '+');\n\t\tif (cur)\n\t\t\t*cur = '\\0';\n\t}\n\n\t/* Access 1 */\n\tcur = expect[1];\n\tend = &expect[1][sizeof(expect[1]) - 1];\n\tif (!r->access[1].fn)\n\t\tcur += scnprintf(cur, end - cur, \"race at unknown origin, with \");\n\n\t/* Access 1 & 2 */\n\tfor (i = 0; i < 2; ++i) {\n\t\tconst int ty = r->access[i].type;\n\t\tconst char *const access_type =\n\t\t\t(ty & KCSAN_ACCESS_ASSERT) ?\n\t\t\t\t      ((ty & KCSAN_ACCESS_WRITE) ?\n\t\t\t\t\t       \"assert no accesses\" :\n\t\t\t\t\t       \"assert no writes\") :\n\t\t\t\t      ((ty & KCSAN_ACCESS_WRITE) ?\n\t\t\t\t\t       ((ty & KCSAN_ACCESS_COMPOUND) ?\n\t\t\t\t\t\t\t\"read-write\" :\n\t\t\t\t\t\t\t\"write\") :\n\t\t\t\t\t       \"read\");\n\t\tconst bool is_atomic = (ty & KCSAN_ACCESS_ATOMIC);\n\t\tconst bool is_scoped = (ty & KCSAN_ACCESS_SCOPED);\n\t\tconst char *const access_type_aux =\n\t\t\t\t(is_atomic && is_scoped)\t? \" (marked, reordered)\"\n\t\t\t\t: (is_atomic\t\t\t? \" (marked)\"\n\t\t\t\t   : (is_scoped\t\t\t? \" (reordered)\" : \"\"));\n\n\t\tif (i == 1) {\n\t\t\t/* Access 2 */\n\t\t\tcur = expect[2];\n\t\t\tend = &expect[2][sizeof(expect[2]) - 1];\n\n\t\t\tif (!r->access[1].fn) {\n\t\t\t\t/* Dummy string if no second access is available. */\n\t\t\t\tstrcpy(cur, \"<none>\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tcur += scnprintf(cur, end - cur, \"%s%s to \", access_type,\n\t\t\t\t access_type_aux);\n\n\t\tif (r->access[i].addr) /* Address is optional. */\n\t\t\tcur += scnprintf(cur, end - cur, \"0x%px of %zu bytes\",\n\t\t\t\t\t r->access[i].addr, r->access[i].size);\n\t}\n\n\tspin_lock_irqsave(&observed.lock, flags);\n\tif (!report_available())\n\t\tgoto out; /* A new report is being captured. */\n\n\t/* Finally match expected output to what we actually observed. */\n\tret = strstr(observed.lines[0], expect[0]) &&\n\t      /* Access info may appear in any order. */\n\t      ((strstr(observed.lines[1], expect[1]) &&\n\t\tstrstr(observed.lines[2], expect[2])) ||\n\t       (strstr(observed.lines[1], expect[2]) &&\n\t\tstrstr(observed.lines[2], expect[1])));\nout:\n\tspin_unlock_irqrestore(&observed.lock, flags);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__report_set_scoped",
          "args": [
            "r",
            "3"
          ],
          "line": 283
        },
        "resolved": true,
        "details": {
          "function_name": "__report_set_scoped",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/kcsan_test.c",
          "lines": "259-275",
          "snippet": "expect_report *\n__report_set_scoped(struct expect_report *r, int accesses)\n{\n\tBUILD_BUG_ON(accesses > 3);\n\n\tif (accesses & 1)\n\t\tr->access[0].type |= KCSAN_ACCESS_SCOPED;\n\telse\n\t\tr->access[0].type &= ~KCSAN_ACCESS_SCOPED;\n\n\tif (accesses & 2)\n\t\tr->access[1].type |= KCSAN_ACCESS_SCOPED;\n\telse\n\t\tr->access[1].type &= ~KCSAN_ACCESS_SCOPED;\n\n\treturn r;\n}",
          "includes": [
            "#include <trace/events/printk.h>",
            "#include <linux/types.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/torture.h>",
            "#include <linux/timer.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kcsan-checks.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <kunit/test.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline const struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/printk.h>\n#include <linux/types.h>\n#include <linux/tracepoint.h>\n#include <linux/torture.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/seqlock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/kcsan-checks.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <kunit/test.h>\n\nstatic __always_inline const struct;\n\nexpect_report *\n__report_set_scoped(struct expect_report *r, int accesses)\n{\n\tBUILD_BUG_ON(accesses > 3);\n\n\tif (accesses & 1)\n\t\tr->access[0].type |= KCSAN_ACCESS_SCOPED;\n\telse\n\t\tr->access[0].type &= ~KCSAN_ACCESS_SCOPED;\n\n\tif (accesses & 2)\n\t\tr->access[1].type |= KCSAN_ACCESS_SCOPED;\n\telse\n\t\tr->access[1].type &= ~KCSAN_ACCESS_SCOPED;\n\n\treturn r;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/printk.h>\n#include <linux/types.h>\n#include <linux/tracepoint.h>\n#include <linux/torture.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/seqlock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/kcsan-checks.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <kunit/test.h>\n\nstatic __always_inline const struct;\n\n__no_kcsan\nstatic bool report_matches_any_reordered(struct expect_report *r)\n{\n\treturn __report_matches(__report_set_scoped(r, 0)) ||\n\t       __report_matches(__report_set_scoped(r, 1)) ||\n\t       __report_matches(__report_set_scoped(r, 2)) ||\n\t       __report_matches(__report_set_scoped(r, 3));\n}"
  },
  {
    "function_name": "__report_set_scoped",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/kcsan_test.c",
    "lines": "259-275",
    "snippet": "expect_report *\n__report_set_scoped(struct expect_report *r, int accesses)\n{\n\tBUILD_BUG_ON(accesses > 3);\n\n\tif (accesses & 1)\n\t\tr->access[0].type |= KCSAN_ACCESS_SCOPED;\n\telse\n\t\tr->access[0].type &= ~KCSAN_ACCESS_SCOPED;\n\n\tif (accesses & 2)\n\t\tr->access[1].type |= KCSAN_ACCESS_SCOPED;\n\telse\n\t\tr->access[1].type &= ~KCSAN_ACCESS_SCOPED;\n\n\treturn r;\n}",
    "includes": [
      "#include <trace/events/printk.h>",
      "#include <linux/types.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/torture.h>",
      "#include <linux/timer.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kcsan-checks.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <kunit/test.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline const struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "accesses > 3"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/printk.h>\n#include <linux/types.h>\n#include <linux/tracepoint.h>\n#include <linux/torture.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/seqlock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/kcsan-checks.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <kunit/test.h>\n\nstatic __always_inline const struct;\n\nexpect_report *\n__report_set_scoped(struct expect_report *r, int accesses)\n{\n\tBUILD_BUG_ON(accesses > 3);\n\n\tif (accesses & 1)\n\t\tr->access[0].type |= KCSAN_ACCESS_SCOPED;\n\telse\n\t\tr->access[0].type &= ~KCSAN_ACCESS_SCOPED;\n\n\tif (accesses & 2)\n\t\tr->access[1].type |= KCSAN_ACCESS_SCOPED;\n\telse\n\t\tr->access[1].type &= ~KCSAN_ACCESS_SCOPED;\n\n\treturn r;\n}"
  },
  {
    "function_name": "__report_matches",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/kcsan_test.c",
    "lines": "156-257",
    "snippet": "__no_kcsan\nstatic bool __report_matches(const struct expect_report *r)\n{\n\tconst bool is_assert = (r->access[0].type | r->access[1].type) & KCSAN_ACCESS_ASSERT;\n\tbool ret = false;\n\tunsigned long flags;\n\ttypeof(observed.lines) expect;\n\tconst char *end;\n\tchar *cur;\n\tint i;\n\n\t/* Doubled-checked locking. */\n\tif (!report_available())\n\t\treturn false;\n\n\t/* Generate expected report contents. */\n\n\t/* Title */\n\tcur = expect[0];\n\tend = &expect[0][sizeof(expect[0]) - 1];\n\tcur += scnprintf(cur, end - cur, \"BUG: KCSAN: %s in \",\n\t\t\t is_assert ? \"assert: race\" : \"data-race\");\n\tif (r->access[1].fn) {\n\t\tchar tmp[2][64];\n\t\tint cmp;\n\n\t\t/* Expect lexographically sorted function names in title. */\n\t\tscnprintf(tmp[0], sizeof(tmp[0]), \"%pS\", r->access[0].fn);\n\t\tscnprintf(tmp[1], sizeof(tmp[1]), \"%pS\", r->access[1].fn);\n\t\tcmp = strcmp(tmp[0], tmp[1]);\n\t\tcur += scnprintf(cur, end - cur, \"%ps / %ps\",\n\t\t\t\t cmp < 0 ? r->access[0].fn : r->access[1].fn,\n\t\t\t\t cmp < 0 ? r->access[1].fn : r->access[0].fn);\n\t} else {\n\t\tscnprintf(cur, end - cur, \"%pS\", r->access[0].fn);\n\t\t/* The exact offset won't match, remove it. */\n\t\tcur = strchr(expect[0], '+');\n\t\tif (cur)\n\t\t\t*cur = '\\0';\n\t}\n\n\t/* Access 1 */\n\tcur = expect[1];\n\tend = &expect[1][sizeof(expect[1]) - 1];\n\tif (!r->access[1].fn)\n\t\tcur += scnprintf(cur, end - cur, \"race at unknown origin, with \");\n\n\t/* Access 1 & 2 */\n\tfor (i = 0; i < 2; ++i) {\n\t\tconst int ty = r->access[i].type;\n\t\tconst char *const access_type =\n\t\t\t(ty & KCSAN_ACCESS_ASSERT) ?\n\t\t\t\t      ((ty & KCSAN_ACCESS_WRITE) ?\n\t\t\t\t\t       \"assert no accesses\" :\n\t\t\t\t\t       \"assert no writes\") :\n\t\t\t\t      ((ty & KCSAN_ACCESS_WRITE) ?\n\t\t\t\t\t       ((ty & KCSAN_ACCESS_COMPOUND) ?\n\t\t\t\t\t\t\t\"read-write\" :\n\t\t\t\t\t\t\t\"write\") :\n\t\t\t\t\t       \"read\");\n\t\tconst bool is_atomic = (ty & KCSAN_ACCESS_ATOMIC);\n\t\tconst bool is_scoped = (ty & KCSAN_ACCESS_SCOPED);\n\t\tconst char *const access_type_aux =\n\t\t\t\t(is_atomic && is_scoped)\t? \" (marked, reordered)\"\n\t\t\t\t: (is_atomic\t\t\t? \" (marked)\"\n\t\t\t\t   : (is_scoped\t\t\t? \" (reordered)\" : \"\"));\n\n\t\tif (i == 1) {\n\t\t\t/* Access 2 */\n\t\t\tcur = expect[2];\n\t\t\tend = &expect[2][sizeof(expect[2]) - 1];\n\n\t\t\tif (!r->access[1].fn) {\n\t\t\t\t/* Dummy string if no second access is available. */\n\t\t\t\tstrcpy(cur, \"<none>\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tcur += scnprintf(cur, end - cur, \"%s%s to \", access_type,\n\t\t\t\t access_type_aux);\n\n\t\tif (r->access[i].addr) /* Address is optional. */\n\t\t\tcur += scnprintf(cur, end - cur, \"0x%px of %zu bytes\",\n\t\t\t\t\t r->access[i].addr, r->access[i].size);\n\t}\n\n\tspin_lock_irqsave(&observed.lock, flags);\n\tif (!report_available())\n\t\tgoto out; /* A new report is being captured. */\n\n\t/* Finally match expected output to what we actually observed. */\n\tret = strstr(observed.lines[0], expect[0]) &&\n\t      /* Access info may appear in any order. */\n\t      ((strstr(observed.lines[1], expect[1]) &&\n\t\tstrstr(observed.lines[2], expect[2])) ||\n\t       (strstr(observed.lines[1], expect[2]) &&\n\t\tstrstr(observed.lines[2], expect[1])));\nout:\n\tspin_unlock_irqrestore(&observed.lock, flags);\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/printk.h>",
      "#include <linux/types.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/torture.h>",
      "#include <linux/timer.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kcsan-checks.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <kunit/test.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct {\n\tspinlock_t lock;\n\tint nlines;\n\tchar lines[3][512];\n} observed = {\n\t.lock = __SPIN_LOCK_UNLOCKED(observed.lock),\n};",
      "static __always_inline const struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&observed.lock",
            "flags"
          ],
          "line": 255
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "192-195",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "observed.lines[2]",
            "expect[1]"
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "observed.lines[1]",
            "expect[2]"
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "observed.lines[2]",
            "expect[2]"
          ],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "observed.lines[1]",
            "expect[1]"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "observed.lines[0]",
            "expect[0]"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "report_available",
          "args": [],
          "line": 244
        },
        "resolved": true,
        "details": {
          "function_name": "report_available",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/kcsan_test.c",
          "lines": "138-142",
          "snippet": "__no_kcsan\nstatic bool report_available(void)\n{\n\treturn READ_ONCE(observed.nlines) == ARRAY_SIZE(observed.lines);\n}",
          "includes": [
            "#include <trace/events/printk.h>",
            "#include <linux/types.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/torture.h>",
            "#include <linux/timer.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kcsan-checks.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <kunit/test.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct {\n\tspinlock_t lock;\n\tint nlines;\n\tchar lines[3][512];\n} observed = {\n\t.lock = __SPIN_LOCK_UNLOCKED(observed.lock),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/printk.h>\n#include <linux/types.h>\n#include <linux/tracepoint.h>\n#include <linux/torture.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/seqlock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/kcsan-checks.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <kunit/test.h>\n\nstatic struct {\n\tspinlock_t lock;\n\tint nlines;\n\tchar lines[3][512];\n} observed = {\n\t.lock = __SPIN_LOCK_UNLOCKED(observed.lock),\n};\n\n__no_kcsan\nstatic bool report_available(void)\n{\n\treturn READ_ONCE(observed.nlines) == ARRAY_SIZE(observed.lines);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&observed.lock",
            "flags"
          ],
          "line": 243
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "383-393",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "scnprintf",
          "args": [
            "cur",
            "end - cur",
            "\"0x%px of %zu bytes\"",
            "r->access[i].addr",
            "r->access[i].size"
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scnprintf",
          "args": [
            "cur",
            "end - cur",
            "\"%s%s to \"",
            "access_type",
            "access_type_aux"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "cur",
            "\"<none>\""
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scnprintf",
          "args": [
            "cur",
            "end - cur",
            "\"race at unknown origin, with \""
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "expect[0]",
            "'+'"
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scnprintf",
          "args": [
            "cur",
            "end - cur",
            "\"%pS\"",
            "r->access[0].fn"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scnprintf",
          "args": [
            "cur",
            "end - cur",
            "\"%ps / %ps\"",
            "cmp < 0 ? r->access[0].fn : r->access[1].fn",
            "cmp < 0 ? r->access[1].fn : r->access[0].fn"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "tmp[0]",
            "tmp[1]"
          ],
          "line": 185
        },
        "resolved": true,
        "details": {
          "function_name": "sym_strcmp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/report.c",
          "lines": "356-365",
          "snippet": "static int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}",
          "includes": [
            "#include \"encoding.h\"",
            "#include \"kcsan.h\"",
            "#include <linux/stacktrace.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/delay.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"encoding.h\"\n#include \"kcsan.h\"\n#include <linux/stacktrace.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/lockdep.h>\n#include <linux/kernel.h>\n#include <linux/kallsyms.h>\n#include <linux/jiffies.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n\nstatic int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}"
        }
      },
      {
        "call_info": {
          "callee": "scnprintf",
          "args": [
            "tmp[1]",
            "sizeof(tmp[1])",
            "\"%pS\"",
            "r->access[1].fn"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scnprintf",
          "args": [
            "tmp[0]",
            "sizeof(tmp[0])",
            "\"%pS\"",
            "r->access[0].fn"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scnprintf",
          "args": [
            "cur",
            "end - cur",
            "\"BUG: KCSAN: %s in \"",
            "is_assert ? \"assert: race\" : \"data-race\""
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "typeof",
          "args": [
            "observed.lines"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/printk.h>\n#include <linux/types.h>\n#include <linux/tracepoint.h>\n#include <linux/torture.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/seqlock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/kcsan-checks.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <kunit/test.h>\n\nstatic struct {\n\tspinlock_t lock;\n\tint nlines;\n\tchar lines[3][512];\n} observed = {\n\t.lock = __SPIN_LOCK_UNLOCKED(observed.lock),\n};\nstatic __always_inline const struct;\n\n__no_kcsan\nstatic bool __report_matches(const struct expect_report *r)\n{\n\tconst bool is_assert = (r->access[0].type | r->access[1].type) & KCSAN_ACCESS_ASSERT;\n\tbool ret = false;\n\tunsigned long flags;\n\ttypeof(observed.lines) expect;\n\tconst char *end;\n\tchar *cur;\n\tint i;\n\n\t/* Doubled-checked locking. */\n\tif (!report_available())\n\t\treturn false;\n\n\t/* Generate expected report contents. */\n\n\t/* Title */\n\tcur = expect[0];\n\tend = &expect[0][sizeof(expect[0]) - 1];\n\tcur += scnprintf(cur, end - cur, \"BUG: KCSAN: %s in \",\n\t\t\t is_assert ? \"assert: race\" : \"data-race\");\n\tif (r->access[1].fn) {\n\t\tchar tmp[2][64];\n\t\tint cmp;\n\n\t\t/* Expect lexographically sorted function names in title. */\n\t\tscnprintf(tmp[0], sizeof(tmp[0]), \"%pS\", r->access[0].fn);\n\t\tscnprintf(tmp[1], sizeof(tmp[1]), \"%pS\", r->access[1].fn);\n\t\tcmp = strcmp(tmp[0], tmp[1]);\n\t\tcur += scnprintf(cur, end - cur, \"%ps / %ps\",\n\t\t\t\t cmp < 0 ? r->access[0].fn : r->access[1].fn,\n\t\t\t\t cmp < 0 ? r->access[1].fn : r->access[0].fn);\n\t} else {\n\t\tscnprintf(cur, end - cur, \"%pS\", r->access[0].fn);\n\t\t/* The exact offset won't match, remove it. */\n\t\tcur = strchr(expect[0], '+');\n\t\tif (cur)\n\t\t\t*cur = '\\0';\n\t}\n\n\t/* Access 1 */\n\tcur = expect[1];\n\tend = &expect[1][sizeof(expect[1]) - 1];\n\tif (!r->access[1].fn)\n\t\tcur += scnprintf(cur, end - cur, \"race at unknown origin, with \");\n\n\t/* Access 1 & 2 */\n\tfor (i = 0; i < 2; ++i) {\n\t\tconst int ty = r->access[i].type;\n\t\tconst char *const access_type =\n\t\t\t(ty & KCSAN_ACCESS_ASSERT) ?\n\t\t\t\t      ((ty & KCSAN_ACCESS_WRITE) ?\n\t\t\t\t\t       \"assert no accesses\" :\n\t\t\t\t\t       \"assert no writes\") :\n\t\t\t\t      ((ty & KCSAN_ACCESS_WRITE) ?\n\t\t\t\t\t       ((ty & KCSAN_ACCESS_COMPOUND) ?\n\t\t\t\t\t\t\t\"read-write\" :\n\t\t\t\t\t\t\t\"write\") :\n\t\t\t\t\t       \"read\");\n\t\tconst bool is_atomic = (ty & KCSAN_ACCESS_ATOMIC);\n\t\tconst bool is_scoped = (ty & KCSAN_ACCESS_SCOPED);\n\t\tconst char *const access_type_aux =\n\t\t\t\t(is_atomic && is_scoped)\t? \" (marked, reordered)\"\n\t\t\t\t: (is_atomic\t\t\t? \" (marked)\"\n\t\t\t\t   : (is_scoped\t\t\t? \" (reordered)\" : \"\"));\n\n\t\tif (i == 1) {\n\t\t\t/* Access 2 */\n\t\t\tcur = expect[2];\n\t\t\tend = &expect[2][sizeof(expect[2]) - 1];\n\n\t\t\tif (!r->access[1].fn) {\n\t\t\t\t/* Dummy string if no second access is available. */\n\t\t\t\tstrcpy(cur, \"<none>\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tcur += scnprintf(cur, end - cur, \"%s%s to \", access_type,\n\t\t\t\t access_type_aux);\n\n\t\tif (r->access[i].addr) /* Address is optional. */\n\t\t\tcur += scnprintf(cur, end - cur, \"0x%px of %zu bytes\",\n\t\t\t\t\t r->access[i].addr, r->access[i].size);\n\t}\n\n\tspin_lock_irqsave(&observed.lock, flags);\n\tif (!report_available())\n\t\tgoto out; /* A new report is being captured. */\n\n\t/* Finally match expected output to what we actually observed. */\n\tret = strstr(observed.lines[0], expect[0]) &&\n\t      /* Access info may appear in any order. */\n\t      ((strstr(observed.lines[1], expect[1]) &&\n\t\tstrstr(observed.lines[2], expect[2])) ||\n\t       (strstr(observed.lines[1], expect[2]) &&\n\t\tstrstr(observed.lines[2], expect[1])));\nout:\n\tspin_unlock_irqrestore(&observed.lock, flags);\n\treturn ret;\n}"
  },
  {
    "function_name": "report_available",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/kcsan_test.c",
    "lines": "138-142",
    "snippet": "__no_kcsan\nstatic bool report_available(void)\n{\n\treturn READ_ONCE(observed.nlines) == ARRAY_SIZE(observed.lines);\n}",
    "includes": [
      "#include <trace/events/printk.h>",
      "#include <linux/types.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/torture.h>",
      "#include <linux/timer.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kcsan-checks.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <kunit/test.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct {\n\tspinlock_t lock;\n\tint nlines;\n\tchar lines[3][512];\n} observed = {\n\t.lock = __SPIN_LOCK_UNLOCKED(observed.lock),\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "observed.lines"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "observed.nlines"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/printk.h>\n#include <linux/types.h>\n#include <linux/tracepoint.h>\n#include <linux/torture.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/seqlock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/kcsan-checks.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <kunit/test.h>\n\nstatic struct {\n\tspinlock_t lock;\n\tint nlines;\n\tchar lines[3][512];\n} observed = {\n\t.lock = __SPIN_LOCK_UNLOCKED(observed.lock),\n};\n\n__no_kcsan\nstatic bool report_available(void)\n{\n\treturn READ_ONCE(observed.nlines) == ARRAY_SIZE(observed.lines);\n}"
  },
  {
    "function_name": "probe_console",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/kcsan_test.c",
    "lines": "96-135",
    "snippet": "__no_kcsan\nstatic void probe_console(void *ignore, const char *buf, size_t len)\n{\n\tunsigned long flags;\n\tint nlines;\n\n\t/*\n\t * Note that KCSAN reports under a global lock, so we do not risk the\n\t * possibility of having multiple reports interleaved. If that were the\n\t * case, we'd expect tests to fail.\n\t */\n\n\tspin_lock_irqsave(&observed.lock, flags);\n\tnlines = observed.nlines;\n\n\tif (strnstr(buf, \"BUG: KCSAN: \", len) && strnstr(buf, \"test_\", len)) {\n\t\t/*\n\t\t * KCSAN report and related to the test.\n\t\t *\n\t\t * The provided @buf is not NUL-terminated; copy no more than\n\t\t * @len bytes and let strscpy() add the missing NUL-terminator.\n\t\t */\n\t\tstrscpy(observed.lines[0], buf, min(len + 1, sizeof(observed.lines[0])));\n\t\tnlines = 1;\n\t} else if ((nlines == 1 || nlines == 2) && strnstr(buf, \"bytes by\", len)) {\n\t\tstrscpy(observed.lines[nlines++], buf, min(len + 1, sizeof(observed.lines[0])));\n\n\t\tif (strnstr(buf, \"race at unknown origin\", len)) {\n\t\t\tif (WARN_ON(nlines != 2))\n\t\t\t\tgoto out;\n\n\t\t\t/* No second line of interest. */\n\t\t\tstrcpy(observed.lines[nlines++], \"<none>\");\n\t\t}\n\t}\n\nout:\n\tWRITE_ONCE(observed.nlines, nlines); /* Publish new nlines. */\n\tspin_unlock_irqrestore(&observed.lock, flags);\n}",
    "includes": [
      "#include <trace/events/printk.h>",
      "#include <linux/types.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/torture.h>",
      "#include <linux/timer.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kcsan-checks.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <kunit/test.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct {\n\tspinlock_t lock;\n\tint nlines;\n\tchar lines[3][512];\n} observed = {\n\t.lock = __SPIN_LOCK_UNLOCKED(observed.lock),\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&observed.lock",
            "flags"
          ],
          "line": 134
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "192-195",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "observed.nlines",
            "nlines"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "observed.lines[nlines++]",
            "\"<none>\""
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "nlines != 2"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strnstr",
          "args": [
            "buf",
            "\"race at unknown origin\"",
            "len"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strscpy",
          "args": [
            "observed.lines[nlines++]",
            "buf",
            "min(len + 1, sizeof(observed.lines[0]))"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "len + 1",
            "sizeof(observed.lines[0])"
          ],
          "line": 121
        },
        "resolved": true,
        "details": {
          "function_name": "irq_setup_timings",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/internals.h",
          "lines": "388-389",
          "snippet": "static inline void irq_setup_timings(struct irq_desc *desc,\n\t\t\t\t     struct irqaction *act) {}",
          "includes": [
            "#include <linux/debugfs.h>",
            "#include \"settings.h\"",
            "#include \"debug.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/pm_runtime.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/irqdesc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void __disable_irq(struct irq_desc *desc);",
            "extern void __enable_irq(struct irq_desc *desc);",
            "extern int irq_activate(struct irq_desc *desc);",
            "extern void irq_shutdown(struct irq_desc *desc);",
            "extern void irq_shutdown_and_deactivate(struct irq_desc *desc);",
            "extern void irq_enable(struct irq_desc *desc);",
            "extern void irq_disable(struct irq_desc *desc);",
            "extern void mask_irq(struct irq_desc *desc);",
            "extern void unmask_irq(struct irq_desc *desc);",
            "extern void unmask_threaded_irq(struct irq_desc *desc);",
            "irqreturn_t __handle_irq_event_percpu(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event_percpu(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event(struct irq_desc *desc);",
            "bool irq_wait_for_poll(struct irq_desc *desc);",
            "extern void irq_set_thread_affinity(struct irq_desc *desc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/debugfs.h>\n#include \"settings.h\"\n#include \"debug.h\"\n#include <linux/sched/clock.h>\n#include <linux/pm_runtime.h>\n#include <linux/kernel_stat.h>\n#include <linux/irqdesc.h>\n\nextern void __disable_irq(struct irq_desc *desc);\nextern void __enable_irq(struct irq_desc *desc);\nextern int irq_activate(struct irq_desc *desc);\nextern void irq_shutdown(struct irq_desc *desc);\nextern void irq_shutdown_and_deactivate(struct irq_desc *desc);\nextern void irq_enable(struct irq_desc *desc);\nextern void irq_disable(struct irq_desc *desc);\nextern void mask_irq(struct irq_desc *desc);\nextern void unmask_irq(struct irq_desc *desc);\nextern void unmask_threaded_irq(struct irq_desc *desc);\nirqreturn_t __handle_irq_event_percpu(struct irq_desc *desc);\nirqreturn_t handle_irq_event_percpu(struct irq_desc *desc);\nirqreturn_t handle_irq_event(struct irq_desc *desc);\nbool irq_wait_for_poll(struct irq_desc *desc);\nextern void irq_set_thread_affinity(struct irq_desc *desc);\n\nstatic inline void irq_setup_timings(struct irq_desc *desc,\n\t\t\t\t     struct irqaction *act) {}"
        }
      },
      {
        "call_info": {
          "callee": "strnstr",
          "args": [
            "buf",
            "\"bytes by\"",
            "len"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strscpy",
          "args": [
            "observed.lines[0]",
            "buf",
            "min(len + 1, sizeof(observed.lines[0]))"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strnstr",
          "args": [
            "buf",
            "\"test_\"",
            "len"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strnstr",
          "args": [
            "buf",
            "\"BUG: KCSAN: \"",
            "len"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&observed.lock",
            "flags"
          ],
          "line": 108
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "383-393",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/printk.h>\n#include <linux/types.h>\n#include <linux/tracepoint.h>\n#include <linux/torture.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/seqlock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/kcsan-checks.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <kunit/test.h>\n\nstatic struct {\n\tspinlock_t lock;\n\tint nlines;\n\tchar lines[3][512];\n} observed = {\n\t.lock = __SPIN_LOCK_UNLOCKED(observed.lock),\n};\n\n__no_kcsan\nstatic void probe_console(void *ignore, const char *buf, size_t len)\n{\n\tunsigned long flags;\n\tint nlines;\n\n\t/*\n\t * Note that KCSAN reports under a global lock, so we do not risk the\n\t * possibility of having multiple reports interleaved. If that were the\n\t * case, we'd expect tests to fail.\n\t */\n\n\tspin_lock_irqsave(&observed.lock, flags);\n\tnlines = observed.nlines;\n\n\tif (strnstr(buf, \"BUG: KCSAN: \", len) && strnstr(buf, \"test_\", len)) {\n\t\t/*\n\t\t * KCSAN report and related to the test.\n\t\t *\n\t\t * The provided @buf is not NUL-terminated; copy no more than\n\t\t * @len bytes and let strscpy() add the missing NUL-terminator.\n\t\t */\n\t\tstrscpy(observed.lines[0], buf, min(len + 1, sizeof(observed.lines[0])));\n\t\tnlines = 1;\n\t} else if ((nlines == 1 || nlines == 2) && strnstr(buf, \"bytes by\", len)) {\n\t\tstrscpy(observed.lines[nlines++], buf, min(len + 1, sizeof(observed.lines[0])));\n\n\t\tif (strnstr(buf, \"race at unknown origin\", len)) {\n\t\t\tif (WARN_ON(nlines != 2))\n\t\t\t\tgoto out;\n\n\t\t\t/* No second line of interest. */\n\t\t\tstrcpy(observed.lines[nlines++], \"<none>\");\n\t\t}\n\t}\n\nout:\n\tWRITE_ONCE(observed.nlines, nlines); /* Publish new nlines. */\n\tspin_unlock_irqrestore(&observed.lock, flags);\n}"
  },
  {
    "function_name": "end_test_checks",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/kcsan_test.c",
    "lines": "79-90",
    "snippet": "static __no_kcsan inline bool\nend_test_checks(bool stop)\n{\n\tif (!stop && time_before(jiffies, end_time)) {\n\t\t/* Continue checking */\n\t\tmight_sleep();\n\t\treturn false;\n\t}\n\n\tkcsan_enable_current();\n\treturn true;\n}",
    "includes": [
      "#include <trace/events/printk.h>",
      "#include <linux/types.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/torture.h>",
      "#include <linux/timer.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kcsan-checks.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <kunit/test.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned long end_time;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kcsan_enable_current",
          "args": [],
          "line": 88
        },
        "resolved": true,
        "details": {
          "function_name": "kcsan_enable_current_nowarn",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/core.c",
          "lines": "835-839",
          "snippet": "void kcsan_enable_current_nowarn(void)\n{\n\tif (get_ctx()->disable_count-- == 0)\n\t\tkcsan_disable_current();\n}",
          "includes": [
            "#include \"permissive.h\"",
            "#include \"kcsan.h\"",
            "#include \"encoding.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/sched.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/bug.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"permissive.h\"\n#include \"kcsan.h\"\n#include \"encoding.h\"\n#include <linux/uaccess.h>\n#include <linux/sched.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/bug.h>\n#include <linux/atomic.h>\n\nvoid kcsan_enable_current_nowarn(void)\n{\n\tif (get_ctx()->disable_count-- == 0)\n\t\tkcsan_disable_current();\n}"
        }
      },
      {
        "call_info": {
          "callee": "might_sleep",
          "args": [],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time_before",
          "args": [
            "jiffies",
            "end_time"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/printk.h>\n#include <linux/types.h>\n#include <linux/tracepoint.h>\n#include <linux/torture.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/seqlock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/kcsan-checks.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <kunit/test.h>\n\nstatic unsigned long end_time;\n\nstatic __no_kcsan inline bool\nend_test_checks(bool stop)\n{\n\tif (!stop && time_before(jiffies, end_time)) {\n\t\t/* Continue checking */\n\t\tmight_sleep();\n\t\treturn false;\n\t}\n\n\tkcsan_enable_current();\n\treturn true;\n}"
  },
  {
    "function_name": "begin_test_checks",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/kcsan_test.c",
    "lines": "62-76",
    "snippet": "static __no_kcsan inline void\nbegin_test_checks(void (*func1)(void), void (*func2)(void))\n{\n\tkcsan_disable_current();\n\n\t/*\n\t * Require at least as long as KCSAN_REPORT_ONCE_IN_MS, to ensure at\n\t * least one race is reported.\n\t */\n\tend_time = jiffies + msecs_to_jiffies(CONFIG_KCSAN_REPORT_ONCE_IN_MS + 500);\n\n\t/* Signal start; release potential initialization of shared data. */\n\tsmp_store_release(&access_kernels[0], func1);\n\tsmp_store_release(&access_kernels[1], func2);\n}",
    "includes": [
      "#include <trace/events/printk.h>",
      "#include <linux/types.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/torture.h>",
      "#include <linux/timer.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kcsan-checks.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <kunit/test.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void (*access_kernels[2])(void);",
      "static unsigned long end_time;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "smp_store_release",
          "args": [
            "&access_kernels[1]",
            "func2"
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_store_release",
          "args": [
            "&access_kernels[0]",
            "func1"
          ],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "msecs_to_jiffies",
          "args": [
            "CONFIG_KCSAN_REPORT_ONCE_IN_MS + 500"
          ],
          "line": 71
        },
        "resolved": true,
        "details": {
          "function_name": "__msecs_to_jiffies",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/time.c",
          "lines": "552-560",
          "snippet": "unsigned long __msecs_to_jiffies(const unsigned int m)\n{\n\t/*\n\t * Negative value, means infinite timeout:\n\t */\n\tif ((int)m < 0)\n\t\treturn MAX_JIFFY_OFFSET;\n\treturn _msecs_to_jiffies(m);\n}",
          "includes": [
            "#include \"timekeeping.h\"",
            "#include <generated/timeconst.h>",
            "#include <asm/unistd.h>",
            "#include <linux/compat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/math64.h>",
            "#include <linux/fs.h>",
            "#include <linux/security.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/errno.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/capability.h>",
            "#include <linux/timex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping.h\"\n#include <generated/timeconst.h>\n#include <asm/unistd.h>\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/math64.h>\n#include <linux/fs.h>\n#include <linux/security.h>\n#include <linux/syscalls.h>\n#include <linux/errno.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/capability.h>\n#include <linux/timex.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nunsigned long __msecs_to_jiffies(const unsigned int m)\n{\n\t/*\n\t * Negative value, means infinite timeout:\n\t */\n\tif ((int)m < 0)\n\t\treturn MAX_JIFFY_OFFSET;\n\treturn _msecs_to_jiffies(m);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kcsan_disable_current",
          "args": [],
          "line": 65
        },
        "resolved": true,
        "details": {
          "function_name": "kcsan_disable_current",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/core.c",
          "lines": "813-816",
          "snippet": "void kcsan_disable_current(void)\n{\n\t++get_ctx()->disable_count;\n}",
          "includes": [
            "#include \"permissive.h\"",
            "#include \"kcsan.h\"",
            "#include \"encoding.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/sched.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/bug.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"permissive.h\"\n#include \"kcsan.h\"\n#include \"encoding.h\"\n#include <linux/uaccess.h>\n#include <linux/sched.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/bug.h>\n#include <linux/atomic.h>\n\nvoid kcsan_disable_current(void)\n{\n\t++get_ctx()->disable_count;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/printk.h>\n#include <linux/types.h>\n#include <linux/tracepoint.h>\n#include <linux/torture.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/seqlock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/kcsan-checks.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <kunit/test.h>\n\nstatic void (*access_kernels[2])(void);\nstatic unsigned long end_time;\n\nstatic __no_kcsan inline void\nbegin_test_checks(void (*func1)(void), void (*func2)(void))\n{\n\tkcsan_disable_current();\n\n\t/*\n\t * Require at least as long as KCSAN_REPORT_ONCE_IN_MS, to ensure at\n\t * least one race is reported.\n\t */\n\tend_time = jiffies + msecs_to_jiffies(CONFIG_KCSAN_REPORT_ONCE_IN_MS + 500);\n\n\t/* Signal start; release potential initialization of shared data. */\n\tsmp_store_release(&access_kernels[0], func1);\n\tsmp_store_release(&access_kernels[1], func2);\n}"
  }
]