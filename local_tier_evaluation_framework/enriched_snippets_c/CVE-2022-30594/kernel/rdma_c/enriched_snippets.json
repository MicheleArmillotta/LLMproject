[
  {
    "function_name": "rdmacg_css_offline",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/rdma.c",
    "lines": "591-602",
    "snippet": "static void rdmacg_css_offline(struct cgroup_subsys_state *css)\n{\n\tstruct rdma_cgroup *cg = css_rdmacg(css);\n\tstruct rdmacg_resource_pool *rpool;\n\n\tmutex_lock(&rdmacg_mutex);\n\n\tlist_for_each_entry(rpool, &cg->rpools, cg_node)\n\t\tset_all_resource_max_limit(rpool);\n\n\tmutex_unlock(&rdmacg_mutex);\n}",
    "includes": [
      "#include <linux/cgroup_rdma.h>",
      "#include <linux/parser.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(rdmacg_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&rdmacg_mutex"
          ],
          "line": 601
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_all_resource_max_limit",
          "args": [
            "rpool"
          ],
          "line": 599
        },
        "resolved": true,
        "details": {
          "function_name": "set_all_resource_max_limit",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/rdma.c",
          "lines": "95-101",
          "snippet": "static void set_all_resource_max_limit(struct rdmacg_resource_pool *rpool)\n{\n\tint i;\n\n\tfor (i = 0; i < RDMACG_RESOURCE_MAX; i++)\n\t\tset_resource_limit(rpool, i, S32_MAX);\n}",
          "includes": [
            "#include <linux/cgroup_rdma.h>",
            "#include <linux/parser.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_rdma.h>\n#include <linux/parser.h>\n#include <linux/cgroup.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic void set_all_resource_max_limit(struct rdmacg_resource_pool *rpool)\n{\n\tint i;\n\n\tfor (i = 0; i < RDMACG_RESOURCE_MAX; i++)\n\t\tset_resource_limit(rpool, i, S32_MAX);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "rpool",
            "&cg->rpools",
            "cg_node"
          ],
          "line": 598
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&rdmacg_mutex"
          ],
          "line": 596
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "css_rdmacg",
          "args": [
            "css"
          ],
          "line": 593
        },
        "resolved": true,
        "details": {
          "function_name": "css_rdmacg",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/rdma.c",
          "lines": "67-70",
          "snippet": "static struct rdma_cgroup *css_rdmacg(struct cgroup_subsys_state *css)\n{\n\treturn container_of(css, struct rdma_cgroup, css);\n}",
          "includes": [
            "#include <linux/cgroup_rdma.h>",
            "#include <linux/parser.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_rdma.h>\n#include <linux/parser.h>\n#include <linux/cgroup.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic struct rdma_cgroup *css_rdmacg(struct cgroup_subsys_state *css)\n{\n\treturn container_of(css, struct rdma_cgroup, css);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_rdma.h>\n#include <linux/parser.h>\n#include <linux/cgroup.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic DEFINE_MUTEX(rdmacg_mutex);\n\nstatic void rdmacg_css_offline(struct cgroup_subsys_state *css)\n{\n\tstruct rdma_cgroup *cg = css_rdmacg(css);\n\tstruct rdmacg_resource_pool *rpool;\n\n\tmutex_lock(&rdmacg_mutex);\n\n\tlist_for_each_entry(rpool, &cg->rpools, cg_node)\n\t\tset_all_resource_max_limit(rpool);\n\n\tmutex_unlock(&rdmacg_mutex);\n}"
  },
  {
    "function_name": "rdmacg_css_free",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/rdma.c",
    "lines": "575-580",
    "snippet": "static void rdmacg_css_free(struct cgroup_subsys_state *css)\n{\n\tstruct rdma_cgroup *cg = css_rdmacg(css);\n\n\tkfree(cg);\n}",
    "includes": [
      "#include <linux/cgroup_rdma.h>",
      "#include <linux/parser.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "cg"
          ],
          "line": 579
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "css_rdmacg",
          "args": [
            "css"
          ],
          "line": 577
        },
        "resolved": true,
        "details": {
          "function_name": "css_rdmacg",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/rdma.c",
          "lines": "67-70",
          "snippet": "static struct rdma_cgroup *css_rdmacg(struct cgroup_subsys_state *css)\n{\n\treturn container_of(css, struct rdma_cgroup, css);\n}",
          "includes": [
            "#include <linux/cgroup_rdma.h>",
            "#include <linux/parser.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_rdma.h>\n#include <linux/parser.h>\n#include <linux/cgroup.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic struct rdma_cgroup *css_rdmacg(struct cgroup_subsys_state *css)\n{\n\treturn container_of(css, struct rdma_cgroup, css);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_rdma.h>\n#include <linux/parser.h>\n#include <linux/cgroup.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic void rdmacg_css_free(struct cgroup_subsys_state *css)\n{\n\tstruct rdma_cgroup *cg = css_rdmacg(css);\n\n\tkfree(cg);\n}"
  },
  {
    "function_name": "rdmacg_css_alloc",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/rdma.c",
    "lines": "562-573",
    "snippet": "static struct cgroup_subsys_state *\nrdmacg_css_alloc(struct cgroup_subsys_state *parent)\n{\n\tstruct rdma_cgroup *cg;\n\n\tcg = kzalloc(sizeof(*cg), GFP_KERNEL);\n\tif (!cg)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tINIT_LIST_HEAD(&cg->rpools);\n\treturn &cg->css;\n}",
    "includes": [
      "#include <linux/cgroup_rdma.h>",
      "#include <linux/parser.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&cg->rpools"
          ],
          "line": 571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*cg)",
            "GFP_KERNEL"
          ],
          "line": 567
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_rdma.h>\n#include <linux/parser.h>\n#include <linux/cgroup.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic struct cgroup_subsys_state *\nrdmacg_css_alloc(struct cgroup_subsys_state *parent)\n{\n\tstruct rdma_cgroup *cg;\n\n\tcg = kzalloc(sizeof(*cg), GFP_KERNEL);\n\tif (!cg)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tINIT_LIST_HEAD(&cg->rpools);\n\treturn &cg->css;\n}"
  },
  {
    "function_name": "rdmacg_resource_read",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/rdma.c",
    "lines": "524-543",
    "snippet": "static int rdmacg_resource_read(struct seq_file *sf, void *v)\n{\n\tstruct rdmacg_device *device;\n\tstruct rdmacg_resource_pool *rpool;\n\tstruct rdma_cgroup *cg = css_rdmacg(seq_css(sf));\n\n\tmutex_lock(&rdmacg_mutex);\n\n\tlist_for_each_entry(device, &rdmacg_devices, dev_node) {\n\t\tseq_printf(sf, \"%s \", device->name);\n\n\t\trpool = find_cg_rpool_locked(cg, device);\n\t\tprint_rpool_values(sf, rpool);\n\n\t\tseq_putc(sf, '\\n');\n\t}\n\n\tmutex_unlock(&rdmacg_mutex);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/cgroup_rdma.h>",
      "#include <linux/parser.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(rdmacg_mutex);",
      "static LIST_HEAD(rdmacg_devices);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&rdmacg_mutex"
          ],
          "line": 541
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_putc",
          "args": [
            "sf",
            "'\\n'"
          ],
          "line": 538
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_putc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "233-246",
          "snippet": "void trace_seq_putc(struct trace_seq *s, unsigned char c)\n{\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (TRACE_SEQ_BUF_LEFT(s) < 1) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putc(&s->seq, c);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_putc(struct trace_seq *s, unsigned char c)\n{\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (TRACE_SEQ_BUF_LEFT(s) < 1) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putc(&s->seq, c);\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_rpool_values",
          "args": [
            "sf",
            "rpool"
          ],
          "line": 536
        },
        "resolved": true,
        "details": {
          "function_name": "print_rpool_values",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/rdma.c",
          "lines": "492-522",
          "snippet": "static void print_rpool_values(struct seq_file *sf,\n\t\t\t       struct rdmacg_resource_pool *rpool)\n{\n\tenum rdmacg_file_type sf_type;\n\tint i;\n\tu32 value;\n\n\tsf_type = seq_cft(sf)->private;\n\n\tfor (i = 0; i < RDMACG_RESOURCE_MAX; i++) {\n\t\tseq_puts(sf, rdmacg_resource_names[i]);\n\t\tseq_putc(sf, '=');\n\t\tif (sf_type == RDMACG_RESOURCE_TYPE_MAX) {\n\t\t\tif (rpool)\n\t\t\t\tvalue = rpool->resources[i].max;\n\t\t\telse\n\t\t\t\tvalue = S32_MAX;\n\t\t} else {\n\t\t\tif (rpool)\n\t\t\t\tvalue = rpool->resources[i].usage;\n\t\t\telse\n\t\t\t\tvalue = 0;\n\t\t}\n\n\t\tif (value == S32_MAX)\n\t\t\tseq_puts(sf, RDMACG_MAX_STR);\n\t\telse\n\t\t\tseq_printf(sf, \"%d\", value);\n\t\tseq_putc(sf, ' ');\n\t}\n}",
          "includes": [
            "#include <linux/cgroup_rdma.h>",
            "#include <linux/parser.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [
            "#define RDMACG_MAX_STR \"max\""
          ],
          "globals_used": [
            "static char const *rdmacg_resource_names[] = {\n\t[RDMACG_RESOURCE_HCA_HANDLE]\t= \"hca_handle\",\n\t[RDMACG_RESOURCE_HCA_OBJECT]\t= \"hca_object\",\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_rdma.h>\n#include <linux/parser.h>\n#include <linux/cgroup.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\n#define RDMACG_MAX_STR \"max\"\n\nstatic char const *rdmacg_resource_names[] = {\n\t[RDMACG_RESOURCE_HCA_HANDLE]\t= \"hca_handle\",\n\t[RDMACG_RESOURCE_HCA_OBJECT]\t= \"hca_object\",\n};\n\nstatic void print_rpool_values(struct seq_file *sf,\n\t\t\t       struct rdmacg_resource_pool *rpool)\n{\n\tenum rdmacg_file_type sf_type;\n\tint i;\n\tu32 value;\n\n\tsf_type = seq_cft(sf)->private;\n\n\tfor (i = 0; i < RDMACG_RESOURCE_MAX; i++) {\n\t\tseq_puts(sf, rdmacg_resource_names[i]);\n\t\tseq_putc(sf, '=');\n\t\tif (sf_type == RDMACG_RESOURCE_TYPE_MAX) {\n\t\t\tif (rpool)\n\t\t\t\tvalue = rpool->resources[i].max;\n\t\t\telse\n\t\t\t\tvalue = S32_MAX;\n\t\t} else {\n\t\t\tif (rpool)\n\t\t\t\tvalue = rpool->resources[i].usage;\n\t\t\telse\n\t\t\t\tvalue = 0;\n\t\t}\n\n\t\tif (value == S32_MAX)\n\t\t\tseq_puts(sf, RDMACG_MAX_STR);\n\t\telse\n\t\t\tseq_printf(sf, \"%d\", value);\n\t\tseq_putc(sf, ' ');\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_cg_rpool_locked",
          "args": [
            "cg",
            "device"
          ],
          "line": 535
        },
        "resolved": true,
        "details": {
          "function_name": "find_cg_rpool_locked",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/rdma.c",
          "lines": "112-126",
          "snippet": "static struct rdmacg_resource_pool *\nfind_cg_rpool_locked(struct rdma_cgroup *cg,\n\t\t     struct rdmacg_device *device)\n\n{\n\tstruct rdmacg_resource_pool *pool;\n\n\tlockdep_assert_held(&rdmacg_mutex);\n\n\tlist_for_each_entry(pool, &cg->rpools, cg_node)\n\t\tif (pool->device == device)\n\t\t\treturn pool;\n\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/cgroup_rdma.h>",
            "#include <linux/parser.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(rdmacg_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_rdma.h>\n#include <linux/parser.h>\n#include <linux/cgroup.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic DEFINE_MUTEX(rdmacg_mutex);\n\nstatic struct rdmacg_resource_pool *\nfind_cg_rpool_locked(struct rdma_cgroup *cg,\n\t\t     struct rdmacg_device *device)\n\n{\n\tstruct rdmacg_resource_pool *pool;\n\n\tlockdep_assert_held(&rdmacg_mutex);\n\n\tlist_for_each_entry(pool, &cg->rpools, cg_node)\n\t\tif (pool->device == device)\n\t\t\treturn pool;\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "sf",
            "\"%s \"",
            "device->name"
          ],
          "line": 533
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "81-100",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "device",
            "&rdmacg_devices",
            "dev_node"
          ],
          "line": 532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&rdmacg_mutex"
          ],
          "line": 530
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "css_rdmacg",
          "args": [
            "seq_css(sf)"
          ],
          "line": 528
        },
        "resolved": true,
        "details": {
          "function_name": "css_rdmacg",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/rdma.c",
          "lines": "67-70",
          "snippet": "static struct rdma_cgroup *css_rdmacg(struct cgroup_subsys_state *css)\n{\n\treturn container_of(css, struct rdma_cgroup, css);\n}",
          "includes": [
            "#include <linux/cgroup_rdma.h>",
            "#include <linux/parser.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_rdma.h>\n#include <linux/parser.h>\n#include <linux/cgroup.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic struct rdma_cgroup *css_rdmacg(struct cgroup_subsys_state *css)\n{\n\treturn container_of(css, struct rdma_cgroup, css);\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_css",
          "args": [
            "sf"
          ],
          "line": 528
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_rdma.h>\n#include <linux/parser.h>\n#include <linux/cgroup.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic DEFINE_MUTEX(rdmacg_mutex);\nstatic LIST_HEAD(rdmacg_devices);\n\nstatic int rdmacg_resource_read(struct seq_file *sf, void *v)\n{\n\tstruct rdmacg_device *device;\n\tstruct rdmacg_resource_pool *rpool;\n\tstruct rdma_cgroup *cg = css_rdmacg(seq_css(sf));\n\n\tmutex_lock(&rdmacg_mutex);\n\n\tlist_for_each_entry(device, &rdmacg_devices, dev_node) {\n\t\tseq_printf(sf, \"%s \", device->name);\n\n\t\trpool = find_cg_rpool_locked(cg, device);\n\t\tprint_rpool_values(sf, rpool);\n\n\t\tseq_putc(sf, '\\n');\n\t}\n\n\tmutex_unlock(&rdmacg_mutex);\n\treturn 0;\n}"
  },
  {
    "function_name": "print_rpool_values",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/rdma.c",
    "lines": "492-522",
    "snippet": "static void print_rpool_values(struct seq_file *sf,\n\t\t\t       struct rdmacg_resource_pool *rpool)\n{\n\tenum rdmacg_file_type sf_type;\n\tint i;\n\tu32 value;\n\n\tsf_type = seq_cft(sf)->private;\n\n\tfor (i = 0; i < RDMACG_RESOURCE_MAX; i++) {\n\t\tseq_puts(sf, rdmacg_resource_names[i]);\n\t\tseq_putc(sf, '=');\n\t\tif (sf_type == RDMACG_RESOURCE_TYPE_MAX) {\n\t\t\tif (rpool)\n\t\t\t\tvalue = rpool->resources[i].max;\n\t\t\telse\n\t\t\t\tvalue = S32_MAX;\n\t\t} else {\n\t\t\tif (rpool)\n\t\t\t\tvalue = rpool->resources[i].usage;\n\t\t\telse\n\t\t\t\tvalue = 0;\n\t\t}\n\n\t\tif (value == S32_MAX)\n\t\t\tseq_puts(sf, RDMACG_MAX_STR);\n\t\telse\n\t\t\tseq_printf(sf, \"%d\", value);\n\t\tseq_putc(sf, ' ');\n\t}\n}",
    "includes": [
      "#include <linux/cgroup_rdma.h>",
      "#include <linux/parser.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>"
    ],
    "macros_used": [
      "#define RDMACG_MAX_STR \"max\""
    ],
    "globals_used": [
      "static char const *rdmacg_resource_names[] = {\n\t[RDMACG_RESOURCE_HCA_HANDLE]\t= \"hca_handle\",\n\t[RDMACG_RESOURCE_HCA_OBJECT]\t= \"hca_object\",\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_putc",
          "args": [
            "sf",
            "' '"
          ],
          "line": 520
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_putc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "233-246",
          "snippet": "void trace_seq_putc(struct trace_seq *s, unsigned char c)\n{\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (TRACE_SEQ_BUF_LEFT(s) < 1) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putc(&s->seq, c);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_putc(struct trace_seq *s, unsigned char c)\n{\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (TRACE_SEQ_BUF_LEFT(s) < 1) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putc(&s->seq, c);\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "sf",
            "\"%d\"",
            "value"
          ],
          "line": 519
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "81-100",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "sf",
            "RDMACG_MAX_STR"
          ],
          "line": 517
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_puts",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "205-220",
          "snippet": "void trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_cft",
          "args": [
            "sf"
          ],
          "line": 499
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_rdma.h>\n#include <linux/parser.h>\n#include <linux/cgroup.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\n#define RDMACG_MAX_STR \"max\"\n\nstatic char const *rdmacg_resource_names[] = {\n\t[RDMACG_RESOURCE_HCA_HANDLE]\t= \"hca_handle\",\n\t[RDMACG_RESOURCE_HCA_OBJECT]\t= \"hca_object\",\n};\n\nstatic void print_rpool_values(struct seq_file *sf,\n\t\t\t       struct rdmacg_resource_pool *rpool)\n{\n\tenum rdmacg_file_type sf_type;\n\tint i;\n\tu32 value;\n\n\tsf_type = seq_cft(sf)->private;\n\n\tfor (i = 0; i < RDMACG_RESOURCE_MAX; i++) {\n\t\tseq_puts(sf, rdmacg_resource_names[i]);\n\t\tseq_putc(sf, '=');\n\t\tif (sf_type == RDMACG_RESOURCE_TYPE_MAX) {\n\t\t\tif (rpool)\n\t\t\t\tvalue = rpool->resources[i].max;\n\t\t\telse\n\t\t\t\tvalue = S32_MAX;\n\t\t} else {\n\t\t\tif (rpool)\n\t\t\t\tvalue = rpool->resources[i].usage;\n\t\t\telse\n\t\t\t\tvalue = 0;\n\t\t}\n\n\t\tif (value == S32_MAX)\n\t\t\tseq_puts(sf, RDMACG_MAX_STR);\n\t\telse\n\t\t\tseq_printf(sf, \"%d\", value);\n\t\tseq_putc(sf, ' ');\n\t}\n}"
  },
  {
    "function_name": "rdmacg_resource_set_max",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/rdma.c",
    "lines": "425-490",
    "snippet": "static ssize_t rdmacg_resource_set_max(struct kernfs_open_file *of,\n\t\t\t\t       char *buf, size_t nbytes, loff_t off)\n{\n\tstruct rdma_cgroup *cg = css_rdmacg(of_css(of));\n\tconst char *dev_name;\n\tstruct rdmacg_resource_pool *rpool;\n\tstruct rdmacg_device *device;\n\tchar *options = strstrip(buf);\n\tint *new_limits;\n\tunsigned long enables = 0;\n\tint i = 0, ret = 0;\n\n\t/* extract the device name first */\n\tdev_name = strsep(&options, \" \");\n\tif (!dev_name) {\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tnew_limits = kcalloc(RDMACG_RESOURCE_MAX, sizeof(int), GFP_KERNEL);\n\tif (!new_limits) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\tret = rdmacg_parse_limits(options, new_limits, &enables);\n\tif (ret)\n\t\tgoto parse_err;\n\n\t/* acquire lock to synchronize with hot plug devices */\n\tmutex_lock(&rdmacg_mutex);\n\n\tdevice = rdmacg_get_device_locked(dev_name);\n\tif (!device) {\n\t\tret = -ENODEV;\n\t\tgoto dev_err;\n\t}\n\n\trpool = get_cg_rpool_locked(cg, device);\n\tif (IS_ERR(rpool)) {\n\t\tret = PTR_ERR(rpool);\n\t\tgoto dev_err;\n\t}\n\n\t/* now set the new limits of the rpool */\n\tfor_each_set_bit(i, &enables, RDMACG_RESOURCE_MAX)\n\t\tset_resource_limit(rpool, i, new_limits[i]);\n\n\tif (rpool->usage_sum == 0 &&\n\t    rpool->num_max_cnt == RDMACG_RESOURCE_MAX) {\n\t\t/*\n\t\t * No user of the rpool and all entries are set to max, so\n\t\t * safe to delete this rpool.\n\t\t */\n\t\tfree_cg_rpool_locked(rpool);\n\t}\n\ndev_err:\n\tmutex_unlock(&rdmacg_mutex);\n\nparse_err:\n\tkfree(new_limits);\n\nerr:\n\treturn ret ?: nbytes;\n}",
    "includes": [
      "#include <linux/cgroup_rdma.h>",
      "#include <linux/parser.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(rdmacg_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "new_limits"
          ],
          "line": 486
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&rdmacg_mutex"
          ],
          "line": 483
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_cg_rpool_locked",
          "args": [
            "rpool"
          ],
          "line": 479
        },
        "resolved": true,
        "details": {
          "function_name": "free_cg_rpool_locked",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/rdma.c",
          "lines": "103-110",
          "snippet": "static void free_cg_rpool_locked(struct rdmacg_resource_pool *rpool)\n{\n\tlockdep_assert_held(&rdmacg_mutex);\n\n\tlist_del(&rpool->cg_node);\n\tlist_del(&rpool->dev_node);\n\tkfree(rpool);\n}",
          "includes": [
            "#include <linux/cgroup_rdma.h>",
            "#include <linux/parser.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(rdmacg_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_rdma.h>\n#include <linux/parser.h>\n#include <linux/cgroup.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic DEFINE_MUTEX(rdmacg_mutex);\n\nstatic void free_cg_rpool_locked(struct rdmacg_resource_pool *rpool)\n{\n\tlockdep_assert_held(&rdmacg_mutex);\n\n\tlist_del(&rpool->cg_node);\n\tlist_del(&rpool->dev_node);\n\tkfree(rpool);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_resource_limit",
          "args": [
            "rpool",
            "i",
            "new_limits[i]"
          ],
          "line": 471
        },
        "resolved": true,
        "details": {
          "function_name": "set_resource_limit",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/rdma.c",
          "lines": "82-93",
          "snippet": "static void set_resource_limit(struct rdmacg_resource_pool *rpool,\n\t\t\t       int index, int new_max)\n{\n\tif (new_max == S32_MAX) {\n\t\tif (rpool->resources[index].max != S32_MAX)\n\t\t\trpool->num_max_cnt++;\n\t} else {\n\t\tif (rpool->resources[index].max == S32_MAX)\n\t\t\trpool->num_max_cnt--;\n\t}\n\trpool->resources[index].max = new_max;\n}",
          "includes": [
            "#include <linux/cgroup_rdma.h>",
            "#include <linux/parser.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_rdma.h>\n#include <linux/parser.h>\n#include <linux/cgroup.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic void set_resource_limit(struct rdmacg_resource_pool *rpool,\n\t\t\t       int index, int new_max)\n{\n\tif (new_max == S32_MAX) {\n\t\tif (rpool->resources[index].max != S32_MAX)\n\t\t\trpool->num_max_cnt++;\n\t} else {\n\t\tif (rpool->resources[index].max == S32_MAX)\n\t\t\trpool->num_max_cnt--;\n\t}\n\trpool->resources[index].max = new_max;\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_set_bit",
          "args": [
            "i",
            "&enables",
            "RDMACG_RESOURCE_MAX"
          ],
          "line": 470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "rpool"
          ],
          "line": 465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "rpool"
          ],
          "line": 464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_cg_rpool_locked",
          "args": [
            "cg",
            "device"
          ],
          "line": 463
        },
        "resolved": true,
        "details": {
          "function_name": "get_cg_rpool_locked",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/rdma.c",
          "lines": "128-149",
          "snippet": "static struct rdmacg_resource_pool *\nget_cg_rpool_locked(struct rdma_cgroup *cg, struct rdmacg_device *device)\n{\n\tstruct rdmacg_resource_pool *rpool;\n\n\trpool = find_cg_rpool_locked(cg, device);\n\tif (rpool)\n\t\treturn rpool;\n\n\trpool = kzalloc(sizeof(*rpool), GFP_KERNEL);\n\tif (!rpool)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\trpool->device = device;\n\tset_all_resource_max_limit(rpool);\n\n\tINIT_LIST_HEAD(&rpool->cg_node);\n\tINIT_LIST_HEAD(&rpool->dev_node);\n\tlist_add_tail(&rpool->cg_node, &cg->rpools);\n\tlist_add_tail(&rpool->dev_node, &device->rpools);\n\treturn rpool;\n}",
          "includes": [
            "#include <linux/cgroup_rdma.h>",
            "#include <linux/parser.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_rdma.h>\n#include <linux/parser.h>\n#include <linux/cgroup.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic struct rdmacg_resource_pool *\nget_cg_rpool_locked(struct rdma_cgroup *cg, struct rdmacg_device *device)\n{\n\tstruct rdmacg_resource_pool *rpool;\n\n\trpool = find_cg_rpool_locked(cg, device);\n\tif (rpool)\n\t\treturn rpool;\n\n\trpool = kzalloc(sizeof(*rpool), GFP_KERNEL);\n\tif (!rpool)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\trpool->device = device;\n\tset_all_resource_max_limit(rpool);\n\n\tINIT_LIST_HEAD(&rpool->cg_node);\n\tINIT_LIST_HEAD(&rpool->dev_node);\n\tlist_add_tail(&rpool->cg_node, &cg->rpools);\n\tlist_add_tail(&rpool->dev_node, &device->rpools);\n\treturn rpool;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rdmacg_get_device_locked",
          "args": [
            "dev_name"
          ],
          "line": 457
        },
        "resolved": true,
        "details": {
          "function_name": "rdmacg_get_device_locked",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/rdma.c",
          "lines": "412-423",
          "snippet": "static struct rdmacg_device *rdmacg_get_device_locked(const char *name)\n{\n\tstruct rdmacg_device *device;\n\n\tlockdep_assert_held(&rdmacg_mutex);\n\n\tlist_for_each_entry(device, &rdmacg_devices, dev_node)\n\t\tif (!strcmp(name, device->name))\n\t\t\treturn device;\n\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/cgroup_rdma.h>",
            "#include <linux/parser.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(rdmacg_mutex);",
            "static LIST_HEAD(rdmacg_devices);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_rdma.h>\n#include <linux/parser.h>\n#include <linux/cgroup.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic DEFINE_MUTEX(rdmacg_mutex);\nstatic LIST_HEAD(rdmacg_devices);\n\nstatic struct rdmacg_device *rdmacg_get_device_locked(const char *name)\n{\n\tstruct rdmacg_device *device;\n\n\tlockdep_assert_held(&rdmacg_mutex);\n\n\tlist_for_each_entry(device, &rdmacg_devices, dev_node)\n\t\tif (!strcmp(name, device->name))\n\t\t\treturn device;\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&rdmacg_mutex"
          ],
          "line": 455
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rdmacg_parse_limits",
          "args": [
            "options",
            "new_limits",
            "&enables"
          ],
          "line": 450
        },
        "resolved": true,
        "details": {
          "function_name": "rdmacg_parse_limits",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/rdma.c",
          "lines": "389-410",
          "snippet": "static int rdmacg_parse_limits(char *options,\n\t\t\t       int *new_limits, unsigned long *enables)\n{\n\tchar *c;\n\tint err = -EINVAL;\n\n\t/* parse resource options */\n\twhile ((c = strsep(&options, \" \")) != NULL) {\n\t\tint index, intval;\n\n\t\tindex = parse_resource(c, &intval);\n\t\tif (index < 0)\n\t\t\tgoto err;\n\n\t\tnew_limits[index] = intval;\n\t\t*enables |= BIT(index);\n\t}\n\treturn 0;\n\nerr:\n\treturn err;\n}",
          "includes": [
            "#include <linux/cgroup_rdma.h>",
            "#include <linux/parser.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_rdma.h>\n#include <linux/parser.h>\n#include <linux/cgroup.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic int rdmacg_parse_limits(char *options,\n\t\t\t       int *new_limits, unsigned long *enables)\n{\n\tchar *c;\n\tint err = -EINVAL;\n\n\t/* parse resource options */\n\twhile ((c = strsep(&options, \" \")) != NULL) {\n\t\tint index, intval;\n\n\t\tindex = parse_resource(c, &intval);\n\t\tif (index < 0)\n\t\t\tgoto err;\n\n\t\tnew_limits[index] = intval;\n\t\t*enables |= BIT(index);\n\t}\n\treturn 0;\n\nerr:\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kcalloc",
          "args": [
            "RDMACG_RESOURCE_MAX",
            "sizeof(int)",
            "GFP_KERNEL"
          ],
          "line": 444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strsep",
          "args": [
            "&options",
            "\" \""
          ],
          "line": 438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstrip",
          "args": [
            "buf"
          ],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "css_rdmacg",
          "args": [
            "of_css(of)"
          ],
          "line": 428
        },
        "resolved": true,
        "details": {
          "function_name": "css_rdmacg",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/rdma.c",
          "lines": "67-70",
          "snippet": "static struct rdma_cgroup *css_rdmacg(struct cgroup_subsys_state *css)\n{\n\treturn container_of(css, struct rdma_cgroup, css);\n}",
          "includes": [
            "#include <linux/cgroup_rdma.h>",
            "#include <linux/parser.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_rdma.h>\n#include <linux/parser.h>\n#include <linux/cgroup.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic struct rdma_cgroup *css_rdmacg(struct cgroup_subsys_state *css)\n{\n\treturn container_of(css, struct rdma_cgroup, css);\n}"
        }
      },
      {
        "call_info": {
          "callee": "of_css",
          "args": [
            "of"
          ],
          "line": 428
        },
        "resolved": true,
        "details": {
          "function_name": "of_css",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cgroup.c",
          "lines": "652-669",
          "snippet": "struct cgroup_subsys_state *of_css(struct kernfs_open_file *of)\n{\n\tstruct cgroup *cgrp = of->kn->parent->priv;\n\tstruct cftype *cft = of_cft(of);\n\n\t/*\n\t * This is open and unprotected implementation of cgroup_css().\n\t * seq_css() is only called from a kernfs file operation which has\n\t * an active reference on the file.  Because all the subsystem\n\t * files are drained before a css is disassociated with a cgroup,\n\t * the matching css from the cgroup's subsys table is guaranteed to\n\t * be and stay valid until the enclosing operation is complete.\n\t */\n\tif (CGROUP_HAS_SUBSYS_CONFIG && cft->ss)\n\t\treturn rcu_dereference_raw(cgrp->subsys[cft->ss->id]);\n\telse\n\t\treturn &cgrp->self;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [
            "#define CGROUP_HAS_SUBSYS_CONFIG\t(CGROUP_SUBSYS_COUNT > 0)"
          ],
          "globals_used": [
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);",
            "static struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);",
            "static void kill_css(struct cgroup_subsys_state *css);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\n#define CGROUP_HAS_SUBSYS_CONFIG\t(CGROUP_SUBSYS_COUNT > 0)\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\nstatic struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);\nstatic void kill_css(struct cgroup_subsys_state *css);\n\nstruct cgroup_subsys_state *of_css(struct kernfs_open_file *of)\n{\n\tstruct cgroup *cgrp = of->kn->parent->priv;\n\tstruct cftype *cft = of_cft(of);\n\n\t/*\n\t * This is open and unprotected implementation of cgroup_css().\n\t * seq_css() is only called from a kernfs file operation which has\n\t * an active reference on the file.  Because all the subsystem\n\t * files are drained before a css is disassociated with a cgroup,\n\t * the matching css from the cgroup's subsys table is guaranteed to\n\t * be and stay valid until the enclosing operation is complete.\n\t */\n\tif (CGROUP_HAS_SUBSYS_CONFIG && cft->ss)\n\t\treturn rcu_dereference_raw(cgrp->subsys[cft->ss->id]);\n\telse\n\t\treturn &cgrp->self;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_rdma.h>\n#include <linux/parser.h>\n#include <linux/cgroup.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic DEFINE_MUTEX(rdmacg_mutex);\n\nstatic ssize_t rdmacg_resource_set_max(struct kernfs_open_file *of,\n\t\t\t\t       char *buf, size_t nbytes, loff_t off)\n{\n\tstruct rdma_cgroup *cg = css_rdmacg(of_css(of));\n\tconst char *dev_name;\n\tstruct rdmacg_resource_pool *rpool;\n\tstruct rdmacg_device *device;\n\tchar *options = strstrip(buf);\n\tint *new_limits;\n\tunsigned long enables = 0;\n\tint i = 0, ret = 0;\n\n\t/* extract the device name first */\n\tdev_name = strsep(&options, \" \");\n\tif (!dev_name) {\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tnew_limits = kcalloc(RDMACG_RESOURCE_MAX, sizeof(int), GFP_KERNEL);\n\tif (!new_limits) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\tret = rdmacg_parse_limits(options, new_limits, &enables);\n\tif (ret)\n\t\tgoto parse_err;\n\n\t/* acquire lock to synchronize with hot plug devices */\n\tmutex_lock(&rdmacg_mutex);\n\n\tdevice = rdmacg_get_device_locked(dev_name);\n\tif (!device) {\n\t\tret = -ENODEV;\n\t\tgoto dev_err;\n\t}\n\n\trpool = get_cg_rpool_locked(cg, device);\n\tif (IS_ERR(rpool)) {\n\t\tret = PTR_ERR(rpool);\n\t\tgoto dev_err;\n\t}\n\n\t/* now set the new limits of the rpool */\n\tfor_each_set_bit(i, &enables, RDMACG_RESOURCE_MAX)\n\t\tset_resource_limit(rpool, i, new_limits[i]);\n\n\tif (rpool->usage_sum == 0 &&\n\t    rpool->num_max_cnt == RDMACG_RESOURCE_MAX) {\n\t\t/*\n\t\t * No user of the rpool and all entries are set to max, so\n\t\t * safe to delete this rpool.\n\t\t */\n\t\tfree_cg_rpool_locked(rpool);\n\t}\n\ndev_err:\n\tmutex_unlock(&rdmacg_mutex);\n\nparse_err:\n\tkfree(new_limits);\n\nerr:\n\treturn ret ?: nbytes;\n}"
  },
  {
    "function_name": "rdmacg_get_device_locked",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/rdma.c",
    "lines": "412-423",
    "snippet": "static struct rdmacg_device *rdmacg_get_device_locked(const char *name)\n{\n\tstruct rdmacg_device *device;\n\n\tlockdep_assert_held(&rdmacg_mutex);\n\n\tlist_for_each_entry(device, &rdmacg_devices, dev_node)\n\t\tif (!strcmp(name, device->name))\n\t\t\treturn device;\n\n\treturn NULL;\n}",
    "includes": [
      "#include <linux/cgroup_rdma.h>",
      "#include <linux/parser.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(rdmacg_mutex);",
      "static LIST_HEAD(rdmacg_devices);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "name",
            "device->name"
          ],
          "line": 419
        },
        "resolved": true,
        "details": {
          "function_name": "sym_strcmp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/report.c",
          "lines": "356-365",
          "snippet": "static int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}",
          "includes": [
            "#include \"encoding.h\"",
            "#include \"kcsan.h\"",
            "#include <linux/stacktrace.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/delay.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"encoding.h\"\n#include \"kcsan.h\"\n#include <linux/stacktrace.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/lockdep.h>\n#include <linux/kernel.h>\n#include <linux/kallsyms.h>\n#include <linux/jiffies.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n\nstatic int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "device",
            "&rdmacg_devices",
            "dev_node"
          ],
          "line": 418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&rdmacg_mutex"
          ],
          "line": 416
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_rdma.h>\n#include <linux/parser.h>\n#include <linux/cgroup.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic DEFINE_MUTEX(rdmacg_mutex);\nstatic LIST_HEAD(rdmacg_devices);\n\nstatic struct rdmacg_device *rdmacg_get_device_locked(const char *name)\n{\n\tstruct rdmacg_device *device;\n\n\tlockdep_assert_held(&rdmacg_mutex);\n\n\tlist_for_each_entry(device, &rdmacg_devices, dev_node)\n\t\tif (!strcmp(name, device->name))\n\t\t\treturn device;\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "rdmacg_parse_limits",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/rdma.c",
    "lines": "389-410",
    "snippet": "static int rdmacg_parse_limits(char *options,\n\t\t\t       int *new_limits, unsigned long *enables)\n{\n\tchar *c;\n\tint err = -EINVAL;\n\n\t/* parse resource options */\n\twhile ((c = strsep(&options, \" \")) != NULL) {\n\t\tint index, intval;\n\n\t\tindex = parse_resource(c, &intval);\n\t\tif (index < 0)\n\t\t\tgoto err;\n\n\t\tnew_limits[index] = intval;\n\t\t*enables |= BIT(index);\n\t}\n\treturn 0;\n\nerr:\n\treturn err;\n}",
    "includes": [
      "#include <linux/cgroup_rdma.h>",
      "#include <linux/parser.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BIT",
          "args": [
            "index"
          ],
          "line": 404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parse_resource",
          "args": [
            "c",
            "&intval"
          ],
          "line": 399
        },
        "resolved": true,
        "details": {
          "function_name": "parse_resource",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/rdma.c",
          "lines": "356-387",
          "snippet": "static int parse_resource(char *c, int *intval)\n{\n\tsubstring_t argstr;\n\tchar *name, *value = c;\n\tsize_t len;\n\tint ret, i;\n\n\tname = strsep(&value, \"=\");\n\tif (!name || !value)\n\t\treturn -EINVAL;\n\n\ti = match_string(rdmacg_resource_names, RDMACG_RESOURCE_MAX, name);\n\tif (i < 0)\n\t\treturn i;\n\n\tlen = strlen(value);\n\n\targstr.from = value;\n\targstr.to = value + len;\n\n\tret = match_int(&argstr, intval);\n\tif (ret >= 0) {\n\t\tif (*intval < 0)\n\t\t\treturn -EINVAL;\n\t\treturn i;\n\t}\n\tif (strncmp(value, RDMACG_MAX_STR, len) == 0) {\n\t\t*intval = S32_MAX;\n\t\treturn i;\n\t}\n\treturn -EINVAL;\n}",
          "includes": [
            "#include <linux/cgroup_rdma.h>",
            "#include <linux/parser.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [
            "#define RDMACG_MAX_STR \"max\""
          ],
          "globals_used": [
            "static char const *rdmacg_resource_names[] = {\n\t[RDMACG_RESOURCE_HCA_HANDLE]\t= \"hca_handle\",\n\t[RDMACG_RESOURCE_HCA_OBJECT]\t= \"hca_object\",\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_rdma.h>\n#include <linux/parser.h>\n#include <linux/cgroup.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\n#define RDMACG_MAX_STR \"max\"\n\nstatic char const *rdmacg_resource_names[] = {\n\t[RDMACG_RESOURCE_HCA_HANDLE]\t= \"hca_handle\",\n\t[RDMACG_RESOURCE_HCA_OBJECT]\t= \"hca_object\",\n};\n\nstatic int parse_resource(char *c, int *intval)\n{\n\tsubstring_t argstr;\n\tchar *name, *value = c;\n\tsize_t len;\n\tint ret, i;\n\n\tname = strsep(&value, \"=\");\n\tif (!name || !value)\n\t\treturn -EINVAL;\n\n\ti = match_string(rdmacg_resource_names, RDMACG_RESOURCE_MAX, name);\n\tif (i < 0)\n\t\treturn i;\n\n\tlen = strlen(value);\n\n\targstr.from = value;\n\targstr.to = value + len;\n\n\tret = match_int(&argstr, intval);\n\tif (ret >= 0) {\n\t\tif (*intval < 0)\n\t\t\treturn -EINVAL;\n\t\treturn i;\n\t}\n\tif (strncmp(value, RDMACG_MAX_STR, len) == 0) {\n\t\t*intval = S32_MAX;\n\t\treturn i;\n\t}\n\treturn -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strsep",
          "args": [
            "&options",
            "\" \""
          ],
          "line": 396
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_rdma.h>\n#include <linux/parser.h>\n#include <linux/cgroup.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic int rdmacg_parse_limits(char *options,\n\t\t\t       int *new_limits, unsigned long *enables)\n{\n\tchar *c;\n\tint err = -EINVAL;\n\n\t/* parse resource options */\n\twhile ((c = strsep(&options, \" \")) != NULL) {\n\t\tint index, intval;\n\n\t\tindex = parse_resource(c, &intval);\n\t\tif (index < 0)\n\t\t\tgoto err;\n\n\t\tnew_limits[index] = intval;\n\t\t*enables |= BIT(index);\n\t}\n\treturn 0;\n\nerr:\n\treturn err;\n}"
  },
  {
    "function_name": "parse_resource",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/rdma.c",
    "lines": "356-387",
    "snippet": "static int parse_resource(char *c, int *intval)\n{\n\tsubstring_t argstr;\n\tchar *name, *value = c;\n\tsize_t len;\n\tint ret, i;\n\n\tname = strsep(&value, \"=\");\n\tif (!name || !value)\n\t\treturn -EINVAL;\n\n\ti = match_string(rdmacg_resource_names, RDMACG_RESOURCE_MAX, name);\n\tif (i < 0)\n\t\treturn i;\n\n\tlen = strlen(value);\n\n\targstr.from = value;\n\targstr.to = value + len;\n\n\tret = match_int(&argstr, intval);\n\tif (ret >= 0) {\n\t\tif (*intval < 0)\n\t\t\treturn -EINVAL;\n\t\treturn i;\n\t}\n\tif (strncmp(value, RDMACG_MAX_STR, len) == 0) {\n\t\t*intval = S32_MAX;\n\t\treturn i;\n\t}\n\treturn -EINVAL;\n}",
    "includes": [
      "#include <linux/cgroup_rdma.h>",
      "#include <linux/parser.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>"
    ],
    "macros_used": [
      "#define RDMACG_MAX_STR \"max\""
    ],
    "globals_used": [
      "static char const *rdmacg_resource_names[] = {\n\t[RDMACG_RESOURCE_HCA_HANDLE]\t= \"hca_handle\",\n\t[RDMACG_RESOURCE_HCA_OBJECT]\t= \"hca_object\",\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "value",
            "RDMACG_MAX_STR",
            "len"
          ],
          "line": 382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "match_int",
          "args": [
            "&argstr",
            "intval"
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "value"
          ],
          "line": 371
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_eprobe.c",
          "lines": "384-401",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/ftrace.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "match_string",
          "args": [
            "rdmacg_resource_names",
            "RDMACG_RESOURCE_MAX",
            "name"
          ],
          "line": 367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strsep",
          "args": [
            "&value",
            "\"=\""
          ],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_rdma.h>\n#include <linux/parser.h>\n#include <linux/cgroup.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\n#define RDMACG_MAX_STR \"max\"\n\nstatic char const *rdmacg_resource_names[] = {\n\t[RDMACG_RESOURCE_HCA_HANDLE]\t= \"hca_handle\",\n\t[RDMACG_RESOURCE_HCA_OBJECT]\t= \"hca_object\",\n};\n\nstatic int parse_resource(char *c, int *intval)\n{\n\tsubstring_t argstr;\n\tchar *name, *value = c;\n\tsize_t len;\n\tint ret, i;\n\n\tname = strsep(&value, \"=\");\n\tif (!name || !value)\n\t\treturn -EINVAL;\n\n\ti = match_string(rdmacg_resource_names, RDMACG_RESOURCE_MAX, name);\n\tif (i < 0)\n\t\treturn i;\n\n\tlen = strlen(value);\n\n\targstr.from = value;\n\targstr.to = value + len;\n\n\tret = match_int(&argstr, intval);\n\tif (ret >= 0) {\n\t\tif (*intval < 0)\n\t\t\treturn -EINVAL;\n\t\treturn i;\n\t}\n\tif (strncmp(value, RDMACG_MAX_STR, len) == 0) {\n\t\t*intval = S32_MAX;\n\t\treturn i;\n\t}\n\treturn -EINVAL;\n}"
  },
  {
    "function_name": "rdmacg_unregister_device",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/rdma.c",
    "lines": "334-353",
    "snippet": "void rdmacg_unregister_device(struct rdmacg_device *device)\n{\n\tstruct rdmacg_resource_pool *rpool, *tmp;\n\n\t/*\n\t * Synchronize with any active resource settings,\n\t * usage query happening via configfs.\n\t */\n\tmutex_lock(&rdmacg_mutex);\n\tlist_del_init(&device->dev_node);\n\n\t/*\n\t * Now that this device is off the cgroup list, its safe to free\n\t * all the rpool resources.\n\t */\n\tlist_for_each_entry_safe(rpool, tmp, &device->rpools, dev_node)\n\t\tfree_cg_rpool_locked(rpool);\n\n\tmutex_unlock(&rdmacg_mutex);\n}",
    "includes": [
      "#include <linux/cgroup_rdma.h>",
      "#include <linux/parser.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(rdmacg_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&rdmacg_mutex"
          ],
          "line": 352
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_cg_rpool_locked",
          "args": [
            "rpool"
          ],
          "line": 350
        },
        "resolved": true,
        "details": {
          "function_name": "free_cg_rpool_locked",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/rdma.c",
          "lines": "103-110",
          "snippet": "static void free_cg_rpool_locked(struct rdmacg_resource_pool *rpool)\n{\n\tlockdep_assert_held(&rdmacg_mutex);\n\n\tlist_del(&rpool->cg_node);\n\tlist_del(&rpool->dev_node);\n\tkfree(rpool);\n}",
          "includes": [
            "#include <linux/cgroup_rdma.h>",
            "#include <linux/parser.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(rdmacg_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_rdma.h>\n#include <linux/parser.h>\n#include <linux/cgroup.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic DEFINE_MUTEX(rdmacg_mutex);\n\nstatic void free_cg_rpool_locked(struct rdmacg_resource_pool *rpool)\n{\n\tlockdep_assert_held(&rdmacg_mutex);\n\n\tlist_del(&rpool->cg_node);\n\tlist_del(&rpool->dev_node);\n\tkfree(rpool);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "rpool",
            "tmp",
            "&device->rpools",
            "dev_node"
          ],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&device->dev_node"
          ],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&rdmacg_mutex"
          ],
          "line": 342
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_rdma.h>\n#include <linux/parser.h>\n#include <linux/cgroup.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic DEFINE_MUTEX(rdmacg_mutex);\n\nvoid rdmacg_unregister_device(struct rdmacg_device *device)\n{\n\tstruct rdmacg_resource_pool *rpool, *tmp;\n\n\t/*\n\t * Synchronize with any active resource settings,\n\t * usage query happening via configfs.\n\t */\n\tmutex_lock(&rdmacg_mutex);\n\tlist_del_init(&device->dev_node);\n\n\t/*\n\t * Now that this device is off the cgroup list, its safe to free\n\t * all the rpool resources.\n\t */\n\tlist_for_each_entry_safe(rpool, tmp, &device->rpools, dev_node)\n\t\tfree_cg_rpool_locked(rpool);\n\n\tmutex_unlock(&rdmacg_mutex);\n}"
  },
  {
    "function_name": "rdmacg_register_device",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/rdma.c",
    "lines": "314-322",
    "snippet": "void rdmacg_register_device(struct rdmacg_device *device)\n{\n\tINIT_LIST_HEAD(&device->dev_node);\n\tINIT_LIST_HEAD(&device->rpools);\n\n\tmutex_lock(&rdmacg_mutex);\n\tlist_add_tail(&device->dev_node, &rdmacg_devices);\n\tmutex_unlock(&rdmacg_mutex);\n}",
    "includes": [
      "#include <linux/cgroup_rdma.h>",
      "#include <linux/parser.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(rdmacg_mutex);",
      "static LIST_HEAD(rdmacg_devices);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&rdmacg_mutex"
          ],
          "line": 321
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&device->dev_node",
            "&rdmacg_devices"
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&rdmacg_mutex"
          ],
          "line": 319
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&device->rpools"
          ],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&device->dev_node"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_rdma.h>\n#include <linux/parser.h>\n#include <linux/cgroup.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic DEFINE_MUTEX(rdmacg_mutex);\nstatic LIST_HEAD(rdmacg_devices);\n\nvoid rdmacg_register_device(struct rdmacg_device *device)\n{\n\tINIT_LIST_HEAD(&device->dev_node);\n\tINIT_LIST_HEAD(&device->rpools);\n\n\tmutex_lock(&rdmacg_mutex);\n\tlist_add_tail(&device->dev_node, &rdmacg_devices);\n\tmutex_unlock(&rdmacg_mutex);\n}"
  },
  {
    "function_name": "rdmacg_try_charge",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/rdma.c",
    "lines": "259-303",
    "snippet": "int rdmacg_try_charge(struct rdma_cgroup **rdmacg,\n\t\t      struct rdmacg_device *device,\n\t\t      enum rdmacg_resource_type index)\n{\n\tstruct rdma_cgroup *cg, *p;\n\tstruct rdmacg_resource_pool *rpool;\n\ts64 new;\n\tint ret = 0;\n\n\tif (index >= RDMACG_RESOURCE_MAX)\n\t\treturn -EINVAL;\n\n\t/*\n\t * hold on to css, as cgroup can be removed but resource\n\t * accounting happens on css.\n\t */\n\tcg = get_current_rdmacg();\n\n\tmutex_lock(&rdmacg_mutex);\n\tfor (p = cg; p; p = parent_rdmacg(p)) {\n\t\trpool = get_cg_rpool_locked(p, device);\n\t\tif (IS_ERR(rpool)) {\n\t\t\tret = PTR_ERR(rpool);\n\t\t\tgoto err;\n\t\t} else {\n\t\t\tnew = rpool->resources[index].usage + 1;\n\t\t\tif (new > rpool->resources[index].max) {\n\t\t\t\tret = -EAGAIN;\n\t\t\t\tgoto err;\n\t\t\t} else {\n\t\t\t\trpool->resources[index].usage = new;\n\t\t\t\trpool->usage_sum++;\n\t\t\t}\n\t\t}\n\t}\n\tmutex_unlock(&rdmacg_mutex);\n\n\t*rdmacg = cg;\n\treturn 0;\n\nerr:\n\tmutex_unlock(&rdmacg_mutex);\n\trdmacg_uncharge_hierarchy(cg, device, p, index);\n\treturn ret;\n}",
    "includes": [
      "#include <linux/cgroup_rdma.h>",
      "#include <linux/parser.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(rdmacg_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rdmacg_uncharge_hierarchy",
          "args": [
            "cg",
            "device",
            "p",
            "index"
          ],
          "line": 301
        },
        "resolved": true,
        "details": {
          "function_name": "rdmacg_uncharge_hierarchy",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/rdma.c",
          "lines": "205-220",
          "snippet": "static void rdmacg_uncharge_hierarchy(struct rdma_cgroup *cg,\n\t\t\t\t     struct rdmacg_device *device,\n\t\t\t\t     struct rdma_cgroup *stop_cg,\n\t\t\t\t     enum rdmacg_resource_type index)\n{\n\tstruct rdma_cgroup *p;\n\n\tmutex_lock(&rdmacg_mutex);\n\n\tfor (p = cg; p != stop_cg; p = parent_rdmacg(p))\n\t\tuncharge_cg_locked(p, device, index);\n\n\tmutex_unlock(&rdmacg_mutex);\n\n\tcss_put(&cg->css);\n}",
          "includes": [
            "#include <linux/cgroup_rdma.h>",
            "#include <linux/parser.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(rdmacg_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_rdma.h>\n#include <linux/parser.h>\n#include <linux/cgroup.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic DEFINE_MUTEX(rdmacg_mutex);\n\nstatic void rdmacg_uncharge_hierarchy(struct rdma_cgroup *cg,\n\t\t\t\t     struct rdmacg_device *device,\n\t\t\t\t     struct rdma_cgroup *stop_cg,\n\t\t\t\t     enum rdmacg_resource_type index)\n{\n\tstruct rdma_cgroup *p;\n\n\tmutex_lock(&rdmacg_mutex);\n\n\tfor (p = cg; p != stop_cg; p = parent_rdmacg(p))\n\t\tuncharge_cg_locked(p, device, index);\n\n\tmutex_unlock(&rdmacg_mutex);\n\n\tcss_put(&cg->css);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&rdmacg_mutex"
          ],
          "line": 300
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "rpool"
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "rpool"
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_cg_rpool_locked",
          "args": [
            "p",
            "device"
          ],
          "line": 279
        },
        "resolved": true,
        "details": {
          "function_name": "get_cg_rpool_locked",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/rdma.c",
          "lines": "128-149",
          "snippet": "static struct rdmacg_resource_pool *\nget_cg_rpool_locked(struct rdma_cgroup *cg, struct rdmacg_device *device)\n{\n\tstruct rdmacg_resource_pool *rpool;\n\n\trpool = find_cg_rpool_locked(cg, device);\n\tif (rpool)\n\t\treturn rpool;\n\n\trpool = kzalloc(sizeof(*rpool), GFP_KERNEL);\n\tif (!rpool)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\trpool->device = device;\n\tset_all_resource_max_limit(rpool);\n\n\tINIT_LIST_HEAD(&rpool->cg_node);\n\tINIT_LIST_HEAD(&rpool->dev_node);\n\tlist_add_tail(&rpool->cg_node, &cg->rpools);\n\tlist_add_tail(&rpool->dev_node, &device->rpools);\n\treturn rpool;\n}",
          "includes": [
            "#include <linux/cgroup_rdma.h>",
            "#include <linux/parser.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_rdma.h>\n#include <linux/parser.h>\n#include <linux/cgroup.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic struct rdmacg_resource_pool *\nget_cg_rpool_locked(struct rdma_cgroup *cg, struct rdmacg_device *device)\n{\n\tstruct rdmacg_resource_pool *rpool;\n\n\trpool = find_cg_rpool_locked(cg, device);\n\tif (rpool)\n\t\treturn rpool;\n\n\trpool = kzalloc(sizeof(*rpool), GFP_KERNEL);\n\tif (!rpool)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\trpool->device = device;\n\tset_all_resource_max_limit(rpool);\n\n\tINIT_LIST_HEAD(&rpool->cg_node);\n\tINIT_LIST_HEAD(&rpool->dev_node);\n\tlist_add_tail(&rpool->cg_node, &cg->rpools);\n\tlist_add_tail(&rpool->dev_node, &device->rpools);\n\treturn rpool;\n}"
        }
      },
      {
        "call_info": {
          "callee": "parent_rdmacg",
          "args": [
            "p"
          ],
          "line": 278
        },
        "resolved": true,
        "details": {
          "function_name": "parent_rdmacg",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/rdma.c",
          "lines": "72-75",
          "snippet": "static struct rdma_cgroup *parent_rdmacg(struct rdma_cgroup *cg)\n{\n\treturn css_rdmacg(cg->css.parent);\n}",
          "includes": [
            "#include <linux/cgroup_rdma.h>",
            "#include <linux/parser.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_rdma.h>\n#include <linux/parser.h>\n#include <linux/cgroup.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic struct rdma_cgroup *parent_rdmacg(struct rdma_cgroup *cg)\n{\n\treturn css_rdmacg(cg->css.parent);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&rdmacg_mutex"
          ],
          "line": 277
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_current_rdmacg",
          "args": [],
          "line": 275
        },
        "resolved": true,
        "details": {
          "function_name": "get_current_rdmacg",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/rdma.c",
          "lines": "77-80",
          "snippet": "static inline struct rdma_cgroup *get_current_rdmacg(void)\n{\n\treturn css_rdmacg(task_get_css(current, rdma_cgrp_id));\n}",
          "includes": [
            "#include <linux/cgroup_rdma.h>",
            "#include <linux/parser.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_rdma.h>\n#include <linux/parser.h>\n#include <linux/cgroup.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic inline struct rdma_cgroup *get_current_rdmacg(void)\n{\n\treturn css_rdmacg(task_get_css(current, rdma_cgrp_id));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_rdma.h>\n#include <linux/parser.h>\n#include <linux/cgroup.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic DEFINE_MUTEX(rdmacg_mutex);\n\nint rdmacg_try_charge(struct rdma_cgroup **rdmacg,\n\t\t      struct rdmacg_device *device,\n\t\t      enum rdmacg_resource_type index)\n{\n\tstruct rdma_cgroup *cg, *p;\n\tstruct rdmacg_resource_pool *rpool;\n\ts64 new;\n\tint ret = 0;\n\n\tif (index >= RDMACG_RESOURCE_MAX)\n\t\treturn -EINVAL;\n\n\t/*\n\t * hold on to css, as cgroup can be removed but resource\n\t * accounting happens on css.\n\t */\n\tcg = get_current_rdmacg();\n\n\tmutex_lock(&rdmacg_mutex);\n\tfor (p = cg; p; p = parent_rdmacg(p)) {\n\t\trpool = get_cg_rpool_locked(p, device);\n\t\tif (IS_ERR(rpool)) {\n\t\t\tret = PTR_ERR(rpool);\n\t\t\tgoto err;\n\t\t} else {\n\t\t\tnew = rpool->resources[index].usage + 1;\n\t\t\tif (new > rpool->resources[index].max) {\n\t\t\t\tret = -EAGAIN;\n\t\t\t\tgoto err;\n\t\t\t} else {\n\t\t\t\trpool->resources[index].usage = new;\n\t\t\t\trpool->usage_sum++;\n\t\t\t}\n\t\t}\n\t}\n\tmutex_unlock(&rdmacg_mutex);\n\n\t*rdmacg = cg;\n\treturn 0;\n\nerr:\n\tmutex_unlock(&rdmacg_mutex);\n\trdmacg_uncharge_hierarchy(cg, device, p, index);\n\treturn ret;\n}"
  },
  {
    "function_name": "rdmacg_uncharge",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/rdma.c",
    "lines": "227-235",
    "snippet": "void rdmacg_uncharge(struct rdma_cgroup *cg,\n\t\t     struct rdmacg_device *device,\n\t\t     enum rdmacg_resource_type index)\n{\n\tif (index >= RDMACG_RESOURCE_MAX)\n\t\treturn;\n\n\trdmacg_uncharge_hierarchy(cg, device, NULL, index);\n}",
    "includes": [
      "#include <linux/cgroup_rdma.h>",
      "#include <linux/parser.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rdmacg_uncharge_hierarchy",
          "args": [
            "cg",
            "device",
            "NULL",
            "index"
          ],
          "line": 234
        },
        "resolved": true,
        "details": {
          "function_name": "rdmacg_uncharge_hierarchy",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/rdma.c",
          "lines": "205-220",
          "snippet": "static void rdmacg_uncharge_hierarchy(struct rdma_cgroup *cg,\n\t\t\t\t     struct rdmacg_device *device,\n\t\t\t\t     struct rdma_cgroup *stop_cg,\n\t\t\t\t     enum rdmacg_resource_type index)\n{\n\tstruct rdma_cgroup *p;\n\n\tmutex_lock(&rdmacg_mutex);\n\n\tfor (p = cg; p != stop_cg; p = parent_rdmacg(p))\n\t\tuncharge_cg_locked(p, device, index);\n\n\tmutex_unlock(&rdmacg_mutex);\n\n\tcss_put(&cg->css);\n}",
          "includes": [
            "#include <linux/cgroup_rdma.h>",
            "#include <linux/parser.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(rdmacg_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_rdma.h>\n#include <linux/parser.h>\n#include <linux/cgroup.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic DEFINE_MUTEX(rdmacg_mutex);\n\nstatic void rdmacg_uncharge_hierarchy(struct rdma_cgroup *cg,\n\t\t\t\t     struct rdmacg_device *device,\n\t\t\t\t     struct rdma_cgroup *stop_cg,\n\t\t\t\t     enum rdmacg_resource_type index)\n{\n\tstruct rdma_cgroup *p;\n\n\tmutex_lock(&rdmacg_mutex);\n\n\tfor (p = cg; p != stop_cg; p = parent_rdmacg(p))\n\t\tuncharge_cg_locked(p, device, index);\n\n\tmutex_unlock(&rdmacg_mutex);\n\n\tcss_put(&cg->css);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_rdma.h>\n#include <linux/parser.h>\n#include <linux/cgroup.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nvoid rdmacg_uncharge(struct rdma_cgroup *cg,\n\t\t     struct rdmacg_device *device,\n\t\t     enum rdmacg_resource_type index)\n{\n\tif (index >= RDMACG_RESOURCE_MAX)\n\t\treturn;\n\n\trdmacg_uncharge_hierarchy(cg, device, NULL, index);\n}"
  },
  {
    "function_name": "rdmacg_uncharge_hierarchy",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/rdma.c",
    "lines": "205-220",
    "snippet": "static void rdmacg_uncharge_hierarchy(struct rdma_cgroup *cg,\n\t\t\t\t     struct rdmacg_device *device,\n\t\t\t\t     struct rdma_cgroup *stop_cg,\n\t\t\t\t     enum rdmacg_resource_type index)\n{\n\tstruct rdma_cgroup *p;\n\n\tmutex_lock(&rdmacg_mutex);\n\n\tfor (p = cg; p != stop_cg; p = parent_rdmacg(p))\n\t\tuncharge_cg_locked(p, device, index);\n\n\tmutex_unlock(&rdmacg_mutex);\n\n\tcss_put(&cg->css);\n}",
    "includes": [
      "#include <linux/cgroup_rdma.h>",
      "#include <linux/parser.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(rdmacg_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "css_put",
          "args": [
            "&cg->css"
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&rdmacg_mutex"
          ],
          "line": 217
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "uncharge_cg_locked",
          "args": [
            "p",
            "device",
            "index"
          ],
          "line": 215
        },
        "resolved": true,
        "details": {
          "function_name": "uncharge_cg_locked",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/rdma.c",
          "lines": "161-196",
          "snippet": "static void\nuncharge_cg_locked(struct rdma_cgroup *cg,\n\t\t   struct rdmacg_device *device,\n\t\t   enum rdmacg_resource_type index)\n{\n\tstruct rdmacg_resource_pool *rpool;\n\n\trpool = find_cg_rpool_locked(cg, device);\n\n\t/*\n\t * rpool cannot be null at this stage. Let kernel operate in case\n\t * if there a bug in IB stack or rdma controller, instead of crashing\n\t * the system.\n\t */\n\tif (unlikely(!rpool)) {\n\t\tpr_warn(\"Invalid device %p or rdma cgroup %p\\n\", cg, device);\n\t\treturn;\n\t}\n\n\trpool->resources[index].usage--;\n\n\t/*\n\t * A negative count (or overflow) is invalid,\n\t * it indicates a bug in the rdma controller.\n\t */\n\tWARN_ON_ONCE(rpool->resources[index].usage < 0);\n\trpool->usage_sum--;\n\tif (rpool->usage_sum == 0 &&\n\t    rpool->num_max_cnt == RDMACG_RESOURCE_MAX) {\n\t\t/*\n\t\t * No user of the rpool and all entries are set to max, so\n\t\t * safe to delete this rpool.\n\t\t */\n\t\tfree_cg_rpool_locked(rpool);\n\t}\n}",
          "includes": [
            "#include <linux/cgroup_rdma.h>",
            "#include <linux/parser.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_rdma.h>\n#include <linux/parser.h>\n#include <linux/cgroup.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic void\nuncharge_cg_locked(struct rdma_cgroup *cg,\n\t\t   struct rdmacg_device *device,\n\t\t   enum rdmacg_resource_type index)\n{\n\tstruct rdmacg_resource_pool *rpool;\n\n\trpool = find_cg_rpool_locked(cg, device);\n\n\t/*\n\t * rpool cannot be null at this stage. Let kernel operate in case\n\t * if there a bug in IB stack or rdma controller, instead of crashing\n\t * the system.\n\t */\n\tif (unlikely(!rpool)) {\n\t\tpr_warn(\"Invalid device %p or rdma cgroup %p\\n\", cg, device);\n\t\treturn;\n\t}\n\n\trpool->resources[index].usage--;\n\n\t/*\n\t * A negative count (or overflow) is invalid,\n\t * it indicates a bug in the rdma controller.\n\t */\n\tWARN_ON_ONCE(rpool->resources[index].usage < 0);\n\trpool->usage_sum--;\n\tif (rpool->usage_sum == 0 &&\n\t    rpool->num_max_cnt == RDMACG_RESOURCE_MAX) {\n\t\t/*\n\t\t * No user of the rpool and all entries are set to max, so\n\t\t * safe to delete this rpool.\n\t\t */\n\t\tfree_cg_rpool_locked(rpool);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "parent_rdmacg",
          "args": [
            "p"
          ],
          "line": 214
        },
        "resolved": true,
        "details": {
          "function_name": "parent_rdmacg",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/rdma.c",
          "lines": "72-75",
          "snippet": "static struct rdma_cgroup *parent_rdmacg(struct rdma_cgroup *cg)\n{\n\treturn css_rdmacg(cg->css.parent);\n}",
          "includes": [
            "#include <linux/cgroup_rdma.h>",
            "#include <linux/parser.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_rdma.h>\n#include <linux/parser.h>\n#include <linux/cgroup.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic struct rdma_cgroup *parent_rdmacg(struct rdma_cgroup *cg)\n{\n\treturn css_rdmacg(cg->css.parent);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&rdmacg_mutex"
          ],
          "line": 212
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_rdma.h>\n#include <linux/parser.h>\n#include <linux/cgroup.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic DEFINE_MUTEX(rdmacg_mutex);\n\nstatic void rdmacg_uncharge_hierarchy(struct rdma_cgroup *cg,\n\t\t\t\t     struct rdmacg_device *device,\n\t\t\t\t     struct rdma_cgroup *stop_cg,\n\t\t\t\t     enum rdmacg_resource_type index)\n{\n\tstruct rdma_cgroup *p;\n\n\tmutex_lock(&rdmacg_mutex);\n\n\tfor (p = cg; p != stop_cg; p = parent_rdmacg(p))\n\t\tuncharge_cg_locked(p, device, index);\n\n\tmutex_unlock(&rdmacg_mutex);\n\n\tcss_put(&cg->css);\n}"
  },
  {
    "function_name": "uncharge_cg_locked",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/rdma.c",
    "lines": "161-196",
    "snippet": "static void\nuncharge_cg_locked(struct rdma_cgroup *cg,\n\t\t   struct rdmacg_device *device,\n\t\t   enum rdmacg_resource_type index)\n{\n\tstruct rdmacg_resource_pool *rpool;\n\n\trpool = find_cg_rpool_locked(cg, device);\n\n\t/*\n\t * rpool cannot be null at this stage. Let kernel operate in case\n\t * if there a bug in IB stack or rdma controller, instead of crashing\n\t * the system.\n\t */\n\tif (unlikely(!rpool)) {\n\t\tpr_warn(\"Invalid device %p or rdma cgroup %p\\n\", cg, device);\n\t\treturn;\n\t}\n\n\trpool->resources[index].usage--;\n\n\t/*\n\t * A negative count (or overflow) is invalid,\n\t * it indicates a bug in the rdma controller.\n\t */\n\tWARN_ON_ONCE(rpool->resources[index].usage < 0);\n\trpool->usage_sum--;\n\tif (rpool->usage_sum == 0 &&\n\t    rpool->num_max_cnt == RDMACG_RESOURCE_MAX) {\n\t\t/*\n\t\t * No user of the rpool and all entries are set to max, so\n\t\t * safe to delete this rpool.\n\t\t */\n\t\tfree_cg_rpool_locked(rpool);\n\t}\n}",
    "includes": [
      "#include <linux/cgroup_rdma.h>",
      "#include <linux/parser.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_cg_rpool_locked",
          "args": [
            "rpool"
          ],
          "line": 194
        },
        "resolved": true,
        "details": {
          "function_name": "free_cg_rpool_locked",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/rdma.c",
          "lines": "103-110",
          "snippet": "static void free_cg_rpool_locked(struct rdmacg_resource_pool *rpool)\n{\n\tlockdep_assert_held(&rdmacg_mutex);\n\n\tlist_del(&rpool->cg_node);\n\tlist_del(&rpool->dev_node);\n\tkfree(rpool);\n}",
          "includes": [
            "#include <linux/cgroup_rdma.h>",
            "#include <linux/parser.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(rdmacg_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_rdma.h>\n#include <linux/parser.h>\n#include <linux/cgroup.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic DEFINE_MUTEX(rdmacg_mutex);\n\nstatic void free_cg_rpool_locked(struct rdmacg_resource_pool *rpool)\n{\n\tlockdep_assert_held(&rdmacg_mutex);\n\n\tlist_del(&rpool->cg_node);\n\tlist_del(&rpool->dev_node);\n\tkfree(rpool);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "rpool->resources[index].usage < 0"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"Invalid device %p or rdma cgroup %p\\n\"",
            "cg",
            "device"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!rpool"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_cg_rpool_locked",
          "args": [
            "cg",
            "device"
          ],
          "line": 168
        },
        "resolved": true,
        "details": {
          "function_name": "find_cg_rpool_locked",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/rdma.c",
          "lines": "112-126",
          "snippet": "static struct rdmacg_resource_pool *\nfind_cg_rpool_locked(struct rdma_cgroup *cg,\n\t\t     struct rdmacg_device *device)\n\n{\n\tstruct rdmacg_resource_pool *pool;\n\n\tlockdep_assert_held(&rdmacg_mutex);\n\n\tlist_for_each_entry(pool, &cg->rpools, cg_node)\n\t\tif (pool->device == device)\n\t\t\treturn pool;\n\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/cgroup_rdma.h>",
            "#include <linux/parser.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(rdmacg_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_rdma.h>\n#include <linux/parser.h>\n#include <linux/cgroup.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic DEFINE_MUTEX(rdmacg_mutex);\n\nstatic struct rdmacg_resource_pool *\nfind_cg_rpool_locked(struct rdma_cgroup *cg,\n\t\t     struct rdmacg_device *device)\n\n{\n\tstruct rdmacg_resource_pool *pool;\n\n\tlockdep_assert_held(&rdmacg_mutex);\n\n\tlist_for_each_entry(pool, &cg->rpools, cg_node)\n\t\tif (pool->device == device)\n\t\t\treturn pool;\n\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_rdma.h>\n#include <linux/parser.h>\n#include <linux/cgroup.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic void\nuncharge_cg_locked(struct rdma_cgroup *cg,\n\t\t   struct rdmacg_device *device,\n\t\t   enum rdmacg_resource_type index)\n{\n\tstruct rdmacg_resource_pool *rpool;\n\n\trpool = find_cg_rpool_locked(cg, device);\n\n\t/*\n\t * rpool cannot be null at this stage. Let kernel operate in case\n\t * if there a bug in IB stack or rdma controller, instead of crashing\n\t * the system.\n\t */\n\tif (unlikely(!rpool)) {\n\t\tpr_warn(\"Invalid device %p or rdma cgroup %p\\n\", cg, device);\n\t\treturn;\n\t}\n\n\trpool->resources[index].usage--;\n\n\t/*\n\t * A negative count (or overflow) is invalid,\n\t * it indicates a bug in the rdma controller.\n\t */\n\tWARN_ON_ONCE(rpool->resources[index].usage < 0);\n\trpool->usage_sum--;\n\tif (rpool->usage_sum == 0 &&\n\t    rpool->num_max_cnt == RDMACG_RESOURCE_MAX) {\n\t\t/*\n\t\t * No user of the rpool and all entries are set to max, so\n\t\t * safe to delete this rpool.\n\t\t */\n\t\tfree_cg_rpool_locked(rpool);\n\t}\n}"
  },
  {
    "function_name": "get_cg_rpool_locked",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/rdma.c",
    "lines": "128-149",
    "snippet": "static struct rdmacg_resource_pool *\nget_cg_rpool_locked(struct rdma_cgroup *cg, struct rdmacg_device *device)\n{\n\tstruct rdmacg_resource_pool *rpool;\n\n\trpool = find_cg_rpool_locked(cg, device);\n\tif (rpool)\n\t\treturn rpool;\n\n\trpool = kzalloc(sizeof(*rpool), GFP_KERNEL);\n\tif (!rpool)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\trpool->device = device;\n\tset_all_resource_max_limit(rpool);\n\n\tINIT_LIST_HEAD(&rpool->cg_node);\n\tINIT_LIST_HEAD(&rpool->dev_node);\n\tlist_add_tail(&rpool->cg_node, &cg->rpools);\n\tlist_add_tail(&rpool->dev_node, &device->rpools);\n\treturn rpool;\n}",
    "includes": [
      "#include <linux/cgroup_rdma.h>",
      "#include <linux/parser.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&rpool->dev_node",
            "&device->rpools"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&rpool->cg_node",
            "&cg->rpools"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&rpool->dev_node"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&rpool->cg_node"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_all_resource_max_limit",
          "args": [
            "rpool"
          ],
          "line": 142
        },
        "resolved": true,
        "details": {
          "function_name": "set_all_resource_max_limit",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/rdma.c",
          "lines": "95-101",
          "snippet": "static void set_all_resource_max_limit(struct rdmacg_resource_pool *rpool)\n{\n\tint i;\n\n\tfor (i = 0; i < RDMACG_RESOURCE_MAX; i++)\n\t\tset_resource_limit(rpool, i, S32_MAX);\n}",
          "includes": [
            "#include <linux/cgroup_rdma.h>",
            "#include <linux/parser.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_rdma.h>\n#include <linux/parser.h>\n#include <linux/cgroup.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic void set_all_resource_max_limit(struct rdmacg_resource_pool *rpool)\n{\n\tint i;\n\n\tfor (i = 0; i < RDMACG_RESOURCE_MAX; i++)\n\t\tset_resource_limit(rpool, i, S32_MAX);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*rpool)",
            "GFP_KERNEL"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_cg_rpool_locked",
          "args": [
            "cg",
            "device"
          ],
          "line": 133
        },
        "resolved": true,
        "details": {
          "function_name": "find_cg_rpool_locked",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/rdma.c",
          "lines": "112-126",
          "snippet": "static struct rdmacg_resource_pool *\nfind_cg_rpool_locked(struct rdma_cgroup *cg,\n\t\t     struct rdmacg_device *device)\n\n{\n\tstruct rdmacg_resource_pool *pool;\n\n\tlockdep_assert_held(&rdmacg_mutex);\n\n\tlist_for_each_entry(pool, &cg->rpools, cg_node)\n\t\tif (pool->device == device)\n\t\t\treturn pool;\n\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/cgroup_rdma.h>",
            "#include <linux/parser.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(rdmacg_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_rdma.h>\n#include <linux/parser.h>\n#include <linux/cgroup.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic DEFINE_MUTEX(rdmacg_mutex);\n\nstatic struct rdmacg_resource_pool *\nfind_cg_rpool_locked(struct rdma_cgroup *cg,\n\t\t     struct rdmacg_device *device)\n\n{\n\tstruct rdmacg_resource_pool *pool;\n\n\tlockdep_assert_held(&rdmacg_mutex);\n\n\tlist_for_each_entry(pool, &cg->rpools, cg_node)\n\t\tif (pool->device == device)\n\t\t\treturn pool;\n\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_rdma.h>\n#include <linux/parser.h>\n#include <linux/cgroup.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic struct rdmacg_resource_pool *\nget_cg_rpool_locked(struct rdma_cgroup *cg, struct rdmacg_device *device)\n{\n\tstruct rdmacg_resource_pool *rpool;\n\n\trpool = find_cg_rpool_locked(cg, device);\n\tif (rpool)\n\t\treturn rpool;\n\n\trpool = kzalloc(sizeof(*rpool), GFP_KERNEL);\n\tif (!rpool)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\trpool->device = device;\n\tset_all_resource_max_limit(rpool);\n\n\tINIT_LIST_HEAD(&rpool->cg_node);\n\tINIT_LIST_HEAD(&rpool->dev_node);\n\tlist_add_tail(&rpool->cg_node, &cg->rpools);\n\tlist_add_tail(&rpool->dev_node, &device->rpools);\n\treturn rpool;\n}"
  },
  {
    "function_name": "find_cg_rpool_locked",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/rdma.c",
    "lines": "112-126",
    "snippet": "static struct rdmacg_resource_pool *\nfind_cg_rpool_locked(struct rdma_cgroup *cg,\n\t\t     struct rdmacg_device *device)\n\n{\n\tstruct rdmacg_resource_pool *pool;\n\n\tlockdep_assert_held(&rdmacg_mutex);\n\n\tlist_for_each_entry(pool, &cg->rpools, cg_node)\n\t\tif (pool->device == device)\n\t\t\treturn pool;\n\n\treturn NULL;\n}",
    "includes": [
      "#include <linux/cgroup_rdma.h>",
      "#include <linux/parser.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(rdmacg_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "pool",
            "&cg->rpools",
            "cg_node"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&rdmacg_mutex"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_rdma.h>\n#include <linux/parser.h>\n#include <linux/cgroup.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic DEFINE_MUTEX(rdmacg_mutex);\n\nstatic struct rdmacg_resource_pool *\nfind_cg_rpool_locked(struct rdma_cgroup *cg,\n\t\t     struct rdmacg_device *device)\n\n{\n\tstruct rdmacg_resource_pool *pool;\n\n\tlockdep_assert_held(&rdmacg_mutex);\n\n\tlist_for_each_entry(pool, &cg->rpools, cg_node)\n\t\tif (pool->device == device)\n\t\t\treturn pool;\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "free_cg_rpool_locked",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/rdma.c",
    "lines": "103-110",
    "snippet": "static void free_cg_rpool_locked(struct rdmacg_resource_pool *rpool)\n{\n\tlockdep_assert_held(&rdmacg_mutex);\n\n\tlist_del(&rpool->cg_node);\n\tlist_del(&rpool->dev_node);\n\tkfree(rpool);\n}",
    "includes": [
      "#include <linux/cgroup_rdma.h>",
      "#include <linux/parser.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(rdmacg_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "rpool"
          ],
          "line": 109
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&rpool->dev_node"
          ],
          "line": 108
        },
        "resolved": true,
        "details": {
          "function_name": "list_del_leaf_cfs_rq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/fair.c",
          "lines": "475-477",
          "snippet": "static inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool sched_idle_cfs_rq(struct cfs_rq *cfs_rq);",
            "static void check_enqueue_throttle(struct cfs_rq *cfs_rq);",
            "static __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);",
            "static bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic bool sched_idle_cfs_rq(struct cfs_rq *cfs_rq);\nstatic void check_enqueue_throttle(struct cfs_rq *cfs_rq);\nstatic __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);\nstatic bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);\n\nstatic inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&rdmacg_mutex"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_rdma.h>\n#include <linux/parser.h>\n#include <linux/cgroup.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic DEFINE_MUTEX(rdmacg_mutex);\n\nstatic void free_cg_rpool_locked(struct rdmacg_resource_pool *rpool)\n{\n\tlockdep_assert_held(&rdmacg_mutex);\n\n\tlist_del(&rpool->cg_node);\n\tlist_del(&rpool->dev_node);\n\tkfree(rpool);\n}"
  },
  {
    "function_name": "set_all_resource_max_limit",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/rdma.c",
    "lines": "95-101",
    "snippet": "static void set_all_resource_max_limit(struct rdmacg_resource_pool *rpool)\n{\n\tint i;\n\n\tfor (i = 0; i < RDMACG_RESOURCE_MAX; i++)\n\t\tset_resource_limit(rpool, i, S32_MAX);\n}",
    "includes": [
      "#include <linux/cgroup_rdma.h>",
      "#include <linux/parser.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_resource_limit",
          "args": [
            "rpool",
            "i",
            "S32_MAX"
          ],
          "line": 100
        },
        "resolved": true,
        "details": {
          "function_name": "set_resource_limit",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/rdma.c",
          "lines": "82-93",
          "snippet": "static void set_resource_limit(struct rdmacg_resource_pool *rpool,\n\t\t\t       int index, int new_max)\n{\n\tif (new_max == S32_MAX) {\n\t\tif (rpool->resources[index].max != S32_MAX)\n\t\t\trpool->num_max_cnt++;\n\t} else {\n\t\tif (rpool->resources[index].max == S32_MAX)\n\t\t\trpool->num_max_cnt--;\n\t}\n\trpool->resources[index].max = new_max;\n}",
          "includes": [
            "#include <linux/cgroup_rdma.h>",
            "#include <linux/parser.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_rdma.h>\n#include <linux/parser.h>\n#include <linux/cgroup.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic void set_resource_limit(struct rdmacg_resource_pool *rpool,\n\t\t\t       int index, int new_max)\n{\n\tif (new_max == S32_MAX) {\n\t\tif (rpool->resources[index].max != S32_MAX)\n\t\t\trpool->num_max_cnt++;\n\t} else {\n\t\tif (rpool->resources[index].max == S32_MAX)\n\t\t\trpool->num_max_cnt--;\n\t}\n\trpool->resources[index].max = new_max;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_rdma.h>\n#include <linux/parser.h>\n#include <linux/cgroup.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic void set_all_resource_max_limit(struct rdmacg_resource_pool *rpool)\n{\n\tint i;\n\n\tfor (i = 0; i < RDMACG_RESOURCE_MAX; i++)\n\t\tset_resource_limit(rpool, i, S32_MAX);\n}"
  },
  {
    "function_name": "set_resource_limit",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/rdma.c",
    "lines": "82-93",
    "snippet": "static void set_resource_limit(struct rdmacg_resource_pool *rpool,\n\t\t\t       int index, int new_max)\n{\n\tif (new_max == S32_MAX) {\n\t\tif (rpool->resources[index].max != S32_MAX)\n\t\t\trpool->num_max_cnt++;\n\t} else {\n\t\tif (rpool->resources[index].max == S32_MAX)\n\t\t\trpool->num_max_cnt--;\n\t}\n\trpool->resources[index].max = new_max;\n}",
    "includes": [
      "#include <linux/cgroup_rdma.h>",
      "#include <linux/parser.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/cgroup_rdma.h>\n#include <linux/parser.h>\n#include <linux/cgroup.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic void set_resource_limit(struct rdmacg_resource_pool *rpool,\n\t\t\t       int index, int new_max)\n{\n\tif (new_max == S32_MAX) {\n\t\tif (rpool->resources[index].max != S32_MAX)\n\t\t\trpool->num_max_cnt++;\n\t} else {\n\t\tif (rpool->resources[index].max == S32_MAX)\n\t\t\trpool->num_max_cnt--;\n\t}\n\trpool->resources[index].max = new_max;\n}"
  },
  {
    "function_name": "get_current_rdmacg",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/rdma.c",
    "lines": "77-80",
    "snippet": "static inline struct rdma_cgroup *get_current_rdmacg(void)\n{\n\treturn css_rdmacg(task_get_css(current, rdma_cgrp_id));\n}",
    "includes": [
      "#include <linux/cgroup_rdma.h>",
      "#include <linux/parser.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "css_rdmacg",
          "args": [
            "task_get_css(current, rdma_cgrp_id)"
          ],
          "line": 79
        },
        "resolved": true,
        "details": {
          "function_name": "css_rdmacg",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/rdma.c",
          "lines": "67-70",
          "snippet": "static struct rdma_cgroup *css_rdmacg(struct cgroup_subsys_state *css)\n{\n\treturn container_of(css, struct rdma_cgroup, css);\n}",
          "includes": [
            "#include <linux/cgroup_rdma.h>",
            "#include <linux/parser.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_rdma.h>\n#include <linux/parser.h>\n#include <linux/cgroup.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic struct rdma_cgroup *css_rdmacg(struct cgroup_subsys_state *css)\n{\n\treturn container_of(css, struct rdma_cgroup, css);\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_get_css",
          "args": [
            "current",
            "rdma_cgrp_id"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_rdma.h>\n#include <linux/parser.h>\n#include <linux/cgroup.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic inline struct rdma_cgroup *get_current_rdmacg(void)\n{\n\treturn css_rdmacg(task_get_css(current, rdma_cgrp_id));\n}"
  },
  {
    "function_name": "parent_rdmacg",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/rdma.c",
    "lines": "72-75",
    "snippet": "static struct rdma_cgroup *parent_rdmacg(struct rdma_cgroup *cg)\n{\n\treturn css_rdmacg(cg->css.parent);\n}",
    "includes": [
      "#include <linux/cgroup_rdma.h>",
      "#include <linux/parser.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "css_rdmacg",
          "args": [
            "cg->css.parent"
          ],
          "line": 74
        },
        "resolved": true,
        "details": {
          "function_name": "css_rdmacg",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/rdma.c",
          "lines": "67-70",
          "snippet": "static struct rdma_cgroup *css_rdmacg(struct cgroup_subsys_state *css)\n{\n\treturn container_of(css, struct rdma_cgroup, css);\n}",
          "includes": [
            "#include <linux/cgroup_rdma.h>",
            "#include <linux/parser.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_rdma.h>\n#include <linux/parser.h>\n#include <linux/cgroup.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic struct rdma_cgroup *css_rdmacg(struct cgroup_subsys_state *css)\n{\n\treturn container_of(css, struct rdma_cgroup, css);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_rdma.h>\n#include <linux/parser.h>\n#include <linux/cgroup.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic struct rdma_cgroup *parent_rdmacg(struct rdma_cgroup *cg)\n{\n\treturn css_rdmacg(cg->css.parent);\n}"
  },
  {
    "function_name": "css_rdmacg",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/rdma.c",
    "lines": "67-70",
    "snippet": "static struct rdma_cgroup *css_rdmacg(struct cgroup_subsys_state *css)\n{\n\treturn container_of(css, struct rdma_cgroup, css);\n}",
    "includes": [
      "#include <linux/cgroup_rdma.h>",
      "#include <linux/parser.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "css",
            "structrdma_cgroup",
            "css"
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_rdma.h>\n#include <linux/parser.h>\n#include <linux/cgroup.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic struct rdma_cgroup *css_rdmacg(struct cgroup_subsys_state *css)\n{\n\treturn container_of(css, struct rdma_cgroup, css);\n}"
  }
]