[
  {
    "function_name": "kdb_bt",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_bt.c",
    "lines": "126-221",
    "snippet": "int\nkdb_bt(int argc, const char **argv)\n{\n\tint diag;\n\tint btaprompt = 1;\n\tint nextarg;\n\tunsigned long addr;\n\tlong offset;\n\n\t/* Prompt after each proc in bta */\n\tkdbgetintenv(\"BTAPROMPT\", &btaprompt);\n\n\tif (strcmp(argv[0], \"bta\") == 0) {\n\t\tstruct task_struct *g, *p;\n\t\tunsigned long cpu;\n\t\tconst char *mask = argc ? argv[1] : kdbgetenv(\"PS\");\n\n\t\tif (argc == 0)\n\t\t\tkdb_ps_suppressed();\n\t\t/* Run the active tasks first */\n\t\tfor_each_online_cpu(cpu) {\n\t\t\tp = kdb_curr_task(cpu);\n\t\t\tif (kdb_bt1(p, mask, btaprompt))\n\t\t\t\treturn 0;\n\t\t}\n\t\t/* Now the inactive tasks */\n\t\tfor_each_process_thread(g, p) {\n\t\t\tif (KDB_FLAG(CMD_INTERRUPT))\n\t\t\t\treturn 0;\n\t\t\tif (task_curr(p))\n\t\t\t\tcontinue;\n\t\t\tif (kdb_bt1(p, mask, btaprompt))\n\t\t\t\treturn 0;\n\t\t}\n\t} else if (strcmp(argv[0], \"btp\") == 0) {\n\t\tstruct task_struct *p;\n\t\tunsigned long pid;\n\t\tif (argc != 1)\n\t\t\treturn KDB_ARGCOUNT;\n\t\tdiag = kdbgetularg((char *)argv[1], &pid);\n\t\tif (diag)\n\t\t\treturn diag;\n\t\tp = find_task_by_pid_ns(pid, &init_pid_ns);\n\t\tif (p)\n\t\t\treturn kdb_bt1(p, \"A\", false);\n\t\tkdb_printf(\"No process with pid == %ld found\\n\", pid);\n\t\treturn 0;\n\t} else if (strcmp(argv[0], \"btt\") == 0) {\n\t\tif (argc != 1)\n\t\t\treturn KDB_ARGCOUNT;\n\t\tdiag = kdbgetularg((char *)argv[1], &addr);\n\t\tif (diag)\n\t\t\treturn diag;\n\t\treturn kdb_bt1((struct task_struct *)addr, \"A\", false);\n\t} else if (strcmp(argv[0], \"btc\") == 0) {\n\t\tunsigned long cpu = ~0;\n\t\tif (argc > 1)\n\t\t\treturn KDB_ARGCOUNT;\n\t\tif (argc == 1) {\n\t\t\tdiag = kdbgetularg((char *)argv[1], &cpu);\n\t\t\tif (diag)\n\t\t\t\treturn diag;\n\t\t}\n\t\tif (cpu != ~0) {\n\t\t\tkdb_bt_cpu(cpu);\n\t\t} else {\n\t\t\t/*\n\t\t\t * Recursive use of kdb_parse, do not use argv after\n\t\t\t * this point.\n\t\t\t */\n\t\t\targv = NULL;\n\t\t\tkdb_printf(\"btc: cpu status: \");\n\t\t\tkdb_parse(\"cpu\\n\");\n\t\t\tfor_each_online_cpu(cpu) {\n\t\t\t\tkdb_bt_cpu(cpu);\n\t\t\t\ttouch_nmi_watchdog();\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t} else {\n\t\tif (argc) {\n\t\t\tnextarg = 1;\n\t\t\tdiag = kdbgetaddrarg(argc, argv, &nextarg, &addr,\n\t\t\t\t\t     &offset, NULL);\n\t\t\tif (diag)\n\t\t\t\treturn diag;\n\t\t\tkdb_show_stack(kdb_current_task, (void *)addr);\n\t\t\treturn 0;\n\t\t} else {\n\t\t\treturn kdb_bt1(kdb_current_task, \"A\", false);\n\t\t}\n\t}\n\n\t/* NOTREACHED */\n\treturn 0;\n}",
    "includes": [
      "#include \"kdb_private.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/kdb.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kdb_bt1",
          "args": [
            "kdb_current_task",
            "\"A\"",
            "false"
          ],
          "line": 215
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_bt1",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_bt.c",
          "lines": "76-104",
          "snippet": "static int\nkdb_bt1(struct task_struct *p, const char *mask, bool btaprompt)\n{\n\tchar ch;\n\n\tif (kdb_getarea(ch, (unsigned long)p) ||\n\t    kdb_getarea(ch, (unsigned long)(p+1)-1))\n\t\treturn KDB_BADADDR;\n\tif (!kdb_task_state(p, mask))\n\t\treturn 0;\n\tkdb_printf(\"Stack traceback for pid %d\\n\", p->pid);\n\tkdb_ps1(p);\n\tkdb_show_stack(p, NULL);\n\tif (btaprompt) {\n\t\tkdb_printf(\"Enter <q> to end, <cr> or <space> to continue:\");\n\t\tdo {\n\t\t\tch = kdb_getchar();\n\t\t} while (!strchr(\"\\r\\n q\", ch));\n\t\tkdb_printf(\"\\n\");\n\n\t\t/* reset the pager */\n\t\tkdb_nextline = 1;\n\n\t\tif (ch == 'q')\n\t\t\treturn 1;\n\t}\n\ttouch_nmi_watchdog();\n\treturn 0;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/kdb.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/nmi.h>\n#include <linux/kdb.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n\nstatic int\nkdb_bt1(struct task_struct *p, const char *mask, bool btaprompt)\n{\n\tchar ch;\n\n\tif (kdb_getarea(ch, (unsigned long)p) ||\n\t    kdb_getarea(ch, (unsigned long)(p+1)-1))\n\t\treturn KDB_BADADDR;\n\tif (!kdb_task_state(p, mask))\n\t\treturn 0;\n\tkdb_printf(\"Stack traceback for pid %d\\n\", p->pid);\n\tkdb_ps1(p);\n\tkdb_show_stack(p, NULL);\n\tif (btaprompt) {\n\t\tkdb_printf(\"Enter <q> to end, <cr> or <space> to continue:\");\n\t\tdo {\n\t\t\tch = kdb_getchar();\n\t\t} while (!strchr(\"\\r\\n q\", ch));\n\t\tkdb_printf(\"\\n\");\n\n\t\t/* reset the pager */\n\t\tkdb_nextline = 1;\n\n\t\tif (ch == 'q')\n\t\t\treturn 1;\n\t}\n\ttouch_nmi_watchdog();\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kdb_show_stack",
          "args": [
            "kdb_current_task",
            "(void *)addr"
          ],
          "line": 212
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_show_stack",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_bt.c",
          "lines": "22-37",
          "snippet": "static void kdb_show_stack(struct task_struct *p, void *addr)\n{\n\tkdb_trap_printk++;\n\n\tif (!addr && kdb_task_has_cpu(p)) {\n\t\tint old_lvl = console_loglevel;\n\n\t\tconsole_loglevel = CONSOLE_LOGLEVEL_MOTORMOUTH;\n\t\tkdb_dump_stack_on_cpu(kdb_process_cpu(p));\n\t\tconsole_loglevel = old_lvl;\n\t} else {\n\t\tshow_stack(p, addr, KERN_EMERG);\n\t}\n\n\tkdb_trap_printk--;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/kdb.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/nmi.h>\n#include <linux/kdb.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n\nstatic void kdb_show_stack(struct task_struct *p, void *addr)\n{\n\tkdb_trap_printk++;\n\n\tif (!addr && kdb_task_has_cpu(p)) {\n\t\tint old_lvl = console_loglevel;\n\n\t\tconsole_loglevel = CONSOLE_LOGLEVEL_MOTORMOUTH;\n\t\tkdb_dump_stack_on_cpu(kdb_process_cpu(p));\n\t\tconsole_loglevel = old_lvl;\n\t} else {\n\t\tshow_stack(p, addr, KERN_EMERG);\n\t}\n\n\tkdb_trap_printk--;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kdbgetaddrarg",
          "args": [
            "argc",
            "argv",
            "&nextarg",
            "&addr",
            "&offset",
            "NULL"
          ],
          "line": 208
        },
        "resolved": true,
        "details": {
          "function_name": "kdbgetaddrarg",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "491-623",
          "snippet": "int kdbgetaddrarg(int argc, const char **argv, int *nextarg,\n\t\t  unsigned long *value,  long *offset,\n\t\t  char **name)\n{\n\tunsigned long addr;\n\tunsigned long off = 0;\n\tint positive;\n\tint diag;\n\tint found = 0;\n\tchar *symname;\n\tchar symbol = '\\0';\n\tchar *cp;\n\tkdb_symtab_t symtab;\n\n\t/*\n\t * If the enable flags prohibit both arbitrary memory access\n\t * and flow control then there are no reasonable grounds to\n\t * provide symbol lookup.\n\t */\n\tif (!kdb_check_flags(KDB_ENABLE_MEM_READ | KDB_ENABLE_FLOW_CTRL,\n\t\t\t     kdb_cmd_enabled, false))\n\t\treturn KDB_NOPERM;\n\n\t/*\n\t * Process arguments which follow the following syntax:\n\t *\n\t *  symbol | numeric-address [+/- numeric-offset]\n\t *  %register\n\t *  $environment-variable\n\t */\n\n\tif (*nextarg > argc)\n\t\treturn KDB_ARGCOUNT;\n\n\tsymname = (char *)argv[*nextarg];\n\n\t/*\n\t * If there is no whitespace between the symbol\n\t * or address and the '+' or '-' symbols, we\n\t * remember the character and replace it with a\n\t * null so the symbol/value can be properly parsed\n\t */\n\tcp = strpbrk(symname, \"+-\");\n\tif (cp != NULL) {\n\t\tsymbol = *cp;\n\t\t*cp++ = '\\0';\n\t}\n\n\tif (symname[0] == '$') {\n\t\tdiag = kdbgetulenv(&symname[1], &addr);\n\t\tif (diag)\n\t\t\treturn diag;\n\t} else if (symname[0] == '%') {\n\t\tdiag = kdb_check_regs();\n\t\tif (diag)\n\t\t\treturn diag;\n\t\t/* Implement register values with % at a later time as it is\n\t\t * arch optional.\n\t\t */\n\t\treturn KDB_NOTIMP;\n\t} else {\n\t\tfound = kdbgetsymval(symname, &symtab);\n\t\tif (found) {\n\t\t\taddr = symtab.sym_start;\n\t\t} else {\n\t\t\tdiag = kdbgetularg(argv[*nextarg], &addr);\n\t\t\tif (diag)\n\t\t\t\treturn diag;\n\t\t}\n\t}\n\n\tif (!found)\n\t\tfound = kdbnearsym(addr, &symtab);\n\n\t(*nextarg)++;\n\n\tif (name)\n\t\t*name = symname;\n\tif (value)\n\t\t*value = addr;\n\tif (offset && name && *name)\n\t\t*offset = addr - symtab.sym_start;\n\n\tif ((*nextarg > argc)\n\t && (symbol == '\\0'))\n\t\treturn 0;\n\n\t/*\n\t * check for +/- and offset\n\t */\n\n\tif (symbol == '\\0') {\n\t\tif ((argv[*nextarg][0] != '+')\n\t\t && (argv[*nextarg][0] != '-')) {\n\t\t\t/*\n\t\t\t * Not our argument.  Return.\n\t\t\t */\n\t\t\treturn 0;\n\t\t} else {\n\t\t\tpositive = (argv[*nextarg][0] == '+');\n\t\t\t(*nextarg)++;\n\t\t}\n\t} else\n\t\tpositive = (symbol == '+');\n\n\t/*\n\t * Now there must be an offset!\n\t */\n\tif ((*nextarg > argc)\n\t && (symbol == '\\0')) {\n\t\treturn KDB_INVADDRFMT;\n\t}\n\n\tif (!symbol) {\n\t\tcp = (char *)argv[*nextarg];\n\t\t(*nextarg)++;\n\t}\n\n\tdiag = kdbgetularg(cp, &off);\n\tif (diag)\n\t\treturn diag;\n\n\tif (!positive)\n\t\toff = -off;\n\n\tif (offset)\n\t\t*offset += off;\n\n\tif (value)\n\t\t*value += off;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int kdb_cmd_enabled = CONFIG_KDB_DEFAULT_ENABLE;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstatic int kdb_cmd_enabled = CONFIG_KDB_DEFAULT_ENABLE;\n\nint kdbgetaddrarg(int argc, const char **argv, int *nextarg,\n\t\t  unsigned long *value,  long *offset,\n\t\t  char **name)\n{\n\tunsigned long addr;\n\tunsigned long off = 0;\n\tint positive;\n\tint diag;\n\tint found = 0;\n\tchar *symname;\n\tchar symbol = '\\0';\n\tchar *cp;\n\tkdb_symtab_t symtab;\n\n\t/*\n\t * If the enable flags prohibit both arbitrary memory access\n\t * and flow control then there are no reasonable grounds to\n\t * provide symbol lookup.\n\t */\n\tif (!kdb_check_flags(KDB_ENABLE_MEM_READ | KDB_ENABLE_FLOW_CTRL,\n\t\t\t     kdb_cmd_enabled, false))\n\t\treturn KDB_NOPERM;\n\n\t/*\n\t * Process arguments which follow the following syntax:\n\t *\n\t *  symbol | numeric-address [+/- numeric-offset]\n\t *  %register\n\t *  $environment-variable\n\t */\n\n\tif (*nextarg > argc)\n\t\treturn KDB_ARGCOUNT;\n\n\tsymname = (char *)argv[*nextarg];\n\n\t/*\n\t * If there is no whitespace between the symbol\n\t * or address and the '+' or '-' symbols, we\n\t * remember the character and replace it with a\n\t * null so the symbol/value can be properly parsed\n\t */\n\tcp = strpbrk(symname, \"+-\");\n\tif (cp != NULL) {\n\t\tsymbol = *cp;\n\t\t*cp++ = '\\0';\n\t}\n\n\tif (symname[0] == '$') {\n\t\tdiag = kdbgetulenv(&symname[1], &addr);\n\t\tif (diag)\n\t\t\treturn diag;\n\t} else if (symname[0] == '%') {\n\t\tdiag = kdb_check_regs();\n\t\tif (diag)\n\t\t\treturn diag;\n\t\t/* Implement register values with % at a later time as it is\n\t\t * arch optional.\n\t\t */\n\t\treturn KDB_NOTIMP;\n\t} else {\n\t\tfound = kdbgetsymval(symname, &symtab);\n\t\tif (found) {\n\t\t\taddr = symtab.sym_start;\n\t\t} else {\n\t\t\tdiag = kdbgetularg(argv[*nextarg], &addr);\n\t\t\tif (diag)\n\t\t\t\treturn diag;\n\t\t}\n\t}\n\n\tif (!found)\n\t\tfound = kdbnearsym(addr, &symtab);\n\n\t(*nextarg)++;\n\n\tif (name)\n\t\t*name = symname;\n\tif (value)\n\t\t*value = addr;\n\tif (offset && name && *name)\n\t\t*offset = addr - symtab.sym_start;\n\n\tif ((*nextarg > argc)\n\t && (symbol == '\\0'))\n\t\treturn 0;\n\n\t/*\n\t * check for +/- and offset\n\t */\n\n\tif (symbol == '\\0') {\n\t\tif ((argv[*nextarg][0] != '+')\n\t\t && (argv[*nextarg][0] != '-')) {\n\t\t\t/*\n\t\t\t * Not our argument.  Return.\n\t\t\t */\n\t\t\treturn 0;\n\t\t} else {\n\t\t\tpositive = (argv[*nextarg][0] == '+');\n\t\t\t(*nextarg)++;\n\t\t}\n\t} else\n\t\tpositive = (symbol == '+');\n\n\t/*\n\t * Now there must be an offset!\n\t */\n\tif ((*nextarg > argc)\n\t && (symbol == '\\0')) {\n\t\treturn KDB_INVADDRFMT;\n\t}\n\n\tif (!symbol) {\n\t\tcp = (char *)argv[*nextarg];\n\t\t(*nextarg)++;\n\t}\n\n\tdiag = kdbgetularg(cp, &off);\n\tif (diag)\n\t\treturn diag;\n\n\tif (!positive)\n\t\toff = -off;\n\n\tif (offset)\n\t\t*offset += off;\n\n\tif (value)\n\t\t*value += off;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "touch_nmi_watchdog",
          "args": [],
          "line": 201
        },
        "resolved": true,
        "details": {
          "function_name": "arch_touch_nmi_watchdog",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/watchdog_hld.c",
          "lines": "32-42",
          "snippet": "notrace void arch_touch_nmi_watchdog(void)\n{\n\t/*\n\t * Using __raw here because some code paths have\n\t * preemption enabled.  If preemption is enabled\n\t * then interrupts should be enabled too, in which\n\t * case we shouldn't have to worry about the watchdog\n\t * going off.\n\t */\n\traw_cpu_write(watchdog_nmi_touch, true);\n}",
          "includes": [
            "#include <linux/perf_event.h>",
            "#include <asm/irq_regs.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(bool, watchdog_nmi_touch);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/perf_event.h>\n#include <asm/irq_regs.h>\n#include <linux/sched/debug.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n\nstatic DEFINE_PER_CPU(bool, watchdog_nmi_touch);\n\nnotrace void arch_touch_nmi_watchdog(void)\n{\n\t/*\n\t * Using __raw here because some code paths have\n\t * preemption enabled.  If preemption is enabled\n\t * then interrupts should be enabled too, in which\n\t * case we shouldn't have to worry about the watchdog\n\t * going off.\n\t */\n\traw_cpu_write(watchdog_nmi_touch, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kdb_bt_cpu",
          "args": [
            "cpu"
          ],
          "line": 200
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_bt_cpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_bt.c",
          "lines": "106-124",
          "snippet": "static void\nkdb_bt_cpu(unsigned long cpu)\n{\n\tstruct task_struct *kdb_tsk;\n\n\tif (cpu >= num_possible_cpus() || !cpu_online(cpu)) {\n\t\tkdb_printf(\"WARNING: no process for cpu %ld\\n\", cpu);\n\t\treturn;\n\t}\n\n\t/* If a CPU failed to round up we could be here */\n\tkdb_tsk = KDB_TSK(cpu);\n\tif (!kdb_tsk) {\n\t\tkdb_printf(\"WARNING: no task for cpu %ld\\n\", cpu);\n\t\treturn;\n\t}\n\n\tkdb_bt1(kdb_tsk, \"A\", false);\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/kdb.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/nmi.h>\n#include <linux/kdb.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n\nstatic void\nkdb_bt_cpu(unsigned long cpu)\n{\n\tstruct task_struct *kdb_tsk;\n\n\tif (cpu >= num_possible_cpus() || !cpu_online(cpu)) {\n\t\tkdb_printf(\"WARNING: no process for cpu %ld\\n\", cpu);\n\t\treturn;\n\t}\n\n\t/* If a CPU failed to round up we could be here */\n\tkdb_tsk = KDB_TSK(cpu);\n\tif (!kdb_tsk) {\n\t\tkdb_printf(\"WARNING: no task for cpu %ld\\n\", cpu);\n\t\treturn;\n\t}\n\n\tkdb_bt1(kdb_tsk, \"A\", false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kdb_parse",
          "args": [
            "\"cpu\\n\""
          ],
          "line": 198
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_parse",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "915-1082",
          "snippet": "int kdb_parse(const char *cmdstr)\n{\n\tstatic char *argv[MAXARGC];\n\tstatic int argc;\n\tstatic char cbuf[CMD_BUFLEN+2];\n\tchar *cp;\n\tchar *cpp, quoted;\n\tkdbtab_t *tp;\n\tint escaped, ignore_errors = 0, check_grep = 0;\n\n\t/*\n\t * First tokenize the command string.\n\t */\n\tcp = (char *)cmdstr;\n\n\tif (KDB_FLAG(CMD_INTERRUPT)) {\n\t\t/* Previous command was interrupted, newline must not\n\t\t * repeat the command */\n\t\tKDB_FLAG_CLEAR(CMD_INTERRUPT);\n\t\tKDB_STATE_SET(PAGER);\n\t\targc = 0;\t/* no repeat */\n\t}\n\n\tif (*cp != '\\n' && *cp != '\\0') {\n\t\targc = 0;\n\t\tcpp = cbuf;\n\t\twhile (*cp) {\n\t\t\t/* skip whitespace */\n\t\t\twhile (isspace(*cp))\n\t\t\t\tcp++;\n\t\t\tif ((*cp == '\\0') || (*cp == '\\n') ||\n\t\t\t    (*cp == '#' && !defcmd_in_progress))\n\t\t\t\tbreak;\n\t\t\t/* special case: check for | grep pattern */\n\t\t\tif (*cp == '|') {\n\t\t\t\tcheck_grep++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (cpp >= cbuf + CMD_BUFLEN) {\n\t\t\t\tkdb_printf(\"kdb_parse: command buffer \"\n\t\t\t\t\t   \"overflow, command ignored\\n%s\\n\",\n\t\t\t\t\t   cmdstr);\n\t\t\t\treturn KDB_NOTFOUND;\n\t\t\t}\n\t\t\tif (argc >= MAXARGC - 1) {\n\t\t\t\tkdb_printf(\"kdb_parse: too many arguments, \"\n\t\t\t\t\t   \"command ignored\\n%s\\n\", cmdstr);\n\t\t\t\treturn KDB_NOTFOUND;\n\t\t\t}\n\t\t\targv[argc++] = cpp;\n\t\t\tescaped = 0;\n\t\t\tquoted = '\\0';\n\t\t\t/* Copy to next unquoted and unescaped\n\t\t\t * whitespace or '=' */\n\t\t\twhile (*cp && *cp != '\\n' &&\n\t\t\t       (escaped || quoted || !isspace(*cp))) {\n\t\t\t\tif (cpp >= cbuf + CMD_BUFLEN)\n\t\t\t\t\tbreak;\n\t\t\t\tif (escaped) {\n\t\t\t\t\tescaped = 0;\n\t\t\t\t\t*cpp++ = *cp++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (*cp == '\\\\') {\n\t\t\t\t\tescaped = 1;\n\t\t\t\t\t++cp;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (*cp == quoted)\n\t\t\t\t\tquoted = '\\0';\n\t\t\t\telse if (*cp == '\\'' || *cp == '\"')\n\t\t\t\t\tquoted = *cp;\n\t\t\t\t*cpp = *cp++;\n\t\t\t\tif (*cpp == '=' && !quoted)\n\t\t\t\t\tbreak;\n\t\t\t\t++cpp;\n\t\t\t}\n\t\t\t*cpp++ = '\\0';\t/* Squash a ws or '=' character */\n\t\t}\n\t}\n\tif (!argc)\n\t\treturn 0;\n\tif (check_grep)\n\t\tparse_grep(cp);\n\tif (defcmd_in_progress) {\n\t\tint result = kdb_defcmd2(cmdstr, argv[0]);\n\t\tif (!defcmd_in_progress) {\n\t\t\targc = 0;\t/* avoid repeat on endefcmd */\n\t\t\t*(argv[0]) = '\\0';\n\t\t}\n\t\treturn result;\n\t}\n\tif (argv[0][0] == '-' && argv[0][1] &&\n\t    (argv[0][1] < '0' || argv[0][1] > '9')) {\n\t\tignore_errors = 1;\n\t\t++argv[0];\n\t}\n\n\tlist_for_each_entry(tp, &kdb_cmds_head, list_node) {\n\t\t/*\n\t\t * If this command is allowed to be abbreviated,\n\t\t * check to see if this is it.\n\t\t */\n\t\tif (tp->minlen && (strlen(argv[0]) <= tp->minlen) &&\n\t\t    (strncmp(argv[0], tp->name, tp->minlen) == 0))\n\t\t\tbreak;\n\n\t\tif (strcmp(argv[0], tp->name) == 0)\n\t\t\tbreak;\n\t}\n\n\t/*\n\t * If we don't find a command by this name, see if the first\n\t * few characters of this match any of the known commands.\n\t * e.g., md1c20 should match md.\n\t */\n\tif (list_entry_is_head(tp, &kdb_cmds_head, list_node)) {\n\t\tlist_for_each_entry(tp, &kdb_cmds_head, list_node) {\n\t\t\tif (strncmp(argv[0], tp->name, strlen(tp->name)) == 0)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!list_entry_is_head(tp, &kdb_cmds_head, list_node)) {\n\t\tint result;\n\n\t\tif (!kdb_check_flags(tp->flags, kdb_cmd_enabled, argc <= 1))\n\t\t\treturn KDB_NOPERM;\n\n\t\tKDB_STATE_SET(CMD);\n\t\tresult = (*tp->func)(argc-1, (const char **)argv);\n\t\tif (result && ignore_errors && result > KDB_CMD_GO)\n\t\t\tresult = 0;\n\t\tKDB_STATE_CLEAR(CMD);\n\n\t\tif (tp->flags & KDB_REPEAT_WITH_ARGS)\n\t\t\treturn result;\n\n\t\targc = tp->flags & KDB_REPEAT_NO_ARGS ? 1 : 0;\n\t\tif (argv[argc])\n\t\t\t*(argv[argc]) = '\\0';\n\t\treturn result;\n\t}\n\n\t/*\n\t * If the input with which we were presented does not\n\t * map to an existing command, attempt to parse it as an\n\t * address argument and display the result.   Useful for\n\t * obtaining the address of a variable, or the nearest symbol\n\t * to an address contained in a register.\n\t */\n\t{\n\t\tunsigned long value;\n\t\tchar *name = NULL;\n\t\tlong offset;\n\t\tint nextarg = 0;\n\n\t\tif (kdbgetaddrarg(0, (const char **)argv, &nextarg,\n\t\t\t\t  &value, &offset, &name)) {\n\t\t\treturn KDB_NOTFOUND;\n\t\t}\n\n\t\tkdb_printf(\"%s = \", argv[0]);\n\t\tkdb_symbol_print(value, NULL, KDB_SP_DEFAULT);\n\t\tkdb_printf(\"\\n\");\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [
            "#define MAXARGC\t20",
            "#define CMD_BUFLEN\t\t200\t/* kdb_printf: max printline\n\t\t\t\t\t * size == 256 */"
          ],
          "globals_used": [
            "static int kdb_cmd_enabled = CONFIG_KDB_DEFAULT_ENABLE;",
            "static LIST_HEAD(kdb_cmds_head);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\n#define MAXARGC\t20\n#define CMD_BUFLEN\t\t200\t/* kdb_printf: max printline\n\t\t\t\t\t * size == 256 */\n\nstatic int kdb_cmd_enabled = CONFIG_KDB_DEFAULT_ENABLE;\nstatic LIST_HEAD(kdb_cmds_head);\n\nint kdb_parse(const char *cmdstr)\n{\n\tstatic char *argv[MAXARGC];\n\tstatic int argc;\n\tstatic char cbuf[CMD_BUFLEN+2];\n\tchar *cp;\n\tchar *cpp, quoted;\n\tkdbtab_t *tp;\n\tint escaped, ignore_errors = 0, check_grep = 0;\n\n\t/*\n\t * First tokenize the command string.\n\t */\n\tcp = (char *)cmdstr;\n\n\tif (KDB_FLAG(CMD_INTERRUPT)) {\n\t\t/* Previous command was interrupted, newline must not\n\t\t * repeat the command */\n\t\tKDB_FLAG_CLEAR(CMD_INTERRUPT);\n\t\tKDB_STATE_SET(PAGER);\n\t\targc = 0;\t/* no repeat */\n\t}\n\n\tif (*cp != '\\n' && *cp != '\\0') {\n\t\targc = 0;\n\t\tcpp = cbuf;\n\t\twhile (*cp) {\n\t\t\t/* skip whitespace */\n\t\t\twhile (isspace(*cp))\n\t\t\t\tcp++;\n\t\t\tif ((*cp == '\\0') || (*cp == '\\n') ||\n\t\t\t    (*cp == '#' && !defcmd_in_progress))\n\t\t\t\tbreak;\n\t\t\t/* special case: check for | grep pattern */\n\t\t\tif (*cp == '|') {\n\t\t\t\tcheck_grep++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (cpp >= cbuf + CMD_BUFLEN) {\n\t\t\t\tkdb_printf(\"kdb_parse: command buffer \"\n\t\t\t\t\t   \"overflow, command ignored\\n%s\\n\",\n\t\t\t\t\t   cmdstr);\n\t\t\t\treturn KDB_NOTFOUND;\n\t\t\t}\n\t\t\tif (argc >= MAXARGC - 1) {\n\t\t\t\tkdb_printf(\"kdb_parse: too many arguments, \"\n\t\t\t\t\t   \"command ignored\\n%s\\n\", cmdstr);\n\t\t\t\treturn KDB_NOTFOUND;\n\t\t\t}\n\t\t\targv[argc++] = cpp;\n\t\t\tescaped = 0;\n\t\t\tquoted = '\\0';\n\t\t\t/* Copy to next unquoted and unescaped\n\t\t\t * whitespace or '=' */\n\t\t\twhile (*cp && *cp != '\\n' &&\n\t\t\t       (escaped || quoted || !isspace(*cp))) {\n\t\t\t\tif (cpp >= cbuf + CMD_BUFLEN)\n\t\t\t\t\tbreak;\n\t\t\t\tif (escaped) {\n\t\t\t\t\tescaped = 0;\n\t\t\t\t\t*cpp++ = *cp++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (*cp == '\\\\') {\n\t\t\t\t\tescaped = 1;\n\t\t\t\t\t++cp;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (*cp == quoted)\n\t\t\t\t\tquoted = '\\0';\n\t\t\t\telse if (*cp == '\\'' || *cp == '\"')\n\t\t\t\t\tquoted = *cp;\n\t\t\t\t*cpp = *cp++;\n\t\t\t\tif (*cpp == '=' && !quoted)\n\t\t\t\t\tbreak;\n\t\t\t\t++cpp;\n\t\t\t}\n\t\t\t*cpp++ = '\\0';\t/* Squash a ws or '=' character */\n\t\t}\n\t}\n\tif (!argc)\n\t\treturn 0;\n\tif (check_grep)\n\t\tparse_grep(cp);\n\tif (defcmd_in_progress) {\n\t\tint result = kdb_defcmd2(cmdstr, argv[0]);\n\t\tif (!defcmd_in_progress) {\n\t\t\targc = 0;\t/* avoid repeat on endefcmd */\n\t\t\t*(argv[0]) = '\\0';\n\t\t}\n\t\treturn result;\n\t}\n\tif (argv[0][0] == '-' && argv[0][1] &&\n\t    (argv[0][1] < '0' || argv[0][1] > '9')) {\n\t\tignore_errors = 1;\n\t\t++argv[0];\n\t}\n\n\tlist_for_each_entry(tp, &kdb_cmds_head, list_node) {\n\t\t/*\n\t\t * If this command is allowed to be abbreviated,\n\t\t * check to see if this is it.\n\t\t */\n\t\tif (tp->minlen && (strlen(argv[0]) <= tp->minlen) &&\n\t\t    (strncmp(argv[0], tp->name, tp->minlen) == 0))\n\t\t\tbreak;\n\n\t\tif (strcmp(argv[0], tp->name) == 0)\n\t\t\tbreak;\n\t}\n\n\t/*\n\t * If we don't find a command by this name, see if the first\n\t * few characters of this match any of the known commands.\n\t * e.g., md1c20 should match md.\n\t */\n\tif (list_entry_is_head(tp, &kdb_cmds_head, list_node)) {\n\t\tlist_for_each_entry(tp, &kdb_cmds_head, list_node) {\n\t\t\tif (strncmp(argv[0], tp->name, strlen(tp->name)) == 0)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!list_entry_is_head(tp, &kdb_cmds_head, list_node)) {\n\t\tint result;\n\n\t\tif (!kdb_check_flags(tp->flags, kdb_cmd_enabled, argc <= 1))\n\t\t\treturn KDB_NOPERM;\n\n\t\tKDB_STATE_SET(CMD);\n\t\tresult = (*tp->func)(argc-1, (const char **)argv);\n\t\tif (result && ignore_errors && result > KDB_CMD_GO)\n\t\t\tresult = 0;\n\t\tKDB_STATE_CLEAR(CMD);\n\n\t\tif (tp->flags & KDB_REPEAT_WITH_ARGS)\n\t\t\treturn result;\n\n\t\targc = tp->flags & KDB_REPEAT_NO_ARGS ? 1 : 0;\n\t\tif (argv[argc])\n\t\t\t*(argv[argc]) = '\\0';\n\t\treturn result;\n\t}\n\n\t/*\n\t * If the input with which we were presented does not\n\t * map to an existing command, attempt to parse it as an\n\t * address argument and display the result.   Useful for\n\t * obtaining the address of a variable, or the nearest symbol\n\t * to an address contained in a register.\n\t */\n\t{\n\t\tunsigned long value;\n\t\tchar *name = NULL;\n\t\tlong offset;\n\t\tint nextarg = 0;\n\n\t\tif (kdbgetaddrarg(0, (const char **)argv, &nextarg,\n\t\t\t\t  &value, &offset, &name)) {\n\t\t\treturn KDB_NOTFOUND;\n\t\t}\n\n\t\tkdb_printf(\"%s = \", argv[0]);\n\t\tkdb_symbol_print(value, NULL, KDB_SP_DEFAULT);\n\t\tkdb_printf(\"\\n\");\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kdb_printf",
          "args": [
            "\"btc: cpu status: \""
          ],
          "line": 197
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_io.c",
          "lines": "859-869",
          "snippet": "int kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/kallsyms.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/delay.h>",
            "#include <linux/nmi.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/string.h>",
            "#include <linux/console.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/kallsyms.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/delay.h>\n#include <linux/nmi.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/console.h>\n#include <linux/kdev_t.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nint kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kdbgetularg",
          "args": [
            "(char *)argv[1]",
            "&cpu"
          ],
          "line": 185
        },
        "resolved": true,
        "details": {
          "function_name": "kdbgetularg",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "362-382",
          "snippet": "int kdbgetularg(const char *arg, unsigned long *value)\n{\n\tchar *endp;\n\tunsigned long val;\n\n\tval = simple_strtoul(arg, &endp, 0);\n\n\tif (endp == arg) {\n\t\t/*\n\t\t * Also try base 16, for us folks too lazy to type the\n\t\t * leading 0x...\n\t\t */\n\t\tval = simple_strtoul(arg, &endp, 16);\n\t\tif (endp == arg)\n\t\t\treturn KDB_BADINT;\n\t}\n\n\t*value = val;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nint kdbgetularg(const char *arg, unsigned long *value)\n{\n\tchar *endp;\n\tunsigned long val;\n\n\tval = simple_strtoul(arg, &endp, 0);\n\n\tif (endp == arg) {\n\t\t/*\n\t\t * Also try base 16, for us folks too lazy to type the\n\t\t * leading 0x...\n\t\t */\n\t\tval = simple_strtoul(arg, &endp, 16);\n\t\tif (endp == arg)\n\t\t\treturn KDB_BADINT;\n\t}\n\n\t*value = val;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[0]",
            "\"btc\""
          ],
          "line": 180
        },
        "resolved": true,
        "details": {
          "function_name": "sym_strcmp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/report.c",
          "lines": "356-365",
          "snippet": "static int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}",
          "includes": [
            "#include \"encoding.h\"",
            "#include \"kcsan.h\"",
            "#include <linux/stacktrace.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/delay.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"encoding.h\"\n#include \"kcsan.h\"\n#include <linux/stacktrace.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/lockdep.h>\n#include <linux/kernel.h>\n#include <linux/kallsyms.h>\n#include <linux/jiffies.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n\nstatic int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_task_by_pid_ns",
          "args": [
            "pid",
            "&init_pid_ns"
          ],
          "line": 168
        },
        "resolved": true,
        "details": {
          "function_name": "find_task_by_pid_ns",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/pid.c",
          "lines": "413-418",
          "snippet": "struct task_struct *find_task_by_pid_ns(pid_t nr, struct pid_namespace *ns)\n{\n\tRCU_LOCKDEP_WARN(!rcu_read_lock_held(),\n\t\t\t \"find_task_by_pid_ns() needs rcu_read_lock() protection\");\n\treturn pid_task(find_pid_ns(nr, ns), PIDTYPE_PID);\n}",
          "includes": [
            "#include <uapi/linux/pidfd.h>",
            "#include <net/sock.h>",
            "#include <linux/idr.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/refcount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/init_task.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/memblock.h>",
            "#include <linux/rculist.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/pidfd.h>\n#include <net/sock.h>\n#include <linux/idr.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/anon_inodes.h>\n#include <linux/refcount.h>\n#include <linux/proc_ns.h>\n#include <linux/syscalls.h>\n#include <linux/init_task.h>\n#include <linux/pid_namespace.h>\n#include <linux/memblock.h>\n#include <linux/rculist.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\nstruct task_struct *find_task_by_pid_ns(pid_t nr, struct pid_namespace *ns)\n{\n\tRCU_LOCKDEP_WARN(!rcu_read_lock_held(),\n\t\t\t \"find_task_by_pid_ns() needs rcu_read_lock() protection\");\n\treturn pid_task(find_pid_ns(nr, ns), PIDTYPE_PID);\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_curr",
          "args": [
            "p"
          ],
          "line": 155
        },
        "resolved": true,
        "details": {
          "function_name": "task_curr",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "2099-2102",
          "snippet": "inline int task_curr(const struct task_struct *p)\n{\n\treturn cpu_curr(task_cpu(p)) == p;\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\ninline int task_curr(const struct task_struct *p)\n{\n\treturn cpu_curr(task_cpu(p)) == p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "KDB_FLAG",
          "args": [
            "CMD_INTERRUPT"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_process_thread",
          "args": [
            "g",
            "p"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdb_curr_task",
          "args": [
            "cpu"
          ],
          "line": 147
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_curr_task",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "158-166",
          "snippet": "struct task_struct *kdb_curr_task(int cpu)\n{\n\tstruct task_struct *p = curr_task(cpu);\n#ifdef\t_TIF_MCA_INIT\n\tif ((task_thread_info(p)->flags & _TIF_MCA_INIT) && KDB_TSK(cpu))\n\t\tp = krp->p;\n#endif\n\treturn p;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstruct task_struct *kdb_curr_task(int cpu)\n{\n\tstruct task_struct *p = curr_task(cpu);\n#ifdef\t_TIF_MCA_INIT\n\tif ((task_thread_info(p)->flags & _TIF_MCA_INIT) && KDB_TSK(cpu))\n\t\tp = krp->p;\n#endif\n\treturn p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kdb_ps_suppressed",
          "args": [],
          "line": 144
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_ps_suppressed",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "2271-2296",
          "snippet": "void kdb_ps_suppressed(void)\n{\n\tint idle = 0, daemon = 0;\n\tunsigned long cpu;\n\tconst struct task_struct *p, *g;\n\tfor_each_online_cpu(cpu) {\n\t\tp = kdb_curr_task(cpu);\n\t\tif (kdb_task_state(p, \"-\"))\n\t\t\t++idle;\n\t}\n\tfor_each_process_thread(g, p) {\n\t\tif (kdb_task_state(p, \"ims\"))\n\t\t\t++daemon;\n\t}\n\tif (idle || daemon) {\n\t\tif (idle)\n\t\t\tkdb_printf(\"%d idle process%s (state -)%s\\n\",\n\t\t\t\t   idle, idle == 1 ? \"\" : \"es\",\n\t\t\t\t   daemon ? \" and \" : \"\");\n\t\tif (daemon)\n\t\t\tkdb_printf(\"%d sleeping system daemon (state [ims]) \"\n\t\t\t\t   \"process%s\", daemon,\n\t\t\t\t   daemon == 1 ? \"\" : \"es\");\n\t\tkdb_printf(\" suppressed,\\nuse 'ps A' to see all.\\n\");\n\t}\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nvoid kdb_ps_suppressed(void)\n{\n\tint idle = 0, daemon = 0;\n\tunsigned long cpu;\n\tconst struct task_struct *p, *g;\n\tfor_each_online_cpu(cpu) {\n\t\tp = kdb_curr_task(cpu);\n\t\tif (kdb_task_state(p, \"-\"))\n\t\t\t++idle;\n\t}\n\tfor_each_process_thread(g, p) {\n\t\tif (kdb_task_state(p, \"ims\"))\n\t\t\t++daemon;\n\t}\n\tif (idle || daemon) {\n\t\tif (idle)\n\t\t\tkdb_printf(\"%d idle process%s (state -)%s\\n\",\n\t\t\t\t   idle, idle == 1 ? \"\" : \"es\",\n\t\t\t\t   daemon ? \" and \" : \"\");\n\t\tif (daemon)\n\t\t\tkdb_printf(\"%d sleeping system daemon (state [ims]) \"\n\t\t\t\t   \"process%s\", daemon,\n\t\t\t\t   daemon == 1 ? \"\" : \"es\");\n\t\tkdb_printf(\" suppressed,\\nuse 'ps A' to see all.\\n\");\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kdbgetenv",
          "args": [
            "\"PS\""
          ],
          "line": 141
        },
        "resolved": true,
        "details": {
          "function_name": "kdbgetenv",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "197-217",
          "snippet": "char *kdbgetenv(const char *match)\n{\n\tchar **ep = __env;\n\tint matchlen = strlen(match);\n\tint i;\n\n\tfor (i = 0; i < __nenv; i++) {\n\t\tchar *e = *ep++;\n\n\t\tif (!e)\n\t\t\tcontinue;\n\n\t\tif ((strncmp(match, e, matchlen) == 0)\n\t\t && ((e[matchlen] == '\\0')\n\t\t   || (e[matchlen] == '='))) {\n\t\t\tchar *cp = strchr(e, '=');\n\t\t\treturn cp ? ++cp : \"\";\n\t\t}\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nchar *kdbgetenv(const char *match)\n{\n\tchar **ep = __env;\n\tint matchlen = strlen(match);\n\tint i;\n\n\tfor (i = 0; i < __nenv; i++) {\n\t\tchar *e = *ep++;\n\n\t\tif (!e)\n\t\t\tcontinue;\n\n\t\tif ((strncmp(match, e, matchlen) == 0)\n\t\t && ((e[matchlen] == '\\0')\n\t\t   || (e[matchlen] == '='))) {\n\t\t\tchar *cp = strchr(e, '=');\n\t\t\treturn cp ? ++cp : \"\";\n\t\t}\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kdbgetintenv",
          "args": [
            "\"BTAPROMPT\"",
            "&btaprompt"
          ],
          "line": 136
        },
        "resolved": true,
        "details": {
          "function_name": "kdbgetintenv",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "284-293",
          "snippet": "int kdbgetintenv(const char *match, int *value)\n{\n\tunsigned long val;\n\tint diag;\n\n\tdiag = kdbgetulenv(match, &val);\n\tif (!diag)\n\t\t*value = (int) val;\n\treturn diag;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nint kdbgetintenv(const char *match, int *value)\n{\n\tunsigned long val;\n\tint diag;\n\n\tdiag = kdbgetulenv(match, &val);\n\tif (!diag)\n\t\t*value = (int) val;\n\treturn diag;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/nmi.h>\n#include <linux/kdb.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n\nint\nkdb_bt(int argc, const char **argv)\n{\n\tint diag;\n\tint btaprompt = 1;\n\tint nextarg;\n\tunsigned long addr;\n\tlong offset;\n\n\t/* Prompt after each proc in bta */\n\tkdbgetintenv(\"BTAPROMPT\", &btaprompt);\n\n\tif (strcmp(argv[0], \"bta\") == 0) {\n\t\tstruct task_struct *g, *p;\n\t\tunsigned long cpu;\n\t\tconst char *mask = argc ? argv[1] : kdbgetenv(\"PS\");\n\n\t\tif (argc == 0)\n\t\t\tkdb_ps_suppressed();\n\t\t/* Run the active tasks first */\n\t\tfor_each_online_cpu(cpu) {\n\t\t\tp = kdb_curr_task(cpu);\n\t\t\tif (kdb_bt1(p, mask, btaprompt))\n\t\t\t\treturn 0;\n\t\t}\n\t\t/* Now the inactive tasks */\n\t\tfor_each_process_thread(g, p) {\n\t\t\tif (KDB_FLAG(CMD_INTERRUPT))\n\t\t\t\treturn 0;\n\t\t\tif (task_curr(p))\n\t\t\t\tcontinue;\n\t\t\tif (kdb_bt1(p, mask, btaprompt))\n\t\t\t\treturn 0;\n\t\t}\n\t} else if (strcmp(argv[0], \"btp\") == 0) {\n\t\tstruct task_struct *p;\n\t\tunsigned long pid;\n\t\tif (argc != 1)\n\t\t\treturn KDB_ARGCOUNT;\n\t\tdiag = kdbgetularg((char *)argv[1], &pid);\n\t\tif (diag)\n\t\t\treturn diag;\n\t\tp = find_task_by_pid_ns(pid, &init_pid_ns);\n\t\tif (p)\n\t\t\treturn kdb_bt1(p, \"A\", false);\n\t\tkdb_printf(\"No process with pid == %ld found\\n\", pid);\n\t\treturn 0;\n\t} else if (strcmp(argv[0], \"btt\") == 0) {\n\t\tif (argc != 1)\n\t\t\treturn KDB_ARGCOUNT;\n\t\tdiag = kdbgetularg((char *)argv[1], &addr);\n\t\tif (diag)\n\t\t\treturn diag;\n\t\treturn kdb_bt1((struct task_struct *)addr, \"A\", false);\n\t} else if (strcmp(argv[0], \"btc\") == 0) {\n\t\tunsigned long cpu = ~0;\n\t\tif (argc > 1)\n\t\t\treturn KDB_ARGCOUNT;\n\t\tif (argc == 1) {\n\t\t\tdiag = kdbgetularg((char *)argv[1], &cpu);\n\t\t\tif (diag)\n\t\t\t\treturn diag;\n\t\t}\n\t\tif (cpu != ~0) {\n\t\t\tkdb_bt_cpu(cpu);\n\t\t} else {\n\t\t\t/*\n\t\t\t * Recursive use of kdb_parse, do not use argv after\n\t\t\t * this point.\n\t\t\t */\n\t\t\targv = NULL;\n\t\t\tkdb_printf(\"btc: cpu status: \");\n\t\t\tkdb_parse(\"cpu\\n\");\n\t\t\tfor_each_online_cpu(cpu) {\n\t\t\t\tkdb_bt_cpu(cpu);\n\t\t\t\ttouch_nmi_watchdog();\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t} else {\n\t\tif (argc) {\n\t\t\tnextarg = 1;\n\t\t\tdiag = kdbgetaddrarg(argc, argv, &nextarg, &addr,\n\t\t\t\t\t     &offset, NULL);\n\t\t\tif (diag)\n\t\t\t\treturn diag;\n\t\t\tkdb_show_stack(kdb_current_task, (void *)addr);\n\t\t\treturn 0;\n\t\t} else {\n\t\t\treturn kdb_bt1(kdb_current_task, \"A\", false);\n\t\t}\n\t}\n\n\t/* NOTREACHED */\n\treturn 0;\n}"
  },
  {
    "function_name": "kdb_bt_cpu",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_bt.c",
    "lines": "106-124",
    "snippet": "static void\nkdb_bt_cpu(unsigned long cpu)\n{\n\tstruct task_struct *kdb_tsk;\n\n\tif (cpu >= num_possible_cpus() || !cpu_online(cpu)) {\n\t\tkdb_printf(\"WARNING: no process for cpu %ld\\n\", cpu);\n\t\treturn;\n\t}\n\n\t/* If a CPU failed to round up we could be here */\n\tkdb_tsk = KDB_TSK(cpu);\n\tif (!kdb_tsk) {\n\t\tkdb_printf(\"WARNING: no task for cpu %ld\\n\", cpu);\n\t\treturn;\n\t}\n\n\tkdb_bt1(kdb_tsk, \"A\", false);\n}",
    "includes": [
      "#include \"kdb_private.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/kdb.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kdb_bt1",
          "args": [
            "kdb_tsk",
            "\"A\"",
            "false"
          ],
          "line": 123
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_bt1",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_bt.c",
          "lines": "76-104",
          "snippet": "static int\nkdb_bt1(struct task_struct *p, const char *mask, bool btaprompt)\n{\n\tchar ch;\n\n\tif (kdb_getarea(ch, (unsigned long)p) ||\n\t    kdb_getarea(ch, (unsigned long)(p+1)-1))\n\t\treturn KDB_BADADDR;\n\tif (!kdb_task_state(p, mask))\n\t\treturn 0;\n\tkdb_printf(\"Stack traceback for pid %d\\n\", p->pid);\n\tkdb_ps1(p);\n\tkdb_show_stack(p, NULL);\n\tif (btaprompt) {\n\t\tkdb_printf(\"Enter <q> to end, <cr> or <space> to continue:\");\n\t\tdo {\n\t\t\tch = kdb_getchar();\n\t\t} while (!strchr(\"\\r\\n q\", ch));\n\t\tkdb_printf(\"\\n\");\n\n\t\t/* reset the pager */\n\t\tkdb_nextline = 1;\n\n\t\tif (ch == 'q')\n\t\t\treturn 1;\n\t}\n\ttouch_nmi_watchdog();\n\treturn 0;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/kdb.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/nmi.h>\n#include <linux/kdb.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n\nstatic int\nkdb_bt1(struct task_struct *p, const char *mask, bool btaprompt)\n{\n\tchar ch;\n\n\tif (kdb_getarea(ch, (unsigned long)p) ||\n\t    kdb_getarea(ch, (unsigned long)(p+1)-1))\n\t\treturn KDB_BADADDR;\n\tif (!kdb_task_state(p, mask))\n\t\treturn 0;\n\tkdb_printf(\"Stack traceback for pid %d\\n\", p->pid);\n\tkdb_ps1(p);\n\tkdb_show_stack(p, NULL);\n\tif (btaprompt) {\n\t\tkdb_printf(\"Enter <q> to end, <cr> or <space> to continue:\");\n\t\tdo {\n\t\t\tch = kdb_getchar();\n\t\t} while (!strchr(\"\\r\\n q\", ch));\n\t\tkdb_printf(\"\\n\");\n\n\t\t/* reset the pager */\n\t\tkdb_nextline = 1;\n\n\t\tif (ch == 'q')\n\t\t\treturn 1;\n\t}\n\ttouch_nmi_watchdog();\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kdb_printf",
          "args": [
            "\"WARNING: no task for cpu %ld\\n\"",
            "cpu"
          ],
          "line": 119
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_io.c",
          "lines": "859-869",
          "snippet": "int kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/kallsyms.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/delay.h>",
            "#include <linux/nmi.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/string.h>",
            "#include <linux/console.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/kallsyms.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/delay.h>\n#include <linux/nmi.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/console.h>\n#include <linux/kdev_t.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nint kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "KDB_TSK",
          "args": [
            "cpu"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_online",
          "args": [
            "cpu"
          ],
          "line": 111
        },
        "resolved": true,
        "details": {
          "function_name": "init_cpu_online",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "2616-2619",
          "snippet": "void init_cpu_online(const struct cpumask *src)\n{\n\tcpumask_copy(&__cpu_online_mask, src);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct cpumask __cpu_online_mask"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstruct cpumask __cpu_online_mask;\n\nvoid init_cpu_online(const struct cpumask *src)\n{\n\tcpumask_copy(&__cpu_online_mask, src);\n}"
        }
      },
      {
        "call_info": {
          "callee": "num_possible_cpus",
          "args": [],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/nmi.h>\n#include <linux/kdb.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n\nstatic void\nkdb_bt_cpu(unsigned long cpu)\n{\n\tstruct task_struct *kdb_tsk;\n\n\tif (cpu >= num_possible_cpus() || !cpu_online(cpu)) {\n\t\tkdb_printf(\"WARNING: no process for cpu %ld\\n\", cpu);\n\t\treturn;\n\t}\n\n\t/* If a CPU failed to round up we could be here */\n\tkdb_tsk = KDB_TSK(cpu);\n\tif (!kdb_tsk) {\n\t\tkdb_printf(\"WARNING: no task for cpu %ld\\n\", cpu);\n\t\treturn;\n\t}\n\n\tkdb_bt1(kdb_tsk, \"A\", false);\n}"
  },
  {
    "function_name": "kdb_bt1",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_bt.c",
    "lines": "76-104",
    "snippet": "static int\nkdb_bt1(struct task_struct *p, const char *mask, bool btaprompt)\n{\n\tchar ch;\n\n\tif (kdb_getarea(ch, (unsigned long)p) ||\n\t    kdb_getarea(ch, (unsigned long)(p+1)-1))\n\t\treturn KDB_BADADDR;\n\tif (!kdb_task_state(p, mask))\n\t\treturn 0;\n\tkdb_printf(\"Stack traceback for pid %d\\n\", p->pid);\n\tkdb_ps1(p);\n\tkdb_show_stack(p, NULL);\n\tif (btaprompt) {\n\t\tkdb_printf(\"Enter <q> to end, <cr> or <space> to continue:\");\n\t\tdo {\n\t\t\tch = kdb_getchar();\n\t\t} while (!strchr(\"\\r\\n q\", ch));\n\t\tkdb_printf(\"\\n\");\n\n\t\t/* reset the pager */\n\t\tkdb_nextline = 1;\n\n\t\tif (ch == 'q')\n\t\t\treturn 1;\n\t}\n\ttouch_nmi_watchdog();\n\treturn 0;\n}",
    "includes": [
      "#include \"kdb_private.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/kdb.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "touch_nmi_watchdog",
          "args": [],
          "line": 102
        },
        "resolved": true,
        "details": {
          "function_name": "arch_touch_nmi_watchdog",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/watchdog_hld.c",
          "lines": "32-42",
          "snippet": "notrace void arch_touch_nmi_watchdog(void)\n{\n\t/*\n\t * Using __raw here because some code paths have\n\t * preemption enabled.  If preemption is enabled\n\t * then interrupts should be enabled too, in which\n\t * case we shouldn't have to worry about the watchdog\n\t * going off.\n\t */\n\traw_cpu_write(watchdog_nmi_touch, true);\n}",
          "includes": [
            "#include <linux/perf_event.h>",
            "#include <asm/irq_regs.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(bool, watchdog_nmi_touch);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/perf_event.h>\n#include <asm/irq_regs.h>\n#include <linux/sched/debug.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n\nstatic DEFINE_PER_CPU(bool, watchdog_nmi_touch);\n\nnotrace void arch_touch_nmi_watchdog(void)\n{\n\t/*\n\t * Using __raw here because some code paths have\n\t * preemption enabled.  If preemption is enabled\n\t * then interrupts should be enabled too, in which\n\t * case we shouldn't have to worry about the watchdog\n\t * going off.\n\t */\n\traw_cpu_write(watchdog_nmi_touch, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kdb_printf",
          "args": [
            "\"\\n\""
          ],
          "line": 94
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_io.c",
          "lines": "859-869",
          "snippet": "int kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/kallsyms.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/delay.h>",
            "#include <linux/nmi.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/string.h>",
            "#include <linux/console.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/kallsyms.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/delay.h>\n#include <linux/nmi.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/console.h>\n#include <linux/kdev_t.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nint kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "\"\\r\\n q\"",
            "ch"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdb_getchar",
          "args": [],
          "line": 92
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_getchar",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_io.c",
          "lines": "126-173",
          "snippet": "char kdb_getchar(void)\n{\n#define ESCAPE_UDELAY 1000\n#define ESCAPE_DELAY (2*1000000/ESCAPE_UDELAY) /* 2 seconds worth of udelays */\n\tchar buf[4];\t/* longest vt100 escape sequence is 4 bytes */\n\tchar *pbuf = buf;\n\tint escape_delay = 0;\n\tget_char_func *f, *f_prev = NULL;\n\tint key;\n\n\tfor (f = &kdb_poll_funcs[0]; ; ++f) {\n\t\tif (*f == NULL) {\n\t\t\t/* Reset NMI watchdog once per poll loop */\n\t\t\ttouch_nmi_watchdog();\n\t\t\tf = &kdb_poll_funcs[0];\n\t\t}\n\n\t\tkey = (*f)();\n\t\tif (key == -1) {\n\t\t\tif (escape_delay) {\n\t\t\t\tudelay(ESCAPE_UDELAY);\n\t\t\t\tif (--escape_delay == 0)\n\t\t\t\t\treturn '\\e';\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * When the first character is received (or we get a change\n\t\t * input source) we set ourselves up to handle an escape\n\t\t * sequences (just in case).\n\t\t */\n\t\tif (f_prev != f) {\n\t\t\tf_prev = f;\n\t\t\tpbuf = buf;\n\t\t\tescape_delay = ESCAPE_DELAY;\n\t\t}\n\n\t\t*pbuf++ = key;\n\t\tkey = kdb_handle_escape(buf, pbuf - buf);\n\t\tif (key < 0) /* no escape sequence; return best character */\n\t\t\treturn buf[pbuf - buf == 2 ? 1 : 0];\n\t\tif (key > 0)\n\t\t\treturn key;\n\t}\n\n\tunreachable();\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/kallsyms.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/delay.h>",
            "#include <linux/nmi.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/string.h>",
            "#include <linux/console.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define ESCAPE_DELAY (2*1000000/ESCAPE_UDELAY) /* 2 seconds worth of udelays */",
            "#define ESCAPE_UDELAY 1000"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/kallsyms.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/delay.h>\n#include <linux/nmi.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/console.h>\n#include <linux/kdev_t.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\n#define ESCAPE_DELAY (2*1000000/ESCAPE_UDELAY) /* 2 seconds worth of udelays */\n#define ESCAPE_UDELAY 1000\n\nchar kdb_getchar(void)\n{\n#define ESCAPE_UDELAY 1000\n#define ESCAPE_DELAY (2*1000000/ESCAPE_UDELAY) /* 2 seconds worth of udelays */\n\tchar buf[4];\t/* longest vt100 escape sequence is 4 bytes */\n\tchar *pbuf = buf;\n\tint escape_delay = 0;\n\tget_char_func *f, *f_prev = NULL;\n\tint key;\n\n\tfor (f = &kdb_poll_funcs[0]; ; ++f) {\n\t\tif (*f == NULL) {\n\t\t\t/* Reset NMI watchdog once per poll loop */\n\t\t\ttouch_nmi_watchdog();\n\t\t\tf = &kdb_poll_funcs[0];\n\t\t}\n\n\t\tkey = (*f)();\n\t\tif (key == -1) {\n\t\t\tif (escape_delay) {\n\t\t\t\tudelay(ESCAPE_UDELAY);\n\t\t\t\tif (--escape_delay == 0)\n\t\t\t\t\treturn '\\e';\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * When the first character is received (or we get a change\n\t\t * input source) we set ourselves up to handle an escape\n\t\t * sequences (just in case).\n\t\t */\n\t\tif (f_prev != f) {\n\t\t\tf_prev = f;\n\t\t\tpbuf = buf;\n\t\t\tescape_delay = ESCAPE_DELAY;\n\t\t}\n\n\t\t*pbuf++ = key;\n\t\tkey = kdb_handle_escape(buf, pbuf - buf);\n\t\tif (key < 0) /* no escape sequence; return best character */\n\t\t\treturn buf[pbuf - buf == 2 ? 1 : 0];\n\t\tif (key > 0)\n\t\t\treturn key;\n\t}\n\n\tunreachable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "kdb_show_stack",
          "args": [
            "p",
            "NULL"
          ],
          "line": 88
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_show_stack",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_bt.c",
          "lines": "22-37",
          "snippet": "static void kdb_show_stack(struct task_struct *p, void *addr)\n{\n\tkdb_trap_printk++;\n\n\tif (!addr && kdb_task_has_cpu(p)) {\n\t\tint old_lvl = console_loglevel;\n\n\t\tconsole_loglevel = CONSOLE_LOGLEVEL_MOTORMOUTH;\n\t\tkdb_dump_stack_on_cpu(kdb_process_cpu(p));\n\t\tconsole_loglevel = old_lvl;\n\t} else {\n\t\tshow_stack(p, addr, KERN_EMERG);\n\t}\n\n\tkdb_trap_printk--;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/kdb.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/nmi.h>\n#include <linux/kdb.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n\nstatic void kdb_show_stack(struct task_struct *p, void *addr)\n{\n\tkdb_trap_printk++;\n\n\tif (!addr && kdb_task_has_cpu(p)) {\n\t\tint old_lvl = console_loglevel;\n\n\t\tconsole_loglevel = CONSOLE_LOGLEVEL_MOTORMOUTH;\n\t\tkdb_dump_stack_on_cpu(kdb_process_cpu(p));\n\t\tconsole_loglevel = old_lvl;\n\t} else {\n\t\tshow_stack(p, addr, KERN_EMERG);\n\t}\n\n\tkdb_trap_printk--;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kdb_ps1",
          "args": [
            "p"
          ],
          "line": 87
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_ps1",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "2298-2324",
          "snippet": "void kdb_ps1(const struct task_struct *p)\n{\n\tint cpu;\n\tunsigned long tmp;\n\n\tif (!p ||\n\t    copy_from_kernel_nofault(&tmp, (char *)p, sizeof(unsigned long)))\n\t\treturn;\n\n\tcpu = kdb_process_cpu(p);\n\tkdb_printf(\"0x%px %8d %8d  %d %4d   %c  0x%px %c%s\\n\",\n\t\t   (void *)p, p->pid, p->parent->pid,\n\t\t   kdb_task_has_cpu(p), kdb_process_cpu(p),\n\t\t   kdb_task_state_char(p),\n\t\t   (void *)(&p->thread),\n\t\t   p == kdb_curr_task(raw_smp_processor_id()) ? '*' : ' ',\n\t\t   p->comm);\n\tif (kdb_task_has_cpu(p)) {\n\t\tif (!KDB_TSK(cpu)) {\n\t\t\tkdb_printf(\"  Error: no saved data for this cpu\\n\");\n\t\t} else {\n\t\t\tif (KDB_TSK(cpu) != p)\n\t\t\t\tkdb_printf(\"  Error: does not match running \"\n\t\t\t\t   \"process table (0x%px)\\n\", KDB_TSK(cpu));\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nvoid kdb_ps1(const struct task_struct *p)\n{\n\tint cpu;\n\tunsigned long tmp;\n\n\tif (!p ||\n\t    copy_from_kernel_nofault(&tmp, (char *)p, sizeof(unsigned long)))\n\t\treturn;\n\n\tcpu = kdb_process_cpu(p);\n\tkdb_printf(\"0x%px %8d %8d  %d %4d   %c  0x%px %c%s\\n\",\n\t\t   (void *)p, p->pid, p->parent->pid,\n\t\t   kdb_task_has_cpu(p), kdb_process_cpu(p),\n\t\t   kdb_task_state_char(p),\n\t\t   (void *)(&p->thread),\n\t\t   p == kdb_curr_task(raw_smp_processor_id()) ? '*' : ' ',\n\t\t   p->comm);\n\tif (kdb_task_has_cpu(p)) {\n\t\tif (!KDB_TSK(cpu)) {\n\t\t\tkdb_printf(\"  Error: no saved data for this cpu\\n\");\n\t\t} else {\n\t\t\tif (KDB_TSK(cpu) != p)\n\t\t\t\tkdb_printf(\"  Error: does not match running \"\n\t\t\t\t   \"process table (0x%px)\\n\", KDB_TSK(cpu));\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kdb_task_state",
          "args": [
            "p",
            "mask"
          ],
          "line": 84
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_task_state",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_support.c",
          "lines": "523-539",
          "snippet": "bool kdb_task_state(const struct task_struct *p, const char *mask)\n{\n\tchar state = kdb_task_state_char(p);\n\n\t/* If there is no mask, then we will filter code that runs when the\n\t * scheduler is idling and any system daemons that are currently\n\t * sleeping.\n\t */\n\tif (!mask || mask[0] == '\\0')\n\t\treturn !strchr(\"-ims\", state);\n\n\t/* A is a special case that matches all states */\n\tif (strchr(mask, 'A'))\n\t\treturn true;\n\n\treturn strchr(mask, state);\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/kdb.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/stddef.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/kdb.h>\n#include <linux/uaccess.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/ptrace.h>\n#include <linux/vmalloc.h>\n#include <linux/stddef.h>\n#include <linux/kallsyms.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n\nbool kdb_task_state(const struct task_struct *p, const char *mask)\n{\n\tchar state = kdb_task_state_char(p);\n\n\t/* If there is no mask, then we will filter code that runs when the\n\t * scheduler is idling and any system daemons that are currently\n\t * sleeping.\n\t */\n\tif (!mask || mask[0] == '\\0')\n\t\treturn !strchr(\"-ims\", state);\n\n\t/* A is a special case that matches all states */\n\tif (strchr(mask, 'A'))\n\t\treturn true;\n\n\treturn strchr(mask, state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kdb_getarea",
          "args": [
            "ch",
            "(unsigned long)(p+1)-1"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdb_getarea",
          "args": [
            "ch",
            "(unsigned long)p"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/nmi.h>\n#include <linux/kdb.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n\nstatic int\nkdb_bt1(struct task_struct *p, const char *mask, bool btaprompt)\n{\n\tchar ch;\n\n\tif (kdb_getarea(ch, (unsigned long)p) ||\n\t    kdb_getarea(ch, (unsigned long)(p+1)-1))\n\t\treturn KDB_BADADDR;\n\tif (!kdb_task_state(p, mask))\n\t\treturn 0;\n\tkdb_printf(\"Stack traceback for pid %d\\n\", p->pid);\n\tkdb_ps1(p);\n\tkdb_show_stack(p, NULL);\n\tif (btaprompt) {\n\t\tkdb_printf(\"Enter <q> to end, <cr> or <space> to continue:\");\n\t\tdo {\n\t\t\tch = kdb_getchar();\n\t\t} while (!strchr(\"\\r\\n q\", ch));\n\t\tkdb_printf(\"\\n\");\n\n\t\t/* reset the pager */\n\t\tkdb_nextline = 1;\n\n\t\tif (ch == 'q')\n\t\t\treturn 1;\n\t}\n\ttouch_nmi_watchdog();\n\treturn 0;\n}"
  },
  {
    "function_name": "kdb_show_stack",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_bt.c",
    "lines": "22-37",
    "snippet": "static void kdb_show_stack(struct task_struct *p, void *addr)\n{\n\tkdb_trap_printk++;\n\n\tif (!addr && kdb_task_has_cpu(p)) {\n\t\tint old_lvl = console_loglevel;\n\n\t\tconsole_loglevel = CONSOLE_LOGLEVEL_MOTORMOUTH;\n\t\tkdb_dump_stack_on_cpu(kdb_process_cpu(p));\n\t\tconsole_loglevel = old_lvl;\n\t} else {\n\t\tshow_stack(p, addr, KERN_EMERG);\n\t}\n\n\tkdb_trap_printk--;\n}",
    "includes": [
      "#include \"kdb_private.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/kdb.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "show_stack",
          "args": [
            "p",
            "addr",
            "KERN_EMERG"
          ],
          "line": 33
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdb_dump_stack_on_cpu",
          "args": [
            "kdb_process_cpu(p)"
          ],
          "line": 30
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_dump_stack_on_cpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/debug_core.c",
          "lines": "467-494",
          "snippet": "void kdb_dump_stack_on_cpu(int cpu)\n{\n\tif (cpu == raw_smp_processor_id() || !IS_ENABLED(CONFIG_SMP)) {\n\t\tdump_stack();\n\t\treturn;\n\t}\n\n\tif (!(kgdb_info[cpu].exception_state & DCPU_IS_SLAVE)) {\n\t\tkdb_printf(\"ERROR: Task on cpu %d didn't stop in the debugger\\n\",\n\t\t\t   cpu);\n\t\treturn;\n\t}\n\n\t/*\n\t * In general, architectures don't support dumping the stack of a\n\t * \"running\" process that's not the current one.  From the point of\n\t * view of the Linux, kernel processes that are looping in the kgdb\n\t * slave loop are still \"running\".  There's also no API (that actually\n\t * works across all architectures) that can do a stack crawl based\n\t * on registers passed as a parameter.\n\t *\n\t * Solve this conundrum by asking slave CPUs to do the backtrace\n\t * themselves.\n\t */\n\tkgdb_info[cpu].exception_state |= DCPU_WANT_BT;\n\twhile (kgdb_info[cpu].exception_state & DCPU_WANT_BT)\n\t\tcpu_relax();\n}",
          "includes": [
            "#include \"debug_core.h\"",
            "#include <linux/atomic.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/irq.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/smp.h>",
            "#include <linux/pid.h>",
            "#include <linux/nmi.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/init.h>",
            "#include <linux/reboot.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/string.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/threads.h>",
            "#include <linux/console.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/serial_core.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/pid_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct debuggerinfo_struct kgdb_info[NR_CPUS];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"debug_core.h\"\n#include <linux/atomic.h>\n#include <asm/byteorder.h>\n#include <asm/cacheflush.h>\n#include <linux/irq.h>\n#include <linux/rcupdate.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/smp.h>\n#include <linux/pid.h>\n#include <linux/nmi.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/init.h>\n#include <linux/reboot.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n#include <linux/string.h>\n#include <linux/ptrace.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/threads.h>\n#include <linux/console.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/serial_core.h>\n#include <linux/clocksource.h>\n#include <linux/pid_namespace.h>\n\nstruct debuggerinfo_struct kgdb_info[NR_CPUS];\n\nvoid kdb_dump_stack_on_cpu(int cpu)\n{\n\tif (cpu == raw_smp_processor_id() || !IS_ENABLED(CONFIG_SMP)) {\n\t\tdump_stack();\n\t\treturn;\n\t}\n\n\tif (!(kgdb_info[cpu].exception_state & DCPU_IS_SLAVE)) {\n\t\tkdb_printf(\"ERROR: Task on cpu %d didn't stop in the debugger\\n\",\n\t\t\t   cpu);\n\t\treturn;\n\t}\n\n\t/*\n\t * In general, architectures don't support dumping the stack of a\n\t * \"running\" process that's not the current one.  From the point of\n\t * view of the Linux, kernel processes that are looping in the kgdb\n\t * slave loop are still \"running\".  There's also no API (that actually\n\t * works across all architectures) that can do a stack crawl based\n\t * on registers passed as a parameter.\n\t *\n\t * Solve this conundrum by asking slave CPUs to do the backtrace\n\t * themselves.\n\t */\n\tkgdb_info[cpu].exception_state |= DCPU_WANT_BT;\n\twhile (kgdb_info[cpu].exception_state & DCPU_WANT_BT)\n\t\tcpu_relax();\n}"
        }
      },
      {
        "call_info": {
          "callee": "kdb_process_cpu",
          "args": [
            "p"
          ],
          "line": 30
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdb_task_has_cpu",
          "args": [
            "p"
          ],
          "line": 26
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/nmi.h>\n#include <linux/kdb.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n\nstatic void kdb_show_stack(struct task_struct *p, void *addr)\n{\n\tkdb_trap_printk++;\n\n\tif (!addr && kdb_task_has_cpu(p)) {\n\t\tint old_lvl = console_loglevel;\n\n\t\tconsole_loglevel = CONSOLE_LOGLEVEL_MOTORMOUTH;\n\t\tkdb_dump_stack_on_cpu(kdb_process_cpu(p));\n\t\tconsole_loglevel = old_lvl;\n\t} else {\n\t\tshow_stack(p, addr, KERN_EMERG);\n\t}\n\n\tkdb_trap_printk--;\n}"
  }
]