[
  {
    "function_name": "init_trace_printk",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_printk.c",
    "lines": "395-398",
    "snippet": "static __init int init_trace_printk(void)\n{\n\treturn register_module_notifier(&module_trace_bprintk_format_nb);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/string.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/security.h>",
      "#include <linux/seq_file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "notifier_block module_trace_bprintk_format_nb = {\n\t.notifier_call = module_trace_bprintk_format_notify,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "register_module_notifier",
          "args": [
            "&module_trace_bprintk_format_nb"
          ],
          "line": 397
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_module_notifier",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/module.c",
          "lines": "307-310",
          "snippet": "int unregister_module_notifier(struct notifier_block *nb)\n{\n\treturn blocking_notifier_chain_unregister(&module_notify_list, nb);\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include \"module-internal.h\"",
            "#include <uapi/linux/module.h>",
            "#include <linux/audit.h>",
            "#include <linux/dynamic_debug.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/pfn.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/percpu.h>",
            "#include <linux/async.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <asm/sections.h>",
            "#include <linux/license.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/set_memory.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/mutex.h>",
            "#include <linux/string.h>",
            "#include <linux/device.h>",
            "#include <linux/sched.h>",
            "#include <linux/notifier.h>",
            "#include <linux/vermagic.h>",
            "#include <linux/err.h>",
            "#include <linux/errno.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/elf.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel_read_file.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buildid.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/module_signature.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/extable.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static BLOCKING_NOTIFIER_HEAD(module_notify_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include \"module-internal.h\"\n#include <uapi/linux/module.h>\n#include <linux/audit.h>\n#include <linux/dynamic_debug.h>\n#include <linux/bsearch.h>\n#include <linux/pfn.h>\n#include <linux/jump_label.h>\n#include <linux/kmemleak.h>\n#include <linux/percpu.h>\n#include <linux/async.h>\n#include <linux/livepatch.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <asm/sections.h>\n#include <linux/license.h>\n#include <asm/mmu_context.h>\n#include <linux/set_memory.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/mutex.h>\n#include <linux/string.h>\n#include <linux/device.h>\n#include <linux/sched.h>\n#include <linux/notifier.h>\n#include <linux/vermagic.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/moduleparam.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/rcupdate.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/elf.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/kernel_read_file.h>\n#include <linux/kernel.h>\n#include <linux/sysfs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buildid.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/trace_events.h>\n#include <linux/module_signature.h>\n#include <linux/moduleloader.h>\n#include <linux/extable.h>\n#include <linux/export.h>\n\nstatic BLOCKING_NOTIFIER_HEAD(module_notify_list);\n\nint unregister_module_notifier(struct notifier_block *nb)\n{\n\treturn blocking_notifier_chain_unregister(&module_notify_list, nb);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/string.h>\n#include <linux/ftrace.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n\nnotifier_block module_trace_bprintk_format_nb = {\n\t.notifier_call = module_trace_bprintk_format_notify,\n};\n\nstatic __init int init_trace_printk(void)\n{\n\treturn register_module_notifier(&module_trace_bprintk_format_nb);\n}"
  },
  {
    "function_name": "init_trace_printk_function_export",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_printk.c",
    "lines": "379-391",
    "snippet": "static __init int init_trace_printk_function_export(void)\n{\n\tint ret;\n\n\tret = tracing_init_dentry();\n\tif (ret)\n\t\treturn 0;\n\n\ttrace_create_file(\"printk_formats\", TRACE_MODE_READ, NULL,\n\t\t\t\t    NULL, &ftrace_formats_fops);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/string.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/security.h>",
      "#include <linux/seq_file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct file_operations ftrace_formats_fops = {\n\t.open = ftrace_formats_open,\n\t.read = seq_read,\n\t.llseek = seq_lseek,\n\t.release = seq_release,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_create_file",
          "args": [
            "\"printk_formats\"",
            "TRACE_MODE_READ",
            "NULL",
            "NULL",
            "&ftrace_formats_fops"
          ],
          "line": 387
        },
        "resolved": true,
        "details": {
          "function_name": "trace_create_file",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "8771-8784",
          "snippet": "struct dentry *trace_create_file(const char *name,\n\t\t\t\t umode_t mode,\n\t\t\t\t struct dentry *parent,\n\t\t\t\t void *data,\n\t\t\t\t const struct file_operations *fops)\n{\n\tstruct dentry *ret;\n\n\tret = tracefs_create_file(name, mode, parent, data, fops);\n\tif (!ret)\n\t\tpr_warn(\"Could not create tracefs '%s' entry\\n\", name);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nstruct dentry *trace_create_file(const char *name,\n\t\t\t\t umode_t mode,\n\t\t\t\t struct dentry *parent,\n\t\t\t\t void *data,\n\t\t\t\t const struct file_operations *fops)\n{\n\tstruct dentry *ret;\n\n\tret = tracefs_create_file(name, mode, parent, data, fops);\n\tif (!ret)\n\t\tpr_warn(\"Could not create tracefs '%s' entry\\n\", name);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracing_init_dentry",
          "args": [],
          "line": 383
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_init_dentry",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "9527-9553",
          "snippet": "int tracing_init_dentry(void)\n{\n\tstruct trace_array *tr = &global_trace;\n\n\tif (security_locked_down(LOCKDOWN_TRACEFS)) {\n\t\tpr_warn(\"Tracing disabled due to lockdown\\n\");\n\t\treturn -EPERM;\n\t}\n\n\t/* The top level trace array uses  NULL as parent */\n\tif (tr->dir)\n\t\treturn 0;\n\n\tif (WARN_ON(!tracefs_initialized()))\n\t\treturn -ENODEV;\n\n\t/*\n\t * As there may still be users that expect the tracing\n\t * files to exist in debugfs/tracing, we must automount\n\t * the tracefs file system there, so older tools still\n\t * work with the newer kernel.\n\t */\n\ttr->dir = debugfs_create_automount(\"tracing\", NULL,\n\t\t\t\t\t   trace_automount, NULL);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};\nstatic __always_inline struct;\n\nint tracing_init_dentry(void)\n{\n\tstruct trace_array *tr = &global_trace;\n\n\tif (security_locked_down(LOCKDOWN_TRACEFS)) {\n\t\tpr_warn(\"Tracing disabled due to lockdown\\n\");\n\t\treturn -EPERM;\n\t}\n\n\t/* The top level trace array uses  NULL as parent */\n\tif (tr->dir)\n\t\treturn 0;\n\n\tif (WARN_ON(!tracefs_initialized()))\n\t\treturn -ENODEV;\n\n\t/*\n\t * As there may still be users that expect the tracing\n\t * files to exist in debugfs/tracing, we must automount\n\t * the tracefs file system there, so older tools still\n\t * work with the newer kernel.\n\t */\n\ttr->dir = debugfs_create_automount(\"tracing\", NULL,\n\t\t\t\t\t   trace_automount, NULL);\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/string.h>\n#include <linux/ftrace.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n\nstatic const struct file_operations ftrace_formats_fops = {\n\t.open = ftrace_formats_open,\n\t.read = seq_read,\n\t.llseek = seq_lseek,\n\t.release = seq_release,\n};\n\nstatic __init int init_trace_printk_function_export(void)\n{\n\tint ret;\n\n\tret = tracing_init_dentry();\n\tif (ret)\n\t\treturn 0;\n\n\ttrace_create_file(\"printk_formats\", TRACE_MODE_READ, NULL,\n\t\t\t\t    NULL, &ftrace_formats_fops);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "ftrace_formats_open",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_printk.c",
    "lines": "360-370",
    "snippet": "static int\nftrace_formats_open(struct inode *inode, struct file *file)\n{\n\tint ret;\n\n\tret = security_locked_down(LOCKDOWN_TRACEFS);\n\tif (ret)\n\t\treturn ret;\n\n\treturn seq_open(file, &show_format_seq_ops);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/string.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/security.h>",
      "#include <linux/seq_file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "__initdata_or_module static\nstruct",
      "static const struct seq_operations show_format_seq_ops = {\n\t.start = t_start,\n\t.next = t_next,\n\t.show = t_show,\n\t.stop = t_stop,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_open",
          "args": [
            "file",
            "&show_format_seq_ops"
          ],
          "line": 369
        },
        "resolved": true,
        "details": {
          "function_name": "gcov_seq_open",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/gcov/fs.c",
          "lines": "288-322",
          "snippet": "static int gcov_seq_open(struct inode *inode, struct file *file)\n{\n\tstruct gcov_node *node = inode->i_private;\n\tstruct gcov_iterator *iter;\n\tstruct seq_file *seq;\n\tstruct gcov_info *info;\n\tint rc = -ENOMEM;\n\n\tmutex_lock(&node_lock);\n\t/*\n\t * Read from a profiling data copy to minimize reference tracking\n\t * complexity and concurrent access and to keep accumulating multiple\n\t * profiling data sets associated with one node simple.\n\t */\n\tinfo = get_accumulated_info(node);\n\tif (!info)\n\t\tgoto out_unlock;\n\titer = gcov_iter_new(info);\n\tif (!iter)\n\t\tgoto err_free_info;\n\trc = seq_open(file, &gcov_seq_ops);\n\tif (rc)\n\t\tgoto err_free_iter_info;\n\tseq = file->private_data;\n\tseq->private = iter;\nout_unlock:\n\tmutex_unlock(&node_lock);\n\treturn rc;\n\nerr_free_iter_info:\n\tgcov_iter_free(iter);\nerr_free_info:\n\tgcov_info_free(info);\n\tgoto out_unlock;\n}",
          "includes": [
            "#include \"gcov.h\"",
            "#include <linux/mm.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(node_lock);",
            "static const struct seq_operations gcov_seq_ops = {\n\t.start\t= gcov_seq_start,\n\t.next\t= gcov_seq_next,\n\t.show\t= gcov_seq_show,\n\t.stop\t= gcov_seq_stop,\n};",
            "static void remove_node(struct gcov_node *node);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"gcov.h\"\n#include <linux/mm.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic DEFINE_MUTEX(node_lock);\nstatic const struct seq_operations gcov_seq_ops = {\n\t.start\t= gcov_seq_start,\n\t.next\t= gcov_seq_next,\n\t.show\t= gcov_seq_show,\n\t.stop\t= gcov_seq_stop,\n};\nstatic void remove_node(struct gcov_node *node);\n\nstatic int gcov_seq_open(struct inode *inode, struct file *file)\n{\n\tstruct gcov_node *node = inode->i_private;\n\tstruct gcov_iterator *iter;\n\tstruct seq_file *seq;\n\tstruct gcov_info *info;\n\tint rc = -ENOMEM;\n\n\tmutex_lock(&node_lock);\n\t/*\n\t * Read from a profiling data copy to minimize reference tracking\n\t * complexity and concurrent access and to keep accumulating multiple\n\t * profiling data sets associated with one node simple.\n\t */\n\tinfo = get_accumulated_info(node);\n\tif (!info)\n\t\tgoto out_unlock;\n\titer = gcov_iter_new(info);\n\tif (!iter)\n\t\tgoto err_free_info;\n\trc = seq_open(file, &gcov_seq_ops);\n\tif (rc)\n\t\tgoto err_free_iter_info;\n\tseq = file->private_data;\n\tseq->private = iter;\nout_unlock:\n\tmutex_unlock(&node_lock);\n\treturn rc;\n\nerr_free_iter_info:\n\tgcov_iter_free(iter);\nerr_free_info:\n\tgcov_info_free(info);\n\tgoto out_unlock;\n}"
        }
      },
      {
        "call_info": {
          "callee": "security_locked_down",
          "args": [
            "LOCKDOWN_TRACEFS"
          ],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/string.h>\n#include <linux/ftrace.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n\n__initdata_or_module static\nstruct;\nstatic const struct seq_operations show_format_seq_ops = {\n\t.start = t_start,\n\t.next = t_next,\n\t.show = t_show,\n\t.stop = t_stop,\n};\n\nstatic int\nftrace_formats_open(struct inode *inode, struct file *file)\n{\n\tint ret;\n\n\tret = security_locked_down(LOCKDOWN_TRACEFS);\n\tif (ret)\n\t\treturn ret;\n\n\treturn seq_open(file, &show_format_seq_ops);\n}"
  },
  {
    "function_name": "t_stop",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_printk.c",
    "lines": "348-351",
    "snippet": "static void t_stop(struct seq_file *m, void *p)\n{\n\tformat_mod_stop();\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/string.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/security.h>",
      "#include <linux/seq_file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "__initdata_or_module static\nstruct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "format_mod_stop",
          "args": [],
          "line": 350
        },
        "resolved": true,
        "details": {
          "function_name": "format_mod_stop",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_printk.c",
          "lines": "185-185",
          "snippet": "static inline void format_mod_stop(void) { }",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/string.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/security.h>",
            "#include <linux/seq_file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/string.h>\n#include <linux/ftrace.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n\nstatic inline void format_mod_stop(void) { }"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/string.h>\n#include <linux/ftrace.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n\n__initdata_or_module static\nstruct;\n\nstatic void t_stop(struct seq_file *m, void *p)\n{\n\tformat_mod_stop();\n}"
  },
  {
    "function_name": "t_show",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_printk.c",
    "lines": "311-346",
    "snippet": "static int t_show(struct seq_file *m, void *v)\n{\n\tconst char **fmt = v;\n\tconst char *str = *fmt;\n\tint i;\n\n\tif (!*fmt)\n\t\treturn 0;\n\n\tseq_printf(m, \"0x%lx : \\\"\", *(unsigned long *)fmt);\n\n\t/*\n\t * Tabs and new lines need to be converted.\n\t */\n\tfor (i = 0; str[i]; i++) {\n\t\tswitch (str[i]) {\n\t\tcase '\\n':\n\t\t\tseq_puts(m, \"\\\\n\");\n\t\t\tbreak;\n\t\tcase '\\t':\n\t\t\tseq_puts(m, \"\\\\t\");\n\t\t\tbreak;\n\t\tcase '\\\\':\n\t\t\tseq_putc(m, '\\\\');\n\t\t\tbreak;\n\t\tcase '\"':\n\t\t\tseq_puts(m, \"\\\\\\\"\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tseq_putc(m, str[i]);\n\t\t}\n\t}\n\tseq_puts(m, \"\\\"\\n\");\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/string.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/security.h>",
      "#include <linux/seq_file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "__initdata_or_module static\nstruct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "m",
            "\"\\\"\\n\""
          ],
          "line": 343
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_puts",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "205-220",
          "snippet": "void trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_putc",
          "args": [
            "m",
            "str[i]"
          ],
          "line": 340
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_putc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "233-246",
          "snippet": "void trace_seq_putc(struct trace_seq *s, unsigned char c)\n{\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (TRACE_SEQ_BUF_LEFT(s) < 1) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putc(&s->seq, c);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_putc(struct trace_seq *s, unsigned char c)\n{\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (TRACE_SEQ_BUF_LEFT(s) < 1) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putc(&s->seq, c);\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"0x%lx : \\\"\"",
            "*(unsigned long *)fmt"
          ],
          "line": 320
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "81-100",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/string.h>\n#include <linux/ftrace.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n\n__initdata_or_module static\nstruct;\n\nstatic int t_show(struct seq_file *m, void *v)\n{\n\tconst char **fmt = v;\n\tconst char *str = *fmt;\n\tint i;\n\n\tif (!*fmt)\n\t\treturn 0;\n\n\tseq_printf(m, \"0x%lx : \\\"\", *(unsigned long *)fmt);\n\n\t/*\n\t * Tabs and new lines need to be converted.\n\t */\n\tfor (i = 0; str[i]; i++) {\n\t\tswitch (str[i]) {\n\t\tcase '\\n':\n\t\t\tseq_puts(m, \"\\\\n\");\n\t\t\tbreak;\n\t\tcase '\\t':\n\t\t\tseq_puts(m, \"\\\\t\");\n\t\t\tbreak;\n\t\tcase '\\\\':\n\t\t\tseq_putc(m, '\\\\');\n\t\t\tbreak;\n\t\tcase '\"':\n\t\t\tseq_puts(m, \"\\\\\\\"\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tseq_putc(m, str[i]);\n\t\t}\n\t}\n\tseq_puts(m, \"\\\"\\n\");\n\n\treturn 0;\n}"
  },
  {
    "function_name": "t_next",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_printk.c",
    "lines": "305-309",
    "snippet": "static void *t_next(struct seq_file *m, void * v, loff_t *pos)\n{\n\t(*pos)++;\n\treturn find_next(v, pos);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/string.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/security.h>",
      "#include <linux/seq_file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "__initdata_or_module static\nstruct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "find_next",
          "args": [
            "v",
            "pos"
          ],
          "line": 308
        },
        "resolved": true,
        "details": {
          "function_name": "find_next",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_printk.c",
          "lines": "265-296",
          "snippet": "static const char **find_next(void *v, loff_t *pos)\n{\n\tconst char **fmt = v;\n\tint start_index;\n\tint last_index;\n\n\tstart_index = __stop___trace_bprintk_fmt - __start___trace_bprintk_fmt;\n\n\tif (*pos < start_index)\n\t\treturn __start___trace_bprintk_fmt + *pos;\n\n\t/*\n\t * The __tracepoint_str section is treated the same as the\n\t * __trace_printk_fmt section. The difference is that the\n\t * __trace_printk_fmt section should only be used by trace_printk()\n\t * in a debugging environment, as if anything exists in that section\n\t * the trace_prink() helper buffers are allocated, which would just\n\t * waste space in a production environment.\n\t *\n\t * The __tracepoint_str sections on the other hand are used by\n\t * tracepoints which need to map pointers to their strings to\n\t * the ASCII text for userspace.\n\t */\n\tlast_index = start_index;\n\tstart_index = __stop___tracepoint_str - __start___tracepoint_str;\n\n\tif (*pos < last_index + start_index)\n\t\treturn __start___tracepoint_str + (*pos - last_index);\n\n\tstart_index += last_index;\n\treturn find_next_mod_format(start_index, v, fmt, pos);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/string.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/security.h>",
            "#include <linux/seq_file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/string.h>\n#include <linux/ftrace.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n\nstatic const char **find_next(void *v, loff_t *pos)\n{\n\tconst char **fmt = v;\n\tint start_index;\n\tint last_index;\n\n\tstart_index = __stop___trace_bprintk_fmt - __start___trace_bprintk_fmt;\n\n\tif (*pos < start_index)\n\t\treturn __start___trace_bprintk_fmt + *pos;\n\n\t/*\n\t * The __tracepoint_str section is treated the same as the\n\t * __trace_printk_fmt section. The difference is that the\n\t * __trace_printk_fmt section should only be used by trace_printk()\n\t * in a debugging environment, as if anything exists in that section\n\t * the trace_prink() helper buffers are allocated, which would just\n\t * waste space in a production environment.\n\t *\n\t * The __tracepoint_str sections on the other hand are used by\n\t * tracepoints which need to map pointers to their strings to\n\t * the ASCII text for userspace.\n\t */\n\tlast_index = start_index;\n\tstart_index = __stop___tracepoint_str - __start___tracepoint_str;\n\n\tif (*pos < last_index + start_index)\n\t\treturn __start___tracepoint_str + (*pos - last_index);\n\n\tstart_index += last_index;\n\treturn find_next_mod_format(start_index, v, fmt, pos);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/string.h>\n#include <linux/ftrace.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n\n__initdata_or_module static\nstruct;\n\nstatic void *t_next(struct seq_file *m, void * v, loff_t *pos)\n{\n\t(*pos)++;\n\treturn find_next(v, pos);\n}"
  },
  {
    "function_name": "t_start",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_printk.c",
    "lines": "298-303",
    "snippet": "static void *\nt_start(struct seq_file *m, loff_t *pos)\n{\n\tformat_mod_start();\n\treturn find_next(NULL, pos);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/string.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/security.h>",
      "#include <linux/seq_file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "__initdata_or_module static\nstruct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "find_next",
          "args": [
            "NULL",
            "pos"
          ],
          "line": 302
        },
        "resolved": true,
        "details": {
          "function_name": "find_next",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_printk.c",
          "lines": "265-296",
          "snippet": "static const char **find_next(void *v, loff_t *pos)\n{\n\tconst char **fmt = v;\n\tint start_index;\n\tint last_index;\n\n\tstart_index = __stop___trace_bprintk_fmt - __start___trace_bprintk_fmt;\n\n\tif (*pos < start_index)\n\t\treturn __start___trace_bprintk_fmt + *pos;\n\n\t/*\n\t * The __tracepoint_str section is treated the same as the\n\t * __trace_printk_fmt section. The difference is that the\n\t * __trace_printk_fmt section should only be used by trace_printk()\n\t * in a debugging environment, as if anything exists in that section\n\t * the trace_prink() helper buffers are allocated, which would just\n\t * waste space in a production environment.\n\t *\n\t * The __tracepoint_str sections on the other hand are used by\n\t * tracepoints which need to map pointers to their strings to\n\t * the ASCII text for userspace.\n\t */\n\tlast_index = start_index;\n\tstart_index = __stop___tracepoint_str - __start___tracepoint_str;\n\n\tif (*pos < last_index + start_index)\n\t\treturn __start___tracepoint_str + (*pos - last_index);\n\n\tstart_index += last_index;\n\treturn find_next_mod_format(start_index, v, fmt, pos);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/string.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/security.h>",
            "#include <linux/seq_file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/string.h>\n#include <linux/ftrace.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n\nstatic const char **find_next(void *v, loff_t *pos)\n{\n\tconst char **fmt = v;\n\tint start_index;\n\tint last_index;\n\n\tstart_index = __stop___trace_bprintk_fmt - __start___trace_bprintk_fmt;\n\n\tif (*pos < start_index)\n\t\treturn __start___trace_bprintk_fmt + *pos;\n\n\t/*\n\t * The __tracepoint_str section is treated the same as the\n\t * __trace_printk_fmt section. The difference is that the\n\t * __trace_printk_fmt section should only be used by trace_printk()\n\t * in a debugging environment, as if anything exists in that section\n\t * the trace_prink() helper buffers are allocated, which would just\n\t * waste space in a production environment.\n\t *\n\t * The __tracepoint_str sections on the other hand are used by\n\t * tracepoints which need to map pointers to their strings to\n\t * the ASCII text for userspace.\n\t */\n\tlast_index = start_index;\n\tstart_index = __stop___tracepoint_str - __start___tracepoint_str;\n\n\tif (*pos < last_index + start_index)\n\t\treturn __start___tracepoint_str + (*pos - last_index);\n\n\tstart_index += last_index;\n\treturn find_next_mod_format(start_index, v, fmt, pos);\n}"
        }
      },
      {
        "call_info": {
          "callee": "format_mod_start",
          "args": [],
          "line": 301
        },
        "resolved": true,
        "details": {
          "function_name": "format_mod_start",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_printk.c",
          "lines": "184-184",
          "snippet": "static inline void format_mod_start(void) { }",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/string.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/security.h>",
            "#include <linux/seq_file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/string.h>\n#include <linux/ftrace.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n\nstatic inline void format_mod_start(void) { }"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/string.h>\n#include <linux/ftrace.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n\n__initdata_or_module static\nstruct;\n\nstatic void *\nt_start(struct seq_file *m, loff_t *pos)\n{\n\tformat_mod_start();\n\treturn find_next(NULL, pos);\n}"
  },
  {
    "function_name": "find_next",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_printk.c",
    "lines": "265-296",
    "snippet": "static const char **find_next(void *v, loff_t *pos)\n{\n\tconst char **fmt = v;\n\tint start_index;\n\tint last_index;\n\n\tstart_index = __stop___trace_bprintk_fmt - __start___trace_bprintk_fmt;\n\n\tif (*pos < start_index)\n\t\treturn __start___trace_bprintk_fmt + *pos;\n\n\t/*\n\t * The __tracepoint_str section is treated the same as the\n\t * __trace_printk_fmt section. The difference is that the\n\t * __trace_printk_fmt section should only be used by trace_printk()\n\t * in a debugging environment, as if anything exists in that section\n\t * the trace_prink() helper buffers are allocated, which would just\n\t * waste space in a production environment.\n\t *\n\t * The __tracepoint_str sections on the other hand are used by\n\t * tracepoints which need to map pointers to their strings to\n\t * the ASCII text for userspace.\n\t */\n\tlast_index = start_index;\n\tstart_index = __stop___tracepoint_str - __start___tracepoint_str;\n\n\tif (*pos < last_index + start_index)\n\t\treturn __start___tracepoint_str + (*pos - last_index);\n\n\tstart_index += last_index;\n\treturn find_next_mod_format(start_index, v, fmt, pos);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/string.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/security.h>",
      "#include <linux/seq_file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "find_next_mod_format",
          "args": [
            "start_index",
            "v",
            "fmt",
            "pos"
          ],
          "line": 295
        },
        "resolved": true,
        "details": {
          "function_name": "find_next_mod_format",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_printk.c",
          "lines": "179-183",
          "snippet": "static inline const char **\nfind_next_mod_format(int start_index, void *v, const char **fmt, loff_t *pos)\n{\n\treturn NULL;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/string.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/security.h>",
            "#include <linux/seq_file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/string.h>\n#include <linux/ftrace.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n\nstatic inline const char **\nfind_next_mod_format(int start_index, void *v, const char **fmt, loff_t *pos)\n{\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/string.h>\n#include <linux/ftrace.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n\nstatic const char **find_next(void *v, loff_t *pos)\n{\n\tconst char **fmt = v;\n\tint start_index;\n\tint last_index;\n\n\tstart_index = __stop___trace_bprintk_fmt - __start___trace_bprintk_fmt;\n\n\tif (*pos < start_index)\n\t\treturn __start___trace_bprintk_fmt + *pos;\n\n\t/*\n\t * The __tracepoint_str section is treated the same as the\n\t * __trace_printk_fmt section. The difference is that the\n\t * __trace_printk_fmt section should only be used by trace_printk()\n\t * in a debugging environment, as if anything exists in that section\n\t * the trace_prink() helper buffers are allocated, which would just\n\t * waste space in a production environment.\n\t *\n\t * The __tracepoint_str sections on the other hand are used by\n\t * tracepoints which need to map pointers to their strings to\n\t * the ASCII text for userspace.\n\t */\n\tlast_index = start_index;\n\tstart_index = __stop___tracepoint_str - __start___tracepoint_str;\n\n\tif (*pos < last_index + start_index)\n\t\treturn __start___tracepoint_str + (*pos - last_index);\n\n\tstart_index += last_index;\n\treturn find_next_mod_format(start_index, v, fmt, pos);\n}"
  },
  {
    "function_name": "trace_is_tracepoint_string",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_printk.c",
    "lines": "254-263",
    "snippet": "bool trace_is_tracepoint_string(const char *str)\n{\n\tconst char **ptr = __start___tracepoint_str;\n\n\tfor (ptr = __start___tracepoint_str; ptr < __stop___tracepoint_str; ptr++) {\n\t\tif (str == *ptr)\n\t\t\treturn true;\n\t}\n\treturn false;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/string.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/security.h>",
      "#include <linux/seq_file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/string.h>\n#include <linux/ftrace.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n\nbool trace_is_tracepoint_string(const char *str)\n{\n\tconst char **ptr = __start___tracepoint_str;\n\n\tfor (ptr = __start___tracepoint_str; ptr < __stop___tracepoint_str; ptr++) {\n\t\tif (str == *ptr)\n\t\t\treturn true;\n\t}\n\treturn false;\n}"
  },
  {
    "function_name": "__ftrace_vprintk",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_printk.c",
    "lines": "245-251",
    "snippet": "int __ftrace_vprintk(unsigned long ip, const char *fmt, va_list ap)\n{\n\tif (!trace_printk_enabled)\n\t\treturn 0;\n\n\treturn trace_vprintk(ip, fmt, ap);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/string.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/security.h>",
      "#include <linux/seq_file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_vprintk",
          "args": [
            "ip",
            "fmt",
            "ap"
          ],
          "line": 250
        },
        "resolved": true,
        "details": {
          "function_name": "__ftrace_vprintk",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_printk.c",
          "lines": "245-251",
          "snippet": "int __ftrace_vprintk(unsigned long ip, const char *fmt, va_list ap)\n{\n\tif (!trace_printk_enabled)\n\t\treturn 0;\n\n\treturn trace_vprintk(ip, fmt, ap);\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/string.h>\n#include <linux/ftrace.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n\nint __ftrace_vprintk(unsigned long ip, const char *fmt, va_list ap)\n{\n\tif (!trace_printk_enabled)\n\t\treturn 0;\n\n\treturn trace_vprintk(ip, fmt, ap);\n}"
  },
  {
    "function_name": "__trace_printk",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_printk.c",
    "lines": "230-242",
    "snippet": "int __trace_printk(unsigned long ip, const char *fmt, ...)\n{\n\tint ret;\n\tva_list ap;\n\n\tif (!trace_printk_enabled)\n\t\treturn 0;\n\n\tva_start(ap, fmt);\n\tret = trace_vprintk(ip, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/string.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/security.h>",
      "#include <linux/seq_file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "va_end",
          "args": [
            "ap"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_vprintk",
          "args": [
            "ip",
            "fmt",
            "ap"
          ],
          "line": 239
        },
        "resolved": true,
        "details": {
          "function_name": "__ftrace_vprintk",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_printk.c",
          "lines": "245-251",
          "snippet": "int __ftrace_vprintk(unsigned long ip, const char *fmt, va_list ap)\n{\n\tif (!trace_printk_enabled)\n\t\treturn 0;\n\n\treturn trace_vprintk(ip, fmt, ap);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/string.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/security.h>",
            "#include <linux/seq_file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/string.h>\n#include <linux/ftrace.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n\nint __ftrace_vprintk(unsigned long ip, const char *fmt, va_list ap)\n{\n\tif (!trace_printk_enabled)\n\t\treturn 0;\n\n\treturn trace_vprintk(ip, fmt, ap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "va_start",
          "args": [
            "ap",
            "fmt"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/string.h>\n#include <linux/ftrace.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n\nint __trace_printk(unsigned long ip, const char *fmt, ...)\n{\n\tint ret;\n\tva_list ap;\n\n\tif (!trace_printk_enabled)\n\t\treturn 0;\n\n\tva_start(ap, fmt);\n\tret = trace_vprintk(ip, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
  },
  {
    "function_name": "__ftrace_vbprintk",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_printk.c",
    "lines": "218-227",
    "snippet": "int __ftrace_vbprintk(unsigned long ip, const char *fmt, va_list ap)\n{\n\tif (unlikely(!fmt))\n\t\treturn 0;\n\n\tif (!trace_printk_enabled)\n\t\treturn 0;\n\n\treturn trace_vbprintk(ip, fmt, ap);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/string.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/security.h>",
      "#include <linux/seq_file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_vbprintk",
          "args": [
            "ip",
            "fmt",
            "ap"
          ],
          "line": 226
        },
        "resolved": true,
        "details": {
          "function_name": "__ftrace_vbprintk",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_printk.c",
          "lines": "218-227",
          "snippet": "int __ftrace_vbprintk(unsigned long ip, const char *fmt, va_list ap)\n{\n\tif (unlikely(!fmt))\n\t\treturn 0;\n\n\tif (!trace_printk_enabled)\n\t\treturn 0;\n\n\treturn trace_vbprintk(ip, fmt, ap);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!fmt"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/string.h>\n#include <linux/ftrace.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n\nint __ftrace_vbprintk(unsigned long ip, const char *fmt, va_list ap)\n{\n\tif (unlikely(!fmt))\n\t\treturn 0;\n\n\tif (!trace_printk_enabled)\n\t\treturn 0;\n\n\treturn trace_vbprintk(ip, fmt, ap);\n}"
  },
  {
    "function_name": "__trace_bprintk",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_printk.c",
    "lines": "200-215",
    "snippet": "int __trace_bprintk(unsigned long ip, const char *fmt, ...)\n{\n\tint ret;\n\tva_list ap;\n\n\tif (unlikely(!fmt))\n\t\treturn 0;\n\n\tif (!trace_printk_enabled)\n\t\treturn 0;\n\n\tva_start(ap, fmt);\n\tret = trace_vbprintk(ip, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/string.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/security.h>",
      "#include <linux/seq_file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "va_end",
          "args": [
            "ap"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_vbprintk",
          "args": [
            "ip",
            "fmt",
            "ap"
          ],
          "line": 212
        },
        "resolved": true,
        "details": {
          "function_name": "__ftrace_vbprintk",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_printk.c",
          "lines": "218-227",
          "snippet": "int __ftrace_vbprintk(unsigned long ip, const char *fmt, va_list ap)\n{\n\tif (unlikely(!fmt))\n\t\treturn 0;\n\n\tif (!trace_printk_enabled)\n\t\treturn 0;\n\n\treturn trace_vbprintk(ip, fmt, ap);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/string.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/security.h>",
            "#include <linux/seq_file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/string.h>\n#include <linux/ftrace.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n\nint __ftrace_vbprintk(unsigned long ip, const char *fmt, va_list ap)\n{\n\tif (unlikely(!fmt))\n\t\treturn 0;\n\n\tif (!trace_printk_enabled)\n\t\treturn 0;\n\n\treturn trace_vbprintk(ip, fmt, ap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "va_start",
          "args": [
            "ap",
            "fmt"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!fmt"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/string.h>\n#include <linux/ftrace.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n\nint __trace_bprintk(unsigned long ip, const char *fmt, ...)\n{\n\tint ret;\n\tva_list ap;\n\n\tif (unlikely(!fmt))\n\t\treturn 0;\n\n\tif (!trace_printk_enabled)\n\t\treturn 0;\n\n\tva_start(ap, fmt);\n\tret = trace_vbprintk(ip, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
  },
  {
    "function_name": "trace_printk_control",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_printk.c",
    "lines": "190-193",
    "snippet": "void trace_printk_control(bool enabled)\n{\n\ttrace_printk_enabled = enabled;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/string.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/security.h>",
      "#include <linux/seq_file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/string.h>\n#include <linux/ftrace.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n\nvoid trace_printk_control(bool enabled)\n{\n\ttrace_printk_enabled = enabled;\n}"
  },
  {
    "function_name": "format_mod_stop",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_printk.c",
    "lines": "185-185",
    "snippet": "static inline void format_mod_stop(void) { }",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/string.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/security.h>",
      "#include <linux/seq_file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/string.h>\n#include <linux/ftrace.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n\nstatic inline void format_mod_stop(void) { }"
  },
  {
    "function_name": "format_mod_start",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_printk.c",
    "lines": "184-184",
    "snippet": "static inline void format_mod_start(void) { }",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/string.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/security.h>",
      "#include <linux/seq_file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/string.h>\n#include <linux/ftrace.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n\nstatic inline void format_mod_start(void) { }"
  },
  {
    "function_name": "find_next_mod_format",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_printk.c",
    "lines": "179-183",
    "snippet": "static inline const char **\nfind_next_mod_format(int start_index, void *v, const char **fmt, loff_t *pos)\n{\n\treturn NULL;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/string.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/security.h>",
      "#include <linux/seq_file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/string.h>\n#include <linux/ftrace.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n\nstatic inline const char **\nfind_next_mod_format(int start_index, void *v, const char **fmt, loff_t *pos)\n{\n\treturn NULL;\n}"
  },
  {
    "function_name": "module_trace_bprintk_format_notify",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_printk.c",
    "lines": "173-178",
    "snippet": "__init static int\nmodule_trace_bprintk_format_notify(struct notifier_block *self,\n\t\tunsigned long val, void *data)\n{\n\treturn NOTIFY_OK;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/string.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/security.h>",
      "#include <linux/seq_file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "__initdata_or_module static\nstruct"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/string.h>\n#include <linux/ftrace.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n\n__initdata_or_module static\nstruct;\n\n__init static int\nmodule_trace_bprintk_format_notify(struct notifier_block *self,\n\t\tunsigned long val, void *data)\n{\n\treturn NOTIFY_OK;\n}"
  },
  {
    "function_name": "format_mod_stop",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_printk.c",
    "lines": "167-170",
    "snippet": "static void format_mod_stop(void)\n{\n\tmutex_unlock(&btrace_mutex);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/string.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/security.h>",
      "#include <linux/seq_file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&btrace_mutex"
          ],
          "line": 169
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/string.h>\n#include <linux/ftrace.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n\nstatic void format_mod_stop(void)\n{\n\tmutex_unlock(&btrace_mutex);\n}"
  },
  {
    "function_name": "format_mod_start",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_printk.c",
    "lines": "162-165",
    "snippet": "static void format_mod_start(void)\n{\n\tmutex_lock(&btrace_mutex);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/string.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/security.h>",
      "#include <linux/seq_file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&btrace_mutex"
          ],
          "line": 164
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/string.h>\n#include <linux/ftrace.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n\nstatic void format_mod_start(void)\n{\n\tmutex_lock(&btrace_mutex);\n}"
  },
  {
    "function_name": "find_next_mod_format",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_printk.c",
    "lines": "122-160",
    "snippet": "static const char **\nfind_next_mod_format(int start_index, void *v, const char **fmt, loff_t *pos)\n{\n\tstruct trace_bprintk_fmt *mod_fmt;\n\n\tif (list_empty(&trace_bprintk_fmt_list))\n\t\treturn NULL;\n\n\t/*\n\t * v will point to the address of the fmt record from t_next\n\t * v will be NULL from t_start.\n\t * If this is the first pointer or called from start\n\t * then we need to walk the list.\n\t */\n\tif (!v || start_index == *pos) {\n\t\tstruct trace_bprintk_fmt *p;\n\n\t\t/* search the module list */\n\t\tlist_for_each_entry(p, &trace_bprintk_fmt_list, list) {\n\t\t\tif (start_index == *pos)\n\t\t\t\treturn &p->fmt;\n\t\t\tstart_index++;\n\t\t}\n\t\t/* pos > index */\n\t\treturn NULL;\n\t}\n\n\t/*\n\t * v points to the address of the fmt field in the mod list\n\t * structure that holds the module print format.\n\t */\n\tmod_fmt = container_of(v, typeof(*mod_fmt), fmt);\n\tif (mod_fmt->list.next == &trace_bprintk_fmt_list)\n\t\treturn NULL;\n\n\tmod_fmt = container_of(mod_fmt->list.next, typeof(*mod_fmt), list);\n\n\treturn &mod_fmt->fmt;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/string.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/security.h>",
      "#include <linux/seq_file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "__initdata_or_module static\nstruct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "mod_fmt->list.next",
            "typeof(*mod_fmt)",
            "list"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "typeof",
          "args": [
            "*mod_fmt"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "v",
            "typeof(*mod_fmt)",
            "fmt"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "typeof",
          "args": [
            "*mod_fmt"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "p",
            "&trace_bprintk_fmt_list",
            "list"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&trace_bprintk_fmt_list"
          ],
          "line": 127
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "41-44",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "long rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nlong rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/string.h>\n#include <linux/ftrace.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n\n__initdata_or_module static\nstruct;\n\nstatic const char **\nfind_next_mod_format(int start_index, void *v, const char **fmt, loff_t *pos)\n{\n\tstruct trace_bprintk_fmt *mod_fmt;\n\n\tif (list_empty(&trace_bprintk_fmt_list))\n\t\treturn NULL;\n\n\t/*\n\t * v will point to the address of the fmt record from t_next\n\t * v will be NULL from t_start.\n\t * If this is the first pointer or called from start\n\t * then we need to walk the list.\n\t */\n\tif (!v || start_index == *pos) {\n\t\tstruct trace_bprintk_fmt *p;\n\n\t\t/* search the module list */\n\t\tlist_for_each_entry(p, &trace_bprintk_fmt_list, list) {\n\t\t\tif (start_index == *pos)\n\t\t\t\treturn &p->fmt;\n\t\t\tstart_index++;\n\t\t}\n\t\t/* pos > index */\n\t\treturn NULL;\n\t}\n\n\t/*\n\t * v points to the address of the fmt field in the mod list\n\t * structure that holds the module print format.\n\t */\n\tmod_fmt = container_of(v, typeof(*mod_fmt), fmt);\n\tif (mod_fmt->list.next == &trace_bprintk_fmt_list)\n\t\treturn NULL;\n\n\tmod_fmt = container_of(mod_fmt->list.next, typeof(*mod_fmt), list);\n\n\treturn &mod_fmt->fmt;\n}"
  },
  {
    "function_name": "module_trace_bprintk_format_notify",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_printk.c",
    "lines": "88-100",
    "snippet": "static int module_trace_bprintk_format_notify(struct notifier_block *self,\n\t\tunsigned long val, void *data)\n{\n\tstruct module *mod = data;\n\tif (mod->num_trace_bprintk_fmt) {\n\t\tconst char **start = mod->trace_bprintk_fmt_start;\n\t\tconst char **end = start + mod->num_trace_bprintk_fmt;\n\n\t\tif (val == MODULE_STATE_COMING)\n\t\t\thold_module_trace_bprintk_format(start, end);\n\t}\n\treturn NOTIFY_OK;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/string.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/security.h>",
      "#include <linux/seq_file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "__initdata_or_module static\nstruct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "hold_module_trace_bprintk_format",
          "args": [
            "start",
            "end"
          ],
          "line": 97
        },
        "resolved": true,
        "details": {
          "function_name": "hold_module_trace_bprintk_format",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_printk.c",
          "lines": "52-86",
          "snippet": "static\nvoid hold_module_trace_bprintk_format(const char **start, const char **end)\n{\n\tconst char **iter;\n\tchar *fmt;\n\n\t/* allocate the trace_printk per cpu buffers */\n\tif (start != end)\n\t\ttrace_printk_init_buffers();\n\n\tmutex_lock(&btrace_mutex);\n\tfor (iter = start; iter < end; iter++) {\n\t\tstruct trace_bprintk_fmt *tb_fmt = lookup_format(*iter);\n\t\tif (tb_fmt) {\n\t\t\tif (!IS_ERR(tb_fmt))\n\t\t\t\t*iter = tb_fmt->fmt;\n\t\t\tcontinue;\n\t\t}\n\n\t\tfmt = NULL;\n\t\ttb_fmt = kmalloc(sizeof(*tb_fmt), GFP_KERNEL);\n\t\tif (tb_fmt) {\n\t\t\tfmt = kmalloc(strlen(*iter) + 1, GFP_KERNEL);\n\t\t\tif (fmt) {\n\t\t\t\tlist_add_tail(&tb_fmt->list, &trace_bprintk_fmt_list);\n\t\t\t\tstrcpy(fmt, *iter);\n\t\t\t\ttb_fmt->fmt = fmt;\n\t\t\t} else\n\t\t\t\tkfree(tb_fmt);\n\t\t}\n\t\t*iter = fmt;\n\n\t}\n\tmutex_unlock(&btrace_mutex);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/string.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/security.h>",
            "#include <linux/seq_file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__initdata_or_module static\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/string.h>\n#include <linux/ftrace.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n\n__initdata_or_module static\nstruct;\n\nstatic\nvoid hold_module_trace_bprintk_format(const char **start, const char **end)\n{\n\tconst char **iter;\n\tchar *fmt;\n\n\t/* allocate the trace_printk per cpu buffers */\n\tif (start != end)\n\t\ttrace_printk_init_buffers();\n\n\tmutex_lock(&btrace_mutex);\n\tfor (iter = start; iter < end; iter++) {\n\t\tstruct trace_bprintk_fmt *tb_fmt = lookup_format(*iter);\n\t\tif (tb_fmt) {\n\t\t\tif (!IS_ERR(tb_fmt))\n\t\t\t\t*iter = tb_fmt->fmt;\n\t\t\tcontinue;\n\t\t}\n\n\t\tfmt = NULL;\n\t\ttb_fmt = kmalloc(sizeof(*tb_fmt), GFP_KERNEL);\n\t\tif (tb_fmt) {\n\t\t\tfmt = kmalloc(strlen(*iter) + 1, GFP_KERNEL);\n\t\t\tif (fmt) {\n\t\t\t\tlist_add_tail(&tb_fmt->list, &trace_bprintk_fmt_list);\n\t\t\t\tstrcpy(fmt, *iter);\n\t\t\t\ttb_fmt->fmt = fmt;\n\t\t\t} else\n\t\t\t\tkfree(tb_fmt);\n\t\t}\n\t\t*iter = fmt;\n\n\t}\n\tmutex_unlock(&btrace_mutex);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/string.h>\n#include <linux/ftrace.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n\n__initdata_or_module static\nstruct;\n\nstatic int module_trace_bprintk_format_notify(struct notifier_block *self,\n\t\tunsigned long val, void *data)\n{\n\tstruct module *mod = data;\n\tif (mod->num_trace_bprintk_fmt) {\n\t\tconst char **start = mod->trace_bprintk_fmt_start;\n\t\tconst char **end = start + mod->num_trace_bprintk_fmt;\n\n\t\tif (val == MODULE_STATE_COMING)\n\t\t\thold_module_trace_bprintk_format(start, end);\n\t}\n\treturn NOTIFY_OK;\n}"
  },
  {
    "function_name": "hold_module_trace_bprintk_format",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_printk.c",
    "lines": "52-86",
    "snippet": "static\nvoid hold_module_trace_bprintk_format(const char **start, const char **end)\n{\n\tconst char **iter;\n\tchar *fmt;\n\n\t/* allocate the trace_printk per cpu buffers */\n\tif (start != end)\n\t\ttrace_printk_init_buffers();\n\n\tmutex_lock(&btrace_mutex);\n\tfor (iter = start; iter < end; iter++) {\n\t\tstruct trace_bprintk_fmt *tb_fmt = lookup_format(*iter);\n\t\tif (tb_fmt) {\n\t\t\tif (!IS_ERR(tb_fmt))\n\t\t\t\t*iter = tb_fmt->fmt;\n\t\t\tcontinue;\n\t\t}\n\n\t\tfmt = NULL;\n\t\ttb_fmt = kmalloc(sizeof(*tb_fmt), GFP_KERNEL);\n\t\tif (tb_fmt) {\n\t\t\tfmt = kmalloc(strlen(*iter) + 1, GFP_KERNEL);\n\t\t\tif (fmt) {\n\t\t\t\tlist_add_tail(&tb_fmt->list, &trace_bprintk_fmt_list);\n\t\t\t\tstrcpy(fmt, *iter);\n\t\t\t\ttb_fmt->fmt = fmt;\n\t\t\t} else\n\t\t\t\tkfree(tb_fmt);\n\t\t}\n\t\t*iter = fmt;\n\n\t}\n\tmutex_unlock(&btrace_mutex);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/string.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/security.h>",
      "#include <linux/seq_file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "__initdata_or_module static\nstruct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&btrace_mutex"
          ],
          "line": 85
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "tb_fmt"
          ],
          "line": 80
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "fmt",
            "*iter"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&tb_fmt->list",
            "&trace_bprintk_fmt_list"
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "strlen(*iter) + 1",
            "GFP_KERNEL"
          ],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "*iter"
          ],
          "line": 74
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_eprobe.c",
          "lines": "384-401",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/ftrace.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(*tb_fmt)",
            "GFP_KERNEL"
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "tb_fmt"
          ],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lookup_format",
          "args": [
            "*iter"
          ],
          "line": 64
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_format",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_printk.c",
          "lines": "38-50",
          "snippet": "static inline struct trace_bprintk_fmt *lookup_format(const char *fmt)\n{\n\tstruct trace_bprintk_fmt *pos;\n\n\tif (!fmt)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tlist_for_each_entry(pos, &trace_bprintk_fmt_list, list) {\n\t\tif (!strcmp(pos->fmt, fmt))\n\t\t\treturn pos;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/string.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/security.h>",
            "#include <linux/seq_file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__initdata_or_module static\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/string.h>\n#include <linux/ftrace.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n\n__initdata_or_module static\nstruct;\n\nstatic inline struct trace_bprintk_fmt *lookup_format(const char *fmt)\n{\n\tstruct trace_bprintk_fmt *pos;\n\n\tif (!fmt)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tlist_for_each_entry(pos, &trace_bprintk_fmt_list, list) {\n\t\tif (!strcmp(pos->fmt, fmt))\n\t\t\treturn pos;\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&btrace_mutex"
          ],
          "line": 62
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_printk_init_buffers",
          "args": [],
          "line": 60
        },
        "resolved": true,
        "details": {
          "function_name": "trace_printk_init_buffers",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "3263-3301",
          "snippet": "void trace_printk_init_buffers(void)\n{\n\tif (buffers_allocated)\n\t\treturn;\n\n\tif (alloc_percpu_trace_buffer())\n\t\treturn;\n\n\t/* trace_printk() is for debug use only. Don't use it in production. */\n\n\tpr_warn(\"\\n\");\n\tpr_warn(\"**********************************************************\\n\");\n\tpr_warn(\"**   NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE   **\\n\");\n\tpr_warn(\"**                                                      **\\n\");\n\tpr_warn(\"** trace_printk() being used. Allocating extra memory.  **\\n\");\n\tpr_warn(\"**                                                      **\\n\");\n\tpr_warn(\"** This means that this is a DEBUG kernel and it is     **\\n\");\n\tpr_warn(\"** unsafe for production use.                           **\\n\");\n\tpr_warn(\"**                                                      **\\n\");\n\tpr_warn(\"** If you see this message and you are not debugging    **\\n\");\n\tpr_warn(\"** the kernel, report this immediately to your vendor!  **\\n\");\n\tpr_warn(\"**                                                      **\\n\");\n\tpr_warn(\"**   NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE   **\\n\");\n\tpr_warn(\"**********************************************************\\n\");\n\n\t/* Expand the buffers to set size */\n\ttracing_update_buffers();\n\n\tbuffers_allocated = 1;\n\n\t/*\n\t * trace_printk_init_buffers() can be called by modules.\n\t * If that happens, then we need to start cmdline recording\n\t * directly here. If the global_trace.buffer is already\n\t * allocated here, then this was called by module code.\n\t */\n\tif (global_trace.array_buffer.buffer)\n\t\ttracing_start_cmdline_record();\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};",
            "static void add_tracer_options(struct trace_array *tr, struct tracer *t);",
            "static int buffers_allocated;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};\nstatic void add_tracer_options(struct trace_array *tr, struct tracer *t);\nstatic int buffers_allocated;\n\nvoid trace_printk_init_buffers(void)\n{\n\tif (buffers_allocated)\n\t\treturn;\n\n\tif (alloc_percpu_trace_buffer())\n\t\treturn;\n\n\t/* trace_printk() is for debug use only. Don't use it in production. */\n\n\tpr_warn(\"\\n\");\n\tpr_warn(\"**********************************************************\\n\");\n\tpr_warn(\"**   NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE   **\\n\");\n\tpr_warn(\"**                                                      **\\n\");\n\tpr_warn(\"** trace_printk() being used. Allocating extra memory.  **\\n\");\n\tpr_warn(\"**                                                      **\\n\");\n\tpr_warn(\"** This means that this is a DEBUG kernel and it is     **\\n\");\n\tpr_warn(\"** unsafe for production use.                           **\\n\");\n\tpr_warn(\"**                                                      **\\n\");\n\tpr_warn(\"** If you see this message and you are not debugging    **\\n\");\n\tpr_warn(\"** the kernel, report this immediately to your vendor!  **\\n\");\n\tpr_warn(\"**                                                      **\\n\");\n\tpr_warn(\"**   NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE   **\\n\");\n\tpr_warn(\"**********************************************************\\n\");\n\n\t/* Expand the buffers to set size */\n\ttracing_update_buffers();\n\n\tbuffers_allocated = 1;\n\n\t/*\n\t * trace_printk_init_buffers() can be called by modules.\n\t * If that happens, then we need to start cmdline recording\n\t * directly here. If the global_trace.buffer is already\n\t * allocated here, then this was called by module code.\n\t */\n\tif (global_trace.array_buffer.buffer)\n\t\ttracing_start_cmdline_record();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/string.h>\n#include <linux/ftrace.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n\n__initdata_or_module static\nstruct;\n\nstatic\nvoid hold_module_trace_bprintk_format(const char **start, const char **end)\n{\n\tconst char **iter;\n\tchar *fmt;\n\n\t/* allocate the trace_printk per cpu buffers */\n\tif (start != end)\n\t\ttrace_printk_init_buffers();\n\n\tmutex_lock(&btrace_mutex);\n\tfor (iter = start; iter < end; iter++) {\n\t\tstruct trace_bprintk_fmt *tb_fmt = lookup_format(*iter);\n\t\tif (tb_fmt) {\n\t\t\tif (!IS_ERR(tb_fmt))\n\t\t\t\t*iter = tb_fmt->fmt;\n\t\t\tcontinue;\n\t\t}\n\n\t\tfmt = NULL;\n\t\ttb_fmt = kmalloc(sizeof(*tb_fmt), GFP_KERNEL);\n\t\tif (tb_fmt) {\n\t\t\tfmt = kmalloc(strlen(*iter) + 1, GFP_KERNEL);\n\t\t\tif (fmt) {\n\t\t\t\tlist_add_tail(&tb_fmt->list, &trace_bprintk_fmt_list);\n\t\t\t\tstrcpy(fmt, *iter);\n\t\t\t\ttb_fmt->fmt = fmt;\n\t\t\t} else\n\t\t\t\tkfree(tb_fmt);\n\t\t}\n\t\t*iter = fmt;\n\n\t}\n\tmutex_unlock(&btrace_mutex);\n}"
  },
  {
    "function_name": "lookup_format",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_printk.c",
    "lines": "38-50",
    "snippet": "static inline struct trace_bprintk_fmt *lookup_format(const char *fmt)\n{\n\tstruct trace_bprintk_fmt *pos;\n\n\tif (!fmt)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tlist_for_each_entry(pos, &trace_bprintk_fmt_list, list) {\n\t\tif (!strcmp(pos->fmt, fmt))\n\t\t\treturn pos;\n\t}\n\treturn NULL;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/string.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/security.h>",
      "#include <linux/seq_file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "__initdata_or_module static\nstruct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "pos->fmt",
            "fmt"
          ],
          "line": 46
        },
        "resolved": true,
        "details": {
          "function_name": "sym_strcmp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/report.c",
          "lines": "356-365",
          "snippet": "static int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}",
          "includes": [
            "#include \"encoding.h\"",
            "#include \"kcsan.h\"",
            "#include <linux/stacktrace.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/delay.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"encoding.h\"\n#include \"kcsan.h\"\n#include <linux/stacktrace.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/lockdep.h>\n#include <linux/kernel.h>\n#include <linux/kallsyms.h>\n#include <linux/jiffies.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n\nstatic int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "pos",
            "&trace_bprintk_fmt_list",
            "list"
          ],
          "line": 45
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EINVAL"
          ],
          "line": 43
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/string.h>\n#include <linux/ftrace.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n\n__initdata_or_module static\nstruct;\n\nstatic inline struct trace_bprintk_fmt *lookup_format(const char *fmt)\n{\n\tstruct trace_bprintk_fmt *pos;\n\n\tif (!fmt)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tlist_for_each_entry(pos, &trace_bprintk_fmt_list, list) {\n\t\tif (!strcmp(pos->fmt, fmt))\n\t\t\treturn pos;\n\t}\n\treturn NULL;\n}"
  }
]