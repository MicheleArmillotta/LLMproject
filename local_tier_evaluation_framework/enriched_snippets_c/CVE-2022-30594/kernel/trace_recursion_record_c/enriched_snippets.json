[
  {
    "function_name": "create_recursed_functions",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_recursion_record.c",
    "lines": "225-234",
    "snippet": "__init static int create_recursed_functions(void)\n{\n\tstruct dentry *dentry;\n\n\tdentry = trace_create_file(\"recursed_functions\", TRACE_MODE_WRITE,\n\t\t\t\t   NULL, NULL, &recursed_functions_fops);\n\tif (!dentry)\n\t\tpr_warn(\"WARNING: Failed to create recursed_functions\\n\");\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <linux/fs.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/seq_file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct recursed_functions recursed_functions[CONFIG_FTRACE_RECORD_RECURSION_SIZE];",
      "static const struct file_operations recursed_functions_fops = {\n\t.open           = recursed_function_open,\n\t.write\t\t= recursed_function_write,\n\t.read           = seq_read,\n\t.llseek         = seq_lseek,\n\t.release        = recursed_function_release,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"WARNING: Failed to create recursed_functions\\n\""
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_create_file",
          "args": [
            "\"recursed_functions\"",
            "TRACE_MODE_WRITE",
            "NULL",
            "NULL",
            "&recursed_functions_fops"
          ],
          "line": 229
        },
        "resolved": true,
        "details": {
          "function_name": "trace_create_file",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "8771-8784",
          "snippet": "struct dentry *trace_create_file(const char *name,\n\t\t\t\t umode_t mode,\n\t\t\t\t struct dentry *parent,\n\t\t\t\t void *data,\n\t\t\t\t const struct file_operations *fops)\n{\n\tstruct dentry *ret;\n\n\tret = tracefs_create_file(name, mode, parent, data, fops);\n\tif (!ret)\n\t\tpr_warn(\"Could not create tracefs '%s' entry\\n\", name);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nstruct dentry *trace_create_file(const char *name,\n\t\t\t\t umode_t mode,\n\t\t\t\t struct dentry *parent,\n\t\t\t\t void *data,\n\t\t\t\t const struct file_operations *fops)\n{\n\tstruct dentry *ret;\n\n\tret = tracefs_create_file(name, mode, parent, data, fops);\n\tif (!ret)\n\t\tpr_warn(\"Could not create tracefs '%s' entry\\n\", name);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <linux/fs.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/kallsyms.h>\n#include <linux/seq_file.h>\n\nstatic struct recursed_functions recursed_functions[CONFIG_FTRACE_RECORD_RECURSION_SIZE];\nstatic const struct file_operations recursed_functions_fops = {\n\t.open           = recursed_function_open,\n\t.write\t\t= recursed_function_write,\n\t.read           = seq_read,\n\t.llseek         = seq_lseek,\n\t.release        = recursed_function_release,\n};\n\n__init static int create_recursed_functions(void)\n{\n\tstruct dentry *dentry;\n\n\tdentry = trace_create_file(\"recursed_functions\", TRACE_MODE_WRITE,\n\t\t\t\t   NULL, NULL, &recursed_functions_fops);\n\tif (!dentry)\n\t\tpr_warn(\"WARNING: Failed to create recursed_functions\\n\");\n\treturn 0;\n}"
  },
  {
    "function_name": "recursed_function_release",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_recursion_record.c",
    "lines": "210-215",
    "snippet": "static int recursed_function_release(struct inode *inode, struct file *file)\n{\n\tif (file->f_mode & FMODE_READ)\n\t\tseq_release(inode, file);\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <linux/fs.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/seq_file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_release",
          "args": [
            "inode",
            "file"
          ],
          "line": 213
        },
        "resolved": true,
        "details": {
          "function_name": "gcov_seq_release",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/gcov/fs.c",
          "lines": "328-342",
          "snippet": "static int gcov_seq_release(struct inode *inode, struct file *file)\n{\n\tstruct gcov_iterator *iter;\n\tstruct gcov_info *info;\n\tstruct seq_file *seq;\n\n\tseq = file->private_data;\n\titer = seq->private;\n\tinfo = gcov_iter_get_info(iter);\n\tgcov_iter_free(iter);\n\tgcov_info_free(info);\n\tseq_release(inode, file);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"gcov.h\"",
            "#include <linux/mm.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"gcov.h\"\n#include <linux/mm.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic int gcov_seq_release(struct inode *inode, struct file *file)\n{\n\tstruct gcov_iterator *iter;\n\tstruct gcov_info *info;\n\tstruct seq_file *seq;\n\n\tseq = file->private_data;\n\titer = seq->private;\n\tinfo = gcov_iter_get_info(iter);\n\tgcov_iter_free(iter);\n\tgcov_info_free(info);\n\tseq_release(inode, file);\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <linux/fs.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/kallsyms.h>\n#include <linux/seq_file.h>\n\nstatic int recursed_function_release(struct inode *inode, struct file *file)\n{\n\tif (file->f_mode & FMODE_READ)\n\t\tseq_release(inode, file);\n\treturn 0;\n}"
  },
  {
    "function_name": "recursed_function_write",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_recursion_record.c",
    "lines": "203-208",
    "snippet": "static ssize_t recursed_function_write(struct file *file,\n\t\t\t\t       const char __user *buffer,\n\t\t\t\t       size_t count, loff_t *ppos)\n{\n\treturn count;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <linux/fs.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/seq_file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <linux/fs.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/kallsyms.h>\n#include <linux/seq_file.h>\n\nstatic ssize_t recursed_function_write(struct file *file,\n\t\t\t\t       const char __user *buffer,\n\t\t\t\t       size_t count, loff_t *ppos)\n{\n\treturn count;\n}"
  },
  {
    "function_name": "recursed_function_open",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_recursion_record.c",
    "lines": "181-201",
    "snippet": "static int recursed_function_open(struct inode *inode, struct file *file)\n{\n\tint ret = 0;\n\n\tmutex_lock(&recursed_function_lock);\n\t/* If this file was opened for write, then erase contents */\n\tif ((file->f_mode & FMODE_WRITE) && (file->f_flags & O_TRUNC)) {\n\t\t/* disable updating records */\n\t\tatomic_set(&nr_records, -1);\n\t\tsmp_mb__after_atomic();\n\t\tmemset(recursed_functions, 0, sizeof(recursed_functions));\n\t\tsmp_wmb();\n\t\t/* enable them again */\n\t\tatomic_set(&nr_records, 0);\n\t}\n\tif (file->f_mode & FMODE_READ)\n\t\tret = seq_open(file, &recursed_function_seq_ops);\n\tmutex_unlock(&recursed_function_lock);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <linux/fs.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/seq_file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct recursed_functions recursed_functions[CONFIG_FTRACE_RECORD_RECURSION_SIZE];",
      "static atomic_t nr_records;",
      "static DEFINE_MUTEX(recursed_function_lock);",
      "static const struct seq_operations recursed_function_seq_ops = {\n\t.start  = recursed_function_seq_start,\n\t.next   = recursed_function_seq_next,\n\t.stop   = recursed_function_seq_stop,\n\t.show   = recursed_function_seq_show\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&recursed_function_lock"
          ],
          "line": 198
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_open",
          "args": [
            "file",
            "&recursed_function_seq_ops"
          ],
          "line": 197
        },
        "resolved": true,
        "details": {
          "function_name": "gcov_seq_open",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/gcov/fs.c",
          "lines": "288-322",
          "snippet": "static int gcov_seq_open(struct inode *inode, struct file *file)\n{\n\tstruct gcov_node *node = inode->i_private;\n\tstruct gcov_iterator *iter;\n\tstruct seq_file *seq;\n\tstruct gcov_info *info;\n\tint rc = -ENOMEM;\n\n\tmutex_lock(&node_lock);\n\t/*\n\t * Read from a profiling data copy to minimize reference tracking\n\t * complexity and concurrent access and to keep accumulating multiple\n\t * profiling data sets associated with one node simple.\n\t */\n\tinfo = get_accumulated_info(node);\n\tif (!info)\n\t\tgoto out_unlock;\n\titer = gcov_iter_new(info);\n\tif (!iter)\n\t\tgoto err_free_info;\n\trc = seq_open(file, &gcov_seq_ops);\n\tif (rc)\n\t\tgoto err_free_iter_info;\n\tseq = file->private_data;\n\tseq->private = iter;\nout_unlock:\n\tmutex_unlock(&node_lock);\n\treturn rc;\n\nerr_free_iter_info:\n\tgcov_iter_free(iter);\nerr_free_info:\n\tgcov_info_free(info);\n\tgoto out_unlock;\n}",
          "includes": [
            "#include \"gcov.h\"",
            "#include <linux/mm.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(node_lock);",
            "static const struct seq_operations gcov_seq_ops = {\n\t.start\t= gcov_seq_start,\n\t.next\t= gcov_seq_next,\n\t.show\t= gcov_seq_show,\n\t.stop\t= gcov_seq_stop,\n};",
            "static void remove_node(struct gcov_node *node);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"gcov.h\"\n#include <linux/mm.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic DEFINE_MUTEX(node_lock);\nstatic const struct seq_operations gcov_seq_ops = {\n\t.start\t= gcov_seq_start,\n\t.next\t= gcov_seq_next,\n\t.show\t= gcov_seq_show,\n\t.stop\t= gcov_seq_stop,\n};\nstatic void remove_node(struct gcov_node *node);\n\nstatic int gcov_seq_open(struct inode *inode, struct file *file)\n{\n\tstruct gcov_node *node = inode->i_private;\n\tstruct gcov_iterator *iter;\n\tstruct seq_file *seq;\n\tstruct gcov_info *info;\n\tint rc = -ENOMEM;\n\n\tmutex_lock(&node_lock);\n\t/*\n\t * Read from a profiling data copy to minimize reference tracking\n\t * complexity and concurrent access and to keep accumulating multiple\n\t * profiling data sets associated with one node simple.\n\t */\n\tinfo = get_accumulated_info(node);\n\tif (!info)\n\t\tgoto out_unlock;\n\titer = gcov_iter_new(info);\n\tif (!iter)\n\t\tgoto err_free_info;\n\trc = seq_open(file, &gcov_seq_ops);\n\tif (rc)\n\t\tgoto err_free_iter_info;\n\tseq = file->private_data;\n\tseq->private = iter;\nout_unlock:\n\tmutex_unlock(&node_lock);\n\treturn rc;\n\nerr_free_iter_info:\n\tgcov_iter_free(iter);\nerr_free_info:\n\tgcov_info_free(info);\n\tgoto out_unlock;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&nr_records",
            "0"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_wmb",
          "args": [],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "recursed_functions",
            "0",
            "sizeof(recursed_functions)"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_mb__after_atomic",
          "args": [],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&nr_records",
            "-1"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&recursed_function_lock"
          ],
          "line": 185
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <linux/fs.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/kallsyms.h>\n#include <linux/seq_file.h>\n\nstatic struct recursed_functions recursed_functions[CONFIG_FTRACE_RECORD_RECURSION_SIZE];\nstatic atomic_t nr_records;\nstatic DEFINE_MUTEX(recursed_function_lock);\nstatic const struct seq_operations recursed_function_seq_ops = {\n\t.start  = recursed_function_seq_start,\n\t.next   = recursed_function_seq_next,\n\t.stop   = recursed_function_seq_stop,\n\t.show   = recursed_function_seq_show\n};\n\nstatic int recursed_function_open(struct inode *inode, struct file *file)\n{\n\tint ret = 0;\n\n\tmutex_lock(&recursed_function_lock);\n\t/* If this file was opened for write, then erase contents */\n\tif ((file->f_mode & FMODE_WRITE) && (file->f_flags & O_TRUNC)) {\n\t\t/* disable updating records */\n\t\tatomic_set(&nr_records, -1);\n\t\tsmp_mb__after_atomic();\n\t\tmemset(recursed_functions, 0, sizeof(recursed_functions));\n\t\tsmp_wmb();\n\t\t/* enable them again */\n\t\tatomic_set(&nr_records, 0);\n\t}\n\tif (file->f_mode & FMODE_READ)\n\t\tret = seq_open(file, &recursed_function_seq_ops);\n\tmutex_unlock(&recursed_function_lock);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "recursed_function_seq_show",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_recursion_record.c",
    "lines": "158-172",
    "snippet": "static int recursed_function_seq_show(struct seq_file *m, void *v)\n{\n\tstruct recursed_functions *record = v;\n\tint ret = 0;\n\n\tif (record) {\n\t\ttrace_seq_print_sym(tseq, record->parent_ip, true);\n\t\ttrace_seq_puts(tseq, \":\\t\");\n\t\ttrace_seq_print_sym(tseq, record->ip, true);\n\t\ttrace_seq_putc(tseq, '\\n');\n\t\tret = trace_print_seq(m, tseq);\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <linux/fs.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/seq_file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct recursed_functions recursed_functions[CONFIG_FTRACE_RECORD_RECURSION_SIZE];",
      "static struct trace_seq *tseq;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_print_seq",
          "args": [
            "m",
            "tseq"
          ],
          "line": 168
        },
        "resolved": true,
        "details": {
          "function_name": "trace_print_seq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "51-68",
          "snippet": "int trace_print_seq(struct seq_file *m, struct trace_seq *s)\n{\n\tint ret;\n\n\t__trace_seq_init(s);\n\n\tret = seq_buf_print_seq(m, &s->seq);\n\n\t/*\n\t * Only reset this buffer if we successfully wrote to the\n\t * seq_file buffer. This lets the caller try again or\n\t * do something else with the contents.\n\t */\n\tif (!ret)\n\t\ttrace_seq_init(s);\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nint trace_print_seq(struct seq_file *m, struct trace_seq *s)\n{\n\tint ret;\n\n\t__trace_seq_init(s);\n\n\tret = seq_buf_print_seq(m, &s->seq);\n\n\t/*\n\t * Only reset this buffer if we successfully wrote to the\n\t * seq_file buffer. This lets the caller try again or\n\t * do something else with the contents.\n\t */\n\tif (!ret)\n\t\ttrace_seq_init(s);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_seq_putc",
          "args": [
            "tseq",
            "'\\n'"
          ],
          "line": 167
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_putc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "233-246",
          "snippet": "void trace_seq_putc(struct trace_seq *s, unsigned char c)\n{\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (TRACE_SEQ_BUF_LEFT(s) < 1) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putc(&s->seq, c);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_putc(struct trace_seq *s, unsigned char c)\n{\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (TRACE_SEQ_BUF_LEFT(s) < 1) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putc(&s->seq, c);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_seq_print_sym",
          "args": [
            "tseq",
            "record->ip",
            "true"
          ],
          "line": 166
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_print_sym",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_output.c",
          "lines": "357-376",
          "snippet": "void\ntrace_seq_print_sym(struct trace_seq *s, unsigned long address, bool offset)\n{\n#ifdef CONFIG_KALLSYMS\n\tchar str[KSYM_SYMBOL_LEN];\n\tconst char *name;\n\n\tif (offset)\n\t\tsprint_symbol(str, address);\n\telse\n\t\tkallsyms_lookup(address, NULL, NULL, NULL, str);\n\tname = kretprobed(str, address);\n\n\tif (name && strlen(name)) {\n\t\ttrace_seq_puts(s, name);\n\t\treturn;\n\t}\n#endif\n\ttrace_seq_printf(s, \"0x%08lx\", address);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nvoid\ntrace_seq_print_sym(struct trace_seq *s, unsigned long address, bool offset)\n{\n#ifdef CONFIG_KALLSYMS\n\tchar str[KSYM_SYMBOL_LEN];\n\tconst char *name;\n\n\tif (offset)\n\t\tsprint_symbol(str, address);\n\telse\n\t\tkallsyms_lookup(address, NULL, NULL, NULL, str);\n\tname = kretprobed(str, address);\n\n\tif (name && strlen(name)) {\n\t\ttrace_seq_puts(s, name);\n\t\treturn;\n\t}\n#endif\n\ttrace_seq_printf(s, \"0x%08lx\", address);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_seq_puts",
          "args": [
            "tseq",
            "\":\\t\""
          ],
          "line": 165
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_puts",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "205-220",
          "snippet": "void trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <linux/fs.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/kallsyms.h>\n#include <linux/seq_file.h>\n\nstatic struct recursed_functions recursed_functions[CONFIG_FTRACE_RECORD_RECURSION_SIZE];\nstatic struct trace_seq *tseq;\n\nstatic int recursed_function_seq_show(struct seq_file *m, void *v)\n{\n\tstruct recursed_functions *record = v;\n\tint ret = 0;\n\n\tif (record) {\n\t\ttrace_seq_print_sym(tseq, record->parent_ip, true);\n\t\ttrace_seq_puts(tseq, \":\\t\");\n\t\ttrace_seq_print_sym(tseq, record->ip, true);\n\t\ttrace_seq_putc(tseq, '\\n');\n\t\tret = trace_print_seq(m, tseq);\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "recursed_function_seq_stop",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_recursion_record.c",
    "lines": "152-156",
    "snippet": "static void recursed_function_seq_stop(struct seq_file *m, void *v)\n{\n\tkfree(tseq);\n\tmutex_unlock(&recursed_function_lock);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <linux/fs.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/seq_file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(recursed_function_lock);",
      "static struct trace_seq *tseq;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&recursed_function_lock"
          ],
          "line": 155
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "tseq"
          ],
          "line": 154
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <linux/fs.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/kallsyms.h>\n#include <linux/seq_file.h>\n\nstatic DEFINE_MUTEX(recursed_function_lock);\nstatic struct trace_seq *tseq;\n\nstatic void recursed_function_seq_stop(struct seq_file *m, void *v)\n{\n\tkfree(tseq);\n\tmutex_unlock(&recursed_function_lock);\n}"
  },
  {
    "function_name": "recursed_function_seq_next",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_recursion_record.c",
    "lines": "141-150",
    "snippet": "static void *recursed_function_seq_next(struct seq_file *m, void *v, loff_t *pos)\n{\n\tint index;\n\tint p;\n\n\tindex = atomic_read(&nr_records);\n\tp = ++(*pos);\n\n\treturn p < index ? &recursed_functions[p] : NULL;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <linux/fs.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/seq_file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct recursed_functions recursed_functions[CONFIG_FTRACE_RECORD_RECURSION_SIZE];",
      "static atomic_t nr_records;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&nr_records"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <linux/fs.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/kallsyms.h>\n#include <linux/seq_file.h>\n\nstatic struct recursed_functions recursed_functions[CONFIG_FTRACE_RECORD_RECURSION_SIZE];\nstatic atomic_t nr_records;\n\nstatic void *recursed_function_seq_next(struct seq_file *m, void *v, loff_t *pos)\n{\n\tint index;\n\tint p;\n\n\tindex = atomic_read(&nr_records);\n\tp = ++(*pos);\n\n\treturn p < index ? &recursed_functions[p] : NULL;\n}"
  },
  {
    "function_name": "recursed_function_seq_start",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_recursion_record.c",
    "lines": "121-139",
    "snippet": "static void *recursed_function_seq_start(struct seq_file *m, loff_t *pos)\n{\n\tvoid *ret = NULL;\n\tint index;\n\n\tmutex_lock(&recursed_function_lock);\n\tindex = atomic_read(&nr_records);\n\tif (*pos < index) {\n\t\tret = &recursed_functions[*pos];\n\t}\n\n\ttseq = kzalloc(sizeof(*tseq), GFP_KERNEL);\n\tif (!tseq)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\ttrace_seq_init(tseq);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <linux/fs.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/seq_file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct recursed_functions recursed_functions[CONFIG_FTRACE_RECORD_RECURSION_SIZE];",
      "static atomic_t nr_records;",
      "static DEFINE_MUTEX(recursed_function_lock);",
      "static struct trace_seq *tseq;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_seq_init",
          "args": [
            "tseq"
          ],
          "line": 136
        },
        "resolved": true,
        "details": {
          "function_name": "__trace_seq_init",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "36-40",
          "snippet": "static inline void __trace_seq_init(struct trace_seq *s)\n{\n\tif (unlikely(!s->seq.size))\n\t\ttrace_seq_init(s);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nstatic inline void __trace_seq_init(struct trace_seq *s)\n{\n\tif (unlikely(!s->seq.size))\n\t\ttrace_seq_init(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*tseq)",
            "GFP_KERNEL"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&nr_records"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&recursed_function_lock"
          ],
          "line": 126
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <linux/fs.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/kallsyms.h>\n#include <linux/seq_file.h>\n\nstatic struct recursed_functions recursed_functions[CONFIG_FTRACE_RECORD_RECURSION_SIZE];\nstatic atomic_t nr_records;\nstatic DEFINE_MUTEX(recursed_function_lock);\nstatic struct trace_seq *tseq;\n\nstatic void *recursed_function_seq_start(struct seq_file *m, loff_t *pos)\n{\n\tvoid *ret = NULL;\n\tint index;\n\n\tmutex_lock(&recursed_function_lock);\n\tindex = atomic_read(&nr_records);\n\tif (*pos < index) {\n\t\tret = &recursed_functions[*pos];\n\t}\n\n\ttseq = kzalloc(sizeof(*tseq), GFP_KERNEL);\n\tif (!tseq)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\ttrace_seq_init(tseq);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "ftrace_record_recursion",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_recursion_record.c",
    "lines": "25-115",
    "snippet": "void ftrace_record_recursion(unsigned long ip, unsigned long parent_ip)\n{\n\tint index = 0;\n\tint i;\n\tunsigned long old;\n\n again:\n\t/* First check the last one recorded */\n\tif (ip == cached_function)\n\t\treturn;\n\n\ti = atomic_read(&nr_records);\n\t/* nr_records is -1 when clearing records */\n\tsmp_mb__after_atomic();\n\tif (i < 0)\n\t\treturn;\n\n\t/*\n\t * If there's two writers and this writer comes in second,\n\t * the cmpxchg() below to update the ip will fail. Then this\n\t * writer will try again. It is possible that index will now\n\t * be greater than nr_records. This is because the writer\n\t * that succeeded has not updated the nr_records yet.\n\t * This writer could keep trying again until the other writer\n\t * updates nr_records. But if the other writer takes an\n\t * interrupt, and that interrupt locks up that CPU, we do\n\t * not want this CPU to lock up due to the recursion protection,\n\t * and have a bug report showing this CPU as the cause of\n\t * locking up the computer. To not lose this record, this\n\t * writer will simply use the next position to update the\n\t * recursed_functions, and it will update the nr_records\n\t * accordingly.\n\t */\n\tif (index < i)\n\t\tindex = i;\n\tif (index >= CONFIG_FTRACE_RECORD_RECURSION_SIZE)\n\t\treturn;\n\n\tfor (i = index - 1; i >= 0; i--) {\n\t\tif (recursed_functions[i].ip == ip) {\n\t\t\tcached_function = ip;\n\t\t\treturn;\n\t\t}\n\t}\n\n\tcached_function = ip;\n\n\t/*\n\t * We only want to add a function if it hasn't been added before.\n\t * Add to the current location before incrementing the count.\n\t * If it fails to add, then increment the index (save in i)\n\t * and try again.\n\t */\n\told = cmpxchg(&recursed_functions[index].ip, 0, ip);\n\tif (old != 0) {\n\t\t/* Did something else already added this for us? */\n\t\tif (old == ip)\n\t\t\treturn;\n\t\t/* Try the next location (use i for the next index) */\n\t\tindex++;\n\t\tgoto again;\n\t}\n\n\trecursed_functions[index].parent_ip = parent_ip;\n\n\t/*\n\t * It's still possible that we could race with the clearing\n\t *    CPU0                                    CPU1\n\t *    ----                                    ----\n\t *                                       ip = func\n\t *  nr_records = -1;\n\t *  recursed_functions[0] = 0;\n\t *                                       i = -1\n\t *                                       if (i < 0)\n\t *  nr_records = 0;\n\t *  (new recursion detected)\n\t *      recursed_functions[0] = func\n\t *                                            cmpxchg(recursed_functions[0],\n\t *                                                    func, 0)\n\t *\n\t * But the worse that could happen is that we get a zero in\n\t * the recursed_functions array, and it's likely that \"func\" will\n\t * be recorded again.\n\t */\n\ti = atomic_read(&nr_records);\n\tsmp_mb__after_atomic();\n\tif (i < 0)\n\t\tcmpxchg(&recursed_functions[index].ip, ip, 0);\n\telse if (i <= index)\n\t\tatomic_cmpxchg(&nr_records, i, index + 1);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <linux/fs.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/seq_file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct recursed_functions recursed_functions[CONFIG_FTRACE_RECORD_RECURSION_SIZE];",
      "static atomic_t nr_records;",
      "static unsigned long cached_function;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_cmpxchg",
          "args": [
            "&nr_records",
            "i",
            "index + 1"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cmpxchg",
          "args": [
            "&recursed_functions[index].ip",
            "ip",
            "0"
          ],
          "line": 112
        },
        "resolved": true,
        "details": {
          "function_name": "rb_time_cmpxchg",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ring_buffer.c",
          "lines": "737-742",
          "snippet": "static bool rb_time_cmpxchg(rb_time_t *t, u64 expect, u64 set)\n{\n\tu64 val;\n\tval = local64_cmpxchg(&t->time, expect, set);\n\treturn val == expect;\n}",
          "includes": [
            "#include <asm/local64.h>",
            "#include <asm/local.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/list.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/delay.h>",
            "#include <linux/mutex.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>\t/* for self test */",
            "#include <linux/hardirq.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/security.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_recursion.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/local64.h>\n#include <asm/local.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/mutex.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\t/* for self test */\n#include <linux/hardirq.h>\n#include <linux/uaccess.h>\n#include <linux/security.h>\n#include <linux/irq_work.h>\n#include <linux/spinlock.h>\n#include <linux/trace_seq.h>\n#include <linux/sched/clock.h>\n#include <linux/trace_clock.h>\n#include <linux/ring_buffer.h>\n#include <linux/trace_events.h>\n#include <linux/trace_recursion.h>\n\nstatic bool rb_time_cmpxchg(rb_time_t *t, u64 expect, u64 set)\n{\n\tu64 val;\n\tval = local64_cmpxchg(&t->time, expect, set);\n\treturn val == expect;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_mb__after_atomic",
          "args": [],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&nr_records"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_mb__after_atomic",
          "args": [],
          "line": 38
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&nr_records"
          ],
          "line": 36
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <linux/fs.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/kallsyms.h>\n#include <linux/seq_file.h>\n\nstatic struct recursed_functions recursed_functions[CONFIG_FTRACE_RECORD_RECURSION_SIZE];\nstatic atomic_t nr_records;\nstatic unsigned long cached_function;\n\nvoid ftrace_record_recursion(unsigned long ip, unsigned long parent_ip)\n{\n\tint index = 0;\n\tint i;\n\tunsigned long old;\n\n again:\n\t/* First check the last one recorded */\n\tif (ip == cached_function)\n\t\treturn;\n\n\ti = atomic_read(&nr_records);\n\t/* nr_records is -1 when clearing records */\n\tsmp_mb__after_atomic();\n\tif (i < 0)\n\t\treturn;\n\n\t/*\n\t * If there's two writers and this writer comes in second,\n\t * the cmpxchg() below to update the ip will fail. Then this\n\t * writer will try again. It is possible that index will now\n\t * be greater than nr_records. This is because the writer\n\t * that succeeded has not updated the nr_records yet.\n\t * This writer could keep trying again until the other writer\n\t * updates nr_records. But if the other writer takes an\n\t * interrupt, and that interrupt locks up that CPU, we do\n\t * not want this CPU to lock up due to the recursion protection,\n\t * and have a bug report showing this CPU as the cause of\n\t * locking up the computer. To not lose this record, this\n\t * writer will simply use the next position to update the\n\t * recursed_functions, and it will update the nr_records\n\t * accordingly.\n\t */\n\tif (index < i)\n\t\tindex = i;\n\tif (index >= CONFIG_FTRACE_RECORD_RECURSION_SIZE)\n\t\treturn;\n\n\tfor (i = index - 1; i >= 0; i--) {\n\t\tif (recursed_functions[i].ip == ip) {\n\t\t\tcached_function = ip;\n\t\t\treturn;\n\t\t}\n\t}\n\n\tcached_function = ip;\n\n\t/*\n\t * We only want to add a function if it hasn't been added before.\n\t * Add to the current location before incrementing the count.\n\t * If it fails to add, then increment the index (save in i)\n\t * and try again.\n\t */\n\told = cmpxchg(&recursed_functions[index].ip, 0, ip);\n\tif (old != 0) {\n\t\t/* Did something else already added this for us? */\n\t\tif (old == ip)\n\t\t\treturn;\n\t\t/* Try the next location (use i for the next index) */\n\t\tindex++;\n\t\tgoto again;\n\t}\n\n\trecursed_functions[index].parent_ip = parent_ip;\n\n\t/*\n\t * It's still possible that we could race with the clearing\n\t *    CPU0                                    CPU1\n\t *    ----                                    ----\n\t *                                       ip = func\n\t *  nr_records = -1;\n\t *  recursed_functions[0] = 0;\n\t *                                       i = -1\n\t *                                       if (i < 0)\n\t *  nr_records = 0;\n\t *  (new recursion detected)\n\t *      recursed_functions[0] = func\n\t *                                            cmpxchg(recursed_functions[0],\n\t *                                                    func, 0)\n\t *\n\t * But the worse that could happen is that we get a zero in\n\t * the recursed_functions array, and it's likely that \"func\" will\n\t * be recorded again.\n\t */\n\ti = atomic_read(&nr_records);\n\tsmp_mb__after_atomic();\n\tif (i < 0)\n\t\tcmpxchg(&recursed_functions[index].ip, ip, 0);\n\telse if (i <= index)\n\t\tatomic_cmpxchg(&nr_records, i, index + 1);\n}"
  }
]