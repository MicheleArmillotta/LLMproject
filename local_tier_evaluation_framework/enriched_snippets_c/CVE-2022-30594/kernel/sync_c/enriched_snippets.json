[
  {
    "function_name": "rcu_sync_dtor",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/sync.c",
    "lines": "189-206",
    "snippet": "void rcu_sync_dtor(struct rcu_sync *rsp)\n{\n\tint gp_state;\n\n\tWARN_ON_ONCE(READ_ONCE(rsp->gp_count));\n\tWARN_ON_ONCE(READ_ONCE(rsp->gp_state) == GP_PASSED);\n\n\tspin_lock_irq(&rsp->rss_lock);\n\tif (rsp->gp_state == GP_REPLAY)\n\t\tWRITE_ONCE(rsp->gp_state, GP_EXIT);\n\tgp_state = rsp->gp_state;\n\tspin_unlock_irq(&rsp->rss_lock);\n\n\tif (gp_state != GP_IDLE) {\n\t\trcu_barrier();\n\t\tWARN_ON_ONCE(rsp->gp_state != GP_IDLE);\n\t}\n}",
    "includes": [
      "#include <linux/sched.h>",
      "#include <linux/rcu_sync.h>"
    ],
    "macros_used": [
      "#define\trss_lock\tgp_wait.lock"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "rsp->gp_state != GP_IDLE"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_barrier",
          "args": [],
          "line": 203
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_barrier_tasks_trace",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tasks.h",
          "lines": "1569-1572",
          "snippet": "void rcu_barrier_tasks_trace(void)\n{\n\trcu_barrier_tasks_generic(&rcu_tasks_trace);\n}",
          "includes": [
            "#include \"rcu_segcblist.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n\nvoid rcu_barrier_tasks_trace(void)\n{\n\trcu_barrier_tasks_generic(&rcu_tasks_trace);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&rsp->rss_lock"
          ],
          "line": 200
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
          "lines": "315-322",
          "snippet": "static inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"../../lib/kstrtox.h\"",
            "#include <linux/security.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/ctype.h>",
            "#include <linux/filter.h>",
            "#include <linux/uidgid.h>",
            "#include <linux/sched.h>",
            "#include <linux/ktime.h>",
            "#include <linux/topology.h>",
            "#include <linux/smp.h>",
            "#include <linux/random.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned long, irqsave_flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_PER_CPU(unsigned long, irqsave_flags);\n\nstatic inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "rsp->gp_state",
            "GP_EXIT"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&rsp->rss_lock"
          ],
          "line": 196
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_spin_lock_irqsave",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
          "lines": "293-300",
          "snippet": "static inline void __bpf_spin_lock_irqsave(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__bpf_spin_lock(lock);\n\t__this_cpu_write(irqsave_flags, flags);\n}",
          "includes": [
            "#include \"../../lib/kstrtox.h\"",
            "#include <linux/security.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/ctype.h>",
            "#include <linux/filter.h>",
            "#include <linux/uidgid.h>",
            "#include <linux/sched.h>",
            "#include <linux/ktime.h>",
            "#include <linux/topology.h>",
            "#include <linux/smp.h>",
            "#include <linux/random.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned long, irqsave_flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_PER_CPU(unsigned long, irqsave_flags);\n\nstatic inline void __bpf_spin_lock_irqsave(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__bpf_spin_lock(lock);\n\t__this_cpu_write(irqsave_flags, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "READ_ONCE(rsp->gp_state) == GP_PASSED"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rsp->gp_state"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "READ_ONCE(rsp->gp_count)"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rsp->gp_count"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sched.h>\n#include <linux/rcu_sync.h>\n\n#define\trss_lock\tgp_wait.lock\n\nvoid rcu_sync_dtor(struct rcu_sync *rsp)\n{\n\tint gp_state;\n\n\tWARN_ON_ONCE(READ_ONCE(rsp->gp_count));\n\tWARN_ON_ONCE(READ_ONCE(rsp->gp_state) == GP_PASSED);\n\n\tspin_lock_irq(&rsp->rss_lock);\n\tif (rsp->gp_state == GP_REPLAY)\n\t\tWRITE_ONCE(rsp->gp_state, GP_EXIT);\n\tgp_state = rsp->gp_state;\n\tspin_unlock_irq(&rsp->rss_lock);\n\n\tif (gp_state != GP_IDLE) {\n\t\trcu_barrier();\n\t\tWARN_ON_ONCE(rsp->gp_state != GP_IDLE);\n\t}\n}"
  },
  {
    "function_name": "rcu_sync_exit",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/sync.c",
    "lines": "168-183",
    "snippet": "void rcu_sync_exit(struct rcu_sync *rsp)\n{\n\tWARN_ON_ONCE(READ_ONCE(rsp->gp_state) == GP_IDLE);\n\tWARN_ON_ONCE(READ_ONCE(rsp->gp_count) == 0);\n\n\tspin_lock_irq(&rsp->rss_lock);\n\tif (!--rsp->gp_count) {\n\t\tif (rsp->gp_state == GP_PASSED) {\n\t\t\tWRITE_ONCE(rsp->gp_state, GP_EXIT);\n\t\t\trcu_sync_call(rsp);\n\t\t} else if (rsp->gp_state == GP_EXIT) {\n\t\t\tWRITE_ONCE(rsp->gp_state, GP_REPLAY);\n\t\t}\n\t}\n\tspin_unlock_irq(&rsp->rss_lock);\n}",
    "includes": [
      "#include <linux/sched.h>",
      "#include <linux/rcu_sync.h>"
    ],
    "macros_used": [
      "#define\trss_lock\tgp_wait.lock"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&rsp->rss_lock"
          ],
          "line": 182
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
          "lines": "315-322",
          "snippet": "static inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"../../lib/kstrtox.h\"",
            "#include <linux/security.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/ctype.h>",
            "#include <linux/filter.h>",
            "#include <linux/uidgid.h>",
            "#include <linux/sched.h>",
            "#include <linux/ktime.h>",
            "#include <linux/topology.h>",
            "#include <linux/smp.h>",
            "#include <linux/random.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned long, irqsave_flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_PER_CPU(unsigned long, irqsave_flags);\n\nstatic inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "rsp->gp_state",
            "GP_REPLAY"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_sync_call",
          "args": [
            "rsp"
          ],
          "line": 177
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_sync_call",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/sync.c",
          "lines": "45-48",
          "snippet": "static void rcu_sync_call(struct rcu_sync *rsp)\n{\n\tcall_rcu(&rsp->cb_head, rcu_sync_func);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/rcu_sync.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/rcu_sync.h>\n\nstatic void rcu_sync_call(struct rcu_sync *rsp)\n{\n\tcall_rcu(&rsp->cb_head, rcu_sync_func);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "rsp->gp_state",
            "GP_EXIT"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&rsp->rss_lock"
          ],
          "line": 173
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_spin_lock_irqsave",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
          "lines": "293-300",
          "snippet": "static inline void __bpf_spin_lock_irqsave(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__bpf_spin_lock(lock);\n\t__this_cpu_write(irqsave_flags, flags);\n}",
          "includes": [
            "#include \"../../lib/kstrtox.h\"",
            "#include <linux/security.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/ctype.h>",
            "#include <linux/filter.h>",
            "#include <linux/uidgid.h>",
            "#include <linux/sched.h>",
            "#include <linux/ktime.h>",
            "#include <linux/topology.h>",
            "#include <linux/smp.h>",
            "#include <linux/random.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned long, irqsave_flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_PER_CPU(unsigned long, irqsave_flags);\n\nstatic inline void __bpf_spin_lock_irqsave(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__bpf_spin_lock(lock);\n\t__this_cpu_write(irqsave_flags, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "READ_ONCE(rsp->gp_count) == 0"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rsp->gp_count"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "READ_ONCE(rsp->gp_state) == GP_IDLE"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rsp->gp_state"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sched.h>\n#include <linux/rcu_sync.h>\n\n#define\trss_lock\tgp_wait.lock\n\nvoid rcu_sync_exit(struct rcu_sync *rsp)\n{\n\tWARN_ON_ONCE(READ_ONCE(rsp->gp_state) == GP_IDLE);\n\tWARN_ON_ONCE(READ_ONCE(rsp->gp_count) == 0);\n\n\tspin_lock_irq(&rsp->rss_lock);\n\tif (!--rsp->gp_count) {\n\t\tif (rsp->gp_state == GP_PASSED) {\n\t\t\tWRITE_ONCE(rsp->gp_state, GP_EXIT);\n\t\t\trcu_sync_call(rsp);\n\t\t} else if (rsp->gp_state == GP_EXIT) {\n\t\t\tWRITE_ONCE(rsp->gp_state, GP_REPLAY);\n\t\t}\n\t}\n\tspin_unlock_irq(&rsp->rss_lock);\n}"
  },
  {
    "function_name": "rcu_sync_enter",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/sync.c",
    "lines": "121-156",
    "snippet": "void rcu_sync_enter(struct rcu_sync *rsp)\n{\n\tint gp_state;\n\n\tspin_lock_irq(&rsp->rss_lock);\n\tgp_state = rsp->gp_state;\n\tif (gp_state == GP_IDLE) {\n\t\tWRITE_ONCE(rsp->gp_state, GP_ENTER);\n\t\tWARN_ON_ONCE(rsp->gp_count);\n\t\t/*\n\t\t * Note that we could simply do rcu_sync_call(rsp) here and\n\t\t * avoid the \"if (gp_state == GP_IDLE)\" block below.\n\t\t *\n\t\t * However, synchronize_rcu() can be faster if rcu_expedited\n\t\t * or rcu_blocking_is_gp() is true.\n\t\t *\n\t\t * Another reason is that we can't wait for rcu callback if\n\t\t * we are called at early boot time but this shouldn't happen.\n\t\t */\n\t}\n\trsp->gp_count++;\n\tspin_unlock_irq(&rsp->rss_lock);\n\n\tif (gp_state == GP_IDLE) {\n\t\t/*\n\t\t * See the comment above, this simply does the \"synchronous\"\n\t\t * call_rcu(rcu_sync_func) which does GP_ENTER -> GP_PASSED.\n\t\t */\n\t\tsynchronize_rcu();\n\t\trcu_sync_func(&rsp->cb_head);\n\t\t/* Not really needed, wait_event() would see GP_PASSED. */\n\t\treturn;\n\t}\n\n\twait_event(rsp->gp_wait, READ_ONCE(rsp->gp_state) >= GP_PASSED);\n}",
    "includes": [
      "#include <linux/sched.h>",
      "#include <linux/rcu_sync.h>"
    ],
    "macros_used": [
      "#define\trss_lock\tgp_wait.lock"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wait_event",
          "args": [
            "rsp->gp_wait",
            "READ_ONCE(rsp->gp_state) >= GP_PASSED"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rsp->gp_state"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_sync_func",
          "args": [
            "&rsp->cb_head"
          ],
          "line": 150
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_sync_func",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/sync.c",
          "lines": "73-104",
          "snippet": "static void rcu_sync_func(struct rcu_head *rhp)\n{\n\tstruct rcu_sync *rsp = container_of(rhp, struct rcu_sync, cb_head);\n\tunsigned long flags;\n\n\tWARN_ON_ONCE(READ_ONCE(rsp->gp_state) == GP_IDLE);\n\tWARN_ON_ONCE(READ_ONCE(rsp->gp_state) == GP_PASSED);\n\n\tspin_lock_irqsave(&rsp->rss_lock, flags);\n\tif (rsp->gp_count) {\n\t\t/*\n\t\t * We're at least a GP after the GP_IDLE->GP_ENTER transition.\n\t\t */\n\t\tWRITE_ONCE(rsp->gp_state, GP_PASSED);\n\t\twake_up_locked(&rsp->gp_wait);\n\t} else if (rsp->gp_state == GP_REPLAY) {\n\t\t/*\n\t\t * A new rcu_sync_exit() has happened; requeue the callback to\n\t\t * catch a later GP.\n\t\t */\n\t\tWRITE_ONCE(rsp->gp_state, GP_EXIT);\n\t\trcu_sync_call(rsp);\n\t} else {\n\t\t/*\n\t\t * We're at least a GP after the last rcu_sync_exit(); everybody\n\t\t * will now have observed the write side critical section.\n\t\t * Let 'em rip!\n\t\t */\n\t\tWRITE_ONCE(rsp->gp_state, GP_IDLE);\n\t}\n\tspin_unlock_irqrestore(&rsp->rss_lock, flags);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/rcu_sync.h>"
          ],
          "macros_used": [
            "#define\trss_lock\tgp_wait.lock"
          ],
          "globals_used": [
            "static void rcu_sync_func(struct rcu_head *rhp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/rcu_sync.h>\n\n#define\trss_lock\tgp_wait.lock\n\nstatic void rcu_sync_func(struct rcu_head *rhp);\n\nstatic void rcu_sync_func(struct rcu_head *rhp)\n{\n\tstruct rcu_sync *rsp = container_of(rhp, struct rcu_sync, cb_head);\n\tunsigned long flags;\n\n\tWARN_ON_ONCE(READ_ONCE(rsp->gp_state) == GP_IDLE);\n\tWARN_ON_ONCE(READ_ONCE(rsp->gp_state) == GP_PASSED);\n\n\tspin_lock_irqsave(&rsp->rss_lock, flags);\n\tif (rsp->gp_count) {\n\t\t/*\n\t\t * We're at least a GP after the GP_IDLE->GP_ENTER transition.\n\t\t */\n\t\tWRITE_ONCE(rsp->gp_state, GP_PASSED);\n\t\twake_up_locked(&rsp->gp_wait);\n\t} else if (rsp->gp_state == GP_REPLAY) {\n\t\t/*\n\t\t * A new rcu_sync_exit() has happened; requeue the callback to\n\t\t * catch a later GP.\n\t\t */\n\t\tWRITE_ONCE(rsp->gp_state, GP_EXIT);\n\t\trcu_sync_call(rsp);\n\t} else {\n\t\t/*\n\t\t * We're at least a GP after the last rcu_sync_exit(); everybody\n\t\t * will now have observed the write side critical section.\n\t\t * Let 'em rip!\n\t\t */\n\t\tWRITE_ONCE(rsp->gp_state, GP_IDLE);\n\t}\n\tspin_unlock_irqrestore(&rsp->rss_lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "synchronize_rcu",
          "args": [],
          "line": 149
        },
        "resolved": true,
        "details": {
          "function_name": "synchronize_rcu_expedited",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_exp.h",
          "lines": "816-865",
          "snippet": "void synchronize_rcu_expedited(void)\n{\n\tbool boottime = (rcu_scheduler_active == RCU_SCHEDULER_INIT);\n\tstruct rcu_exp_work rew;\n\tstruct rcu_node *rnp;\n\tunsigned long s;\n\n\tRCU_LOCKDEP_WARN(lock_is_held(&rcu_bh_lock_map) ||\n\t\t\t lock_is_held(&rcu_lock_map) ||\n\t\t\t lock_is_held(&rcu_sched_lock_map),\n\t\t\t \"Illegal synchronize_rcu_expedited() in RCU read-side critical section\");\n\n\t/* Is the state is such that the call is a grace period? */\n\tif (rcu_blocking_is_gp())\n\t\treturn;\n\n\t/* If expedited grace periods are prohibited, fall back to normal. */\n\tif (rcu_gp_is_normal()) {\n\t\twait_rcu_gp(call_rcu);\n\t\treturn;\n\t}\n\n\t/* Take a snapshot of the sequence number.  */\n\ts = rcu_exp_gp_seq_snap();\n\tif (exp_funnel_lock(s))\n\t\treturn;  /* Someone else did our work for us. */\n\n\t/* Ensure that load happens before action based on it. */\n\tif (unlikely(boottime)) {\n\t\t/* Direct call during scheduler init and early_initcalls(). */\n\t\trcu_exp_sel_wait_wake(s);\n\t} else {\n\t\t/* Marshall arguments & schedule the expedited grace period. */\n\t\trew.rew_s = s;\n\t\tINIT_WORK_ONSTACK(&rew.rew_work, wait_rcu_exp_gp);\n\t\tqueue_work(rcu_gp_wq, &rew.rew_work);\n\t}\n\n\t/* Wait for expedited grace period to complete. */\n\trnp = rcu_get_root();\n\twait_event(rnp->exp_wq[rcu_seq_ctr(s) & 0x3],\n\t\t   sync_exp_work_done(s));\n\tsmp_mb(); /* Workqueue actions happen before return. */\n\n\t/* Let the next expedited grace period start. */\n\tmutex_unlock(&rcu_state.exp_mutex);\n\n\tif (likely(!boottime))\n\t\tdestroy_work_on_stack(&rew.rew_work);\n}",
          "includes": [
            "#include <linux/lockdep.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int rcu_print_task_exp_stall(struct rcu_node *rnp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockdep.h>\n\nstatic int rcu_print_task_exp_stall(struct rcu_node *rnp);\n\nvoid synchronize_rcu_expedited(void)\n{\n\tbool boottime = (rcu_scheduler_active == RCU_SCHEDULER_INIT);\n\tstruct rcu_exp_work rew;\n\tstruct rcu_node *rnp;\n\tunsigned long s;\n\n\tRCU_LOCKDEP_WARN(lock_is_held(&rcu_bh_lock_map) ||\n\t\t\t lock_is_held(&rcu_lock_map) ||\n\t\t\t lock_is_held(&rcu_sched_lock_map),\n\t\t\t \"Illegal synchronize_rcu_expedited() in RCU read-side critical section\");\n\n\t/* Is the state is such that the call is a grace period? */\n\tif (rcu_blocking_is_gp())\n\t\treturn;\n\n\t/* If expedited grace periods are prohibited, fall back to normal. */\n\tif (rcu_gp_is_normal()) {\n\t\twait_rcu_gp(call_rcu);\n\t\treturn;\n\t}\n\n\t/* Take a snapshot of the sequence number.  */\n\ts = rcu_exp_gp_seq_snap();\n\tif (exp_funnel_lock(s))\n\t\treturn;  /* Someone else did our work for us. */\n\n\t/* Ensure that load happens before action based on it. */\n\tif (unlikely(boottime)) {\n\t\t/* Direct call during scheduler init and early_initcalls(). */\n\t\trcu_exp_sel_wait_wake(s);\n\t} else {\n\t\t/* Marshall arguments & schedule the expedited grace period. */\n\t\trew.rew_s = s;\n\t\tINIT_WORK_ONSTACK(&rew.rew_work, wait_rcu_exp_gp);\n\t\tqueue_work(rcu_gp_wq, &rew.rew_work);\n\t}\n\n\t/* Wait for expedited grace period to complete. */\n\trnp = rcu_get_root();\n\twait_event(rnp->exp_wq[rcu_seq_ctr(s) & 0x3],\n\t\t   sync_exp_work_done(s));\n\tsmp_mb(); /* Workqueue actions happen before return. */\n\n\t/* Let the next expedited grace period start. */\n\tmutex_unlock(&rcu_state.exp_mutex);\n\n\tif (likely(!boottime))\n\t\tdestroy_work_on_stack(&rew.rew_work);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&rsp->rss_lock"
          ],
          "line": 142
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
          "lines": "315-322",
          "snippet": "static inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"../../lib/kstrtox.h\"",
            "#include <linux/security.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/ctype.h>",
            "#include <linux/filter.h>",
            "#include <linux/uidgid.h>",
            "#include <linux/sched.h>",
            "#include <linux/ktime.h>",
            "#include <linux/topology.h>",
            "#include <linux/smp.h>",
            "#include <linux/random.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned long, irqsave_flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_PER_CPU(unsigned long, irqsave_flags);\n\nstatic inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "rsp->gp_count"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "rsp->gp_state",
            "GP_ENTER"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&rsp->rss_lock"
          ],
          "line": 125
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_spin_lock_irqsave",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
          "lines": "293-300",
          "snippet": "static inline void __bpf_spin_lock_irqsave(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__bpf_spin_lock(lock);\n\t__this_cpu_write(irqsave_flags, flags);\n}",
          "includes": [
            "#include \"../../lib/kstrtox.h\"",
            "#include <linux/security.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/ctype.h>",
            "#include <linux/filter.h>",
            "#include <linux/uidgid.h>",
            "#include <linux/sched.h>",
            "#include <linux/ktime.h>",
            "#include <linux/topology.h>",
            "#include <linux/smp.h>",
            "#include <linux/random.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned long, irqsave_flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_PER_CPU(unsigned long, irqsave_flags);\n\nstatic inline void __bpf_spin_lock_irqsave(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__bpf_spin_lock(lock);\n\t__this_cpu_write(irqsave_flags, flags);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/sched.h>\n#include <linux/rcu_sync.h>\n\n#define\trss_lock\tgp_wait.lock\n\nvoid rcu_sync_enter(struct rcu_sync *rsp)\n{\n\tint gp_state;\n\n\tspin_lock_irq(&rsp->rss_lock);\n\tgp_state = rsp->gp_state;\n\tif (gp_state == GP_IDLE) {\n\t\tWRITE_ONCE(rsp->gp_state, GP_ENTER);\n\t\tWARN_ON_ONCE(rsp->gp_count);\n\t\t/*\n\t\t * Note that we could simply do rcu_sync_call(rsp) here and\n\t\t * avoid the \"if (gp_state == GP_IDLE)\" block below.\n\t\t *\n\t\t * However, synchronize_rcu() can be faster if rcu_expedited\n\t\t * or rcu_blocking_is_gp() is true.\n\t\t *\n\t\t * Another reason is that we can't wait for rcu callback if\n\t\t * we are called at early boot time but this shouldn't happen.\n\t\t */\n\t}\n\trsp->gp_count++;\n\tspin_unlock_irq(&rsp->rss_lock);\n\n\tif (gp_state == GP_IDLE) {\n\t\t/*\n\t\t * See the comment above, this simply does the \"synchronous\"\n\t\t * call_rcu(rcu_sync_func) which does GP_ENTER -> GP_PASSED.\n\t\t */\n\t\tsynchronize_rcu();\n\t\trcu_sync_func(&rsp->cb_head);\n\t\t/* Not really needed, wait_event() would see GP_PASSED. */\n\t\treturn;\n\t}\n\n\twait_event(rsp->gp_wait, READ_ONCE(rsp->gp_state) >= GP_PASSED);\n}"
  },
  {
    "function_name": "rcu_sync_func",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/sync.c",
    "lines": "73-104",
    "snippet": "static void rcu_sync_func(struct rcu_head *rhp)\n{\n\tstruct rcu_sync *rsp = container_of(rhp, struct rcu_sync, cb_head);\n\tunsigned long flags;\n\n\tWARN_ON_ONCE(READ_ONCE(rsp->gp_state) == GP_IDLE);\n\tWARN_ON_ONCE(READ_ONCE(rsp->gp_state) == GP_PASSED);\n\n\tspin_lock_irqsave(&rsp->rss_lock, flags);\n\tif (rsp->gp_count) {\n\t\t/*\n\t\t * We're at least a GP after the GP_IDLE->GP_ENTER transition.\n\t\t */\n\t\tWRITE_ONCE(rsp->gp_state, GP_PASSED);\n\t\twake_up_locked(&rsp->gp_wait);\n\t} else if (rsp->gp_state == GP_REPLAY) {\n\t\t/*\n\t\t * A new rcu_sync_exit() has happened; requeue the callback to\n\t\t * catch a later GP.\n\t\t */\n\t\tWRITE_ONCE(rsp->gp_state, GP_EXIT);\n\t\trcu_sync_call(rsp);\n\t} else {\n\t\t/*\n\t\t * We're at least a GP after the last rcu_sync_exit(); everybody\n\t\t * will now have observed the write side critical section.\n\t\t * Let 'em rip!\n\t\t */\n\t\tWRITE_ONCE(rsp->gp_state, GP_IDLE);\n\t}\n\tspin_unlock_irqrestore(&rsp->rss_lock, flags);\n}",
    "includes": [
      "#include <linux/sched.h>",
      "#include <linux/rcu_sync.h>"
    ],
    "macros_used": [
      "#define\trss_lock\tgp_wait.lock"
    ],
    "globals_used": [
      "static void rcu_sync_func(struct rcu_head *rhp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&rsp->rss_lock",
            "flags"
          ],
          "line": 103
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "192-195",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "rsp->gp_state",
            "GP_IDLE"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_sync_call",
          "args": [
            "rsp"
          ],
          "line": 94
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_sync_call",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/sync.c",
          "lines": "45-48",
          "snippet": "static void rcu_sync_call(struct rcu_sync *rsp)\n{\n\tcall_rcu(&rsp->cb_head, rcu_sync_func);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/rcu_sync.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/rcu_sync.h>\n\nstatic void rcu_sync_call(struct rcu_sync *rsp)\n{\n\tcall_rcu(&rsp->cb_head, rcu_sync_func);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "rsp->gp_state",
            "GP_EXIT"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wake_up_locked",
          "args": [
            "&rsp->gp_wait"
          ],
          "line": 87
        },
        "resolved": true,
        "details": {
          "function_name": "swake_up_locked",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/swait.c",
          "lines": "22-32",
          "snippet": "void swake_up_locked(struct swait_queue_head *q)\n{\n\tstruct swait_queue *curr;\n\n\tif (list_empty(&q->task_list))\n\t\treturn;\n\n\tcurr = list_first_entry(&q->task_list, typeof(*curr), task_list);\n\twake_up_process(curr->task);\n\tlist_del_init(&curr->task_list);\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nvoid swake_up_locked(struct swait_queue_head *q)\n{\n\tstruct swait_queue *curr;\n\n\tif (list_empty(&q->task_list))\n\t\treturn;\n\n\tcurr = list_first_entry(&q->task_list, typeof(*curr), task_list);\n\twake_up_process(curr->task);\n\tlist_del_init(&curr->task_list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "rsp->gp_state",
            "GP_PASSED"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&rsp->rss_lock",
            "flags"
          ],
          "line": 81
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "383-393",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "READ_ONCE(rsp->gp_state) == GP_PASSED"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rsp->gp_state"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "READ_ONCE(rsp->gp_state) == GP_IDLE"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rsp->gp_state"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "rhp",
            "structrcu_sync",
            "cb_head"
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sched.h>\n#include <linux/rcu_sync.h>\n\n#define\trss_lock\tgp_wait.lock\n\nstatic void rcu_sync_func(struct rcu_head *rhp);\n\nstatic void rcu_sync_func(struct rcu_head *rhp)\n{\n\tstruct rcu_sync *rsp = container_of(rhp, struct rcu_sync, cb_head);\n\tunsigned long flags;\n\n\tWARN_ON_ONCE(READ_ONCE(rsp->gp_state) == GP_IDLE);\n\tWARN_ON_ONCE(READ_ONCE(rsp->gp_state) == GP_PASSED);\n\n\tspin_lock_irqsave(&rsp->rss_lock, flags);\n\tif (rsp->gp_count) {\n\t\t/*\n\t\t * We're at least a GP after the GP_IDLE->GP_ENTER transition.\n\t\t */\n\t\tWRITE_ONCE(rsp->gp_state, GP_PASSED);\n\t\twake_up_locked(&rsp->gp_wait);\n\t} else if (rsp->gp_state == GP_REPLAY) {\n\t\t/*\n\t\t * A new rcu_sync_exit() has happened; requeue the callback to\n\t\t * catch a later GP.\n\t\t */\n\t\tWRITE_ONCE(rsp->gp_state, GP_EXIT);\n\t\trcu_sync_call(rsp);\n\t} else {\n\t\t/*\n\t\t * We're at least a GP after the last rcu_sync_exit(); everybody\n\t\t * will now have observed the write side critical section.\n\t\t * Let 'em rip!\n\t\t */\n\t\tWRITE_ONCE(rsp->gp_state, GP_IDLE);\n\t}\n\tspin_unlock_irqrestore(&rsp->rss_lock, flags);\n}"
  },
  {
    "function_name": "rcu_sync_call",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/sync.c",
    "lines": "45-48",
    "snippet": "static void rcu_sync_call(struct rcu_sync *rsp)\n{\n\tcall_rcu(&rsp->cb_head, rcu_sync_func);\n}",
    "includes": [
      "#include <linux/sched.h>",
      "#include <linux/rcu_sync.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "call_rcu",
          "args": [
            "&rsp->cb_head",
            "rcu_sync_func"
          ],
          "line": 47
        },
        "resolved": true,
        "details": {
          "function_name": "call_rcu_tasks_trace",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tasks.h",
          "lines": "1533-1536",
          "snippet": "void call_rcu_tasks_trace(struct rcu_head *rhp, rcu_callback_t func)\n{\n\tcall_rcu_tasks_generic(rhp, func, &rcu_tasks_trace);\n}",
          "includes": [
            "#include \"rcu_segcblist.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n\nvoid call_rcu_tasks_trace(struct rcu_head *rhp, rcu_callback_t func)\n{\n\tcall_rcu_tasks_generic(rhp, func, &rcu_tasks_trace);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/sched.h>\n#include <linux/rcu_sync.h>\n\nstatic void rcu_sync_call(struct rcu_sync *rsp)\n{\n\tcall_rcu(&rsp->cb_head, rcu_sync_func);\n}"
  },
  {
    "function_name": "rcu_sync_enter_start",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/sync.c",
    "lines": "36-40",
    "snippet": "void rcu_sync_enter_start(struct rcu_sync *rsp)\n{\n\trsp->gp_count++;\n\trsp->gp_state = GP_PASSED;\n}",
    "includes": [
      "#include <linux/sched.h>",
      "#include <linux/rcu_sync.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/sched.h>\n#include <linux/rcu_sync.h>\n\nvoid rcu_sync_enter_start(struct rcu_sync *rsp)\n{\n\trsp->gp_count++;\n\trsp->gp_state = GP_PASSED;\n}"
  },
  {
    "function_name": "rcu_sync_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/sync.c",
    "lines": "21-25",
    "snippet": "void rcu_sync_init(struct rcu_sync *rsp)\n{\n\tmemset(rsp, 0, sizeof(*rsp));\n\tinit_waitqueue_head(&rsp->gp_wait);\n}",
    "includes": [
      "#include <linux/sched.h>",
      "#include <linux/rcu_sync.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "init_waitqueue_head",
          "args": [
            "&rsp->gp_wait"
          ],
          "line": 24
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "rsp",
            "0",
            "sizeof(*rsp)"
          ],
          "line": 23
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sched.h>\n#include <linux/rcu_sync.h>\n\nvoid rcu_sync_init(struct rcu_sync *rsp)\n{\n\tmemset(rsp, 0, sizeof(*rsp));\n\tinit_waitqueue_head(&rsp->gp_wait);\n}"
  }
]