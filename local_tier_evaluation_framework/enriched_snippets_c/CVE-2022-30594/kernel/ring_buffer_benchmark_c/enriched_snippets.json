[
  {
    "function_name": "ring_buffer_benchmark_exit",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ring_buffer_benchmark.c",
    "lines": "484-490",
    "snippet": "static void __exit ring_buffer_benchmark_exit(void)\n{\n\tkthread_stop(producer);\n\tif (consumer)\n\t\tkthread_stop(consumer);\n\tring_buffer_free(buffer);\n}",
    "includes": [
      "#include <asm/local.h>",
      "#include <linux/ktime.h>",
      "#include <linux/module.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/completion.h>",
      "#include <linux/ring_buffer.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct trace_buffer *buffer;",
      "static struct task_struct *producer;",
      "static struct task_struct *consumer;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ring_buffer_free",
          "args": [
            "buffer"
          ],
          "line": 489
        },
        "resolved": true,
        "details": {
          "function_name": "ring_buffer_free",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ring_buffer.c",
          "lines": "1782-1796",
          "snippet": "void\nring_buffer_free(struct trace_buffer *buffer)\n{\n\tint cpu;\n\n\tcpuhp_state_remove_instance(CPUHP_TRACE_RB_PREPARE, &buffer->node);\n\n\tfor_each_buffer_cpu(buffer, cpu)\n\t\trb_free_cpu_buffer(buffer->buffers[cpu]);\n\n\tkfree(buffer->buffers);\n\tfree_cpumask_var(buffer->cpumask);\n\n\tkfree(buffer);\n}",
          "includes": [
            "#include <asm/local64.h>",
            "#include <asm/local.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/list.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/delay.h>",
            "#include <linux/mutex.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>\t/* for self test */",
            "#include <linux/hardirq.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/security.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_recursion.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline u64 rb_time_stamp(struct trace_buffer *buffer);",
            "static __always_inline struct",
            "static noinline struct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/local64.h>\n#include <asm/local.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/mutex.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\t/* for self test */\n#include <linux/hardirq.h>\n#include <linux/uaccess.h>\n#include <linux/security.h>\n#include <linux/irq_work.h>\n#include <linux/spinlock.h>\n#include <linux/trace_seq.h>\n#include <linux/sched/clock.h>\n#include <linux/trace_clock.h>\n#include <linux/ring_buffer.h>\n#include <linux/trace_events.h>\n#include <linux/trace_recursion.h>\n\nstatic inline u64 rb_time_stamp(struct trace_buffer *buffer);\nstatic __always_inline struct;\nstatic noinline struct;\nstatic __always_inline struct;\n\nvoid\nring_buffer_free(struct trace_buffer *buffer)\n{\n\tint cpu;\n\n\tcpuhp_state_remove_instance(CPUHP_TRACE_RB_PREPARE, &buffer->node);\n\n\tfor_each_buffer_cpu(buffer, cpu)\n\t\trb_free_cpu_buffer(buffer->buffers[cpu]);\n\n\tkfree(buffer->buffers);\n\tfree_cpumask_var(buffer->cpumask);\n\n\tkfree(buffer);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kthread_stop",
          "args": [
            "consumer"
          ],
          "line": 488
        },
        "resolved": true,
        "details": {
          "function_name": "kthread_stop",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
          "lines": "697-715",
          "snippet": "int kthread_stop(struct task_struct *k)\n{\n\tstruct kthread *kthread;\n\tint ret;\n\n\ttrace_sched_kthread_stop(k);\n\n\tget_task_struct(k);\n\tkthread = to_kthread(k);\n\tset_bit(KTHREAD_SHOULD_STOP, &kthread->flags);\n\tkthread_unpark(k);\n\twake_up_process(k);\n\twait_for_completion(&kthread->exited);\n\tret = kthread->result;\n\tput_task_struct(k);\n\n\ttrace_sched_kthread_stop_ret(ret);\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/numa.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mm.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nint kthread_stop(struct task_struct *k)\n{\n\tstruct kthread *kthread;\n\tint ret;\n\n\ttrace_sched_kthread_stop(k);\n\n\tget_task_struct(k);\n\tkthread = to_kthread(k);\n\tset_bit(KTHREAD_SHOULD_STOP, &kthread->flags);\n\tkthread_unpark(k);\n\twake_up_process(k);\n\twait_for_completion(&kthread->exited);\n\tret = kthread->result;\n\tput_task_struct(k);\n\n\ttrace_sched_kthread_stop_ret(ret);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/local.h>\n#include <linux/ktime.h>\n#include <linux/module.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/ring_buffer.h>\n\nstatic struct trace_buffer *buffer;\nstatic struct task_struct *producer;\nstatic struct task_struct *consumer;\n\nstatic void __exit ring_buffer_benchmark_exit(void)\n{\n\tkthread_stop(producer);\n\tif (consumer)\n\t\tkthread_stop(consumer);\n\tring_buffer_free(buffer);\n}"
  },
  {
    "function_name": "ring_buffer_benchmark_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ring_buffer_benchmark.c",
    "lines": "430-482",
    "snippet": "static int __init ring_buffer_benchmark_init(void)\n{\n\tint ret;\n\n\t/* make a one meg buffer in overwite mode */\n\tbuffer = ring_buffer_alloc(1000000, RB_FL_OVERWRITE);\n\tif (!buffer)\n\t\treturn -ENOMEM;\n\n\tif (!disable_reader) {\n\t\tconsumer = kthread_create(ring_buffer_consumer_thread,\n\t\t\t\t\t  NULL, \"rb_consumer\");\n\t\tret = PTR_ERR(consumer);\n\t\tif (IS_ERR(consumer))\n\t\t\tgoto out_fail;\n\t}\n\n\tproducer = kthread_run(ring_buffer_producer_thread,\n\t\t\t       NULL, \"rb_producer\");\n\tret = PTR_ERR(producer);\n\n\tif (IS_ERR(producer))\n\t\tgoto out_kill;\n\n\t/*\n\t * Run them as low-prio background tasks by default:\n\t */\n\tif (!disable_reader) {\n\t\tif (consumer_fifo >= 2)\n\t\t\tsched_set_fifo(consumer);\n\t\telse if (consumer_fifo == 1)\n\t\t\tsched_set_fifo_low(consumer);\n\t\telse\n\t\t\tset_user_nice(consumer, consumer_nice);\n\t}\n\n\tif (producer_fifo >= 2)\n\t\tsched_set_fifo(producer);\n\telse if (producer_fifo == 1)\n\t\tsched_set_fifo_low(producer);\n\telse\n\t\tset_user_nice(producer, producer_nice);\n\n\treturn 0;\n\n out_kill:\n\tif (consumer)\n\t\tkthread_stop(consumer);\n\n out_fail:\n\tring_buffer_free(buffer);\n\treturn ret;\n}",
    "includes": [
      "#include <asm/local.h>",
      "#include <linux/ktime.h>",
      "#include <linux/module.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/completion.h>",
      "#include <linux/ring_buffer.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct trace_buffer *buffer;",
      "static struct task_struct *producer;",
      "static struct task_struct *consumer;",
      "static unsigned int disable_reader;",
      "static int producer_nice = MAX_NICE;",
      "static int consumer_nice = MAX_NICE;",
      "static int producer_fifo;",
      "static int consumer_fifo;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ring_buffer_free",
          "args": [
            "buffer"
          ],
          "line": 480
        },
        "resolved": true,
        "details": {
          "function_name": "ring_buffer_free",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ring_buffer.c",
          "lines": "1782-1796",
          "snippet": "void\nring_buffer_free(struct trace_buffer *buffer)\n{\n\tint cpu;\n\n\tcpuhp_state_remove_instance(CPUHP_TRACE_RB_PREPARE, &buffer->node);\n\n\tfor_each_buffer_cpu(buffer, cpu)\n\t\trb_free_cpu_buffer(buffer->buffers[cpu]);\n\n\tkfree(buffer->buffers);\n\tfree_cpumask_var(buffer->cpumask);\n\n\tkfree(buffer);\n}",
          "includes": [
            "#include <asm/local64.h>",
            "#include <asm/local.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/list.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/delay.h>",
            "#include <linux/mutex.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>\t/* for self test */",
            "#include <linux/hardirq.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/security.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_recursion.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline u64 rb_time_stamp(struct trace_buffer *buffer);",
            "static __always_inline struct",
            "static noinline struct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/local64.h>\n#include <asm/local.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/mutex.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\t/* for self test */\n#include <linux/hardirq.h>\n#include <linux/uaccess.h>\n#include <linux/security.h>\n#include <linux/irq_work.h>\n#include <linux/spinlock.h>\n#include <linux/trace_seq.h>\n#include <linux/sched/clock.h>\n#include <linux/trace_clock.h>\n#include <linux/ring_buffer.h>\n#include <linux/trace_events.h>\n#include <linux/trace_recursion.h>\n\nstatic inline u64 rb_time_stamp(struct trace_buffer *buffer);\nstatic __always_inline struct;\nstatic noinline struct;\nstatic __always_inline struct;\n\nvoid\nring_buffer_free(struct trace_buffer *buffer)\n{\n\tint cpu;\n\n\tcpuhp_state_remove_instance(CPUHP_TRACE_RB_PREPARE, &buffer->node);\n\n\tfor_each_buffer_cpu(buffer, cpu)\n\t\trb_free_cpu_buffer(buffer->buffers[cpu]);\n\n\tkfree(buffer->buffers);\n\tfree_cpumask_var(buffer->cpumask);\n\n\tkfree(buffer);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kthread_stop",
          "args": [
            "consumer"
          ],
          "line": 477
        },
        "resolved": true,
        "details": {
          "function_name": "kthread_stop",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
          "lines": "697-715",
          "snippet": "int kthread_stop(struct task_struct *k)\n{\n\tstruct kthread *kthread;\n\tint ret;\n\n\ttrace_sched_kthread_stop(k);\n\n\tget_task_struct(k);\n\tkthread = to_kthread(k);\n\tset_bit(KTHREAD_SHOULD_STOP, &kthread->flags);\n\tkthread_unpark(k);\n\twake_up_process(k);\n\twait_for_completion(&kthread->exited);\n\tret = kthread->result;\n\tput_task_struct(k);\n\n\ttrace_sched_kthread_stop_ret(ret);\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/numa.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mm.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nint kthread_stop(struct task_struct *k)\n{\n\tstruct kthread *kthread;\n\tint ret;\n\n\ttrace_sched_kthread_stop(k);\n\n\tget_task_struct(k);\n\tkthread = to_kthread(k);\n\tset_bit(KTHREAD_SHOULD_STOP, &kthread->flags);\n\tkthread_unpark(k);\n\twake_up_process(k);\n\twait_for_completion(&kthread->exited);\n\tret = kthread->result;\n\tput_task_struct(k);\n\n\ttrace_sched_kthread_stop_ret(ret);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_user_nice",
          "args": [
            "producer",
            "producer_nice"
          ],
          "line": 471
        },
        "resolved": true,
        "details": {
          "function_name": "set_user_nice",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "6891-6942",
          "snippet": "void set_user_nice(struct task_struct *p, long nice)\n{\n\tbool queued, running;\n\tint old_prio;\n\tstruct rq_flags rf;\n\tstruct rq *rq;\n\n\tif (task_nice(p) == nice || nice < MIN_NICE || nice > MAX_NICE)\n\t\treturn;\n\t/*\n\t * We have to be careful, if called from sys_setpriority(),\n\t * the task might be in the middle of scheduling on another CPU.\n\t */\n\trq = task_rq_lock(p, &rf);\n\tupdate_rq_clock(rq);\n\n\t/*\n\t * The RT priorities are set via sched_setscheduler(), but we still\n\t * allow the 'normal' nice value to be set - but as expected\n\t * it won't have any effect on scheduling until the task is\n\t * SCHED_DEADLINE, SCHED_FIFO or SCHED_RR:\n\t */\n\tif (task_has_dl_policy(p) || task_has_rt_policy(p)) {\n\t\tp->static_prio = NICE_TO_PRIO(nice);\n\t\tgoto out_unlock;\n\t}\n\tqueued = task_on_rq_queued(p);\n\trunning = task_current(rq, p);\n\tif (queued)\n\t\tdequeue_task(rq, p, DEQUEUE_SAVE | DEQUEUE_NOCLOCK);\n\tif (running)\n\t\tput_prev_task(rq, p);\n\n\tp->static_prio = NICE_TO_PRIO(nice);\n\tset_load_weight(p, true);\n\told_prio = p->prio;\n\tp->prio = effective_prio(p);\n\n\tif (queued)\n\t\tenqueue_task(rq, p, ENQUEUE_RESTORE | ENQUEUE_NOCLOCK);\n\tif (running)\n\t\tset_next_task(rq, p);\n\n\t/*\n\t * If the task increased its priority or is running and\n\t * lowered its priority, then reschedule its CPU:\n\t */\n\tp->sched_class->prio_changed(rq, p, old_prio);\n\nout_unlock:\n\ttask_rq_unlock(rq, p, &rf);\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\nvoid set_user_nice(struct task_struct *p, long nice)\n{\n\tbool queued, running;\n\tint old_prio;\n\tstruct rq_flags rf;\n\tstruct rq *rq;\n\n\tif (task_nice(p) == nice || nice < MIN_NICE || nice > MAX_NICE)\n\t\treturn;\n\t/*\n\t * We have to be careful, if called from sys_setpriority(),\n\t * the task might be in the middle of scheduling on another CPU.\n\t */\n\trq = task_rq_lock(p, &rf);\n\tupdate_rq_clock(rq);\n\n\t/*\n\t * The RT priorities are set via sched_setscheduler(), but we still\n\t * allow the 'normal' nice value to be set - but as expected\n\t * it won't have any effect on scheduling until the task is\n\t * SCHED_DEADLINE, SCHED_FIFO or SCHED_RR:\n\t */\n\tif (task_has_dl_policy(p) || task_has_rt_policy(p)) {\n\t\tp->static_prio = NICE_TO_PRIO(nice);\n\t\tgoto out_unlock;\n\t}\n\tqueued = task_on_rq_queued(p);\n\trunning = task_current(rq, p);\n\tif (queued)\n\t\tdequeue_task(rq, p, DEQUEUE_SAVE | DEQUEUE_NOCLOCK);\n\tif (running)\n\t\tput_prev_task(rq, p);\n\n\tp->static_prio = NICE_TO_PRIO(nice);\n\tset_load_weight(p, true);\n\told_prio = p->prio;\n\tp->prio = effective_prio(p);\n\n\tif (queued)\n\t\tenqueue_task(rq, p, ENQUEUE_RESTORE | ENQUEUE_NOCLOCK);\n\tif (running)\n\t\tset_next_task(rq, p);\n\n\t/*\n\t * If the task increased its priority or is running and\n\t * lowered its priority, then reschedule its CPU:\n\t */\n\tp->sched_class->prio_changed(rq, p, old_prio);\n\nout_unlock:\n\ttask_rq_unlock(rq, p, &rf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sched_set_fifo_low",
          "args": [
            "producer"
          ],
          "line": 469
        },
        "resolved": true,
        "details": {
          "function_name": "sched_set_fifo_low",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "7599-7603",
          "snippet": "void sched_set_fifo_low(struct task_struct *p)\n{\n\tstruct sched_param sp = { .sched_priority = 1 };\n\tWARN_ON_ONCE(sched_setscheduler_nocheck(p, SCHED_FIFO, &sp) != 0);\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\nvoid sched_set_fifo_low(struct task_struct *p)\n{\n\tstruct sched_param sp = { .sched_priority = 1 };\n\tWARN_ON_ONCE(sched_setscheduler_nocheck(p, SCHED_FIFO, &sp) != 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "producer"
          ],
          "line": 451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "producer"
          ],
          "line": 449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kthread_run",
          "args": [
            "ring_buffer_producer_thread",
            "NULL",
            "\"rb_producer\""
          ],
          "line": 447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "consumer"
          ],
          "line": 443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "consumer"
          ],
          "line": 442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kthread_create",
          "args": [
            "ring_buffer_consumer_thread",
            "NULL",
            "\"rb_consumer\""
          ],
          "line": 440
        },
        "resolved": true,
        "details": {
          "function_name": "kthread_create_worker",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
          "lines": "882-893",
          "snippet": "struct kthread_worker *\nkthread_create_worker(unsigned int flags, const char namefmt[], ...)\n{\n\tstruct kthread_worker *worker;\n\tva_list args;\n\n\tva_start(args, namefmt);\n\tworker = __kthread_create_worker(-1, flags, namefmt, args);\n\tva_end(args);\n\n\treturn worker;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/numa.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mm.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __printf(4, 0)\nstruct task_struct *__kthread_create_on_node(int (*threadfn)(void *data),\n\t\t\t\t\t\t    void *data, int node,\n\t\t\t\t\t\t    const char namefmt[],\n\t\t\t\t\t\t    va_list args)\n{\n\tDECLARE_COMPLETION_ONSTACK(done);\n\tstruct task_struct *task;",
            "static __printf(3, 0) struct kthread_worker *\n__kthread_create_worker(int cpu, unsigned int flags,\n\t\t\tconst char namefmt[], va_list args)\n{\n\tstruct kthread_worker *worker;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nstatic __printf(4, 0)\nstruct task_struct *__kthread_create_on_node(int (*threadfn)(void *data),\n\t\t\t\t\t\t    void *data, int node,\n\t\t\t\t\t\t    const char namefmt[],\n\t\t\t\t\t\t    va_list args)\n{\n\tDECLARE_COMPLETION_ONSTACK(done);\n\tstruct task_struct *task;\nstatic __printf(3, 0) struct kthread_worker *\n__kthread_create_worker(int cpu, unsigned int flags,\n\t\t\tconst char namefmt[], va_list args)\n{\n\tstruct kthread_worker *worker;\n\nstruct kthread_worker *\nkthread_create_worker(unsigned int flags, const char namefmt[], ...)\n{\n\tstruct kthread_worker *worker;\n\tva_list args;\n\n\tva_start(args, namefmt);\n\tworker = __kthread_create_worker(-1, flags, namefmt, args);\n\tva_end(args);\n\n\treturn worker;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ring_buffer_alloc",
          "args": [
            "1000000",
            "RB_FL_OVERWRITE"
          ],
          "line": 435
        },
        "resolved": true,
        "details": {
          "function_name": "ring_buffer_alloc_read_page",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ring_buffer.c",
          "lines": "5404-5440",
          "snippet": "void *ring_buffer_alloc_read_page(struct trace_buffer *buffer, int cpu)\n{\n\tstruct ring_buffer_per_cpu *cpu_buffer;\n\tstruct buffer_data_page *bpage = NULL;\n\tunsigned long flags;\n\tstruct page *page;\n\n\tif (!cpumask_test_cpu(cpu, buffer->cpumask))\n\t\treturn ERR_PTR(-ENODEV);\n\n\tcpu_buffer = buffer->buffers[cpu];\n\tlocal_irq_save(flags);\n\tarch_spin_lock(&cpu_buffer->lock);\n\n\tif (cpu_buffer->free_page) {\n\t\tbpage = cpu_buffer->free_page;\n\t\tcpu_buffer->free_page = NULL;\n\t}\n\n\tarch_spin_unlock(&cpu_buffer->lock);\n\tlocal_irq_restore(flags);\n\n\tif (bpage)\n\t\tgoto out;\n\n\tpage = alloc_pages_node(cpu_to_node(cpu),\n\t\t\t\tGFP_KERNEL | __GFP_NORETRY, 0);\n\tif (!page)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tbpage = page_address(page);\n\n out:\n\trb_init_page(bpage);\n\n\treturn bpage;\n}",
          "includes": [
            "#include <asm/local64.h>",
            "#include <asm/local.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/list.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/delay.h>",
            "#include <linux/mutex.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>\t/* for self test */",
            "#include <linux/hardirq.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/security.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_recursion.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline u64 rb_time_stamp(struct trace_buffer *buffer);",
            "static void rb_reset_cpu(struct ring_buffer_per_cpu *cpu_buffer);",
            "static __always_inline struct",
            "static inline void rb_end_commit(struct ring_buffer_per_cpu *cpu_buffer);",
            "static noinline struct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/local64.h>\n#include <asm/local.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/mutex.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\t/* for self test */\n#include <linux/hardirq.h>\n#include <linux/uaccess.h>\n#include <linux/security.h>\n#include <linux/irq_work.h>\n#include <linux/spinlock.h>\n#include <linux/trace_seq.h>\n#include <linux/sched/clock.h>\n#include <linux/trace_clock.h>\n#include <linux/ring_buffer.h>\n#include <linux/trace_events.h>\n#include <linux/trace_recursion.h>\n\nstatic inline u64 rb_time_stamp(struct trace_buffer *buffer);\nstatic void rb_reset_cpu(struct ring_buffer_per_cpu *cpu_buffer);\nstatic __always_inline struct;\nstatic inline void rb_end_commit(struct ring_buffer_per_cpu *cpu_buffer);\nstatic noinline struct;\nstatic __always_inline struct;\n\nvoid *ring_buffer_alloc_read_page(struct trace_buffer *buffer, int cpu)\n{\n\tstruct ring_buffer_per_cpu *cpu_buffer;\n\tstruct buffer_data_page *bpage = NULL;\n\tunsigned long flags;\n\tstruct page *page;\n\n\tif (!cpumask_test_cpu(cpu, buffer->cpumask))\n\t\treturn ERR_PTR(-ENODEV);\n\n\tcpu_buffer = buffer->buffers[cpu];\n\tlocal_irq_save(flags);\n\tarch_spin_lock(&cpu_buffer->lock);\n\n\tif (cpu_buffer->free_page) {\n\t\tbpage = cpu_buffer->free_page;\n\t\tcpu_buffer->free_page = NULL;\n\t}\n\n\tarch_spin_unlock(&cpu_buffer->lock);\n\tlocal_irq_restore(flags);\n\n\tif (bpage)\n\t\tgoto out;\n\n\tpage = alloc_pages_node(cpu_to_node(cpu),\n\t\t\t\tGFP_KERNEL | __GFP_NORETRY, 0);\n\tif (!page)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tbpage = page_address(page);\n\n out:\n\trb_init_page(bpage);\n\n\treturn bpage;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/local.h>\n#include <linux/ktime.h>\n#include <linux/module.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/ring_buffer.h>\n\nstatic struct trace_buffer *buffer;\nstatic struct task_struct *producer;\nstatic struct task_struct *consumer;\nstatic unsigned int disable_reader;\nstatic int producer_nice = MAX_NICE;\nstatic int consumer_nice = MAX_NICE;\nstatic int producer_fifo;\nstatic int consumer_fifo;\n\nstatic int __init ring_buffer_benchmark_init(void)\n{\n\tint ret;\n\n\t/* make a one meg buffer in overwite mode */\n\tbuffer = ring_buffer_alloc(1000000, RB_FL_OVERWRITE);\n\tif (!buffer)\n\t\treturn -ENOMEM;\n\n\tif (!disable_reader) {\n\t\tconsumer = kthread_create(ring_buffer_consumer_thread,\n\t\t\t\t\t  NULL, \"rb_consumer\");\n\t\tret = PTR_ERR(consumer);\n\t\tif (IS_ERR(consumer))\n\t\t\tgoto out_fail;\n\t}\n\n\tproducer = kthread_run(ring_buffer_producer_thread,\n\t\t\t       NULL, \"rb_producer\");\n\tret = PTR_ERR(producer);\n\n\tif (IS_ERR(producer))\n\t\tgoto out_kill;\n\n\t/*\n\t * Run them as low-prio background tasks by default:\n\t */\n\tif (!disable_reader) {\n\t\tif (consumer_fifo >= 2)\n\t\t\tsched_set_fifo(consumer);\n\t\telse if (consumer_fifo == 1)\n\t\t\tsched_set_fifo_low(consumer);\n\t\telse\n\t\t\tset_user_nice(consumer, consumer_nice);\n\t}\n\n\tif (producer_fifo >= 2)\n\t\tsched_set_fifo(producer);\n\telse if (producer_fifo == 1)\n\t\tsched_set_fifo_low(producer);\n\telse\n\t\tset_user_nice(producer, producer_nice);\n\n\treturn 0;\n\n out_kill:\n\tif (consumer)\n\t\tkthread_stop(consumer);\n\n out_fail:\n\tring_buffer_free(buffer);\n\treturn ret;\n}"
  },
  {
    "function_name": "ring_buffer_producer_thread",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ring_buffer_benchmark.c",
    "lines": "401-428",
    "snippet": "static int ring_buffer_producer_thread(void *arg)\n{\n\twhile (!break_test()) {\n\t\tring_buffer_reset(buffer);\n\n\t\tif (consumer) {\n\t\t\twake_up_process(consumer);\n\t\t\twait_for_completion(&read_start);\n\t\t}\n\n\t\tring_buffer_producer();\n\t\tif (break_test())\n\t\t\tgoto out_kill;\n\n\t\ttrace_printk(\"Sleeping for 10 secs\\n\");\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\tif (break_test())\n\t\t\tgoto out_kill;\n\t\tschedule_timeout(HZ * SLEEP_TIME);\n\t}\n\nout_kill:\n\t__set_current_state(TASK_RUNNING);\n\tif (!kthread_should_stop())\n\t\twait_to_die();\n\n\treturn 0;\n}",
    "includes": [
      "#include <asm/local.h>",
      "#include <linux/ktime.h>",
      "#include <linux/module.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/completion.h>",
      "#include <linux/ring_buffer.h>"
    ],
    "macros_used": [
      "#define SLEEP_TIME\t10"
    ],
    "globals_used": [
      "static DECLARE_COMPLETION(read_start);",
      "static struct trace_buffer *buffer;",
      "static struct task_struct *consumer;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wait_to_die",
          "args": [],
          "line": 425
        },
        "resolved": true,
        "details": {
          "function_name": "wait_to_die",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ring_buffer_benchmark.c",
          "lines": "371-379",
          "snippet": "static void wait_to_die(void)\n{\n\tset_current_state(TASK_INTERRUPTIBLE);\n\twhile (!kthread_should_stop()) {\n\t\tschedule();\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t}\n\t__set_current_state(TASK_RUNNING);\n}",
          "includes": [
            "#include <asm/local.h>",
            "#include <linux/ktime.h>",
            "#include <linux/module.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/local.h>\n#include <linux/ktime.h>\n#include <linux/module.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/ring_buffer.h>\n\nstatic void wait_to_die(void)\n{\n\tset_current_state(TASK_INTERRUPTIBLE);\n\twhile (!kthread_should_stop()) {\n\t\tschedule();\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t}\n\t__set_current_state(TASK_RUNNING);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kthread_should_stop",
          "args": [],
          "line": 424
        },
        "resolved": true,
        "details": {
          "function_name": "kthread_should_stop",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
          "lines": "156-159",
          "snippet": "bool kthread_should_stop(void)\n{\n\treturn test_bit(KTHREAD_SHOULD_STOP, &to_kthread(current)->flags);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/numa.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mm.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nbool kthread_should_stop(void)\n{\n\treturn test_bit(KTHREAD_SHOULD_STOP, &to_kthread(current)->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__set_current_state",
          "args": [
            "TASK_RUNNING"
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schedule_timeout",
          "args": [
            "HZ * SLEEP_TIME"
          ],
          "line": 419
        },
        "resolved": true,
        "details": {
          "function_name": "io_schedule_timeout",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "8396-8406",
          "snippet": "long __sched io_schedule_timeout(long timeout)\n{\n\tint token;\n\tlong ret;\n\n\ttoken = io_schedule_prepare();\n\tret = schedule_timeout(timeout);\n\tio_schedule_finish(token);\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __sched",
            "static void __sched"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic void __sched;\nstatic void __sched;\n\nlong __sched io_schedule_timeout(long timeout)\n{\n\tint token;\n\tlong ret;\n\n\ttoken = io_schedule_prepare();\n\tret = schedule_timeout(timeout);\n\tio_schedule_finish(token);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "break_test",
          "args": [],
          "line": 417
        },
        "resolved": true,
        "details": {
          "function_name": "break_test",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ring_buffer_benchmark.c",
          "lines": "80-83",
          "snippet": "static bool break_test(void)\n{\n\treturn test_error || kthread_should_stop();\n}",
          "includes": [
            "#include <asm/local.h>",
            "#include <linux/ktime.h>",
            "#include <linux/module.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int test_error;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/local.h>\n#include <linux/ktime.h>\n#include <linux/module.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/ring_buffer.h>\n\nstatic int test_error;\n\nstatic bool break_test(void)\n{\n\treturn test_error || kthread_should_stop();\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_current_state",
          "args": [
            "TASK_INTERRUPTIBLE"
          ],
          "line": 416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_printk",
          "args": [
            "\"Sleeping for 10 secs\\n\""
          ],
          "line": 415
        },
        "resolved": true,
        "details": {
          "function_name": "trace_printk_seq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "9766-9787",
          "snippet": "void\ntrace_printk_seq(struct trace_seq *s)\n{\n\t/* Probably should print a warning here. */\n\tif (s->seq.len >= TRACE_MAX_PRINT)\n\t\ts->seq.len = TRACE_MAX_PRINT;\n\n\t/*\n\t * More paranoid code. Although the buffer size is set to\n\t * PAGE_SIZE, and TRACE_MAX_PRINT is 1000, this is just\n\t * an extra layer of protection.\n\t */\n\tif (WARN_ON_ONCE(s->seq.len >= s->seq.size))\n\t\ts->seq.len = s->seq.size - 1;\n\n\t/* should be zero ended, but we are paranoid. */\n\ts->buffer[s->seq.len] = 0;\n\n\tprintk(KERN_TRACE \"%s\", s->buffer);\n\n\ttrace_seq_init(s);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [
            "#define KERN_TRACE\t\tKERN_EMERG",
            "#define TRACE_MAX_PRINT\t\t1000"
          ],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\n#define KERN_TRACE\t\tKERN_EMERG\n#define TRACE_MAX_PRINT\t\t1000\n\nstatic __always_inline struct;\n\nvoid\ntrace_printk_seq(struct trace_seq *s)\n{\n\t/* Probably should print a warning here. */\n\tif (s->seq.len >= TRACE_MAX_PRINT)\n\t\ts->seq.len = TRACE_MAX_PRINT;\n\n\t/*\n\t * More paranoid code. Although the buffer size is set to\n\t * PAGE_SIZE, and TRACE_MAX_PRINT is 1000, this is just\n\t * an extra layer of protection.\n\t */\n\tif (WARN_ON_ONCE(s->seq.len >= s->seq.size))\n\t\ts->seq.len = s->seq.size - 1;\n\n\t/* should be zero ended, but we are paranoid. */\n\ts->buffer[s->seq.len] = 0;\n\n\tprintk(KERN_TRACE \"%s\", s->buffer);\n\n\ttrace_seq_init(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ring_buffer_producer",
          "args": [],
          "line": 411
        },
        "resolved": true,
        "details": {
          "function_name": "ring_buffer_producer",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ring_buffer_benchmark.c",
          "lines": "230-369",
          "snippet": "static void ring_buffer_producer(void)\n{\n\tktime_t start_time, end_time, timeout;\n\tunsigned long long time;\n\tunsigned long long entries;\n\tunsigned long long overruns;\n\tunsigned long missed = 0;\n\tunsigned long hit = 0;\n\tunsigned long avg;\n\tint cnt = 0;\n\n\t/*\n\t * Hammer the buffer for 10 secs (this may\n\t * make the system stall)\n\t */\n\ttrace_printk(\"Starting ring buffer hammer\\n\");\n\tstart_time = ktime_get();\n\ttimeout = ktime_add_ns(start_time, RUN_TIME * NSEC_PER_SEC);\n\tdo {\n\t\tstruct ring_buffer_event *event;\n\t\tint *entry;\n\t\tint i;\n\n\t\tfor (i = 0; i < write_iteration; i++) {\n\t\t\tevent = ring_buffer_lock_reserve(buffer, 10);\n\t\t\tif (!event) {\n\t\t\t\tmissed++;\n\t\t\t} else {\n\t\t\t\thit++;\n\t\t\t\tentry = ring_buffer_event_data(event);\n\t\t\t\t*entry = smp_processor_id();\n\t\t\t\tring_buffer_unlock_commit(buffer, event);\n\t\t\t}\n\t\t}\n\t\tend_time = ktime_get();\n\n\t\tcnt++;\n\t\tif (consumer && !(cnt % wakeup_interval))\n\t\t\twake_up_process(consumer);\n\n#ifndef CONFIG_PREEMPTION\n\t\t/*\n\t\t * If we are a non preempt kernel, the 10 seconds run will\n\t\t * stop everything while it runs. Instead, we will call\n\t\t * cond_resched and also add any time that was lost by a\n\t\t * reschedule.\n\t\t *\n\t\t * Do a cond resched at the same frequency we would wake up\n\t\t * the reader.\n\t\t */\n\t\tif (cnt % wakeup_interval)\n\t\t\tcond_resched();\n#endif\n\t} while (ktime_before(end_time, timeout) && !break_test());\n\ttrace_printk(\"End ring buffer hammer\\n\");\n\n\tif (consumer) {\n\t\t/* Init both completions here to avoid races */\n\t\tinit_completion(&read_start);\n\t\tinit_completion(&read_done);\n\t\t/* the completions must be visible before the finish var */\n\t\tsmp_wmb();\n\t\treader_finish = 1;\n\t\twake_up_process(consumer);\n\t\twait_for_completion(&read_done);\n\t}\n\n\ttime = ktime_us_delta(end_time, start_time);\n\n\tentries = ring_buffer_entries(buffer);\n\toverruns = ring_buffer_overruns(buffer);\n\n\tif (test_error)\n\t\ttrace_printk(\"ERROR!\\n\");\n\n\tif (!disable_reader) {\n\t\tif (consumer_fifo)\n\t\t\ttrace_printk(\"Running Consumer at SCHED_FIFO %s\\n\",\n\t\t\t\t     consumer_fifo == 1 ? \"low\" : \"high\");\n\t\telse\n\t\t\ttrace_printk(\"Running Consumer at nice: %d\\n\",\n\t\t\t\t     consumer_nice);\n\t}\n\tif (producer_fifo)\n\t\ttrace_printk(\"Running Producer at SCHED_FIFO %s\\n\",\n\t\t\t     producer_fifo == 1 ? \"low\" : \"high\");\n\telse\n\t\ttrace_printk(\"Running Producer at nice: %d\\n\",\n\t\t\t     producer_nice);\n\n\t/* Let the user know that the test is running at low priority */\n\tif (!producer_fifo && !consumer_fifo &&\n\t    producer_nice == MAX_NICE && consumer_nice == MAX_NICE)\n\t\ttrace_printk(\"WARNING!!! This test is running at lowest priority.\\n\");\n\n\ttrace_printk(\"Time:     %lld (usecs)\\n\", time);\n\ttrace_printk(\"Overruns: %lld\\n\", overruns);\n\tif (disable_reader)\n\t\ttrace_printk(\"Read:     (reader disabled)\\n\");\n\telse\n\t\ttrace_printk(\"Read:     %ld  (by %s)\\n\", read,\n\t\t\tread_events ? \"events\" : \"pages\");\n\ttrace_printk(\"Entries:  %lld\\n\", entries);\n\ttrace_printk(\"Total:    %lld\\n\", entries + overruns + read);\n\ttrace_printk(\"Missed:   %ld\\n\", missed);\n\ttrace_printk(\"Hit:      %ld\\n\", hit);\n\n\t/* Convert time from usecs to millisecs */\n\tdo_div(time, USEC_PER_MSEC);\n\tif (time)\n\t\thit /= (long)time;\n\telse\n\t\ttrace_printk(\"TIME IS ZERO??\\n\");\n\n\ttrace_printk(\"Entries per millisec: %ld\\n\", hit);\n\n\tif (hit) {\n\t\t/* Calculate the average time in nanosecs */\n\t\tavg = NSEC_PER_MSEC / hit;\n\t\ttrace_printk(\"%ld ns per entry\\n\", avg);\n\t}\n\n\tif (missed) {\n\t\tif (time)\n\t\t\tmissed /= (long)time;\n\n\t\ttrace_printk(\"Total iterations per millisec: %ld\\n\",\n\t\t\t     hit + missed);\n\n\t\t/* it is possible that hit + missed will overflow and be zero */\n\t\tif (!(hit + missed)) {\n\t\t\ttrace_printk(\"hit + missed overflowed and totalled zero!\\n\");\n\t\t\thit--; /* make it non zero */\n\t\t}\n\n\t\t/* Calculate the average time in nanosecs */\n\t\tavg = NSEC_PER_MSEC / (hit + missed);\n\t\ttrace_printk(\"%ld ns per entry\\n\", avg);\n\t}\n}",
          "includes": [
            "#include <asm/local.h>",
            "#include <linux/ktime.h>",
            "#include <linux/module.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [
            "#define RUN_TIME\t10ULL"
          ],
          "globals_used": [
            "static int wakeup_interval = 100;",
            "static int reader_finish;",
            "static DECLARE_COMPLETION(read_start);",
            "static DECLARE_COMPLETION(read_done);",
            "static struct trace_buffer *buffer;",
            "static struct task_struct *consumer;",
            "static unsigned long read;",
            "static unsigned int disable_reader;",
            "static unsigned int write_iteration = 50;",
            "static int producer_nice = MAX_NICE;",
            "static int consumer_nice = MAX_NICE;",
            "static int producer_fifo;",
            "static int consumer_fifo;",
            "static int read_events;",
            "static int test_error;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/local.h>\n#include <linux/ktime.h>\n#include <linux/module.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/ring_buffer.h>\n\n#define RUN_TIME\t10ULL\n\nstatic int wakeup_interval = 100;\nstatic int reader_finish;\nstatic DECLARE_COMPLETION(read_start);\nstatic DECLARE_COMPLETION(read_done);\nstatic struct trace_buffer *buffer;\nstatic struct task_struct *consumer;\nstatic unsigned long read;\nstatic unsigned int disable_reader;\nstatic unsigned int write_iteration = 50;\nstatic int producer_nice = MAX_NICE;\nstatic int consumer_nice = MAX_NICE;\nstatic int producer_fifo;\nstatic int consumer_fifo;\nstatic int read_events;\nstatic int test_error;\n\nstatic void ring_buffer_producer(void)\n{\n\tktime_t start_time, end_time, timeout;\n\tunsigned long long time;\n\tunsigned long long entries;\n\tunsigned long long overruns;\n\tunsigned long missed = 0;\n\tunsigned long hit = 0;\n\tunsigned long avg;\n\tint cnt = 0;\n\n\t/*\n\t * Hammer the buffer for 10 secs (this may\n\t * make the system stall)\n\t */\n\ttrace_printk(\"Starting ring buffer hammer\\n\");\n\tstart_time = ktime_get();\n\ttimeout = ktime_add_ns(start_time, RUN_TIME * NSEC_PER_SEC);\n\tdo {\n\t\tstruct ring_buffer_event *event;\n\t\tint *entry;\n\t\tint i;\n\n\t\tfor (i = 0; i < write_iteration; i++) {\n\t\t\tevent = ring_buffer_lock_reserve(buffer, 10);\n\t\t\tif (!event) {\n\t\t\t\tmissed++;\n\t\t\t} else {\n\t\t\t\thit++;\n\t\t\t\tentry = ring_buffer_event_data(event);\n\t\t\t\t*entry = smp_processor_id();\n\t\t\t\tring_buffer_unlock_commit(buffer, event);\n\t\t\t}\n\t\t}\n\t\tend_time = ktime_get();\n\n\t\tcnt++;\n\t\tif (consumer && !(cnt % wakeup_interval))\n\t\t\twake_up_process(consumer);\n\n#ifndef CONFIG_PREEMPTION\n\t\t/*\n\t\t * If we are a non preempt kernel, the 10 seconds run will\n\t\t * stop everything while it runs. Instead, we will call\n\t\t * cond_resched and also add any time that was lost by a\n\t\t * reschedule.\n\t\t *\n\t\t * Do a cond resched at the same frequency we would wake up\n\t\t * the reader.\n\t\t */\n\t\tif (cnt % wakeup_interval)\n\t\t\tcond_resched();\n#endif\n\t} while (ktime_before(end_time, timeout) && !break_test());\n\ttrace_printk(\"End ring buffer hammer\\n\");\n\n\tif (consumer) {\n\t\t/* Init both completions here to avoid races */\n\t\tinit_completion(&read_start);\n\t\tinit_completion(&read_done);\n\t\t/* the completions must be visible before the finish var */\n\t\tsmp_wmb();\n\t\treader_finish = 1;\n\t\twake_up_process(consumer);\n\t\twait_for_completion(&read_done);\n\t}\n\n\ttime = ktime_us_delta(end_time, start_time);\n\n\tentries = ring_buffer_entries(buffer);\n\toverruns = ring_buffer_overruns(buffer);\n\n\tif (test_error)\n\t\ttrace_printk(\"ERROR!\\n\");\n\n\tif (!disable_reader) {\n\t\tif (consumer_fifo)\n\t\t\ttrace_printk(\"Running Consumer at SCHED_FIFO %s\\n\",\n\t\t\t\t     consumer_fifo == 1 ? \"low\" : \"high\");\n\t\telse\n\t\t\ttrace_printk(\"Running Consumer at nice: %d\\n\",\n\t\t\t\t     consumer_nice);\n\t}\n\tif (producer_fifo)\n\t\ttrace_printk(\"Running Producer at SCHED_FIFO %s\\n\",\n\t\t\t     producer_fifo == 1 ? \"low\" : \"high\");\n\telse\n\t\ttrace_printk(\"Running Producer at nice: %d\\n\",\n\t\t\t     producer_nice);\n\n\t/* Let the user know that the test is running at low priority */\n\tif (!producer_fifo && !consumer_fifo &&\n\t    producer_nice == MAX_NICE && consumer_nice == MAX_NICE)\n\t\ttrace_printk(\"WARNING!!! This test is running at lowest priority.\\n\");\n\n\ttrace_printk(\"Time:     %lld (usecs)\\n\", time);\n\ttrace_printk(\"Overruns: %lld\\n\", overruns);\n\tif (disable_reader)\n\t\ttrace_printk(\"Read:     (reader disabled)\\n\");\n\telse\n\t\ttrace_printk(\"Read:     %ld  (by %s)\\n\", read,\n\t\t\tread_events ? \"events\" : \"pages\");\n\ttrace_printk(\"Entries:  %lld\\n\", entries);\n\ttrace_printk(\"Total:    %lld\\n\", entries + overruns + read);\n\ttrace_printk(\"Missed:   %ld\\n\", missed);\n\ttrace_printk(\"Hit:      %ld\\n\", hit);\n\n\t/* Convert time from usecs to millisecs */\n\tdo_div(time, USEC_PER_MSEC);\n\tif (time)\n\t\thit /= (long)time;\n\telse\n\t\ttrace_printk(\"TIME IS ZERO??\\n\");\n\n\ttrace_printk(\"Entries per millisec: %ld\\n\", hit);\n\n\tif (hit) {\n\t\t/* Calculate the average time in nanosecs */\n\t\tavg = NSEC_PER_MSEC / hit;\n\t\ttrace_printk(\"%ld ns per entry\\n\", avg);\n\t}\n\n\tif (missed) {\n\t\tif (time)\n\t\t\tmissed /= (long)time;\n\n\t\ttrace_printk(\"Total iterations per millisec: %ld\\n\",\n\t\t\t     hit + missed);\n\n\t\t/* it is possible that hit + missed will overflow and be zero */\n\t\tif (!(hit + missed)) {\n\t\t\ttrace_printk(\"hit + missed overflowed and totalled zero!\\n\");\n\t\t\thit--; /* make it non zero */\n\t\t}\n\n\t\t/* Calculate the average time in nanosecs */\n\t\tavg = NSEC_PER_MSEC / (hit + missed);\n\t\ttrace_printk(\"%ld ns per entry\\n\", avg);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_for_completion",
          "args": [
            "&read_start"
          ],
          "line": 408
        },
        "resolved": true,
        "details": {
          "function_name": "try_wait_for_completion",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/completion.c",
          "lines": "282-303",
          "snippet": "bool try_wait_for_completion(struct completion *x)\n{\n\tunsigned long flags;\n\tbool ret = true;\n\n\t/*\n\t * Since x->done will need to be locked only\n\t * in the non-blocking case, we check x->done\n\t * first without taking the lock so we can\n\t * return early in the blocking case.\n\t */\n\tif (!READ_ONCE(x->done))\n\t\treturn false;\n\n\traw_spin_lock_irqsave(&x->wait.lock, flags);\n\tif (!x->done)\n\t\tret = false;\n\telse if (x->done != UINT_MAX)\n\t\tx->done--;\n\traw_spin_unlock_irqrestore(&x->wait.lock, flags);\n\treturn ret;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nbool try_wait_for_completion(struct completion *x)\n{\n\tunsigned long flags;\n\tbool ret = true;\n\n\t/*\n\t * Since x->done will need to be locked only\n\t * in the non-blocking case, we check x->done\n\t * first without taking the lock so we can\n\t * return early in the blocking case.\n\t */\n\tif (!READ_ONCE(x->done))\n\t\treturn false;\n\n\traw_spin_lock_irqsave(&x->wait.lock, flags);\n\tif (!x->done)\n\t\tret = false;\n\telse if (x->done != UINT_MAX)\n\t\tx->done--;\n\traw_spin_unlock_irqrestore(&x->wait.lock, flags);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wake_up_process",
          "args": [
            "consumer"
          ],
          "line": 407
        },
        "resolved": true,
        "details": {
          "function_name": "wake_up_process",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "4215-4218",
          "snippet": "int wake_up_process(struct task_struct *p)\n{\n\treturn try_to_wake_up(p, TASK_NORMAL, 0);\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\nint wake_up_process(struct task_struct *p)\n{\n\treturn try_to_wake_up(p, TASK_NORMAL, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ring_buffer_reset",
          "args": [
            "buffer"
          ],
          "line": 404
        },
        "resolved": true,
        "details": {
          "function_name": "ring_buffer_reset",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ring_buffer.c",
          "lines": "5226-5254",
          "snippet": "void ring_buffer_reset(struct trace_buffer *buffer)\n{\n\tstruct ring_buffer_per_cpu *cpu_buffer;\n\tint cpu;\n\n\t/* prevent another thread from changing buffer sizes */\n\tmutex_lock(&buffer->mutex);\n\n\tfor_each_buffer_cpu(buffer, cpu) {\n\t\tcpu_buffer = buffer->buffers[cpu];\n\n\t\tatomic_inc(&cpu_buffer->resize_disabled);\n\t\tatomic_inc(&cpu_buffer->record_disabled);\n\t}\n\n\t/* Make sure all commits have finished */\n\tsynchronize_rcu();\n\n\tfor_each_buffer_cpu(buffer, cpu) {\n\t\tcpu_buffer = buffer->buffers[cpu];\n\n\t\treset_disabled_cpu_buffer(cpu_buffer);\n\n\t\tatomic_dec(&cpu_buffer->record_disabled);\n\t\tatomic_dec(&cpu_buffer->resize_disabled);\n\t}\n\n\tmutex_unlock(&buffer->mutex);\n}",
          "includes": [
            "#include <asm/local64.h>",
            "#include <asm/local.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/list.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/delay.h>",
            "#include <linux/mutex.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>\t/* for self test */",
            "#include <linux/hardirq.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/security.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_recursion.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline u64 rb_time_stamp(struct trace_buffer *buffer);",
            "static void rb_reset_cpu(struct ring_buffer_per_cpu *cpu_buffer);",
            "static __always_inline struct",
            "static inline void rb_end_commit(struct ring_buffer_per_cpu *cpu_buffer);",
            "static noinline struct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/local64.h>\n#include <asm/local.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/mutex.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\t/* for self test */\n#include <linux/hardirq.h>\n#include <linux/uaccess.h>\n#include <linux/security.h>\n#include <linux/irq_work.h>\n#include <linux/spinlock.h>\n#include <linux/trace_seq.h>\n#include <linux/sched/clock.h>\n#include <linux/trace_clock.h>\n#include <linux/ring_buffer.h>\n#include <linux/trace_events.h>\n#include <linux/trace_recursion.h>\n\nstatic inline u64 rb_time_stamp(struct trace_buffer *buffer);\nstatic void rb_reset_cpu(struct ring_buffer_per_cpu *cpu_buffer);\nstatic __always_inline struct;\nstatic inline void rb_end_commit(struct ring_buffer_per_cpu *cpu_buffer);\nstatic noinline struct;\nstatic __always_inline struct;\n\nvoid ring_buffer_reset(struct trace_buffer *buffer)\n{\n\tstruct ring_buffer_per_cpu *cpu_buffer;\n\tint cpu;\n\n\t/* prevent another thread from changing buffer sizes */\n\tmutex_lock(&buffer->mutex);\n\n\tfor_each_buffer_cpu(buffer, cpu) {\n\t\tcpu_buffer = buffer->buffers[cpu];\n\n\t\tatomic_inc(&cpu_buffer->resize_disabled);\n\t\tatomic_inc(&cpu_buffer->record_disabled);\n\t}\n\n\t/* Make sure all commits have finished */\n\tsynchronize_rcu();\n\n\tfor_each_buffer_cpu(buffer, cpu) {\n\t\tcpu_buffer = buffer->buffers[cpu];\n\n\t\treset_disabled_cpu_buffer(cpu_buffer);\n\n\t\tatomic_dec(&cpu_buffer->record_disabled);\n\t\tatomic_dec(&cpu_buffer->resize_disabled);\n\t}\n\n\tmutex_unlock(&buffer->mutex);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/local.h>\n#include <linux/ktime.h>\n#include <linux/module.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/ring_buffer.h>\n\n#define SLEEP_TIME\t10\n\nstatic DECLARE_COMPLETION(read_start);\nstatic struct trace_buffer *buffer;\nstatic struct task_struct *consumer;\n\nstatic int ring_buffer_producer_thread(void *arg)\n{\n\twhile (!break_test()) {\n\t\tring_buffer_reset(buffer);\n\n\t\tif (consumer) {\n\t\t\twake_up_process(consumer);\n\t\t\twait_for_completion(&read_start);\n\t\t}\n\n\t\tring_buffer_producer();\n\t\tif (break_test())\n\t\t\tgoto out_kill;\n\n\t\ttrace_printk(\"Sleeping for 10 secs\\n\");\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\tif (break_test())\n\t\t\tgoto out_kill;\n\t\tschedule_timeout(HZ * SLEEP_TIME);\n\t}\n\nout_kill:\n\t__set_current_state(TASK_RUNNING);\n\tif (!kthread_should_stop())\n\t\twait_to_die();\n\n\treturn 0;\n}"
  },
  {
    "function_name": "ring_buffer_consumer_thread",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ring_buffer_benchmark.c",
    "lines": "381-399",
    "snippet": "static int ring_buffer_consumer_thread(void *arg)\n{\n\twhile (!break_test()) {\n\t\tcomplete(&read_start);\n\n\t\tring_buffer_consumer();\n\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\tif (break_test())\n\t\t\tbreak;\n\t\tschedule();\n\t}\n\t__set_current_state(TASK_RUNNING);\n\n\tif (!kthread_should_stop())\n\t\twait_to_die();\n\n\treturn 0;\n}",
    "includes": [
      "#include <asm/local.h>",
      "#include <linux/ktime.h>",
      "#include <linux/module.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/completion.h>",
      "#include <linux/ring_buffer.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DECLARE_COMPLETION(read_start);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wait_to_die",
          "args": [],
          "line": 396
        },
        "resolved": true,
        "details": {
          "function_name": "wait_to_die",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ring_buffer_benchmark.c",
          "lines": "371-379",
          "snippet": "static void wait_to_die(void)\n{\n\tset_current_state(TASK_INTERRUPTIBLE);\n\twhile (!kthread_should_stop()) {\n\t\tschedule();\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t}\n\t__set_current_state(TASK_RUNNING);\n}",
          "includes": [
            "#include <asm/local.h>",
            "#include <linux/ktime.h>",
            "#include <linux/module.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/local.h>\n#include <linux/ktime.h>\n#include <linux/module.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/ring_buffer.h>\n\nstatic void wait_to_die(void)\n{\n\tset_current_state(TASK_INTERRUPTIBLE);\n\twhile (!kthread_should_stop()) {\n\t\tschedule();\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t}\n\t__set_current_state(TASK_RUNNING);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kthread_should_stop",
          "args": [],
          "line": 395
        },
        "resolved": true,
        "details": {
          "function_name": "kthread_should_stop",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
          "lines": "156-159",
          "snippet": "bool kthread_should_stop(void)\n{\n\treturn test_bit(KTHREAD_SHOULD_STOP, &to_kthread(current)->flags);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/numa.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mm.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nbool kthread_should_stop(void)\n{\n\treturn test_bit(KTHREAD_SHOULD_STOP, &to_kthread(current)->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__set_current_state",
          "args": [
            "TASK_RUNNING"
          ],
          "line": 393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schedule",
          "args": [],
          "line": 391
        },
        "resolved": true,
        "details": {
          "function_name": "audit_schedule_prune",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_tree.c",
          "lines": "963-966",
          "snippet": "static void audit_schedule_prune(void)\n{\n\twake_up_process(prune_thread);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include \"audit.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct task_struct *prune_thread;",
            "static void audit_schedule_prune(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic struct task_struct *prune_thread;\nstatic void audit_schedule_prune(void);\n\nstatic void audit_schedule_prune(void)\n{\n\twake_up_process(prune_thread);\n}"
        }
      },
      {
        "call_info": {
          "callee": "break_test",
          "args": [],
          "line": 389
        },
        "resolved": true,
        "details": {
          "function_name": "break_test",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ring_buffer_benchmark.c",
          "lines": "80-83",
          "snippet": "static bool break_test(void)\n{\n\treturn test_error || kthread_should_stop();\n}",
          "includes": [
            "#include <asm/local.h>",
            "#include <linux/ktime.h>",
            "#include <linux/module.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int test_error;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/local.h>\n#include <linux/ktime.h>\n#include <linux/module.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/ring_buffer.h>\n\nstatic int test_error;\n\nstatic bool break_test(void)\n{\n\treturn test_error || kthread_should_stop();\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_current_state",
          "args": [
            "TASK_INTERRUPTIBLE"
          ],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ring_buffer_consumer",
          "args": [],
          "line": 386
        },
        "resolved": true,
        "details": {
          "function_name": "ring_buffer_consumer",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ring_buffer_benchmark.c",
          "lines": "182-228",
          "snippet": "static void ring_buffer_consumer(void)\n{\n\t/* toggle between reading pages and events */\n\tread_events ^= 1;\n\n\tread = 0;\n\t/*\n\t * Continue running until the producer specifically asks to stop\n\t * and is ready for the completion.\n\t */\n\twhile (!READ_ONCE(reader_finish)) {\n\t\tint found = 1;\n\n\t\twhile (found && !test_error) {\n\t\t\tint cpu;\n\n\t\t\tfound = 0;\n\t\t\tfor_each_online_cpu(cpu) {\n\t\t\t\tenum event_status stat;\n\n\t\t\t\tif (read_events)\n\t\t\t\t\tstat = read_event(cpu);\n\t\t\t\telse\n\t\t\t\t\tstat = read_page(cpu);\n\n\t\t\t\tif (test_error)\n\t\t\t\t\tbreak;\n\n\t\t\t\tif (stat == EVENT_FOUND)\n\t\t\t\t\tfound = 1;\n\n\t\t\t}\n\t\t}\n\n\t\t/* Wait till the producer wakes us up when there is more data\n\t\t * available or when the producer wants us to finish reading.\n\t\t */\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\tif (reader_finish)\n\t\t\tbreak;\n\n\t\tschedule();\n\t}\n\t__set_current_state(TASK_RUNNING);\n\treader_finish = 0;\n\tcomplete(&read_done);\n}",
          "includes": [
            "#include <asm/local.h>",
            "#include <linux/ktime.h>",
            "#include <linux/module.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int reader_finish;",
            "static DECLARE_COMPLETION(read_done);",
            "static struct task_struct *producer;",
            "static unsigned long read;",
            "static int read_events;",
            "static int test_error;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/local.h>\n#include <linux/ktime.h>\n#include <linux/module.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/ring_buffer.h>\n\nstatic int reader_finish;\nstatic DECLARE_COMPLETION(read_done);\nstatic struct task_struct *producer;\nstatic unsigned long read;\nstatic int read_events;\nstatic int test_error;\n\nstatic void ring_buffer_consumer(void)\n{\n\t/* toggle between reading pages and events */\n\tread_events ^= 1;\n\n\tread = 0;\n\t/*\n\t * Continue running until the producer specifically asks to stop\n\t * and is ready for the completion.\n\t */\n\twhile (!READ_ONCE(reader_finish)) {\n\t\tint found = 1;\n\n\t\twhile (found && !test_error) {\n\t\t\tint cpu;\n\n\t\t\tfound = 0;\n\t\t\tfor_each_online_cpu(cpu) {\n\t\t\t\tenum event_status stat;\n\n\t\t\t\tif (read_events)\n\t\t\t\t\tstat = read_event(cpu);\n\t\t\t\telse\n\t\t\t\t\tstat = read_page(cpu);\n\n\t\t\t\tif (test_error)\n\t\t\t\t\tbreak;\n\n\t\t\t\tif (stat == EVENT_FOUND)\n\t\t\t\t\tfound = 1;\n\n\t\t\t}\n\t\t}\n\n\t\t/* Wait till the producer wakes us up when there is more data\n\t\t * available or when the producer wants us to finish reading.\n\t\t */\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\tif (reader_finish)\n\t\t\tbreak;\n\n\t\tschedule();\n\t}\n\t__set_current_state(TASK_RUNNING);\n\treader_finish = 0;\n\tcomplete(&read_done);\n}"
        }
      },
      {
        "call_info": {
          "callee": "complete",
          "args": [
            "&read_start"
          ],
          "line": 384
        },
        "resolved": true,
        "details": {
          "function_name": "complete_vfork_done",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/fork.c",
          "lines": "1334-1345",
          "snippet": "static void complete_vfork_done(struct task_struct *tsk)\n{\n\tstruct completion *vfork;\n\n\ttask_lock(tsk);\n\tvfork = tsk->vfork_done;\n\tif (likely(vfork)) {\n\t\ttsk->vfork_done = NULL;\n\t\tcomplete(vfork);\n\t}\n\ttask_unlock(tsk);\n}",
          "includes": [
            "#include <linux/init_task.h>",
            "#include <trace/events/task.h>",
            "#include <trace/events/sched.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <linux/bpf.h>",
            "#include <linux/io_uring.h>",
            "#include <linux/scs.h>",
            "#include <linux/kasan.h>",
            "#include <linux/stackleak.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/kcov.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/compiler.h>",
            "#include <linux/aio.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/oom.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/magic.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/tty.h>",
            "#include <linux/random.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/acct.h>",
            "#include <linux/ksm.h>",
            "#include <linux/rmap.h>",
            "#include <linux/profile.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/kthread.h>",
            "#include <linux/compat.h>",
            "#include <linux/futex.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mman.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/sem.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>",
            "#include <linux/unistd.h>",
            "#include <linux/init.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/anon_inodes.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __latent_entropy struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/init_task.h>\n#include <trace/events/task.h>\n#include <trace/events/sched.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <linux/bpf.h>\n#include <linux/io_uring.h>\n#include <linux/scs.h>\n#include <linux/kasan.h>\n#include <linux/stackleak.h>\n#include <linux/thread_info.h>\n#include <linux/livepatch.h>\n#include <linux/kcov.h>\n#include <linux/sysctl.h>\n#include <linux/compiler.h>\n#include <linux/aio.h>\n#include <linux/uprobes.h>\n#include <linux/signalfd.h>\n#include <linux/khugepaged.h>\n#include <linux/oom.h>\n#include <linux/user-return-notifier.h>\n#include <linux/posix-timers.h>\n#include <linux/perf_event.h>\n#include <linux/magic.h>\n#include <linux/fs_struct.h>\n#include <linux/tty.h>\n#include <linux/random.h>\n#include <linux/taskstats_kern.h>\n#include <linux/delayacct.h>\n#include <linux/freezer.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/acct.h>\n#include <linux/ksm.h>\n#include <linux/rmap.h>\n#include <linux/profile.h>\n#include <linux/proc_fs.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/ptrace.h>\n#include <linux/rcupdate.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/kthread.h>\n#include <linux/compat.h>\n#include <linux/futex.h>\n#include <linux/jiffies.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/seccomp.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/cgroup.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/nsproxy.h>\n#include <linux/vmacache.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mman.h>\n#include <linux/binfmts.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/sem.h>\n#include <linux/mempolicy.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/unistd.h>\n#include <linux/init.h>\n#include <linux/rtmutex.h>\n#include <linux/seq_file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/user.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/anon_inodes.h>\n\nstatic __latent_entropy struct;\n\nstatic void complete_vfork_done(struct task_struct *tsk)\n{\n\tstruct completion *vfork;\n\n\ttask_lock(tsk);\n\tvfork = tsk->vfork_done;\n\tif (likely(vfork)) {\n\t\ttsk->vfork_done = NULL;\n\t\tcomplete(vfork);\n\t}\n\ttask_unlock(tsk);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/local.h>\n#include <linux/ktime.h>\n#include <linux/module.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/ring_buffer.h>\n\nstatic DECLARE_COMPLETION(read_start);\n\nstatic int ring_buffer_consumer_thread(void *arg)\n{\n\twhile (!break_test()) {\n\t\tcomplete(&read_start);\n\n\t\tring_buffer_consumer();\n\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\tif (break_test())\n\t\t\tbreak;\n\t\tschedule();\n\t}\n\t__set_current_state(TASK_RUNNING);\n\n\tif (!kthread_should_stop())\n\t\twait_to_die();\n\n\treturn 0;\n}"
  },
  {
    "function_name": "wait_to_die",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ring_buffer_benchmark.c",
    "lines": "371-379",
    "snippet": "static void wait_to_die(void)\n{\n\tset_current_state(TASK_INTERRUPTIBLE);\n\twhile (!kthread_should_stop()) {\n\t\tschedule();\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t}\n\t__set_current_state(TASK_RUNNING);\n}",
    "includes": [
      "#include <asm/local.h>",
      "#include <linux/ktime.h>",
      "#include <linux/module.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/completion.h>",
      "#include <linux/ring_buffer.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__set_current_state",
          "args": [
            "TASK_RUNNING"
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_current_state",
          "args": [
            "TASK_INTERRUPTIBLE"
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schedule",
          "args": [],
          "line": 375
        },
        "resolved": true,
        "details": {
          "function_name": "audit_schedule_prune",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_tree.c",
          "lines": "963-966",
          "snippet": "static void audit_schedule_prune(void)\n{\n\twake_up_process(prune_thread);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include \"audit.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct task_struct *prune_thread;",
            "static void audit_schedule_prune(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic struct task_struct *prune_thread;\nstatic void audit_schedule_prune(void);\n\nstatic void audit_schedule_prune(void)\n{\n\twake_up_process(prune_thread);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kthread_should_stop",
          "args": [],
          "line": 374
        },
        "resolved": true,
        "details": {
          "function_name": "kthread_should_stop",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
          "lines": "156-159",
          "snippet": "bool kthread_should_stop(void)\n{\n\treturn test_bit(KTHREAD_SHOULD_STOP, &to_kthread(current)->flags);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/numa.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mm.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nbool kthread_should_stop(void)\n{\n\treturn test_bit(KTHREAD_SHOULD_STOP, &to_kthread(current)->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_current_state",
          "args": [
            "TASK_INTERRUPTIBLE"
          ],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/local.h>\n#include <linux/ktime.h>\n#include <linux/module.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/ring_buffer.h>\n\nstatic void wait_to_die(void)\n{\n\tset_current_state(TASK_INTERRUPTIBLE);\n\twhile (!kthread_should_stop()) {\n\t\tschedule();\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t}\n\t__set_current_state(TASK_RUNNING);\n}"
  },
  {
    "function_name": "ring_buffer_producer",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ring_buffer_benchmark.c",
    "lines": "230-369",
    "snippet": "static void ring_buffer_producer(void)\n{\n\tktime_t start_time, end_time, timeout;\n\tunsigned long long time;\n\tunsigned long long entries;\n\tunsigned long long overruns;\n\tunsigned long missed = 0;\n\tunsigned long hit = 0;\n\tunsigned long avg;\n\tint cnt = 0;\n\n\t/*\n\t * Hammer the buffer for 10 secs (this may\n\t * make the system stall)\n\t */\n\ttrace_printk(\"Starting ring buffer hammer\\n\");\n\tstart_time = ktime_get();\n\ttimeout = ktime_add_ns(start_time, RUN_TIME * NSEC_PER_SEC);\n\tdo {\n\t\tstruct ring_buffer_event *event;\n\t\tint *entry;\n\t\tint i;\n\n\t\tfor (i = 0; i < write_iteration; i++) {\n\t\t\tevent = ring_buffer_lock_reserve(buffer, 10);\n\t\t\tif (!event) {\n\t\t\t\tmissed++;\n\t\t\t} else {\n\t\t\t\thit++;\n\t\t\t\tentry = ring_buffer_event_data(event);\n\t\t\t\t*entry = smp_processor_id();\n\t\t\t\tring_buffer_unlock_commit(buffer, event);\n\t\t\t}\n\t\t}\n\t\tend_time = ktime_get();\n\n\t\tcnt++;\n\t\tif (consumer && !(cnt % wakeup_interval))\n\t\t\twake_up_process(consumer);\n\n#ifndef CONFIG_PREEMPTION\n\t\t/*\n\t\t * If we are a non preempt kernel, the 10 seconds run will\n\t\t * stop everything while it runs. Instead, we will call\n\t\t * cond_resched and also add any time that was lost by a\n\t\t * reschedule.\n\t\t *\n\t\t * Do a cond resched at the same frequency we would wake up\n\t\t * the reader.\n\t\t */\n\t\tif (cnt % wakeup_interval)\n\t\t\tcond_resched();\n#endif\n\t} while (ktime_before(end_time, timeout) && !break_test());\n\ttrace_printk(\"End ring buffer hammer\\n\");\n\n\tif (consumer) {\n\t\t/* Init both completions here to avoid races */\n\t\tinit_completion(&read_start);\n\t\tinit_completion(&read_done);\n\t\t/* the completions must be visible before the finish var */\n\t\tsmp_wmb();\n\t\treader_finish = 1;\n\t\twake_up_process(consumer);\n\t\twait_for_completion(&read_done);\n\t}\n\n\ttime = ktime_us_delta(end_time, start_time);\n\n\tentries = ring_buffer_entries(buffer);\n\toverruns = ring_buffer_overruns(buffer);\n\n\tif (test_error)\n\t\ttrace_printk(\"ERROR!\\n\");\n\n\tif (!disable_reader) {\n\t\tif (consumer_fifo)\n\t\t\ttrace_printk(\"Running Consumer at SCHED_FIFO %s\\n\",\n\t\t\t\t     consumer_fifo == 1 ? \"low\" : \"high\");\n\t\telse\n\t\t\ttrace_printk(\"Running Consumer at nice: %d\\n\",\n\t\t\t\t     consumer_nice);\n\t}\n\tif (producer_fifo)\n\t\ttrace_printk(\"Running Producer at SCHED_FIFO %s\\n\",\n\t\t\t     producer_fifo == 1 ? \"low\" : \"high\");\n\telse\n\t\ttrace_printk(\"Running Producer at nice: %d\\n\",\n\t\t\t     producer_nice);\n\n\t/* Let the user know that the test is running at low priority */\n\tif (!producer_fifo && !consumer_fifo &&\n\t    producer_nice == MAX_NICE && consumer_nice == MAX_NICE)\n\t\ttrace_printk(\"WARNING!!! This test is running at lowest priority.\\n\");\n\n\ttrace_printk(\"Time:     %lld (usecs)\\n\", time);\n\ttrace_printk(\"Overruns: %lld\\n\", overruns);\n\tif (disable_reader)\n\t\ttrace_printk(\"Read:     (reader disabled)\\n\");\n\telse\n\t\ttrace_printk(\"Read:     %ld  (by %s)\\n\", read,\n\t\t\tread_events ? \"events\" : \"pages\");\n\ttrace_printk(\"Entries:  %lld\\n\", entries);\n\ttrace_printk(\"Total:    %lld\\n\", entries + overruns + read);\n\ttrace_printk(\"Missed:   %ld\\n\", missed);\n\ttrace_printk(\"Hit:      %ld\\n\", hit);\n\n\t/* Convert time from usecs to millisecs */\n\tdo_div(time, USEC_PER_MSEC);\n\tif (time)\n\t\thit /= (long)time;\n\telse\n\t\ttrace_printk(\"TIME IS ZERO??\\n\");\n\n\ttrace_printk(\"Entries per millisec: %ld\\n\", hit);\n\n\tif (hit) {\n\t\t/* Calculate the average time in nanosecs */\n\t\tavg = NSEC_PER_MSEC / hit;\n\t\ttrace_printk(\"%ld ns per entry\\n\", avg);\n\t}\n\n\tif (missed) {\n\t\tif (time)\n\t\t\tmissed /= (long)time;\n\n\t\ttrace_printk(\"Total iterations per millisec: %ld\\n\",\n\t\t\t     hit + missed);\n\n\t\t/* it is possible that hit + missed will overflow and be zero */\n\t\tif (!(hit + missed)) {\n\t\t\ttrace_printk(\"hit + missed overflowed and totalled zero!\\n\");\n\t\t\thit--; /* make it non zero */\n\t\t}\n\n\t\t/* Calculate the average time in nanosecs */\n\t\tavg = NSEC_PER_MSEC / (hit + missed);\n\t\ttrace_printk(\"%ld ns per entry\\n\", avg);\n\t}\n}",
    "includes": [
      "#include <asm/local.h>",
      "#include <linux/ktime.h>",
      "#include <linux/module.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/completion.h>",
      "#include <linux/ring_buffer.h>"
    ],
    "macros_used": [
      "#define RUN_TIME\t10ULL"
    ],
    "globals_used": [
      "static int wakeup_interval = 100;",
      "static int reader_finish;",
      "static DECLARE_COMPLETION(read_start);",
      "static DECLARE_COMPLETION(read_done);",
      "static struct trace_buffer *buffer;",
      "static struct task_struct *consumer;",
      "static unsigned long read;",
      "static unsigned int disable_reader;",
      "static unsigned int write_iteration = 50;",
      "static int producer_nice = MAX_NICE;",
      "static int consumer_nice = MAX_NICE;",
      "static int producer_fifo;",
      "static int consumer_fifo;",
      "static int read_events;",
      "static int test_error;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_printk",
          "args": [
            "\"%ld ns per entry\\n\"",
            "avg"
          ],
          "line": 367
        },
        "resolved": true,
        "details": {
          "function_name": "mmio_trace_printk",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_mmiotrace.c",
          "lines": "359-362",
          "snippet": "int mmio_trace_printk(const char *fmt, va_list args)\n{\n\treturn trace_vprintk(0, fmt, args);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/atomic.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/pci.h>",
            "#include <linux/mmiotrace.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/atomic.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/pci.h>\n#include <linux/mmiotrace.h>\n#include <linux/kernel.h>\n\nint mmio_trace_printk(const char *fmt, va_list args)\n{\n\treturn trace_vprintk(0, fmt, args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_printk",
          "args": [
            "\"hit + missed overflowed and totalled zero!\\n\""
          ],
          "line": 361
        },
        "resolved": true,
        "details": {
          "function_name": "trace_printk_seq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "9766-9787",
          "snippet": "void\ntrace_printk_seq(struct trace_seq *s)\n{\n\t/* Probably should print a warning here. */\n\tif (s->seq.len >= TRACE_MAX_PRINT)\n\t\ts->seq.len = TRACE_MAX_PRINT;\n\n\t/*\n\t * More paranoid code. Although the buffer size is set to\n\t * PAGE_SIZE, and TRACE_MAX_PRINT is 1000, this is just\n\t * an extra layer of protection.\n\t */\n\tif (WARN_ON_ONCE(s->seq.len >= s->seq.size))\n\t\ts->seq.len = s->seq.size - 1;\n\n\t/* should be zero ended, but we are paranoid. */\n\ts->buffer[s->seq.len] = 0;\n\n\tprintk(KERN_TRACE \"%s\", s->buffer);\n\n\ttrace_seq_init(s);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [
            "#define KERN_TRACE\t\tKERN_EMERG",
            "#define TRACE_MAX_PRINT\t\t1000"
          ],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\n#define KERN_TRACE\t\tKERN_EMERG\n#define TRACE_MAX_PRINT\t\t1000\n\nstatic __always_inline struct;\n\nvoid\ntrace_printk_seq(struct trace_seq *s)\n{\n\t/* Probably should print a warning here. */\n\tif (s->seq.len >= TRACE_MAX_PRINT)\n\t\ts->seq.len = TRACE_MAX_PRINT;\n\n\t/*\n\t * More paranoid code. Although the buffer size is set to\n\t * PAGE_SIZE, and TRACE_MAX_PRINT is 1000, this is just\n\t * an extra layer of protection.\n\t */\n\tif (WARN_ON_ONCE(s->seq.len >= s->seq.size))\n\t\ts->seq.len = s->seq.size - 1;\n\n\t/* should be zero ended, but we are paranoid. */\n\ts->buffer[s->seq.len] = 0;\n\n\tprintk(KERN_TRACE \"%s\", s->buffer);\n\n\ttrace_seq_init(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_div",
          "args": [
            "time",
            "USEC_PER_MSEC"
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_printk",
          "args": [
            "\"Read:     %ld  (by %s)\\n\"",
            "read",
            "read_events ? \"events\" : \"pages\""
          ],
          "line": 330
        },
        "resolved": true,
        "details": {
          "function_name": "__trace_printk",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_printk.c",
          "lines": "230-242",
          "snippet": "int __trace_printk(unsigned long ip, const char *fmt, ...)\n{\n\tint ret;\n\tva_list ap;\n\n\tif (!trace_printk_enabled)\n\t\treturn 0;\n\n\tva_start(ap, fmt);\n\tret = trace_vprintk(ip, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/string.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/security.h>",
            "#include <linux/seq_file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/string.h>\n#include <linux/ftrace.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n\nint __trace_printk(unsigned long ip, const char *fmt, ...)\n{\n\tint ret;\n\tva_list ap;\n\n\tif (!trace_printk_enabled)\n\t\treturn 0;\n\n\tva_start(ap, fmt);\n\tret = trace_vprintk(ip, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ring_buffer_overruns",
          "args": [
            "buffer"
          ],
          "line": 300
        },
        "resolved": true,
        "details": {
          "function_name": "ring_buffer_overruns",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ring_buffer.c",
          "lines": "4245-4258",
          "snippet": "unsigned long ring_buffer_overruns(struct trace_buffer *buffer)\n{\n\tstruct ring_buffer_per_cpu *cpu_buffer;\n\tunsigned long overruns = 0;\n\tint cpu;\n\n\t/* if you care about this being correct, lock the buffer */\n\tfor_each_buffer_cpu(buffer, cpu) {\n\t\tcpu_buffer = buffer->buffers[cpu];\n\t\toverruns += local_read(&cpu_buffer->overrun);\n\t}\n\n\treturn overruns;\n}",
          "includes": [
            "#include <asm/local64.h>",
            "#include <asm/local.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/list.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/delay.h>",
            "#include <linux/mutex.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>\t/* for self test */",
            "#include <linux/hardirq.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/security.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_recursion.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline u64 rb_time_stamp(struct trace_buffer *buffer);",
            "static void rb_reset_cpu(struct ring_buffer_per_cpu *cpu_buffer);",
            "static __always_inline struct",
            "static inline void rb_end_commit(struct ring_buffer_per_cpu *cpu_buffer);",
            "static noinline struct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/local64.h>\n#include <asm/local.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/mutex.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\t/* for self test */\n#include <linux/hardirq.h>\n#include <linux/uaccess.h>\n#include <linux/security.h>\n#include <linux/irq_work.h>\n#include <linux/spinlock.h>\n#include <linux/trace_seq.h>\n#include <linux/sched/clock.h>\n#include <linux/trace_clock.h>\n#include <linux/ring_buffer.h>\n#include <linux/trace_events.h>\n#include <linux/trace_recursion.h>\n\nstatic inline u64 rb_time_stamp(struct trace_buffer *buffer);\nstatic void rb_reset_cpu(struct ring_buffer_per_cpu *cpu_buffer);\nstatic __always_inline struct;\nstatic inline void rb_end_commit(struct ring_buffer_per_cpu *cpu_buffer);\nstatic noinline struct;\nstatic __always_inline struct;\n\nunsigned long ring_buffer_overruns(struct trace_buffer *buffer)\n{\n\tstruct ring_buffer_per_cpu *cpu_buffer;\n\tunsigned long overruns = 0;\n\tint cpu;\n\n\t/* if you care about this being correct, lock the buffer */\n\tfor_each_buffer_cpu(buffer, cpu) {\n\t\tcpu_buffer = buffer->buffers[cpu];\n\t\toverruns += local_read(&cpu_buffer->overrun);\n\t}\n\n\treturn overruns;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ring_buffer_entries",
          "args": [
            "buffer"
          ],
          "line": 299
        },
        "resolved": true,
        "details": {
          "function_name": "ring_buffer_entries",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ring_buffer.c",
          "lines": "4222-4235",
          "snippet": "unsigned long ring_buffer_entries(struct trace_buffer *buffer)\n{\n\tstruct ring_buffer_per_cpu *cpu_buffer;\n\tunsigned long entries = 0;\n\tint cpu;\n\n\t/* if you care about this being correct, lock the buffer */\n\tfor_each_buffer_cpu(buffer, cpu) {\n\t\tcpu_buffer = buffer->buffers[cpu];\n\t\tentries += rb_num_of_entries(cpu_buffer);\n\t}\n\n\treturn entries;\n}",
          "includes": [
            "#include <asm/local64.h>",
            "#include <asm/local.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/list.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/delay.h>",
            "#include <linux/mutex.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>\t/* for self test */",
            "#include <linux/hardirq.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/security.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_recursion.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline u64 rb_time_stamp(struct trace_buffer *buffer);",
            "static void rb_reset_cpu(struct ring_buffer_per_cpu *cpu_buffer);",
            "static __always_inline struct",
            "static inline void rb_end_commit(struct ring_buffer_per_cpu *cpu_buffer);",
            "static noinline struct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/local64.h>\n#include <asm/local.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/mutex.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\t/* for self test */\n#include <linux/hardirq.h>\n#include <linux/uaccess.h>\n#include <linux/security.h>\n#include <linux/irq_work.h>\n#include <linux/spinlock.h>\n#include <linux/trace_seq.h>\n#include <linux/sched/clock.h>\n#include <linux/trace_clock.h>\n#include <linux/ring_buffer.h>\n#include <linux/trace_events.h>\n#include <linux/trace_recursion.h>\n\nstatic inline u64 rb_time_stamp(struct trace_buffer *buffer);\nstatic void rb_reset_cpu(struct ring_buffer_per_cpu *cpu_buffer);\nstatic __always_inline struct;\nstatic inline void rb_end_commit(struct ring_buffer_per_cpu *cpu_buffer);\nstatic noinline struct;\nstatic __always_inline struct;\n\nunsigned long ring_buffer_entries(struct trace_buffer *buffer)\n{\n\tstruct ring_buffer_per_cpu *cpu_buffer;\n\tunsigned long entries = 0;\n\tint cpu;\n\n\t/* if you care about this being correct, lock the buffer */\n\tfor_each_buffer_cpu(buffer, cpu) {\n\t\tcpu_buffer = buffer->buffers[cpu];\n\t\tentries += rb_num_of_entries(cpu_buffer);\n\t}\n\n\treturn entries;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ktime_us_delta",
          "args": [
            "end_time",
            "start_time"
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_for_completion",
          "args": [
            "&read_done"
          ],
          "line": 294
        },
        "resolved": true,
        "details": {
          "function_name": "try_wait_for_completion",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/completion.c",
          "lines": "282-303",
          "snippet": "bool try_wait_for_completion(struct completion *x)\n{\n\tunsigned long flags;\n\tbool ret = true;\n\n\t/*\n\t * Since x->done will need to be locked only\n\t * in the non-blocking case, we check x->done\n\t * first without taking the lock so we can\n\t * return early in the blocking case.\n\t */\n\tif (!READ_ONCE(x->done))\n\t\treturn false;\n\n\traw_spin_lock_irqsave(&x->wait.lock, flags);\n\tif (!x->done)\n\t\tret = false;\n\telse if (x->done != UINT_MAX)\n\t\tx->done--;\n\traw_spin_unlock_irqrestore(&x->wait.lock, flags);\n\treturn ret;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nbool try_wait_for_completion(struct completion *x)\n{\n\tunsigned long flags;\n\tbool ret = true;\n\n\t/*\n\t * Since x->done will need to be locked only\n\t * in the non-blocking case, we check x->done\n\t * first without taking the lock so we can\n\t * return early in the blocking case.\n\t */\n\tif (!READ_ONCE(x->done))\n\t\treturn false;\n\n\traw_spin_lock_irqsave(&x->wait.lock, flags);\n\tif (!x->done)\n\t\tret = false;\n\telse if (x->done != UINT_MAX)\n\t\tx->done--;\n\traw_spin_unlock_irqrestore(&x->wait.lock, flags);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wake_up_process",
          "args": [
            "consumer"
          ],
          "line": 293
        },
        "resolved": true,
        "details": {
          "function_name": "wake_up_process",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "4215-4218",
          "snippet": "int wake_up_process(struct task_struct *p)\n{\n\treturn try_to_wake_up(p, TASK_NORMAL, 0);\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\nint wake_up_process(struct task_struct *p)\n{\n\treturn try_to_wake_up(p, TASK_NORMAL, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_wmb",
          "args": [],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_completion",
          "args": [
            "&read_done"
          ],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_completion",
          "args": [
            "&read_start"
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "break_test",
          "args": [],
          "line": 283
        },
        "resolved": true,
        "details": {
          "function_name": "break_test",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ring_buffer_benchmark.c",
          "lines": "80-83",
          "snippet": "static bool break_test(void)\n{\n\treturn test_error || kthread_should_stop();\n}",
          "includes": [
            "#include <asm/local.h>",
            "#include <linux/ktime.h>",
            "#include <linux/module.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int test_error;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/local.h>\n#include <linux/ktime.h>\n#include <linux/module.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/ring_buffer.h>\n\nstatic int test_error;\n\nstatic bool break_test(void)\n{\n\treturn test_error || kthread_should_stop();\n}"
        }
      },
      {
        "call_info": {
          "callee": "ktime_before",
          "args": [
            "end_time",
            "timeout"
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 281
        },
        "resolved": true,
        "details": {
          "function_name": "__cond_resched",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "8172-8193",
          "snippet": "int __sched __cond_resched(void)\n{\n\tif (should_resched(0)) {\n\t\tpreempt_schedule_common();\n\t\treturn 1;\n\t}\n\t/*\n\t * In preemptible kernels, ->rcu_read_lock_nesting tells the tick\n\t * whether the current CPU is in an RCU read-side critical section,\n\t * so the tick can report quiescent states even for CPUs looping\n\t * in kernel context.  In contrast, in non-preemptible kernels,\n\t * RCU readers leave no in-memory hints, which means that CPU-bound\n\t * processes executing in kernel context might never report an\n\t * RCU quiescent state.  Therefore, the following code causes\n\t * cond_resched() to report a quiescent state, but only when RCU\n\t * is in urgent need of one.\n\t */\n#ifndef CONFIG_PREEMPT_RCU\n\trcu_all_qs();\n#endif\n\treturn 0;\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __sched",
            "static void __sched"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic void __sched;\nstatic void __sched;\n\nint __sched __cond_resched(void)\n{\n\tif (should_resched(0)) {\n\t\tpreempt_schedule_common();\n\t\treturn 1;\n\t}\n\t/*\n\t * In preemptible kernels, ->rcu_read_lock_nesting tells the tick\n\t * whether the current CPU is in an RCU read-side critical section,\n\t * so the tick can report quiescent states even for CPUs looping\n\t * in kernel context.  In contrast, in non-preemptible kernels,\n\t * RCU readers leave no in-memory hints, which means that CPU-bound\n\t * processes executing in kernel context might never report an\n\t * RCU quiescent state.  Therefore, the following code causes\n\t * cond_resched() to report a quiescent state, but only when RCU\n\t * is in urgent need of one.\n\t */\n#ifndef CONFIG_PREEMPT_RCU\n\trcu_all_qs();\n#endif\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ktime_get",
          "args": [],
          "line": 264
        },
        "resolved": true,
        "details": {
          "function_name": "__ktime_get_real_seconds",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
          "lines": "1025-1030",
          "snippet": "noinstr time64_t __ktime_get_real_seconds(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\n\treturn tk->xtime_sec;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nnoinstr time64_t __ktime_get_real_seconds(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\n\treturn tk->xtime_sec;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ring_buffer_unlock_commit",
          "args": [
            "buffer",
            "event"
          ],
          "line": 261
        },
        "resolved": true,
        "details": {
          "function_name": "ring_buffer_unlock_commit",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ring_buffer.c",
          "lines": "3258-3275",
          "snippet": "int ring_buffer_unlock_commit(struct trace_buffer *buffer,\n\t\t\t      struct ring_buffer_event *event)\n{\n\tstruct ring_buffer_per_cpu *cpu_buffer;\n\tint cpu = raw_smp_processor_id();\n\n\tcpu_buffer = buffer->buffers[cpu];\n\n\trb_commit(cpu_buffer, event);\n\n\trb_wakeups(buffer, cpu_buffer);\n\n\ttrace_recursive_unlock(cpu_buffer);\n\n\tpreempt_enable_notrace();\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/local64.h>",
            "#include <asm/local.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/list.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/delay.h>",
            "#include <linux/mutex.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>\t/* for self test */",
            "#include <linux/hardirq.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/security.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_recursion.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline u64 rb_time_stamp(struct trace_buffer *buffer);",
            "static void rb_reset_cpu(struct ring_buffer_per_cpu *cpu_buffer);",
            "static __always_inline struct",
            "static inline void rb_end_commit(struct ring_buffer_per_cpu *cpu_buffer);",
            "static noinline struct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/local64.h>\n#include <asm/local.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/mutex.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\t/* for self test */\n#include <linux/hardirq.h>\n#include <linux/uaccess.h>\n#include <linux/security.h>\n#include <linux/irq_work.h>\n#include <linux/spinlock.h>\n#include <linux/trace_seq.h>\n#include <linux/sched/clock.h>\n#include <linux/trace_clock.h>\n#include <linux/ring_buffer.h>\n#include <linux/trace_events.h>\n#include <linux/trace_recursion.h>\n\nstatic inline u64 rb_time_stamp(struct trace_buffer *buffer);\nstatic void rb_reset_cpu(struct ring_buffer_per_cpu *cpu_buffer);\nstatic __always_inline struct;\nstatic inline void rb_end_commit(struct ring_buffer_per_cpu *cpu_buffer);\nstatic noinline struct;\nstatic __always_inline struct;\n\nint ring_buffer_unlock_commit(struct trace_buffer *buffer,\n\t\t\t      struct ring_buffer_event *event)\n{\n\tstruct ring_buffer_per_cpu *cpu_buffer;\n\tint cpu = raw_smp_processor_id();\n\n\tcpu_buffer = buffer->buffers[cpu];\n\n\trb_commit(cpu_buffer, event);\n\n\trb_wakeups(buffer, cpu_buffer);\n\n\ttrace_recursive_unlock(cpu_buffer);\n\n\tpreempt_enable_notrace();\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ring_buffer_event_data",
          "args": [
            "event"
          ],
          "line": 259
        },
        "resolved": true,
        "details": {
          "function_name": "ring_buffer_event_data",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ring_buffer.c",
          "lines": "274-277",
          "snippet": "void *ring_buffer_event_data(struct ring_buffer_event *event)\n{\n\treturn rb_event_data(event);\n}",
          "includes": [
            "#include <asm/local64.h>",
            "#include <asm/local.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/list.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/delay.h>",
            "#include <linux/mutex.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>\t/* for self test */",
            "#include <linux/hardirq.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/security.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_recursion.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct",
            "static noinline struct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/local64.h>\n#include <asm/local.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/mutex.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\t/* for self test */\n#include <linux/hardirq.h>\n#include <linux/uaccess.h>\n#include <linux/security.h>\n#include <linux/irq_work.h>\n#include <linux/spinlock.h>\n#include <linux/trace_seq.h>\n#include <linux/sched/clock.h>\n#include <linux/trace_clock.h>\n#include <linux/ring_buffer.h>\n#include <linux/trace_events.h>\n#include <linux/trace_recursion.h>\n\nstatic __always_inline struct;\nstatic noinline struct;\nstatic __always_inline struct;\n\nvoid *ring_buffer_event_data(struct ring_buffer_event *event)\n{\n\treturn rb_event_data(event);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ring_buffer_lock_reserve",
          "args": [
            "buffer",
            "10"
          ],
          "line": 254
        },
        "resolved": true,
        "details": {
          "function_name": "ring_buffer_lock_reserve",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ring_buffer.c",
          "lines": "3665-3705",
          "snippet": "struct ring_buffer_event *\nring_buffer_lock_reserve(struct trace_buffer *buffer, unsigned long length)\n{\n\tstruct ring_buffer_per_cpu *cpu_buffer;\n\tstruct ring_buffer_event *event;\n\tint cpu;\n\n\t/* If we are tracing schedule, we don't want to recurse */\n\tpreempt_disable_notrace();\n\n\tif (unlikely(atomic_read(&buffer->record_disabled)))\n\t\tgoto out;\n\n\tcpu = raw_smp_processor_id();\n\n\tif (unlikely(!cpumask_test_cpu(cpu, buffer->cpumask)))\n\t\tgoto out;\n\n\tcpu_buffer = buffer->buffers[cpu];\n\n\tif (unlikely(atomic_read(&cpu_buffer->record_disabled)))\n\t\tgoto out;\n\n\tif (unlikely(length > BUF_MAX_DATA_SIZE))\n\t\tgoto out;\n\n\tif (unlikely(trace_recursive_lock(cpu_buffer)))\n\t\tgoto out;\n\n\tevent = rb_reserve_next_event(buffer, cpu_buffer, length);\n\tif (!event)\n\t\tgoto out_unlock;\n\n\treturn event;\n\n out_unlock:\n\ttrace_recursive_unlock(cpu_buffer);\n out:\n\tpreempt_enable_notrace();\n\treturn NULL;\n}",
          "includes": [
            "#include <asm/local64.h>",
            "#include <asm/local.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/list.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/delay.h>",
            "#include <linux/mutex.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>\t/* for self test */",
            "#include <linux/hardirq.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/security.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_recursion.h>"
          ],
          "macros_used": [
            "#define BUF_MAX_DATA_SIZE (BUF_PAGE_SIZE - (sizeof(u32) * 2))"
          ],
          "globals_used": [
            "static inline u64 rb_time_stamp(struct trace_buffer *buffer);",
            "static void rb_reset_cpu(struct ring_buffer_per_cpu *cpu_buffer);",
            "static __always_inline struct",
            "static inline void rb_end_commit(struct ring_buffer_per_cpu *cpu_buffer);",
            "static noinline struct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/local64.h>\n#include <asm/local.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/mutex.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\t/* for self test */\n#include <linux/hardirq.h>\n#include <linux/uaccess.h>\n#include <linux/security.h>\n#include <linux/irq_work.h>\n#include <linux/spinlock.h>\n#include <linux/trace_seq.h>\n#include <linux/sched/clock.h>\n#include <linux/trace_clock.h>\n#include <linux/ring_buffer.h>\n#include <linux/trace_events.h>\n#include <linux/trace_recursion.h>\n\n#define BUF_MAX_DATA_SIZE (BUF_PAGE_SIZE - (sizeof(u32) * 2))\n\nstatic inline u64 rb_time_stamp(struct trace_buffer *buffer);\nstatic void rb_reset_cpu(struct ring_buffer_per_cpu *cpu_buffer);\nstatic __always_inline struct;\nstatic inline void rb_end_commit(struct ring_buffer_per_cpu *cpu_buffer);\nstatic noinline struct;\nstatic __always_inline struct;\n\nstruct ring_buffer_event *\nring_buffer_lock_reserve(struct trace_buffer *buffer, unsigned long length)\n{\n\tstruct ring_buffer_per_cpu *cpu_buffer;\n\tstruct ring_buffer_event *event;\n\tint cpu;\n\n\t/* If we are tracing schedule, we don't want to recurse */\n\tpreempt_disable_notrace();\n\n\tif (unlikely(atomic_read(&buffer->record_disabled)))\n\t\tgoto out;\n\n\tcpu = raw_smp_processor_id();\n\n\tif (unlikely(!cpumask_test_cpu(cpu, buffer->cpumask)))\n\t\tgoto out;\n\n\tcpu_buffer = buffer->buffers[cpu];\n\n\tif (unlikely(atomic_read(&cpu_buffer->record_disabled)))\n\t\tgoto out;\n\n\tif (unlikely(length > BUF_MAX_DATA_SIZE))\n\t\tgoto out;\n\n\tif (unlikely(trace_recursive_lock(cpu_buffer)))\n\t\tgoto out;\n\n\tevent = rb_reserve_next_event(buffer, cpu_buffer, length);\n\tif (!event)\n\t\tgoto out_unlock;\n\n\treturn event;\n\n out_unlock:\n\ttrace_recursive_unlock(cpu_buffer);\n out:\n\tpreempt_enable_notrace();\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ktime_add_ns",
          "args": [
            "start_time",
            "RUN_TIME * NSEC_PER_SEC"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/local.h>\n#include <linux/ktime.h>\n#include <linux/module.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/ring_buffer.h>\n\n#define RUN_TIME\t10ULL\n\nstatic int wakeup_interval = 100;\nstatic int reader_finish;\nstatic DECLARE_COMPLETION(read_start);\nstatic DECLARE_COMPLETION(read_done);\nstatic struct trace_buffer *buffer;\nstatic struct task_struct *consumer;\nstatic unsigned long read;\nstatic unsigned int disable_reader;\nstatic unsigned int write_iteration = 50;\nstatic int producer_nice = MAX_NICE;\nstatic int consumer_nice = MAX_NICE;\nstatic int producer_fifo;\nstatic int consumer_fifo;\nstatic int read_events;\nstatic int test_error;\n\nstatic void ring_buffer_producer(void)\n{\n\tktime_t start_time, end_time, timeout;\n\tunsigned long long time;\n\tunsigned long long entries;\n\tunsigned long long overruns;\n\tunsigned long missed = 0;\n\tunsigned long hit = 0;\n\tunsigned long avg;\n\tint cnt = 0;\n\n\t/*\n\t * Hammer the buffer for 10 secs (this may\n\t * make the system stall)\n\t */\n\ttrace_printk(\"Starting ring buffer hammer\\n\");\n\tstart_time = ktime_get();\n\ttimeout = ktime_add_ns(start_time, RUN_TIME * NSEC_PER_SEC);\n\tdo {\n\t\tstruct ring_buffer_event *event;\n\t\tint *entry;\n\t\tint i;\n\n\t\tfor (i = 0; i < write_iteration; i++) {\n\t\t\tevent = ring_buffer_lock_reserve(buffer, 10);\n\t\t\tif (!event) {\n\t\t\t\tmissed++;\n\t\t\t} else {\n\t\t\t\thit++;\n\t\t\t\tentry = ring_buffer_event_data(event);\n\t\t\t\t*entry = smp_processor_id();\n\t\t\t\tring_buffer_unlock_commit(buffer, event);\n\t\t\t}\n\t\t}\n\t\tend_time = ktime_get();\n\n\t\tcnt++;\n\t\tif (consumer && !(cnt % wakeup_interval))\n\t\t\twake_up_process(consumer);\n\n#ifndef CONFIG_PREEMPTION\n\t\t/*\n\t\t * If we are a non preempt kernel, the 10 seconds run will\n\t\t * stop everything while it runs. Instead, we will call\n\t\t * cond_resched and also add any time that was lost by a\n\t\t * reschedule.\n\t\t *\n\t\t * Do a cond resched at the same frequency we would wake up\n\t\t * the reader.\n\t\t */\n\t\tif (cnt % wakeup_interval)\n\t\t\tcond_resched();\n#endif\n\t} while (ktime_before(end_time, timeout) && !break_test());\n\ttrace_printk(\"End ring buffer hammer\\n\");\n\n\tif (consumer) {\n\t\t/* Init both completions here to avoid races */\n\t\tinit_completion(&read_start);\n\t\tinit_completion(&read_done);\n\t\t/* the completions must be visible before the finish var */\n\t\tsmp_wmb();\n\t\treader_finish = 1;\n\t\twake_up_process(consumer);\n\t\twait_for_completion(&read_done);\n\t}\n\n\ttime = ktime_us_delta(end_time, start_time);\n\n\tentries = ring_buffer_entries(buffer);\n\toverruns = ring_buffer_overruns(buffer);\n\n\tif (test_error)\n\t\ttrace_printk(\"ERROR!\\n\");\n\n\tif (!disable_reader) {\n\t\tif (consumer_fifo)\n\t\t\ttrace_printk(\"Running Consumer at SCHED_FIFO %s\\n\",\n\t\t\t\t     consumer_fifo == 1 ? \"low\" : \"high\");\n\t\telse\n\t\t\ttrace_printk(\"Running Consumer at nice: %d\\n\",\n\t\t\t\t     consumer_nice);\n\t}\n\tif (producer_fifo)\n\t\ttrace_printk(\"Running Producer at SCHED_FIFO %s\\n\",\n\t\t\t     producer_fifo == 1 ? \"low\" : \"high\");\n\telse\n\t\ttrace_printk(\"Running Producer at nice: %d\\n\",\n\t\t\t     producer_nice);\n\n\t/* Let the user know that the test is running at low priority */\n\tif (!producer_fifo && !consumer_fifo &&\n\t    producer_nice == MAX_NICE && consumer_nice == MAX_NICE)\n\t\ttrace_printk(\"WARNING!!! This test is running at lowest priority.\\n\");\n\n\ttrace_printk(\"Time:     %lld (usecs)\\n\", time);\n\ttrace_printk(\"Overruns: %lld\\n\", overruns);\n\tif (disable_reader)\n\t\ttrace_printk(\"Read:     (reader disabled)\\n\");\n\telse\n\t\ttrace_printk(\"Read:     %ld  (by %s)\\n\", read,\n\t\t\tread_events ? \"events\" : \"pages\");\n\ttrace_printk(\"Entries:  %lld\\n\", entries);\n\ttrace_printk(\"Total:    %lld\\n\", entries + overruns + read);\n\ttrace_printk(\"Missed:   %ld\\n\", missed);\n\ttrace_printk(\"Hit:      %ld\\n\", hit);\n\n\t/* Convert time from usecs to millisecs */\n\tdo_div(time, USEC_PER_MSEC);\n\tif (time)\n\t\thit /= (long)time;\n\telse\n\t\ttrace_printk(\"TIME IS ZERO??\\n\");\n\n\ttrace_printk(\"Entries per millisec: %ld\\n\", hit);\n\n\tif (hit) {\n\t\t/* Calculate the average time in nanosecs */\n\t\tavg = NSEC_PER_MSEC / hit;\n\t\ttrace_printk(\"%ld ns per entry\\n\", avg);\n\t}\n\n\tif (missed) {\n\t\tif (time)\n\t\t\tmissed /= (long)time;\n\n\t\ttrace_printk(\"Total iterations per millisec: %ld\\n\",\n\t\t\t     hit + missed);\n\n\t\t/* it is possible that hit + missed will overflow and be zero */\n\t\tif (!(hit + missed)) {\n\t\t\ttrace_printk(\"hit + missed overflowed and totalled zero!\\n\");\n\t\t\thit--; /* make it non zero */\n\t\t}\n\n\t\t/* Calculate the average time in nanosecs */\n\t\tavg = NSEC_PER_MSEC / (hit + missed);\n\t\ttrace_printk(\"%ld ns per entry\\n\", avg);\n\t}\n}"
  },
  {
    "function_name": "ring_buffer_consumer",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ring_buffer_benchmark.c",
    "lines": "182-228",
    "snippet": "static void ring_buffer_consumer(void)\n{\n\t/* toggle between reading pages and events */\n\tread_events ^= 1;\n\n\tread = 0;\n\t/*\n\t * Continue running until the producer specifically asks to stop\n\t * and is ready for the completion.\n\t */\n\twhile (!READ_ONCE(reader_finish)) {\n\t\tint found = 1;\n\n\t\twhile (found && !test_error) {\n\t\t\tint cpu;\n\n\t\t\tfound = 0;\n\t\t\tfor_each_online_cpu(cpu) {\n\t\t\t\tenum event_status stat;\n\n\t\t\t\tif (read_events)\n\t\t\t\t\tstat = read_event(cpu);\n\t\t\t\telse\n\t\t\t\t\tstat = read_page(cpu);\n\n\t\t\t\tif (test_error)\n\t\t\t\t\tbreak;\n\n\t\t\t\tif (stat == EVENT_FOUND)\n\t\t\t\t\tfound = 1;\n\n\t\t\t}\n\t\t}\n\n\t\t/* Wait till the producer wakes us up when there is more data\n\t\t * available or when the producer wants us to finish reading.\n\t\t */\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\tif (reader_finish)\n\t\t\tbreak;\n\n\t\tschedule();\n\t}\n\t__set_current_state(TASK_RUNNING);\n\treader_finish = 0;\n\tcomplete(&read_done);\n}",
    "includes": [
      "#include <asm/local.h>",
      "#include <linux/ktime.h>",
      "#include <linux/module.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/completion.h>",
      "#include <linux/ring_buffer.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int reader_finish;",
      "static DECLARE_COMPLETION(read_done);",
      "static struct task_struct *producer;",
      "static unsigned long read;",
      "static int read_events;",
      "static int test_error;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "complete",
          "args": [
            "&read_done"
          ],
          "line": 227
        },
        "resolved": true,
        "details": {
          "function_name": "complete_vfork_done",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/fork.c",
          "lines": "1334-1345",
          "snippet": "static void complete_vfork_done(struct task_struct *tsk)\n{\n\tstruct completion *vfork;\n\n\ttask_lock(tsk);\n\tvfork = tsk->vfork_done;\n\tif (likely(vfork)) {\n\t\ttsk->vfork_done = NULL;\n\t\tcomplete(vfork);\n\t}\n\ttask_unlock(tsk);\n}",
          "includes": [
            "#include <linux/init_task.h>",
            "#include <trace/events/task.h>",
            "#include <trace/events/sched.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <linux/bpf.h>",
            "#include <linux/io_uring.h>",
            "#include <linux/scs.h>",
            "#include <linux/kasan.h>",
            "#include <linux/stackleak.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/kcov.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/compiler.h>",
            "#include <linux/aio.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/oom.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/magic.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/tty.h>",
            "#include <linux/random.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/acct.h>",
            "#include <linux/ksm.h>",
            "#include <linux/rmap.h>",
            "#include <linux/profile.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/kthread.h>",
            "#include <linux/compat.h>",
            "#include <linux/futex.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mman.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/sem.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>",
            "#include <linux/unistd.h>",
            "#include <linux/init.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/anon_inodes.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __latent_entropy struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/init_task.h>\n#include <trace/events/task.h>\n#include <trace/events/sched.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <linux/bpf.h>\n#include <linux/io_uring.h>\n#include <linux/scs.h>\n#include <linux/kasan.h>\n#include <linux/stackleak.h>\n#include <linux/thread_info.h>\n#include <linux/livepatch.h>\n#include <linux/kcov.h>\n#include <linux/sysctl.h>\n#include <linux/compiler.h>\n#include <linux/aio.h>\n#include <linux/uprobes.h>\n#include <linux/signalfd.h>\n#include <linux/khugepaged.h>\n#include <linux/oom.h>\n#include <linux/user-return-notifier.h>\n#include <linux/posix-timers.h>\n#include <linux/perf_event.h>\n#include <linux/magic.h>\n#include <linux/fs_struct.h>\n#include <linux/tty.h>\n#include <linux/random.h>\n#include <linux/taskstats_kern.h>\n#include <linux/delayacct.h>\n#include <linux/freezer.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/acct.h>\n#include <linux/ksm.h>\n#include <linux/rmap.h>\n#include <linux/profile.h>\n#include <linux/proc_fs.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/ptrace.h>\n#include <linux/rcupdate.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/kthread.h>\n#include <linux/compat.h>\n#include <linux/futex.h>\n#include <linux/jiffies.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/seccomp.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/cgroup.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/nsproxy.h>\n#include <linux/vmacache.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mman.h>\n#include <linux/binfmts.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/sem.h>\n#include <linux/mempolicy.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/unistd.h>\n#include <linux/init.h>\n#include <linux/rtmutex.h>\n#include <linux/seq_file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/user.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/anon_inodes.h>\n\nstatic __latent_entropy struct;\n\nstatic void complete_vfork_done(struct task_struct *tsk)\n{\n\tstruct completion *vfork;\n\n\ttask_lock(tsk);\n\tvfork = tsk->vfork_done;\n\tif (likely(vfork)) {\n\t\ttsk->vfork_done = NULL;\n\t\tcomplete(vfork);\n\t}\n\ttask_unlock(tsk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__set_current_state",
          "args": [
            "TASK_RUNNING"
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schedule",
          "args": [],
          "line": 223
        },
        "resolved": true,
        "details": {
          "function_name": "audit_schedule_prune",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_tree.c",
          "lines": "963-966",
          "snippet": "static void audit_schedule_prune(void)\n{\n\twake_up_process(prune_thread);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include \"audit.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct task_struct *prune_thread;",
            "static void audit_schedule_prune(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic struct task_struct *prune_thread;\nstatic void audit_schedule_prune(void);\n\nstatic void audit_schedule_prune(void)\n{\n\twake_up_process(prune_thread);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_current_state",
          "args": [
            "TASK_INTERRUPTIBLE"
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_page",
          "args": [
            "cpu"
          ],
          "line": 205
        },
        "resolved": true,
        "details": {
          "function_name": "read_page",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ring_buffer_benchmark.c",
          "lines": "105-180",
          "snippet": "static enum event_status read_page(int cpu)\n{\n\tstruct ring_buffer_event *event;\n\tstruct rb_page *rpage;\n\tunsigned long commit;\n\tvoid *bpage;\n\tint *entry;\n\tint ret;\n\tint inc;\n\tint i;\n\n\tbpage = ring_buffer_alloc_read_page(buffer, cpu);\n\tif (IS_ERR(bpage))\n\t\treturn EVENT_DROPPED;\n\n\tret = ring_buffer_read_page(buffer, &bpage, PAGE_SIZE, cpu, 1);\n\tif (ret >= 0) {\n\t\trpage = bpage;\n\t\t/* The commit may have missed event flags set, clear them */\n\t\tcommit = local_read(&rpage->commit) & 0xfffff;\n\t\tfor (i = 0; i < commit && !test_error ; i += inc) {\n\n\t\t\tif (i >= (PAGE_SIZE - offsetof(struct rb_page, data))) {\n\t\t\t\tTEST_ERROR();\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tinc = -1;\n\t\t\tevent = (void *)&rpage->data[i];\n\t\t\tswitch (event->type_len) {\n\t\t\tcase RINGBUF_TYPE_PADDING:\n\t\t\t\t/* failed writes may be discarded events */\n\t\t\t\tif (!event->time_delta)\n\t\t\t\t\tTEST_ERROR();\n\t\t\t\tinc = event->array[0] + 4;\n\t\t\t\tbreak;\n\t\t\tcase RINGBUF_TYPE_TIME_EXTEND:\n\t\t\t\tinc = 8;\n\t\t\t\tbreak;\n\t\t\tcase 0:\n\t\t\t\tentry = ring_buffer_event_data(event);\n\t\t\t\tif (*entry != cpu) {\n\t\t\t\t\tTEST_ERROR();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tread++;\n\t\t\t\tif (!event->array[0]) {\n\t\t\t\t\tTEST_ERROR();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tinc = event->array[0] + 4;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tentry = ring_buffer_event_data(event);\n\t\t\t\tif (*entry != cpu) {\n\t\t\t\t\tTEST_ERROR();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tread++;\n\t\t\t\tinc = ((event->type_len + 1) * 4);\n\t\t\t}\n\t\t\tif (test_error)\n\t\t\t\tbreak;\n\n\t\t\tif (inc <= 0) {\n\t\t\t\tTEST_ERROR();\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tring_buffer_free_read_page(buffer, cpu, bpage);\n\n\tif (ret < 0)\n\t\treturn EVENT_DROPPED;\n\treturn EVENT_FOUND;\n}",
          "includes": [
            "#include <asm/local.h>",
            "#include <linux/ktime.h>",
            "#include <linux/module.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct trace_buffer *buffer;",
            "static unsigned long read;",
            "static int test_error;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/local.h>\n#include <linux/ktime.h>\n#include <linux/module.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/ring_buffer.h>\n\nstatic struct trace_buffer *buffer;\nstatic unsigned long read;\nstatic int test_error;\n\nstatic enum event_status read_page(int cpu)\n{\n\tstruct ring_buffer_event *event;\n\tstruct rb_page *rpage;\n\tunsigned long commit;\n\tvoid *bpage;\n\tint *entry;\n\tint ret;\n\tint inc;\n\tint i;\n\n\tbpage = ring_buffer_alloc_read_page(buffer, cpu);\n\tif (IS_ERR(bpage))\n\t\treturn EVENT_DROPPED;\n\n\tret = ring_buffer_read_page(buffer, &bpage, PAGE_SIZE, cpu, 1);\n\tif (ret >= 0) {\n\t\trpage = bpage;\n\t\t/* The commit may have missed event flags set, clear them */\n\t\tcommit = local_read(&rpage->commit) & 0xfffff;\n\t\tfor (i = 0; i < commit && !test_error ; i += inc) {\n\n\t\t\tif (i >= (PAGE_SIZE - offsetof(struct rb_page, data))) {\n\t\t\t\tTEST_ERROR();\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tinc = -1;\n\t\t\tevent = (void *)&rpage->data[i];\n\t\t\tswitch (event->type_len) {\n\t\t\tcase RINGBUF_TYPE_PADDING:\n\t\t\t\t/* failed writes may be discarded events */\n\t\t\t\tif (!event->time_delta)\n\t\t\t\t\tTEST_ERROR();\n\t\t\t\tinc = event->array[0] + 4;\n\t\t\t\tbreak;\n\t\t\tcase RINGBUF_TYPE_TIME_EXTEND:\n\t\t\t\tinc = 8;\n\t\t\t\tbreak;\n\t\t\tcase 0:\n\t\t\t\tentry = ring_buffer_event_data(event);\n\t\t\t\tif (*entry != cpu) {\n\t\t\t\t\tTEST_ERROR();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tread++;\n\t\t\t\tif (!event->array[0]) {\n\t\t\t\t\tTEST_ERROR();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tinc = event->array[0] + 4;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tentry = ring_buffer_event_data(event);\n\t\t\t\tif (*entry != cpu) {\n\t\t\t\t\tTEST_ERROR();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tread++;\n\t\t\t\tinc = ((event->type_len + 1) * 4);\n\t\t\t}\n\t\t\tif (test_error)\n\t\t\t\tbreak;\n\n\t\t\tif (inc <= 0) {\n\t\t\t\tTEST_ERROR();\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tring_buffer_free_read_page(buffer, cpu, bpage);\n\n\tif (ret < 0)\n\t\treturn EVENT_DROPPED;\n\treturn EVENT_FOUND;\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_event",
          "args": [
            "cpu"
          ],
          "line": 203
        },
        "resolved": true,
        "details": {
          "function_name": "read_event",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ring_buffer_benchmark.c",
          "lines": "85-103",
          "snippet": "static enum event_status read_event(int cpu)\n{\n\tstruct ring_buffer_event *event;\n\tint *entry;\n\tu64 ts;\n\n\tevent = ring_buffer_consume(buffer, cpu, &ts, NULL);\n\tif (!event)\n\t\treturn EVENT_DROPPED;\n\n\tentry = ring_buffer_event_data(event);\n\tif (*entry != cpu) {\n\t\tTEST_ERROR();\n\t\treturn EVENT_DROPPED;\n\t}\n\n\tread++;\n\treturn EVENT_FOUND;\n}",
          "includes": [
            "#include <asm/local.h>",
            "#include <linux/ktime.h>",
            "#include <linux/module.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct trace_buffer *buffer;",
            "static unsigned long read;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/local.h>\n#include <linux/ktime.h>\n#include <linux/module.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/ring_buffer.h>\n\nstatic struct trace_buffer *buffer;\nstatic unsigned long read;\n\nstatic enum event_status read_event(int cpu)\n{\n\tstruct ring_buffer_event *event;\n\tint *entry;\n\tu64 ts;\n\n\tevent = ring_buffer_consume(buffer, cpu, &ts, NULL);\n\tif (!event)\n\t\treturn EVENT_DROPPED;\n\n\tentry = ring_buffer_event_data(event);\n\tif (*entry != cpu) {\n\t\tTEST_ERROR();\n\t\treturn EVENT_DROPPED;\n\t}\n\n\tread++;\n\treturn EVENT_FOUND;\n}"
        }
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "reader_finish"
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/local.h>\n#include <linux/ktime.h>\n#include <linux/module.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/ring_buffer.h>\n\nstatic int reader_finish;\nstatic DECLARE_COMPLETION(read_done);\nstatic struct task_struct *producer;\nstatic unsigned long read;\nstatic int read_events;\nstatic int test_error;\n\nstatic void ring_buffer_consumer(void)\n{\n\t/* toggle between reading pages and events */\n\tread_events ^= 1;\n\n\tread = 0;\n\t/*\n\t * Continue running until the producer specifically asks to stop\n\t * and is ready for the completion.\n\t */\n\twhile (!READ_ONCE(reader_finish)) {\n\t\tint found = 1;\n\n\t\twhile (found && !test_error) {\n\t\t\tint cpu;\n\n\t\t\tfound = 0;\n\t\t\tfor_each_online_cpu(cpu) {\n\t\t\t\tenum event_status stat;\n\n\t\t\t\tif (read_events)\n\t\t\t\t\tstat = read_event(cpu);\n\t\t\t\telse\n\t\t\t\t\tstat = read_page(cpu);\n\n\t\t\t\tif (test_error)\n\t\t\t\t\tbreak;\n\n\t\t\t\tif (stat == EVENT_FOUND)\n\t\t\t\t\tfound = 1;\n\n\t\t\t}\n\t\t}\n\n\t\t/* Wait till the producer wakes us up when there is more data\n\t\t * available or when the producer wants us to finish reading.\n\t\t */\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\tif (reader_finish)\n\t\t\tbreak;\n\n\t\tschedule();\n\t}\n\t__set_current_state(TASK_RUNNING);\n\treader_finish = 0;\n\tcomplete(&read_done);\n}"
  },
  {
    "function_name": "read_page",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ring_buffer_benchmark.c",
    "lines": "105-180",
    "snippet": "static enum event_status read_page(int cpu)\n{\n\tstruct ring_buffer_event *event;\n\tstruct rb_page *rpage;\n\tunsigned long commit;\n\tvoid *bpage;\n\tint *entry;\n\tint ret;\n\tint inc;\n\tint i;\n\n\tbpage = ring_buffer_alloc_read_page(buffer, cpu);\n\tif (IS_ERR(bpage))\n\t\treturn EVENT_DROPPED;\n\n\tret = ring_buffer_read_page(buffer, &bpage, PAGE_SIZE, cpu, 1);\n\tif (ret >= 0) {\n\t\trpage = bpage;\n\t\t/* The commit may have missed event flags set, clear them */\n\t\tcommit = local_read(&rpage->commit) & 0xfffff;\n\t\tfor (i = 0; i < commit && !test_error ; i += inc) {\n\n\t\t\tif (i >= (PAGE_SIZE - offsetof(struct rb_page, data))) {\n\t\t\t\tTEST_ERROR();\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tinc = -1;\n\t\t\tevent = (void *)&rpage->data[i];\n\t\t\tswitch (event->type_len) {\n\t\t\tcase RINGBUF_TYPE_PADDING:\n\t\t\t\t/* failed writes may be discarded events */\n\t\t\t\tif (!event->time_delta)\n\t\t\t\t\tTEST_ERROR();\n\t\t\t\tinc = event->array[0] + 4;\n\t\t\t\tbreak;\n\t\t\tcase RINGBUF_TYPE_TIME_EXTEND:\n\t\t\t\tinc = 8;\n\t\t\t\tbreak;\n\t\t\tcase 0:\n\t\t\t\tentry = ring_buffer_event_data(event);\n\t\t\t\tif (*entry != cpu) {\n\t\t\t\t\tTEST_ERROR();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tread++;\n\t\t\t\tif (!event->array[0]) {\n\t\t\t\t\tTEST_ERROR();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tinc = event->array[0] + 4;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tentry = ring_buffer_event_data(event);\n\t\t\t\tif (*entry != cpu) {\n\t\t\t\t\tTEST_ERROR();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tread++;\n\t\t\t\tinc = ((event->type_len + 1) * 4);\n\t\t\t}\n\t\t\tif (test_error)\n\t\t\t\tbreak;\n\n\t\t\tif (inc <= 0) {\n\t\t\t\tTEST_ERROR();\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tring_buffer_free_read_page(buffer, cpu, bpage);\n\n\tif (ret < 0)\n\t\treturn EVENT_DROPPED;\n\treturn EVENT_FOUND;\n}",
    "includes": [
      "#include <asm/local.h>",
      "#include <linux/ktime.h>",
      "#include <linux/module.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/completion.h>",
      "#include <linux/ring_buffer.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct trace_buffer *buffer;",
      "static unsigned long read;",
      "static int test_error;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ring_buffer_free_read_page",
          "args": [
            "buffer",
            "cpu",
            "bpage"
          ],
          "line": 175
        },
        "resolved": true,
        "details": {
          "function_name": "ring_buffer_free_read_page",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ring_buffer.c",
          "lines": "5451-5475",
          "snippet": "void ring_buffer_free_read_page(struct trace_buffer *buffer, int cpu, void *data)\n{\n\tstruct ring_buffer_per_cpu *cpu_buffer = buffer->buffers[cpu];\n\tstruct buffer_data_page *bpage = data;\n\tstruct page *page = virt_to_page(bpage);\n\tunsigned long flags;\n\n\t/* If the page is still in use someplace else, we can't reuse it */\n\tif (page_ref_count(page) > 1)\n\t\tgoto out;\n\n\tlocal_irq_save(flags);\n\tarch_spin_lock(&cpu_buffer->lock);\n\n\tif (!cpu_buffer->free_page) {\n\t\tcpu_buffer->free_page = bpage;\n\t\tbpage = NULL;\n\t}\n\n\tarch_spin_unlock(&cpu_buffer->lock);\n\tlocal_irq_restore(flags);\n\n out:\n\tfree_page((unsigned long)bpage);\n}",
          "includes": [
            "#include <asm/local64.h>",
            "#include <asm/local.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/list.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/delay.h>",
            "#include <linux/mutex.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>\t/* for self test */",
            "#include <linux/hardirq.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/security.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_recursion.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline u64 rb_time_stamp(struct trace_buffer *buffer);",
            "static void rb_reset_cpu(struct ring_buffer_per_cpu *cpu_buffer);",
            "static __always_inline struct",
            "static inline void rb_end_commit(struct ring_buffer_per_cpu *cpu_buffer);",
            "static noinline struct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/local64.h>\n#include <asm/local.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/mutex.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\t/* for self test */\n#include <linux/hardirq.h>\n#include <linux/uaccess.h>\n#include <linux/security.h>\n#include <linux/irq_work.h>\n#include <linux/spinlock.h>\n#include <linux/trace_seq.h>\n#include <linux/sched/clock.h>\n#include <linux/trace_clock.h>\n#include <linux/ring_buffer.h>\n#include <linux/trace_events.h>\n#include <linux/trace_recursion.h>\n\nstatic inline u64 rb_time_stamp(struct trace_buffer *buffer);\nstatic void rb_reset_cpu(struct ring_buffer_per_cpu *cpu_buffer);\nstatic __always_inline struct;\nstatic inline void rb_end_commit(struct ring_buffer_per_cpu *cpu_buffer);\nstatic noinline struct;\nstatic __always_inline struct;\n\nvoid ring_buffer_free_read_page(struct trace_buffer *buffer, int cpu, void *data)\n{\n\tstruct ring_buffer_per_cpu *cpu_buffer = buffer->buffers[cpu];\n\tstruct buffer_data_page *bpage = data;\n\tstruct page *page = virt_to_page(bpage);\n\tunsigned long flags;\n\n\t/* If the page is still in use someplace else, we can't reuse it */\n\tif (page_ref_count(page) > 1)\n\t\tgoto out;\n\n\tlocal_irq_save(flags);\n\tarch_spin_lock(&cpu_buffer->lock);\n\n\tif (!cpu_buffer->free_page) {\n\t\tcpu_buffer->free_page = bpage;\n\t\tbpage = NULL;\n\t}\n\n\tarch_spin_unlock(&cpu_buffer->lock);\n\tlocal_irq_restore(flags);\n\n out:\n\tfree_page((unsigned long)bpage);\n}"
        }
      },
      {
        "call_info": {
          "callee": "TEST_ERROR",
          "args": [],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_ERROR",
          "args": [],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ring_buffer_event_data",
          "args": [
            "event"
          ],
          "line": 158
        },
        "resolved": true,
        "details": {
          "function_name": "ring_buffer_event_data",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ring_buffer.c",
          "lines": "274-277",
          "snippet": "void *ring_buffer_event_data(struct ring_buffer_event *event)\n{\n\treturn rb_event_data(event);\n}",
          "includes": [
            "#include <asm/local64.h>",
            "#include <asm/local.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/list.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/delay.h>",
            "#include <linux/mutex.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>\t/* for self test */",
            "#include <linux/hardirq.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/security.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_recursion.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct",
            "static noinline struct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/local64.h>\n#include <asm/local.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/mutex.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\t/* for self test */\n#include <linux/hardirq.h>\n#include <linux/uaccess.h>\n#include <linux/security.h>\n#include <linux/irq_work.h>\n#include <linux/spinlock.h>\n#include <linux/trace_seq.h>\n#include <linux/sched/clock.h>\n#include <linux/trace_clock.h>\n#include <linux/ring_buffer.h>\n#include <linux/trace_events.h>\n#include <linux/trace_recursion.h>\n\nstatic __always_inline struct;\nstatic noinline struct;\nstatic __always_inline struct;\n\nvoid *ring_buffer_event_data(struct ring_buffer_event *event)\n{\n\treturn rb_event_data(event);\n}"
        }
      },
      {
        "call_info": {
          "callee": "TEST_ERROR",
          "args": [],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_ERROR",
          "args": [],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_ERROR",
          "args": [],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_ERROR",
          "args": [],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_read",
          "args": [
            "&rpage->commit"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ring_buffer_read_page",
          "args": [
            "buffer",
            "&bpage",
            "PAGE_SIZE",
            "cpu",
            "1"
          ],
          "line": 120
        },
        "resolved": true,
        "details": {
          "function_name": "ring_buffer_read_page",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ring_buffer.c",
          "lines": "5511-5672",
          "snippet": "int ring_buffer_read_page(struct trace_buffer *buffer,\n\t\t\t  void **data_page, size_t len, int cpu, int full)\n{\n\tstruct ring_buffer_per_cpu *cpu_buffer = buffer->buffers[cpu];\n\tstruct ring_buffer_event *event;\n\tstruct buffer_data_page *bpage;\n\tstruct buffer_page *reader;\n\tunsigned long missed_events;\n\tunsigned long flags;\n\tunsigned int commit;\n\tunsigned int read;\n\tu64 save_timestamp;\n\tint ret = -1;\n\n\tif (!cpumask_test_cpu(cpu, buffer->cpumask))\n\t\tgoto out;\n\n\t/*\n\t * If len is not big enough to hold the page header, then\n\t * we can not copy anything.\n\t */\n\tif (len <= BUF_PAGE_HDR_SIZE)\n\t\tgoto out;\n\n\tlen -= BUF_PAGE_HDR_SIZE;\n\n\tif (!data_page)\n\t\tgoto out;\n\n\tbpage = *data_page;\n\tif (!bpage)\n\t\tgoto out;\n\n\traw_spin_lock_irqsave(&cpu_buffer->reader_lock, flags);\n\n\treader = rb_get_reader_page(cpu_buffer);\n\tif (!reader)\n\t\tgoto out_unlock;\n\n\tevent = rb_reader_event(cpu_buffer);\n\n\tread = reader->read;\n\tcommit = rb_page_commit(reader);\n\n\t/* Check if any events were dropped */\n\tmissed_events = cpu_buffer->lost_events;\n\n\t/*\n\t * If this page has been partially read or\n\t * if len is not big enough to read the rest of the page or\n\t * a writer is still on the page, then\n\t * we must copy the data from the page to the buffer.\n\t * Otherwise, we can simply swap the page with the one passed in.\n\t */\n\tif (read || (len < (commit - read)) ||\n\t    cpu_buffer->reader_page == cpu_buffer->commit_page) {\n\t\tstruct buffer_data_page *rpage = cpu_buffer->reader_page->page;\n\t\tunsigned int rpos = read;\n\t\tunsigned int pos = 0;\n\t\tunsigned int size;\n\n\t\tif (full)\n\t\t\tgoto out_unlock;\n\n\t\tif (len > (commit - read))\n\t\t\tlen = (commit - read);\n\n\t\t/* Always keep the time extend and data together */\n\t\tsize = rb_event_ts_length(event);\n\n\t\tif (len < size)\n\t\t\tgoto out_unlock;\n\n\t\t/* save the current timestamp, since the user will need it */\n\t\tsave_timestamp = cpu_buffer->read_stamp;\n\n\t\t/* Need to copy one event at a time */\n\t\tdo {\n\t\t\t/* We need the size of one event, because\n\t\t\t * rb_advance_reader only advances by one event,\n\t\t\t * whereas rb_event_ts_length may include the size of\n\t\t\t * one or two events.\n\t\t\t * We have already ensured there's enough space if this\n\t\t\t * is a time extend. */\n\t\t\tsize = rb_event_length(event);\n\t\t\tmemcpy(bpage->data + pos, rpage->data + rpos, size);\n\n\t\t\tlen -= size;\n\n\t\t\trb_advance_reader(cpu_buffer);\n\t\t\trpos = reader->read;\n\t\t\tpos += size;\n\n\t\t\tif (rpos >= commit)\n\t\t\t\tbreak;\n\n\t\t\tevent = rb_reader_event(cpu_buffer);\n\t\t\t/* Always keep the time extend and data together */\n\t\t\tsize = rb_event_ts_length(event);\n\t\t} while (len >= size);\n\n\t\t/* update bpage */\n\t\tlocal_set(&bpage->commit, pos);\n\t\tbpage->time_stamp = save_timestamp;\n\n\t\t/* we copied everything to the beginning */\n\t\tread = 0;\n\t} else {\n\t\t/* update the entry counter */\n\t\tcpu_buffer->read += rb_page_entries(reader);\n\t\tcpu_buffer->read_bytes += BUF_PAGE_SIZE;\n\n\t\t/* swap the pages */\n\t\trb_init_page(bpage);\n\t\tbpage = reader->page;\n\t\treader->page = *data_page;\n\t\tlocal_set(&reader->write, 0);\n\t\tlocal_set(&reader->entries, 0);\n\t\treader->read = 0;\n\t\t*data_page = bpage;\n\n\t\t/*\n\t\t * Use the real_end for the data size,\n\t\t * This gives us a chance to store the lost events\n\t\t * on the page.\n\t\t */\n\t\tif (reader->real_end)\n\t\t\tlocal_set(&bpage->commit, reader->real_end);\n\t}\n\tret = read;\n\n\tcpu_buffer->lost_events = 0;\n\n\tcommit = local_read(&bpage->commit);\n\t/*\n\t * Set a flag in the commit field if we lost events\n\t */\n\tif (missed_events) {\n\t\t/* If there is room at the end of the page to save the\n\t\t * missed events, then record it there.\n\t\t */\n\t\tif (BUF_PAGE_SIZE - commit >= sizeof(missed_events)) {\n\t\t\tmemcpy(&bpage->data[commit], &missed_events,\n\t\t\t       sizeof(missed_events));\n\t\t\tlocal_add(RB_MISSED_STORED, &bpage->commit);\n\t\t\tcommit += sizeof(missed_events);\n\t\t}\n\t\tlocal_add(RB_MISSED_EVENTS, &bpage->commit);\n\t}\n\n\t/*\n\t * This page may be off to user land. Zero it out here.\n\t */\n\tif (commit < BUF_PAGE_SIZE)\n\t\tmemset(&bpage->data[commit], 0, BUF_PAGE_SIZE - commit);\n\n out_unlock:\n\traw_spin_unlock_irqrestore(&cpu_buffer->reader_lock, flags);\n\n out:\n\treturn ret;\n}",
          "includes": [
            "#include <asm/local64.h>",
            "#include <asm/local.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/list.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/delay.h>",
            "#include <linux/mutex.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>\t/* for self test */",
            "#include <linux/hardirq.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/security.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_recursion.h>"
          ],
          "macros_used": [
            "#define BUF_PAGE_SIZE (PAGE_SIZE - BUF_PAGE_HDR_SIZE)",
            "#define RB_MISSED_STORED\t(1 << 30)",
            "#define RB_MISSED_EVENTS\t(1 << 31)",
            "#define BUF_PAGE_HDR_SIZE offsetof(struct buffer_data_page, data)"
          ],
          "globals_used": [
            "static inline u64 rb_time_stamp(struct trace_buffer *buffer);",
            "static void rb_reset_cpu(struct ring_buffer_per_cpu *cpu_buffer);",
            "static __always_inline struct",
            "static inline void rb_end_commit(struct ring_buffer_per_cpu *cpu_buffer);",
            "static noinline struct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/local64.h>\n#include <asm/local.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/mutex.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\t/* for self test */\n#include <linux/hardirq.h>\n#include <linux/uaccess.h>\n#include <linux/security.h>\n#include <linux/irq_work.h>\n#include <linux/spinlock.h>\n#include <linux/trace_seq.h>\n#include <linux/sched/clock.h>\n#include <linux/trace_clock.h>\n#include <linux/ring_buffer.h>\n#include <linux/trace_events.h>\n#include <linux/trace_recursion.h>\n\n#define BUF_PAGE_SIZE (PAGE_SIZE - BUF_PAGE_HDR_SIZE)\n#define RB_MISSED_STORED\t(1 << 30)\n#define RB_MISSED_EVENTS\t(1 << 31)\n#define BUF_PAGE_HDR_SIZE offsetof(struct buffer_data_page, data)\n\nstatic inline u64 rb_time_stamp(struct trace_buffer *buffer);\nstatic void rb_reset_cpu(struct ring_buffer_per_cpu *cpu_buffer);\nstatic __always_inline struct;\nstatic inline void rb_end_commit(struct ring_buffer_per_cpu *cpu_buffer);\nstatic noinline struct;\nstatic __always_inline struct;\n\nint ring_buffer_read_page(struct trace_buffer *buffer,\n\t\t\t  void **data_page, size_t len, int cpu, int full)\n{\n\tstruct ring_buffer_per_cpu *cpu_buffer = buffer->buffers[cpu];\n\tstruct ring_buffer_event *event;\n\tstruct buffer_data_page *bpage;\n\tstruct buffer_page *reader;\n\tunsigned long missed_events;\n\tunsigned long flags;\n\tunsigned int commit;\n\tunsigned int read;\n\tu64 save_timestamp;\n\tint ret = -1;\n\n\tif (!cpumask_test_cpu(cpu, buffer->cpumask))\n\t\tgoto out;\n\n\t/*\n\t * If len is not big enough to hold the page header, then\n\t * we can not copy anything.\n\t */\n\tif (len <= BUF_PAGE_HDR_SIZE)\n\t\tgoto out;\n\n\tlen -= BUF_PAGE_HDR_SIZE;\n\n\tif (!data_page)\n\t\tgoto out;\n\n\tbpage = *data_page;\n\tif (!bpage)\n\t\tgoto out;\n\n\traw_spin_lock_irqsave(&cpu_buffer->reader_lock, flags);\n\n\treader = rb_get_reader_page(cpu_buffer);\n\tif (!reader)\n\t\tgoto out_unlock;\n\n\tevent = rb_reader_event(cpu_buffer);\n\n\tread = reader->read;\n\tcommit = rb_page_commit(reader);\n\n\t/* Check if any events were dropped */\n\tmissed_events = cpu_buffer->lost_events;\n\n\t/*\n\t * If this page has been partially read or\n\t * if len is not big enough to read the rest of the page or\n\t * a writer is still on the page, then\n\t * we must copy the data from the page to the buffer.\n\t * Otherwise, we can simply swap the page with the one passed in.\n\t */\n\tif (read || (len < (commit - read)) ||\n\t    cpu_buffer->reader_page == cpu_buffer->commit_page) {\n\t\tstruct buffer_data_page *rpage = cpu_buffer->reader_page->page;\n\t\tunsigned int rpos = read;\n\t\tunsigned int pos = 0;\n\t\tunsigned int size;\n\n\t\tif (full)\n\t\t\tgoto out_unlock;\n\n\t\tif (len > (commit - read))\n\t\t\tlen = (commit - read);\n\n\t\t/* Always keep the time extend and data together */\n\t\tsize = rb_event_ts_length(event);\n\n\t\tif (len < size)\n\t\t\tgoto out_unlock;\n\n\t\t/* save the current timestamp, since the user will need it */\n\t\tsave_timestamp = cpu_buffer->read_stamp;\n\n\t\t/* Need to copy one event at a time */\n\t\tdo {\n\t\t\t/* We need the size of one event, because\n\t\t\t * rb_advance_reader only advances by one event,\n\t\t\t * whereas rb_event_ts_length may include the size of\n\t\t\t * one or two events.\n\t\t\t * We have already ensured there's enough space if this\n\t\t\t * is a time extend. */\n\t\t\tsize = rb_event_length(event);\n\t\t\tmemcpy(bpage->data + pos, rpage->data + rpos, size);\n\n\t\t\tlen -= size;\n\n\t\t\trb_advance_reader(cpu_buffer);\n\t\t\trpos = reader->read;\n\t\t\tpos += size;\n\n\t\t\tif (rpos >= commit)\n\t\t\t\tbreak;\n\n\t\t\tevent = rb_reader_event(cpu_buffer);\n\t\t\t/* Always keep the time extend and data together */\n\t\t\tsize = rb_event_ts_length(event);\n\t\t} while (len >= size);\n\n\t\t/* update bpage */\n\t\tlocal_set(&bpage->commit, pos);\n\t\tbpage->time_stamp = save_timestamp;\n\n\t\t/* we copied everything to the beginning */\n\t\tread = 0;\n\t} else {\n\t\t/* update the entry counter */\n\t\tcpu_buffer->read += rb_page_entries(reader);\n\t\tcpu_buffer->read_bytes += BUF_PAGE_SIZE;\n\n\t\t/* swap the pages */\n\t\trb_init_page(bpage);\n\t\tbpage = reader->page;\n\t\treader->page = *data_page;\n\t\tlocal_set(&reader->write, 0);\n\t\tlocal_set(&reader->entries, 0);\n\t\treader->read = 0;\n\t\t*data_page = bpage;\n\n\t\t/*\n\t\t * Use the real_end for the data size,\n\t\t * This gives us a chance to store the lost events\n\t\t * on the page.\n\t\t */\n\t\tif (reader->real_end)\n\t\t\tlocal_set(&bpage->commit, reader->real_end);\n\t}\n\tret = read;\n\n\tcpu_buffer->lost_events = 0;\n\n\tcommit = local_read(&bpage->commit);\n\t/*\n\t * Set a flag in the commit field if we lost events\n\t */\n\tif (missed_events) {\n\t\t/* If there is room at the end of the page to save the\n\t\t * missed events, then record it there.\n\t\t */\n\t\tif (BUF_PAGE_SIZE - commit >= sizeof(missed_events)) {\n\t\t\tmemcpy(&bpage->data[commit], &missed_events,\n\t\t\t       sizeof(missed_events));\n\t\t\tlocal_add(RB_MISSED_STORED, &bpage->commit);\n\t\t\tcommit += sizeof(missed_events);\n\t\t}\n\t\tlocal_add(RB_MISSED_EVENTS, &bpage->commit);\n\t}\n\n\t/*\n\t * This page may be off to user land. Zero it out here.\n\t */\n\tif (commit < BUF_PAGE_SIZE)\n\t\tmemset(&bpage->data[commit], 0, BUF_PAGE_SIZE - commit);\n\n out_unlock:\n\traw_spin_unlock_irqrestore(&cpu_buffer->reader_lock, flags);\n\n out:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "bpage"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ring_buffer_alloc_read_page",
          "args": [
            "buffer",
            "cpu"
          ],
          "line": 116
        },
        "resolved": true,
        "details": {
          "function_name": "ring_buffer_alloc_read_page",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ring_buffer.c",
          "lines": "5404-5440",
          "snippet": "void *ring_buffer_alloc_read_page(struct trace_buffer *buffer, int cpu)\n{\n\tstruct ring_buffer_per_cpu *cpu_buffer;\n\tstruct buffer_data_page *bpage = NULL;\n\tunsigned long flags;\n\tstruct page *page;\n\n\tif (!cpumask_test_cpu(cpu, buffer->cpumask))\n\t\treturn ERR_PTR(-ENODEV);\n\n\tcpu_buffer = buffer->buffers[cpu];\n\tlocal_irq_save(flags);\n\tarch_spin_lock(&cpu_buffer->lock);\n\n\tif (cpu_buffer->free_page) {\n\t\tbpage = cpu_buffer->free_page;\n\t\tcpu_buffer->free_page = NULL;\n\t}\n\n\tarch_spin_unlock(&cpu_buffer->lock);\n\tlocal_irq_restore(flags);\n\n\tif (bpage)\n\t\tgoto out;\n\n\tpage = alloc_pages_node(cpu_to_node(cpu),\n\t\t\t\tGFP_KERNEL | __GFP_NORETRY, 0);\n\tif (!page)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tbpage = page_address(page);\n\n out:\n\trb_init_page(bpage);\n\n\treturn bpage;\n}",
          "includes": [
            "#include <asm/local64.h>",
            "#include <asm/local.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/list.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/delay.h>",
            "#include <linux/mutex.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>\t/* for self test */",
            "#include <linux/hardirq.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/security.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_recursion.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline u64 rb_time_stamp(struct trace_buffer *buffer);",
            "static void rb_reset_cpu(struct ring_buffer_per_cpu *cpu_buffer);",
            "static __always_inline struct",
            "static inline void rb_end_commit(struct ring_buffer_per_cpu *cpu_buffer);",
            "static noinline struct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/local64.h>\n#include <asm/local.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/mutex.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\t/* for self test */\n#include <linux/hardirq.h>\n#include <linux/uaccess.h>\n#include <linux/security.h>\n#include <linux/irq_work.h>\n#include <linux/spinlock.h>\n#include <linux/trace_seq.h>\n#include <linux/sched/clock.h>\n#include <linux/trace_clock.h>\n#include <linux/ring_buffer.h>\n#include <linux/trace_events.h>\n#include <linux/trace_recursion.h>\n\nstatic inline u64 rb_time_stamp(struct trace_buffer *buffer);\nstatic void rb_reset_cpu(struct ring_buffer_per_cpu *cpu_buffer);\nstatic __always_inline struct;\nstatic inline void rb_end_commit(struct ring_buffer_per_cpu *cpu_buffer);\nstatic noinline struct;\nstatic __always_inline struct;\n\nvoid *ring_buffer_alloc_read_page(struct trace_buffer *buffer, int cpu)\n{\n\tstruct ring_buffer_per_cpu *cpu_buffer;\n\tstruct buffer_data_page *bpage = NULL;\n\tunsigned long flags;\n\tstruct page *page;\n\n\tif (!cpumask_test_cpu(cpu, buffer->cpumask))\n\t\treturn ERR_PTR(-ENODEV);\n\n\tcpu_buffer = buffer->buffers[cpu];\n\tlocal_irq_save(flags);\n\tarch_spin_lock(&cpu_buffer->lock);\n\n\tif (cpu_buffer->free_page) {\n\t\tbpage = cpu_buffer->free_page;\n\t\tcpu_buffer->free_page = NULL;\n\t}\n\n\tarch_spin_unlock(&cpu_buffer->lock);\n\tlocal_irq_restore(flags);\n\n\tif (bpage)\n\t\tgoto out;\n\n\tpage = alloc_pages_node(cpu_to_node(cpu),\n\t\t\t\tGFP_KERNEL | __GFP_NORETRY, 0);\n\tif (!page)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tbpage = page_address(page);\n\n out:\n\trb_init_page(bpage);\n\n\treturn bpage;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/local.h>\n#include <linux/ktime.h>\n#include <linux/module.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/ring_buffer.h>\n\nstatic struct trace_buffer *buffer;\nstatic unsigned long read;\nstatic int test_error;\n\nstatic enum event_status read_page(int cpu)\n{\n\tstruct ring_buffer_event *event;\n\tstruct rb_page *rpage;\n\tunsigned long commit;\n\tvoid *bpage;\n\tint *entry;\n\tint ret;\n\tint inc;\n\tint i;\n\n\tbpage = ring_buffer_alloc_read_page(buffer, cpu);\n\tif (IS_ERR(bpage))\n\t\treturn EVENT_DROPPED;\n\n\tret = ring_buffer_read_page(buffer, &bpage, PAGE_SIZE, cpu, 1);\n\tif (ret >= 0) {\n\t\trpage = bpage;\n\t\t/* The commit may have missed event flags set, clear them */\n\t\tcommit = local_read(&rpage->commit) & 0xfffff;\n\t\tfor (i = 0; i < commit && !test_error ; i += inc) {\n\n\t\t\tif (i >= (PAGE_SIZE - offsetof(struct rb_page, data))) {\n\t\t\t\tTEST_ERROR();\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tinc = -1;\n\t\t\tevent = (void *)&rpage->data[i];\n\t\t\tswitch (event->type_len) {\n\t\t\tcase RINGBUF_TYPE_PADDING:\n\t\t\t\t/* failed writes may be discarded events */\n\t\t\t\tif (!event->time_delta)\n\t\t\t\t\tTEST_ERROR();\n\t\t\t\tinc = event->array[0] + 4;\n\t\t\t\tbreak;\n\t\t\tcase RINGBUF_TYPE_TIME_EXTEND:\n\t\t\t\tinc = 8;\n\t\t\t\tbreak;\n\t\t\tcase 0:\n\t\t\t\tentry = ring_buffer_event_data(event);\n\t\t\t\tif (*entry != cpu) {\n\t\t\t\t\tTEST_ERROR();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tread++;\n\t\t\t\tif (!event->array[0]) {\n\t\t\t\t\tTEST_ERROR();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tinc = event->array[0] + 4;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tentry = ring_buffer_event_data(event);\n\t\t\t\tif (*entry != cpu) {\n\t\t\t\t\tTEST_ERROR();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tread++;\n\t\t\t\tinc = ((event->type_len + 1) * 4);\n\t\t\t}\n\t\t\tif (test_error)\n\t\t\t\tbreak;\n\n\t\t\tif (inc <= 0) {\n\t\t\t\tTEST_ERROR();\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tring_buffer_free_read_page(buffer, cpu, bpage);\n\n\tif (ret < 0)\n\t\treturn EVENT_DROPPED;\n\treturn EVENT_FOUND;\n}"
  },
  {
    "function_name": "read_event",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ring_buffer_benchmark.c",
    "lines": "85-103",
    "snippet": "static enum event_status read_event(int cpu)\n{\n\tstruct ring_buffer_event *event;\n\tint *entry;\n\tu64 ts;\n\n\tevent = ring_buffer_consume(buffer, cpu, &ts, NULL);\n\tif (!event)\n\t\treturn EVENT_DROPPED;\n\n\tentry = ring_buffer_event_data(event);\n\tif (*entry != cpu) {\n\t\tTEST_ERROR();\n\t\treturn EVENT_DROPPED;\n\t}\n\n\tread++;\n\treturn EVENT_FOUND;\n}",
    "includes": [
      "#include <asm/local.h>",
      "#include <linux/ktime.h>",
      "#include <linux/module.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/completion.h>",
      "#include <linux/ring_buffer.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct trace_buffer *buffer;",
      "static unsigned long read;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "TEST_ERROR",
          "args": [],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ring_buffer_event_data",
          "args": [
            "event"
          ],
          "line": 95
        },
        "resolved": true,
        "details": {
          "function_name": "ring_buffer_event_data",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ring_buffer.c",
          "lines": "274-277",
          "snippet": "void *ring_buffer_event_data(struct ring_buffer_event *event)\n{\n\treturn rb_event_data(event);\n}",
          "includes": [
            "#include <asm/local64.h>",
            "#include <asm/local.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/list.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/delay.h>",
            "#include <linux/mutex.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>\t/* for self test */",
            "#include <linux/hardirq.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/security.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_recursion.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct",
            "static noinline struct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/local64.h>\n#include <asm/local.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/mutex.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\t/* for self test */\n#include <linux/hardirq.h>\n#include <linux/uaccess.h>\n#include <linux/security.h>\n#include <linux/irq_work.h>\n#include <linux/spinlock.h>\n#include <linux/trace_seq.h>\n#include <linux/sched/clock.h>\n#include <linux/trace_clock.h>\n#include <linux/ring_buffer.h>\n#include <linux/trace_events.h>\n#include <linux/trace_recursion.h>\n\nstatic __always_inline struct;\nstatic noinline struct;\nstatic __always_inline struct;\n\nvoid *ring_buffer_event_data(struct ring_buffer_event *event)\n{\n\treturn rb_event_data(event);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ring_buffer_consume",
          "args": [
            "buffer",
            "cpu",
            "&ts",
            "NULL"
          ],
          "line": 91
        },
        "resolved": true,
        "details": {
          "function_name": "ring_buffer_consume",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ring_buffer.c",
          "lines": "4887-4923",
          "snippet": "struct ring_buffer_event *\nring_buffer_consume(struct trace_buffer *buffer, int cpu, u64 *ts,\n\t\t    unsigned long *lost_events)\n{\n\tstruct ring_buffer_per_cpu *cpu_buffer;\n\tstruct ring_buffer_event *event = NULL;\n\tunsigned long flags;\n\tbool dolock;\n\n again:\n\t/* might be called in atomic */\n\tpreempt_disable();\n\n\tif (!cpumask_test_cpu(cpu, buffer->cpumask))\n\t\tgoto out;\n\n\tcpu_buffer = buffer->buffers[cpu];\n\tlocal_irq_save(flags);\n\tdolock = rb_reader_lock(cpu_buffer);\n\n\tevent = rb_buffer_peek(cpu_buffer, ts, lost_events);\n\tif (event) {\n\t\tcpu_buffer->lost_events = 0;\n\t\trb_advance_reader(cpu_buffer);\n\t}\n\n\trb_reader_unlock(cpu_buffer, dolock);\n\tlocal_irq_restore(flags);\n\n out:\n\tpreempt_enable();\n\n\tif (event && event->type_len == RINGBUF_TYPE_PADDING)\n\t\tgoto again;\n\n\treturn event;\n}",
          "includes": [
            "#include <asm/local64.h>",
            "#include <asm/local.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/list.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/delay.h>",
            "#include <linux/mutex.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>\t/* for self test */",
            "#include <linux/hardirq.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/security.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_recursion.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline u64 rb_time_stamp(struct trace_buffer *buffer);",
            "static void rb_reset_cpu(struct ring_buffer_per_cpu *cpu_buffer);",
            "static __always_inline struct",
            "static inline void rb_end_commit(struct ring_buffer_per_cpu *cpu_buffer);",
            "static noinline struct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/local64.h>\n#include <asm/local.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/mutex.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\t/* for self test */\n#include <linux/hardirq.h>\n#include <linux/uaccess.h>\n#include <linux/security.h>\n#include <linux/irq_work.h>\n#include <linux/spinlock.h>\n#include <linux/trace_seq.h>\n#include <linux/sched/clock.h>\n#include <linux/trace_clock.h>\n#include <linux/ring_buffer.h>\n#include <linux/trace_events.h>\n#include <linux/trace_recursion.h>\n\nstatic inline u64 rb_time_stamp(struct trace_buffer *buffer);\nstatic void rb_reset_cpu(struct ring_buffer_per_cpu *cpu_buffer);\nstatic __always_inline struct;\nstatic inline void rb_end_commit(struct ring_buffer_per_cpu *cpu_buffer);\nstatic noinline struct;\nstatic __always_inline struct;\n\nstruct ring_buffer_event *\nring_buffer_consume(struct trace_buffer *buffer, int cpu, u64 *ts,\n\t\t    unsigned long *lost_events)\n{\n\tstruct ring_buffer_per_cpu *cpu_buffer;\n\tstruct ring_buffer_event *event = NULL;\n\tunsigned long flags;\n\tbool dolock;\n\n again:\n\t/* might be called in atomic */\n\tpreempt_disable();\n\n\tif (!cpumask_test_cpu(cpu, buffer->cpumask))\n\t\tgoto out;\n\n\tcpu_buffer = buffer->buffers[cpu];\n\tlocal_irq_save(flags);\n\tdolock = rb_reader_lock(cpu_buffer);\n\n\tevent = rb_buffer_peek(cpu_buffer, ts, lost_events);\n\tif (event) {\n\t\tcpu_buffer->lost_events = 0;\n\t\trb_advance_reader(cpu_buffer);\n\t}\n\n\trb_reader_unlock(cpu_buffer, dolock);\n\tlocal_irq_restore(flags);\n\n out:\n\tpreempt_enable();\n\n\tif (event && event->type_len == RINGBUF_TYPE_PADDING)\n\t\tgoto again;\n\n\treturn event;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/local.h>\n#include <linux/ktime.h>\n#include <linux/module.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/ring_buffer.h>\n\nstatic struct trace_buffer *buffer;\nstatic unsigned long read;\n\nstatic enum event_status read_event(int cpu)\n{\n\tstruct ring_buffer_event *event;\n\tint *entry;\n\tu64 ts;\n\n\tevent = ring_buffer_consume(buffer, cpu, &ts, NULL);\n\tif (!event)\n\t\treturn EVENT_DROPPED;\n\n\tentry = ring_buffer_event_data(event);\n\tif (*entry != cpu) {\n\t\tTEST_ERROR();\n\t\treturn EVENT_DROPPED;\n\t}\n\n\tread++;\n\treturn EVENT_FOUND;\n}"
  },
  {
    "function_name": "break_test",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ring_buffer_benchmark.c",
    "lines": "80-83",
    "snippet": "static bool break_test(void)\n{\n\treturn test_error || kthread_should_stop();\n}",
    "includes": [
      "#include <asm/local.h>",
      "#include <linux/ktime.h>",
      "#include <linux/module.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/completion.h>",
      "#include <linux/ring_buffer.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int test_error;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kthread_should_stop",
          "args": [],
          "line": 82
        },
        "resolved": true,
        "details": {
          "function_name": "kthread_should_stop",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
          "lines": "156-159",
          "snippet": "bool kthread_should_stop(void)\n{\n\treturn test_bit(KTHREAD_SHOULD_STOP, &to_kthread(current)->flags);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/numa.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mm.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nbool kthread_should_stop(void)\n{\n\treturn test_bit(KTHREAD_SHOULD_STOP, &to_kthread(current)->flags);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/local.h>\n#include <linux/ktime.h>\n#include <linux/module.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/ring_buffer.h>\n\nstatic int test_error;\n\nstatic bool break_test(void)\n{\n\treturn test_error || kthread_should_stop();\n}"
  }
]